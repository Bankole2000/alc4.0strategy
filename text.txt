ENHANCING THE ANDROID APPLICATION EXPERIENCE - Course Description

Providing a high-quality user experience is critical to the success of any application. Android provides a wide-variety of features and capabilities that empower developers to provide such an experience and this course, Enhancing the Android Application Experience, will serve as your guide to including these features in your applications. First, you'll learn how to include rich, card-based lists using RecyclerView and CardView. After that, you'll explore how to improve user interaction with options menus and app bar actions. Next, you'll cover how to expand your application navigation experience with NavigationDrawer. To assure application reliability, you'll learn how to create automated UI tests that cover RecyclerView, options menus, and NavigationDrawer. Additionally, you'll dive into how to enrich the app appearance and branding through resources, styles, and themes. Finally, you'll discover how to provide user customizable behavior with SharedPreferences and settings screens. By the end of this course, you'll have the necessary skills and knowledge to create Android apps of your own that provide a high-quality engaging user experience.

Designing and Planning Your App
Introduction
Welcome to the Pluralsight course, Enhancing the Android Application Experience. This is our first module, Designing and Planning our App. In this module, we'll quickly provide a high-level view of what we're going to cover throughout this course. My name is Jim Wilson. This is a super exciting course, and I'm so glad you're joining me for it. It's exciting for two reasons. One is that we're going to cover a lot of great Android stuff, but also, the application we've been working on really begins to grow up throughout this course, and we really transition our app from being a little baby duckling to being a beautiful grown-up swan, so we're going to cover a lot of things throughout this course to achieve that. So from an application standpoint, the first thing we'll do throughout this course is improve the appearance of our note list, and we're going to do that using something called a RecyclerView. And then from there, we'll improve the interaction of our note activity, and we'll do that through a combination of using the Options menu, but also using a feature of the Options menu known as app bar actions. We'll then expand the navigation of our application using the navigation drawer, and then we'll revisit automated user interface testing. And that's important, because as we add these new features to our application, there are new testing capabilities we need to understand. We'll then enrich the app appearance overall using resources. We'll cover drawing resources, as well as some other resource types such as string resources. We'll then give our application more consistency and better branding using Android styles and themes. And then we'll cover how our application can include customizable content behavior using the Android preference system.

Improving List Appearance and Note Interaction
If we look at the current state of our application, the most obvious opportunity to make an improvement is in the note list activity. Now remember that our note list activity currently uses a ListView, and then the individual items within that ListView use just kind of a default rendering. So what we'll do in this course is we'll transition the appearance of our note list from what you see here to a much more modern appearance like you see here. Now in order to do that, what we'll do is we'll render the individual items in the list using a CardView, and then we'll also transition from using the ListView to a much more powerful and modern class known as the RecyclerView. Now the note list activity is not the only place that has an obvious opportunity for improvement. Our note activity also has the opportunity for improvement. So the next thing we'll do in the course is we'll actually expand the Options menu on our note activity. So we'll add a Cancel option, so that way if someone creates a new note or makes a change to a new note, and decides they don't want that to be applied, they can cancel that without saving it. In addition, the next option will allow them to move from the current note to the next note in the list without having to go back to the note list activity. Now the Options menu like this gives us a good start, but we can actually do an even better job, so that once we create these options we'll then transition them to be app bar actions, and as app bar actions you can access these options directly from the app bar. So if you want to cancel out of a note, you can simply tap on that icon directly there on the app bar and you'll cancel, or if you want to move to the next note you can tap directly on that icon and move to the next note, without having to expand the Options menu first. So making these changes will get our course off to a good start. In our next clip, we'll start looking at the changes we'll make to expand our application navigation.

Expanding Navigation and More App Testing
The next thing we'll cover in our application is how we can provide a more expansive navigation experience. So what we'll do is we'll take that activity that shows our list of notes, and we'll add to it something called a navigation drawer. In the navigation drawer, we can provide the user with a pull-out experience from the edge of the screen, and display a list of navigation options. So as part of that, what we'll do is we'll add the ability to not only see a list of notes, but also allow the user to select courses and then see the list of course that have notes associated with them. With that, we'll still have the navigation drawer in place so the user can still have that pull-out experience. The navigation drawer would then again show. They can select notes, and then return back to viewing the list of notes. So we're allowing the user to interact with the information in multiple ways, and taking advantage of the navigation drawer to provide them with that navigation experience. At this point in the course, we will have added a number of new features to our application, and of course we want to make sure those features behave correctly, so we want to have an appropriate automated user interface test. So we'll then cover how to test those new features using automated user interface testing. So what we'll do then is take our main activity, and we'll have our test interact with the navigation drawer to open up the navigation drawer, make a selection from the navigation drawer, which then goes ahead and loads our RecyclerView. Our test will then automatically interact with that RecyclerView to make a selection, and then when that selection is made that opens up our note activity, and our test from there will then go ahead and automatically interact with our Options menu and verify that behavior that next through our notes. So this will leverage what we've already learned about automatic UI testing, but then add some additional capabilities to what we already know. Alright, so at this point we've begun to expand the application experience pretty significantly, so in our next clip we'll look at the features of Android we'll cover that provide a richer application experience for the user.

Enriching Appearance and Providing Consistency
Once we have the RecyclerView, the Options menu, and the navigation drawer added to our application, our application is going to have a pretty rich set of features, so the next thing we'll cover are the features of Android that will allow us to enrich the appearance of our application. So one of the first things we'll do is address the navigation drawer, because when we first add the navigation drawer to our application we get default imagery associated with the selections. So if you look, for example, the selections show the notes has a camera next to it, and that doesn't really make sense for our notes, and the image next to courses is appropriate for still pictures, not so much videos, and courses are made up of videos, so we probably want a different image than that there. So then what we'll do is we'll see how to use the Android resource system to add our own images to our project, and then first associate them with the navigation drawer. So now our notes will have a clipboard next to it, and our courses will have a stack of videos next to it. We'll then take those resources and associate them with our lists. So our list of notes will also have that clipboard, and our list of courses will also have that stack of videos with it. And so that way now, our application appears more professional, but also there are visual associations between the selections on the navigation drawer, and the cards showing the data corresponding to that selection. So from there we're going to start styling our application more effectively. So if we take that list of cards showing our notes and that list of cards showing the list of courses that have notes, well both of those cards have course titles on them, but initially those course titles will have different stylings. So what we'll do is use Android styles to make sure that all of our course titles use the same style. In addition to that, we'll use Android themes to introduce a more branded appearance with our application. So notice that our app bar there has that dark gray color that many of the Pluralsight applications have, and notice that our floating action button is styled with an orange that's appropriate for Pluralsight. Also, we'll have used the style to put a plus sign on that floating action button, which is much more appropriate for creating a new note. In addition, by using Android themes, even our note activity will have a more consistent appearance with the other activities. We have that dark action bar at the top, but also notice that the edit text for our note title now has an orange highlight bar and an orange cursor. So when we get to this point in the course, our application is going to have a really nice, professional, branded appearance. So now in our next clip we'll see the user user-customizable behavior features we'll add to the application later in the course.

Personalizing Content and Behavior
Then we'll finish up the course with a look at the Android preferences system, and how it allows us to provide user-customizable content and behavior in our applications. We'll use Android Studio to generate a Settings screen for our application. When we have a Settings screen it's normally divided into sections, so what we'll do is we'll customize one of those sections to allow the user to do things like enter their display name, or select their favorite social network. And one of the things we'll see is that the Android preferences system does a great job of providing a rich user experience. So in the case of something like display name, it handles the details, providing the user with a pop-up window they can type into, but in cases where having the user select from a list is more appropriate, again it handles the details of presenting that pop-up list that the user can select from. Alright, so that's all the great stuff we're going to cover throughout this course, and as you can see it's really exciting because there's a lot of neat things happening with our application. So in our next module, we'll get started by digging into the RecyclerView.

Working with RecyclerView and CardView
Introduction
Welcome to the Working with RecyclerView and CardView module of the Pluralsight course, Enhancing the Android Application Experience. My name is Jim Wilson. Providing a rich user experience is an essential part of most modern applications. Achieving this rich experience using the ListView is difficult to do, so in this module we'll look at a much richer alternative to ListView known as the RecyclerView. So we'll start off by looking at the ListView limitations, we'll then get an overview of the RecyclerView, we'll see what's involved in developing the RecyclerView components, and then we'll take a close look at one of those component types known as RecyclerView LayoutManagers.

RecyclerView Overview
Displaying lists of data is something we very commonly do in mobile applications. Lists make it really easy for users to browse through large amounts of information, and it makes it easy for them to select a particular item of interest without doing any kind of typing or that sort of thing. And for a very long time, the ListView is what we used to display lists of data. But now ListView has some limitations. One simple thing is that it always displays things as a vertical list. If you want some other list display scenario than that, ListView didn't really work so well. It can be challenging to customize. You can certainly provide a layout for an individual row in a ListView relatively easily, but again, beyond that it was kind of hard to customize its appearance or behavior. And it does have performance challenges in some cases, particularly in scenarios where there's a very large data set, or scenarios where an individual item may have complicated loading needs. So when it comes to modern applications, although there are still times when you use the ListView, it doesn't quite have the flexibility we often need, so we need a solution that provides more flexibility. And this is where RecyclerView comes in, because RecyclerView is really designed for modern applications. It's extremely flexible, and it divides the process of displaying the list into distinct phases, and each of these phases offers us a chance to customize the behavior. And the RecyclerView provides efficient display management so it can work well with large data sets and other complicated data loading scenarios. So let's see what it's like to work with RecyclerView from a conceptual level. So we create our RecyclerView, and one of the first things we do is associate a LayoutManager with it. The LayoutManager controls how individual items are arranged within RecyclerView. Then we need an adapter, and that adapter will be connected up to our RecyclerView. And of course, that adapter will be backed by some data, and that data could be, potentially, very long. Now the adapter is also responsible to create individual view instances, so it needs to create a view to create an individual item in the list. So the adapter then takes that and then can place it into RecyclerView. And, again, the arrangement of these individual items is controlled by the LayoutManager. And then the Adapter will create additional view instances to allow the displaying of additional rows in RecyclerView, and this will continue on until there are enough row views created for the user to be able to look through the information in the RecyclerView. But then the Adapter is also responsible to take the data and then load that into items within the Views that are displayed within RecyclerView. And so the process of using the RecyclerView involves managing all these pieces. Now remember that we also mentioned that the RecyclerView has this LayoutManager, and the LayoutManager is responsible for how the individual items are arranged. And this level of customization support allows us to do things like replace the LayoutManager, so that rather than having to want to stack some one above another, maybe we associate a LayoutManager with a RecyclerView that has more of a grid layout management associated with it. And with no other changes, the exact same adapter with the exact same data loading the exact same individual views, could then be used to display information inside a grid layout like that. So you can see the RecyclerView is all about customization and control and meeting this kind of rich, modern application need. So our next clip, let's see what the individual steps involved are in setting up and using a RecyclerView.

Developing the Recycler Components
Working with RecyclerView is a pretty straightforward process, but it does involve a few steps, so let's see what those steps are. Now the first step, of course, is designing the RecyclerView. And doing this is really straightforward, because it's handled much like any other view. In most cases, you're just going to go ahead and put the RecyclerView into some layout resource, like for example, in the case of our application in our note list activity, we'll take the layout resource we used for the content of that activity, and just put the RecyclerView inside of there. Now from there we need to associate a LayoutManager with RecyclerView, and remember that the LayoutManager controls the arrangement of the items, so we select an appropriate LayoutManager for whatever arrangement we want. So next we have to design the item view. What that means is that we want to design the view to control the appearance of an individual item. So what we're really saying here is how we want an individual item inside of the RecyclerView to appear. We'll usually do this with a layout resource, but keep in mind this is a different layout resource than the one we placed the RecyclerView on. This layout resource is a resource specific to the appearance of an individual item in the list. And then from there we need to create and associate an adapter with the RecyclerView. Now this is going to be responsible to construct the individual view instances, manager our data interaction, and associate data items with the item views, so in other words, put each items' data into the appropriate view. Now we'll go through each one of these in more detail, and we'll see actual code for them, and let's start out by looking at the LayoutManager. Now when we're dealing with a LayoutManager, all LayoutManagers derive from the class RecyclerView. LayoutManager, so it's the base class for all LayoutManagers. And you extend this class to create a custom LayoutManager. The good news is that most scenarios you're likely to encounter don't require you to create a custom LayoutManager. Instead, you can use one of the several implementation that Android provides. Now these will handle, as we said, most common scenarios, and both of these support both the concept of both a vertical or a horizontal orientation. So you can scroll things up and down, or just scroll things left and right. One of the most common LayoutManagers we use is the Linear Layout Manager. and as its name implies, items are organized as a linear list, and it's very much like a ListView in that sense. So if we have RecyclerView, and we associate a LinearLayoutManager with it, and let's say that we go ahead and give it a vertical orientation, then each item and its data just appears kind of one underneath the other, and very much, again, like a ListView, but again, with all the power of RecyclerView. Another layout manager we have is the grid layout manager. And, again, as its name implies, items are organized as a grid. And as far as that grid, you can specify the span. And when we say span, what we mean is that, well, if it's a vertical orientation, the span is how many columns do you want it to have. If it was a horizontal orientation, the span would be how many rows do you want it to have. And when you use the GridLayoutManager adjacent items are consistently sized. So let's see what this looks like. Let's say we have a RecyclerView, we've associated a GridLayoutManager with it, and we've given it a vertical orientation, and we set the span to 2, in other words we want it to have 2 columns. So the first item we'll have the view for it, and let's say the data inside there is fairly tall, so we have the data inside that view. Well, when we show the item next to it, the height of that item will be the same, even if the height of the data inside of it doesn't require as much height because they're being consistently sized. So then as we display the next item it's back over into the first column, it's got its data displayed inside of it, and there might be some extra space at the bottom because the one adjacent to it actually requires more height for its data. So you see that the adjacent items across the span are each being consistently sized. And then we have the staggered grid layout manager. And, again, the items are organized as a grid, and again, we can specify the span, but in this case each item is individually sized. So if we have our RecyclerView, and say we go ahead and display a view for the first item, and the data inside that one is fairly tall, but then for our second item we display its view, and because the data inside there doesn't need as much height, it actually has less height for the view overall. Go to the next item, if its data is fairly short, the view also is fairly short. But then for the one next to it if the data is going to be taller, the view itself is taller as well. So it actually staggers it as it lays them out. So you see that gives us a lot of control and a lot of power. So now in our next clip, let's start doing the work to convert our NoteListActivity to use a RecyclerView rather than a ListView.

Making the Change to Using RecyclerView
Here we are in Android Studio, and we're looking at the resource file content_note_list, and this is the layout resource that's responsible for displaying the content of our NoteListActivity. So what we want to do not is convert this from using a ListView to display all the individual nodes, to using RecyclerView. Alright, so the first thing we want to do is get rid of that ListView. So here we are on the List View, and we're just going to right-click and just choose Delete, so that guy is gone. So now we'll replace it with a RecyclerView. Now putting in a RecyclerView is just like putting in any other view. So we're going to go over here to the palette and scroll down to the bottom. So I'll just drag it over and it drops in place there, Now remember that we're inside of a constraint layout, so I need to go ahead and set the positioning, so I'm just going to take it right the edges, drag them up so it's relevant to the parent. So with that we have margins of 8dp all around. Remember that when we work with constraint layout and we drag the view on here, it's setting our layout width and our layout height to have absolute values, and that's not what we want. We want to change these over to zeros so we actually use our constraints to do the sizing. So now once we do that the actual size of the RecyclerView will be based on those margins we've set, so there's no absolute width or height. It'll size based on the size of the screen it's sitting inside of. So we want to make sure and go ahead and give this guy an ID as well. Let's go ahead and use the same ID we were using before, list_notes. Okay, so that takes care of all the work we've had to do inside this resource file. We got rid of the list view, we put the RecyclerView in its place, and then we set all the values appropriately. So let's go over now to the code for our NoteListActivity. So we've got it over here, let's click on that. So now what we want to do here inside the NoteListActivity class is get rid of everything that was related to our ListView. So one thing we don't need anymore is this adapter that we were using for the ListView, because it's a different kind of adapter, so let's go ahead and comment that line out. Because remember that although a RecyclerView uses an adapter, it's going to use its own kind of adapter, so the adapter we were using with the ListView are not helpful to us anymore. Let's go down here to the onResume method and let's comment out the line that uses the adapter there as well. Let's go ahead and scroll down now to the bottom of our NoteListActivity class, and here we have the initializeDisplayContent method, and that was responsible for setting up everything related to our ListView, so let's go ahead and comment all the lines out inside of there. So now everything related to the ListView is gone. We took it out of the layout resource, and we've taken all of the related code out of our NoteListActivity. Let's do the initial few steps to get ready to start working with our RecyclerView. Remember we said that basically RecyclerView is just another view, so what we'll want to do is go ahead and get a reference to the RecyclerView that was loaded by our layout resource. So let's go ahead and declare a local variable here of type RecyclerView, and we'll just call it recyclerNotes, and now we'll just go ahead and do the findViewById for R. id. list_notes, and cast to our RecyclerView. So with that, now we have a reference to our RecyclerView. Remember that our RecyclerView needs a LayoutManager, so what we want to do is go ahead and create an instance of a LayoutManager. And in this case, let's go ahead and stay with that regular list style layout, so we'll use a LinearLayoutManager. So we'll go ahead and create a local variable of type LinearLayoutManager, and let's call it notesLayoutManager. We'll then new up the LinearLayoutManager, and so now we'll go ahead and pass in this reference to the LinearLayoutManager constructor, because that constructor requires a context reference, and we know we can use our activity as that context reference. So now we've got the reference to the RecyclerView, we've created a LinearLayoutManager, all we need to do now is tie them together. So we're going to go to the recyclerNotes, and call set LayoutManager, passing in our notesLayoutManager. And so now with that we've got our RecyclerView, the LayoutManager, and we've associated the LayoutManager. And we know the next thing we need to address is creating a layout for the individual items in the RecyclerView, and that's what we'll talk about in our next clip.

Creating the Card Appearance of the Item View Layout
Here we are in Android Studio. We're looking at the layout resource named content_note_list, which is a layout resource used for our NoteListActivity, and we currently have the RecyclerView selected. Now to make it so we can see just a little bit better here, I'm going to go over to the Project window and just get that guy out of that way just so we have a little bit more visible space here where we're working. So now, we know that have the RecyclerView on this layout resource, but we know that we have to also create another layout resource that will be used to layout the individual items displayed within RecyclerView. Remember we mentioned that there's no implicit relationship between these two layout resources, it's actually the adapter that's going to kind of create the view used to show each item, which we'll use the layout resource we're about to create, and then it shows it within the RecyclerView. Now before we create that layout resource, just look at the screen for a second. You see there in the RecyclerView there's a preview that shows what the contents of the RecyclerView might look like, and that preview is just kind of a generic preview, so it's just going to show some items. Now one of the things that's nice about working with Android Studio is Android Studio provides previews of what things are going to look like. But in the case of RecyclerView, because there's no implicit relationship between the RecyclerView and the layout resource used to show the items, by itself Android Studio can't really know what we're going to layout each individual item like, but it turns out we can actually give Android Studio a hint. You notice the properties for the RecyclerView, there's a property there called listitem. You notice that listitem has a little picture of a wrench next to it, and that tells us that it's a tools property. And what that means is that that property doesn't affect the execution of our program, it's something we use within Android Studio. And what we can actually do is associate the layout resource we're going to create for the individual items with this RecyclerView. And then once we do that, Android Studio will be able to preview what those items will lay out like inside of RecyclerView. Now if we had an existing layout resource, we could go ahead and just select it and put it into this property, but we don't have one yet, so we need to go ahead and create it. So what we'll do is go over to this listitem property, choose these dots here next to it, and then as I mentioned, if we had an existing layout resource we'd select it from this dialog, but since we don't, we're going to go over here to Add new resource and say New layout file. We need to give this file a name, so this will be the layout resource we use for showing each item in the note_list, so we'll call it item_note_list. So now the next thing we need to set is the root element. The root element controls the way things are initially arranged within this layout resource. What we're going to do is instead of using a LinearLayout, we're going to use FrameLayout, and you remember from the first course in this series, a FrameLayout is just a very simple kind of layout that contains one direct child. So we'll change this from LinearLayout to FrameLayout. Okay, so we have a name and a root element, let's go ahead and say OK. So we've got our FrameLayout, and as we mentioned, a FrameLayout is very simple, it has one direct child. Now keep in mind that when you create this layout for use with the RecyclerView, you can lay it out any way that makes sense for the kind of content you're showing. There's no kind of hard rules about the way the individual item layouts need to work. But one of the very common and very popular ways to lay out items within the RecyclerView is to give them a card-based appearance. So what I'm going to do is go over to the palette here, and I'm going to scroll down to the bottom. And you see here near the bottom there's a CardView widget, and CardView actually comes from the support library, and it renders the appearance of a card. So let's go over here and select it. And you notice that as soon as I select it, Android Studio says, hey, you know, you've got a project dependency here you need to address. The idea comes from the support libraries, from the v7 group, and it's the one for CardView. And Android Studio is saying, hey, do you want to go ahead and put this in your build. gradle file, and we do, so let's say OK. So now our build. gradle has the entries that we need for CardView in there. So let's go ahead and drag this guy onto the FrameLayout. Drag it there, it's going to expand the FrameLayout, so we've got our CardView underneath there. So now for our CardView let's go ahead and give it an ID of just card_view. So now you notice that the width of the CardView defaults to match_parent, so just take the full width of its parent, which in this case would be the screen, and the layout_height is wrap_content, so each card will be just as tall as is required for the content within it. But now one of the things about CardViews is they need to have kind of a 3-dimensional appearance to them. So there's some properties we're going to set that are specific to CardView that relate to this concept of a 3-dimensional appearance. And one of those properties is this guy here, cardElevation, in other words, how far do we want to kind of have this sense of floating above the screen. We'll set that to 4dp. The next thing we need to look at is this thing called contentPadding, and what that means is that white space that occurs within the rendering of the card, in other words when when you put content on the card you generally don't want it right against the box that draws to represent the card, you want some padding in there, so let's set this padding to be 16dp. So what that means now is that on the inside edge of the card that's rendered, there'll be a space of 16dp going all the way around. And then the cardCornerRadius is, do we want the corners of the card to be rounded instead of squared, and we do, so we'll set that to be 4dp. And then one last property we need to set is this last one here, cardUseCompatPadding, and this relates to differences in the way that cards are rendered across different versions of Android. Newer versions of Android can render it very directly, older versions can't, so by setting this to true, the CardView widget itself takes care of dealing with differences across versions when it render the card. So we'll go ahead and just set that to true. Now as we look at our CardView, before we move on from this, notice again that our layout_width is match_parent, which is the full width of the screen, wrap_content for the height means just as much space as we need. Remember that our CardView is rendered within a FrameLayout, and so let's go to our FrameLayout for a second, let's choose that guy. And you'll notice when we choose FrameLayout our width is match_parent, but notice also our height is match_parent, and that's not what we want, because if we leave the height as match_parent, that means that the FrameLayout will take up the full height of the screen, so we want to make sure that our layout_height for this guy is also wrap_content. So that way it makes sure that not just the CardView is only the height of the content, but what it's inside of, the FrameLayout, is also only as tall as required for the content. Alright, so with that we're off to a pretty good start. In our next clip, we'll finish up the rest of the work on our viewitem layout.

Completing the Item View Layout
Remember we said that our FrameLayout has that one direct child, which is the CardView, but now the actual content that we want to display is going to be underneath the CardView, so what we're going to need is another layout type within the CardView. And you can use whatever layout type you prefer, but let's go over here to our layouts on the palette, let's just choose that for a second. Let's scroll up to the top, and what we'll do is let's use ConstraintLayout because that's one of the most flexible. So we want to go ahead and drag that onto the CardView, expand our CardView. So now within the ConstraintLayout we're going to place two TextViews. So what I'll do is I'll go back here and just select All, scroll all the way up to the top, and then I'm going to drag two TextViews onto here, one underneath the other, and I'm going to set the constraints so that the course title is at the very top of the ConstraintLayout, and then the note_title is just below that. Alright, so now we have our two TextViews within the ConstraintLayout that's on the CardView. We have our first TextView here called text_course. Notice that its margins are all set to 0. We've got a layout width of 0dp, which means apply constraints. And, of course, the height is wrap_content, in other words, as tall as it needs to be for the content. The one below that, text_title, will be for our note_title that's actually positioned underneath of the course. It's going to get margins of all 0's, width of 0dp for applied constraints, wrap_content for the actual height. So now one last bit we can do here. Now we've got everything in place that we actually need, but you know we want this to kind of start to look sharp now, where we're actually starting to format it and make it look a little prettier. So what we should do here is maybe instead of just taking the default appearance of the text, maybe we can make the appearance of these TextViews a bit more appealing. And it turns out that you notice that on the Properties window there there's a property called textAppearance, and that actually allows us to set a value that will control the appearance of these TextViews. Now we're going to talk more about this concept later in this series when we talk about the idea of themes and styles, but for now the key thing to understand is that using this drop-down we can change the appearance of these TextViews. So I'm going to expand this drop-down. I'm going to scroll down to one called Material. Large. So let's go here to Material. Large, we'll select that, and you'll notice that when I do that, the text acts just a little larger and a little bolder. For the one for our text_title for the note_title, let's make that guy a Material. Medium. So we've got Material. Medium, we'll select that. And it's not quite as large as Material. Large, and it's also kind of a grayish instead of more black. So now we've got this layout pretty good here. Now let's just make sure our ConstraintLayout has a width of match_parent, and we want our height, oh, remember this, we want this guy not to be match_parent, but also this guy should be wrap_content. We want the ConstraintLayout to be just as tall as the content within it, just like we did with the CardView. If we go to CardView, width is match_parent, height is wrap_content; FrameLayout, width is match_parent, height is wrap_content; and now our ConstraintLayout, width is match_parent and height is wrap_content. Okay, so now if all is going well, if I go back to my layout for my note_list and I choose that, you notice that now our RecyclerView is actually rendering example content using the CardView that we've put together. Alright, so each item is now a card with that kind of 3-dimnsional look. So now before we wrap this up let's look at one more thing. Let's go over to our Project window and let's go ahead and expand that. Let's go down to our Gradle files and expand that. And let's go to our apps build. gradle. I'm just going to scroll down a little bit here. And you'll notice now that we have a couple of compile entries that have the red underlines on them, and these actually both relate to the support libraries. The first one here is the appcompat-v7, which is version 24. 2. 1, but look at the last one. That's the support library for cardview. That's the one that Android Studio put in for us automatically. And notice that it's got a different version number than the one for appcompat. The one for appcompat, again, was 24. 2. 1, the one for cardview is 25. 3. 1. Let me scroll up here just a little bit. Alright, so look here at our compileSdkVersion. Notice that our compileSdkVerson is 24. Remember that in the second course in the series when we were talking about Gradle files, we mentioned that when we reference the support libraries, for most support libraries, we want to use the version whose first part of its version number matches our compileSdkVersion. In other words, since we're compiling with the compileSdkVersion 24, we want a support library whose version number also starts with 24. So let's scroll back down to the bottom. So what we want to do here is actually change our CardView support library reference to use the same version number that we're using with our appcompat support library reference, so we're going to change this CardView one from 25. 3. 1 to 24. 2. 1. And once we do that, we need to go ahead and sync our files, so let's go ahead and do that. Alright, so there we go. We've now created the layout resource we're going to use to represent each individual item in the RecyclerView, we've associated it with the RecyclerView within Android Studio so we can actually preview that layout within the RecyclerView when designing inside of Android Studio, and we've got our Gradle build file all set to correctly build using the CardView. Now one thing you'll notice here is that we don't have a RecyclerView entry in the Gradle file, and RecyclerView does come from the support library, and basically that just comes down to the Gradle plug-in within Android Studio. The Gradle plug-in in Android Studio will automatically reference the RecyclerView, because it's so commonly used. But other support library things like our CardView, we actually have to specifically reference on our own.

Summary
To wrap up, here are some of the key things we want to remember from this module. Remember that our RecyclerView supports the ability to provide a rich application experience, and it does that while providing efficient display management. Now a key part of achieving these two goals is the fact that RecyclerView divides list display into phases, and each of those phases are customizable. So when it comes to working with our RecyclerView, we have to design the RecyclerView, we then need to create and associate a LayoutManager, we need to design the view we're going to use for each item, and then we need to create and associate our RecyclerView adapter. And one of the key components involved in working with RecyclerView is our LayoutManager, because remember that our LayoutManager provides our item display organization, and it can be customized. But in most cases we don't actually need to customize the LayoutManager because there are actually multiple LayoutManager implementations provided for us. And remember kind of three key LayoutManager implementations. There's the LinearLayoutManager, which lays out items in a line linearly, and this is very similar to what we might see with a ListView layout. We have our GridLayoutManager, which lays items out as a grid, but as a symmetric grid so that adjacent items take up similar amounts of space. And then there's the StaggeredGridLayoutManager where items are laid out in a grid, but adjacent items are not required to take up similar amount of space. Alright, so this gets our discussion of RecyclerView started. In our next module, we'll continue this discussion of the RecyclerView, and in that module we'll look at using the adapters with RecyclerViews to create the item views and associate data.

Binding Data to RecyclerView
Introduction
Welcome to the Binding Data to RecyclerView module of the Pluralsight course Enhancing the Android Application Experience. My name is Jim Wilson. The RecyclerView uses an efficient presentation model that separates view creation from data display. This model's behavior is provided by the RecyclerView adapter. Understanding the RecyclerView adapter is essential to working effectively with RecyclerView. So in this module, we'll start out by looking at RecyclerView and adapter interaction, we'll then see what's involved with implementing the RecyclerView adapter, we'll look at the view management aspects of the adapter, we'll then look at the data management aspects of the adapter, and then we'll finish up with a discussion of item selection within a RecyclerView.

RecyclerView and Adapter Interaction
So we've seen a RecyclerView and we've seen how to create a layout for an individual view item. What we need to look at now is our RecyclerView adapter, because that's the key piece that ties together the view items, the data for those items, and then feeds them into the RecyclerView. So a RecyclerView adapter has kind of two key jobs. The first one is to create the item views. Now what's interesting, though, is that it works very closely with the RecyclerView in doing this, because it will return these to the RecyclerView, and the RecyclerView is going to actually manage these item views inside of a pool. The other job a RecyclerView has is to populate the item views. and what happens now is the RecyclerView will then pass the view items that is in the pool back into us to put the data into. So let's get a sense of what that looks like kind of visually. So if we have our adapter, and our adapter, of course, it will be backed by some data, the data we want to display, and we know we've got a RecyclerView, and our adapter is going to be associated with that RecyclerView. Now, again, one of the first jobs our adapter has is actually creating these individual view items. So the adapter is going to be responsible to create instances of these view items, it's going to feed them into the RecyclerView, but then the RecyclerView is going to ask us for the data for that item, and it's going to come through the adapter, and the adapter then is going to take the data and then populate that view item, and of course, that process will continue. So as for the next view item, we'll feed it into RecyclerView, it'll ask for the data, we'll populate it, and that carries on. Now obviously this is going to happen often enough to at least create enough view items for what's visible inside the RecyclerView. But think about anytime we display a list, whether it's something like a ListView, or in this case a RecyclerView, the user is likely to scroll through that list. So RecyclerView is going to need to create some additional instances so that the scrolling goes smoothly. So going beyond what's visible inside the RecyclerView, the RecyclerView is going to ask for more view items, we're going to feed it into the RecyclerView, we're going to have to go ahead and populate that with the data, and that's going to carry on until there are enough instances created and populated where the user can scroll through them smoothly. Now I'm showing kind of two extra in this graphic we have on the screen, but it's going to be more than that. The key thing to understand is that the RecyclerView just manages enough view instances to make sure the scrolling goes smoothly. But let's think about how this worked. We kind of did this idea of creating the views as one distinct task, and then populating those views is a completely separate task. Now why would the RecyclerView have us do it that way? Why not just go ahead and have us say, hey, create a view, put the data in it, and give it to me? Why is the RecyclerView managing these as two completely separate tasks? And that's where this idea of the view pools comes in. So the user scrolls through, they go from the first four items in this case, to see the second four items, right, 2 through 5, so they scroll through, and as they scroll through they begin to approach the end of the views that are populated in the pool, so obviously the RecyclerView needs to request some more. Now it could ask that we go ahead and create a brand-new ViewItem and go ahead and populate that brand-new ViewItem, but what's interesting is that this idea of creating views is somewhat expensive, and the reality is that no matter how many data items we have, whether we have 10 items, 100 items, 1, 000 items, 10, 000 items, no matter how much data is there, a limited number of items can be viewed at any point in time. So for the RecyclerView, rather than create individual view items for each data item, again, we manage this pool. So what happens is that as we begin to approach the end of the pool as the user is scrolling through it, rather than have the RecyclerView ask our adapter to create yet another ViewItem, what it actually does is move one of the old items from the pool, and then sets it up to use that ViewItem from the pool as further down the list. So then it asks our adapter to say, hey, go ahead and give me the next bit of data, and popluate that into the ViewItem. So then as the user scrolls down, they approach the end again, we pull one of the old ones we've already gone past out of the pool, we kind of move that down the list, the RecyclerView says, well, give me the data for that guy, I'll go ahead and put it inside there, and this process continues on. Now in this case it's happening as we're scrolling down, but obviously this process will happen no matter which direction we're scrolling in, scrolling up or scrolling down. So the key idea here is that the RecyclerView is managing a limited number of view items based on what's visible in the screen plus some extra, and it uses the adapter to simply recycle those view items to show whatever data the user is scrolling towards, whether that be up or down. Okay, so now in our next clip let's look at the classes and methods involved in creating a RecyclerView adapter.

Implementing RecyclerView Adapter
Now in order for this all to work, we have to provide the view items in a way that RecyclerView can manage them, and we use something we call item view holders. And what happens now is these views are managed using what's called a view holder pattern, and what that means is that we're going to have a reference to the top of a view, because RecyclerView is going to be responsible to render that top-level view and its descendants within the RecyclerView, but also we're going to hold references to the contained views. In other words, we want to have references that will allow us to actually assign values to what's displayed inside that top-level view. And the way we do that with RecyclerView is we use a custom view holder class. The custom view holder class that we're going to write will extend the class RecyclerView. ViewHolder. And we'll have fields inside of it for all the contained views that are used to display the information for each individual view item. So now when it comes to actually implementing our RecyclerView adapter, we're going to extend the class named RecyclerView. Adapter. And the RecyclerView. Adapter class actually accepts a type parameter. The type parameter that we're going to pass into the RecyclerView. Adapter class is going to be our custom view holder class. Now when we declare our view holder class, you can declare it any way you want, but commonly we just go ahead and declare it as a nested class within our adapter implementation. Because the view holder class is not normally used outside of our adapter, it makes sense to declare it as a nested class within our custom adapter implementation. The RecyclerView. Adapter class has some very rich capabilities, and there are a number of methods that we can override to provide our custom behaviors. But at a minimum, there are three methods that we pretty much always override. One is the getItemCount method, and we override that method to return the number of total data items that we want to display. We then have the onCreateViewHolder method, and that creates our item view and actually stores the information from that item view in our custom view holder class. So these are the things that we're creating to go into the RecyclerView's pool of view items. And then there's the onBindViewHolder method, and this one receives a view holder from the RecyclerView, and the position of the data we want to display. It's this method's job to then go ahead and set the data values within that view holder for the data item we want to display. And by overriding these methods, we now have our adapter providing the RecyclerView with what it needs. So in our next clip, let's see what it's like to now actually implement our RecyclerView adapter implementation.

Creating and Constructing the RecyclerView Adapter
Here we are in Android Studio, and we're looking at the layout resource item_note_list that we created earlier, that we'll use to display each item within our RecyclerView. So what we need to do now is create an adapter for our RecyclerView so we can create view instances that use this layout, and have them displayed within that RecyclerView. To get us started, the first thing we need to do is create a class that we'll use as our adapter. So let's go over here, right-click, say new, I'll choose Java Class, and I'll name this guy NoteRecyclerAdapter. I'll go ahead and say OK. So this is the class that we'll use for our RecyclerAdapter. But remember, we also need a class to hold information for the views that will be displayed within RecyclerAdapter. And as we mentioned, we don't have to create this class within our NoteRecyclerAdapter class, but we normally do because the ViewHolder class is normally only used by the RecyclerAdapter. So what we'll do here is go down here and we'll create a new class, and we'll just simple call it ViewHolder, and we'll have it extend the RecyclerView. ViewHolder class. So we have that there. And you notice we've got a little red line underneath our class name. If we click on that, it says there's no default constructor available for the base class RecyclerView. ViewHolder. So let's do an Alt Enter, and what we'll do is choose this Create constructor matching super. So basically, we just added a constructor to our ViewHolder class that accepts a view, and then passes that to our super classes constructor. And we'll see more about what we're doing with that shortly. Okay, so now that we have our ViewHolder class in place that extends RecyclerView. ViewHolder, remember that our Adapter class needs to extend the RecyclerView. Adapter class. So let's go ahead and have this guy extend RecyclerView. Adapter. And remember that RecyclerView. Adapter takes a type argument of the type of ViewHolder class we're going to use, and in our case that's going to be our NoteRecyclerAdapter. ViewHolder class. We'll put that in. So what this is basically saying is that our class NoteRecyclerAdapter, extends the class RecyclerView. Adapter, and we're going to use our class NoteRecyclerAdapter. ViewHolder to hold the information for our individual views. Now, again, we see we've got a red line underneath here. Let's go ahead and click on this guy, and click on the red light bulb, and what we need to do is implement the methods for it, so we'll just simply say implement methods. We'll go ahead and implement all the methods. And this is basically the three methods that we talked about in the slides. GetItemCount will indicate the number of data items we have, onBindViewHolder will be responsible for associating data with our views, and then onCreateViewHolder is responsible to create our ViewHolder instances. So let's start with our onCreateViewHolder method. Remember, as we mentioned, this is the one that's going to create the instances of our ViewHolder, but it's actually got to do more than that. It actually needs to create the views themselves, so we'll see how to do that. Now in order to create these views we're going to need a context, and remember that a context is really just something that we often use for factoring things, right, creating things, and we generally when we're doing UI stuff will just use our activity for that. So let's go ahead and create a field within our NoteRecyclerAdapter class of type Context, and we'll just simply name it mContext. So let's go ahead and make it private and final. So we have our mContext field which is private and final, again, we've got the red underline because it's final and we haven't initialized it, so let's go ahead and click on our light bulb. We'll just say go ahead and add constructor parameter. Now this is interesting, right, because it's saying add constructor parameter but we don't even have a constructor, but let's go ahead and click on it and see what it does. And you see when we clicked on that it went ahead and created a constructor for us that accepts the Context as a parameter, and it assigns it to our field named mContext. So that's off to a good start, so we'll use that. Now in order to create views from the layout resource, we need to use the class that Android provides called LayoutInflater. And when we create a LayoutInflater, we actually create from a context. So what we'll do is create a local variable here of type LayoutInflater, and we'll simply call it LayoutInflater, and what we'll do is use the LayoutInflater class's factory method called from. So we'll simply say equals LayoutInflater. from, and the from method accepts a context, so we'll pass our context in there. So that will go ahead and create a LayoutInflater using the current context, which will be our activity, and we're going to use this LayoutInflater to then inflate those layout resources into actual view hierarchies. Now in order to do that we're going to need this LayoutInflater outside of the constructor. So what we'll do now is go ahead and promote this guy up to a field. So I'm just going to go ahead and right-click, choose Refactor, and I'll choose Extract, and then we'll choose Field. We'll accept all the defaults there and hit Enter. And so now we've got that LayoutInflater assigned to a field named mLayoutInflater. Alright, so we now have our Adapter class and ViewHolder class in place. In our next clip we'll see how to inflate our item view, and populate the required ViewHolder information.

View Management Within a Recycler Adapter
So let's go ahead and scroll down here a little bit. So here we are now in the onCreateViewHolder method. So as I mentioned, what we need to do before we can create the ViewHolder is actually create the view itself. So let's go ahead and create a local variable here of type view, and we'll call it ItemView. And this is going to use our LayoutInflater, so we'll use our mLayoutInflater field, and it has a method on it called Inflate. The inflate method takes a few parameters. The first one is the layout resources we want to inflate, so we'll pass in R. layout. item_note_list. The next thing it needs is the view group that's being inflated within, and you notice that there's a parameter passed to onCreateViewHolder called parent of type ViewGroup, so we'll pass in parent. And the last thing that we have to pass in is False, and false simply indicates that we don't want to have this newly inflated view automatically attached to its parent. Instead, we're going to do this through the adapter and RecyclerView cooperation. So now what this means is that that View itemView points to the root of the view that's created when that layout resource, item_note_list, is inflated. So that'll be our top-level view. It'll contain our CardView within there, and it'll contain our TextViews within there as well. So now our onCreateViewHolder method returns back a ViewHolder, and what we want to do is return back a newly-created instance of our ViewHolder class, so we'll go ahead and return new ViewHolder. And our ViewHolder constructor accepts as a parameter a view, and we're going to pass in our itemView. So now we've not only created a view based on that resource, we've passed it into our ViewHolder, and we're actually returning that back from onCreateViewHolder. And this is what the RecyclerView will use to start creating this pool of views. But there's still some more work we have to do, and we're going to do that down in our ViewHolder class. Let's go ahead and scroll down there. So down here in our ViewHolder class we've got our ViewHolder constructor, and you notice that that view that we received is being passed up to our base class constructor. But now we sill have more work to do than that, because remember that this ViewHolder is supposed to keep references to any of the views that we're going to have to set at runtime for each item. So what we need to do is go ahead and get references to each of the TextViews within our layout. So we'll go down here under our call to to the base class constructor, and one of the things we know we need to do is get a reference to the TextView we're going to use for the course. So we'll declare a variable of type TextView, and we'll simply name it textCourse. And what we're going to do now is have to do a findViewById within the ItemView view. In other words, we're going to find a TextView related to our course within this view we just inflated. And it's going to work very much like what we do when finding references to views within activities. So the first thing we'll do is cast the return type to TextView, and then we're going to say itemView. findViewById, and then we pass in the ID of the view we want to find, which is R. Id. text_course. And now we want to do that same thing for our TextView with the ID text_title. And so now we have references to the TextView for course, and then reference for the TextView for the note_title. Now we don't want these to be local variables, we want to go ahead and promote them up to be fields in our ViewHolder class. So let's go to the first one here, textCourse, I'm going to right-click, do Refactor, choose Extract, and I'm going to say Field. So when I choose this now, notice that it actually says, well, okay, I'm going to choose the field, but what class do you want me to put it into? Because, remember, our ViewHolder class is actually a nested class. So this field could be promoted into our ViewHolder class or up to the NoteRecyclerAdapter. We want to go ahead and put it in our ViewHolder class, so I'll just go ahead and hit Enter and select that one. I'll go ahead and accept the name, so we'll do that. And so now we have a field and text_course, and let's do the same thing here for our text_title as well. So now we've got that all set. Now we have one last little thing we want to do. these two fields are marked as private, and normally we do want fields to be private, but in this case we're going to go ahead and make each one of these public, so let's go ahead and do that first. And the reason we make them public is we want our outer class, NoteRecyclerAdapter, to be able to reference those fields directly. We could certainly put getters on there to get access to them through that, but since this is really kind of a utility class only being used by our NoteRecyclerAdapter anyway, for convenience we often just reference the fields directly. And so now we're off to a good start, where we've got our ViewHolder class here that can receive a view, get references to the TextViews inside of it if I scroll up here a little bit, and we've got our onCreateViewHolder method that inflates our view, passes it into our ViewHolder class, and returns it back so that it can go into the pool that the RecyclerView uses. Alright, so now we've done all the work we need to do to get our ItemView set up. So in our next clip, let's start looking at how we can actually bind the data into those views.

Data Management Within a Recycler Adapter
Now we're ready to start adding data handling to our RecyclerAdapter. Now in order to handle some data we're going to need some data, so remember that this guy's job is to deal with notes. So what I'm going to do is go ahead and create a field here that'll hold the list of notes. So it'll be a List that holds NoteInfos, and we'll call it mNotes. Now we want to go ahead and set this guy in the constructor, so let's go over here to our light bulb, choose that, say Add constructor parameter, and by doing that you'll see it actually adds it as a parameter to our NoteRecyclerAdapter constructor, and assigns it in the body of the constructor for us. Let's just scroll down just a little bit, and remember we said that one of the things we have to do when we're handling our data is indicate how much data there is, and that's where the getItemCount method comes in. So we'll go down here to getItemCount, and what we'll do is return back the size of mNotes. And then the last thing we need to do is pretty straightforward. We need to go ahead and bind the data to our views. So you notice that we've got our method onBindViewHolder, and you'll see it receives two parameters. Now the second parameter, position, indicates the position of the data item we need to display, so that's pretty straightforward. But then the first parameter is ViewHolder, and that's our ViewHolder, the one we created, and our ViewHolder, remember, has references to the TextViews that we used to display our information. So you can kind of see what's happening now. When we implemented onCreateViewHolder, we were inflating the views, storing information about how to get to the TextViews inside of our ViewHolder, we've passed that back into RecyclerView. RecyclerView has now held that into a pool of these ViewHolders, and when it's time to display a certain bit of data, it now calls our onBindViewHolder method, passes in our ViewHolder back to us for a particular view, and then the position of the desired data. So what happens now is that there will be references to several of our ViewHolder instances stored inside the RecyclerView, and the RecyclerView is recycling them and calling into our onBindViewHolder saying, okay, now I want you to display this bit of data in this view, and now I want you to display a different bit of data into this view, and it's just repeating that process. So what we're going to do here inside of onBindViewHolder, the first thing we want to do is get the note that corresponds to the position, so we'll have a local variable of type NoteInfo, we'll call it note, and then we'll simply do an mNotes. get of that position. And then from there we'll go to our holder, our ViewHolder, and we'll get each of the TextViews. So let's start with holder. mTextCourse, we'll call setText, and then we'll take our note, get the course, and then get the title of that course. And that'll now display the title of the course associated with the current note. Now we'll do that same sort of thing for textTitle, so it'll be holder. textTitle, call setText, and we'll pass in note. getTitle. And with that, our RecyclerAdapter is all set. And so, again, our onCreateViewHolder method takes care of inflating the view and storing information about that view in our ViewHolder. OnBindViewHolder takes care of associating data for a desired position within a ViewHolder. And so now the last bit of work we need to do is to associate our NoteRecyclerAdapter with our RecyclerView. So let's go to our NoteListActivity. We're here inside of our NoteListActivity class's initializeDisplayContent method where we set up the RecyclerView, and after we've got our LayoutManager in place there, let's first of all let's go ahead and get the notes that we want to display within the RecyclerView. So we'll declare a local variable called Notes, which is a List of NoteInfo. We'll simply go to our DataManager, call getInstance, and getNotes. Let's scroll down here a little bit. So now that we have the notes, we want to go ahead and create an instance of our NoteRecyclerAdapter. So we'll have a local variable of type NoteRecyclerAdapter named NoteRecyclerAdapter. We'll new up noteRecyclerAdapter. Remember we had to pass in a context, so that'll just be this, our activity, and then our notes. The last step we need to do is associate this adapter with our RecyclerView. So remember the reference to our RecyclerView is called recyclerNotes, we'll call setAdapter and pass in NoteRecyclerAdapter. And with that, we're all set. Just remember that in our previous module we went ahead and got a reference to our RecyclerView that we had added to the layout resource for a NoteListActivity, we associated a LayoutManager with it, and we used the LinearLayoutManager, which gives it a very linear appearance very similar to a ListView in the sense that they're stacked one on top of the other. And now we've got our adapter holding our list of notes, and we've associated that adapter with our RecyclerView. So let's go ahead and run this guy and see what it looks like. So now you can see our NoteListActivity now uses this card style of appearance. I can grab this guy and I can scroll it, and as I scroll down, I see the additional notes that are associated with it. That process of inflating these views and then associating the data with them is all being managed by our NoteRecyclerAdapter. So now in our next clip let's start looking at what's involved, and adding support for handling user selections of one of the items inside of our RecyclerView.

Item Selection Handling
Now that we have our adapter in place and we're displaying information inside of our RecyclerView, we now want to add item selection, so as the user browses through the information displayed in RecyclerView, they can select one of those items. Now if you remember when we did our ListView work and we wanted to have item selection, we actually implemented an interface, the OnItemClickListener interface, and associated that with the ListView. And what that meant was that the ListView was responsible for handling the item selection and informing our application. RecyclerView takes a very different approach, because RecyclerView has no explicit support for item selection. Instead what it does is it actually allows the contained views to each add their own click event handler, and that's really powerful because it allows us to support the concept of a single item being selected, or the idea of a given item having multiple hot spots on it. Think of the idea of tapping on the picture does one thing, tapping on a link does a different thing, that sort of idea. So let's see what this might look like. So let's say we have a RecyclerView, and let's think about our application scenario. So we've got our CardView, and we've got a CardView created for each of the items, and then on one of those CardViews we have a course title, and then we have a note title, and of course, we repeat that for each of the items being displayed. So now in our application we want kind of the ListView-based behavior. We don't really care where on that item the user taps. It doesn't matter whether it's the course title, whether it's the note title, whether it's on the card itself. If they tap anywhere there, we want to select that particular note. So in this scenario what we do is we actually associate a clickListener with our top-level view. So no matter where they tap on that view, or anything contained within the view, there's just one click handling, and we do that for each of the views that we actually inflate. So we're actually associating a separate clickListener with each of the views that we inflate, and when that's selected we'll go ahead and show the note that corresponds to it. But that solution is not appropriate for every application. Some applications may have more involved needs. So think of a scenario where you maybe have like a course title, and if the user tapped on the course title he wanted us to show the course, and if the user tapped on the note title he wanted to show the note, and then maybe you even have this idea of a like. So if the user tapped on the star, in this case, we want to actually record that that user likes this particular item, so of course we'd have to have that star on each of the items. Well, using RecyclerView, rather than being limited to having entire item selections, we could say that, okay, well, when you tap on the course title and want to show the course, we can associate a clickListener with the view showing the course title. We can then associate a different listener with the view showing the note title, so if the user tapped on that we could show the note. And then have a different clickListener on the star, so we could record the like when the user taps on the star. And, of course, we would do that for each of the views as we inflate them. And so ultimately, all the items individual views contained within them would have clickListeners for each of the hot spots for that item. And so this is a real power in RecyclerView, because we can do this kind of multiple hot spots for an item, or we can have a single hot spot for the entire item, and that's what we're going to do in our application. In our application we're going to go with a single hot spot for the entire item. In our next clip, let's see how to implement that.

Implementing Item Selection Handling
So here we are in Android Studio, and we're looking at our NoteRecyclerAdapter. And remember, this is the guy that takes care of managing the data that's displayed within our RecyclerView, and we want to add support for the user making a selection. And what we want to do is that when the user taps on any of the items, and it doesn't matter where it is, it doesn't matter whether it's on a piece of text or on the card itself or whatever, we just want to go ahead and show the note that corresponds to the selected item. Now in order to show a particular note, we're going to need to know the position of that note, remember that's how we did it with the ListView when we created the ListView version of this application earlier. So what we'll need to do then is that for the ViewHolder associated with the views, we'll need to know what position that ViewHolder is currently associated with, because remember that a given ViewHolder will show different data items at different times. So what we'll do is here is inside of our ViewHolder we're going to go ahead and add another field for the current position. This one is not going to be final, because it will have to be set each time the ViewHolder is associated with a different data item. So I'm simply going to have a public int, and I'm going to name it mCurrentPosition. So now of course I'll need to set that mCurrentPosition each time this ViewHolder is associated with a different set of data. So we'll go up here to our onBindViewHolder method and each time we set the values for a given position, we're also going to store the position. So I'll go up here, and I'm going to simply say holder. mCurrentPosition = position. Alright, so now our ViewHolder can hold the CurrentPosition, and we set the CurrentPosition each time that ViewHolder is associated with a different position in our data. Let me just scroll up here for a minute. So now here in our onCreateViewHolder method, remember the way we do this is that we inflate the view, and then we create a new ViewHolder instance and associate the view with that ViewHolder instance. So what we're going to want to do then is that down in our ViewHolder class when it's being constructed, we want to go ahead and associate our click event handlers. Now in our case we need to only handle a single click event. We don't care where these are taps on the item. So we're going to actually associate this click event handler with the top-level view. So let me scroll back down to our ViewHolder class's constructor. So here we are on the constructor, and remember this is called just after we inflate the view. So what we'll do here is go ahead and associate a click event handler with the itemView. So I'm simply going to say itemView. setOnClickListener, and I'll associate the view class's onClickListener interface. So I'm just going to type new, and do Ctrl space, and notice Android Studio is prepared to go ahead and stub out the anonymous class implementation for me, so I'll select that. And, of course, what we want to do now is show our NoteActivity for whatever the current position is. So what we'll do here then is go ahead and set up the intent to show our NoteActivity. So we'll create a new intent named intent, associated with our NoteActivity class. So now when we create that intent, we pass in the Context, which is actually part of our NoteRecyclerAdapter class's fields. and of course the class for the activity. So now the next thing we need to do is set the Extra for the NOTE_POSITION. So we're simply going to say intent. putExtra, pass in the Note Position extra's name, and our mCurrentPosition. So now when the user makes the selection we'll actually put whatever data item position this current view is associated with, and is the value of the extra for this intent. So now from there we can simply take our context called startActivity, and pass in the intent. And that's actually all we need to do. Simply by associating the CurrentPosition with our ViewHolder, adding our clickListener with the top-level view, and then starting our activity just as we always do, we're good to go. Now one last tiny bit of housekeeping. Remember that when a user selects a note, and they view that note, they can actually change the data inside that note, so it's important that our NoteRecyclerAdapter always be showing the most recent information. so in order to do that, we're going to go back to our NoteListActivity, and what we need to do now is have our NoteRecyclerAdapter be updated whenever the data is changed. Now currently our NoteRecyclerAdapter is a local variable, and what we want to do now is go ahead and promote this up to a field. So what I'll do now, I'll use Ctrl+Alt+F to promote it to a field, I'll accept the defaults. So now that mNoteRecyclerAdapter is a field within my NoteListActivity. And I'll scroll up here to the onResume method of our NoteListActivity. And here in the onResume method, I'm simply going to take my mNoteRecyclerAdapter and call notifyDataSetChanged. So that way, any time our NoteListActivity is resumed we'll refresh our data set. Now this is something to note is that in our case our data set is fairly small, so it's okay to simply say, hey, the data set has changed, and let the adapter deal with that change. If you have a very large amount of data, the RecyclerViewAdapter class actually has very fine control available over notifications as well. You can tell a particular item has changed, you can tell a particular item has been inserted, so it has that very fine-grained control if that's what you need, or in a case like ours where there's not a lot of data and we have this very simple approach available to us, just simply saying the data set has changed. Alright, so let's just go ahead and run this guy and see if it all works. So here we are inside the emulator, you can see we have our data displayed there, and of course it all scrolls just fine. let's go ahead and select this one with the Android Programming with Intents, that has a note title of Delegating Intents, so I'll click on that. And it showed my notes, so that did the right thing. So now let's go ahead and just put an XXX in front of the note title, and then let's go back to our NoteListActivity. And you can see when we do that, the displayed data updated correctly, our title now has the XXX in it. And so you can see here when we're working with RecyclerView, this ability to associate the click event handlers with individual views gives us very fine-grained control. We can either do it for the entire item, as we've done here, but we also have the option of having different hot spots within a single item by associating the click event handlers with individual views contained within that top-level view.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that the adapter is the workhorse for RecyclerView. Now when we implement an adapter, we extend the RecyclerView. Adapter class, and the adapter is responsible to create our view instances, and separate from that, it also needs to associate data with those views. But remember that when we're working with RecyclerView, the views are decoupled from the data. The RecyclerView creates just enough views to provide a reasonable scrolling experience. And then those views are stored in a pool, and then reused as the user scrolls through the list of data items. Now to provide this decoupled behavior relies on the concept known as ViewHolders. Now our ViewHolders extend the RecyclerView. ViewHolder class, and they contain a top-level view item, and they hold references to the views contained within that top-level view item. So in this model, binding data is separate from the view creation. So the adapter will bind data to the views, and those are set into existing ViewHolders. So the idea then is that using the adapter, a pool of views is created and as the user goes through it, the adapter is responsible to effectively swap new data into those existing views as the user scrolls through. Now remember, when it comes to selecting items within a RecyclerView, the RecyclerView has no explicit support for item selection, and instead the contained views handle their specific click event. And this is a really powerful concept, because if you have a scenario where you want to have single item selection, in other words, the user selects an entire item no matter where they click on that item, then we can add a click handler to our top-level view. But if we need a richer experience where multiple selections within a given item can occur, well then the contained views can provide their own individual click handlers. In our next module, we'll start digging into the details of Android menu handling, and we'll also see how we can provide tappable images that serve as menu options.

Using Options Menus
Introduction
Welcome to the Using Options Menus module of the Pluralsight course Enhancing the Android Application Experience. My name is Jim Wilson. In the first course in this series, we added a few features to our NoteActivity using the options menu. As we saw then, the options menu provided a quick and easy way to surface activity features to the user. Well, in this module we're going to take a closer look at options menus so more fully understand their capabilities. So we'll start out with taking a look at the options menu basics, we'll then look at how menu items become app bar actions, in other words, icons that appear directly on the app bar. Then we'll see how we can change menu items at runtime.

Options Menus
As we saw with the work we did with menus in our first course in our series, option menus allow us to provide actions for an activity. Those actions appear on the activity's application bar, and by default they appear under the action overflow button. So if we look at an activity, we've got that stack of dots that appear in that one corner, and that's known as our action overflow. So when a user wants to access one of these menu options, they tap on the action overflow, that shows them the options, and then they can select a specific option that they want to choose. When we want to create an options menu, we normally define a menu resource. The root of that resource is a menu, and then what we want to do is define each of our actions as menu items within that menu. Now there are a number of different properties we can associate with menu items, but there are two key properties. One is an ID value for that menu item, and that'll be unique within a particular menu, and that's how we'll identify the menu item within our application code, but we also give the menu item a title, and that's the text that's displayed to the user. Now when you create a menu, there's no automatic association with an activity. What we have to do is that in the activity we override its onCreateOptionsMenu callback method. That method receives a reference to a menu, and then we're responsible to attach our menu items to the menu that's passed in. The way we normally do that is by inflating our menu resource. The activity class provides a method called getMenuInflater, which gives us access to the MenuInflater, and then we'll simply inflate our resource using that returned MenuInflater. And then when it comes to handling menu options, we override the onOptionsItemSelected callback method. That receives a reference to a menu item. What we normally do is simply get the ID of the received menu item, we do that by using the menu item's getItemId method, and then we perform whatever work we want to do based on the ID of the selected menu item. Alright, so now in our next clip, let's start building our understanding of options menu. So we'll quickly review the menu items we created back in the first course in this series, and then we'll add a new feature to our NoteActivity. We'll do that using a menu item that allows the user to next through the list of notes directly from the NoteActivity.

Adding Options Menu Items to Our App
Here we are in Android Studio, and we're currently looking at the menu resource that we've been using with our NoteActivity class. And let's recall that back in the first course in the series we added a Cancel menu option to this to allow the user to cancel out of any changes they've made to a note. We also had added a Send as email option to allow the user to send an email containing the information from a note. Now if we look at the Project window, we'll notice that this resource is named menu_note, and it's located in the res folder for our project, down in the menu folder under res, and that's where all the menu resources are located. So what we want to do now is add another menu option that the user will use to next through the notes in the application, so they can select a particular note from our NoteListActivity, and then once they're looking at a note they can use menu option to next to the following note, and so forth. So what we'll do is go up here to our menu item in the palette, and we'll simply drag that, let's say we'll put it between Cancel and Send as email, So we'll drag it there. Then once we do that we can go over to the Properties window. The first thing we want to do is give it an ID. And let's look at the IDs for the menu items we already have. So we'll look at cancel, that ID was action_cancel, and then Send as email was action_send_mail. And starting the IDs of menu items with action_ is just kind of a general guideline we tend to follow. It's not required, there's nothing special about it, it just makes it very easy to identify an ID associated a menu item. So we'll go up to our new menu item here, and let's give this guy an ID of action_next. So there's our ID. Then we'll give it a title, and we'll give that a title of simply next. And that easily, we've added another menu item to our menu. So let's go over here to our NoteActivity class, and let's look at the methods related to menus. So here's our onCreateOptionsMenu, and as we talked about, it receives a menu as a parameter, and it's our job to attach our menu items to that menu. So you notice that we've got this getMenuInflater call that gets the menu inflater from the activity, we call the inflate method, and then we pass in the ID of our menu resource. Well the ID of our menu resource is R. menu., the name of the resource. so in our case, menu_note. And then having the second parameter menu the same menu we received into onCreateOptionsMenu, attaches the menu items from that resource to the menu that was passed into us. You'll see just below there we have our method onOptionsItemSelected. Let me just scroll that down a little bit so we can see better. And the onOptionsItemSelected method is called when the user selects something from our menu. As you can see, we receive in the menu item, and one of the first things we do is call getItemId against that menu item. That gives us the ID of the menu item that was selected. So you see we have an if statement down here where we check the id values against our menu items. So we have one there for send_mail already, and one for action_cancel, so what we want to do now is go ahead and add another one for the new menu option we added. So what we'll do here is put an else if in place here, and then we'll simply check the id value against R. id. action_next. So that way now when the user selects our menu item for next, this test will test the true, so it's going to put a body here. So now our activity needs to do the appropriate work for that next menu item. So let's call a method called moveNext. So now of course that method doesn't exist yet, so we'll go over here to our light bulb, choose that and say Create method. It goes ahead and stubs out the method for us, asks us to verify we want a void return type, and we do, so I'll hit Tab. So now that easily we've got all the menu stuff itself set up. We added our menu option to the resource, we already had the code in place to associate our menu resource with the menu for this activity, and we've added the code to call our moveNext method whenever the user chooses that next menu item. So now in our next clip we'll go ahead and implement the work that we need to do inside of our moveNext method.

Implementing Next Note Behavior
Here we are back in the Android Studio. We're looking at our NoteActivity class, and we're looking at its moveNext method. And remember that this is the method that gets called when the user selects the menu option Next, and the user expects to move from whatever note they're currently looking at to then be viewing the next note that comes after that. So the question is, how do we do that? Well, what we need to do is do some work that's similar to part of the work that happens when the initial note is displayed. So let me scroll up here in the source code a little bit. So here we are now looking at the readDisplayStateValues method. This is a method that gets called when this activity is first displayed. You notice there's a couple of important things in there. The first thing it does is go to the intent that it received and actually gets the position of the note that's supposed to be displayed and stores that in mNotePosition. A little further down, it then goes ahead and gets the note from the DataManager that corresponds to that position and puts it into the member field mNote. So it would seem that all we need to do is simply increment that NotePosition and then get the correct note, and that will get us pretty far along, and that's true. But now once we have that note, we actually need to display it within the NoteActivity, and that's where a method just above readDisplayStateValues called displayNote comes in. If we've got our field set correctly for mNote, calling displayNote should go ahead and display that note, and in fact it will. So let's scroll back down to our moveNext method. So here we are back at moveNext, so the first thing we'll do is go ahead and increment our mNote position. Once we have that, we'll get the note that corresponds to that position from the DataManager and put it in the mNote. And then finally we get something called displayNote to display the note into the views that are currently displayed by our NoteActivity. Alright, so that actually will take care of advancing us to the next note, and then showing its values within the activity. But that's not all the work we have to do, because we have to remember how our application actually works. If you think back to the work we did earlier in this course series, we had to save any changes the user made to a particular note. And we save those changes in the activity's onPause method, in other words, we saved the changes when the user left that note. Well if we're advancing the user from the note they're looking at to the next note, they're leaving that note, so we want to go ahead and save those changes. So what we want to do here is before we actually advance to the next note, what we want to do is call our saveNote method to save any changes they might have made to the note they were just looking at. So now once we do that, we've saved any changes to that note, we can go ahead and move them to the next note. But now there's one other feature to our application we have to remember, Remember that the user might make changes to the particular note, and then cancel out of those changes, in other words, they don't want those changes to be applied. So if they've made changes, and we want to be able to get back to the original values, we actually have to remember those original note values before we display the note. So what we want to do here now is jut before we call displayNote we want to call the method we wrote earlier called saveOriginalNoteValues. And now we're set. Whenever the user moves to a new note, we save any changes they might have made to the existing note, we advance to the next note and get it, we save the original values for that note, and then we go ahead and display the note out there, and that should give the user the behavior they expect. So let's go ahead and run this guy and verify that it works. Alright, so here we are in the emulator, and we see our application running. Let's go ahead and choose our very first note here. So that's our Android Programming with Intents note, with the title Dynamic intent resolution. Let's go up here to our menu option, and let's choose Next. And now we move to the next note that had the same course, but now its title is Delegating intents. So now we have a couple of things we want to test. We want to make sure that we move to the next note, that any changes we make are applied, so what I'll do is go ahead and put a bunch of X's at the start of this title, and let's go ahead and move to the next note. So now let's take this current note that we're on, let's put a bunch of Z's in front of it, and then we'll go ahead and cancel out. So when I cancel out of here, it means the second note should have the X's I added, but the third note should not have the Z's. Alright, so let's go ahead and choose Cancel. And now if we look at the results, our second note there has the X's in it that we added, which means that it did save when we moved to the next note, and our third note does not have the changes we applied, which means it canceled out correctly. So that shows that we've got our basic next note behavior implemented well. But there is kind of a hassle here. Let's go back into our NoteActivity. And remember, we've provided the ability to move from one note to the next note without having to go back to the NoteListActivity, in other words, we're trying to provide a convenience here to make it easy to mover form one note to another. But it's kind of a hassle the way we've done it, because the way it's currently implemented to get to a new note, we've always got to go to the overflow action and then choose Next. Alright, go to the overflow action, choose next. It would be nice for commonly used features like our Next feature to not have to first go to the overflow action and then choose Next. And in our next clip, we'll talk about how we can do that.

Menu Items as App Bar Actions
As we've seen, menu items are an easy and effective way to add features to an activity, but having our menu items appear always under the action overflow presents some challenges. One of the biggest challenges is that features underneath the action overflow are not immediately discoverable by users. If a user is looking for a particular feature or behavior, they've got to first tap on the action overflow and then look at the menu items that pop up to see if what they're looking for is there. The other issues is that even if a user knows that a menu item is under the action overflow, it takes multiple steps to get to that menu item. They've always got to first tap on action overflow, and then from there then tap on the actual menu item. And that's fine for infrequently used menu item features, but not great if it's something the user uses a lot. And to address that issue, we have app bar actions, and app bar actions allow us to have menu items that are visible on the app bar, and so they're a great way to improve access to commonly used menu items. Now although not required, app bar actions normally have an icon associated with them. So the user, generally speaking, gets to actually choose that menu item by simply tapping on an icon that appears directly on the action bar. Now the way we make a menu item into an app bar action is by using the showAsAction property on that menu item. Now there are a number of possible values for the showAsAction property, but there are three that we most commonly use, and the far and away most common of all is the ifRoom value. What that says is that I want this menu item to appear as an app bar action when space allows. So, basically, you can mark multiple menu items with the showAsAction property value of ifRoom, and only those that fit will appear up on the app bar. The others will remain under the action overflow. And the way it's chosen which ones to actually put on the app bar and which one to keep under the action overflow, is simply in a top-to-bottom order. It just starts at the top, and the first one it finds that has a showAsAction value with ifRoom, if there's room it puts it up there. It then checks the second one that has a showAsAction value with ifRoom, if it fits it's up there. Once it gets to ones that don't fit anymore, they stay down under the action overflow, so basically just what you would expect. Now another possible value is the always value. As its name indicates, it says that this menu item should always appear as an action. And I would say use this one extremely sparingly, because if you mark too many menu items with showAsAction of always, it will show them, and it'll just start crowding them up there, and they'll just start overlapping each other, so you want to really stay away from that. The official guidelines say that no more than two menu items should have a showAsAction value of always. In general, I just kind of stay away from it whenever I can. I just rely on the ifRoom value to fit the ones up on the action bar that will fit, and then I simply rely on that top-to-bottom order, so that the ones that I care about most being on the action bar are put closest to the top of the menu. Now another commonly used value we have is withText, and what this indicates is show text with the action when space allows. And this can be combined with the ifRoom or always values. If you take something like withText and combine it with ifRoom, If there's room for only the icon, then the icon will be placed up on the app bar, but if there's room for the icon and the text, you would then have the icon with the text next to it. Alright, so now in our next clip let's go back to our application and enhance it to enable our Cancel and our Next menu items to appear up on the action bar.

Adding Menu Item Actions to Our App
Here we are in Android Studio, and we're looking at the menu resource we've been using with our NoteActivity class. What we want to do now is look at some of the menu items here and make some of them available as app bar actions. So we want to consider menu items that a user might use frequently, something like the Next menu item, or menu items that we want to make sure the user can easily discover, like the Cancel menu item. So let's go ahead and start with the Next menu item. So I'll click on that guy. And remember that what we use is that showAsAction property to indicate that we have a menu item that we'd like to be available as an app bar action. So what we'll do is go over here to showAsAction, I'll click on this box. You notice that when I do that, it brings up a dialog with the options I have for showAsAction, I'll just use ifRoom, and I'll say OK. And you notice that once I chose ifRoom, it actually went up to be an app bar action, but it's using the actual menu text for that. And that will certainly work, but it doesn't really give us that kind of sharp feel we expect from a modern application. We would much rather use an icon up on the app bar. So what we'll do is go up to the icon field here, I'll choose these little dots next to it, and that brings up a window with a bunch of drawables I can choose. Now a little bit later in the course series we'll talk about how we can add our own resources to drawables and so forth, but for right now we'll go ahead and use the ones that are provided by Android. So I'm going to go over here, I'm going to go ahead and scroll down a little bit, and when I get down here I'm going to choose this one ic_media_next, because that's a good icon to indicate moving to the next item. So we'll go ahead and say OK. And now once we have the icon associated with it, and the showAsAction of ifRoom, now the icon itself shows up on the app bar. So let's go to our Cancel menu item, choose that guy. Let's go ahead and associate an icon with this guy, so we'll choose the icon. So I'll go over here and I'll scroll down. What I'll do in this case is choose the ic_menu_revert, a standard icon we use for undoing an action, and I'll say OK. So now you'll notice that associating the icon didn't put it up in our app bar. What we have to do is make sure we also go to the showAsAction and we'll say ifRoom, and I'll say OK. So now notice here in our Android Studio preview, our cancel menu item is now up on the app bar, but our next isn't anymore. And we're currently previewing using a Nexus 4 as our display. You can see that indicated up there above the Preview window. Now if I wanted to, I could go over there and choose a different device to preview on, but this gives us a good sense of what it's going to look like on a fairly narrow screen, and then we'll see what it looks like on a wider screen when we run it inside of our emulator. So let's go ahead and do that now. Let's go ahead and run this guy and see what it looks like inside the emulator. So here we are running the emulator. Let's just go ahead and choose the first one here. So that opens up our NoteActivity. You'll notice that we've got our app bar actions up there at the top. We've got the revert button to indicate our cancel action, we've got that media next to indicate moving to the next one. But notice that we still have our action overflow there, and if I click on that guy, so we're kind of getting the best of both worlds. We still have all of our memory items available. The ones that don't fit are down under the action overflow; the ones that do fit are actually up here on our app bar. So if I click the next button here, we'll move from one note to the next, to the next, to the next, to the next, that works just fine. If I go over here and click on our Cancel menu item, we cancel out. So you see we have that richer application experience of having actions up on the app bar, just by changing the menu resource itself. We didn't have to change our code at all. Our code still processes it just as a regular menu item. So let's go back here to Android Studio, and let's just check something out. And let's go to our showAsAction, and we currently have Cancel selected, and I'm going to go here and I'm going to add withText, so I'll choose that. So now I have both ifRoom and withText selected, I'll say OK there. I'm going to do the same thing for Next. I'll choose Next, I'll go over here to showAsAction, and I'll mark it with withText. And let's go ahead and run this guy again. So here we are back in the emulator. Let's just go ahead and choose one of the notes. It opens up in the NoteActivity, and notice that in this narrower screen we still only have the icons showing, we don't have any text showing. But let's go ahead and rotate the emulator so we have a wider display. So we'll go over here to the option to rotate it, and you notice now when I put it on a wider display, which in this case is just the smart phone display in landscape mode, I get the text along with the icon. A similar experience would happen if I had a wide-screen tablet. So you see these menu resources give us the opportunity to express the things we'd like to have happen, but then at display time they take advantage of what's possibly there. In a case like this, where both the icon and the text both fit, they are all displayed together, but if I rotate back to a narrow display, we now have just the icons, so it's taken care of all of that stuff for us of showing the best it can based on the current device. So let's go through and let's start nexting through our notes here. So we'll keep nexting on, life is going good, we're going through here, and as we next through, everything seems like it's working well, until we get to our very last note, and now when I click Next, our program crashes. And what's actually happened there is we've actually tried to next passed the ends of the notes, so what we probably should have done there is actually disabled that next menu item once we got o the last note in our list. So in our next clip, we'll take a look at the states that we can change with a menu item, and how we can change them during our program execution.

Changing Menu Items at Runtime
So we've seen how we can create a menu, display the menu in our application, and respond to the users' menu selections. But now what happens if we need to change our menu options, because there are times where your application goes through some state change which requires that we then need to change the menu options, because there are cases where we might need to add or remove menu items, or we may need to enable or disable menu items. And these generally occur when the information that's displayed on the screen has changed, or your application's data state has changed somehow. There are two key methods involved in changing our menu state; one the system calls, one our application calls. The first method is the onPrepareOptionsMenu, and this is one that the system calls, so it's one that we actually override, and it gives us a chance to modify the menu state, because the system will pass us in a reference to the current menu. So we create the menu in the onCreateOptionsMenu, and then we receive a reference to that existing menu in the onPrepareOptionsMenu, and onPrepareOptionsMenu is initially called before the menu is displayed, so it allows you to set up any specific state of the menu just before it's displayed. But there are times where you actually need to change that state after the menu is already displayed, and that's where the invalidateOptionsMenu method comes in. And this is the method that our application calls, and we call it when the menu state might need to change. So what happens is when we call this method the system will schedule a call to onPrepareOptionsMenu. So then what happens is then onPrepareOptionsMenu gets called and gives us another chance to modify the state of our menus. So the best way to understand how this all works is to see it in our code. So in our next clip, we'll update our application to allow us to disable the Next menu item when the user reaches the end of the list of notes.

Disabling the Next Note Menu Item
Here we are in Android Studio, and we're looking at the menu resource we've been using with our NoteActivity class. And if you remember the last time what we were doing is we were using the Next menu item. As the user tapped on it, it worked really well as we nexted from one note to the next one, until we got to the very last note. Then when the user tapped on that Next menu item we actually crashed our program because we tried to next past the end of the list. Well a great solution for this would be to actually disable the Next menu item when we reach the end of the list. That way, even if the user taps on it, it never actually calls into our menu handling code. It also gives the user a great indication that they can't next any further. So let's head over to our NoteActivity class, and what we'll do is just before our moveNext method here I'm going to add our onPrepareOptionsMenu method. So I'll go up to the Code menu option, choose Override Methods, then what I'll do is I'll scroll down to onPrepareOptionsMenu. So here we are, we'll choose onPrepareOptionsMenu and say OK. Alright, so we're there. You'll notice that, again, we receive a reference to the menu, so one of the things that we can do is actually get a reference to a menu item we're interested in. So what I'll do is declare a local variable here called item, of type MenuItem, and then we'll take that menu reference and call findItem against it, and then we can just pass in the ID of the menu item we want. The one we want is R. id. action_next. So that will now give us a reference to the menu item that corresponds to the id. action_next, in other words, our Next menu item. So now what do we want to do? Well, we want to have that menu item enabled as long as we're not at the very last note in the list. So what might be a good idea is to determine what's the index of the very last note in the list. So let's create a local variable here of type int named lastNoteIndex. Then let's go to our DataManager and get our Notes list. And we know that the last valid index of that list is going to be its size minus 1. So all we've done there is accessed the Notes list, get its size, and then subtract 1, and that tells us the last valid index of our Note list. So what we can do now is use this last note index information to determine whether we should enable our next menu item or not. So what we'll do is we'll call item. setEnabled, and setEnabled accepts a true/false value. If we pass in true, it will allow that menu item to be enabled. If we pass in false, that menu item will not be enabled, it will disabled. So what we can do is we can simply check the current NotePosition, and we'll check and see if it's last on the lastNoteIndex. So what'll happen now is that if we're at a note that's not the last note, that test will resolve to true, and the menu item will be enabled, but if we are at the very last note in the list, then that test will be false, and then our menu item will be disabled. Okay, so the onPrepareOptionsMenu has done all the work it needs to. So remember we said that this method, onPrepareOptionsMenu only gets called when the menu is initially displayed. While the user is nexting through the list, they're changing the position that Note list, therefore we have to have a way to get onPrepareOptionsMenu to get called again, and that's where the invalidateOptionsMenu method comes in. So what we'll do here is go down to our moveNext method that we have below here, and what we'll do at the very end of that, if we've done all the work and we've advanced our NotePosition, we'll go ahead and just call invalidateOptionsMenu. So this way, each time the user taps the Next menu item our moveNext method gets called. We're going to advance the mNotePosition, and then we call invalidateOptionsMenu. And then when we do that, the system will call onPrepareOptionsMenu, it will run all that code we have there, and as long as the NotePosition is not the last one, the menu item will be enabled. But once we get to that very last menu item, then the next menu item will be disabled. So let's go ahead and run this guy and verify that it all works. So here we are with the program running in the emulator. Let me just scroll down the list here a little bit. So with that I'm actually looking at the last four items in the list, so let's choose this one here. So now we're on the NoteActivity screen for that particular note. Let's go ahead and try and next through it, so we'll next to the next one, next to the next one, next to get to the very last one, but now we click Next, and nothing ever happens because we disabled that menu item. So now our application is managing that Next menu item correctly. It's enabled as long as we're not at the end of the list, but when we reach the end of the list we disable it.

Summary
To wrap up, here are some of the key things we need to remember from this module. Remember we first started looking at what it takes to create an options menu. An options menu is normally defined as a menu resource. Then that menu is composed of menu items. And although menu items have a number of different properties available, there were two key properties. One was the ID property, which gave it a unique identifier for that menu item, and there was also the title property to provide a menu items display text. Remember, though, that there is no implicit association between an options menu and an activity. We have to explicitly associate the menu with the activity. We do that by overriding the onCreateOptionsMenu method. And what we generally do there is inflate that menu resource, and then attach it to the menu reference that's passed into onCreateOptionsMenu. When it comes to handling the menu item selections, we override the onOptionsItemSelected method, and that receives a reference to a menu item. And generally all we do there is call the getItemId method against that MenuItem reference, that tells us which menu option the user selected, and then we perform the appropriate work for that selection. Now menu items normally appear under the action overflow, but as we saw, we had these things called app bar actions, which allow us to make the menu items visible on the app bar. We control this using the showAsAction property, and although a menu item can become an app bar action with just text, we normally don't do it that way. We normally associate an icon with the menu item so the user can actually see the icon directly on the app bar and just tap on that icon to perform the associated action. And then we had the issue of setting the menu state. Now the way we do that is we override the onPrepareOptionsMenu method that receives a menu reference, and then what we can do is access the individual menu items from that menu reference and set their state however we need to, to enable them or disable them and so forth. Now remember that, by default, onPrepareOptionsMenu is only called once just before the menu is displayed. But there are times where you may need to trigger a change to the menu state. We do that by calling the invalidateOptionsMenu method, and then that will then in turn schedule a call to onPrepareOptionsMenu, where our code can do whatever is necessary to make the menu state reflect the application's current state. Alright, that's it for options menus. In our next module we'll dig into the Android navigation drawer. In the Android navigation drawer, we can include a slide-out panel on our activities to provide users with activity options.

Working with Navigation Drawer
Introduction
Welcome to the Working with Navigation Drawer module of the Pluralsight course, Enhancing the Android Application Experience. My name is Jim Wilson. In this module, we're going to take a look at the navigation drawer, which is one of the key user interface facilities for providing users with the ability to easily navigate through your application's features. We'll start out by taking a look at the navigation drawer's behavior and usage, we'll then look at the classes that are involved in creating a navigation drawer. We'll then focus in on one of the really important classes called the NavigationView, we'll look at the resource types that are associated with the NavigationView, and then finally we'll take a look at NavigationView selection handling.

Navigation Drawer Layout
Navigation drawer is a very powerful user interface concept, and what it's intended to do is provide our application's main navigation options. One of the things that so nice about the navigation drawer is that it's hidden whenever we're not using it, but then when we need it we can simply slide it in from the edge of the screen. Technically speaking, we slide it in from the start edge of the screen, but on most devices that's going to be the left edge of the screen. The only time we would slide it in from the right is if we were dealing with a language like Arabic or Hebrew that's actually written right to left, then in those cases we'd slide it from the right, but for the overwhelming of majority of devices we slide it in from the left edge. And just for convenience as we talk about the navigation drawer, we're just going to talk about sliding it in from the left edge. If the navigation drawer is hidden when we don't need it, how do we find it when we do need it? And there are basically two ways we can do that. One is that we can tap on the app icon, which is simply an icon that appears on the activity's app bar, and that will go ahead and open it up. Or the user can simply swipe from the left edge of the screen and effectively pull the navigation drawer onto the screen. Alright, so what does this look like in our application? Well if we look in our application activity, you notice that we've added an app icon here, and that's just that icon in the left. And the specific app icon we're using here is what's often called the hamburger, or just the stacked bar icon, and that's used to indicate that we have a navigation drawer. So the user can tap on that to open up the navigation drawer, or as we mentioned, the user can simply go to the left edge of the screen and then swipe their finger inward, and that would open the navigation drawer. So once we have that, and the user performs one of those actions, the navigation drawer slides out and overlays our main application content. And then the user can select whatever option they want from the navigation drawer, and then our application will then go on to perform whatever action is appropriate for the user's selection. Alright, so to get a sense of what it's like to work with the navigation drawer, in our next clip we're going to modify our application to now include a navigation drawer.

Creating a Navigation Drawer Activity
Here we are in Android Studio, and we're looking at the layout file for our NoteListActivity. Now as you recall, our NoteListActivity is kind of the initial activity that the user sees in our application. Now currently that activity does not have a navigation drawer, and we could go through and manually add all the pieces in to give it a navigation drawer, but rather than doing that, let's go ahead and create a new activity with Android Studio, and as we'll see, Android Studio will then do all the work for us to get things set up. So what I'll do is I'll go over here to my package, I'll right-click, I'm going to say New, go down to Activity, and then I'll choose the Gallery. Now, as always, you have a bunch of options here, but what I'm going to do is choose the one that says Navigation Drawer Activity. Then we'll say Next. Alright, so let's go ahead and set some of the values for this activity. So let's go ahead and leave the name MainActivity, we can even leave the layout resource name the same, but for our title here let's go ahead and change this over to notekeeper, because this is going to, again, be the initial activity the user comes into when they come into our application. So we have the appropriate title there. And if this is going to be the initial activity that the user comes into, let's go here and just mark it as the Launcher Activity. As we talked about in the first course in this series, marking it as a Launcher Activity puts information into our application manifest, which will then tell the Android system that we want this to be an activity that the user can launch directly into. So we'll go ahead and click the Finish button. Alright, so now when we do that, Android Studio takes us into the layout for the content of this activity. Let's go over to this activity_main resource file here. Alright, this is the top level layout resource file, so I'll double-click on that. And you'll notice that it's kind of looking funny when I do that, and that's not uncommon. I see this has happened pretty frequently in Android studio. It often happens when I add in an activity that has a navigation drawer in it. But you notice here it has render problems under here under Render errors. If we go down here a little bit, you'll notice that I can't scroll down here, but let's go ahead and pull the top up so we can see more of the message. and you'll notice that down here at the bottom where it says try to refresh the layout, let's go ahead and click on refresh and see what happens, and you see that goes ahead and fixes it. So if you run into that situation when you add a new activity to your project, and you kind of get the layout doesn't look right or you see those render errors, just clicking on that refresh link will fix it the overwhelming majority of the time. And you can see there in the preview that our activity will now have a navigation drawer, so that's really good. But, of course, we want our application's initial activity to show that list of notes. So what we need to do is go ahead and add whatever we need to to the layout resource in the class here to show that list of notes. So let's go back to our content_main, which is the layout resource that shows the content of this activity, and what we'll do is we'll go ahead and add RecyclerView to it. So we'll go down here, just scroll down to the bottom. We'll go ahead and take a RecyclerView, and just drop it on here. And then I'll go ahead and anchor this RecyclerView to the top, bottom, left, and right sides of the activity. So now I have everything set up so this RecyclerView is anchored to all four sides of the constraint layout and it's got the layout width and layout height of 0dp, which says use constraints for the width and height. And we need to go ahead and give this guy an id. So let's give it the id of list_items, rather than list_notes, and we'll see why we're doing that shortly. Alright, so we have that id in place there. So we've done everything we need to do for this RecyclerView, but there's one other nice thing we can do for the RecyclerView. If we look at the preview of the RecyclerView, we can see its showing us that default preview of individual items. Well, we can go ahead and associate the actual layout we're going to use with it, our item_note_list layout resource, with that listitem property, and then Android Studio will give us a better preview, so let's do that. Let's go down here to listitem, click on our little dots there. We'll choose our item_note_list, we'll say OK, and now we get that nice preview, the preview that shows what it will look like using the layout resource we're going to use for each individual item. And with that we've set up our MainActivity to actually have the RecyclerView in it, and we have our preview all set up. Now in our next clip we'll do the work we need to do to associate data with this RecyclerView, and make sure that everything works as we expect it to now that we've added the navigation drawer.

Connecting Note Functionality to the New Activity
Here we are back in Android Studio, and as you'll recall, we created a new activity, MainActivity, that contains a navigation drawer, and we've done the layout work necessary for that activity to contain a RecyclerView. So what we want to do now is add the code necessary to display our list of notes inside that RecyclerView. Now you may be thinking that, wow, we did all this work already in NoteListActivity. Am I going to have to do a whole bunch of new work here in this MainActivity? And the answer is well we have to do a little bit of work, but it's not much, and we can actually copy pretty much all of it from NoteListActivity right over into our MainActivity. So let's go over to MainActivity to get started. So I'll go over here to my project window, double-click on MainActivity, So here we are in the MainActivity class, and there's a bit of code in here that Android Studio has added for us to this activity to deal with the navigation drawer, and we'll talk about that code as we go throughout this particular module. But what we want to focus on right now is dealing with displaying the notes in our RecyclerView. So let's go over to our NoteListActivity, so here. And notice that one of the first things we have in our NoteListActivity is this RecyclerAdapter, because remember that much of the work related to RecyclerViews is handled in the adapter. So we're probably going to need this field over in our MainActivity. Let's go ahead and take this line and copy it. We'll go back over to our MainActivity. Here in MainActivity we'll paste that in. Alright, let's head back over to our NoteListActivity. Let's scroll down here towards the bottom. So if we look here now at the code, we have our initializeDisplayContent method, and that took care of just setting up our RecyclerView and associating the adapter with it, and we also have our onResume method that takes care of just notifying the adapter that the data set may have changed whenever we return back to this activity. And then, of course, the initializeDisplayContent method needs to be called from the end of our Create method. So let's go over here and let's copy these two methods, onResume and initializeDisplayContent. We'll head back over to our MainActivity, and then what we'll do is we'll scroll down here just a little bit just below the onCreate method. And when we get down here we'll go ahead and paste in those two methods. Now a couple things we need to do. One is remember that our RecyclerView here in this class is called list_items rather than list_notes, so we'll change that. And then of course we want to make sure we call and initializeDisplayContent. So we'll go up here to our onCreate method and we'll add a call to that method. And that's really all we had to do. We now have the code in place that will take care of configuring our RecyclerView and associating the adapter with it, and then of course notifying the adapter of possible changes to the data whenever we return back to this activity. So we've done most of our work, but we have one last bit of housekeeping to do. Let's go back over here to our project window. I'll click on this guy to expand it, and let's go ahead and get it to expand the tree for us. I want to go up here and go to the locate file guy here, so I'll click on this guy. That expands our tree to show us where the MainActivity is, but what I really want to look at is up here where it says manifest. Let's go ahead and expand that part of the tree, and it shows the file AndroidManifest. So let's go ahead and double-click on that guy. So here we are in the AndroidManifest, and you remember we talked about this in the first course in the series that the AndroidManifest informs Android about things that are important to our application. One of the things it does is identify which of our activities are launcher activities. And let's scroll down here just a little bit, and you can see now we were looking at this section of the Android Manifest for our NoteListActivity and our MainActivity. And you notice that both these activities have this section there called intent-filter. And we talked about this back in the first course, it's this intent-filter that identifies these activities as launcher activities, and we don't want both of these to be launcher activities. If the MainActivity is going to be where we want people to start into our application, that's the only one that needs to be a launcher activity. So what we can do here is up here where it says NoteListActivity and we have that intent-filter, what we can do is highlight this guy, and then just delete it. And so now we only have one launcher activity, which is our MainActivity, and that's what we want. Alright, so we should be good to go here. So let's go ahead and run this guy and see how it all works. So here we are looking at our application running in the emulator. And it should pretty familiar, we can see our list of notes there. Let's just click on one of those and make sure all that code still works. If we select one it works just fine, so that's good to go. But now what about the navigation drawer work, that's the stuff we're really adding into this? Well remember you have the app icon up top there, if I go ahead and click on that let's see what happens. See our navigation drawer slides out, let's go ahead and slide it back. And so I can also go in here and grab the edge and pull it out, and I can even use the back button to put it back, so that stuff's all working. So we've got our navigation drawer added in, we've got our NoteDisplay added in, but there's one last thing we need to add in here. What about our new note button? If I go and click on this guy, I'm getting the default behavior that Android Studio generated, so we still need to add in the new note code from our NoteListActivity and our MainActivity, and that should be really easy to do. So let's head back to Android Studio. So here we are back in Android Studio, and we've got the click handler for our FloatingActionButton, right, and all that guy did was call StartActivity to start our NoteListActivity, so let's go ahead and copy that line. Then we'll head over to MainActivity. And you notice that there's a click handler for its FloatingActionButton, so we'll just take the code that's in there and replace it with our code. You notice that when we paste that code in we now get an error where it says NoteListActivity. this. Remember that our click handler is implemented in an anonymous class, and we need the this pointer from the activity that wraps that anonymous class. So we're now in the MainActivity class, so what we need to do is change where it says NoteListActivity into MainActivity. And now we're passing into this pointer for the activity that we're contained in, and that's what we needed. So let's go ahead and run this guy again and see if everything works as it should now. So here we are back in the Emulator, and now if we click on our new note button we now see our Note activity completely empty so we can create a new note, so everything is working there. So now things are off and rolling for us. We've got our navigation drawer behavior added to our StartupActivity, which is now MainActivity, and all of our functional code-related application behavior, which was showing the list of notes, letting users select one of those notes or create a new note, is now all in this MainActivity class just by copying a few lines of code from our NoteListActivity. Alright, so now in our next clip we'll take a look at the classes and components involved in managing our navigation drawer behavior.

Navigation Drawer Classes
Let's look now at the types involved in providing this navigation drawer behavior. The primary type is DrawerLayout, and this gives us the ability to have a layout that has our primary activity content, as well as the navigation drawer. And when we look at the primary activity content, that can be any view placed underneath the DrawerLayout, but when we use Android studio to generate an activity with a navigation drawer, the primary content for the activity is actually referenced through an include, in other words, the layout resource that we used to layout the activity containing the drawer, then reference another layout resource that will have that main content area of our activity. And then when it comes to the navigation drawer itself, that also can be any old view. The DrawerLayout doesn't really care about the types of the views underneath of it, but in practice the navigation drawer is usually provided through a class call NavigationView, and we'll talk more about the details of NavigationView shortly. Now with just these types involved, the core aspects of the navigation drawer are in place. The user could swipe in from the edge of the screen, see the navigation drawer, swipe to push it back, all those sort of things. What they wouldn't have is the app icon behavior. So there's another type called ActionBarDrawerToggle, and it actually connects up with the DrawerLayout and the activity's app bar. And that takes care of making sure that we have an appropriate app icon there, and it provides the behavior that we need. So that way, if the user taps on that app icon, that will also open up our navigation drawer. So collectivity these types all provide our navigation-drawer-based behavior. So now in our next clip let's see what all this looks like in code.

Navigation Drawer Code and Layout
Here we are in Android Studio, and let's just take a minute and look around the layout files and the source code that's involved in managing our navigation drawer. Now currently we're looking at the activity_main layout file, and that's the one that provides the layout for our MainActivity class. And you'll notice here in the Component Tree, the root of the tree is the drawer_layout, as we talked about, that actually manages the main content area of our activity, and the navigation drawer. And if you look there, the first child of the drawer_layout is an include, and if I hover over that, that includes app_bar_main, and remember that this is our MainActivity area. If I go to that layout resource and we click on that, this is responsible for primarily the app bar at the top, and the fab that we have down there in the bottom right-hand corner. So in general we don't do a whole lot of work inside this particular layout resource, but notice that this one also has an include in it, and this includes content_main. If we go over to content_main, this is where we actually put our RecyclerView in, and this is where we work on the main content presented inside the activity that contains a navigation drawer. And this is very much like the work we did earlier in the series where we had one layout resource that provided the app bar and our fab, and a different one that had the content. So we're doing that same sort of thing here, except we have three. We have one that provides the drawer behavior, one that has the app bar and the fab, and then another one that has the actual content area. so let's back to activity_main and take a look at the navigation drawer part of it. So you notice that the last child down here is a navigation view, and that's what provides our navigation drawer itself. And we'll talk more about the details of that class just a little bit later in this module, but I want to show you one key thing about the NavigationView. I want to switch down here into the Text view, So I'll choose Text, and we'll just scroll down a little bit so we can see the entire area for the NavigationView. So you see we're looking at the entry for the NavigationView, and it's got a number of different values there, but the one I want to point out is the one for layout_gravity. Notice that it has a value of start, and what that's saying is that this navigation drawer opens from the start edge of the screen, which for most languages is the left edge. It is possible to have a non-start, kind of an end from a bottom or a top and so forth, but primarily we do it from the start edge, which again, is usually the left edge, and it's important to understand that as we look at some of the source code later on. So let's go back here into our Design view, and let's go over now to the MainActivity. So here we are in the MainActivity class, and that's the class that we present an activity that has a navigation drawer on it, and let's look first here at the onCreate method. If you look at your onCreate method, you'll notice there's a section there that has a bunch of code for the DrawerLayout. So you'll notice there we do a findViewById to get the DrawerLayout, then underneath there we set up the ActionBarDrawerToggle, and then you notice we actually set that toggle to be a DrawerListener on the DrawerLayout, so that's part of their cooperation together so that the ActionBarDrawerToggle can do the work for the app icon to work with the DrawerLayout, and also just keep things in sync. And you notice we even call toggle. syncState just to make sure the ActionBarDrawerToggle is synchronized with the current state of the navigation drawer. In other words, if the drawer is currently open, ActionBarDrawerToggle needs to know that, and if it's currently closed, it also needs to know that. And you'll notice just down below there we do some work with the NavigationView as well, and we'll talk more about that in detail just a little bit later in this module. And so you can see, having the navigation drawer in place there is pretty simple in terms of just setting it up. There will be some other work we need to do to deal with user selections in the navigation drawer, but this is most of the work for setting it up. There's just one other method I want to show you, so let me scroll down so we can get to that. So here's this method onBackPressed, and this method is called when the user presses the Back button. And you notice here is that one of the first things it does is get a reference to our DrawerLayout and then it checks to see if the drawer is open. And you notice it's passing in this GravityCompat. START, and basically what it's saying here is that, well, in case there's more than one navigation drawer on an activity, which again, in most common uses there aren't', but if there are, it wants to know which one you're looking for, so we want the one that's on the start edge. And so basically what it's saying is that, well, if the drawer is currently open and the user hit the Back button, you can just go ahead and close the drawer and that's all we want to have happen, but if it's not currently open, then we call our super class's onBackPressed. In other words, if it's not currently open, do whatever you would normally do when the Back button is pressed. And so that's just part of managing the interaction with the navigation drawer. And, of course, the cool thing about all of this is that Android Studio wrote all this code for us, so it's got all those kind of basics set up for us. So in our next clip we'll start looking at how we can handle user selections that occur on the navigation drawer.

NavigationView
As we've seen, there are various types that work together to present this experience of the navigation drawer. What we want to focus on now is our NavigationView, because the NavigationView is really kind of the primary point of interaction of actually using the navigation drawer behavior. Now if we look at the navigation drawer, you can see we've got some layout area at the top that presents some information, I'm going to use that for things like the currently logged in user, or things like Gmail actually uses that top area to show which email account you're currently working in, if you have multiple accounts associated with your Gmail. Alright, so it's just a great place to provide information. So the area at the top is actually a layout. So what happens is the NavigationView has a property header layout, and we associate that with a layout resource, and that provides the layout appearance for that top area. But now the primary interaction point on a NavigationView are the selections, and those look very much like a menu, and in fact, there's actually a property menu that we associate with a menu resource to provide the options that show up there. Now if you look at the menu area of our NavigationView, we're actually taking advantage of a menu feature known as groups, and groups allow us to group our menu items. So at the top there you see we actually have a group that is an unlabeled group, and at the bottom we have a group that's labeled as the communicate group, and then each of the options there are simply menu items that have a title and also have an icon associated with them. So since our NavigationView is actually using menus to present the selections to the user, we need to handle those selections, and what we have to do is we have to implement an interface within the NavigationView class, and it's a nested interface, NavigationView. onNavigationItemSelectedListener. Now in spite of that interface's very long name, it's actually a very simple interface. It has one method in it, which is onNavigationItemSelected, and it receives in the menu item that the user selected. So within that method, onNavigationItemSelected, we simply look at the ID of the menu item selected, and we perform whatever operation is necessary. Now as we implement this interface, we of course need to associate it with the NavigationView, and that's very simple for us to do. The NavigationView class has a method, setNavigationItemSelectedListener, that we simply pass in a reference to our interface implementation, and then that takes care of having our code notified when the user makes a selection. Alright, so now in our next clip let's start implementing our actual navigation drawer behavior in our application.

NavigationView Resources
Here we are in Android Studio looking at the layout resource for our MainActivity, and what we want to focus on now is our NavigationView. So we're going to go over here to Component Tree and select the NavigationView. As we talked about, when we work with our NavigationView, we kind of work with it in two separate areas. We have that top area that we can use to provide status information, and that's a layout. And you'll notice that over in the Properties window there's the Property headerLayout, and that points to a layout resource, nav_header_main. And then the NavigationView also has kind of the menu area, the place where we actually make selections from. If we look at the menu property for the NavigationView, that points to a menu resource, activity_main_drawer. So let's take a look at both of those resources. So I'm going to go over here to my project window and expand that, and what we'll do is go down to our layout resources here, and let me just scroll down a little bit so we can see all the resources. And let's go here to our nav_header_main resource, double-click on that, and you can see that is just a regular old layout resource. If we look at the Component Tree, it's got a linear layout, it's got an imageView that's currently showing the Android image, and then we have two textViews on it. One has the Android Studio text in it, and the other has an email address inside of it. And, of course, you can do anything with this that you want, it's just a layout resource. Any status information that's appropriate for your application can be shown in this layout resources. Now let's look at the menu resource, which is our menu resource here, activity_main_drawer, so let's double-click on that. let's go ahead and get this project window out of the way. Now if we look at the Component Tree for this menu, you'll notice there's a little bit more going on here than we had when we were creating just a simple options menu. And what we're doing here is we're taking advantage of a menu's ability to do groupings. And there's actually two different ways we're doing groups inside of this component tree. If you look there at the top, we have one that's explicitly a group, and it's got four options underneath of it, alright, one for nav_camera, nav_gallery, nav_slideshow, and nav_manage. Let me click on that group entry there on the Component Tree. And if we go over to our Properties window here, and let's just widen this guy a little bit, and you'll notice there on our group we have a property, checkableBehavior. What we're doing is we're saying that this a group, and they have a checkable behavior of single. What that means is that only one of them can be checked at a time. So what'll happen is that we're using this first group to kind of indicate distinct modes in our navigation drawer, so that each of those can only kind of be checked at a time, and we'll see how we can kind of take advantage of that in our application in just a moment. If we go back to the Component Tree, you notice that we have a another kind of grouping there that's marked Communicate. And you notice if I select that guy, that's just a menu item. If you look at the Properties window, it's just an item. And what we're doing is we're taking that menu item that we're labeling as Communicate, and we're creating a grouping within it by having a menu underneath of it that then has additional menu items underneath there, which is our nav_share and nav_send. And so what we're doing there is we're indicating these as actions that can be performed. So the group above is used to kind of indicate a current display mode. The grouping below that we're actually doing is a menu item with a menu inside of it, our distinct actions, for things like performing a sharing action or a send action. Well let's focus on that group area at the top and see how we can use that in our application. Now currently our application only shows notes, but remember that notes have a course associated with them, so it would be really cool if our application could either show a list of all the notes, or a list of courses, and then you could click on that course and see the notes just for that course. So that's a great use for our navigation drawer here. So what we can do here is take the group that's in our Component Tree for the menu, and cut that down to two options, one for notes, and one for courses. So let's go ahead and get rid of these bottom two entries here, the one for the slideshow, so I'll select that and just hit Delete, and I'll do that same here for the nav_manage. And then what we'll do is change our first one here, nav_camera, let's make the id for that nav_notes, and then we'll make the title Notes. So when the user selects this option, we'll show all the notes we have available. Let's go back over here to our menu, choose a second one, and let's make this one the id nav_courses, and then we'll make its title Courses. So when the user selects this option, they'll just see the list of courses that have notes, and they won't be able to see the notes for that particular course by selecting a course. So now our application is being set up to have kind of these two distinct behaviors, the ability to show all the notes or the courses, and we can then see the notes for that course behind it. Alright, so that takes care of all of our work we had to do with our resources. In our next clip, we'll get into the MainActivity class and add the code necessary to handle these NavigationView selections.

Handling NavigationView Options
So now our application is being set up to have kind of these two distinct behaviors, the ability to show all the notes, or the courses, and then we can then see the notes for that course behind it. So now of course we need to implement this behavior. So we'll do that in our MainActivity. So let's head over here to our MainActivity class, and you see here in my MainActivity class it implements that NavigationView. OnNavigationItemSelectedListener. Now let's scroll down here a little bit. And then you see here in our onCreate method we have a code that actually gets a reference to our NavigationView, and then we call setNavigationItemSelectedListener, and pass in this, pass in the activity, so now our activity will be notified when the user makes a selection from our NavigationView. So let's scroll down. So here we are in OnNavigationItemSelected, and this is the method that gets called when the user makes a selection from our NavigationView. And, of course, we'll pass this in the menu item, we get the id for that menu item, and then our code then does the work associated with the menu item. So let's go ahead and do some simple updates to this to kind of get us started. So the first thing we'll do is we'll get rid of these two options, nav_slideshow and nav_manage because we don't have those anymore. So now with those two gone we need to have handlers for our notes and and our courses. So we'll take the first one here, nav_camera, and let's make that nav_notes, and then we'll change nav_gallery to nav_courses. So now with all of our if checks in place, let's just go ahead and put a simple helper method in here just to let us verify that we've got a lot of our handling in place. So I'm going to put a method in place, handleSelection, and I'm just going to pass in the string value to indicate the selection, so I'll pass in the string Notes. Now, of course, we don't have this method yet, so let's go ahead and let Android Studio create it for us. So we'll just click on the light bulb, say create method, we'll accept a return type of void. The parameter type is String. Let's change the parameter name to message. And then what we'll do here is just use a Snackbar to display that message. Right, remember snack bar is just text that kind of floats up from the bottom. So that's easy enough to do. Now one thing we need whenever we use a Snackbar is a view from the current activity. So what I'll do is I'll just get a reference to our RecyclerView, but I'll just get it as the type View. And the reason we need this view is it's just a detail of the way the Snackbar works. We have to pass it a view in order for it to display information on our activity. So we'll go ahead and set up our Snackbar to display the passed-in text. So now when we call this handleSelection method, whatever text we've passed in as the message will just slide up from the bottom of the screen. It's a great way to verify that we've got everything hooked up correctly. So let's scroll up here a little bit. So we're back here in our onNavigationItemSelected method, and let's go ahead and call handleSelection for each of the other three options as well. So that now gives us all of our code in place for our NavigationView. Basically, we've just updated the menu resource associated with NavigationView, associated the appropriate interface with our activity, and then provided handling in the onNavigationItemSelected method. So let's go ahead and run this guy just to make sure all this works. Here we are with our application up and running in the emulator. Let's go over here to our app icon and let's tap on that. We'll see our NavigationView open up, we see we have our Notes option there, our Courses option there, and then the Share and the Send. So let's go ahead and choose Notes. When I do that, I see the Snackbar pops up with the text notes in it. Let's go back to our app icon, let's choose Courses, Snackbar with courses in it, go back, choose our Share option. We see text for our Share option. And just to round it out, let's go up here and choose our Send option and our Snackbar for the Send option as well. So we've now got our NavigationView all set up. And fundamentally, this takes care of everything we need to do to get our DrawerLayout into place. But we really haven't provided any improved application experience, so in our next clip what we'll do now is take the work we've done with the navigation drawer and combine that with the work we've done with our RecyclerView, and start providing a richer application experience for our user by giving them the ability to switch between that list of notes and that list of courses.

Implementing Notes Navigation Option
Here we are in Android Studio, and we're looking at our MainActivity class. And remember that what we want to do now is take the navigation drawer that we've just added to the application, and use it in conjunction with our RecyclerView to allow the user to either display the list of notes, or the list of courses that have notes, and we're going to do that using a single RecyclerView instance. So what we need to do now is change the application so that we can either display notes in that RecyclerView or the list of courses in that RecyclerView. So our focus in this clip is going to be taking the code that displays notes in that RecyclerView, and setting it up so that we can make that one of two options, the notes or the courses. So, to get us started, I'm going to scroll down to our initializeDisplayContent method. So here we are in our initializeDisplayContent method, and the way it's currently set up is that it always displays notes. So let's start changing this code so that we can easily switch between either displaying notes or displaying courses. So to do that, first of all we're going to take a few of the variables here that are local, and promote those up to fields. So let's jump here to our RecyclerNotes, and I'm going to press Ctrl+Alt+F, which allows me to go ahead and promote up to a field, but instead of being called mRecyclerNotes, I'm going to change its name to mRecyclerItems, because it can either be notes or courses, and we'll just generically refer to that as items. So we have that there, I'll go ahead and hit Enter. And let's take our notesLayoutManager here, and let's go ahead and promote that up to a field as well. So, again, I'll press Ctrl+Alt+F, we'll accept the default name so I'll hit Enter. So both those guys are fields now, and we'll see why we did that a little bit later. So currently this initializeDisplayContent method is focused entirely on just displaying notes in the RecyclerView. What we want to do now is take the part of the code that's specific to displaying notes in RecyclerView, and we'll move that into its own method and we'll call that method displayNotes. Now if you look at the code here, at the bottom we set up the adapter with the notes, and then we associate it with our RecyclerView. Let's go ahead and take the line here where we associate it with the RecyclerView, and let's go ahead and extract that out into its own method. Let's go ahead and right-click on it, choose Refactor, I'll choose Extract, and then I'll choose Method, and I'll simply name it displayNotes. I'll go ahead and say OK, so that goes ahead and moves that line of associating the adapter with the RecyclerView into this method, displayNotes. But I'm also going to do one other thing. I'm going to go up here where we set the LayoutManager, and I'm going to go ahead and move that down there as well. So I'll highlight that and cut it, and I'll go down here and paste it in. So with that in our InitializeDisplayContent Method, we go ahead and get references to our RecyclerView, we go ahead and create the LayoutManager we're using with our notes, we can go ahead and create the Adapter we're using with our notes, but we then associate that LayoutManager and the Adapter with the RecyclerView down in our displayNotes method. So now that will, of course, display the notes when the application first comes up, but we also want to go ahead and associate it with the user selection from the navigation drawer. So let's go ahead and scroll down in our code, and here we are in the onNavigationItemSelected method, and remember this is the one method that gets called when the user makes a selection from the options in our navigation drawer. And what we want to do here is look at the part of the if for the Notes selection, and let's change it from our call to our simple helper method handleSelection to our displayNotes method. Alright, so we now have the code in place that displays the notes when we first start up, and allows us to select the selection of displaying notes. Now that's not a new behavior of any sort, but let's just go ahead and run the application and make sure we haven't broken anything. So here we are in the Emulator, and we can see our list of notes. So the good news is we haven't broken anything. But I want to take a look at a user interface issue here for second. I'm going to go over to the app icon and I'll tap on that, and that of course opens up my navigation drawer, and then I want to take a look at these two entries, Notes and Courses. And you remember that we mentioned these guys were in a group, and the group allowed one of them to be checked at a time. In other words, they support the idea of showing the user the current selection. And, again, in the case of our application, that's because we're going to have distinct modes, one mode of displaying notes, and one mode of displaying courses. Well if you look at that right now, there's no feedback as to the current mode. But let me go in her and select Notes. Now, of course, what gets displayed doesn't change, because we're still displaying the notes, but let me hit the app icon again. And you can see now that Notes option is highlighted, it's, in effect, checked, so it's giving the user feedback that we're currently displaying the information that corresponds with the Notes selection. So what we want to do is make sure that that happens when our application first starts up as well. And what we really want to do is just make sure that anytime we're displaying the notes that we actually have that current selection selected in the navigation drawer. So let's head back into Android Studio and fix that up. So here we are in Android Studio, and we're currently looking at the displayNotes method. Again, this is the method that gets called whenever we're displaying the notes to the user within that RecyclerView. And so let's go ahead and add the code now to set the Notes option as checked in that navigation drawer. So what I'll do first of all here is I'll declare a local variable of type NavigationView named navigationView, and then I'll get a reference to our NavigationView. So now NavigationView has a reference to the NavigationView itself, but remember that the menu is actually contained within the NavigationView, so we actually have to get a reference to the menu within that NavigationView. So let's create a local variable here of type Menu called menu, and then what we'll do is call the navigationView. getMenu method. And so now that local variable named menu has a reference to the menu within the NavigationView. So what we can do now is use that menu to go out and find the menu item we want to select. So I'm going to call menu. findItem, and I'm going to pass in the id of the menu item we want to select, and that's our R. id. nav_notes, and that's simply the id that we gave that menu selection when we were setting up the menu for the navigation drawer. And then we'll simply call setChecked, and pass in true. And so now with that, we've got a reference to the NavigationView, we've got a reference to the menu inside the NavigationView, we then got a reference to our particular menu item, the one for notes, and then said set it as checked, in other words, display it as the currently selected option. Let's go ahead and run our application again now and see if that fixed things up for us. So here we are again in the emulator, we're of course showing our notes. Let's go ahead and tap the app icon, and now you can see that when I tap the app icon Notes is currently selected even though there was no user action to select it. So, again, we're giving the user feedback that you're currently viewing information associated with that Notes selection. Alright, so now we've got our Notes work compartmentalized and selectable, what we want to do in the next clip is start making it so that we can display our courses that have notes inside this same RecyclerView. In order to that, we're going to need to create an adapter that can display courses, and that's what we'll do in our next clip.

Adding an Adapter for Courses
Here we are again in Android Studio, and what we want to do now is do the work necessary to be able to display information for courses with notes in our RecyclerView on our MainActivity. In order to do that, we'll need a RecyclerAdapter, and in order to use that RecyclerAdapter, we're also going to need a layout for the individual items that we want to display in the RecyclerView. So let's go over here under our layouts, and let's just look at the layout resource we used for the course notes. So let's double-click on our item_note_list, and if you look at that guy it's got two fields in it, one for the course name, and one for the note title, and they're both left-justified. Now this is probably a good place for us to start for displaying the list of courses that have notes, so what we do is let's go ahead and copy this guy, then when we copy we'll go ahead and paste it back in here. So I'm going to on layout, right-click, choose Paste, and when I do that Android Studio prompts me for, well, what name do you want this copy to have, and I want the name to be item_course_list. So we have that, so we'll say OK. So that now creates an exact copy of that resource file, but named item_course_list. It's currently showing us the xml view, let's go down here and put it back in Design view, and let's go ahead and make some changes to this. Well, one thing is that we know that we're only going to display a list of courses, so let's go up here to our entry for the note title, and let's just right-click on that guy and say Delete, because we don't need him. So now let's get our TextView for the course, and let's just make a couple of small changes to it. Let's go over here to the Properties window and just scroll down a little bit. So we'll do two things. Rather than using a text appearance of Material. Large, let's change this to Material. Medium. So I'll select that, choose Medium, it makes it a little bit smaller. Now let's go in here and center it as well, so that way the text will actually be centered when we display within a card. Alright, so now we have a layout that can show the title of the courses by itself, so that's off to a good start. The next thing we need is the actual adapter. Now we could, of course, create another adapter entirely from scratch, but the adapter we need to display the list of courses is going to be very similar to the adapter we currently have that displays our list of notes. So let's go back over here to the project window, and we'll go ahead and scroll up a bit, and what I'm going to do is go to our NoteRecyclerAdapter, right-click and copy that guy. I'm going to paste it on the package name here. So it says, okay, you're copying that class, what do you want the new class to be called, and we'll call it CourseRecyclerAdapter. So that'll be our CourseRecyclerAdapter, I'll click OK. So let me just scroll this guy up a little bit. So as you can see now it's a class named CourseRecyclerAdapter, it extends RecyclerView. Adapter, and it's typed on the ViewHolder class that's a nested class inside of our CourseRecyclerAdapter class. Now a couple things we have to do. One, we have a field here named mNotes that holds a list of NoteInfos. Let's go ahead and change that field name from mNotes to mCourses. So I'll right-click, choose Refactor, choose Rename, and I'll name it mCourses. So we have that there, I'll go ahead and hit Enter. And you notice that when I did that, Android Studio noticed that I actually had a case where I'm using a parameter that's also associated with that field, right now it would be in our constructor, and so it's saying, hey, do you want to go ahead and rename that as well. So where it says there's a parameter named Notes, do you want me to change its name to correspond to the field name, and I'll say, well, yes I do. So I'll say Select All, and OK. And you'll notice now in the constructor, that second parameter's name is now courses, instead of it being notes as it was before. Now let's go ahead and change the type of this mCourses field as well. Instead of being a list of NoteInfo, we want it to be a list of CourseInfo. So that takes care of the field. Let's go ahead and change it in our parameter for our constructor as well. Let's scroll down here a little bit. So we're here in our onBindViewHolder method, and that's the one responsible for setting the values corresponding to a certain position in our data, and you notice that when it's doing the get against mCourses it's trying to put it into a NoteInfo, and we don't want that, we want to put it into a CourseInfo. So let's go ahead and change this site from NoteInfo to CourseInfo, and let's change the variable name from Note to Course. So a couple more things. Notice where we call setText against the holder. mTextCourse we want to actually just take that current course and get the title from that. So we'll change this line of code here to simply say course. getTitle. So now that will display the title of the course at whatever position is currently being bound. Now we only display a course title, there's no note title or equivalent here, so let's go ahead and get rid of this line. So that takes care of getting a list of courses rather than a list of notes, and assigning values from a course rather than a note. Let's just scroll up here a little bit. Remember that onCreateViewHolder is responsible for creating the view instance associated with each item we're displaying. Well, currently we have item_note_list, and now we want that to be item_course_list, so we'll change that. So that will now create instances of that new layout we just created, but remember that that layout is going to have a ViewHolder associated with it, so let's scroll down to the ViewHolder class that's nested inside of our CourseRecyclerAdapter class. So a couple of things we need to do here. Let's go ahead and get rid of the field associated with the note title because we're only showing the courseTitle now. We'll go ahead and get rid of the line that assigns it. So that takes care of all of that work. Okay, now if we were to build this all the way out, what we would do when the user selects a course in our MainActivity's RecyclerView, we would then show the NoteListActivity containing only the notes associated with that course. But for expediency, what we're doing now instead is we'll simply just show a Snackbar that shows the name of the selected course so we can verify that all this is working. So we'll go down here to my setOnClickListener associated with our top-level view, get rid of all this code here associated with showing an activity. Then what I'll do is go ahead and start creating a Snackbar. We'll then go to the list of course and just get the course to current position and display its title. Then we'll display this for a length of Snackbar. LENGTH_LONG, and we'll call the show method. And with that, we've got our adapter all set for our courses. We created a layout resource specific to the way we wanted to display courses, and we've got an adapter constructed that can actually create instances of that layout and bind data from our list of courses into that layout. So in our next clip, we'll complete this process by associating this adapter with the RecyclerView that's in our MainActivity.

Implementing Courses Navigation Option
Here we are back in Android Studio, and we're currently looking at the the MainActivity class. What we want to do now is take that RecyclerAdapter we created in the last clip, and add the code to MainActivity, which will then display the list of courses when the user selects Courses from our navigation drawer. So we'll start working in our initializeDisplayContent method, and we currently have code there that sets up the RecyclerAdapter for the notes. So what we'll do is just after that let's go ahead and add some code that sets up the RecyclerAdapter for our courses. So the first thing we'll do is go out to the DataManager, get a list of the courses and assign them to a local variable. And let's go ahead and create a local variable of type CourseRecyclerAdapter, and then we'll go ahead and new it up, passing in this, and that list of courses. So that takes care of getting our CourseRecyclerAdapter created. Let's go over here and promote this up to a class field, so Ctrl+Alt+F, accept the default name, so that guy's all set. Now we've got our adapter in place, let's go one step further. Remember that when we deal with a RecyclerView, we can change adapters to change the data, but we can also have layout managers to affect the way it's organized. So why don't we use a different layout manager to display the list of courses. So rather than using a LinearLayoutManager for the courses, let's use a GridLayoutManager. So what I'll do is I'll go up top here, just below where we create the LinearLayoutManager, let's declare a local variable of type GridLayoutManager, and we'll call it CoursesLayoutManager. Let's go ahead and new it up, we'll pass in this, and then we have to pass in the span. And by default, a good LayoutManager is vertical, so the span in this case is columns, and let's just say 2. So we'll use that to display our courses using a two-column layout. Alright, so why don't we go ahead and promote this guy up to a field as well. So I'll select it, do Ctrl+Alt+F, accept the default name, and that guy is good to go. So we've got our layout manager for our courses set up, and we've got our adapter set up. We now just need to go ahead and have the code in place to associate it with the RecyclerView. So let's scroll down a little bit, and what I'll do here is create a displayCourses very much like displayNotes. So we'll have private void displayCourses, go ahead and give it a body, and then all we have to do here is the same basic work that we did with displayNotes. So the first thing we did is associate the appropriate LayoutManager with the RecyclerView, so we'll call mRecyclerItems. setLayoutManager, mCoursesLayoutManager, and in the same way we're going to call setAdapter against the RecyclerView, passing in mCourseReyclerAdapter. And that does all the work now associating a different LayoutManager and Adapter with our RecyclerView. And this is really all the code we have to write in terms of managing the RecyclerView here. But one of the things you'll notice that in displayNotes we explicitly set the associated menu item, the Checked, and we did that because at startup there was no user action to cause the system to automatically set it to Checked. So technically we can rely on the system to go ahead and set the courses for us, because we're not doing it until the user does a menu option. But I don't like to do things that way, because we may have code later that in some cases has us launch the activity with courses selected, and we want to make sure that the menu is properly selected in that case as well. Now as you would imagine, the code to set the menu item for the courses as checked is almost the exact same code as to set the menu item notes as checked, just with a different menu id. So what we should probably do is take these three lines of code up in displayNotes that are responsible for setting the menu item, and let's extract this into a method. So let's go ahead and highlight this guy, I'll right-click, choose Refactor, Extract, and Method. Let's just call it selectNavigationMenuItem, and click OK. Then what we'll do is take the id here and let's promote this up to a parameter. So I'll right-click on that, choose Refactor, choose Extract, choose Parameter, the system takes it up as a parameter, and it gives it the default name of nav_notes, but what I would like to use is the name id. And you can see that's one of the options down here, so I'll just arrow down to that. I'll hit Enter. And so now selectNavigationMenuItem, accepts a parameter of id, and you'll notice that up in displayNotes, when it calls selectNavigationMenuItem, it passes in that R. id. nav_notes. So what we want to do now is down here in displayCourses, we want to make a call to selectNavigationMenuItem, and we want to pass in R. id. nav_courses. So now one last thing we have to do is simply call displayCourses when the user makes that selection from the navigation drawer. So let's go ahead and scroll down, and what we'll do here is for our if statement for the courses selection we'll call displayCourses. And that should take care of everything. So let's go ahead and run this guy and see how it does. So here we are now in the Emulator, and we're seeing the list of notes. Let's go up here to our app icon and let's tap that. Let's go down and choose Courses. You can now see we have the list of courses. Now if I tap on one of them, I simply get that Snackbar, but again, ideally what we would do is go ahead and show our NoteListActivity, and just show the notes corresponding to that particular course. Let's go back up to our app icon, let's choose Notes, and again we see the list of notes. So you see what we've done here. By combining the work we did earlier in this course with the RecyclerView, with the work we did in this module with the navigation drawer, we're able to provide a much more rich experience for the user.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that the navigation drawer provides your app's main navigation options. It normally slides out form the start edge of the screen, which on most devices is the left edge. And from a user experience standpoint, when they open or close a navigation drawer they have a few options. They can swipe from that left edge in to open it up, or swipe it back out to close it, they can tap on the app icon to open it up, or they can use the Back button to close it. When it comes to providing the navigation drawer experience, there are a few different classes involved. There's the DrawerLayout class, and that provides our navigation drawer's layout management. It has the area for the primary content of an activity, as well as an area for the pull-out drawer content. We have the ActionBarDrawerToggle class, and that simply provides the behavior associated with the app icon, presenting the app icon, and providing the ability for the navigation drawer to open when the user taps on the app icon. One of our main classes associated with the navigation drawer is the NavigationView class. That serves as the navigation drawer. Remember that it has a layout area for providing information to the user, and it has a menu area that presents the actual options. When it comes to handling our navigation options, we have to implement the interface within the NavigationView, onNavigationSelectedListener. again, remember that's a nested interface, and then we have to associate that implementation with the NavigationView, and we do that with the setNavigationItemSelectedListener method. Alright, so that wraps up this module. In our next module, we'll revisit automated user interface testing, and we'll see how we can automate testing that involves the navigation drawer in our RecyclerView.

Testing Menu, Navigation Drawer, and RecyclerView Behavior
Introduction
Welcome to the Testing Menu, Navigation Drawer, and RecyclerView Behavior module of the Pluralsight course, Enhancing the Android Application Experience. My name is Jim Wilson. Throughout this course, we've seen how to provide users with a richer application experience through the use of menus, navigation drawers, and RecyclerViews. Well in this module, we dig into how to build automated UI tests that exercise these features, so that we can be sure that our app continues to provide users with a high quality and reliable experience. So to get us started, the first thing we'll look at is how testing these UI features are similar to our automated UI tests we talked about earlier in our series, and as you'll see, they have far more in common than is actually different. We'll then look at test actions that are related to navigation drawers, look at test actions that are related to RecyclerViews, and then to bring this all together, we'll finish up this module by building a comprehensive automated UI test that exercises the features of our application that rely on these UI capabilities.

Tests and Test Action Classes
When it comes to building automated user interface tests to exercise our menus, our navigation drawers and our RecyclerViews, the key thing to remember is it's very much like what we talked about earlier in this series when we talked about automated user interface tests. We're still going to rely heavily on the ViewInteraction class, we're still going to find the views we want to interact with using matchers, and we're going to execute actions against those. In fact, when it comes to testing menus, it's exactly like what we talked about earlier in the series. You literally just find the menu that you want to interact with and click on it, and that's really all it takes to select a menu. But for navigation drawers and RecyclerViews, the actions do require some special handling, because there are separate action-related classes for the NavigationDrawer classes and RecyclerViews. Now there are a couple of action classes related to the navigation drawer. One is the DrawerActions class, and that actually interacts with our DrawerLayout. And what rely on this guy for is opening and closing the drawer. So what we'll do is we'll use matchers to get a reference to the DrawerLayout, and then we want to perform an action, we'll perform an action from this DrawerActions class, and again, that'll allow us to open or close the drawer. And then once we have the drawer open or close we can make a selection from it. Well to make selections, we're going to rely on the NavigationViewActions class, and that will interact with our NavigationView itself, and that allows us to select an option. So when it comes to interacting with a navigation drawer, what we'll generally do is get a reference to our DrawerLayout, perform an action from DrawerActions to open it, and then get a reference to our NavigationView and perform an action from our NavigationViewActions to make that selection. And then when it comes to our RecyclerView, we have the RecyclerViewActions class. As you would expect, you can interact with the RecyclerView with that. So we would go ahead and use a matcher to get a reference into our RecyclerView, and then from there we can perform actions directly against the RecyclerView, like scrolling, or confirm actions against items within the RecyclerView, like making a selection. So to get a better sense of how all this works in conjunction with what we've already learned about automated UI testing, in our next clip we'll start building a test that exercises the features we've put together throughout this course that use our menus, our navigation drawer, and our RecyclerView.

Setting up Our Test
Here we are in Android Studio, and what I want to do now is start building a test that will verify many of the behaviors we added throughout this course. So we want to verify our NavigationDrawer behaviors, some RecyclerView behaviors, and that nexting menu option we put into place. So to get us started here I'm in the MainActivity class. I'm just going to click on the class name, and I'm just going to do a Ctrl+Shift+T. And that will allow me to create a new test, so I'll say Create New Test. And what I'll do is I'll name this test NextThroughNotesTest. Then what we'll do is that inside this test we'll actually select our notes from the navigation drawer, select an item from the RecyclerView, and then exercise that menu that next through each of the notes in our NoteActivity. So we'll click Ok to get started. And we want this to be a UI test, so we want to choose androidTest here, and then say OK. So we're now in the test class that was generated for us, the nextThroughNotesTest, and one of the first things we want to do up here is just go in and paste in some imports that I know we're going to need. Now as you recall from our testing discussions earlier in this series, we rely a lot on static imports when building tests, so it's a lot easier to just go ahead and drop them in to get us started. I'm going to go ahead and collapse imports. So now the first thing we want to do in this test is add the rule for the activity we want to test. So I'll go ahead and add in the @Rule annotation, then I'll create a public field of type ActivityTestRule, and then remember that the ActivityTestRule accepts as a type argument the Activity type, and that'll be MainActivity. We'll name the field mActivityTestRule, and then we'll go ahead and new up the ActivityTestRule, passing in MainActivity. class. And as you'll recall, adding that rule will cause the testing system to go ahead and start that activity before it runs any of our tests inside this class. So let's go ahead and add a public test method named NextThroughNotes, and remember that we want to make sure that we mark this guy with the Test annotation, so now the NextThroughNotes is a testing method. So let's go ahead and start writing the body of this guy. Now what we want to do in this test is verify that we can select a note from our MainActivity, and then successfully next through the notes within the NoteActivity. Now since our application starts up with the notes already selected, we might be tempted to not bother selecting the notes in the navigation drawer, but remember that we always want to make sure our tests are highly stable. So if this test expects the notes to be currently displayed in that activity, then we should go ahead and select those notes from the navigation drawer. So to do that we'll first start out using an onView that gets the view with the ID of drawer_layout, alright, so that's actually our drawr_layout instance, and we're going to perform an action against it so we'll call. perform. And what we want to do now is actually open up the drawer. So remember that there are special actions in the DrawerActions class that we can run in the drawer_layout, so that'll be DrawerActions. open. So you can see here now the DrawerActions is showing up in red. And your initial thought might be, well, I just need to import it. But we know that if we need to import a type Android Studio gives us that option, and since it's not giving us that option, it means it doesn't know how to get to that type. And the issue is that DrawerActions is not part of the core espresso library. We have to add in another expresso library to do that. So what we're going to do is go over to my gradle scripts, go over to the build. gradle for this module, for the application module, just scroll down a little bit here. Alright, so now, what do we need to add here? Well, if we looked at the documentation on DrawerActions, we see that it's part of an expresso test library called espresso-contrib. So what we need to do is compile that in for our Android UI tests. So what we can do is add that here towards the bottom. So remember that our Android UI tests rely on the command androidTestCompile, and then I'll put the library name in it. And then we have to give the version number, and we use the same version number as our espresso core entry, which is 2. 2. 2. So now we're compiling in this espresso-contrib library as part of our Android UI test. So let's go ahead and sync gradle and see what happens. And you see what happens there now is we're getting a whole boat-load of errors, and the knee jerk here is ahhh! And what the issue is, is simply that the espresso_contrib library is actually relying on different versions of certain classes that we're using in our application, because remember that gradle takes care of resolving down-chain dependencies. But all we have to do to fix this is simply explicitly add androidTestCompile entries for the libraries that we're using here. So now if you look at the compile entries on the gradle file, we've got that appcompat support library we're bringing in, the design, and the cardview libraries. Well what we need to do is actually add androidTestCompile entries to our build. gradle file for those three libraries. So let's get this bottom out of the way here, and then what we'll do is we'll put those three guys in. Alright, so we've androidTestCompile entries for those three support libraries. So let's go to the button up top that lets us sync grade, and see what happens. And now you see when we sync gradle we're good to go. So all we've done is simply told the Android UI Test build to use the versions of those libraries that we explicitly want, not the ones that were necessarily referenced when that espresso-contrib library was built. So let's go back over to our NextThroughNotesTest class. And you notice now, if I click on this guy, it'll say do Alt+Enter to import it, and so now we've got it. So we'll go ahead and do our DrawerActions. open. Alright, so we're off and running now. We've got our test set up, and we've got it building properly. So in our next clip we'll continue our work here with the navigation drawer and the RecyclerView.

Testing Navigation Drawer and RecyclerView
Here we are back in Android Studio. We're still working in our NextThroughNotesTest class, and we've already got the line of code in here that actually opens up our navigation drawer. So what we want to do now is make sure that the notes are selected. So we'll go ahead and add an onView entry here for our navigation view so that'll be withId R. id. nav_view, so that'll give us a reference to the navigation view under our drawer layout. What we want to do is perform an action. So now we want to select the navigation option nav_notes, so what we'll do is we'll use a NavigationViewActions classes navigateTo to do that. So those two lines of code will take care of opening up the navigation drawer and then selecting our Notes option. So now what we want to do is go ahead and select something from our RecyclerView. So what we'll do is use onView to get to the RecyclerView, which has an id of list_items. We're going to perform an action. I'm going to use the RecyclerViewActions class and call the method actionOnItemAtPosition. And what this lets us do is specify which item we want, and I want the first one, so I'll put in the value of 0, and the actual action I want to perform on it, which is a click. So what that'll do now is go to the zeros position item in the RecyclerView, and perform a click on it. So, in effect, what that does is select the first note within our RecyclerView. And the result of that will be to open up our NoteActivity. So once our NoteActivity is open, we can start verifying that we have the values there that we expect. So let's do a few things to take care of that. So the first thing I'll do is get a reference to the Notes list from our DataManager. So our local variable notes there will have a reference to our Note list. And for now let's create a local variable here called index with a value of 0. So what we'll do now is use that index to assign a local variable of type NoteInfo called note, the first note from that Notes list. So that now gives us a reference to the note. What we want to do now is walk through each of the UI fields on the NoteActivity and make sure that the spinner and each of the text views have the right text with this note in the. Let's go ahead and scroll down a little bit. So the first thing we'll do is use onView for withId of the spinner_courses. Then we want to call a check method. And then what we want to do now is use the matches method to make sure that the spinner text has the title that goes with the course of the current note. So that takes care of checking the value in the spinner, So what we want to do now is check each of the text views. So the first one onView for withId of text_note_title, and check that it matches the note title, and then we'll do the same thing to check the note text. So now with this we have a test that will open up a navigation drawer, select Notes, then select the first note from the RecyclerView, and then when the NoteActivity opens up, we get the first note information, and then we go through and check that the course title is displayed in the spinner, that the note title field has the right note title, and the note text field has the right note text. So let's go ahead and run this guy and see how it goes. And you see that it brings that navigation drawer up, shows the RecyclerView, selects a note, and then went through and did all our checks for us. And when we go back here to Android Studio, we see we have a successful test. So now we have a test that can successfully select the notes from the navigation drawer, select the first item from the RecyclerView, and then verify that the NoteActivity has the right values for that first note. So now in our next clip what we'll do is we'll expand this test to include nexting through the notes using our menu option, and verifying that the data is correct for each of the notes that we walk through.

Testing Menu Behavior
Here we are back in Android Studio taking a look at our NextThroughNotesTest test class, and currently our test does a good job of selecting notes from the navigation drawer, selecting the first item in the RecyclerView, and then verifying that the NoteActivity class displays the right data for that selected note. What we want to do now is expand this test to actually support our next menu option, nexting through the notes, and confirming that the right data is shown each time we next through the notes. So what we're going to do here is have this variable index that's just simply set to 0, let's convert this to be a loop that walks through the full range of indexes for our note list. So we'll make it a for loop. We'll have it run up the note size, incrementing index each time. So that'll take us through the full index range of our Nots list. Let's put all the code ready to check in the values on our NoteActivity inside the body of this loop. So we know that the code worked for the 0 index, we saw that work in the last clip. What we want to do now is add code to this to select our next menu item. Now from a testing standpoint, menu items are just another view, so what I can do here is after we do all the checks, let's add a couple lines here, I'm simply going to do an onView withId, and use the ID of the next menu item, which is action_next. Then all I want to do in that menu item view is perform a click. So now by simply adding that loop to walk through all the notes, and then adding the perform click on the menu item, this test will now show the initial note, verify its data, choose the next menu item, check the data for that note, and continue on to the end of the list. So let's go ahead and run it and see if that actually happens. So you see it come up, it goes to our NoteActivity, and then you see it nexting through all of the notes. If we go back to Android Studio, you see it worked correctly. So that's a pretty cool test. It goes through and checks that we're nexting through properly, that the data displayed corresponds to the next note in the list, and that's a pretty good start. Now let me go ahead and get this bottom window out of the way. But we have a little bit more work to do. If you remember when we did the work on our menu items earlier in this course, we added a feature to our NoteActivity to disable that next menu item when you got to the end of this list. Nothing in this test verifies that that actually works correctly, so what we really want to do is do two things; make sure it's actually enabled while we expect it to be enabled, and then after we get to the end of the list, we want to make sure it's actually disabled. Now we can actually make sure it stays enabled in the onViewTask where we actually perform the click. So what we'll do here is we have onView withId, we're going to convert that to an allOf that includes the withId, so the withId is a criteria within the allOf, but we're going to add another criteria, and that criteria is isEnabled. So now we'll only be able to perform the click on the Next button if it is enabled. Now if we ran this right now, our test would actually fail when we got to the very last note, because remember we disable the menu item on the very last note. So what we'll do is just put a little check in front of this to make sure that we're not at the very last index. So now as long as the index is less than size minus 1 means we still expect there to be more Notes, so we expect that next menu item to still be enabled. We'll go ahead and just end at the line under the if. So that takes care of part of the job, confirming that the menu remains enabled for all the items except the very last one, but we have one last thing we want to test. When we get to that last one, we want to make sure that it's actually disabled. So what I'll do is after the body of the loop here I'll do an onView withId of action_next, and the action I want to perform is a check. I'm going to make sure it matches the criteria. Now if I wanted to check that it was actually enabled, I would use isEnabled. So that code would actually verify that it's currently enabled, but what I want to do is wrap the isEnabled in a not. So now what that will do is that after we walk through all the notes in the list we now verify that our next menu items is actually not enabled, in other words, it's disabled. Let's just go ahead and put a pressBack in here for completeness. So now we'll go through the whole test as we finish our work on our NoteActivity. We'll hit the back button and return back to our starting activity. Let's go ahead and run it. So it comes up, opens the drawer, makes a selection, walks through the list, gets to the end. If we go back to Android Studio, our test is successful. So now we've done a really good job of verifying this behavior in our application. We can select the notes from the navigation drawer, we select an item from the RecyclerView, that brings up the NoteActivity, we verify the data in that NoteActivity, we next our way through the NoteActivity making sure the right data is always displayed, and we verify that our next menu item is enabled at the right times and disabled at the right times.

Summary
To wrap up, here's one of the key things you want to remember from this module. Remember that testing things like menus, navigation drawers, and RecyclerViews is very consistent with our other discussions about automated UI testing, in fact they have far more in common than are different. We still rely on view interactions to do the testing, we find our views using matchers, and then we can execute actions against them. But in some cases, we may need special handling to perform the actions. Remember that in order to open and close a drawer rely on the DrawerActions class, to make a selection from a navigation view rely on the NavigationViewActions class, and then when it came to interacting with RecyclerView or items within RecyclerView, we had a RecyclerViewActions class. Alright, that wraps up this module. In our next module, we'll learn how to use the Android preference system to provide app customization and incorporate setting screens.

Using Drawable and Values Resources
Introduction
Welcome to the Using Drawable and Values Resources module of the Pluralsight course, Enhancing the Android Application Experience. My name is Jim Wilson. In this module, we'll look at the important role that drawable resources and values resources play in creating an application's user experience. So we'll start off by taking a brief look at the general aspect of working with resources, we'll then see how we can introduce imagery into our application using drawable resources, we'll see how we can provide values like strings, colors, or even integers using values resources, and then we'll finish up by taking a look at how we can access resources from our Java code.

Resources Introduction and Drawable Resources
Resources are an important concept in Android, because it gives us a way to have content that's external from the source code. And by that content being external form the source code, we can have content that's actually maintained separately from the source code. In addition, as we'll see a little later, resources also simplify adaptability. We'll talk about that in detail later in the series. Now as part of them being maintained separately from the source code, our resources are all located under the res project folder, and there are a variety of resource types supported, we've seen some of those already. We've seen the layout resources that allow us to describe an activity's layout separate from that activity's source code, or a menu resource, that allow us to describe a menu separately from the activity that relied on that menu. And there are many other resource types supported. One very common resource type we use are the drawable resources, and they simply represent something that can be drawn to the screen. They're often used with ImageViews or ImageButtons, or for icons on menus or navigation drawers, and there's even other uses. We can use it for backgrounds and other things as well. So it's just a general way to store content related to drawing something to the screen. They're located in our project under the res/drawable folder, and there are a wide variety of drawable types supported. Some of them, in fact, are very sophisticated, and can even support different states and those sort of things. Now one very common drawable type we deal with is the raster drawable types, and these are simply non-scalable graphics files. So these are things like your. png files, your. jpg files or your. gif files. In general, we want to prefer png files over the other types, and as much as possible avoid the gif files, so it's kind of png preferred, jpg if you don't have a png, but try to minimize your use of gif. And these work well for very rich involved graphics because they're fairly efficient to render. But they do have challenges because they don't scale, so there are some adaptability things we have to consider that, again, we'll talk about later in this series. But another graphic type we have are vector graphics, and these are scalable vector graphics files, which means that they can actually be scaled up and down without losing resolutions, but they are more expensive to render than raster graphics are. So they work well for simple graphics, particularly one-color graphics work well, and we'll see we use these very often with icons and those sort of things. Now when we work with vector graphics, we have to use the Vector Asset Studio to actually interact with those. We import them into our project using that, and we'll see an example of how to do that. And as I mentioned, there are a number of other drawable types as well, but these two, raster and vector, will actually get you pretty far. So in our next clip, let's jump back into our application, and then we'll use some vector graphics to improve the user experience.

Working with Vector Drawables
Here we are with the application running on the Emulator. Let me open up to the navigation drawer here. If we look at our Notes entry and our Courses entry, notice that the icons that are next to hose aren't really representative. Here on the Notes entry we have a camera, and on the Courses entry we have kind of gallery type of icon, and those are just the default icons that we got from Android Studio when we created the navigation drawer. And it would be nice to have icons that are representative. So for like our courses, since Pluralsight courses are made up of a bunch of video clips it would be nice to have an icon that actually had that look to it, and then maybe when I select it and we show the list of courses, it might even be nice to show that icon on the card for each of the courses. And if I go back here to the navigation drawer for Notes, instead of showing a camera, maybe something like a clipboard or something that showed that we were keeping notes, and then when we select it, maybe on the cards with the notes we could have that same icon as well. So let's go back here in Android Studio and see what that might look like. So we're here in the menu resource for navigation drawer, we've got our Notes and we've got Courses there. You notice I currently have Courses highlighted, and if we look at the Properties window notice the icon is a drawable. That @drawable indicates that it's coming from a drawable resource, and it's the one named ic_menu_gallery. Let's click on the dots to the right of it, and you can see there that's that the icon that's selected and what it looks like, but notice down here on the left there's an ic_menu_slideshow. That was actually added to our project as part of adding the navigation drawer, and when we deleted some of the default options away, the menu option associated with that is no longer part of our navigation drawer. But that looks like a good one to use for our Courses, right, because, again, Pluralsight courses are a series of videos, and this looks like kind of a series of play buttons, so that might work well, so let's go ahead and click OK. So now we switch that menu option to the ic_menu_slideshow drawable, and let's see what that drawable looks like. So you see over here in the project window I've got the ic_menu_slideshow. xml. The fact that it's an xml file versus a png or something like that, means it's not simple raster graphics. Let's double-click on it. And you can see that this is a vector graphics file, and vector graphics actually store the instructions on how to draw the image, and in fact, that pathData attribute there on the path element is actually the draw instructions. It's very much like what we use with SVG files, scalable vector graphics files. And if you look there at the fill color, notice that those first two F's, that's the opacity. So FF means it's fully opaque, it means it's not transparent at all. If those first two were 00, it would be fully transparent, so it's just that scale from 00 to FF. And then you've got those last six 0's there, right, that's our RGB values, our regular color values, and all 0's, of course, means that it's black. Okay, now obviously looking at the vector graphics file doesn't help a lot, but you saw when we select it we could actually see what it looked like. So let's go ahead now and let's add this onto the card that we're using for our courses. So let's go over to our layout file item_course_list. Now let's go ahead and get the project window out of the way here so we can just see a little better. And so why don't we go ahead and take an ImageView and put that under the course title, and then we'll set the value of that ImageView to be the same icon we're using for the menu. So I'll go over to my palette, I'll choose Images, and I'll grab ImageView, and I'll drag that right underneath our TextView here. Now you see when I drop that there it says, well what image do you want to use with this, or what drawable do you want to use with this. I want to use the ic_menu_slideshow, so I'll choose that, we'll say OK. Now, of course, we need to go ahead and set the constraints on this guy, so let's go ahead and select it. Then we'll take the top constraint, put it underneath the TextView, and then we'll take the right and left and we'll put them to the outsides of the parent, which now centers it in the parent. Let's go ahead and set the top one up to 8 so we have a little bit of space between that and the TextView. And so now we've got that ImageView positioned underneath of our TextView. But, you know, as I'm looking at this, that black version of the vector image there doesn't look great. It would be kind of nice to use something kind of more consistent with the Pluralsight brand, like an orange that Pluralsight often uses. Now one thing I could do is save another version of the vector graphics file for the color orange for that. But we don't need to do that. Whenever we're dealing with single color files like this with these vector graphics files, we generally store them in black, because remember that black was all 0's, and by being all 0's black works well with tints, because if I apply a tint to this image, because the core color is black the image will actually become whatever the tint is. If it was any other color than black, the tint would actually blend with the base color, but because it is black we can use that tint to take one version of the vector graphics file and apply different colors to it. So what I'll do here is just go over to the other properties here, the more detailed properties, because tint is not on the Properties summary. I'm going to scroll down here to get the tint, and when I get the tint, I'm going to apply the color that we use for Pluralsight orange. So I'll go ahead and hit Enter, and now it switches to that orange. And, again, that's a trick that we often use with vector graphics files, is we just bring them in as black, and then we use the tint to change the color to whatever we might want it to be. So now we have a drawable with the appropriate icon on our navigation drawer for Courses, as well as on the Courses cards. In our next clip, let's do that same sort of things for the Notes.

Adding a Vector Drawable with Vector Asset Studio
Here we are back in Android Studio, and remember what we're going to do now is choose an appropriate icon for our notes. We'll put that icon on the navigation drawer, as well as the card for the Notes. So I currently am looking at the menu resource for the navigation drawer, I have Notes selected, and remember that it currently has that camera icon. Let's go over to the dots to the right of it and see some other choices. Now you can see that the camera is selected, and if we look around at the ones that are already in the project, the drawables that are already in our project, there's really nothing there that's appropriate for using with our notes. And we can scroll through the built-in Android ones, but I had actually already done that, and there's nothing there that I really like either. So what I'd like to do is bring in a new vector graphics that I can use with Notes. Let's go ahead and cancel out of here, let's go ahead and open up our project window, we'll go ahead and expand the tree by just locating our current resource. That took us to our menu resources. Let's go and expand the drawables. And so now this shows us all the drawables that are currently in our project, and we know that none of these works. So what I'm going to do is right-click here, and choose new, and I'm going to go down here and choose Vector Asset. And what will actually do is open up Vector Asset Studio. So I'll click on that, and this is our Asset Studio. And you'll notice there are a couple of asset types here. We currently have Material Icon selected, and that will let us import from a standard library of material design icons. Notice there's another option there, Local file, so if you've got an SVG type file or something you wanted to import you could choose that to bring it in, but we're going to go ahead and go with the Material icon. Now the way we choose the icon that we want is by clicking on this little button here where it says Icon, and this gives me a big list of material design icons I can choose from. But, you know, I see one I I like right now, the one there that actually looks like a clipboard with some stuff written on it, that's actually called assignment. So let's go ahead and choose that guy, and then we'll say OK. And we'll go ahead and take that default name of ic_assignment_black_24dp, and that'll be our standard icon now for Notes. So we'll say Next. It just confirms that I want to put it under my drawable folder, and I do, so I'll say Finish. So now we have that available to us. So let's go over here to the icon now for our menu option, we'll choose our clipboard, we'll say OK. So that associates it with the navigation drawer. Now let's go to our LayoutResource that we used for Notes, which is our item_note_list, let's click on that guy. Let's go ahead and close the project window to get it out of the way. What we'll do in this case is we'll put the icon to the left of the text, because remember we have a course title and the note title here. And we can make a little room here. I'll choose Images, take our ImageView, drag it onto the ConstraintLayout. It prompts me for what drawable I want to associate my ic_assignment_black_24dp, say OK. So now what I want to do is put each of these text fields to the right of that ImageView. So I'll select the text field, I'll drag its left edge, do the same thing to the one below it, so now both of their left edges are to the right of the ImageView. We'll take the ImageView and center it vertically in the parent. So now you can see on the preview there that both TextViews are to the right of the image. The image shows our little clipboard guy there, the assignment icon, but again, it's still showing it in black, and we want this guy to be orange just like we do on the Courses. So what we'll again do is go over to our Properties, go to the Details property list, scroll down to tint, and we're going to use that same orange value we used for the Courses icon. Then we'll hit Enter, and now that guy is orange as well. And that should be all we have to do now. We've got icons associated with our Courses and Notes on both the navigation drawer and on their individual card layouts. So let's go ahead and run it and see what it looks like. So here we are now with it running in the Emulator, and looking at our Notes list, notice we've got a little orange clipboard there on each of the cards. Let's expand the navigation drawer, and notice that we've got the little clipboard next to Notes. Next to Courses we have our multiple clips icon there. Let's choose Courses. Now our Courses card show with that same icon on there in orange. Go back to our navigation drawer, go back to Notes, and we're back to displaying our Notes now. So you see, that easily we were able to incorporate drawables into our application and provide a much richer experience for the user. So now in our next clip let's look at some other resource types we can work with.

Values Resources
Another resource type we often work with are values resources. These are also often referred to as simple resources. These allow us to store values as resources, so we can store our strings as resources, or we can store color values as resources, or things like UI dimensions like heights and widths, and so forth, and then even values like integers, and there's actually many other value types that can be stored as resources as well. These types of resources are stored in our projects under the res/values folder. Now when you work with values resources, they're organized a little bit differently than some of the other resources. Now they do use XML files, but in the case of values resources, the file name doesn't actually matter, and a given file can have a mix of different resource types inside of it, and you can have multiple files in the res/values folder mixing up the resources across those files. That's not necessarily a good idea, but from the Android standpoint it doesn't matter. So now we need to clear these kind of resources. The file always has a root element of resources, and then each resource is declared as a child element under resources. The element itself indicates the resource type, so if you wanted to integer resource the element would be integer, if you wanted a color resource the element would be color, and then the resource name is specified by the name attribute on that element. So let's look at a simple example of what it looks like when we declare one of these kind of resources. So let's say we wanted to create an integer resource named my_value. Well, the file has to have a root element of resources. If we want an integer resource, we use the integer element, and we want to name it my_value, so we give it a name attribute and assign it my_value, and then the resource value is simply between the opening and closing tags. So in this case, the integer resource called my_value has a value of 1000. And then within that same file we could declare other values-based resources as well. Alright, so as you can see, declaring these kinds of resources is really simple. In our next clip, we'll see how we can actually access those kind of resources from Java code.

Accessing Resources from Code
Whether working with values resources, as we talked about in the last clip, or other resource types we've talked about earlier like drawables, resources are only useful if we can get access to them. Now as we've seen, when we're working in the Android Studio designer, we can reference resources simply by using a dialog to pick them. For example, we use the ImageView, if we want to get access to one of our drawables we could simply bring up a dialog and select that drawable. But what about when we need access to resources in our code? Well, when we need access to resources within our code, we generally need a resources reference, and that's available through any context reference, which in most cases is simply going to be our current activity class. And then we can simply call the getResources method to get a reference to a resources instance. Once we have that resources instance, we can reference specific resources. So there's a whole bunch of get methods there, so there's getDrawable methods, there's getInteger methods, there's getString methods, those sort of things, and then we simply pass in the resource name to the get method. Now our resource names in code are part of the generated R class we talked about earlier in the course series, and the individual resource can be qualified by its resource type, so it's going to be R dot the resource type, dot the resource name. So for an integer resource named my_value, its name is R. integer. my_value. In addition to the resources that are part of our own projects, there are also built-in Android resources, and they're found in the android. R class, so it's android. R. type. name. So if you want the built-in string resource name cancel, its name would be android. R. string. cancel. Now when we think about this idea of string resources, they can be treated a little bit differently than the other values resources. Now they are totally accessible through the resources. getString method, but string resources are some of the most commonly used values resources in our code. So for convenience we don't actually have to go get that resources reference first. The context classes actually have a getString method on them directly, so inside of an activity you can simply call getString to get that string value, you don't have to first call getResources, then getString. But string resources have even other conveniences beyond that, because often we don't even need to go out and get the string value. Many methods that accept strings also will accept the resource identifiers as well, so we'll have overloads that allow us to pass the resource identifier for the string rather than requiring us to go out and get the string first. Alright, so to see what all this is like to work with, in our next clip we'll add some resources to our project.

Working with Values Resources
Here we are in Android Studio, and we're currently looking at the item_note_list layout resource, and as you'll recall, this is the layout resource that displays the individual note items in our RecyclerView. And I currently have the ImageView we added earlier that has a drawable resource there showing a clipboard to indicate that it's a note. And as you recall, we set the tint on that image to be a version of orange that we commonly use with Pluralsight branding. And you see it there as that tint property, it's that color value F05A28. Now it's very probable that we might need to use that color in other places in our program, in fact we know we've used it at least one other time in setting the image tint on our Course card as well. So if this is a common color we're going to use, it might be better to give it a name rather than keep using a direct color value, and that's one of the things we can use resources for. So what we'll do is just go change the color value. Now, you notice there in the projects window there's the values section under res, and there's a colors file. Now, again, I want to reinforce this, the file name has nothing to do with what's inside of it from an Android standpoint. We tend to group common resources in files of a meaningful name just so they're meaningful to us, but from an Android standpoint it doesn't really care. So let's go into that colors file, let's go ahead and select that guy, and you inside there we've got that resources root node, and each of the entry elements are named color. And it's that element that actually makes this a color resource, not the fact that it's in a file called color, because again, the filename doesn't mean anything. But what we can do here is we can add another color resource. Let's add another line to the end here. I'll put the color element in place, and we want to give it a name, and let's call it Pluralsight_orange, so we'll use a name attribute for that. So we'll go ahead and close up that opening tag, and we'll give it the color value. So we now have that color as a color resource. So let's head back over here to our item_note_list, and let's go ahead down here to our tint property and we'll choose the dots next to it. And when it comes up, it's showing these drawable resources, but we'll go over here and choose color, and when we choose color you can now see that Pluralsight_orange is one of the choices there. So let's go ahead and select that, we'll say OK, and you can see now it's set to our Pluralsight_orange color resource. Alright, so let's go over to our item_course_list, and we'll do the same thing. So we'll make sure that we have the ImageView selected, we do. We'll go over here to the tint property, click on the dots, choose color here in the resources dialog, choose Pluralsight_orange, and then say OK, and that guy is set now as well. Now let's look at another kind of resource. So let's go to the layout resource we used for our navigation drawer header, so that's nav_header_main. I've got my LinearLayout selected. And if we look at the layout_height property for this guy, notice it's set to 160dp. Let me go ahead and click on that guy. Notice that it actually switches to a resource name. It switches to the resource name nav_header_height. And that's a dimensions resource. Let's just see what that guy looks like. So we'll go over here to our values folder, choose dimensions, and again, it's in the dimens file name, but that file name doesn't mean anything, it's actually the individual elements in here which are named dimen, d-i-m-e-n, that actually make them dimension resources. And you see there we have that resource, nav_header_height that has a value of 160dp. So when we provide dimensions resources we have to give them not just a size, but a unit, and most commonly that's going to be dp, because remember that's our device independent pixel sizes, and that's what we size most things in when we're working in Android. Now let's look at another resource type that we actually use not in resource files. Let's go over here to my MainActivity class. So we're looking at this InitializeDisplayContent method, and remember that that's the method that sets up our RecyclerView, as well as the LayoutManagers and Adapters. And let's look here at the mCoursesLayoutManager when we go ahead and new that guy up. Alright, it's a GridLayoutManager, and we give it a span of 2, which in this case means it's two columns. That 2 there is actually a good option to put out in a resource, because it's possible that you might want to change the number of columns we have here for a number of reasons, maybe when dealing with different devices, maybe to just kind of change the way you're doing things. And it's nice for things like that to not have to go into the code, so it's a great opportunity to take a value and move it out to a resource. So in this case let's go ahead and create a new values resource file. So I want to head over here to the project window, I'm going to right-click on values. I'm going to go up and choose New, and choose Values resource file. And, again, files names don't matter so I can name it anything I want, but I'm going to go ahead and call it ui_constants. We'll say OK. So it goes and creates the file for me, and gives me that root element of resources. So what we'll do in here is create an integer resource. So to make it an integer resource we'll use the element integer. And let's name it course_grid_span. So let's go ahead and close up that opening tag, and we'll give it a value of 2. Alright, so we now have that course_grid_span as a resource, so now of course we need to get that value in our code. So let's go back to MainActivity, let's go down here where we can new up the GridLayoutManager, let's add a new line here, and what we'll do is rather than actually using the 2 literal we want to go ahead and get the resources. So the first thing we'll do is call getResources to get reference to the resources object, and remember that that getResources is available on any class that is a context, and again, most commonly that's our activity, and then we want to get an integer resource. So we'll call getInteger, and then we'll pass in the resource name, which is R. integer. course_grid_span. And so with that now we're getting our column number from a resource file, and again, that allows us to modify and maintain that value outside of the source code, and as we'll see a little later in the series, by making it a resource it's easier to make our application adaptable to device differences. Alright, so we've made a couple of key changes to our program. We controlled the number of columns in the Courses RecyclerView based on a resource, and we go ahead and set the color of the icons that are on both our Note card and our Course cards in the resource. So let's go ahead and run this guy and make sure everything still works as it did before. So here we are with our program running in the Emulator. We're currently looking at the Note view, and we can see that the image for the Notes, that clipboard, sill looks orange, so the resource value is working fine there. Let's go ahead and open up the navigation drawer, we'll choose Courses, and we can see that our Courses RecyclerView still has two columns, so that resource value is working, and the ImageView is also orange, so that resource value is working. So these changes are working fantastically. So in our next clip, let's see what it's like working with string resources.

Working with String Resources and Converting String Literals
So here we are again in Android Studio, and now we're looking at the layout resource content_note. Remember this is the layout we used for our NoteActivity, the activity where you display an actual note. And I currently have the TextView for the Note title selected. If we take a look at the hint property there, if I click on that guy, you notice that I've got a string in there for the hint, of course, but I've actually got a string literal here. And one of the things in general in Android programs, we don't really want to use very many string literals, we want to prefer string resources, because one of the things that string resources allow us to do is adapt our program to other language requirements, right, so translating it from things like English to Spanish, to French, to whatever language we need to, and we'll see how we can do this later in the course series. But just from this point it's important to understand that it's just a good practice to put strings in resources as much as we can. So what we'd like to do now is convert these two string literals, the hint for the Note title and the hint for the Note text, to string resources. Now we could actually do that manually, right, we could just type up two string resources with those values in them, but Android Studio helps us out with that. You notice here on the screen there's that little red box with a 2 in it there, and that's the results of Android Studio doing what's called static analysis, or what we often called LINT, L-I-N-T, LINT, and it's just looking for things in a program that may not be quite as good as they could be, or might even be a potential problems. And let's go up here and select that guy. And you'll see in here there are two warnings, and they're both about hard-coded strings, one for the Note title and one for the Note text. And if you look down below where it says issues explanation, notice we have suggested fixes. One of those has suggested fixes is to extract a string resource, so let's go ahead and click on that guy. And you see as soon as I do that it actually brings up the Extract Resource dialog, sets the Resource value for me, and even suggests a Resource name. And I'm going to change the name to note_title_hint, because it's the resource that displays the hint for Note title. Notice it's asking what file name I want it into, and I'll say yep, go ahead and make it in the strings file, that's part of our values resources, so I'll just say OK. So now you see as soon as I did that when we look at the hint property now, it shows us that it's using that string resource rather than the string literal. So let's go ahead and do it for the Note text as well. So we'll go up here to our red box, click on that. We see that it says there's a warning for that Note text, so we'll go down here to Extract string resource. We'll name it note_text_hint, we'll say OK. So now you can see with the hint property that's a string resource as well. So if we go over here to our strings file, you can see there at the end that we have those two resources, note_title_hint and note_text_hint. So now let's look at another example of using string resources. I'm going to head over here to my MainActivity class, and we're currently looking at the onNavigationItemSelected method, and remember, this is the method that gets called each time the user makes a selection from our navigation drawer. If you look at the last two options in the if there, the one for nav_share and nav_send, both of those call that handleSelection method passing in a string. And if we look down here at the handleSelection method, we can see it receives that string, and then it simply displays a Snackbar containing that string value. So what we can do here is both of those little strings that are in the onNavigationItemSelected method, we can actually convert those to resources. Now, again, we could do it manually, but Android Studio can do most of the work for us here. So what I'll do is I'll go down here and I'm going to click on the first string here, the one that we used for the nav_share. You can see I have my yellow light bulb over there, let's click on that. You see Extract string resource is one of the options, so I'll click on that. It wants to know the resources name, and I'll call it nav_share_message, and say OK. And now if you look at the code there now where it calls handleSelection it calls getString, and it passes in that R. string. nav_share_message. Now notice here it's calling getString without calling getResources first, as we talked about. We could call getResources first, but we don't need to because we access strings so often as a convenience for us to be able to call getString directly. So let's do the same thing for the handleSelection call for send. So I'll click on the text, go to the light bulb, choose Extract string resource, and I'll make the name of this guy nav_send_message. We'll say Ok. Then, again, that does the same thing. It calls getString for R. string. nav_send_message. So our code is getting better. We don't have the string of literals here now, we're actually using resources. But remember I mentioned that often API calls that accept a string, also accept a resource ID, so we won't have to go out and get the string, we can just give it the id and it will take care of those details for us. And the Snackbar. make method is one of those kinds of methods. So now we're currently passing in a literal string. But what we could do is convert this. So instead of accepting a parameter of type string named message, we convert this guy to accept a parameter of type int named message_id. And then we can change our call to Snackbar. make to accept that message_id. So now the Snackbar. make method is accepting a string resource, rather than a string. So what we can do now is that we'll recall handleSelection up in the onNavigationItemSelected method, instead of calling getString with a resource, we can simply pass the resource directly. So in the first case here I'll get rid of getString. So now for the nav_share option we're calling handleSelection passing in just the string resource name itself, or the string. nav_share_message, and we'll do the same thing for the nav_send call as well. Alright, so we've changed our program now to use some string resources. Here in the Snackbars that are shown for the share and send options use a string resource, and also we use string resources for the hints when we create a new note. So let's go ahead and run this guy and see what it looks like. Alright, so here we are running in the Emulator, and let's go ahead and see how these string resources work for us. So let's first of all go down to our new Note button and let's click on that. And that bring s up our Note activity. And remember now that our hints for both the title and the text are string resources, and you can see that both of those are showing up correctly, so that's fine. So let's go ahead and get out of here. Let's open up our navigation drawer, let's first choose Share. You see the Snackbar opens and it's showing the string from the string resource. Go to the navigation drawer again, we'll choose Send, and that also shows our Snackbar with the string from the resource.

Summary
Here are some of the key things you want to remember from this module. We started out with a look at resources, and we saw resources throughout this module, of course, but also throughout this series. As we've seen, Android supports a variety of different types of resources, and they each have a different specific purpose. But the one thing they have in common is that all resources allow us to externalize content from our source code. Now one of the resource types we talked about in this module was drawable resources, and they represented something that could be drawn to the screen. They allow us to bring imagery into our application. And we saw that there were raster graphics, and those represented non-scalable image files, things like png's or jpg's or even gif's. We'll talk more about raster graphics later in this series. We saw there was also vector graphics supported, and vector graphics are scalable graphics files. Now in order to bring these vector graphics into our applications, Android Studio provides Vector Asset Studio that allows to either select certain vector graphics or even bring vector graphics in from the file system. And then we looked at values resources, or what are often also referred to as simply resources, and these allow us to store values such as strings or colors, or an image, or even dimensions, as a resource. Now values resources are organized in XML files, but the individual element indicates the type of the resource, alright, so if I want to declare a color resource I use the color element. And unlike the other resource types, the name of the resource is actually part of the declaration. So when we declare that resource with the element, there's actually a name attribute on there where we identify the name of that specific resource. Now there are times when we want to access our resources from our Java code. In order to access those resources, we need a reference to an instance of the resources class. That's available from context. getResources. In most cases, that's just going to be our current activity will serve as our context, so we can just call getResources right from there. And then we access the individual resource with a particular get method. So if I need a color resource I call getColor, if I need an integer resource I call getInteger, that sort of thing. Now remember that string resources provide some conveniences. So they are accessible from a resources reference, but also there's a getString directly on Context. So if I'm working in my activity, I can simply just call getString against the current activity. But in many cases, I don't even need to get the string, because many of the API methods will actually accept a string resource directly, so I can simply pass in the resource name without it ever getting the string value itself. Now whenever we interact with resources from our Java code we will need the Resource name. The resource name is part of that generated R class, and it's qualified by the resource type. So if I have an integer resource whose name is my_value, it's referenced from my Java code as R. integer. my_value. Alright, so that wraps up this module. In our next module, we'll look at how we can use styles and themes to customize the appearance of an application.

Customizing App Appearance with Styles and Themes
Introduction
Welcome to the Customizing App Appearance with Styles and Themes module from the Pluralsight course, Enhancing the Android Application Experience. My name is Jim Wilson. An important aspect of modern application development is providing a rich, consistent, and oftentimes well-branded application experience. Styles and themes are a key part of achieving this goal. So in this module, we'll first look at the role of styles, we'll then see how to declare and use styles, we'll see the role of themes, we'll see how we can modify themes using the Android Studio Theme Editor, and we'll also see how we can use themes to provide default styling for views.

Declaring Styles
So let's talk about another resource type known as a style resource, and style resources help us with the appearance of views in our application. Now we know that the appearance of a view is controlled by properties, and those properties identify appearance attributes. So you think of something like a TextView property identifies the size of the text, or the color of the text, or is that text centered, those sort of things. Now often in an application we might go through and set each of those properties individually for each individual view, and that may not be very practical. You probably want your application to have a consistent look, so you're probably going to have a lot of views that you end up setting the same attribute values for, and it would be nice to somehow group those, and that's where style resources come in. Styles allow us to define a collection of attributes. So we can define that collection of attributes, and then give it a name. And then once we have that name style, we can associate it with specific views. And then by associating that style with a view, that view will then take on the attributes in that collection. Now we've already seen this a little bit. Think about earlier when we defined the card layout that we used to display an individual note in a RecyclerView. It had two TextViews in it. One was the name of the Course that that note was associated with, the other TextView was the title of the note. And initially, both of those fields looked the same in terms of appearance, right, they were smaller gray-colored text. But as we were designing that layout, we changed it so that the course name was large black-colored text, and the note title was kind of medium-sized gray text. And if we think about what we did there is that if we look first at the Note title, well when we set up the properties for that, we actually used this property textAppearance and we set it to Material. Medium, and that made it the slightly larger, what we'll call the medium-sized gray text. And then when we set up the Course title we also set up the properties, and again, we set the textAppearance, but we set it to Material. Large, and that made it larger black text. And so both Material. Medium and Material. Large are actually styles, and they each identify a different set of attributes for how we want text to appear. Now Material. Medium and Material. Large are built-in styles, but we can actually declare our own styles, and styles are declared as values resources, so just like the other resources we talked about earlier in this module. So as values resources they're in the res/values folder. The name of the file that they're contained in doesn't matter, and they're in a file whose root element is named resources. So when we declare a style resource we use the style element, but the style element actually has child elements, and those child elements indicate the attributes that are contained within that style. So each child of the style element will be in the item element, and then the name of that item element will indicate the particular attribute that's being set. So let's look at a simple example. So, again, as a values resource it's in a file whose root element is resources, declaring a style, so we'll use the style element to do that, we'll name the style, so hre we're declaring a style whose name is myTextStyle, and then we want to indicate the attributes that are being set by that style. So we use the item element, and for the first one here we'll say name= android:textSize, so we're saying that we want to set a text size with this style, and we're setting it to 20sp. Then we have another item element, and this will be out text color, and we're setting our text color to black. Now one thing to note here, notice if we look at textSize we're using that unit sp, and we haven't talked about that before. Now sp is very much like dp, remember dp was device independent pixels. Well sp is scalable pixels. Now by default sp's are the same size as dp's, but the difference is is that sp's can be scaled based on device settings. Oftentimes people like to have larger fonts displayed on their phone, so for example, my wife has some visual limitations, so it's nice for her to have her text larger than normal when she looks at her phone. By using sp's, the sizing of the text will respect any scaling options the user has set on their phone, so pretty much always when you're setting text size, use sp's as your unit. Alright, now next clip we'll continue our discussion about declaring and using styles.

Style Inheritance and Using Styles
So, of course, the question comes up, how do you know what the valid attributes are for any given view type? Well, the good news is is it's actually provided in the view class's documentation. Each of the view class have a section XML attributes, and that section indicates the valid attributes for that view type. So, for example, I have the XML attributes section from the TextView class's documentation, and you can see there it just lists them off, and of course this is just a small subset, but it lists all those XML attributes and what their meaning is. But now as you see that long list of attributes for something like TextView and you start thinking that, well, as I build my application I'm probably going to have a lot of different styles that are mostly the same with just things slightly different. Like maybe I want to use the same color text throughout, but sometimes I want it larger, sometimes I want it smaller, so I have to go through and kind of repeat those over and over again? And the answer is no, because one style decoration can inherit another style, and you can inherit from the built-in styles, the ones that are part of the framework, or from styles that you have set up inside your own project. So the way we do that is that when we have the style element there we include the parent to indicate who we're inheriting from, and then that new style will have the parents' attributes, and you can then add attributes to that style or even override attributes that you've inherited. So let's take a look at another example. So we have a resources root element, we want to declare a style, and we're naming this style myBrandedTextStyle. But let's say we want it to inherit from that style we created earlier, myTextStyle. So all we have to do is say parent= myTextStyle. So if we stopped right here, any view we associated myBrandedTextStyle with would look exactly the same as if we associated myTextStyle with that same view, but of course we want to go ahead and make some changes. So let's say we want to change the color of the text for our BrandedText. So what we'll do is rather than having black text like we had in myTextStyle, we'll now use that Pluralsight_orange. Then as part of our BrandedText maybe we want to go ahead and make sure that the text is displayed all caps so we can add another attribute to it, textAllCaps, of true. So any changes made to myTextStyle will be inherited by myBrandedTextStyle, but myBrandedTextStyle will still have a text color of orange, and will always display as all caps. But now as we mentioned, we could inherit from framework styles or ones defined in our own projects. While we're inheriting from styles defined in our own projects, we can use the parent to indicate who we're inheriting from, but there's also a shortcut available to us. We can use a naming technique to indicate when we're inheriting from a style that's defined as part of our own project. So here's that myBrandedTextStyle that we set up just a couple of slides ago, and we explicitly inherited from myTextStyle by indicating the parent. Well since myTextStyle is part of the project, we can change the way we do this. What we can do instead is when we name this new style we use myTextStyle, then a dot, and then Branded. What happens is that myTextStyle. Branded indicates that this new style is inheriting form myTextStyle. So whenever we use it we use it as myTextStyle. Branded, and any changes made to myTextStyle will be inherited, but it's just a shortcut we can use when we're inheriting from a style that's part of our own project. So we've talked a lot about how we actually declare styles, well how do we use them? Well, using them is actually really easy. The View classes have a style property, and basically you can just set that style property to the style you want to use. All the attributes that are supported by that particular view that are defined in that style will be applied to that view, but if you happen to have attributes in that style that are not supported by that view, they're simply ignored. Now the style property is kind of the base way we associate styles with a view, but some views have additional properties that accept styles, and they'll generally apply a specific subset of attributes. A good example of that is the TextView's textAppearance property. It supports attributes related to things like textSize, textColor, and so forth, but it doesn't support the full universe of properties that are settable by style. In general, don't get too hung up on this, because Android Studio does a good job of showing you the things you're most like to want to set. Now one thing to keep in mind, as you associate styles with views, that style is only applied to the individual view, so of course you can associate a style with something like a TextView or a button, or remember that layouts are views too, so you can actually associate a style with a layout. But when you associate the style with a particular view, it doesn't affect the child or descendent views. Alright, so if you associate a style with, say, a ConstraintLayout, and that ConstraintLayout has TextViews in it, those TextViews will not use any styles associated with the ConstraintLayout. So when you're associating the styles with a view, they only affect the view they're associated with, they do not affect the descendent views. Alright, so to get a good sense of how all this works, in our next clip we'll add some styles to our application.

Creating a Text Style
Here we are in Android Studio, and what I want to do now is see how we can use a style to improve the appearance of our application. So I'm currently looking at the item_note_list layout. Remember that's the layout we use to display notes in our RecyclerView. Alright, so I currently have the TextView here highlighted that we used to display the Course title, and you notice that the textAppearance is using one of the built-in styles of Material. Large, and then if I go down to the other TextView, that's where we actually show the Note title and we're using the built-in style Material. Medium. Now let's go over to the item_course_list layout. This is the layout we use to display the list of courses in our RecyclerView. If we click on that TextView, this is one, again, we use to display the course title, and again, we're using a built-in style, and it's Material. Medium. Now if you think about this for a second, we display the course title on this card using Material. Medium, but on the card we use to display notes we just show the course title using Material. Large. It would probably make sense to use a similar appearance for the course titles no matter which of the cards we're displaying them on. Now we don't want to use Material. Medium because we're also using that for the note title. So this might be a great chance for us to go ahead and create a new style that maybe inherits from Material. Medium, but maybe uses the Pluralsight_orange color and we make it bold. So to do that, we'll declare a new style that inherits from Material. Medium. Now Material. Medium is actually a friendly name for that style. In order to see the full name of the style, what we want to do is go over here to the textAppearance field and just click on it, and that will actually show us the full name of it. So we want to do Ctrl+C to copy that. Now to declare a new style, Let's go over here to our project window, and what we want to do is go down here under values, and again, we can put this any file under values, but when a project is generated it has a file called Styles, so we'll just go ahead and use that. Okay, remember, the file name doesn't matter, it's just like all the other values resources. And there's some existing styles in here, and we'll look at those a little bit later. Let's just go ahead and declare our new style. So we're going to use the style element, and let's name our new style CourseTitle. And we want to inherit from the built-in style for Material. Medium, so we'll say parent= and paste in that style name. So if we look at the value of parent there, the @ symbol says we're referring to another resource, the android:style says we're inheriting from a style resource that's part of the Android framework, and its full name is textAppearance. Material. Medium. So let's go ahead and put the closing tag here. So now with that, this style called CourseTitle has all the characteristics of the built-in one called textAppearance. Material. Medium. But remember, first of all we want to change the text color, so let's create an item element here, and the name is going to be android:textColor. So what we'll do is go ahead and put the close tag. So now I'm going to go ahead and provide the value for the textColor attribute, and we want to use that Pluralsight_orange color that we created. So we'll put an @ symbol here saying we want to refer to a resource and we want a color resource, so it will be @color/, and remember we named that color resource Pluralsight_orange. So that now means that when we associate it to style course title with a textView, the color of the text will be that color Pluralsight_orange. We want to go ahead and make it bold as well, so let's put another element in here, and the attributes name in that case is android:textStyle, and we want it to have bold, so we'll go ahead and put the word bold in there. And so now with that this style CousreTitle has all the characteristics of the built-in style textAppearance. Material. Medium, except the text color will be our Pluralsight_orange that we defined, and it will be bold. So let's go back to each of our layout resources now and associate the style. So let's go first to our item_course_list. Then what we'll do is go ahead and select our TextView and then we'll go to our textApparance and let's select the drop-down. And let's go ahead and scroll up to the top. And you notice when we scroll up to the top our style is not there. The reason our style is not showing up there is that we already had this TextView selected when we defined the style. Let's go over here and let's just select something else, and let's select the TextView again, and let's go back to the textAppearance drop-down, scroll back to the top again, and now you see our CourseTitle style is there. So just keep that in mind. If a given view is already selected when you define a style, you may not see the style in the drop-down until you select another view and come back to it. So now we'll go ahead and say CourseTitle, and you see now it goes ahead and switches to that bold orange, and we want this guy to go ahead and be centered, so in conjunction with our style we'll scroll down here a little bit in the property window and we'll do a textAlignment to centered. So now we're using everything in that style we defined, plus a local value here of aligning it to center. Okay, let's go over to our item_note_list, choose the TextView we used for our courses, we'll choose that. Let's go to the TextAppearance, we'll scroll to the top, and you see there's our CourseTitle style again. So we'll go ahead and select that. So now the TextView we used to display the CourseTitle has the same appearance whether we're showing it for a note or we're showing it for the list of courses. So let's go ahead and run this guy and confirm that everything looks as we expect it to. So here we are with our program running in the Emulator. You'll notice here we're going to show the list of notes on our Note cards. Our CourseTitle has that bold orange font. Let's go up to our navigation drawer, let's choose Courses, and you see we have that same font now on our Course cards as well. So now we're actually helping the consistency of our program a lot here by giving a very consistent appearance whenever we show that same value or Course title on a card. So now in our next clip, let's see what it's like to use a style with a floating action button.

Creating a Floating Action Button Style
Here we are again in Android Studio, and we're looking at our layout resource named app_bar_main. As you recall from discussions earlier, our MainActivity involves a number of layout resources, and the one we're looking at here is the one that contains the layout information for the application bar, and the floating action button. And what we want to do is use a style to change the image that appears in our floating action button, because currently we have that envelope there, and since our floating action button is used to add a new note, an envelope is not really a good image for that. So whether we're going to change the image using a style, or we're going to set it here directly, in either case we first need the image we want to associate with that floating action button. So let's go over here to our project window, our drawables, let's right-click on that, let's choose New, and then we'll choose Vector Asset. We'll click on the icon button. Let's just scroll up a little bit, and let's use this one here, add circle. So we'll choose that, and we'll say OK. So we'll go ahead and accept that default name, I'll click Next. Then we'll go ahead and click Finish, and put it right there in the drawable folder. So now if I expand my drawable folder, see we've got our ic_add_circle_black_24dp. So we could, of course, just go ahead and set this directly, or we could go to our srcCompat property there in the property window, set it to this image name, and we want the image to be white, not its default color of black, so we'd also have to set the tint to the color white to do that. But, you know what, in an application of any sophistication, you're likely going to have more than one add button. So rather than having to always go ahead and set that image and tint explicitly, this is a great opportunity for a style. If we define a style with those values, anytime our application needs a kind of add button, we can just go ahead and associate the style with the floating action button, and we'd take on the characteristics we want. So let's see how we can do that. So let's go ahead and close our project window again. Now of course whatever style we define we want to go ahead and have the characteristics of the default styles. We just want to add a few things to it, which is the image and that tint. But the question is, how do we find out what the appropriate style for this floating actin button is, because if you look at the property window in summary mode as it's displayed right now there's nothing about style, but of course we know we can go over here to the property window and see all the properties. Let's scroll down to Style. So now you can see here there's the style entry in the property window, but it still doesn't tell us anything. So I'll show you a little trick you can use to find what style is being used by default. If we go to the style property here and click in it, and I click this drop-down, you notice that it tells me the default one there is Widget. Design. FloatingActionButton. Now if I try to use that one, it won't actually select, but if I actually go to the drop-down and choose that same name without the default next to it, it'll go ahead and put that in the style property for me. So once I do that, I can select that and do a Ctrl+C to copy it. So now I've got that style name copied into the clipboard. So let's head over to our styles file, let's scroll down a little bit here, and then we'll go ahead and define another style. So we'll use a style element, and let's name this style AddFab for the add floating action button. And then we'll go ahead and set the parent to that style we just copied. And you can see here that the style that we've copied is the @style/Widget. Design. FloatingActionButton. And you notice that this style does not have the android: in front of it, where when we did the CourseTitle it did have the android: in front of it. And the difference there is that that textAppearance. Material. Medium, that's actually part of the framework, part of the Android framework. This FloatingActionButton style is actually part of a support library, so it doesn't have that android: prefix on it. But by simply using the technique we just did by copying the names from the property window, we'll just always get the right name for it, so we're good to go there. So let's go ahead and put the close tag on here. So with that now we want to go ahead and set the properties here. So the first property we want to set is srcCompat. So we'll use an item element to do that, and that is the source compatibility property, and we want to go ahead and put our image name in there. So let's put an image tag first. So our image is a vector drawable that's part of our project, so it's going to be @drawable. That indicates that it's a drawable resource, and then slash and the images name. Alright, so that identifies the image, but of course we also want to do the tint, so we'll use another item element, and the name for this one will be android:tint. So now we want to go ahead and put the color value in here. And what we'll do is use the built-in color white that's part of the Android framework, so we'll use @android:color, and then we'll say /white. So our new style here, AddFab, inherits all the attributes from that style named Widget. Design. FloatingActionButton, remember that comes from the support library, and then it has our drawable associated with it, and it has that tint of white there. Now let me point out a couple of things here. Notice that we set the attribute srcCompat. That does not have the android: in front of it, but when we set the tint it does have the android: in front of it. And what's happening there is that some of these attributes are coming from the framework, and some of them are coming from the support library. The srcCompat comes from the support library so it doesn't have the android: in front of it. The tint is a property that's defined in the framework, so it does have the android: in front of it. Now if you're looking at this, you're going, well, gees, how am I going to know which ones come from the framework, and which ones come from support libraries? There's kind of a little trick we can use to figure that out. Let's head back to our layout, app_bar_main. Now we've got our FloatingActionButton selected here. Let's go back to the summary property window. Alright so that's our Properties window and that's Summary view. Now currently srcCompat is already set to the email image, and we'll keep that. Let's go down here to tint and let's just go ahead and set that as well. So I'm going to click on the dotted box here, let's choose color, and I'll scroll down a little bit here, and I'll go ahead and choose that built-in color white. So we've got that, and we'll say OK. So now we've got our srcCompat property and our temp property set here locally on the FloatingActionButton itself. Now generally when we're in layout resources we use the design appearance that we have right now, but remember, we can always see the raw XML. So let's go over here to the text options and choose that. Let's scroll down here a little bit, and you can see there now we've got the entry for the FloatingActionButton, and you notice we've got the property value for tint, and a property value for srcCompat. And notice that tint has the android: in front of it. If it has the android: in front of it here, we're going to need to have the android: in front of it when we define the style. Notice that the srcCompat value actually has app: in front of it, and the app: is associated with a special namespace that we use in these layout resources, but the key thing to understand here, because it's that app: instead of android:, in most cases that means we don't want to use the android: in front of it when we define the style. So this is just kind of an easy way to know about any given property, whether it has to have the android: in front of it or not when you use it in the style. If it has the Android: here, it probably needs it in the style. If it doesn't have it here, it probably doesn't need it in the style. Again, it's not a 100% rule, but this will get you pretty far. So let's switch back to our design appearance here, and let's go ahead and clear out the tint value here locally, and let's go ahead and clear the srcCompat value as well. Alright, so now if you look at the floating action button it doesn't show any image now. So what I'm going to do is go ahead and select something else, and then select it again just to make sure that my style drop-down is repopulated, go to our Properties window, let's go to the Detail properties view. Let's scroll up now to our style entry, and then we'll choose our style, go drop-down, and choose our AddFab. And now you notice that once I choose that style that plus sign image now shows up on the FloatingActionButton. So you see here now by doing this, as our application grows, anytime we need a button that should have an add appearance, all we have to do is set this style on it and the button will take on that appearance. Alright, so now in our next clip let's start looking at themes.

Themes
As we've seen, styles allow us to define a collection of display characteristics and apply those to individual views. Themes allow us to take the same idea and apply it more broadly. With a theme, we can define a collection of display characteristics and apply it at either the activity level or even at the application level. So if we apply a theme at the activity level, what we're saying is we have a set of display characteristics that we want to have affect the activity, as well as the views contained within that activity. So this set of display characteristics will actually cascade through the activity and through the views contained within it. Now applying a theme at the application level really just means that we're defining a default theme for all of the activities in the app. So any activity that sets its own theme will use the theme it set for itself, but any activity that doesn't set its own theme will then use the theme set at the application level. Applying a theme is something that's really simple for us to do. We just simply go into the application manifest. So if we want to set a theme for a specific activity, we find that activity's activity element in the application manifest, and simply set the theme attribute on that activity element to the appropriate theme name. To set our default theme, we simply find the application element in the manifest, and set the theme attribute on the application element. Now you actually already know most of what you need to define a theme, because a theme is defined as a style resource, because a theme really is a style. Now it'll generally inherit from an existing theme-based style, but otherwise, working with it is very much like working with a style. Now to set the display characteristics within a theme, you kind of have a couple of choices. One thing you can do is go in and simply edit the style resource directly. In other words, just open up the XML and go in there and edit the values for that resource. But Android Studio also provides something called a theme editor. Now a theme editor doesn't cover everything single thing you can do in a theme, but it does provide a UI for the commonly modified theme attributes, and on top of that it gives you the ability to preview the affects of that theme. So as you're going and you're changing values, you get this preview window that shows you what things will look like based on the changes that you're making. So in our next clip we'll take a look at the theming within our application, and we'll also make some changes.

Exploring the Application Theme
Here we are in Android Studio, and let's just take a look at some of the theming that's going on inside our application. So to get us started, let's go over here to our manifest and open that guy up. So if we look here in our manifest, let's first look at the application element. So we can see the application element has a theme set of AppTheme, and remember that that's the theme that will serve as our default theme. If there are any activities that don't have a theme explicitly set, AppTheme is the theme that will be applied to it. But if we look at the entries for our three activities here, each one of them actually have an explicit theme set. So currently no one is using that default theme of AppTheme, each one is explicitly using the themes AppTheme. NoActionBar. So let's see what these themes look like. So let's head down here to our styles entry, and open that guy up. If we take a look there, we see we've got our AppTheme at the top, it inherits from one of the support library themes, Theme. AppCompat. Light. DarkActionBar, and then we have our theme, AppTheme. NoActionBar. Now AppTheme. NoActionBar doesn't have an explicit parent, but remember that because AppThemes defines part of our project, a theme named AppTheme. NoActionBar actually inherits from AppTheme. And if we look at AppTheme. NoActionBar, the only entries in there actually turn off the ActionBar, and the reason for that is that all these activities actually include an AppBar as part of their layout, so they don't need the system ActionBar. Now if the only thing AppTheme. NoActionBar does is turn off the ActionBar, and it inherits from AppTheme, most of the changes we'll likely need to make we can probably make right here inside of AppTheme. Now currently the only entries in AppTheme relate to some colors. Now obviously we could add some more entries here or even modify these entries right here inside the styles file, but before we do that, notice that there's this entry up top here, Open editor. Let's go ahead and click on that guy and see what happens. So we'll choose Open editor, and notice that opens up our Theme Editor, and that gives us a bit of a UI to interact with the theme with. Now before we took a look at the Theme Editor, one thing I want to note is we don't actually have to go into that resource file to open up the Theme Editor. I could have also gotten here by going up to our Tools menu, choosing Android, and then I could have jumped to Theme Editor from there. So I can do it through the menu, or through that resource file. Now looking at the Theme Editor, on the right-hand side there it gives us the opportunity to interact with our themes, on the left-hand side there it gives us a preview of the way some common UI elements will appear based on this theme. Now you notice the current theme that's selected is AppTheme, and it shows as default, and it shows as default only because it's the theme that's associated with the application in our manifest. If we were to change which theme was associated with the application, that theme would become the default. So now if I click on the drop-down here, notice I could choose my other themes, like AppTheme. NoActionBar, along with some other themes here. And notice I could even create a brand-new theme. Now generally you probably won't need to do that, we'll probably be able to just work with the ones that have already been created for us, but just know that feature is there. Now notice also when I have a theme selected, down below there there's a theme parent. That allows me to select what theme I want this current theme to inherit from. So, again, I could select that, I could choose a different theme to inherit from, or I could go down here and choose this Show all themes, and then a dialog would open up showing me a long list of themes I could choose from. But in most cases we can just go ahead and stay with what's already been created for us. So let's just look over some of the entries here. Now notice these three color entries, colorPrimary, colorPrimaryDark, and colorAccent, and these are the three entries that were actually in that style's resource file. These are the three points you're very likely to have to interact with, and these relate to your application's branding. ColorPrimary is intended to be your primary branding color. In most themes, the most obvious thing they use as that color is generally going to be the app bar. But we also have the colorPrimaryDark, which is a dark variant of your primary branding color, and then there's colorAccent that's intended to be a bright complement to your primary color. So let's scroll down here a little bit and see some of the other values that are there. So we have things like colorBackground, which will be our background color, colorForeground. Then we get into navigationBarColor and statusBarColor. Now you notice that navigationBarColor is black. So if I go over here to the Preview window and I scroll down a little bit, so now if we look at these previews, notice that our navigation bar is black, consistent with the color set with navigationBarColor, and if we look at our status bar color it's actually using one of our branding colors, colorPrimaryDark, the dark variant of our primary branding color. We can see there that our status bar would then be using that color. And then there are some other properties we can set here too related to our text colors and so forth. So now that we've seen our themes and our application and the Theme Editor, in our next clip, let's use this to apply some branding colors to our application.

Changing Theme Branding
Here we are back in Android Studio, and we're looking at the Theme Editor. And as you recall from our discussion earlier, our application was generated with two themes. One theme is called AppTheme, and it inherits from one of the support library themes, and then our other theme, if we choose our drop-down here, is AppThemeNoActionBar, and that inherits from AppTheme. But now when we looked at the details of these themes, remember that when we looked at AppThemeNoActionBar, the only thing it did was turn off the action bar. Everything else about it was inherited from AppTheme. So that means that any changes we need to make to the way our theme appears we can probably just go ahead and make in AppTheme. So let's switch back to AppTheme here. So what we want to do in this clips is change the colors in the theme so we can provide a branding appearance that might be appropriate for a Pluralsight-type application. As we talked about earlier, there are three color values in the theme that relate to our branding, colorPrimary, colorPrimaryDark, and colorAccent, and each of these actually have their values set using resources, and these are the resources that are defined within our project. So, for example, the attribute colorPrimary is set based on the color resource in our project called colorPrimary, the same sort of thing for colorPrimaryDark and colorAccent. Now to modify these, one thing we could do is head over here to the styles file, find themes, we see AppTheme there, we've got the entries for our colorPrimary, colorPrimaryDark, and colorAccent, and we could actually change the color values right here, put actually color codes right inside of these item elements for the colors. But we've already got resources for those, so another thing we could do is head over to our colors, and then go to each of the color resources and change their values here. And doing that would actually work, if we change the color values here in the resource definitions that that would cascade into the theme. But we have another alternative that might be a little easier for us to work with. Let's head back to the Theme Editor. The Theme Editor actually allows us to edit the theme, make changes to some of the attributes in the theme, and we can make changes to these colors here, so let's go ahead and do that. Let's go over here to our colorPrimary. Now the way I can change the value for colorPrimary, is I can go over to this box to the left of where it's set and just click on that, and you can see that brings up a dialog now that will actually let me set the color. Now one thing I could do is I could go over here and say, choose one of these color resources over here on the left, so I'll choose this one here, holo_blue_bright, I'll choose that. Now if I say OK, notice what it did. It actually changed the colorPrimary attribute to have its value actually set as that resource, and that's not what I wanted to do. What I wanted it to do was change the color value that was actually associated with my own resource. So I'm going to hit Ctrl+Z to undo this. So let's go back up here, bring that dialog back up, and what I want to do is just go ahead and change the color value right here. So what I want to do here is have our colorPrimary to be like a dark gray color. So what I'll do now is I'm going to switch from ARGB to RBG format. Now ARGB format is simply Alpha RGB, which means it allows me to control the opacity and transparency, but I'll switch it just to RGB since I'm not using any kind of transparency. And the value I want to use here is a dark gray that has a value of 51 for red, green, and blue. So now setting all of those to 51 gives me a hex color code of 333333, I'll going and keep that, so I'll say OK. And you notice now by changing that colorPrimary using that mechanism, I'm still keeping my own colorPrimary resource, it's just set to this dark gray color, and we can see now that our app bar is actually showing up in that color. So let's scroll down here a little bit in the previews of the views in our Theme Editor. And we can see there our status bar is actually currently set to the colorPrimaryDark. And remember that colorPrimaryDark is kind of the dark variant of our primary color. Now our color is already a pretty dark gray, but what we'll do is we'll just use a darker gray. So, again, I'll go over here and click on this little box, that brings up the dialog. I'm going to go ahead and switch to RBG style again. And in this case I'm going to use a really dark gray, in fact, it's almost a light black, where the red, the green, and the blue are all set to the value of 34. So you see I'm going to make that change now I get a color hex value of 222222, I'll say OK. And you can see now that the status bar now is that color. So now the last thing we want to set here is colorAccent. So let's go ahead and click on the box for that guy. And remember that colorAccent is supposed to be a bright complement to our primary color, and this would be a great chance to use our Pluralsight_orange color. Now I could go into the individual color values here and actually set it to the red, green, and the blue values to represent that orange, but I already have a resource, Pluralsight_orange, that has that color. Now we know that if I select Pluralsight_orange right here in the resources dialog, it'll actually switch from setting my colorAccent attribute using the colorAccent resource, to using the Pluralsight_orange resource, and that's now what I want to do. I want to keep using my colorAccent resource. But I want it to have the same value as my resource Pluralsight_orange. So what we can do is, if we look at our dialog, notice there's an option here next to Color that says Reference. Let's go ahead and chose that. What Reference will allow me to do is set my resource to be a reference to another resource. So what I'll do here is click on the box right here with the question mark in it. Now that brings up a dialog very similar to this one, but now when I go ahead and choose my color resource, Pluralsight_orange, and then I'll say OK, notice that I'm still setting the color resource called colorAccent, it now is a reference to the color resources Pluralsight_orange. So now when I say OK, you can see the things like my progress bars and my seek bars over here in the preview are now using that color. But if we look at the theme itself, the attributes for colorPrimary, colorPrimaryDark, and colorAccent still all use the resources within my project to have the same names. If we head over here to our styles file, we'll notice that nothing has really changed here. The colorPrimary attribute still uses the resource named colorPrimary, same thing for colorPrimaryDark. And even our attribute colorAccent still referenced the resource named colorAccent. So if I head over here to my color resources, you can see that colorPrimary is now set to that appropriate color, that dark gray that I wanted as my primary color, colorPrimaryDark is now set to that even darker gray, and colorAccent is now set to a reference to my color resource named Pluralsight_orange. But I was able to do all of that right from inside the Theme Editor. So let's go ahead and run our program now and see what all this looks like. So here we are running inside our Emulator and you'll notice now that our app bar is set to that color that's the dark gray, our status bar is set to that really dark gray, again, almost a light black, but now notice though that our floating action button is now colored orange. Now if I go over here and click on the floating action button and create a new note, notice now that the field that I type into, Note title, is now highlighted in that orange color. If I click on Note text, that now has that orange color. So we can see now that our application is styling in a way that kind of represents a branding that might be appropriate for a Pluralsight application. Alright, so now in our next clip let's see how we can set the default styling for specific view types using our theme.

Applying Theme-wide and View-specific Theme Attributes
Here we are back in Android Studio continuing our discussion about using themes. Now we saw that we could use themes to set things like colors that affected our application, but remember that any attribute that we set within a theme cascades through the activity that that theme is applied to, and we can use any valid view attribute within that theme. So something we could do here, let's go ahead and add an attribute for textSize. And just for the purposes of our demo, let's give it a pretty large textSize, let's give it 30sp. So it's a textSize of 30 scalable pixels, which by default is the same size as 30 device-independent pixels. Now what'll happen is that this textSize attribute now will cascade through the activities, and any view that understands textSize and hasn't explicitly set it somehow, will use this 30sp as its textSize. So let's go ahead and run the application and see what it looks like. So you see us here running on the Emulator, all of our cards now have the text really large on them, both the Course title and the Note title. If I click on a new note button here, notice that even the spinner text is large, as well as the hint text and the edit text. If I just type a title here, we can see even that is using that large textSize. So you can see that that textSize attribute is cascading through the activities that are using this theme. In a real application, when you're setting attributes in the application-wide themes like this, you probably wouldn't set something like the textSize, but you might set it in a theme that you're using for a particular activity. For example, if you're using a banners type appearance or something like that on a particular activity or a subset of activities, you might want to do something like this. Alright, let's head back into Android Studio. So we're back here again in Android Studio. Now the first thing I'm going to do is just comment out this textSize attribute we've set, so I'll just do a Ctrl+/ to do that. So now as I mentioned, you probably in an application-wide theme like this wouldn't set the textSize, but what you might want to do is make sure that all the views of a certain type have a consistent appearance. So let's scroll down here a little bit, and let's define a new style that we'll use for EditText. So we'll go ahead and declare the style, and let's give it the name WeirdEditText. Now I've named this WeirdEditText, because the particular values we're going to set in here, you probably wouldn't want to set in a real application. I just want to use values that will really stand out when we apply them so we can see the effect that the theme is having on our activities. Now we're going to use this style with EditText, so we're going to go ahead and inherit from one of the support library EditText styles. Let's go ahead and put our closing tags here. Alright, so let's go ahead and put a couple of values in here. Now one attribute we'll set we'll say is textColor. So let's set the textColor to one of the built-in dark green colors. So our text color will be that dark green color, and let's go ahead and set our hint color to a dark red. So now what this style does is it inherits the support library EditText styles, but now the hints will be displayed in dark red, but once you enter text that text will be in dark green. Now, again, I'm not saying this is a good idea for an application, we're just using this as a demonstration so we can see the effect of styles. Now declaring this style WeirdEditText, won't actually affect the EditText on any activity. Now one thing I could do is go to each EditText within an activity, and set the style explicitly on that EditText to use this style, or I can actually set it within the theme. So let's scroll back up top to our theme. So here in our theme, we can actually set an attribute that affects the style applied to particular view types, and you can do this for pretty much any view type that can occur on an activity. So what I'm going to do is go ahead and put an item element here, and what I'm going to set is the attribute editTextStyle. And then what I want to do is reference that style I just declared, so I'm going to do @style/WeirdEditText. So what that means now is that any activity that's using this theme, if it contains an EditText and that EditText doesn't explicitly set its own style, it will use the WeirdEditText style as its style. And, again, we could do this for things like TextViews, Spinners, pretty much all the view types have this ability to set a style within the theme. So let's go ahead and run it now and see what it looks like in our application. So here we are back in the Emulator. Of course our text sizes are back to normal now because we commented out that large text size we had set, and we're focusing now on the style we're using for the EditTexts. So let's go ahead and click our new button. So now if you look here for the EditText for both Title and Text, they're both showing the hint in red, but if I go ahead and type a new title here, the title text is showing up in that dark green. The same thing down in my text here, that text is also showing up in dark green. So without explicitly setting a style on each EditText, I was able to centrally set the style from within the theme. Now the last thing I want to do here is go back in Android Studio, I'm going to go ahead and just comment this guy out, because using a style like this is just really a bad idea. And with that, we're back to using our theme with our branded colors, but without any of these particular attributes we've set here. But the important thing to remember here is that themes allow us to centrally control the appearance of our views, either one attribute at a time, or by associating styles with entire view types.

Summary
Here are some of the key things you want to remember from this module. Remember that when we talked about styles, all the style really does is define a named attribute collection, and it provides an alternative to setting each property value individually on each view. Now to declare a style, we do it as a values resource, and we use the style element, then underneath the style element I have a series of children that are each item elements, and these provide the individual attribute values. Now remember that a style can inherit another style, so we can either do it explicitly by specifying the parent in the style declaration, but remember there is also a shorthand available for inheriting from another style to specify in our project. We can simply prefix our style name with the parent's name followed by a dot. But whichever way we specify the parent, the new style can then add new attributes, or it can actually override parent attributes. Now as we saw, themes are simply broadly-applied styles. They can be applied to an activity, or to the app. And when we apply it to an activity, it affects the activity itself, but remember that it also cascades through the views within that activity. When we apply a theme to the application, all we're doing there is really just providing a default theme. So any activity that doesn't specify its own theme would then instead use the theme provided at the application level. Now remember that themes are defined as a style resource. Now we can actually edit some of the commonly interacted with values in the theme using the Theme Editor, so it gives us a UI for that, and even gives us a preview of what some common views will look like, or we can actually just go into the resource and edit it directly, and that gives us more extensive capability to modify the theme. Now the attributes that appear within the theme, and remember they can be individual attribute values, things related to doing colors, or even like text size, or they can provide default styling for individual views, so we can associate a default style with things like an EditText or a default style with a TextView and so forth. Alright, that wraps up this module. In our next module, we'll look at how we can use the Android preferences system to do things like store name value pairs and provide user-customizable behaviors.

Creating Settings Screens and Accessing SharedPreferences
Introduction
Welcome to the Creating Settings Screens and Accessing SharedPreferences module in the Pluralsight course Enhancing the Android Application Experience. My name is Jim Wilson. Most applications provide at least some degree of user customization. In this module, we dig into how to use the Android preference system to expose such customization through settings screens. So we'll start out with an overview of what's required for a settings screen, we'll then see how to create a settings screen using Android Studio we'll see the resources and classes involved in creating settings screens, we'll see how to customize a settings screen for our own application needs, we'll see how to manage preference summary information and deal with default values, and then we'll finish up by seeing how to access the information from our settings screen using the SharedPreferences class.

Settings Screens
Most applications will have a settings screen, and that's because most applications have some kind of user preferences that allow the user to customize the behavior of some aspect of the application. But no matter what the specific preferences are, the process of implementing a settings screen follows a pretty standard model. Now we want to be sure that our preferences are organized well, because we want to group related preferences together. As we present each preference, we want to be sure we do a few things. We want to display the preference title, so at a glance the user can know what each preference is for, and we also want to include a summary to provide the user with more information about that preference, and then of course, the user needs to be able to modify the preference. And then, of course, we need a way to store those preferences. So we want to store them generally as a name value pair, or a name for each preference and what its current value is, and we, of course, want to provide default values for the preferences, so that way we'll always have a reasonable value for each preference, even if the user never goes to a settings screen. Now manually implementing all of this could be pretty tedious, so the preference system helps us out with this because it simplifies implementation by providing a standard way to build a settings screen. It allows us to describe preferences declaratively, it provides settings-oriented UI classes, and it incorporates name/value pair storage management. To help us understand how all this works, in our next clip let's add a settings screen to our application.

Adding a Settings Screen to Our App
Here we are in Android Studio. What we want to do now is add a settings screen to our application. Now before we do that, let's just take a look at our application running inside the emulator. Here we are with our app running in the Emulator, and I want to go up here and just choose the action overflow. And notice that presents a menu option called Settings. Let's go ahead and choose it. And, of course, when we choose it nothing happens. Now just to clarify, I've added nothing to this application since the end of the last module. When we originally generated the MainActivity, it actually included a menu option for settings. Now that option doesn't do anything, but once we create our settings screen we can go ahead and hook it up to that option. So let's head back to Android Studio and start creating our settings screen. So to create our settings screen, we're going to go over to the package name, right-click, choose New, we're going to go down and choose Activity, and I'll choose Gallery. Now here in the gallery, let's scroll down a little bit, and notice that one of the activities we can generate is a SettingsActivity. So let's go ahead and choose that guy, and we'll say Next. Now from here we go ahead and give the Activity class a name, and we'll accept that default name of SettingsActivity. We'll have its title be Settings, and of course we want to go ahead and create it in our MainApplication package. And I want to look at another option here, Hierarchal Parent. When the SettingsActivity is created, it'll actually have an arrow in the top left corner, and the Hierarchal Parent is the activity we want to make sure that the Settings screen returns back to when the user taps on that arrow, and we want this to be our MainActivity. So what we'll do is go up to the dots here on the right, just choose MainActivity, say OK, so now we're set to go. And, again, this just ensures that when the user taps on the arrow that'll be in the top left of the SettingsActivity that it returns back to our MainActivity. And we'll go ahead and click Finish. So here you can see that Android Studio has generated this new Activity class for us, SettingsActivity, but notice that it extends a class named AppCompatPreferenceActivity, and it has a special class for displaying preferences. Now if we scroll through this class, we wouldn't see a whole bunch of code in here about very specific preferences. Remember that the preference system uses a declarative model, so we'd see more general code in here. And we'll take a closer look at this class shortly, but I want to show you something else first. We're going to go over here to the project window, and we're going to go ahead and collapse our package name, and I'm going to expand the resources area. And you'll notice there's a resource folder there, xml, that we didn't have before. If I go ahead and expand that, you'll see that there's four files in there, and these files provide declarative information about the preferences that we want our SettingsActivity to have. Now we'll look at the contents of these individual files more closely shortly, but for now I want to show you just one of the files, the one named pref_headers, so let's go ahead and choose that. And you notice there's three entries here, each labeled header, and these are sections that allow us to organize related settings together. If you look there at the first one, you notice that it's got a title of General, so that's going to be the name of that section, it has an icon associated with it, and then it has a fragment entry, and we'll talk more about that in a bit. The thing I want you to notice now, there's one for General, one for Notifications, and one for Data & Sync. So when our application displays a Settings screen, we should expect to see those three sections appear within the Settings screen. So in order to test that out, let's go ahead and connect the SettingsActivity to our MainActivity's menu option. So we're going to head over here to MainActivity, and you notice over here in MainActivity I'm looking at the onOptionsItemSelected method and when this class was originally generated it actually had the if statement for action_settings in place there, so all we're going to do here is go ahead and add the code displayActivity. So we'll add a line, we'll call startActivity, and we'll pass into it a new intent that displays our SettingsActivity. So let's go ahead and run our application now and see what this SettingsActivity looks like. So here we are on the Emulator, let's go ahead and tap on our actions overflow, and let's go ahead and choose Settings, and you see now we have our Settings screen. And you notice those three section headers we saw, General, Notifications, and Data & Sync all appear here. So let me go ahead and choose General, and you see we see some preferences that would go into this General section. Let's go back, let's go to Notifications, and we see a different set of preferences here that go with the Notification sections. Let's head back, and you see there's another section for Data & Sync. Now obviously we can put whatever sections in here we want to, and we can put whatever preferences in that we want to, and we'll see how to do that shortly. Now before we do that, let's tap on this arrow on the top left, remember we said there would be an arrow on the top left of the Settings screen and we tapped on that one to make sure it went back to our MainActivity, and it does, so that all works correctly. So now before we go to the next clip, I want to run the application one more time. Now what I've done is I've created a second emulator, and this other emulator is modeled on a Nexus 9 tablet. And let's see what the Settings screen looks like when running on that tablet. Here we are with the application running on emulator that emulates a Nexus 9 table. Now I created this emulator just like we created the other emulator earlier in the series. I just chose the hardware option for a Nexus 9. This will allow us to see what the application looks like when run on a tablet versus a phone. So I'm going to go up here to my action overflow, choose Settings, and notice that my Settings look different now. Notice that the sections for the Settings is now shown on the left-hand side, and then the preferences within that section show on the right. So if I go over here and choose Notifications, again, it just changes the right-hand side of the screen, and that's one of the nice things that the preferences system does for us is that it actually adapts the appearance of the Settings screen to the capabilities of the device. Alright, so now in our next clip we'll see what's involved in customizing the sections and the individual preferences that appear on the Settings screen.

Settings Resources and Classes
As we saw, displaying a settings screen involves both resources and classes. When we want to display the settings screen, we actually had to launch an Activity class, SettingsActivity, and remember that inherited from an activity class that was part of the preferences system. Then we had a resource file that described the sections of our settings screen. So what this SettingsActivity class actually does is load up that resource file and then based on that it knows the sections that are going to be in our settings screen, and can actually display that page of our settings screen. Now within that resource file there is a header element for each of those sections, and we saw that that element included a title and an icon, and that provided the information to indicate each of the sections to the user. Now the header element also had another piece of information, it had a fragment value, and that fragment value indicates the class that's responsible for that individual section. So for this section General, there's a class General Preferences Fragment, and that inherits from a fragment class that's part of the preference system, so this class also relies on a resource file. Each of the sections will have a resource file that describes the individual preferences that are in that section. So this General Preferences Fragment class has to load up that resource file, and that enables it to display the information for that section. Now part of the real power of the preference system is that we don't have to build our UIs explicitly. Instead, we rely on classes that inherit from the preference base class, and these classes handle the details of presenting the UI for each of the preferences. They manage all the storage details, they retrieve the current value and save back any changes to those values, they present the title and the summary for that preference, and they provide the appropriate UI experience, and the specific experience will vary based on the type of preference. In our application, we're going to use some of these preference-derived classes to customize the General section of the settings screen. So we're going to make it so the General section of the settings screen allows the user to enter their display name, their email address, and select a favorite social network. So in order to do that, we're going to use a couple of different preference-derived classes. So for the Display name we're going to use the EditTextPreference class, and we're going to use that same class for the email address. But for favorite social network we're going to present the user with a list to select from, so in that case we're going to use the ListPreference class. Alright, so in the next clip we're going to dig into these classes and resources in more detail.

Walking Through the Resource and Class Relationship
Here we are in Android Studio, and before we start making actual changes to our settings screens, let's just briefly take a closer look at the relationship between our classes and the resource files involved in presenting that settings screen. The class we're looking at here is our SettingsActivity class, remember it inherits from this base class AppCompatPreferenceActivity, and that base class actually handles most of the details of presenting the settings screens. Most of the code is generated directly into our our SettingsActivity class here, it's just there to handle some common housekeeping tasks so we don't have to write the code to do those things. Now let's scroll down here in this class a little bit. So here we are looking at the method onBuildHeaders within the SettingsActivity class, and notice that what it does here is loads loads up that resource, pref_headers, and remember, that's the resource file that describes the sections within our settings screen. And that's how the relationship between this class and the resource file is created. Again, it's an explicit relationship where the class loads up that resource file. So let's take another look at our pref_headers resource. And as we talked about, it has a header element for each of the sections on our settings screen. Now let's take a look at this fragment entry. Remember, the fragment identifies the class that's responsible for presenting the preferences in a particular section of our settings screen. Now notice that fragment entry points to a class, but the class name may look unfamiliar to you, because notice it has that dollar sign in the middle of it. That dollar sign simply means that we're referring to a nested class. If you look to the left of the dollar sign, that's the fully-qualified name of our SettingsActivity. and then to the right of the dollar sign is a class named GeneralPreferenceFragment. So all that means is that GeneralPreferenceFragment is a class that's nested inside of our SettingsActivity class. And you notice that each of the header elements here do that same thing. Now these classes don't have to be nested, but as you'll see, these classes are actually fairly simple, so they're commonly just nested in the SettingsActivity for just convenience of managing them. So let's head over to our SettingsActivity class and then scroll down to that GeneralPreferenceFragment class. So here we are at that GeneralPreferenceFragment class, again, it's nested inside of our SettingsActivity, and notice that GeneralPreferenceFragment inherits from a class PreferenceFragment. And, again, the details of actually presenting the preferences for this section of our Settings screen, most of that work occurs in that base class. The primary responsibility of this class is it'll load up the resource that has the information for the preferences in that section. So you notice that our GeneralPreferenceFragment class has a method onCreate, and that onCreate method calls method addPreferencesFromResource, and it passes in that pref_general. So, again, that's what creates this relationship is that the pref_headers pointed to this class, GeneralPreferenceFragment, and then this class was responsible to load up the resource that presented the preferences that belong in that section of the Settings screen. Let's scroll down to another one of these fragment classes. So here we are now at the NotificationPreferenceFragment class, and you'll notice here it looks very much like our GeneralPreferenceFragment class. It inherits from PreferenceFragment, and the main thing it does here is load up the resource, describing the preferences for its section of the settings screen. So you can see here that the classes that's described as sections within our settings screen are very much alike. So if you want to add additional sections, it's pretty straightforward. You can simply create a resource that describes that section, copy one of these existing classes, and add an entry to our pref_headers file, and you would largely have that section ready to go. But there's one other thing you have to consider if you're going to add additional sections to a settings screen. Let me scroll up here a little bit. What we're looking at here now is a method called isValidFragment that's within our SettingsActivity class, and this is a method that's responsible to protect your settings screens, and in certain situations it's possible for malicious applications to inject fragments into a settings screen. So the purpose of this method is to make sure that any time a fragment is being loaded up, it's a fragment that you expect to have your settings screen actually load up. So if you see here this return statement somebody checks that name that's passed in against a known set of fragments. It checks it against the base class preference fragment, but then it also goes through each of the fragments that we're using, GeneralPreferenceFragment, DataSyncPreferenceFragment, and and NotificationPreferenceFragment. So if you're going to add additional sections to a settings screen, you need to make sure you add a line into this return statement for that fragment as well, because if you don't, the attempt to load that fragment will actually fail. So as you can see, none of the issues related to presenting our settings screens are complicated, there's just a number of different pieces we need to be aware of and make sure we put them together correctly. Alright, so now in our next clip, let's start modifying the General section of our Settings screen.

Customizing the Settings Screen
Here we are back in Android Studio and we're looking at the class GeneralPreferenceFragment. Remember, that's the class that's responsible for the General section of our settings screen. Now we want to customize this section to include a place for a user to enter their display name, their email address, and select their favorite social network. Now if we're going to make a change to this section of the settings screen, we need to go to the resource related to this section. And we can see here that this class loads that resource pref_general, so that's where we want to go, so I'm going to head over here to my project window. I'll select pref_general, and let's go ahead and close this project window so we can see a little bit better. Now as you can see, the Android Studio UI for interacting with the resource files related to an individual section of our settings screen looks a lot like the UI provided for interacting with the layout resources. As you can see, there's actually a preview area there in the center. The bottom left shows us a Component Tree, the top left shows us the different types of preferences we have available to us. And this resource file we're looking at right now is the way it was generated by Android Studio when we created the Settings screen, and what we'll do is we'll modify this to fit what we'd like it to do. Now currently you can see I have the preference labeled Enable social recommendations selected, and you'll notice with that selected, if we look at the Properties window it indicates the kind of preference it is, a SwitchPreference, and the Properties window has values there that are appropriate for this type of preference. Now if we look at the way this type of preferences is rendered, you can see that it has a title, which is the Enable social recommendations, underneath of that is the summary. Now in the case of a SwitchPreference, you can even modify its value by changing that slider directly from the Settings screen itself. Many other preference types will actually pop up another window when you select a preference, and we'll some examples of that when we run our program. Now in our case we don't need a SwitchPreference, so let's go ahead in here and let's get rid of this guy. So we'll just go on over to it, I'll right-click, say Delete, and so that guy is gone. Now we know we do want a display name in our application, so let's go over here and select this Display name preference. And you'll notice that this guy is an EditTextPreference, so it allows the user to enter in a value. And let's look at the values in the property window. Now one of the most important values over there is the one labeled key, because the key is the name under which the preference system will actually store the value for this preference, and that key is also the name we will use any time we need to interact with this preference from our code, so we want to make sure that key is a meaningful value. So rather than use an example text, let's use user_display_name. So any time we want to interact with this preference from code, we'll access it using that value user_display_name. Now you see that title there is a reference to a resource string, and we can tell by looking at the preview that that resource string contains the value display name. And also we have a default value there, and the default value indicates what we want the value of this preference to be if the user never sets it, and we can see that's also a string resource as well. So let's head over to our strings resource file. And here in the strings resource file we can see those two string resources that we're referring to for that preference. We have the one for the display name and the one for its default value. So rather than using a default value of John Smith, let's change that to Your Name. And so with that, we actually have our display name preference all set to go. And let's head back to our pref_general resource file. Now remember we also want to have a preference that allows the user to enter their email address, so we'll need to add a preference to the screen for that. And we want to, again, use an EditTextPreference, again, because we want to allow the user to enter in that value. So I'm going to go over to the Palette, grab an EditTextPreference and just drag it onto the preview. And we can see now that that preference has been added to the screen. If I take a look at the Properties window, I need to go over there now and set the appropriate values there. As we said, one of the really important values is the key, so let's give it a key of user_email_address. So now we want to go ahead and set the title for this. Now we'll do it as a string resource, so to create that string resource I'll head over here to the dots to the right of title, choose that, say Add new resource, choose New String Value. And so we'll name this resource pref_title_email_address, and the value we give it will simply be Email address. We'll go ahead and click OK. So we can see now in the Properties window that string resource is being referenced. If we look at the preview, it now says Email address. So let's go ahead and create a string resource for our default value as well. So, again, we'll click on the dots here. So now when we're creating the default value we have to indicate what kind of resource we want, and we want to choose a string resource, so we'll head over here to where it says String, choose that, go back and say Add new resource, New String Value. So this resource name will be pref_default_email_address. And then for the value, we'll make it something like yourname@yourhost. com, and we'll go ahead and say OK. So we now have the default value there. Alright, so now at this point we've got this email address preference on our settings screen, but since we're using this to enter email addresses, we want to take advantage of the full capabilities of the preference, because the EditTextPreference gives us access to many of the capabilities of the EditTextView itself. Let's head over here to the Properties window and switch from the summary view to the detail view. Now we'll go ahead and scroll down a little bit. Now look here at the property inputType. Let's go ahead and expand that guy. Now the inputType allows us to indicate the kind of values we expect to be entered here, and depending on which we choose, in some cases it will actually automatically format the text that's entered, in some cases it will actually limit the text that could be entered, and in some cases it will even change the keyboard based on the kind of text that's expected to be entered. Now this is actually a feature of the actual EditTextView itself, but the EditTextPreference gives us access to it as well. And since I know this is an email address, I'm going to go down here where it says textEmailAddress and check that. And so now it'll accept input that's appropriate for an email address. So let's head back over to the summary view. Alright, now, so our display name preference and our email address preference are all set to go. In our next clip, we're going to take a look at what's involved in presenting a preference that allows the user to select their favorite social network.

Completing the Settings Screen Customization
Here we are back in Android Studio, and we're looking at the resource file that's associated with the General section of our Settings screen. And what we want to do now is add a preference that allows a user to select their favorite social network from a list. Now you notice here that I have this Add friends to messages preference selected, and that was one of the preferences that was added for us automatically when we generated the settings screen. If we look at the Properties window, that's a ListPreference, and a ListPreference allows us to present a user with a list, and they can make their selection from it. So we'll modify it to work appropriately for favorite social network. Now remember, one of the first things we want to set here is the key, because that's how we'll find this preference when we interact with it. so we'll make the key user_favorite_social. I'm going to go ahead and set the title, so click on the dots here. We'll add a new string resource. We'll name this resource pref_title_favorite_social, and then the value will be favorite social network. We'll say OK. Alright, so we've got our key and out title set. Now in the case of a ListPreference, as its name implies, we've got to present the user with a list, and what we really need are two lists. One list displays values to the user the way the user expects to see them, and another list that has the values listed the way our program might want them. And that's where these two properties, entries and entryValues, come in. Entries is the list the way a user expects to see it, something like Google Plus, Facebook or Twitter; EntryValues are what we want to get back within our application, and let's say in our case that might be the URLs, so we're going to need to build both those lists. And we build those lists as resources, because just like we have a string resource, we can actually have a stringArray resource. So let's head over to our strings file, and let's go ahead there now and create these string array resources. So the resource element will be string-array, and this array will be the values the way a user expects to see them, so let's name this guy pref_entires_favorite_social, put our close tag in here. Now each of the values in here fall between item elements. So our first choice here will be Google+, so this indicates that the first value in this array is Google+. So let's do the same thing for Facebook and for Twitter. Now we'll create another array for the values the way that we want our program to interact with them. So we'll create another string array, and we'll name this guy pref_values_favorite_social. Put the closing tag in place here, and then we'll add a bunch of items here as well. And, again, we'll say our program wants the actual URLs that correspond to these choices. So we'll have an item with the URL for Google+, and then, again, we'll do the same thing for Facebook and Twitter. Now it's important to keep in mind that these are parallel arrays, and what that means is that the members of each array must correspond to one another. So like in the case of our entries array, the first member is Google+, so in our values array that first URL needs to correspond to Google+, same thing for the second and third members. So now we've got these arrays created. While we're in here, why don't we go ahead and create a string entry for our default value as well. So we'll create a string element, and I'll name it pref_default_favorite_social. Let's go ahead and give it a closing tag. Now it's important to remember here that when we say default for a list preference, we mean default value. So we're going to make our default value http://plus. google. com. So this default comes from the values array, not the entries array. So let's head back over to the pref_general resource, and then, of course, what we'll want to do is make sure we have all the right resource names in here. So let's go ahead and change our entryValues to the appropriate one. Let's go ahead and set the entries array as well, and we'll set our default. And so now with that we have the resource file for the General section of our Settings screen ready to go. So now in our next clip we'll do a last little bit of housekeeping, and then we'll test all these changes out.

Managing Summary Updates and Default Initialization
Here we are back in Android Studio, and we're looking at the resource file that goes with the General section of our Settings screen. and we're just about ready to test out all the work we've done. We just have a little bit more housekeeping to do. Now if we look at these preferences, you notice that none of our preferences, Display name, Email address, or Favorite social network, are displaying a summary, and the reason for that is for EditTextPreferences, ListPreferences, and some others, the UI guidelines indicate that the summary area should be used to display the current value for that preference. Now of course what that means is then, we have to update that summary any time the user changes the value. So let's head over to our GeneralPreferenceFragment class. Here we are in the onCreate method of our GeneralPreferenceFragment class, and notice at the end of onCreate there are calls to a method named bindPreferenceSummaryToValue, and that method is actually part of our SettingsActivity class. And that method handles the details of updating the summary any time the value for a preference changes. Now bindPreferenceSummaryToValue accepts a reference to a preference, so you notice that we're calling findPreference, passing in the key for a particular preference. So what we want to do is update these keys to be the keys of our preferences. So remember that our first EditTextPreference had a key user display name, so let's change this first one here to pass in user_display_name. Then we'll do the same thing for user_email_address. And then we also want to do it for our ListPreference, so we'll make that same call for our user_favorite_social. So with those calls in place, any time the user changes the value of a preference through our Settings screen, the summary for that preference will update. So there's one last thing we need to address. Remember that each of our preferences had a default value, so what we need to do is initialize the preference system with the default values for each of our preferences. So to do that, let's head over to our MainActivity class. So here we are in the onCreate method of our MainActivity class, and what we want to do here is that just after we set up our floating action button, we're going to make a call to a method within the PreferenceManager class. Now as its name implies, the PreferenceManager class is the manager for the preference system, and there's a static method on there called setDefaultValues. So setDefaultValues requires a context, so we'll pass in this. And then when we set default values, we don't do it preference by preference, we do it for each preference resource. So if we want to set all the defaults for all of our preferences in our resource pref_general, we actually pass in that resource. So we'll pass in R. xml. pref_general. And then the last thing we need to pass in is a true/false value. We're going to pass in false. And what that last parameter indicates is do you want to force these defaults into place. By passing in false, we're saying that well if the preference already has a value, don't let it default into it. If we had passed true, it would overwrite whatever values are there with the defaults, and we didn't want to do that. So now I'm going to go ahead and do the same thing for our other two settings resource files. And so now with that we've got all of our default values loaded in as well. And so now we're ready to test out our settings screen, so let's go ahead and run this guy. So here we are running in the Emulator. Let's go ahead and choose our menu option here, Settings, choose General. So you can see that we have our display name, and its current name is Your Name, our a default value; Email address, current value is yourname@yourhost. com, its default value; Your favorite social network is Google+, again, it's default value. So let's choose Display name, and you see it pops up a window that allows me to enter in that name. So I enter in Jim Wilson, we'll say OK. Notice that the summary now updates with the Jim Wilson. Let's go to the email address. Again, it lets me enter an email address so I enter in mine. We'll say OK. Our summary now has that email address, and now let's choose favorite social network. Choose that, and you see that now pops up a selection list. So let's say I go down here and choose Twitter, notice that the summary updates with Twitter. Now of course we don't want that, so let's go back here and choose it again, go back to Google+, and again our summary now shows our selection Google+. So it shows that our settings screen is now working. So now in our next clip let's see how we can access the values that we've stored inside the preference system.

Accessing SharedPreferences Data
Here we are in Android Studio, and what we want to do now is utilize the values from our Settings screen. So we'll get started with the user's display name and email address. Now currently we're looking at the layout resource for the header of our navigation drawer. You'll notice that this layout has two TextViews on it. One currently says Android Studio, and then the one below that has an email address in it. Well this is a perfect place to put the user's display name and email. Now in order to do that we need to give each of these TextViews an id. So now I currently have the TextView selected that says Android Studio. Go over here to the id, and I'll give it an id value of text_user_name. Then I'll select the other TextView, and we'll give this guy an id of text_email_address. So we're all set on those id values now, so let's head over to our MainActivity class. So here we're looking at the onResume method of our MainActivity class, and what we'll do is we'll update the values in that navigation drawer header each time onResume gets called, because this is a good place to do it because remember, the onResume is called every time we return to this activity, so by putting it here we're sure the value will get set when the activity is very first started. Also, whenever the user shows the settings screen, when they return from that settings screen to this activity, onResume will get called again so we'll update those values. Now there are more efficient ways to do this, we can even be notified any time when those preference values are changed, and we'll see how to do that later in the series. But for now let's keep it simple. So what we'll do here is let's add a method call to a method we'll create. Let's call that method updateNavHeader. So let's go ahead and create that method. So we'll click on the light bulb, say Create, hit Tab to accept the return type, and we're set to go there. So now in order to interact with those TextViews, the first thing we need to do is get a reference to our NavigationView, and then from there we'll get a reference to the NavigationView's header, and so now using that headerView we'll get reference to each of the TextViews. So first we'll get a reference to the TextView for username, and then we'll do the same thing for email address. So now that we have the references to the TextViews, we now want to start interacting with the preference system to get the values. Now in order to interact with the preference system, we need a reference of type SharedPreferences. So let's declare a local variable here called pref of type SharedPreferences. Now in order to get that reference, we need to use the class PreferenceManager and call a method getDefaultSharedPreferences. And this method requires a context method so we'll just pass in this. And so now that we have the reference to SharedPreferences, we can get the values. So first we want to get the username, so let's declare a local string variable named username, and we want a string back, so we'll call pref. getString. We need to pass in the key of the preference we want, which is user_display_name. Now we also need to pass in a second parameter, and that's the value we want returned in the event that there's no preference matching this key. Now I'm just going to pass an empty string here. So the reason I'm comfortable passing the empty string is that remember that we've set this preference up as part of our Settings screen, and we even initialize it with a default value, so that way even if the user doesn't set it, we'll still get a value back. So now let's do the same thing for email address, and that'll be the key user_email_address. And so now that we have those values back, we can just go ahead and set each of the TextViews. And so now our updateNavHeader method has all the code we need to get access to those TextViews, get the values out of the preference system, and then assign those values to the TextViews. Alright, so now in our next clip, let's add the code to interact with our favorite social network value, and test out our program.

Verifying Application Behavior
Here we are back in Android Studio, and what we want to do now is add the code to interact with the preference value for favorite social network. So I'm currently looking at the method onNavigationItemSelected, and remember this is the method that gets called when the user makes a selection from our navigation drawer. And what we want to do here is display the current favorite social network value whenever the user selects share. Now currently whenever the user selects share, we just display a standard text message. So what we'll do is comment that line of code out, and we'll call a new method we'll create, which is called handleShare. And, of course, handleShare doesn't exist yet so let's go ahead and create it, so we'll click on the light bulb, say Create method, and we'll confirm our return type. So now we still want to show a Snackbar, so what I'm going to do is copy the code from down here in handleSelection and paste it into handleShare. But then what I'll do is the parameter for the resource id I'll actually change to a string, and I'll make it the string Share to. And then what we'll do is concatenate onto the end of that the current value for the preference. So let's put a plus sign and a new line. So we'll use the PreferenceManager class and call it getDefaultSharedPreferences method. Then we'll call getString for the key user_favorite_social, and let's go ahead and add a line break here. Alright, and so with that now, any time the user selects that option from the navigation drawer share, we'll see the current value for that preference. Alright, so we're ready to test out our program, but now before we do that I want to uninstall the current version of the program. The reason I want to do that is that, remember we tested the program out earlier, and we added our own values for those preferences. I want to test the program out first with the default values, and then with our own values for those preferences, so by uninstalling it, the defaults will get reapplied for our application. So let's switch over to our Emulator. So we're here on the Emulator. Let's bring up the list of programs. We'll choose Settings. Let's scroll down to Apps. We'll choose Apps. Let's scroll down to NoteKeeper. So there's NoteKeeper. We'll select it, we'll say Uninstall, and we'll say OK. So now our program is uninstalled. Let's take it back to the home screen. Alright, so let's switch back to Android Studio, and then what we'll do is go ahead and run our program now. So here's our program running in the Emulator, so let's go ahead and open up the navigation drawer. And you notice that when the navigation drawer opens we have the default value for display name, which was Your Name, then our default email address. So let's go down here to Share, and let's select that. And you notice that the URL for Google+ comes up. And remember when we set that preference up, we actually had to give it two lists of values. We had display values like Google+, but then we had the actual value, which was the URL. And so notice that when we actually get the value of that list preference, we get what we consider the actual value, not the display value. Alright, so let's go over to our Settings screen now. So we'll go up to our action overflow, choose Settings. Let's go in here and choose General, and then we'll change some of our preferences. So let's first go to Display name, we'll go ahead and make that my name, then we'll say OK. We'll choose Email address. We'll make that my email address. We'll say OK. And then we'll choose Favorite social network, and let's go ahead and choose to say Twitter. Alright, so let's head back to the main application screen here. Let's open up our navigation drawer, and we see now it's Jim Wilson, and my email address. I go down here and choose Share, We see we have the URL for Twitter now. And so we can see now that all the work we do with our Settings screen is working correctly, and we saw that from within our application code we could easily access the preference values that correspond to that settings screen.

Summary
To wrap up, here are some of the key things we want to remember from this module. Most applications will have settings screens because most applications have at least some features that a user can customize. Now implementing a settings screen follows a standard pattern. So now when it comes to implementing a settings screen in an Android application we tend to use the preference system because it simplifies implementing our settings screens. It allows us to describe our preferences declaratively, it provides us with settings-oriented user interface classes, and then manages the storage of our settings as name/value pairs. So now when it comes to implementing our settings screen, we have our Activity class, and that relies on a resource that lists the sections in our settings screen, and that same resource file indicates what classes are responsible for those individual sections. Now each of the sections in our settings screen is managed by a fragment class, and the details of that section are handled declaratively in a resource file. So now when it comes to presenting the individual preferences on our settings screen, we'll use one of the classes that inherits from the preference base class, because they will handle UI details for that preference, and they manage the storage. But there's still some housekeeping tasks that we're responsible for. We want to make sure that those preferences that require the summary to be updated any time there's a value change, are properly hooked up, and we did that using a helper method that was inside of our SettingsActivity class. And we also want to make sure that all of our defaults for our settings are properly initialized, and we generally do that in the onCreate method of the MainActivity of our application. Now when it came to accessing the values from our settings, we did that through the SharedPreferences class and then provide get methods that will allow us to get those individual values. And we got a reference to our SharedPrefrences class using the PreferenceManager class. Alright, that wraps up this module, and it wraps up this course. In our next course, we'll cover the SQLite database API, and transition our application from using an in-memory data model to storing our data in a SQLite database.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Intermediate
Rating
4.8 stars with 40 raters(40)
My rating
null stars

Duration
4h 51m
Released
26 Jun 2017
Share course
