Working with Android Tools and Testing
by Jim Wilson

In this course, start learning the skills necessary to work efficiently as an Android app developer, and assure quality software through testing by learning to effectively utilize the single most important tool for Android developers, Android Studio.

With any craftsman, knowing how to use your tools is a critical part of doing a job well. Android Studio, is the single most important tool for Android developers, and it includes a wide variety of features that empower developers to work effectively and assure software quality through testing. In this course, Working with Android Tools and Testing, you'll learn the skills necessary to work efficiently as an Android app developer, and assure quality software through testing. First, you'll start by exploring Android Studio productivity tools, such as refactoring and automatic code generation. Next, you'll learn how to identify and resolve application problems using the debugger. From there, you'll learn how to incorporate more expansive feature support into your applications using Android Support Libraries and the Gradle build system. Finally, you'll learn how to assure software quality and reliability through the combination of local JVM unit tests, Android instrumented unit tests, and automated user interface tests. By the end of this course, you'll have the necessary skills and knowledge to utilize Android Studio efficiently for your own Android applications.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Beginner
Rating
4.6 stars with 47 raters(47)
My rating
null stars

Duration
2h 54m
Released
3 May 2017
Share course

Working with the Core Tools and Features
Introduction
Welcome to the Working with the Core Tools and Features module of the Pluralsight course, Working with Android Tools and Testing. My name is Jim Wilson. In this module, we're going to look at those elements of Android Studio and related tools that are essential to being an effective Android developer. So we're going to start out with just a quick little overview, so the important aspects of Android Studio itself. And then we'll look at developer productivity features of Android Studio. then we'll look at how we do program execution and the debugging capabilities of Android Studio. We'll then look at a really important feature of Android Studio called instant run that allows us to very quickly apply changes to our applications. From there, we'll see how to resolve unhandled exceptions, and then we'll finish up with the Android logging feature known as Logcat.

Android Studio
If you have completed the first course in this series, you're probably pretty aware that Android Studio is our primary Android development tool. And one of things that's really cool about Android Studio is that it handles installing the things we need, so it takes care of doing things like installing the Android SDK or the JDK, the Java Development Kit, and a number of other Android development tools and we'll touch on some of those as we go. Something that's kind of interesting to note is that Android Studio is built on the IntelliJ IDEA technology. Now IntelliJ IDEA technology is actually a cross-platform cross-language development tool. Now that may just sound like trivia, but the reality is it's something important to understand because Android Studio, like the IntelliJ IDEA, is actually a really, really, really rich development environment with lots and lots of features and capabilities. So you will periodically find yourself searching, you're kind of googling to find the answer to how to do something, and sometimes what you'll find is if you Google on how to do that particular thing in Android Studio, you might get a match, you might not. But if you don't get a match, Google for that same thing, but then look for it in the context of IntelliJ and odds are you will then find the answer, so just be aware of that, that if you can't find answer on how to do something with Android Studio, just look for how to do that same thing in IntelliJ and you will likely find the answer. Now as you've seen, Android Studio provides a place to do our code development and our UI design and we'll continue to look at both of those throughout this entire course series, particularly, we're going to look at the area of UI design a little later in the course series when we look at things like resources. But Android Studio does a lot of things. It's got features that help us with developer productivity. As we've seen a bit of, it can do code deployment and execution, as well as providing debugging capabilities and we're going to look at each of these three developer productivity, code deployment and execution, and debugging throughout this module. Later in this course, we're going to look at a couple of the other key features, one is the build system, what's called Gradle, how we build our projects, and then some of the testing features that are built in Android Studio. Now Android Studio has lots and lots of features in there. It has built-in source code control support, things for like GitHub and so forth. It's got code inspection. In reality, there's just tons of great stuff in there and we'll see a number of these features as we go throughout this series. What I really encourage you to do is be curious, explore, and check out the many great things that are in Android Studio. Now to get us started in our next clip, we're going to look at a few of the Android Studio productivity features.

Android Studio Developer Productivity
Let's take a look at some of the productivity features in Android Studio. Now we're not going to go into any of these features in detail, rather our goal is simply make you aware of what's available within Android Studio. When we think this idea of productivity, what we really mean is we want to do what we need to do as quickly as we reasonably can. A key part of achieving that is being able to easily learn how to do things. So let's start up by looking at the samples feature in Android Studio. So I come up here to the File menu, going to scroll down here where it says New, and then we'll go over to where it says import sample. If we choose Import Sample, you can see that actual will bring up a list of available samples and there's a whole bunch there. Let me just scroll down a little bit and we get down here to getting started and let's say that we want to learn a little bit about floating action buttons, so I can choose this one Floating Action Button Basics. Now when I choose it, it will go ahead and give me a little description of what it does and it has a little preview what the app will look like and you notice that from here I can actually jump right to the GitHub source if I need to, but also, once I go down to the Next button and choose that, you see that actually gives me a chance to create that project locally, and from there, I'll go ahead and download the sample as an Android Studio project so I can start looking at the code and working in it right away. Now this is a really valuable tool when you're first learning how to work with Android, so be sure and take advantage of it. Okay, so let's look at another one. One of the things we've seen used a bit throughout the first course in this series is this idea of refactor. Let's look a little bit more closely at that. So I'm just going to go over here and just right-click on something, choose Refactor, and see what's there. Now we've seen this Rename option before, it allows us to easily rename fields or variables and so forth. Notice there's a change signature option that actually allows you to change a method, change its name or its parameters. We've got the Move option which allows us to actually move a method to another class if we need to. The Copy option allows us to actually copy this class and there's even one here Safe Delete. Safe Delete will actually go through and verify anything you try to delete isn't already in use, and if it is in use, it will show you where it is currently in use so you can address those things before you actually execute a delete. Let's look at this extract option refactor, so let's go to Extract and that's another important one. So something like extract variable will actually allow you to take a complex part of a statement and move that out and take the results and assign it to a variable. We've seen the Constant option in the Field options, right, constant allows us to take a literal, move it up to a constant. Field allows us to promote a local variable up to be a field in the class. Parameter works similarly, allows us to take a local variable and promote it up to be a parameter in the method. So these are all really powerful, so you want to make sure you check those guys out. You'll also get another option here, generate. So I'm going to go up here to the Code menu and choose Generate. And Generate, again, is really powerful. It actually will generate the code we need. So if I'm within a class, it will generate the constructor for me or if we look at the options for equals and hashCode or ToString, those are methods we commonly have to implement in a class. It will actually provide a stub for those methods for us. We've seen the override methods option before. It allows us to easily override a method from a class we inherit from. And then, of course, we've got this Getter, Setter, then Getter and Setter. Let's choose one of those. Let's go down here, let's choose Getter. So we choose Getter. What it'll actually do now is show us the list of fields within our class. And we can select which ones we like to have getters generated for and this will take care of generating the getter for any of the members that we select. So in case, you want to make sure you're aware of those options because as you can see, these features simplify a lot of the common things that we have to do. So anytime you find yourself needing to do work that's more focused on managing the source code rather than solving the actual problem, take a look around and see what Android Studio offers that can help out. Now let's scroll up here to the field at the top. If we take a look at the list of fields there, you notice that all my field names begin with an m, for example, the field for the NoteInfo is mNote. Now it's important Android Studio understand that I like to start my fields with an m because if I'm going to generate a getter or a setter, I don't want to have the m there. Alright. So the getter for mNote should actually be GetNote, not GetmNote. You've also seen me promote a number of variables from being local up to being fields. Well when I promote them, I want Android Studio to actually add the m for me. So let's take a look at how Android Studio knows my coding styles. So we'll go up here to the File menu again, choose File, then Settings, and if you look down here in the Settings dialog, you've got this area on the left. If I expand one of these, for example, Editor, you see a whole bunch of additional options opened up, so you'll want to check out this settings dialog because there's a lot in here. Let me go down here to Code Style, let's expand that, and we're going to choose Java because I want to set coding style for Java. You notice that once I selected Java, a whole bunch of tabs appeared and they're all the different coding style options I can set for the language for Java. Let me go to the Code Generation tab and select that, and you'll notice there's a section for name prefixes. So I simply told it that well all of my fields are prefixed with m so it knows to take the m off when generating a getter or a setter. It knows to add the m when it promotes a local variable up to be a field. As a similar option set for any statics there, I add an s to any statics. Now another part of being productive is having my editor environment be set up in a way that works well for me. So here in the Settings dialog, let's go to under Editor again, but this time let's choose General and I'll go down here to Appearance and notice there's a bunch of checkboxes, for example, there's one for show line numbers. I don't have that checked because I don't want to see line numbers in my source code. If I checked it, I would now have the line numbers appearing within the source code. The one I do like is method separators, so I have Show method separators checked. So let's see what that does when I have that checked. So if I go down back to my source code, you'll notice here right before the onCreate method there's that horizontal line that's being used to mark that I'm going into a new method. Now if I scroll down a little bit, you'll notice that after the onCreate method is the restoreOriginalNoteValues method, so there's a separator there between the onCreate method and restoreOriginalNoteValues method. There's another separator after the restoreOriginalNoteValues method and before saveOriginalNoteValues method, and I like having that turned on because it makes it very easy for me to scan through my source code and find the individual methods. So I really encourage you to look around in the project settings and see what options are in there. You may find there's a lot of things in there that help you work more the way that you want to work. Alright, now in our next clip, let's start digging into some of the deployment, execution, and debugging features of Android Studio.

Program Execution and Debugging
Let's take a look now at the options we have for executing our programs from inside of Android Studio. Now one option we have is a simple run and that occurs when we click on that green triangle. A run takes care of installing the latest version of our application onto the device or emulator and then starts it running and that's great for doing just simple tests just to make sure things kind of run like you expect them to, but during our development process, we tend not to use that one a lot. Instead what we use is the debug option, which is that button there that actually has the little bug with a small green triangle on it. When we execute with the debug option, that allows us to do things like stop our code at certain points, walk through the code statement by statement if we need to, and determine what the values of fields and variables are inside of our program. So because of that, that's what we'll generally use as we're trying to resolve any issues inside of our program. So to check it out, let's go ahead and put a breakpoint in here. Okay, so what we're going to do is put a breakpoint next to this line where I signed the mSpinnerCourses field. As I mentioned in the first course, we set a breakpoint by simply clicking in that gray area to the left of the line we want to break on, and so let's go ahead and launch this inside of the debugger. So of course, it asks me what target I want to hit. I'm going to go ahead and choose my emulator. And now that took care of installing the application onto the emulator and begins it executing. Now I put a breakpoint inside of my node activity class, inside that on create method, so let's go in here and just choose one of the options. And of course, you see in the background now it's actually stopped at that line of code. I'm just going to go back here, just switch back in Android Studio. So now once I'm here, I'm stopped on this line of code, but what if I want to kind of walk from this point and see what's happening. Well, I've got a few options I can use to determine how I walk through the code. Now one option is step over. Step over says I want to basically stay where I'm at in here. I want to step from this line to the next line of code largely in this method. If I get to the end of the method, I'll go ahead and exit out to wherever this method was called from and so forth. Another option we commonly use is called Step Into. Step into indicates that I want to actually step into whatever method is being called, so I can jump into that method and then step through from there. And another option is Step Out of and step out of will actually allow me to exit the current method up to the line that called it. And a final one, which is Run to Cursor, which allows me to just put my cursor somewhere and have the code run until it reaches that point. So let's through these one by one. So starting here with this Step Over. So I click on Step Over. I'll actually step from this line to the next line, click it again to the next line, click it again to the next line, and we'll keep going there. When I get to this line, readDisplayStateValues, that's one of my methods. Now if I click Step Over, it will actually run that entire method, but the debugger never stops inside of there. I stepped over that method call. Let me step again. So now I'm on this method saveOriginalNoteValues. So if now instead of step over, I choose this next guy here, which is Step Into, I click on that, I'll actually step into that method and allow me to walk through from there. Alright, so now I can switch back here to step over, just keep walking inside that method. And once I get to a point, maybe this is as far as I'm interested in. When I just want to get out of this method, I can go over here to Step Out of. When I click on this Step Out of or Step Out, it will step out of that method back to where it was called from and so it gives me that kind of control. Now I can keep stepping the line by line if I want to, but sometimes I go you know what, I don't really care about the lines in between where I'm at now and where I want to be, so I can actually put my cursor right there, and when I do that, I can go down to here to this guy here, run the cursor, and it'll actually run until it reaches the line where I've actually got the cursor placed. So you see that gives us a great deal of control over how we walk through the code in our application. We can go line by line, skip over methods, jump into methods, jump out of methods, and then jump to certain points in our code. Now once I'm done looking at the code, I've kind of got two options I can do here. I could actually stop the application, it would just stop it dead right here, or I could tell it to just resume, in other words, just start running normally until you hit any other breakpoints. Let's go ahead and click on that. And that now let's my application just start running kind of on its own again. I'm still running inside the debugger, but I'm not going statement by statement anymore. So let's go back into the emulator. Let's go ahead and hit the Back button to get back to our main screen. Let's go ahead and select one of the items here again. I'll just select the first one. Of course, I hit my breakpoint again because I didn't remove the breakpoint, switch back here in Android Studio, and let's see what we can do in terms of variables now. Alright, now you notice that the various variables that I have here and there's the line in on the mSpinnerCourses off to the right there that actually shows me it's currently null. You'll notice also there is a variables window and the variables window shows me the values of what are considered relevant variables, so I can see things like my this reference, I can see the value of the savedInstanceState parameter and that shows me that it's null. Alright, you can see my mSpinnerCourses is equal to null down there. So let's go ahead and step through here a little bit now and let's watch the variables on this. So as we step through here and you see that once we ran that line with mSpinnerCourses was assigned and now shows us the current value that's in there, and basically what it's doing is just calling the ToString method on that class. So for a lot of classes, you just see kind of the type name and some memory information about it. So let's go ahead and scroll down here just a little bit and let's say that I want to see the values get set for these two text fields. I'm going to put the cursor there, I'm going to run to that, maybe just scroll down here a little bit, and as you can see, we have a number of variables showing here, and notice that mTextNoteTitle and mTextNoteText are both red. I'm going to click on this step. When I click on this Step Over, notice that mTextNoteTitle turned blue and what that's doing is that's indicating to me that this value has just been assigned to. So if I step again, you'll notice that mTextNoteText will switch from red and now that switches to blue telling me that it's just been set. So you see here now that Android Studio does a pretty good job of showing us all the variable values as they're actually occurring and as they're changing, but sometimes you might want to actually look and see what something is. Now of course, one thing we could do is just hover over it and just kind of see what it is, but often as we're hovering we'll see the information off to the right inside of Android Studio anyway. But maybe I would just want to do something like you know I'm about to set the TextNoteTitle a little bit later in my code and I want to see what that title value is while I'm stopped right here. Well if I scroll down here a little bit, notice I've got a method down here saveOriginalNoteValues, and inside of there, there's a statement that actually says mNote. getText and mNote. getTitle and I want to know the title. Well mNote is actually a field and that field is in scope, so even though the method I'm looking at saveOriginalNoteValues is not in scope because mNote as a field is in scope, I can do something like this. I can actually highlight this, and when I highlight, I'm going to right-click and then choose Evaluate Expression, and Evaluate Expression allows me to at any time I want to determine the results of an expression for any variables that are currently in scope. So mNote is a field that's currently in scope. GetTitle is a method called inside of variables, so if I click Evaluate now, I can actually see that the title for the current note is dynamic intent resolution. So this evaluate expression is very powerful because I can actually have complex statements and just evaluate portions of those statements. As you can see, I can even evaluate the value of variables that are not necessarily in the code where I'm running right now, but they are in scope at the current breakpoint, so this gives me a lot of control over seeing what the current values of things are. Let's go ahead and close this up, let's scroll back up top, let's get rid of this breakpoint, and what I want to do now is go down to the method readDisplayStateValues. So now we're now in this method, readDisplayStateValues, and let's put a breakpoint here where we check to see if mIsNote is true. Okay, and let's go ahead and release it now because we're still stopped from when we broke earlier, so we'll let that go. Switch back to our emulator, go back to our list. Now the way I've got this currently set is that the breakpoint in that method readDisplayStateValues and we know that gets called every time our note activity is shown. Alright, so if I go up and I click on the first item, I click on that, we hit that breakpoint. Now we know our position right now. If we hover over it is 0. I'll release it. Let's go back to the emulator. Go back. Let's say that I now clicked a New Note button. I go in there. I still break inside of here. Of course, when I'm here, when it's a new note, we know our position is -1. Let's go ahead and release it. And let's say we're trying to resolve an issue and our program is fairly complex and maybe we start coming to this note activity from a number of different scenarios as our application gets more and more complex and let's say we're trying to debug a scenario that only occurs when the position is equal to -1. Well one of the things that we can actually do is associate a condition with a breakpoint. So if I get rid of this breakpoint, I right-click on it, notice that condition field comes up, so I can put any statement in there that is valid for the state of the program at this breakpoint. So I can put the value in here, position == -1. Now once I do that and I click Done, I'll only break here when position has a value of -1. So if I go back into the emulator and we'll go back to our list. So now I'll choose one of the items. Notice that I don't stop at that breakpoint because we know when we choose an item, there is a non-negative value for position. But if I go back and now I choose new note, now we do hit the breakpoint because we know our position has a value of -1. So as you can see, using a debugger we have a tremendous amount of control of walking through statement by statement to have control over things, evaluate our variables, and even have conditions associated with our breakpoints. Now in our next clip, let's take a look at a feature called instant run available inside of Android Studio.

Android Studio Instant Run
Here is the application running inside the emulator and I launched my application into the emulator using the Debugger button. Alright, so if I go back to the Android Studio, I've got, of course, my Run button and my Debugger button, but one of the challenges we have, particularly while we're doing debugging in an application, right, trying to resolve a problem, we'll have to make a lot of small changes to our code, test them out, see how that goes, and then make some more changes. Now of course, we make those changes, at any point, we could go there and just click the Debugger button again. If we did that, it would stop our application, fully redeploy the application, restart it. One thing is that takes a fair amount of time, particularly in large applications, the other issue is that any state in the application will be lost. So Android Studio has what's called an Instant Run button, also known as apply changes and that's that lightning bolt there. So whether someone says apply changes or the instant run feature, they're going to talk about the same thing. It's a feature of Android Studio that does just enough deployment based on the changes that you've made, and in many cases, it can even leave your application running. So it's a mechanism that allows us to make small changes to our application and then get them running on our device or emulator very quickly. It's a feature that allows us to work much more effectively in that process of making small changes and testing them out. Now there are some cases where instant run will actually shut down your program, reinstall it, and then launch it, but only when it needs to. In many cases, it'll just leave the application running, apply that change, restart your activity, and bring it right back. So let's see this in action. So let's go back to the emulator, let's go up here and we'll just pick this very first item, and let's do something here like let's put a XXX on the end here. Now let's go up to the title and let's do something creative like put a YYY. So I've got those guys there. Now remember the way our application works is that this would actually change the state of our application. Right. If I go back to the list and come back in, remember that was actually saved within our application, but our application doesn't have any persistent state so that data remaining in place is dependent on the application continuing to run. So let's go back here in the Android Studio and let's just do some simple change. What I'll do is I'll go to the layout for that note activity and let's do something creative like go to the note title and let's change the color of the text, so click on this button over here to bring up the dialog, choose color, and I'll just use our color accent here, that kind of fuchsia-like color, and we'll say OK. So now again if I actually went up here and clicked the debug button, it would fully relaunch my application all state would be lost. What I'll do instead is click the instant run feature, and I'm going to very quickly switch back over to the emulator. So click Instant Run, switch to the emulator. And you'll notice that when I do that, first of all, you see apply changes shows at the bottom, but notice also that my text color changed, but my data changes are still there. So in that case, it did just enough deployment to get the changes out there, but did not restart my application and it did a much faster than if I'd actually had to do a full deployment. So the key thing there is that be sure to take advantage of the instant run feature. It'll allow you to work much more effectively and keep yourself moving as you're making these small changes to your code and testing them out. At any time you wanted to force a full restart, you can do that by just clicking on the debugger run button. But in most cases, Android Studio will do a good job of just deciding how much deployment and how much restart is actually necessary. Alright, in our next clip, we're going to take a look at how we can actually resolve uncalled exceptions in our applications.

Resolving Unhandled Exceptions
We've seen some of the features of the Android Studio debugger, but the value of any debugger is its ability to help us debug our applications, in other words, its ability to help us resolve issues that come up. So let's say we want to take a look at our note activity here. We're here in the onCreate method and there's that method readDisplayStateValues and that actually handles some of the startup behavior of our activity. Now if I want to look at the method, now one way I could get to that method is I could actually right-click on it, choose this Go To option and you see over here there's Declaration, and that will jump right to it. And that's great for when I want to look at a particular method, but sometimes I want to jump around between a few methods. So there's another option we have here. Notice here over on the left, one of the tabs on the left is marked to structure, let me select that. The Structure tab shows me the members of the class I'm currently looking at. Now if I wanted to, I could sort this alphabetically, but instead, I'm just going to go ahead and leave it in the order it shows right here. What I'll do is I'll go down to here where it actually says readDisplayStateValues, I'll click on that, and that jumps down to that method. Now if we look here in our readDisplayStateValues, we have this if statement, and if the if is false, we go out and get the notes from the DataManager and get note at that current position. But if the if is true, we call this method createNote. Now what I'll do here to get the createNote here, I'm going to go ahead and select it from the list on the left here again, and there's createNote and it turns out it's actually just below our readDisplayStateValues. Let me just kind of scroll up here just a little bit so we can see both methods. And if we look here, the createNewNote has that getNotes and then get a note at particular position as well, so it seems like we may have a chance to simplify our application here a little bit. Since both of these methods are in that call path of readDisplayStateValues and both of them get a Note at a particular position from the DataManager, why do we have to do it in both places. So let's say that instead of calling getNotes. get down here, we'll go ahead and comment that guy out. So now once we comment that guy out, that means our call to getNotes. get and readDisplayStateValues should happen whether it's a new note or not. So what we'll do then is we'll get rid of this else here and let's go ahead and put a blank line between there so we can see it easily. So now we only do the getNotes. get at a particular position once whether it's a new note or not. So I'll run it inside a debugger. So here we are running, so I'll go ahead and just choose the first option here and that goes in. It shows our note activity, so that worked okay. So let's go ahead and go back and now let's click on our new note and our application crashed. And that's what we call, my friends, an on-call exception. Something crashed, we didn't do something right, and so now we've got to debug the application, and oftentimes, this can be one of the hardest things to debug. So let's go back here to Android Studio. Now here in the Debugger tab, there's not a lot of information. I even might go ahead and bring the debugger panel up from the bottom. There's not a lot there that really helps us out. If we look at the console view, that just kind of tells us the commands that launch the application. If I look at debugger view, there's really nothing there because I'm not stopped in the debugger. But you'll notice there's another tab here marked Android Monitor and you can see there's a bunch of messages in there. Now we can't see them very well right now, so let's go ahead and make this a little larger so we can see it a little better. So if we look here now, we can see there's some message about exceptions and so forth, but they're kind of hard to read and one of the issues is that when we record these videos, we use a fairly large font and the font we're using is causing these messages to line wrap. So there's an option where we can turn that line wrapping on and off and that's over here on the left. What I'm going to do is go ahead and turn that off. So now that pushes the lines together, so now if I go here to my scroll bar and scroll over a little bit, I can see a little bit better. So now you notice there there's a message that says there's an ArrayIndexOutOfBoundsException. So that tells me that I threw an exception because I was out of bounds and you'll notice that what it's telling me also is that the length of the array had 10 elements in it and the index I was using was -1, right, that's information from that uncalled exception. But simply knowing you have an exception isn't really that helpful, but notice also underneath the exception message is a stack trays and the stack trays are showing the most recent methods were called going all the way back to the start of the method call stack. A couple of them actually have the name of our source file, NoteActivity, and a line number and those guys are links. So if I go over here, and generally, what I want to do is go to the one that's closest to the exception, if I click on that, that'll jump to that line and that's the line in my program where things went horribly wrong. Alright, so we now know that it has something to do when we're getting the position of our notes and we know that's code that we just changed. So let's go put a breakpoint in here and let's try running this guy again and see if we can figure out what happened there. So we'll go in here and do an instant run just to kind of help us hopefully get a faster start inside the emulator. So here we are inside the emulator. Let's go down here and click our NewNote button. Alright, that stops us inside the debugger, and so now we can hover over that position and our position is -1. Alright, so that is our problem is that our NewNote operation is causing us to call this get method with a -1 position and that's not valid. Now we know that the way our program works, remember we did this all in the first course, is that we can go ahead and add a new note spot into our list of notes for a new note and then we want to go ahead and get it back from that position. So we've done something wrong here when we've combined this code that does the get from notes. So let's go ahead and stop this guy, and let's go ahead and get this bottom panel out of the way, and scroll up here a little bit so we can see both readDisplayStateValues and createNewNote, and you'll notice that in our original createNewNote, we set that class field, mNotePosition, and that's where we're using the do the get. Here in readDisplayStateValues, we're using a local variable called position, when we get the position from the intent, and then that's what we're using inside the get. Now it makes sense if we have a field for position, we should probably use that same field whether it's a new note or an existing note. So what we probably want to do here is up here we use this local variable composition, we should change this to use our field mNotePosition. Now I want to make that change where we get the value out of the intent into our field. Let's go ahead and take that mNotePosition, let's copy that, and then we'll paste it where we're using position. So we'll paste it here where we check to see if it's -1 and then we'll paste it down here where we do the get. Alright, so let's go ahead and run this guy again. So here we are running inside the emulator. Let's click our New button here. We hit our breakpoint. Our mNotePosition now has a value 8. So that is the index that was created for our new note, so let's let this guy go ahead and run. Switch back to our emulator. Okay, so that part works. Let's go ahead and cancel out of here. Let's go ahead and select an existing note and see if that works well as well. We hit a breakpoint, mNotePosition to 0, so that worked also. So we were able to go ahead and combine the get from our notes list. The thing is, we actually had to make sure we were using a consistent field for the position, which we've now done. And by being able to actually resolve the source of an unhandled exception by looking at the stack trays and then jumping to the lines of our code that were affected, we were able to easily resolve that issue. In our next clip, let's see how we can actually write our own log messages out so we can track our application's behavior without having to always stop it inside the debugger.

Logcat
Debugging is a powerful tool when we want to get into the details of exactly what a program is doing, walk through individual statements in the program, receive the value of variables within that program. But in many scenarios, it's more effective to simply capture logging information about what the program is doing or what it did and that's where a logcat comes in. Logcat is a system for recording log information. Now the way we interact with the logcat system is with a class called log and it provides methods for writing the logcat. And when we use the Log class, use those methods writes our a message along with a tag for that message. The tag is really just meant to kind of identify or somehow group the messages. The tag could be anything you want it to be, but commonly we use the class name of the class that's actually writing out the message. Now the Android Monitor, that same pane within Android Studio we used to track down that unhandled exception is where our logcat messages actually appear, and the Android Monitor is really powerful because we can do things like filtering the messages, as well as search through the messages. Now one of the powerful aspects of logcat is that messages are organized into levels and these levels indicate the relative severity of the messages. The log class provides methods for each of the severity levels. So each time we write a message with the log class, the method we choose to write that message with indicates what the severity associated with that message is. Then when we're viewing our messages, each of the messages are labeled with their severity and we can actually limit what levels are displayed within the Android Monitor to make it easy to kind of zero in on an issue. Now what happens is that whenever we're viewing messages with the Android Monitor, we select a severity to display, and whatever severity we select, its messages that have that severity or greater that are actually displayed. As we look at this idea of levels, remember that levels are used to indicate relative severity. So the most severe level is what's called the assert level. Now this is for messages or these are for errors that you never expect to happen and they're actually labeled with an A and they kind of indicate how severe assert level messages are. The method to write an assert level message is actually Log. wtf. Now documentation says that the wtf is for what a terrible failure. However the case, it's used to indicate that most severe level of message. Now in general, when we run into a problem and we want to log it, we'll actually use the error level and that indicates, of course, that an error has occurred. These are labeled with an E. The log method to write those out is log. e. And if we carry on, there's a warning level labeled as W and that log method is Log. w. And so these are the levels that indicate a problem. As we move above this, they're more about just kind of capturing messages. So there's a level info, which refer informational messages. That's labeled as I, method is Log. i. And then we get into our debug messages, messages that we capture just for debug purposes. They're labeled with a D and their log method is Log. d. And then the least severe message is what's called a verbose message, label is a V, and the log method is Log. v. So basically as we head down this table, each of these log methods log in message of increasing severity with Log. v being the least severe and that Log. wtf being associated with the most severe. But remember we said that when we view messages, we select a single level and the messages are shown of that level and higher. So as we head up the table, we're actually seeing that these levels get more inclusive. So if we actually have our viewing on the Android Monitor set to level assert, the only messages we would see are ones of the assert level. But if we then set that level to be error, then we would see both error and assert. If we set it to be info, we'd see info, warning, error, and assert. And then of course, if we set it to verbose, we would see all the messages. To get a better sense of how all this works, in our next clip, we'll actually update our program to include some log information and then take a look at that information within the Android Monitor of Android Studio.

Using Logcat
Here in Android Studio, let's update our NoteActivity class to take advantage of logcat. Remember we said that whenever we write out a logcat message, we associate a tag with it and that tag can be anything we want, but we can't always use the name of the class that's writing the message out, so what we'll have to do is go ahead and declare a constant named tag with a current class name, so let's go ahead and do that. So we're here in the first line in the NoteActivity class, let's declare that constant. And so we have that there now. And you'll notice that I'm actually using the getClass method and then calling getSimpleName rather than putting the literal NoteActivity there. And the reason I do that so that if I ever change the name of this class or if I take this line and copy it to another class, tag will always have the correct name for the current class. Now let's go ahead and write some messages out. Now one of the things that I like to do is write debug messages for the lifecycle methods. That way, if anything ever goes wonky, I can take a look at logcat and see what the lifecycle event methods that were running at the time were. So let's start with the onCreate method, so let's scroll down here. We've got onCreate, so let's go down to the very end of this and what I'll do here is I'll write a debug message that's Log. d, the tag will be our tag constant, and then my message simply be the name of the method. Okay, so we have that, so let's go over to our onPause method, so over here in the structure and we'll click on onPause and we'll do the same thing. We'll write a debug message, but with the string onPause. Alright, so we have those logcat messages in place. Remember we can actually set the severity level of what we view, and so debug is pretty inclusive level and that's what I'm going to try and track down my debug information, but you know there might be a little bit narrow level of information I want to put in there just to kind of track kind of general behavior of the application and maybe I'll use something like an information message. And something that might be good to use that for is keeping track of when the user cancels. So when they do a cancel, let's write a message out that simply indicates that they're cancelling and what the position is. So I'm still here in onPause. I'm going to go up here to the if mIsCancelling. I'm going to do a Log. i for informational message. I'm going to put the tag and my message, in this case, is going to be cancelling note at position and then the value of position. You know now that I'm thinking about this idea of writing informational messages with the position in it, you know it might be a good idea to write informational message each time the new activity is start with what position it's being started for. That way if anything unexpected happens, I'll at least know the note position where it happened, so we do that in our readDisplayStateValues. Let's go over here to our structure, let's choose readDisplayStateValues, and then here right before we actually get the note, let's go ahead and write an informational message with that position. Alright, so we've got some messages in there, so let's get ready to go ahead and run the application and see what the messages are. Now one of the cool things about logcat is that the messages get written no matter how we run it, whether we do a debug run, a regular run, or even as we release our application out in production, these messages are all captured. So it's a great way to figure out what's happening or what was happening when something went wrong. So the first thing I want to do here is go ahead and open up our Android Monitor. So we go down here to the tab and Android Monitor can often write a lot of information out, so one of the things that I like to do before I actually run an application is I right-click and I go ahead and just choose this clear logcat. That way any old messages are just out of the way. It avoids any confusion with something that was maybe left from an earlier run or that came from another place. Okay, so we've got that there. So let's go ahead and run our application now. Alright, so here we are inside the emulator, you can see there's some messages in there in the background, so let's go ahead and just choose let's say the first line over here, so we'll choose that. You can see some messages get generated as our NoteActivity opens. Let's go ahead and hit the Back button. Let's choose another one. NoteActivity opens and let's go ahead and cancel out of here now, so we do that. Alright, so let's go back here now inside of Android Studio. And now if you notice here, we've actually got quite a few messages here. Now let's look at a couple things we have access to kind of affect what shows up here. Now if we look at the drop-down over here on the left where it says Emulator Pixel_API_24. If I click that drop-down, now that curly only has that one selection in it, but this shows me what I can actually be looking at right now, so if I had multiple emulators running, there'd be multiple selections there or may have an emulator running and physical device connected, that would show up there. Here this next drop-down, these are a list of processes that I can actually monitor on that particular emulator. So we've got our current application selected there, notekeeper. Now notice that was important because over here on the right, these are actually filters, we'll talk a bit more about those in just a second, and the filter currently selected is the one that says show only the selected application. Alright, so it will only show messages that come from the application we have selected where it says notekeeper. Now let's do something here. Let's go ahead and set our severity levels here first. Let's take our severity level and let's select it in debug. You can see when I do that, I've still got a lot of messages in there, right, but let's see if we can kind of narrow this down a little bit. Let's go ahead and filter on the word say note and that cuts things down a bit. You can see that I grabbed some of my messages like NoteActivity with mNotePosition of 1 and NoteActivity onCreate. Let's take a look at what's in there. Let's take a look at what's in there. Let's look at the one with the onCreate and you notice there's a timestamp on that guy. Notice there's information about the process that's currently running. That's our notekeeper application. Notice that there's a D there indicating that it's a debug message and then there's a slash in that NoteActivity, that's our tag. And then what shows up to the right of the colon is our actual message, so that's the onCreate. Right now, again, we currently have a level of debug selected. Remember that shows everything at that level or higher, so we're showing both our debug messages and our informational messages. If I go up here and set my level from debug to info, we'll see that we actually lose those debug messages. I'm just going to scroll here a little bit, and so I've got my NotePosition of 0 messages there. I'm going to scroll down a little bit. See I've got my NotePosition of 1 message there and my NoteActivity cancelling note at position 1, so just the informational messages. Now something that's important to understand is that because there is so much information that shows up in logcat, we often need to be able to search through it or filter it. Alright, so let me go here and we could clear this out. I'm going to take this guy up to verbose for a moment. Okay, so when I do verbose, I'm going to go ahead and do a control F and that brings the find, so I can actually now do a search through here. So I'm going to search for NoteActivity and what that's doing now is doing just a regular string search through here and I can go ahead and click through and find any message that shows NoteActivity inside of it. Clear that out. Notice if I go up here to this filter box here, I can go ahead and type NoteActivity there and that also filters it down to NoteActivity, but again, it's just doing a regular string filter. The word NoteActivity shows up anywhere in the message it shows up here, and what I probably want to do, in this case, is filter it down to just those messages that have a tag of NoteActivity. So let's go ahead and clear this out. So what we're going to do is go around this right drop-down where it says show only selected application, I'm going to click on that, I'm going to choose this one, Edit Filter Configuration because it shows me the filters I can apply and it allows me to create new filters. So I click on that, what I'm going to do is I'm going to create a filter that filters on NoteActivity only in the tag field and what I'll do is I'll call this NoteActivity tag. And so now when I say okay, only those messages that have NoteActivity in the tag, it doesn't matter if the string NoteActivity appeared anywhere else, so it allows me to really zero in on that. If I want to change this, again click that drop-down, choose edit filter configuration, you notice that I could actually get much more specific about this. I could look for certain log messages, can limit the package name, or I could even set the log level associated with this filter. Alright, so these filters are a really powerful tool for identifying what's in the logcat. And again, because logcats can contain so much information, effective use of things like search and filtering are really important for using it efficiently.

Summary
To wrap up, here's one of the key things you want to remember from this module. Now as we've seen, Android Studio is really the central tool for Android development and not only helps installing all the tools we need, but it provides most the core features we use throughout the process of developing our applications. We've seen that Android Studio provides features to help with developer productivity. Things like refactoring allows us to easily evolve our code. Or Code generation, which takes care of adding a lot of commonly used code blocks to our application. And we've even seen it's customizable to our developer style so we can tell Android Studio how we like to do things like name our fields, do we like to see line numbers, how do we want to group methods inside of our source code, that sort of thing. We've seen the rich features Android Studio has for program execution and debugging, so it takes care of doing things like installing and then running our application. We have things like breakpoints allows us to stop in our code where we need to and we could even make those breakpoints conditional. And then code stepping allows us to step over lines of codes, step into methods, or step out of methods. A variety of ways to view the values of variables, and we could even do things like on-the-fly statement evaluation, so we can see what the result of a particular statement is that's a context of the current breakpoint. And then we have instant run, which accelerates the process of deploying our code changes. Because rather than install the entire application every time, it does just enough to apply those changes. And oftentimes when using instant run, the app can even keep running. When we need to resolve unhandled exceptions, Android Studio provides the information we need in the Android Monitor, so it has the crash information, it shows the exception along with the call stack. And in the call stack, we even have links to our source code so we can jump right from the call stack to that line of code in our application. And then finally, we have logcat. Logcat was at system for recording log information and allowed us to record the information with a tag and associated severity level. We write the logcat using the Log class and we're able to view the information using the Android Monitor. In our next module, we'll start looking at the Android build system known as Gradle.

Understanding the Android Studio Build Process
Introduction
Welcome to the Understanding the Android Studio Build Process module of the Pluralsight course, Working with Android Tools and Testing. My name is Jim Wilson. In this module, we're going to look at the key things we need to understand in order to effectively work with our applications build process. So we'll start out by looking at an overview of the Android build process and the role Gradle plays in that process, look at how we modify Gradle parameters, we'll then look at how we specify application dependencies in Gradle, and then we'll finish up by taking a look at the Android support library.

Android Build Process and Gradle
When it comes to building our Android applications, if we had to manually manage all the details involved in building the application, it would actually be somewhat challenging because there's a number of different tools that come together to actually complete the full build process. So to help us with that, Android Studio leverages something called Gradle, which simplifies our build process. Now Gradle is actually a general-purpose build system and there's an Android plugin that plugs into Gradle to actually give it some Android-oriented features. So if we think about what goes on when we build our Android applications, now we know we have our source files and our resource files, and as your applications get more complex, there'll be a few other file types you might build into that as well. And as you have those files, we ultimately want to produce what's called an Android package file or what we commonly call an APK file. Now obviously, we can't get from those source and resource files directly to that APK file something has to happen between there. Now of course we know that there are compilers. In other words, the resource compiler, there's the Java compiler, and there's some other tools that might be involved, but there's also dependencies. Some of those dependencies are Android specific, some of them might come from third parties, some of them might even be other things that we're creating ourselves that go into making this application. So as all that stuff passes through the compiler as we ultimately produce some intermediate files. So now we've got to get from these intermediate files out to the APK. So there's actually an APK packager tool, and of course, the intermediate files go into the APK packager, but there's more to it. There's still things that need to be known like what's the version information for our application, what's the minimum version of the SDK that we want to support, what target SDK have we actually tested this against. So all that stuff has to be managed so that we can ultimately create an APK file that is a deployable version of our application. So to help us with all that, that's where Gradle comes in. Gradle actually automates all this for us so that we can kind of focus on just building our application. Then keeping track of all that information in terms of dependencies and so forth is actually centralized with Gradle. There are a few different files associated with Gradle, but the one we normally deal with are the ones called build. gradle to give us a place to kind of put the configuration information of our build right inside just a few files. Now Gradle is extremely powerful and it's very flexible. In fact, it actually has its own domain-specific language, so in effect, it actually has its own kind of programming language. And so as you work with Android more and more, it's worth trying to understand Gradle as you use it because it gives you a lot of flexibility, allows you to create different build variations to your program relatively easily, so it's really worth understanding. But it turns out that the common things that we deal with in Gradle are actually pretty easily managed because our Android Studio projects will actually generate some starter build. gradle files for us and most the things that we commonly need to do can really just be simple edits to those Gradle files. Now the Gradle files are always going to give you the most complete access to the capability of Gradle, but Android Studio helps out the many of the changes that we commonly want to make can also be made through the Android Studio UI. So if we go to the File menu and choose Project Structure, we could actually set a lot of things from inside of there. Now they'll ultimately end up in the Gradle file, but it gives us a UI for doing it. To get a better sense of how all this comes together, let's take a look at some of the Gradle values in our next clip.

Modifying Gradle Parameters
Here we are in Android Studio, and before we look at the Gradle information, I just want to point out something important here in the Project window. Now the Project window is this window off to the left here that shows the files and so forth make up our project. Now up at the top left, there's a drop-down there that lets you select different views for the Project window. So if I go up here, one of the ones we have access to is say the Project view. So the Project view in the Project window basically shows me everything under the directories for the project. So if I expand this down, see there's a whole lot of folders down here, I can just kind of jump around, a whole bunch of stuff inside of here. Generally, we don't want to be working in that view. What we want to do instead most of the time is be up here in our Android view making this a very Android-friendly view of the project and it's very focused on the files that make up our project. Now why that's important here is you'll notice at the bottom there's actually a section that says Gradle Scripts. So I'm just go ahead and collapse the Java note here, we've got our Gradle scripts, and let's go ahead and expand that. And these are the files that affect Gradle. Now if we look at this, you'll see that there's actually two different build. gradle files there and there's one at the project level, which is the first one, and then one that's at the module level. Now in Android Studio terms, a project is kind of this overall project, everything has to do with a particular project that we're working on. A project then has one or more modules in it. Now by default, when you have one module, which is our app module, that's our module related to building our application. In some scenarios, you may have multiple modules in your project, and in those scenarios, it's common to have the other modules be what are called the library modules, so it's code that you're building in a way to reuse it with different applications. In our case though, we only have the one module, which is the app module. Now the reason that's important is that if we had multiple modules in this project, we'd have an additional build. gradle for each of the modules. Now the first one here, the project-related one, this is where settings related to the overall project appear. And for things we commonly do, we don't need to get into that project Gradle file. What we tend to work with much more is in the module Gradle file because these are the settings particular to our module, so I want to double-click on that, and you'll see here that towards the top there's a section labeled Android and this is kind of the general settings for building this module. So you'll notice there are things like the compileSdkVersion and that indicates what version of the Android SDK are we using, 24, which we know corresponds to Android 7. Then there's the buildToolsVersion and that just indicates which version of the Android tools do we want to use. I'm using 25. 0. 1. Then you see there's a section now called defaultConfig. Now the reason there's a section called defaultConfig because Gradle supports having multiple configurations for the same module or, in this case, for the same application and that's great when you may have different behaviors targeting different platforms and so forth, but for the simple case we have just this one, defaultConfig, and it identifies things like the applicationId. That's what our application is going to be known by in the play store. The minSdkVersion, what's the minimum version of Android our application supports. What's the target version? And what the targetSdkVersion indicates is what kind of behavior are we expecting. If at some point in the future Android were to change the behavior of certain APIs and is our application expects in the work the way they did at SDK 24, so we can create a consisting environment for our application. And the next two, versionCode and versionName, they identify our application versions. Alright so the versionName is the version as it's displayed in things like play store or in our device settings. The versionCode is the integer version, which is just an incrementing value to identify that we're moving from one version to the next. This should look pretty familiar because it's the way Android versioning works is that the Android platform has a version name, things like 7. 0, 6. 0, 4. 4, but then there's also the integer versions like 22, 23, 24. So our application has that same idea. An integer version, which we use to have increasing values to indicate that we're moving from one version to a next and then a versionName, which is just a friendly name to display for our versions. Now one thing to keep in mind is that if you make any changes to the Gradle file, you'll need to sync Gradle, and when you make those changes in general, Android Studio will display a bar across the top indicating that you need to sync now, other words, you need to sync the Gradle files now, and I'll go ahead and make sure that it has everything it needs, confirm that all your settings make sense. But also note that at any time, you can still force a sync by clicking on the Gradle sync button there, which will then do the same thing, make sure you have everything you need and confirm that the Gradle settings you have are actually valid. Now in addition to being able to control these Gradle settings inside build. gradle file itself, remember we mentioned that we can also do it through the Android Studio UI. So I'll go right here to the File menu and then I choose Project Structure, see we get this dialog here. Now there's a number of different selections down the left-hand side. We want to, again, choose the one that's associated with our module, so our app module. And you'll notice here that in the first half, the Properties tab, well there's the compile SDK version and the build tools version, the same things we saw inside the Gradle file. So if we change them here, they'll actually be changed in the Gradle file. This is just a UI allows to do it instead of having to edit the file. If we go over here to Flavors, notice that there's that name defaultConfig just like there was in the Gradle file and there's the min Sdk version, and the application id, and the target Sdk version. Alright, the same sort of things that we were seeing inside the Gradle file or even our versionCode and our versionName. So this is just an alternate way to interact with those build settings. So we can do it here in the UI or we can do it out in the Gradle file itself. Okay, so now in our next clip, let's look at the idea of dependencies.

Understanding Dependecies
As we've mentioned, most applications rarely stand-alone. Instead, those applications have dependencies. Alright, so in our build process we have to specify those dependencies. Those dependencies might be an external binary file or they might be a library you're building as part of the same project. But whatever the case, when we're building our application, we need to list our dependencies in Gradle. Now we do that in our build. gradle file in the dependencies block. So in that dependencies block, we need to list any of our direct dependencies, but one thing that's nice about Gradle is that if any of those dependencies also have dependencies, Gradle will take care of going ahead and including those as well. When it comes to dealing with dependencies, there are two basic things we need to understand. The first is dependency types. Dependencies fall into three types. There are module dependencies, which is simply dependency on another module from your project. There are jar dependencies, which are dependencies on a Java jar file. And then finally, there are library dependencies, which are dependencies that actually pull things from a repository. A repository is simply a collection of binaries we can access. We can have some repositories on our local machine. So we can have the Android support repository and the Google repositories and these contain binaries that we commonly need to build our Android applications. So we don't have to do anything special to get Gradle to look on our local machine for these repositories. Beyond those repositories, they actually have to be specified. Now when we generate a brand new Android Studio project, the build. gradle files that are generated for us include a reference to the jcenter repository, which is just a massive Java repository. But you can also add other repositories if you need to by modifying the Gradle file to look for those repositories as well. Now in addition to understanding dependency types, we also need to understand how we associate dependencies. Most dependencies we want to associate with are build variants, basically, just all the different kinds of building we do. So there's actually a compile directive, and in the compile directive, we identify a particular dependency and that dependency will be applied to all of our build variants, all the different kinds of builds that we do. But one of the things we'll talk about a little bit later in this course is testing. And so we can build testing specific variance. Now there's two kinds of testing that we commonly do, one is JVM testing, other words, tests that rely on just the Java environment. We don't really need all the Android environment. So any dependencies that we want to specify particular to our JVM testing, instead of using the compile directive, we use the testCompile directive. Now there's another kind of test called instrumentation tests and those are tests that actually rely on the Android environment and we want to specify dependency. For those kinds of tests, we use the androidTestCompile directive. Now again, we'll talk about these testing scenarios much more later in this course. The key thing we need to understand for right now is that when we specify a dependency, do we want that dependency to be specified for everything or do we want it to be specified just for a particular testing build that we're dealing with. To get a better sense of all of this, in our next clip, we'll take a look at how we specify dependencies in our Android Studio project.

Specifying Gradle Dependencies
Here on Android Studio, we're looking inside the same build. gradle file we looked at earlier. This is the one for our app module of our project and we see we have this dependency section here at the bottom, it specifies our dependencies, and notice that most the statements in there begin with the word compile indicating that these are dependencies for all of our different build variants, but you'll notice that there is one at the bottom for test compile, which says that the dependency just used for our JVM testing, and there's another one further up in the dependencies block for AndroidTestCompile saying that's a dependency for our Android instrumentation testing. We'll talk more with those guys a little bit later in this course when we look at testing. Now you notice that the first line of dependency there is a compile that says fileTree and you'll notice it has dir value of libs and it said include *. jar. What that says is look inside the libs folder under our current project, so underneath our NoteKeeper project and any. jar files that are inside that libs folder, brings those in as dependencies. So basically, the easiest way to add a jar dependency to our project is to simply put it in the libs folder underneath our NoteKeeper folder or our project folder because Gradle is configured to look inside that libs folder for all the. jar files. Now our Android project has only one module in our app. We don't have any library modules in it, but if we do, we can reference those from right here inside the gradle file as well. For example, if we included a MyHelper library as part of this project, we could reference it from this gradle file by simply saying compile project and then saying :mHelperLibrary. And notice though that we have a number of compile entries here that have fairly long names in them. Look at the one, com. android. support:appcompat-v7:24. 2. 1, right, and that's a library dependency. It's actually coming from a repository and that's a dependency that actually comes from Android support and we use those quite a bit. And the way the naming of these is identified is around the colons. The value there com. android. support before the first colon, that's actually considered the namespace group for that particular component. Name of it is appcompat-v7 and then the version is 24. 2. 1. Now don't get too hung up on that. Most of these that we need will actually specify how they are identified inside the repository as we look at the documentation for them. Also, in many cases, Android Studio does a pretty good job of bringing in ones that we need. For example, the entry there compile com. android. support. constraint:constraint-layout:1. 0. 2 is actually the reference to the library that provides the constraint layout we were using back in the first course in this series. Just like the other Gradle values we talked about earlier, we can actually specify dependencies here in the Gradle file or using the Android Studio UI. If I go over here to File, then Project Structure, choose that, notice the last tab here when we have our current app model selected is dependencies, we choose that, and you'll see a list of dependencies from our dependency block that we had in our build. gradle file. If we want to add a dependency from here inside the UI, we can go over here to the plus sign. We choose that plus sign, you see we've got a module dependency, though if we select that, it'll give us a list of the modules in their Android Studio project that we can select from. There's a jar dependency entry there. If we select that, it will actually allow us to browse to a location of a jar file on our computer, and then we have our library dependency and let's select that. And you can see that it actually lists some of the libraries that we can actually bring in as dependencies. If we type a name in this box here at the top, it'll actually filter it down for us or we can just scroll through and select. Alright, so let's cancel out of here. One of the areas where we're allowing dependencies a lot in our Android projects is when using the Android support libraries. So in our next clip, let's take a look at the Android support libraries and just get a sense of what they are.

Android Support Library
The Android support library is a really important part of Android development. Basically, it supplements the Android SDK and one of the key things it does is it provides backward compatibility. One of the issues that we often have with Android is that as new versions of Android were being released it was introducing new features, but there was still a large user base using phones with older versions of Android on there, so to help that, initially the Android support library was focused on this idea of backward compatibility. Basically, making some of the newer platform features that were coming out with these new Android versions available to older platform versions and we'd do that by providing alternate classes, so they would have classes with different names to indicate these were support library classes and they would provide some of those features. And again, that was really the focus of the support library in the beginning, but over time, this poor library has actually grown quite a bit. So now in addition to providing backward compatibility, it also provides some convenience and helper classes, other words, they actually provide features that are not part of the platform. One of the areas where this really comes up is in the user interface and we'll see some of these a little bit later in this course series, things like recycler view or the card view and a number of other classes like that. And in addition to that, the support library includes a number of other things way to debugging, testing, and other utilities. In fact, the testing support library is a really important part of testing, and later in this course, we're going to look at some of those testing features that are provided by support library, particularly in the area of UI testing. There are also things that do enhance code checks just to do better code checking during the build process and so forth. And even some special case utility for deploying application some special scenarios. Now the organization of the Android support library can get a bit confusing. It's important to understand that its evolved a lot over time. Initially, the Android support library was just that, a single library that was the Android support library, and it was very focused on this idea of backward compatibility. But as time has gone on as we've added more and more to it, it does more things than just backward compatibility as we talked about, as well as it could actually get sizable so it had to be broken up. So now it's organized so that we won't have to have one large binary, one huge single library file we bring into our projects, but instead they're grouped, and most of the grouping is based on platform support. So the name of a support library historically indicated the minimum platform it supported. For example, there is the v4 support library and that doesn't mean it's version 4 of the support library. It means it's a support library that supported devices running API level 4 and up, other words, devices running Android 1. 6 and up. So then there was the v7 support library. Wasn't version 7 of the support library. It was the support library that actually support API level 7 and up, other words, Android 2. 1 and up. And then another example would be the v13 support library, the support library that supports devices running API 13 and up, which is Android 3. 2 and up. But as time has gone on, even that has actually changed. Starting with the support library releases that came out in the latter half of 2016, no library supports less than API 9. So the v4 support library supports API level 9 and up. The v7 support library supports API level 9 and up. Whereas the v13 library still supports API 13 and up. So it gets a little confusing and don't get too hung up on that. I'm going over this just so you don't get confused when you see it. These are really old versions of Android, and in most cases, you're not going to really have to worry about devices running versions that old. But now within these groupings, there are specific libraries and those specific libraries are tied to features. So each of those groupings will generally have multiple libraries inside of them tied to specific features. It's these individual libraries that we're going to reference from inside of our Gradle files. So to get a better sense of all this, in our next clip, we'll take a look at some of the Android support libraries and that'll go closer to the information for those libraries that's in our Gradle files.

Understanding Android Support Library
Here our page that shows the list of Android support libraries. Now if I scroll down here a little bit, you see there's a section here for the v4 support libraries, and inside there, you see a link that will actually take you out to a full description of what's in the v4 support libraries. So you just check that out if you want to know what's specifically in the classes tied to the v4 support libraries and that's going to be true for all of the various libraries here. If I scroll down a little further, you'll notice that there's the v4 compat library, the v4 core-utils library, v4 core-ui library and these are all libraries within that v4 support library group. And so once you identify which features you want and you know what library it's a part of, you'll notice that these libraries then have the Gradle information inside there. So the v4 compat library, you see there is the Gradle entry for com. android. support:support-compat and then a version number. So if we need to access the classes that are in that library, that's what we add to our Gradle file or we add a compile statement with that name. So as we scroll down here, we'll see that we have the information we need for all these various libraries. So we scroll a little further, here we have the v7 support libraries and the v7 appcompat library, scroll down a little further, you see there's the cardview library, we'll actually use that one a little bit later in this course series. There's a v7 gridlayout library, mediarouter library, palette, and recyclerview library, that's another one we'll use a little later in the course series, so they're the v7 ones. Scroll a little further. You see there's the v8 support libraries, v13, v14, a bunch of v17 libraries. Then notice eventually the libraries even stop having the version numbers in there. There's an annotation support library, design support library, custom tabs support library. So as you can see, there's a lot of different support libraries out there, which means there's a lot of different features and capabilities available through these support libraries. So just be willing to explore them and see what's out there. Let's now switch to Android Studio and look at our Gradle file. Here we are in the build. gradle file for our application, and as we've talked about before, we have compile entries in here for support libraries. We've got one for the appcompat v7 library, one for the constraint-layout library, and then one for the design library. Notice that each of those have a release number, that's a value after the last colon, so for example, the appcompat v7 release numbers 24. 2. 1 and notice that's separate from the version in the name. The v7 in the name initially indicated platform support. This release number is actually identifying what release that library is. And you notice that the appcompat v7 library and the design library are both highlighted in yellow. Let's go and hover over that. You notice it says that hey there's a newer version of this guy available, you're on 24. 2. 1 and there's a 25. 3. 1 available. And of course, when we see something like that, well geez, that sounds really good. I must want that. So let's go over to the yellow light bulb, click on that, and it says change to 25. 3. 1, so let's do it. You'll notice now that there's a red line under our appcompat v7, and so if I hover over that, it basically says that hey you're using a different version than your compile SDK version and that's something that's important to keep in mind. We don't always want to use the very latest version of a particular library. In general, you want to use the version that's the most current for our compile SDK version. So let's go ahead and switch this guy back. And so now we're again on 24. 2. 1 and the way we know what compile SDK version that goes with most of the libraries is that very first number there. Notice that the release version on our appcompat v7 starts with a 24. Well notice our compile SDK version is also a 24. So in general, when we're working with these libraries, we want to use the release that ties to our compile SDK version. There are certainly exceptions to that, for example, the constraint layout uses a different numbering system, but for most of the libraries, that guideline applies. So now Android Studio has noticed that I've actually made a change to the Gradle files, so it's asking me to sync now, so it's good. I'll just click on that. I'll just go ahead and bring everything back in line. Now remember we said that these Android support libraries actually come from a repository that's on our machine, and that repository is actually installed as part of the Android SDK. So how can we tell if our machine is set up right? Android Studio is supposed to take care of all that for us and we can actually check it out by going and looking at the SDK manager. You notice we have a button there for the SDK manager. Let's go ahead and click on that guy. So what that does now bring up a dialog and one of the things it will let us do is install additional versions of the Android platforms if we want to and notice there's also a tab here that says SDK Tools and it shows the various tools that are here. Let's scroll down to the bottom, and you notice that down in the support repository section, there's one there for Android support repository and it's checked. So it just shows me that that's properly installed on my machine. Now if you wanted to explore around and see what was actually installed on your machine as part of the Android SDK, notice at the top of this dialog there's actually an entry that says your Android SDK location. So if you go out to that folder on your machine, you can actually see all the contents of the Android SDK and I encourage you to explore that. Let's go ahead and cancel out of here. So now the support libraries themselves are a really big topic, and again, we'll visit aspects of them throughout this course and throughout the course series. The key thing to understand here is that Android support libraries are a central part of your Android application development, know they're there, explore around, and just get a sense of what's available.

Summary
Here's some of the key things you want to remember from this module. Remember that Gradle manages our application build process. Although the underlying details of how an Android application is built may be involved, Gradle simplifies that for us a great deal. Now as we work with Gradle, remember that we will have to deal with some of the settings and the common settings we deal with are actually in the build. gradle file. Now don't forget that there are multiple build. gradle files. There is one for the project level settings, and then there's one for each module level setting. Now most of the changes we want to make are actually going to be at the module level, the ones that are specific to our application. Now we want to make changes to those settings, remember there are two ways we can do it. We can edit the gradle file directly if we want to, but also many of these common settings are exposed through the Android Studio UI. I do encourage you to get comfortable with working with build. gradle because the gradle file is going to give you the most complete access to the features that gradle provides, so as you get more experience, you can dig into those capabilities further and further. Remember that as we create our applications, our applications will have dependencies and there are three general types of dependencies. There's a module dependency, which simply means that our project may be building libraries up for us so we may incorporate into our application. We can use Java jar files as dependencies. But the ones we deal with most frequently are generally the library dependencies, the ones that are pulled from a repository. Now these dependencies have to be associated. Most of the dependencies will generally be associated with all our build variance. So we actually used a compile directive to specify those dependencies. We can also have ones that are tied to our JVM test, which uses a testCompile directive, and then there are those that might be tied to just the instrumentation test, which are our UI tests and those are specified with the androidTestCompiler directive. We'll see more about testCompile and androidTestCompile a little bit later in this course. And then we looked at the Android support library and we mentioned that although the Android support library started out as being focused on just providing backward compatibility with features, it's grown tremendously since then, so the Android support library also includes convenience and helper classes and then things related to debugging, testing, and utilities. So the Android support library is a really important part of our application development these days. And as we look at the Android support library organization, it's a little bit complicated just because of the way it's evolved every time. Most the libraries are grouped by platform support and there will generally be multiple libraries within each of those groups. And then once you identify what specific library you're interested in, the documentation for that library will provide you with the Gradle information you need to incorporate that library into your application. Well that's it for this module. In our next module, we'll start digging into the details of how we can automate our application testing.

Using JVM Testing
Introduction
Welcome to the Using JVM Testing module of the Pluralsight course, Working with Android Tools and Testing. My name is Jim Wilson. Good quality testing is an essential part of modern application development. In this module, we're going to look at the features of Android Studio that allow us to quickly and efficiently create and run Java-based tests to help us improve the quality of the apps we develop and we'll start out by looking at just the basics of testing. We'll then look at how we create something called unit tests. We'll see how we can use Android Studio to execute those unit tests. We'll talk about how we can assure that our tests run consistently. And then we'll wrap up with a brief discussion of a testing philosophy known as test driven development.

Testing Basics
Software testing has been around as long as we've had software development, but for a long time, software testing was really kind of an ad hoc process. You'd write some code, you'd run the program, you'd do a few manual tests, things look okay, ah, I tested my software. Well now that's no longer the case. Testing is now a core task of our application development and it needs to be a core task because it's essential to delivering quality software. Software is just too sophisticated now to rely on a few manual tests to be sure things are okay. Now as we go through the rest of this course and the rest of the series, we're going to focus on a type of testing known as functional testing and functional testing focuses on the idea of does my application meet the business requirements or specifications and that's distinctly separate from what we call non-functional testing. And non-functional testing is testing things that are not part of those core requirements, and that might be things like security testing or performance testing, that sort of thing. So when we look at functional testing, what we're really focused on is verifying that things behave as we expect, but now a key part of that is that being sure that not only they behave as we expect when we first write them, but making sure that any changes we make don't break things, what we call breaking changes, and that's the idea is that when I originally wrote the code it was fine, but then I made some changes elsewhere in the application and that had unexpected side effects that broke other things. So that's going to really be our focus in this idea of functional testing. Now we're going to look at two specific aspects of functional testing. First, in this module, we're going to look at what we call unit testing and unit testing, as this name implies, is that we want to test individual units of code. And generally speaking, each unit that we test is going to be relatively simple, so each test unit is really going to focus on a specific feature or behavior, oftentimes, it's just one particular thing a method might do. By doing things that way, we're able to actually verify the fundamental aspects of our application. So as we work with unit testing, we will generally have many unit tests because each individual test focuses on a very narrowly-defined set of functionality, we're going to need lots of tests to verify all our functionality. Now another kind of testing we'll talk about in the next module focuses on this idea of integration testing. Integration testing is testing how the pieces come together. Basically, when you move away from individual features up to application level behaviors and often this kind of testing involves testing of the user interface. And again, that's what we'll talk about in the next module. In this module, we'll focus on this idea of unit testing. Now one of the key aspects of using unit testing effectively is that we want to be able to run our test often. So pretty much, after we do any of our code changes, we're going to want to go ahead and run our unit test and certainly before we check our source code into any kind of source code control, we want to go ahead and run our unit tests because we want to always be making sure that things are working as expected. And generally, we want to run all the unit tests. Now as we're going through and in a process of making an individual change to our code, we may run one or a few unit tests just to kind of verify that as we go, but no application change we make is complete until all the tests pass. Remember that we're not just trying to test the functionality that we're implementing, we also want to make sure that any changes we make don't break other aspects of our code. So that means then is that we're going to have a lot of unit tests and we want to run all them a lot. Ideally, we need to be able to run our unit tests quickly so we're not spending a lot of time unnecessarily waiting for these tests to run. So now as we think of this idea of testing our Android applications, this introduces some challenges for us. Remember that our Android applications, in order to fully test them, we actually need the Android environment or we need all those aspects of Android that we're using to fully test our application. And in order to do that, we're going to have to run those tests on an emulator or on a physical device, but that can make actually running all of our tests all the time kind of challenging. What we really need is a way to efficiently run our unit tests. We want to limit how often we need the full environment so we can do some kind of lighter testing along the way. Now we'll talk about how to do that in our next clip.

Efficiently Running Unit Tests
So how can we efficiently run unit tests. Now let's think about how an Android application is put together. Now an Android application actually kind of has two parts to it if we think about it. There's the Java-based behavior, that's all of our application logic that might be dealing with data that comes back from user interface, it may be preparing data to send to the user interface. And then there's the actual Android-based behavior where we're actually interacting directly with the Android SDK libraries to actually have Android do something for us. Well what if we could separate the tests for those two behaviors. What if we could have one set of tests for the Java-based behavior and then a different set of tests for the Android-based behavior. That way we could do all the work of testing our Java-based work without actually needing the entire Android environment. And in fact, that's exactly what we do. Using Android Studio, we can actually officially run our unit test by having the Java parts not just run separately from the Android-based behaviors, but actually run locally, other words, leverage the Java virtual machine that's on our desktop or workstation. So we can actually test out the Java parts of our application without involving a device or an emulator or anything. We can actually leverage the ease of testing that code directly on our desktop or workstation. Now by working with Android Studios, we set up our application, it actually makes this really easy for us. As we used Android Studio to generate our application project, it actually took care of setting up a separate source set for a JVM test force and that's all set up to use a tool called JUnit 4. If you're not familiar with JUnit, Junit is one of the most popular unit testing environments for Java and it makes working with unit tests really simple. Now Android Studio makes it really easy for us to manage these unit tests because we can basically not just run our unit tests, we can actually debug them. So we can actually step through them line by line if we're trying to figure out what a problem is. We can run individual tests, we can run a group of tests, or we can run all our tests, and we can view our test results directly in Android Studio. It actually indicates the success or failure of each test by color. Now one of the real powers of working with JUnit is that each test really kind of stands on its own. We're not really involved in the details of setting up the testing environment. Well, all we really need to do is write our unit test methods, so each unit test is its own method. We simply mark that method with the @Test annotation and then JUnit will take care of the details of actually running each of those tests for us. So we don't have to worry about any of the details of managing all of those things. We simply just code up our test and then JUnit in cooperation with Android Studio takes care of those details of running them and getting the results back to us. And when we work with JUnit, we actually group our tests in the classes. Now those classes are primarily just for organizational convenience. There's no super magic to how you organize tests within a class, but it does allow us to execute tests as a grouping because we can execute all the tests within a class easily and it also allows us to group, setup, and teardown behaviors for our tests. We'll talk more about that a little bit later in this module. Now I see we're running tests, we're trying to see if things are working correctly and that's where the Assert class comes in. Assert class allows us to, in our tests, indicate what our expected results are and it'll take care of failing our test for us whenever one of those expectations are not met. The Assert class provides a number of different methods we can use. Here is just a few examples. The one we use a lot is assertSame where we pass in two references and if both those references point to the same object, then the assert is true and the test will pass. If they don't point to the same object, then the assert is false and the test would fail. AssertEqual, we pass in two references. It doesn't pass the equals test. In other words, they don't have to point to the exact same object, but the equals methods must return back true for those objects. Another one is assertNull, other words, is a particular reference actually null. And there are many others besides this. And in addition to these, there's also negative versions of most methods. So there's an assertNotSame or assertNotEqual or assertNotNull. Alright, so to get a better sense of how all this works in our next clip, let's write a simple unit test.

Adding a Unit Test
Here we are in Android Studio. Let's get ready to build a simple unit test, and before we do that, let's just take a look at how unit test are organized within Android Studio. So we look here in Android Studio, we have our Project window and we currently have the Android view selected. Now look in the Project window under the Java folder, we have the source code we've been using to build our application, but if we look a little further down, notice there's another source code folder that actually has test in parentheses and that's where our unit test code goes. So if I expand that folder, notice there's one class in there called example unit test, if I double-click on that, hooking that guy up, this is a unit test class that was generated for us automatically when creating our application project. It's just provided to give you an example of what a simple unit test looks like. It's got a class, it's got one method in it marked with a test annotation, and it has the simple use of the assertEquals method. Alright, so let's get rid of our own unit test now. So let's go ahead and close this guy up and what we'll do for our unit test here is let's go to our DataManager class. Now you remember from the first course in this series that our DataManager class is responsible for managing our data, keeps track of our notes, and that sort of thing. If I scroll down here just a little bit, you'll notice there's a method here called createNewNote and we use that to, as its name implies, create a new note. Now as you may recall, the way we use createNewNote is we actually call it, it creates a spot for a new note, and that's an empty note, gives us back the index, and then we're responsible to actually populate that note. So what we want to do is maybe go ahead and write a test and make sure that all this works correctly. Now the way we do that is we need to be inside the class we want to test, which we are, DataManager class, and then what we do is we go up here to the Navigate menu and go down to where it says Test. Now note that we can also do the same thing with Ctrl+Shift+T. So let's go ahead and select that and see what happens. Now you notice here that it says that there are 0 tests found for DataManager because we haven't created any yet, but we have the option to create a new test, so let's go ahead and select that. So now if we look here at the create test dialog, notice that we can go ahead and change the test class name to the default one is DataManagerTest, let's go ahead and accept that. Want to go ahead and keep it in the same package we're working in, that's fine. But if we look down here, we can actually choose which methods we want to generate unit test methods for. Now we can just select the ones we want for right now. We can actually add other ones later. So we'll go ahead and choose this one here createNewNote. We'll say OK. Now it says well do you want to put that in the Android test or the regular test folder, and that's what we want, we want the regular test folder. The Android tests are tests that actually require the Android environment. We'll talk about those in the next module. So we'll go ahead and accept the regular test folder there, so let's say OK. So now as we do that, we're in the test class, DataManagerTest, and notice it's gone ahead and created a method for us called createNewNote, we can change the method name if we want to, but notice the key thing here is it has that test annotation on it and that's what JUnit is going to need to know that this is a test method because the way the unit testing environment works with JUnit is we're not going to write any kind of program that actually run. We're simply going to write the test methods. JUnit takes care of all the work of creating a process and those sort of things, so we're focused very much on our tests. Now you'll notice our test method here, createNewNote, is marked with throws Exception. We generally want that in our test methods so we don't have to have a bunch of try/catch blocks in there. Alright, so now that we have our test method in place, let's dig into the details of implementing and running the test method in our next clip. So let's go ahead and write our test code now.

Implementing and Running a Unit Test
Now one of the things we have to remember is that in order to create a new note, we're going to need three things, a course, a note title, and note text. So first of all, we'll go ahead and create our course and what we'll do is just declare our variable here of type CourseInfo called course and we'll mark it as final because we're not going to change it. Okay, so now go ahead and create that course, we're going to need the DataManager, so let's go ahead and get the Instance. Now once we have that DataManager instance, we want to go ahead and get a course, so that'll go ahead and get the course associated with the identifier android_async and put it in our local variable there, course. Now of course, we're also going to need a noteTitle and noteText, so let's go ahead and create variables for those. Okay, so we now have all the variables that we need to create our note. So now we're ready to go ahead and create the note, but remember that create a note, we need a reference to our DataManager again. Now we could call DataManager. getInstance to do that, but we know we've already done that once inside this method, so maybe it makes sense to go ahead and get the instance once and assign it to a local variable. So let's see if we can use refactoring to help us with that. So I'm going to go up here where I already call DataManager. getInstance, let's highlight that, and once it's highlighted, let's right-click, let's choose refactor, let's choose Extract, and let's choose variable. So basically, says well what I want this variable name to be and I'm just going to call it DM for DataManager. So now I have a data manager reference in my local variable here called dm, and given that, I can go ahead and call dm. createNewNote and take the index that's returned and assign it to a local variable. So now once we have that index, we can go ahead and get the note that's associated with the index, so that'll return it back to note that's associated with that index. Now remember that's note empty. What we need to do here is go ahead and set the course, the title, and the text. So now that's all the code that we would use to create a new note. Alright, we've got all the values that we want to have with a note, we called createNewNote to create a spot for the note, got the index back, got the note associated with that index, and we've set all the values. So at this point, we've used the functionality of createNewNote, but we haven't tested anything yet. Alright, so in order to test things, what we need to do now is decide what it means to test this. What do we expect to have happen? Well, what we would expect to have happen is that once we've created that note with those values, if we went back to the DataManager and asked for a note at that index, we would get back a note with the values that we've put into that spot. Alright, so what we want to do then is in order to actually do the testing is go ahead out to the DataManager, call getNotes, and then get a note back that's at that index. Now if you're new to unit testing, you may be watching this and going oh that just seems really simple. Alright, but that's the point of unit tests is it created a bunch of simple tests, so when you run across the whole set of tests, it gives you a really accurate picture that all the parts of your program are fundamentally working. Alright, so what we want to really do at this point is make sure that compare note contains the things that we've put into the note at that spot. Now one of the things that's really important to remember is that when we're building our unit tests, we don't want to focus on implementation details. What we want to do is focus on functionality. Does it behave the way we expect it to from a user standpoint not being tied to the details of implementation. The reason that's important is that over time implementations often change, but even as implementations change, in general, we want to keep those behaviors the same, so we want to think about things at a functionality level. So what we want to do now is compare whether this note called compareNote has all the values we put into that newNote variable. Now remember, we're going to use the Assert class to do this. Now let me go up here to the import at the top and expand that for a second. So go up here by the import and you notice that under the import, the Assert class is a static import. Remember that in Java, static import allows us to use the static members of that class without using the class name. What that means then is that we can actually use the method names almost as if they're statements. Alright, so let's go ahead and collapse this. Now here's one possible test that we could put in place here. One thing we might want to do is just do an assertSame. Remember, assertSame checks to see if two references point to the same object, so I want to say assertSame, newNote, and compareNote. Now remember, assertSame is a method on the Assert class, but because the Assert class has a static import, we can simply use the method name assertSame. Now the way createNewNote is currently implemented, assertSame would be a valid test. It basically makes sure that we got back the exact same note we put in there. But that may not be a really valid test from functionality standpoint. From a functionality standpoint, what we really want to do is just make sure that the note that comes back from that index has the values we put in there. We don't care if it points to the same note or not. So that's not really a good test from a functionality standpoint. What we want to do is actually check the values that we've put into the note. So let's take this statement away, and instead, check the individual value. So instead of using assertSame, let's do an assertEquals, and what we want to do is get the compareNoteCourse and compare it to the course that we put into the note when we created it. Now we want to do the same thing for the title and the note text. So now this is a better test. Remember, when we did the assertSame, we were basically testing, well did the same exact note that I put in there come back and that's what we want to do. What we want to do instead is saying that does the note that comes back have the values that I put into the note at that position. So you notice here we're checking for the course, the title, and the text that we put into the note at that position. So again, we're testing functionality, not a particular implementation. Alright, so that goes ahead and gives us our test where we set up our values, we did the work that we wanted to test, which was creating the note and putting values in it, and then we did the test itself, get the note back and make sure the values that we expect to be there are actually there. Alright, so now we're ready to run our test and you notice here by the source code window there are arrows off to the side here. Next to the createNewNote, there is a single green arrow. Next to the class name, there is a double green arrow. If I click on the green arrow next to the createNewNote method, I'll run just that test. If I click on the double green arrows next to the class name, I'd run all the tests in the class. Now in this case, our class only has one test in it anyway. So let's go up here to the green arrow next to createNewNote, click on that, and notice I can run the test or I can debug it. Let's go ahead and just run it for now. And so now you notice there on the bottom of the window, we can actually see the class name, DataManagerTest, and our test method, createNewNote. And notice that they both have green circles next to them saying they're okay. And so that now indicates that test ran successfully and that's fundamentally what we're trying to do with unit testing is that we built up all these tests, we can run them, in general what we're going to do is run all of them and then a quick glance we can see that if all the functionality we built tests for is valid. Alright, so now in our next clip, let's see what things look like when we have a failed test.

Dealing with a Failed Unit Test
Here we are in Android Studio. We're still looking at our createNewNote test method and let's see what the testing experience is like when a test fails. Broadly speaking, there are two ways a test fails, one can be because an exception was thrown, the other would be an assertion failure, other words, one of the calls to one of our assert methods didn't pass whatever it was testing for. Let's see what each of those are like. So the first thing we'll look at is the case of an exception. So what we'll do is we'll introduce an error into our program that throws an exception. So I'll go over here to our DataManager, we've got a createNewNote method there, and basically, it adds a new note and then returns back our note size -1 because the size indicates how many total Ms there are, right, because at 0-base, we always return them back -1. Let's go ahead and take that -1 off the end. Now by doing that, we'll actually return back the size of our list, not the last index of the list, which means we won't be able to validly put something there, so that should cause our test to fail with an exception. So let's go back here to our test class and let's go ahead and run it. So now the first thing you'll notice there is that at the list of tests we actually have a red next to both the test method and the class contains the test method, so that's our first indication of failure. Now on the right side there, we actually see some messages about the failure, so let's go ahead and enlarge that window a little bit so we can see more information. So we can see there we have an IndexOutOfBoundsException, you notice that we've got our stack trays underneath it, and you can see there's actually one of those lines on stack trays has a link to one of the lines in our test class, DataManagerTest. Let's go ahead and click on that. So that indicates the line where the exception was thrown and that makes sense because we just tried to get something from the notes list that's passed the end of the list. Now obviously, we know what the issue is here because we introduced the error, alright, let's say we didn't, so how can we track it down. Remember that we cannot only run tests, we can actually debug them. So let's go up here to where we call createNewNote and let's put a breakpoint in, let's scroll up a little bit. So what we'll do is go ahead and launch the test, but this time, we'll debug it. So we'll click on the circle to the left of it here. We've got Debug createNewNote, so we'll choose that. And notice here now we actually hit our breakpoint. So the breakpoint is at our call into createNewNote. Now we've got full access to the debugger, alright, so we can do things like step into it, so let's go ahead and do that, step in. Alright, once we get inside of there, we can step line by line, and so we get right there and we can see that hey that's the line where we return back the size of the note list, not the last index, the -1. Alright, so we can go ahead and stop this guy now. So let's go ahead and fix our code. So now we return back to the last index correctly, go back to our test class. Let's go ahead and remove that breakpoint. Let's switch from the Debug window at the bottom to the Run window. And of course, that's all of our failed test information, but notice there there's a button with a red circle and an exclamation in it. That would actually allow us to re-run just those tests that have failed. Now again, currently, we only have one test, but as you're building up your unit test, you often have a lot of tests and a given error in your code may cause multiple tests to fail, so it's an easy way to simply re-run only those failed tests. So let's go ahead and choose that and see what happens. And there we have a successful test, so everything worked just like it was supposed to. We have greens and green is good, so we're good to go. Let's go ahead and collapse this bottom window for a moment. So let's introduce another error. In this case, we'll introduce an assertion error. Alright, it calls one of our assert method calls to fail. Now an easy way to do that is that we go ahead and create a new note and we get the index back. Let's change the wrong note. So I'm going to do yours in my test code where I actually get the initial note to set the values. I have to go and modify the index there. So instead of using the index that was actually returned from createNewNote, I'll use that index -1. That'll change the note just before the index of the new spot that we've created in the list, but then we get down to the compareNote, we'll actually get the note that's actually in that last spot, so this calls our assertions to fail. Alright, so we'll go ahead and run this test again, so just click on circle, say run. Okay, now in this case, we can see the test failed, but instead of the red circles, we've actually got the yellow circles, indicating we have the assertion failures and we've got information about the failure over on the window on the right, so let's go ahead and enlarge a little bit so we can see more information and you can see there that it indicates that there's an assertion error and it shows that one value is null and the other value is actually that Android Async Programming and Services. So obviously, something didn't match. Now notice that we've got the list of calls down at the bottom and one of those calls is into our test class, let's go ahead and click on that. So what that shows there is which of our assert calls failed and that indicates that it was a check for course. So other words, we were looking for one course, but we got a different course, in fact, we actually got a null course back, so that's bad. So that's the first thing that we can see there is that, okay, it wasn't a match, and now of course, we know why it didn't match because we actually broke our test on purpose. But here's the other thing to notice. Notice that if we look at the error message about the assertion error. It says that the expected was null, but the actual was that title Android Async Programming and Services and that message is kind of backwards because what we expected was the course, Android Async Programming and Services, and what we got was a null and what that shows us is that the order that we pass parameters to the assertion methods is important. The first parameter is the expected value. The second parameter is what you're testing against. And in a simple test like this it doesn't matter, but again, as things get more complicated, you want to have accurate information. So what we want to do here is add in each of our calls to assertEquals, we want to switch to order those parameters, so let's do that. So now we have all of our assert method calls fixed. The first parameter is the value we actually expect, the second parameter is the one we're testing against. So let's go ahead and run our fail test again. And so, now as we run those, we have better error messages there. The expected was the Android Async Programming and Services. What we actually got was the null. So now our error messages are shown in the correct order. Alright, so let's go back to the test code here, let's fix that bug we introduced, so we take the noteIndex and use it directly here when we create the new note. And let's go ahead and run our failed test again. And now life is good. Our test again passes. In our next clip, let's take a look at the features that are available to help us maintain test consistency.

Assuring Test Consistency
What I'm about to say may seem obvious, but it requires specific effort to achieve and that is that tests must be reliable. Now I see that means that our tests have to be written in a way that they test whatever they're testing whatever appropriately, but there's more to it than that. Tests have to be sure to run consistently. So what that means is that a given test cannot depend on the action of another test. At the same time, a given test cannot be impacted by side effects of other tests. Other words, you don't want one test causing another test to behave inconsistently. To achieve that, our tests have to always start from the same state because remember their test order is not guaranteed, and in fact, we often run our tests differently. Sometimes we run a test by itself, sometimes we run all the tests, sometimes we'll run some subset of tests. So in order to assure that our tests always start from the same state, we need some way to set or reset the test state so that they're always starting from that same state. JUnit gave us help with this. JUnit has the ability to support test preprocessing. So what we can do is that in a given test class, we can have a method that has the Before annotation on it. Any method that has a before annotation will be run before each test in that class. So if we have three tests in a given class, the method with Before annotation will run three times, once before each test. And just like we have test preprocessing, we also have test post-processing available, so you can take a method and mark it with the After annotation and then that method would run after each test in the class, so it kind of gives us a sandwich. If we need to create an initial state before the test, we use the Before annotation on a method. If we need to clean something up or do something special after a test, we put the After annotation on a method. Now in addition to having pre and post processing per test, we can also have once per class pre-processing. So we have a method that's marked with a BeforeClass annotation. In that case, it'll run once before all tests in that class. So even if we have three tests in the class, the method marked with BeforeClass will only run once before all the tests. Now that method has to be marked as static. So just like we had the once per class preprocessing, we have the once per class post processing. That's a method marked with the AfterClass annotation. It will run once after all the tests in the class run and that method as well needs to be static. So what about the issue of having multiple pre or post processing methods. Well that is valid. In other words, I could have three different methods all of which marked with the before annotation and all of those would run before each test. The thing to keep in mind though is the sequence is not guaranteed. So if you are going to have multiple methods with the Before annotation or multiple with the After annotation or the same thing at the class level. If you create these multiple methods, they're simply for code organization. You can have one of those preprocessing methods depend on another preprocessing method or the same thing for the post processing methods. So just be sure to keep this in mind. If you do have multiple pre-processing methods or multiple post processing methods, remember that there is no guaranteed sequence. Alright, so now in our next clip, let's take a look at using some of this capability in our code.

Pre-processing Between Each Test
Here we are on our DataManagerTest class and we still have our createNewNote method inside of here, but I've also added another test method. Now remember our createNewNoteTest method basically just created a note, then got it back and made sure everything in it was correct. Let's see what this findSimilarNotes test method does, so let me scroll down there. Now the purpose of this test method is to verify that our findNote behaves correctly in what I'll call an edge case. What we're testing is that if we create two notes who have the same course and same title, but different bodies, there's a find method to find the correct one in that case. So the way this is set up is we start out by getting a reference to our DataManager, then I initialize values for the course, the title, and then the two separate note bodies, then I do the work to create the first note, then I do the work to create the second note, then I find the first note, and confirm that I get back the index where I put that first note, and then do the same thing for the second note. It's a pretty straightforward test. Again, we're just testing an edge case to make sure we find the right note when two notes are very similar. So let's go ahead and run this test. So we go up here, I'll click the button over here, choose Run, and we see there that our test succeeds, so it seems we have a good test, right, we've handled that correctly. Now that's running the test in isolation. But I'll show you what happens if you run all the tests in this class. Now to run all the tests in the class, I could scroll up to the top of the class and just click the Run button next to the class name, but let me show you another option we have. Notice up top here on the toolbar, we actually have a box that shows us what we call run configurations. Let me go ahead and just expand that a little bit. You notice there's an entry there for the app. So if I have app chosen, I'll actually run the app normally, although there's not a test scenario, but actually run the app, but I can also see some other run configurations I've used recently and they're the individual test configurations. There is one for the createNewNoteTest, one that runs just at findSimilarNotes, but there's also one here for all the members of the DataManagerTest class, so let's choose that and let's go ahead and run it. And you see I have a problem. My createNewNoteTest still runs fine, but that one findSimilarNotes now fails, but now it ran fine when I ran it by itself, but now it breaks when being run as part of multiple tests in this class. If we look at the error, we kind of get indication of what might be happening. So we have an assertion error and we expected the index 9, but we got back the index 8, so we got one earlier than we expected. So let me get this window at the bottom out of the way and see if we can see what's going on. So we see here that we actually get a reference to the DataManager instance, we get a reference to the course with the id, android_async, our noteTitle is test note title, and for that first note, the body text is this is the body text of my test note. Let's go look at our other tests, our createNewNoteTest. And if we look there, we're actually using the same course, the same title, and the same noteText and that's what's breaking our findSimilarNotes test is that when findSimilarNotes was running by itself, everything was fine. When I ran it along with the createNewNote test, I ended up putting two notes in with the same course, the same title, and the same body. And as a result, my findSimilarNotes test fails. Now you might be saying well duh, don't do that. Alright, don't create two notes look exactly the same in your tests. And you're right. In a simple case like this where I have only two unit tests, that would be an easy solution. But when you're building a real application, you're going to have hundreds, if not thousands of unit tests and it can become very impractical to assure that you have no conflicting data. The better solution here is to make sure that every test always runs in the same environment, right, in a consistent state and that's where things like our test pre-processing can help us out. So let's go up here and let's add a method to the beginning here and I'm going to call this my setup method and we're just going to make it public and void. I'll go ahead and give it a body. And what I'm going to do now is take this method and mark it with a Before annotation. So that Before attribute there, this method will run before each test in this class and what I can do inside of this method is make sure that my list of notes always starts in a consistent state. So what I'll do now is I'll go ahead and get a reference to the data manager again. Now once I have that, what I'll do is I'll go ahead and clear out the list of notes. So now what'll happen is that each time before the tests run, I'll have a note list that's completely empty and that certainly would be a valid test, but I usually like to make my tests just a little bit harder than that. So rather than start with a completely empty list of notes each time, what I'll do is I'll go ahead and add some example notes to it. And in my DataManager class, actually I have a method called initialize example notes that adds a bunch of example notes into our new list. So now what'll happen is that each time before a test is run, any notes that are already in my note list are cleared out and then a consistent set of example notes are then added to that list. So my test inside this class always start out with the exact same set of notes whether that test is run by itself or run as part of a larger set of tests. So let's go ahead and run our data manager test again. So go up top here, choose Run. But as you can see now, both tests are successful because the test always run in that same environment, that same exact set of starting notes in the list.

Pre-processing at the Start of Each Test Class
Now let's take a look at something. Our setup method we have to go out and get the DataManager instance. In our createNewNote method we have to go out and get the DataManager instance, and we've already seen that in our findSimilarNotes method we had to go out and get the DataManager instance. So we're constantly, for everything we do in this class, we're having to go out and get a reference to the DataManager instance. It'd be nice just maybe go ahead and do that once and have it available to everything else that we do and that's a great use for our Before class method. Basically, before any of the tests or any of the setup work actually starts, I can go out and get that reference to the DataManager and then have access to it. Now remember that the BeforeClass method we use has to be static, which means that any variables that it sets has to be static. So let's go up here to our DataManagerTest class and let's add a static member of type DataManager called sDataManager. So I've got that static member. Let's go ahead and create a static method called classSetUp, let's give it a body, and then we'll go ahead and we'll mark it with that BeforeClass annotation. So now as a BeforeClass method it's assured to run before any of my methods marked with the Before annotation or any of my test methods. So what I'll do inside of here now is just assign that field as DataManager, the DataManager instance. And so now once I have that, I know I can always rely on that field sDataManager to have a DataManager. As you see here that we're actually using these annotations to not only assure that our tests actually run a consistent environment, but we can also use it for housekeeping scenarios like this. So with that in place, what I can do is go to like my setUp method here, let's get rid of the call to get the DataManager instance, and let's change both those dms to sDataManager. So now it's using the reference to the DataManager we got in our class setUp method, the BeforeClass method. Let's do the same thing with both our tests. So if I scroll down a little bit so you can see all the createNewNote method, you can see that we use that sDataManager field any time we need a DataManager reference. If I scroll down to findSimilarNotes, same thing we use our sDataManager field, the field that was set in our class setUp method, which is marked with that BeforeClass annotation. So let's go ahead and run all the tests in our DataManagerTest class again just to make sure that everything is working as expected. And everything now works just like it should. So as you're building your test, remember that your job is not just to write a bunch of individual tests, but create tests that run consistently. And things like the Before annotation and the BeforeClass annotation are important tools in being able to do that. Okay, now in our next clip, let's take a look at something called test driven development.

Test Drive Development
Throughout this course series, our focus is on providing you with the skills and information you need to be an effective Android developer and a key goal in doing that is not to have a bias towards and particular development philosophy because there are just so many out there and I don't know what philosophy you're going to be working with. But I want to deviate from that idea for just a moment, for just this one clip. And I want to focus on a particular development philosophy called test driven development and I'm going to do that because even though there are many different philosophies out there, test driven development is one you're likely to encounter in many places you're going to go and my goal here is not to teach you everything you need to know about test driven development. I'm not going to go deep at all. I just want to give you a general idea of what the term means and how it deviates from other development philosophies. Now in test driven development, what we do is we actually write our test before we actually write our application implementation. So let's kind of walk through an example what that might look like. Now here in the DataManager class, we've got that createNewNote method and we've used this guy quite a bit. Remember, createNewNote method is responsible to, as this name implies, create a note. But the way it's implemented is a little bit awkward. You actually call createNewNote, it creates an empty note, and it gives you back an index to where that empty note is and it's your responsibility now to get that note and fill it up. So let's say our manager has given us a design specification that says that they want another overload of createNewNote. They want a createNewNote implementation that actually allows the program to pass in your information and then create the note completely with that data. So in test driven development, rather than write the method first and then go build the test, we're actually going to translate those requirements into a test, and then from that test, provide implementation that meets the requirements of the test. So let's go back to our DataManagerTest class, we're going to scroll down here towards the bottom, and let's add a new test method called createNewNote one step creation. So we'll first put the Test annotation. We'll then go ahead and declare the test method. So we have our test method there. So now the first thing we need to do is go ahead and provide the data values we're going to use to create our test note, so let's go ahead and declare variables for each of those. So now we have all the values we need declared. So let me go ahead and scroll down just a little bit so we can see better. And so now what we need to do is add the code that would call this new method we're going to create. So what I'll do now is declare a local variable called noteIndex and I'll use my sDataManager field, and what I'll do now is I'll go ahead and call createNewNote, but I'm going to use an overload that does not yet exist. I'm going to use an overload that meets the new specification I've been given. The new specification I've been given says that my createNewNote needs to accept the three values required to create a note. So I'm going to go ahead and pass in the course, the note title, and the note text. Now as you would expect, Android Studio has given me an error because I don't have an overload like that, but I can go ahead and let Android Studio create it for me. So I'm going to go over here to our little red light bulb, click on that. I'm going to choose create method createNewNote. And so, what that does now is it goes ahead and adds that to my DataManager class, go ahead and tab through with the return value and the parameters. So now it's given me a default implementation, and as part of test driven development, I actually want to start out with a failed test. So I'm going to make sure this test fails by returning -1 because -1 is not going to be a valid index. So I've now got a failed test, which is the first step in setting this all up. So I'll go back to my DataManagerTest class and now what I want to do is go ahead and finish this test. What needs to happen for this test to be successful. Well, the first thing I want to do is get back a note at the index that I just created. So I get back the note at that location and what do I want to do? I want to use assert and make sure the note at that position has all the right values. So let's go ahead and add assertEquals for the course, the note title, and the note text. And now that completes my test. I've gotten the note back and now I just go through and check and make sure the note that came back from that index has all the values in it. And so what I've basically done here is that rather than create some implementation I think will fulfill the requirement, I've translated the requirement into a test. Then that way as I implement the method, I'll implement just what I need to implement in order to fulfill the requirement. So the first thing we'll do now is go ahead and run the test, and of course, the test fails because my index return back is -1, but that's expected. So what we're going to do now is go ahead and implement our new method in order to fulfill the requirements of this test. So go back to our DataManager class. As we implement this, we need to go ahead and create the new note. Now we could write all the code to go ahead and create the spot inside the list and so forth if we wanted to, but in this case, we actually have an overload that we can use. So let's go ahead and use our createNewNote. Overloaded takes no parameters to do the work of creating the spot. So now that creates the spot for the note. What we'll do is get that note back. So now we have a note at that location, so of course, what we want to do now is go through and actually set all the values in that note. So now we have the note fully populated, so the last thing we want to do here is return back the index of that note and that should be enough now to fulfill this test requirement. So let's go back to DataManagerTest. Let's go ahead and run our test again. And there our test succeeded, so we know that test is fine. But we know just because that test succeeded by itself, we're not actually done yet. We're not done until all of our tests pass. We want to make sure we haven't broken any existing code. So we'll go up here, choose our run configuration, I'll choose the one for DataManagerTest, so I run all the tests in there. I'll go ahead and run this guy. And now all of our tests pass and with that, we're done because we fulfilled the requirements of this test, and we haven't broken any of our other tests. Now this may seem kind of odd to you at first, but what it really comes down to is that as we do our testing, what we don't want to do is go implement a method that we think is going to do everything we possibly need. Instead, what we want to do is we want to make sure our methods do exactly what we need, not more, not less. By translating requirements into our tests first and then implementing our code so it then passes the test, our code then fulfills the requirements. Now again, this was just a brief overview of just general philosophy called test driven development. When the time comes and you're ready to start working fully in test driven development, I've got a URL for a course on the screen there that you can check out that goes into the details of doing test driven development with Java and I encourage you to check that out when you're ready. For now, just understand that this test driven development is a philosophy of taking requirements, translating those into tests first, and then implementing code that fulfills those tests.

Summary
To wrap up, here are some of the key things we want to remember from this module. Remember that testing needs to be a core task of your application development because testing is essential to creating software of high quality. Particular testing we looked at in this module is what we call unit testing, and in unit testing, we have relatively simple test that focus on a specific feature or behavior. Now remember that we want to run our tests frequently so it can be sure to catch any errors as soon as they're introduced. Now as we saw, we have access to something called local JVM testing and that's where we focused on the Java aspects of our app and what was powerful about those is that we were able to run those directly on our desktop. We didn't need access to an emulator or device to provide the full Android environment. Now Android Studio allows us to manage our tests easily. We can run or debug our test from within Android Studio and the success or failure of our tests are displayed directly in Android Studio. Now remember as we created our test methods, they were grouped in classes, and then each test method within a class is marked with that @Test annotation. Now within those test methods, we used the Assert class and we used that to indicate expected results. It has a bunch of methods on it that allow us to test for expected results and we'll fail our test if those expectations are not met. But remember that when we build our test, we're not just focused on the testing of our application behavior, but the test themselves need to be reliable. We want to assure that we have consistent testing. Whether we run an individual test or a group of tests, we want to make sure that each test runs in a consistent environment. So we can take advantage of the ability to include pre or post processing for the tests. So we have the @Before or the @After annotation and those are run for each test, so the methods marked with @Before are run before each test within a particular class. The @Afters are run after each test within a particular class. But remember, we can also have pre and post processing at the class level. And that was the @BeforeClass and @AfterClass annotations and those are run once for each test class, so they're run before any of the tests or before any of the @Befores and then the AfterClass is run after all the tests and after any @Afters. Remember though when you use @BeforeClass or @AfterClass, the methods have to be static. Alright, so that wraps up this module. In our next module, we're going to look at how we can create tests that exercise our apps user interface.

Understanding Instrumented Testing
Introduction
Welcome to the Understanding Instrumented Testing module of the Pluralsight course, Working with Android Tools and Testing. My name is Jim Wilson. Incorporating testing that occurs within the Android environment is critical to assuring app quality. As part of assuring that app quality, we need to also incorporate testing that includes interacting with the application user interface. However, doing this sort of testing manually is time prohibitive in most cases. So for our test to be effective, we need a way to automate it and this is where instrumented testing comes in. So as we go through this module, we'll start with an overview of instrumented testing, we'll then see what's involved in implementing instrumented tests, we'll see how we can set up our automated UI tests, we'll go into the basics of our UI test interaction, and then we'll deal with a special case of interacting with AdapterViews, and we'll see how we verify our test behavior, and then we'll finish up with a brief look at the Espresso test recorder tool.

Instrumented Testing Overview
As we continue our discussion of Android testing, remember that when we test our Android applications, there are two general types of behavior that we look at for testing. One is the Java-based behavior, the other is the Android-based behavior. Now as you recall, in our last module we talked about testing the Java-based behavior, and to do that, we used the local JVM tests and that allowed us runner test directly on our desktop or workstation, but of course, these are Android applications, so we're going to need to test the Android-based behavior at some point, and to do that, we use something called instrumented tests. Now instrumented tests are run on an emulator or a physical device because we need something that has the full Android environment. Now one kind of instrumented test is what we call an instrumented unit test and that is just a regular old unit test that relies on Android features or capabilities. Other words, everything we talked about in the last module about how you build unit tests applies here. We're just including the testing features that rely on Android features or capabilities. But now another kind of instrumented test is what we call an automated user interface test and these are a type of integration test. And what we're doing here is we're actually testing at the application level. We're actually testing specific application behaviors in response to UI interactions. So thinking about our application, this might be something like well when a user makes a selection from the list of notes, does the correct note get displayed, or when the user creates a new note, does everything behave correctly in that case. So what we're doing here is automating interaction with our application's user interface and then confirming the application behaves correctly in those interactions. So how does this all work? How can we actually test the interaction with our application. Well of course, we're going to have an emulator or a device and we'll, of course, have to deploy our application onto that device and the application is going to have run inside of a process, but during instrumented tests that process also has a test package running inside of it as well. That test package includes JUnit. It also includes the Android instrumentation and that's just the aspect that'll allow us to perform these interactive tests and gain information about those tests. And of course, we then have our test cases, the things that we actually want to test, the test that we actually write. And what happens is there's test cases that run against our application and they do that using something called AndroidJUnitRunner and that allows us to code up tests and have those tests applied interactively to our application. Alright, so now in our next clip, let's take a look at what's involved in implementing instrumented tests.

Implementing Instrumented Tests
When it comes to creating our instrumented tests, we're still using JUnit 4, which means many of the aspects of creating the tests are going to be very much like we talked about in the last module. We're still going to have a series of test methods and they're all going to be marked with that @Test annotation. We still support the pre and post processing methods, so methods we marked with @Before or @After or static methods marked with @BeforeClass or @AfterClass are all valid. We still rely on the Assert class and we use the Assert class to indicate test expectations and a test will fail if the expectations are not met. And the tests are still managed by Android Studio so they can run or debug our tests, we can run one test, a group of tests, or all the tests and our results are displayed right there in Android Studio. But there are some differences from what we talked about in the last module. One thing is that the instrumented tests are organized separate from the JVM tests so we actually have an AndroidTest source set, which is separate from our source set for the JVM test, which was the test source set. Instrumented tests rely on something called the Android JUnit test runner. So that means when we create our test class, it has to be marked with the @RunWith annotation and we have to pass into that AndroidJUnit4. class to indicate that we want to use that Android JUnit test runner. And of course, implemented tests require the Android environment, so they're going to be run on emulator or device. So what this means is the process of constructing our test classes are going to be very similar to what we talked about in the last module. But again, create a class, we're going to use methods to contain our individual tests. Those methods are going to be marked with the @Test annotation, but of course, in our instrumented test, these test methods are going to have code that relies on things in the Android environment, so we want to make sure that test class is marked with the @RunWith annotation and that we pass into that annotation AndroidJUnit4. class. But as we mentioned, we can still have pre or post processing methods in there. We can even have class level pre and post processing methods. So from the aspect of creating these tests, the only thing that's really different in the code is the presence of that @RunWith annotation and the AndroidJUnit4. class. But of course, the key thing here is that we're exercising code that relies on the Android environment. So if you're creating instrumented unit tests, everything we talked about in the previous module by how you create unit tests still holds true. We're just exercising code that relies on the Android environment. But now in the next clip, let's start looking at how we can use instrumented tests to create these automated user interface tests.

Creating UI Test Interactions
As we mentioned, one of the things we can do with instrumented tests is create automated user interface tests and if we're going to create automated user interface tests, we, of course, need a way to code user interface interactions. Now when we say code user interface interactions, what we're really talking about is interacting with a series of views that appear within an activity. So what that means then is that we need a way to specify each view of interest we want to interact with and then we need a way to specify the action that we want to perform on that view. Well at the heart of doing this is the Espresso class' onView method accepts a parameter that's a matcher and that allows us to specify the view matching criteria, other words, what criteria has to be matched to get to the view we want to interact with and then what onView returns is a reference to a view interaction object. Now objects associated with the matched view and we can use that view interaction object to perform an action on that view. So the first question is how do we specify the matching criteria for a view and we use something called Hamcrest matchers. And Hamcrest matchers allow us to specify our matching criteria declaratively. Now Hamcrest matchers are actually a general purpose framework for doing matching, so there's nothing Android specific about them, we're just using the job implementation of Hamcrest matchers. Now if you want more information on Hamcrest matchers themselves, just head out to hamcrest. org to see that. Now specific to our Android testing, there's a class called the ViewMatchers class and it provides matchers for matching Android views and these methods that match Android views actually return back Hamcrest matchers. Now the reason that that's important is that we're building our matching criteria we can actually easily combine the Hamcrest general purpose matchers with these Android view specific ViewMatchers. Now there are a number of different ViewMatchers methods. But to give you a sense of what's available here, let's look at a few examples. Now one of the ViewMatchers method is withId, and as its name applies, it allows us to specify the id of a desired view and it'll match based on the id value, but there's also a width text method, so it will actually match a view based on the text property or an isDisplayed method, which allows us to match views that's currently on screen or isChecked, which will allow us to match a currently checked checkable view, so something like a switch or a CheckBox. So there's a whole bunch of these methods available and as you can see that using these methods, there are many different criteria we can use to match on a view, but remember, we still have the basic Hamcrest matchers available and just to see some examples of those, there's an equalTo matcher, which allows us to pass in a value and it will match based on the result of the equals method or an instanceOf matcher, which allows us to match based on an object's type. There is an allOf matcher and that allows us to pass in multiple other matchers and this provides an and condition. The all of matcher matches if all the past matchers match. There's also an anyOf matcher, which also accepts multiple matchers. This is kind of an or condition. The anyOf matcher matches if any of the past matchers match. So now remember that we use these matchers to pass the onView method and that onView method returns us back a reference to a ViewInteraction. Well the ViewInteraction has a method on it called perform and that allows us to specify one of our actions we want to perform and those actions are passed as parameters to the perform method and we generally use the viewActions class to do that. So it provides action methods and each method returns a specific action. ViewAction supports a number of different action methods, but here's just some examples. The click method returns back a click action, other words, it actually performs a click on that view. The typeText method actually types text into the view at the current cursor position. It's also a replace text, which will actually replace all the text within a given view. And then even things like closeSoftKeyboard, which as its name implies, closes the soft keyboard, actually slides it out of the way. And again, there are many different action methods available to us. If we're doing user interface testing, we're, of course, going to need to use our interface, which means our test is going to involve at least one activity, so we need a way to actually start those activities and that's where the ActivityTestRule class comes in. It automates test activity lifetime and what we'll do is I'll go ahead and start our activity before each test in the class and then we'll terminate the activity after each test in the class and its behavior includes the @Before and @After marked methods, so it'll create a new instance of the activity, run any methods that are marked with @Before, run the test method, then run any methods marked with @After and then it'll destroy the activity and then repeat that for any other test in the class. Now the way we use the ActivityTestRule is actually declarative. What we do is we need to declare and initialize a field in our test class, so in other words, we have to have a field whose type is ActivityTestRule and create an instance of activity test rule and the specific activity we want to create is actually a type parameter for the ActivityTestRule class. And then what we do is just mark that field with the @Rule annotation and then ActivityTestRule will do the work for us of creating destroying the activity appropriately. Alright, so in our next clip, let's start coding up a UI test and see what all this stuff looks like in practice.

Setting up the Test
Here we are in Android Studio and let's say we want to go ahead and create a test that verifies the creation of a new note in our application. Now this, of course, is going to be a UI test, so remember that when we look at the Project window, in our last module, when we were doing the local JVM tests, we did that in our Test source set. Well our UI tests are going to go into our AndroidTest source set. Now before we can actually write our test, we need to know the UI operations it takes to perform our test. So what we'll do is let's go ahead and run our application and walk through kind of the minimum we can do to create a new note. Now one of the things you want to be careful of is that when you've been running tests, there's a good chance Android Studio is still in a configuration to run tests. If we want to run our app, go up here to our run configuration and let's choose the one that actually says app. So now we click on the Run button, it'll run our app instead of running a test. So we go ahead and run that. So here we are running in the emulator. If we think about creating a new note, well the first thing we do is we go down here to this New Note button and we'll click on that. That brings up our note activity. We'll go up here and click on the title. We'll go ahead and type in a title. And then once we have that title, we'll go ahead and type in our note text body as well. So now let's go ahead and close the soft keyboard. Alright, and that goes and gives us kind of a starting point for creating our new note. So let's see how we can implement that inside of our test. So let's go back to Android Studio, we go ahead and stop our program from running. So now we're ready to go ahead and create our test. So to create our test, we're going to start out very much like we do with the JVM test. We're going to go up here to the Navigate menu. We're going to choose the Test option and we'll say Create New Test. So let's go ahead and change our class test name to NoteCreationTest. So once we have that, we'll go ahead and accept all the other defaults, so we'll click OK. Now in this case instead of running a JVM test, remember we want an Android test, an AndroidUITest. We'll choose the androidTest option, click OK, so now that's stubbed out our test class for us. Now remember that when we're creating our UI test, one of the things we need to do is run this with the AndroidJUnitRunner. So what we want to do now is go ahead on this class and mark it with that @RunWith annotation and then pass it AndroidJUnit4. class. So now we've got that in place, we're ready to start doing the work to actually create our tests. Now remember that in order for our tests to run, we need an activity and that's where the activityTestRule class comes in. So what we want to do here is create a public field of type ActivityTestRule and then it takes a type argument of the activity we want to test. Now we know that when we're actually creating a new note, most of the work happens on our noteActivity activity, but in this case, remember our test actually starts with the NoteListActivity because the first operation we perform is clicking that New Note button. So that's the activity we want to specify here because we want to specify where the test starts. So we'll give it a type argument of NoteListActivity, then we'll go ahead and give the field a name and I usually follow a naming scheme that kind of relates to the activity I'm creating and then the word rule at the end. So I'll call this my mNoteListActivityRule. And then we need to go ahead and new up an instance of our ActivityTestRule class, so I'll just say new ActivityTestRule. And as an argument, this constructor takes the class for the activity we want to create, so we'll just pass in NoteListActivity. class. So we've got that there, now let's be sure to put an = between the field and the construction of the class. So now we have ActivityTestRule typed on NoteListActivity. The field is mNoteListActivityRule= new ActivityTestRule passing in the NoteListActivity. class. Now that creates the field for the rule, but the thing is JUnit won't know about it yet. JUnit won't know about this rule until we mark it with an annotation. So what we need to do is go ahead and mark this guy with the @Rule annotation. So we've got that rule in place, and with that rule in place, our testing environment will take care of creating that activity instance for us before each test and cleaning it up after each test. So now we're ready to go ahead and put our test method in place, so let's go ahead and just do it just as we did in the previous module. So we'll have the annotation @Test and then we'll call the method createNewNote. And so with that, we have everything in place we need to begin working on our UI test. And so now in our next clip, we'll start creating the test to test the creation of a new note.

Implementing Basic Test Interactions
So now we're ready to start implementing the test to test the creation of a new note. Now generally, before I start actually writing the individual test, I generally want to get a few imports in place. When we build tests, most of the test methods we use are static methods on their respective classes. And to make our tests more readable, we generally just want to use the method names themselves. So in order to do that, we need to have static import for the classes associate with those methods. So let's go up here to our import statement area and let's just add a few lines here and what I want to do is go ahead and do a static import on the Espresso class, the ViewMatchers class, and the ViewActions class. So now we have those static imports for Espresso, ViewMatchers, and ViewActions and that allows us now in our test to use any of the static methods from those classes as just the method names, and again, that's just done to make our test a little bit more readable. Let me go ahead and collapse the import area here. Now remember we mentioned that the view interaction class is really kind of at the heart of what we do, so let's go ahead and declare a local variable here of type ViewInteraction. Remember that the first interaction we're going to perform is clicking the Floating Action button for a new note. So what I'll do here is I'll call this local variable fabNewNote and remember the way that we actually get a reference to our view interaction is with the onView method. Now because we have static imported the classes here, we can simply say = onView and then our onView method wants a matcher to indicate what view we want. Well we know the idea of the view that we want. It's our floating action button, so that's going to be r. id. fab, so we're simply going to say here withId R. id. fab. So now once we do that, we can actually interact with that fab button through that fab new node variable and so what we want to do now is perform an action on that view. So we'll say fabNewNote. perform and the way that we specify the specific action we want to perform is using one of the viewActions methods. Now again, that viewActions class has a static import, so we can simply use the method name and we want to perform a click action, so we'll call the click method. And so those two steps now take care of getting to the view and performing an action on it. Now this process of getting to a view and performing an action, again, is really kind of the heart of what we do in our tests, so in general, we don't declare variables for those views, unless there's a number of things we want to do with it over time. So generally, the way we'll write this same thing is do it all in one line. We'll do the onView withId R. id. fab and then we'll just simply say. perform click. So we do all that work in one line. So let's go ahead and comment out now the two-line version of it. So now when our test runs, the testing environment will launch the activity and the first thing we do is click on that fab button. So remember now the next thing we want to do is actually type in a title for that note. But remember that in our application when that fab button is clicked on, our application automatically launches the note activity. So now we're thinking from a perspective of the note activity. So what we want to do now is use the onView to actually get to our note title field, so we're going to say. perform and we want to type text, so we use the typeText method and we want to pass in a text that we want to type, so we'll pass in Test note title. So now we got the text for our title typed in and we want to do the same thing for the note body so that's the view withId R. id. text_note_text and we'll again say perform typeText. We'll put in this is the body of our test note. Now one of the things that's nice about the perform method is it actually takes a variable length argument list, so there's multiple actions you want to perform right now related to that view. We can also pass that next action method right here in this one called a perform, so just put a comma and a new line and let's go ahead and close the soft keyboard as well. Now you can see there when I call closeSoftKeyboard, there's actually an error message there and one of the challenges is that there are actually multiple classes that have closeSoftKeyboard available. So what I want to do is go up to my imports area here and what I want to do now is explicitly statically import the vActions CloseSoftKeyboard. Now that makes it clear that that's the implementation of closeSoftKeyboard that I want. So let me go ahead and collapse my imports. Alright, so now with that, we're good to go. We've actually got our basic test written. Again, the test environment will take care of launching the activity. We then click on the floating action button on our NoteListActivity. Our program them opens up our note activity and then we type into both the text fields. So what I want to do here now is go ahead and put a breakpoint at the very end of this method. Now one last thing we need to look at before we launch the test is to be sure that everything that the test environment needs access to is public. Now our createNewNote method is public, but we also want to make sure that our rules are public. You notice we got that ActivityTestRule field, mNoteListActivityRule, and that guy is not public, so we want to make sure that guy is public as well. Alright, so it's really important that everything we need for our test environment is marked public. So let's go ahead and make that public. And so with that, now we're ready to go ahead and launch this guy in the debugger, so let's go ahead and click the green arrow next to the method name, we'll choose debug, we'll choose the emulator. Now as this comes up, one of the cool things about these tests is they're really fun to watch. So you see it launches, you see it click the button, types the text into each of the fields, and then it hits our breakpoint. So you notice in the background there our breakpoint is stopped and it shows us that all those values are actually into the fields themselves. Alright, so if I go ahead and release this now and let the test finish, and when I return to the emulator, the activity is gone. So what's really kind of a cool thing is that the UI test actually run the application and then do all that user interface interaction for us and it does it fairly quickly, but we can then watch it happen. Alright, so we've got our basic test in place. In our next clip, let's see some additional interactions we can add to our test.

AdpterView and Back Button
As we've seen, we can easily access a view and interact with it through the use of the onView method, but there are some cases where the onView method can't do quite what we need and where this generally comes up is with AdapterView derived views. Now AdapterView derived views load their data from Adapter classes and examples of AdapterView derived views are things like the listView or the spinner. A challenge comes up because these sort of views display multiple data items, and at any given point, only a subset of those data items may be loaded. So what that means is that at any given point in our test, the specific data that we want to interact with within that view may not be currently loaded. So what we have to do in this case is rather than trying to directly access a view, we actually have our test do their selections based on the target data itself. So to get a sense of what this looks like, imagine we have a ListView and that ListView occupies some area space on the screen, which means you can only display some number of items at a given point in time, but then the data associated with that ListView is relatively large. Well remember that we have an adapter that loads the data into our ListView and it basically shows a window into a subset of that data. But now the problem comes up is that when we're running our test, maybe you want to get access to a selection that corresponds the data that's not currently loaded into the ListView. So what we need is some mechanism that will take care of changing the window display data that correspond to the selection we're trying to make and then give us back the view associated with that selected data. So the way we achieve that is by using the Espresso classes on data method. What that allows us to do is specify a matcher based on our target data. So rather than going directly into a view, we actually do it based on the data, and in this case, because we're working with data rather than views, we tend to use the general purpose Hamcrest Matchers, so we do things tied to data matching, not view matching. Now the onData method returns back a reference to a DataInteraction. The DataInteraction type provides a number of methods for interacting with or narrowing the match that corresponds to our selection. Although the DataInteraction type can do a number of things, we tend to use the DataInteraction's perform method and that allows us to perform an action against the top-level view of that entry within the AdapterView. And generally, what we're doing there is we're clicking on the item to select it. Now another case where you perform a user interaction in our test that doesn't involve a view is the simple case of the back button, and in that case, we use the Espresso class's pushBack method, and as its name implies, it performs the action of pushing the back button. And again, it doesn't require a reference to any given view. So when we call this method, it's the same as pushing the back button. In general, we'll use this method for us to go ahead and leave our activity and return to the one before it. Alright, so now in our next clip, let's expand our test scenario to take advantage of the onData and pushBack methods.

Implementing Spinner and Back Button Interactions
Here we are in Android Studio, let's expand our test to take advantage of the onData method and the pressBack method. We use the onData method to select a course from the spinner and then we use the pressBack method to return from our NoteActivity back to the NoteListActivity when we're all done creating our new note. Now to get us started, the first thing we'll have to do is take care of a little bit of housekeeping. Now in order to select a course from our spinner, we're going to actually need a reference to a course. And you remember from the last module, the way we get a reference to a course is use the DataManager. So why don't we go ahead and set up that static member variable to point to the DataManager just like we did in our test in the previous module. So the first thing I'll do here is add the sDataManager static field and then what I'll do is add a static method to initialize that sDataManager field and mark that method with the BeforeClass annotation. So now we have our DataManager, what we'll do is go down here to our createNewNote test and let's go to initialize a variable that actually points to the course that we want to use in our test. So we'll go ahead and declare a variable here of type CourseInfo called course and we'll use our DataManager to get a reference to that course and we'll use a course whose id is java_lang. So that gives us back a reference to the Java language course. While we're sending it variables here to hold the values we're testing with, we should probably go ahead and add variables for the note title and note text, rather than using string literals as we're doing now, so let's go ahead and set those variables up. So we have these variables there now, so let's go ahead and change the two places where we type text that use the variables rather than the string literals. So now where there's variables in place, we have one last bit of housekeeping to take care of. Remember that we said that when we use the onData method, rather than using the viewMatchers, in most cases, we use the Hamcrest general purpose Matchers instead. So what we'll want to do then is go ahead and add a static import for the Hamcrest Matchers. So let's scroll up to the top, so what I'll do now is go ahead and add a static import for org. hamcrest. Matchers and with that there, I can use the Hamcrest Matchers just by their method names rather than have to prefix them all with the class name. But now, while I'm up here with the imports, I'm going to go ahead and add one more import. I'm going to add a static import for the Espresso class' pressBack method. The reason we add that import is because just like with the CloseSoftKeyboard method, there's a pressBack static method in both the Espresso class and the viewActions class, so we're just specifying that when we say pressBack, we want to use the one from the Espresso class. Alright, so let's go ahead and scroll back down to the body of our createNewNote method. So now with all that housekeeping out of the way, we're ready to start using the onData method to make a selection from our spinner. So we'll make that the first thing we do once we get to our NoteActivity, so remember that we call the click on the fab button, which launches our NoteActivity, so what we'll do just after this is go ahead and make a call to the onData method, and remember when we're using the onData method, we generally do data oriented matches rather than view oriented matches. So what I'll do is I'll go ahead and match on the course variable that I've set up to hold the course that I want to select. Generally, when we do this, we match on a combination of both the actual value and the type. So what I'll do is I'll start out with an allOf Matcher, then what I'll use is the instance of Matcher to match on the CourseInfo class, and then I'll use the equalTo Matcher to match on the specific course variable I've set up. So what this says now is to go ahead and look through the AdapterViews on this activity and then find the one that holds CourseInfo instance who's equalTo our course variable, that'll then go into our spinner and then find the view that corresponds with that selection. So now we can just go ahead and perform some action on it. What we'll do is we'll actually perform a click to select that course. So that should be all we need to go ahead and make a selection of that course from the spinner. So let's go down here to the end of our test and let's go ahead and add the call to pressBack to actually leave the NoteActivity at the end of the test. Alright, so we now have our test set up. We have an onData that corresponds with the course we want to select and then the pressBack at the end. So let's go ahead and run this test and see how it goes. So we see it start up. We see it start up okay, but then when it goes to make selection, something went wrong. So let's get back here to Android Studio and see if we can get a sense of what's going on. So we can see the information for our failed test here, so let me scroll up a little bit, and we can see here that we're getting a NoMatchingViewException, so it seems to indicate that they couldn't find some view. So let's scroll to the right a little bit so we can see a little more. And you see here on the error message, it's saying that the view it can't match on is text_note_title. Now we know that code was working just fine. So let's get this bottom window out of the way and take a look at our test method. So we can see the line there where we actually try to get the view corresponding to text_note_title and that happens right after that onData method call we added. Now it turns out the problem that we're encountering is something that's specific to a spinner. So let's go ahead and run our application normally and I'll point out what's going on and I'll show you how to fix it. So we'll go up here to our run configuration, we'll choose the application, let's go ahead and run the app. Okay, so here we are on the app. Let's go in here and click on the button and we're now in our NoteActivity. Now we want to go ahead and make a selection for the course. But now when we deal with a spinner, in order to make the selection, what do we have to do? Well, the first thing we have to do is click on the spinner and then that presents the selections, and then from there, we can go ahead and make the selection and we have to do that same thing in our test. Now if we were dealing with a ListView, we wouldn't need that extra step to click on it first, but because just like when you interact with the spinner in real life, you have to click on it, then select from it. When we're writing our test, it's the same thing. So let's return back to Android Studio here. Let's go ahead and stop this guy. So what we'll do here is that right before our call to onData, we're going to go ahead and add a call to onView and we'll pass in the withId for the spinner, and then from there, we just perform the click. And so now, the test will mimic the interaction with the spinner. First, you click on the spinner, and once you've clicked on it, you can make the selection. Now again, that's something that's peculiar to spinners. If we were dealing with a ListView, the onData would be all we need, but because spinners interactively require click first, we need to do the same thing in our test. So let's go ahead and run our test again now. See our NoteListActivity makes a selection, selects our course, creates our note, and if we look back here to Android Studio, everything ran fine. So let's go ahead and get this bottom window out of the way. So we can see now that everything works as we want it to. We went ahead and set this up very much like a regular test. We actually were able to use the BeforeClass annotation to get a reference to our DataManager. We're using variables here to start of the test method to set the values we want to work with and then we just go through the interactive steps, and as you can see, these interactive steps are very much like what we do interactively. Okay, so we're doing pretty good here. We've got a lot of interactive code added to our test. One thing we haven't done yet though is add assertions to make sure our test is actually working. So in our next clip, we'll see how to start doing that.

Verifying Behavior
I know for me, as we've gone through this module, it's been a lot of fun to write these user interface tests and then see the instruction we've put into the test then be run against user interface of our application, but it's important that we don't forget the actual purpose of writing our test. Remember that our tests are meant to confirm that the application conforms to some expected behavior. Now when it comes to verifying behavior, there are two broad categories we look at, one is the user interface behavior. Does the user interface behave as we expect? And then there is logic behavior. Does the interactions with the application actually make the expected changes to the application data or application state? Now when it comes to verifying the user interface behavior, we're again going to use the ViewInteraction class. Remember the ViewInteraction class is the class to provide that perform method that let us actually perform operations against a view. Well now we're going to use the check method and what that allows us to do is confirm some aspect of the view and what we'll generally use is the ViewAssertions class when we do that because it provides methods for performing assertions against the views. Now there are a couple of methods that we commonly use from the ViewAssertions class. Far and away, the one we use most commonly is the matches method and it confirms that a view passes some matcher and it's commonly used in conjunction with the ViewMatchers class because remember the ViewMatchers class allows us to do things like check the text property view or some other aspect of a view. Part of what the matches method does is confirm that the view actually exists, so if you run a match against a view that doesn't exist, it will fail against that assertion. Although not super common, there are scenarios that come up where you may want to check the view does not exist and there is a method called doesNotExist and the way we use this is that we provide a view interaction that identifies some view and the test will pass if that view doesn't actually exist. But again, far and away, what we use most often is the matches method. But as we mentioned, our user interface tests are generally going to be modifying data or state within our application. So we want to verify that the logic related to those things actually works correctly as well. And when we do this, we're basically going to do the same thing we did in our JVM tests. We're going to take advantage of the methods on the Assert class and that's the main way we confirm that our logic works as expected. So to see how this all comes together, in our next clip we're going to add the code, the verified expected behaviors, to our test method.

Implementing Test Verification
Here we are in Android Studio looking at our NoteCreationTest class and what we want to do, of course, is add some checks to our user interface test and make sure things are behaving as we expect. Now before we do that, we have one super quick bit of housekeeping we need to address. I'm here at the top of the file and let's go ahead and add a static import for the ViewAssertions class. Alright, so we have that there, so let's go ahead and scroll down to our createNewNote method. Here in our createNewNote method, we're going to want to add code that actually checks both UI behavior and logic behavior. Now let's start with some UI behavior checks and the first one we'll do, let's do something really simple here. Let's take the edit text where we put the noteText into and let's just check and make sure that edit text actually contains the text we've typed into it. Now to be clear, that's not a test we would actually need to do. We can rely on the typeText method to do the right thing, but what I want us to do is actually get an initial sense of what it's like to work with these methods doing something really simple. So what we do here is that after the onView where we performed the typeText, let's go ahead and add a new line after that. Now we want to interact with the view that has the id of text_note_text, so we're going to use the onView method and withId. So now once we do that, we've got the view interaction that's associated with that view. So now in order to do a check, what we want to do is call the check method and now what we need to do is identify what we want to check and what we'll do is use the viewAssertions method called matches. So we want to verify that this view passes some Matcher. And what we'll do now is use the ViewMatchers class, which has a method with text, which allows us to get access to the view's text property. So now, we can apply a matcher to the current value of that view's text property. So now if we look at what this statement does, the onView method returned back a ViewInteraction for that view. We said we wanted to check it and the assertion we want to do is a matches and we look at the text property of that view and then we want to make sure it contains the string that's in the variable noteText. Alright, so as you can see there, there's a lot of parts to it, but they actually build up logically. So let's do another simpler one. Let's go up here where we have the noteTitle and what we'll do now is go ahead and do a check on that one as well. Now remember that the check method is on the ViewInteraction class just like the before method is. Well now the before method returns back a ViewInteraction. So we have a scenario where we want to perform an operation on a view, and then immediately after it, we want to check it. We don't have to do a separate onView for the check. What we can do up here is just we'll take the semicolon off, I'll put a new line in so it's easy to read, and what we're going to do again here is go ahead and call the check method and we again want to do the matches with text, and in this case, we want to make sure it contains the string noteTitle. So what we've done there now is perform the operation against the view and then immediately checked it without having to repeat the onView. Okay, now again, both of these checks that we've just put in here now, they're not really something we'd have to add to a test, alright, because we can rely on the typeText method doing the right thing. But now, let's look at one that we should include in our test. Now we've got our spinner there, and in our spinner, we went ahead and selected a particular course, but now we want our application to show the course title when a course is selected. So we want to go ahead and do a check in that case to make sure that what's currently being shown by that spinner is the course title. So what we'll do is go up here and let's add a new line. So we'll go ahead and call onView to get a ViewInteraction for the spinner. Now again, we're going to call check and matches. But now in the case of a spinner, there's a special case, we can't use the withText method. We actually have to use the withSpinnerText method to check what text is displayed by a spinner. So again, use the containString method, but in this case, we're going to actually get the course title. So let's go ahead and put a new line in here and then call containString passing in course title. So we've got all that there. Let's go ahead and put a semicolon at the end. Let's go ahead and clean it up so all the parentheses are on that same line. And so now here we have a case of we've gotten a reference to the spinner view, we're checking to make sure that the text of that spinner contains the string that correlates to the course's title. So now here, we're verifying a UI behavior. We want to actually select a course. Well we want to be sure that what's getting displayed is the course title. Okay, so that shows us checking some UI behaviors, but let's remember, what's the point of creating a new note. Well, we actually want to create a new note. So what we want to do here now in our test is make sure that the logic of creating a note is actually run properly. Now if you think back to the first course in this series, when do we actually save the values for the note. Well, when the user leaves the activity, other words, when they press the back button. So what we want to do here now is go down here towards the end of the method, after we call pressBack, we'll have to put a couple new lines in here. Let's just go ahead and scroll it up a little bit. So what we want to do now is make sure that whatever note is now the last one in the list corresponds to all the values that we put into this input screen. So let's go ahead and get the index at the last note in the list, other words, we've gone out and got the note list, got it sized, subtracted 1 to get that last index. So let's go ahead now and use that index to get the last note. So now what we want to do is go ahead and use the regular assert methods to make sure that the values inside that note correspond to all the values we put into this screen. So now we have this assertEquals for the course, the title, and the text. And if you look at this code, right, this is very much like the code we wrote in our unit test in the last module where we were verifying the note was created correctly, right, so using the user interface testing to make sure our app behaves correctly, but ultimately, we're then verifying the logic to make sure that the application did the right thing. Okay, so now if all has gone well, we should be able to scroll up here a little bit, and let's go ahead and run this guy. So we see our application start up, see it make the selections for the note, and when it leaves, go back here to Android Studio and we can see that our test has passed. So that shows us now that all the UI behaviors we checked on worked and all the logic checks we put in our tests also worked. So we're getting a lot of power here now that we have this ability to create these tests that not only focus on the logic or not only focus on the user interface, but can check to make sure all those things come together correctly. Alright, now in our next clip, let's look at a tool that Android Studio provides to give us some assistance in creating these user interface tests.

Android Studio Test Recording
Before we wrap up our discussion of automated UI testing, I want to quickly show you a tool that could be helpful in creating these UI tests. Look up here in Android Studio to the Run menu and notice there's an option here that says Record Espresso Test, let's go ahead and choose that. Go ahead and launch the emulator. Now you can see that our application is running inside the emulator. We've got that window off to the side here that's marked with Record Your Test. So let's walk through a few steps of interacting with our app. So I'll go down here to our Floating Action button, I'll click on that. And you notice that when I do that, you can actually see over in the Record Your Test window Tap FloatingActionButton with ID of fab. From there in the note title field, if I start typing in that, you can see it says type into the view with the ID text_note_title and it shows I typed in the text Title. Now if I go here, click on the field below it and I type in something there, again our Test window says that we typed into the field the ID text_note_text and put the value Body in there. Now notice there's also a button on the Record Your Test window that says Add Assertion, so let's go over and choose that and you see it brings up a screen capture. You notice down there at the bottom where it says Edit assertion, underneath there it says select an element from screenshot. So let's go over here and let's click on the edit text for our title and you notice that edit assertion's area now says well what kind of match do you want to do. We'll do a match on text is and then it shows the value of title. So let's go ahead and click on Save Assertion. So now let me bring my emulator back up. Alright, let's go ahead and wrap this test up. So what I'll do here once is click the back button to get the soft keyboard out of the way and I'll click it again, return back to the main activity of my application. Alright, so let's go over here to record your test now and click OK. So now it's asking me what do I want to name the class for this test. Right now, I'll just go ahead and click OK. Alright, so here we are back at Android Studio and we're looking at the Test class that tool generated and now your first question probably is hey why didn't you show me this in the first place. And the reason is that although this tool is helpful, it doesn't replace understanding how to create these tests, but it does take care of a number of the common things we need to do. You'll notice that the classes marked with that @RunWith annotation and has the AndroidJUnit4. class passed to it, you'll notice that it generated an ActivityTestRule for our NoteListActivity, the activity where our test started. If we get down into the test method itself, you can see that it gets a view interaction using onView for our view with the id fab. Now notice that is also included an isDisplayed matcher there and it's simply saying that it wants the view that has an id that's currently displayed on screen and that's okay. It's an additional check, but it keeps our test working fine. From there, it does a perform click. You see it handled our interactions for our EditText, so for the title it actually found the view of the id of text_note_title, but it also again include that isDisplayed condition, which again is fine. And the same thing for our note body. You see also in there that it included the closeSoftKeyboard for each one of those. So as it enters the text for those fields, it automatically as that closeSoftKeyboard action as well. One thing that's a little different from when we coded up our test is that where we said typeText, it's using replaceText, well that simply means it replaces whatever is in that field, as opposed to typing where the cursor is. That's fine. It's just a little different. Let's scroll down a little bit. Remember that we used the tool to add an assertion just to check the text value in our title editText field and you see it's got the code there to do that. Now here's a case where it's actually using a much more involved code to find the view than we would code up. This thing that's using your childAtPosition is actually just a method that's generated to deal with hierarchies of use. It's again much more than we would need, but it doesn't hurt anything and that's the kind of stuff that when I'm using this tool to generate a test, I actually go through and just kind of cut that down to just the matchers that we need rather than having these additional matchers in there. But now there are a few things that we need to be aware of when working with these tests. Remember that when I got done entering the text, I actually hit the back button to close the soft keyboard and then I hit it again to return back to our starting activity. Well you notice there that we've got two pressBacks at the end of this test method, but that's actually more than we need because a little bit higher up where the before method is used to replace the text for the new body field, it had a closeSoftKeyboard action in there as well, which means that soft keyboard is already out of the way, so there's too many pressBacks inside a test, so we need to remove one of those. And so, if we just ran it, we may end up failing our test, even though, things are fine, so of course, we want to watch for those situations. The other thing is you'll notice that I didn't do anything with my spinner and that's because as the Espresso Test Recorder is implemented at the time of recording this video, it doesn't deal very well with these onData situations, so just another thing to be aware of. But what you see here now though is that this is a useful tool for generating at least part of our test code. So combining this tool with the knowledge of how these automated user interface test work can make the job of creating those tests much easier.

Summary
To wrap up, here's some of the key things you want to remember from this module. Remember we talked about instrumented tests. We're talking about tests that are run on an emulator or a device and that gives our test access to the full Android environment. Now there are two broad types of instrumented tests. There are unit tests that rely on Android, other words, just plain old unit tests that happen to use Android features or capabilities and then we have our automated UI tests. Remember that our instrumented tests still use JUnit 4, so when we create our tests methods we marked them with the @Test annotation. We still have support for pre and post processing methods, methods marked with the @Before or @After annotations or the @BeforeClass or @AfterClass annotations. Remember that one of the key things we want to make sure we do is mark our test class with that @RunWith annotation. We pass in the AndroidJUnit4. class as a parameter to it. Now out automated UI tests are simply a type of instrumented test and those will generally include the use of the ActivityTestRule because it takes care of managing the lifetime of the activity that we're testing. One of the key methods that we use when we're creating automated UI tests is the onView method of the Espresso class and that takes care of locating a view based on the view criteria and that will return back to us a ViewInteraction reference. But remember that we also have the Espresso. onData method and that's used for interacting with AdapterViews because that allows us to locate the views based on data criteria and that returns back a DataInteraction reference. Now when we're specifying these criteria, we're using matchers. Now we have the Hamcrest Matchers, which are general purpose matchers, then we also have the ViewMatchers class that gives us helpers for dealing with views. Now ultimately, in these tests, we want to perform actions against user interface. So the ViewInteraction class and the DataInteraction class both have perform methods, so they allow us to easily perform actions against user interface. Now remember that in almost all cases the reason we write tests is to verify behavior. And so an important part of doing that is the ViewInteraction class' check method and the ViewAssertions class helps us out with that, but remember that the Assert class is still really important. It provides the methods we need to verify the state of our data or application. Alright, that wraps up this module and this course, but don't worry, this is not the last we'll see of automated UI tests. In the next course in the series, we're going to learn about some of the richer UI features provided by Android that can really enhance the user's application experience, UI features like the navigation drawer and recycler view. As part of our discussions of those UI features, we'll also see how to create automated UI tests that exercise those features.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Beginner
Rating
4.6 stars with 47 raters(47)
My rating
null stars

Duration
2h 54m
Released
3 May 2017
Share course