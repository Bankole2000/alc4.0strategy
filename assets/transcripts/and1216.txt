Android: Image Processing with Picasso
by Alex Wolf

Android apps often require dynamic image content in order to meet modern design standards. In this course, you will learn how to use the Picasso Image Library to work with images, such as managing request activity, caching, transformations, and more.

As you learn to develop for Android you’ll quickly want to enhance your apps with dynamic image content. In this course, Android: Image Processing with Picasso you’ll learn how to manage and process images in using Picasso. First, you'll learn how Picasso is a popular, reusable, and lightweight library that reduces the technical problems of working with images. Next, you’ll learn how to utilize Picasso’s powerful features, like how to load images from different source locations, and maintain performance with caching. Finally, you’ll discover how to resize and transform images properly, manage request behavior, and much more. By the end of this course, you should feel comfortable building your own apps that display image content in dynamic ways.

Course author
Author: Alex Wolf	
Alex Wolf
Alex Wolf is passionate about software development and mastering new technologies. He has several years of experience working almost exclusively with .NET platforms, such as SharePoint, NopCommerce...

Course info
Level
Beginner
Rating
0 stars with 2 raters
My rating
null stars

Duration
1h 57m
Released
9 Mar 2018
Share course

Course Overview
Course Overview
Hey everyone. My name is Alex Wolf, and welcome to this course on Android: Image Processing with Picasso. As you learn to develop for Android, you'll soon want to add dynamic image content to your apps. Images are one of the best ways to enhance app design and offer a more professional user experience. However, images can also introduce considerable technical challenges that repeatedly surface in every project. So in this course, you will learn how to manage and process images in your app using Picasso. Picasso is a popular, reusable, and lightweight library that reduces the technical problems of working with images. In this course, you'll learn how to utilize Picasso's powerful features like how to load images from different source locations, maintain performance with caching, resize and transform images properly, manage request behavior, and much more. By the end of this course, you should feel comfortable building your own apps that display image content in dynamic ways. Before starting this course, you should be familiar with general Android development such as working with activities, layouts, and responding to user interactions. Any prior knowledge of web service communication over HTTP is a helpful bonus, but certainly not required since we'll be starting with the basics. So I hope you'll join me on this journey to mastering Picasso and really take your apps to the next level, right here on Pluralsight.

Getting Started with Picasso
Managing Images in Android Apps
Hi there. I'm Alex Wolf, and welcome to Android: Image Processing with Picasso. In this course, we'll be exploring how to work with images when developing Android apps. This requirement might sound simple on the surface, but there are many use cases and technical factors to consider. Let's begin by discussing some of those scenarios, the challenges they present, and just why we need tools like Picasso in the first place. So regardless of your experience level, adding an image to an Android app can of course start out very simple. You can accomplish this by including an image in your project files and then assign it to the source of an Image in the layout. When the app runs, the image will be loaded and displayed. However, such basic scenarios can quickly evolve into more complex and daunting challenges. So for example, maybe the image has to update or change frequently so it must be retrieved from a web server. Now we have to manually make HTTP requests and get that data, handle the file the server responds with, and load it into the ImageView. Mobile apps often need to request many images this way. Maybe it's a list of featured items where each list item includes a URL to the associated image or an image gallery of products or places. These types of features require asynchronously fetching and rendering large numbers of images in the background in order to maintain performance. This additional complexity is just the beginning. Apps that use a large number of images create new challenges such as the need for caching. What if the app uses the same image in multiple spots, but you don't want to request that same file every time? How can we still show stored images when the app is offline or preload images the user will soon need? Image transformations present other common challenges. What if we want to dynamically resize or rotate the image to specific dimensions or container sizes? What if we want to maintain or manipulate aspect ratios or even add stylized filters? These types of problems surface time and time again and the solutions can become quite complex. We generally don't want to have to write and manage this type of code repeatedly in all of our apps. Common problems with complex solutions are often ideal cases for libraries and frameworks. Managing images certainly aligns with this criteria. Android has a few different image-management libraries to help out with these issues. One of the most popular is Picasso, which excels at retrieving, displaying, and caching images. Picasso can actually help solve, or at least improve, all of the technical challenges we just discussed. By the end of this module, you'll have loaded your first images with Picasso. So let's take a closer look at this library in the next clip.

Introducing Picasso
Picasso is a great library for Android, designed to eliminate many of the pain points of working with images. It's easy to learn most of what Picasso has to offer in a very short amount of time, as we'll see throughout the course. For now, let's focus on the high-level solutions and features it offers for your apps. One of the best aspects of Picasso is just how concise and simple most of its code and syntax is to work with. Here you can see just one line of code can load an image from a web server and then display it using an ImageView on a layout. Most of the images you'll display with Picasso follow this same basic structure, so let's look a little more closely at this process. So as we just saw, the standard image rendering process for Picasso utilizes three methods that are easily chained together. The with method accepts a context object as a parameter, which we can generally retrieve from the current activity or fragment. Picasso uses this object for various behind-the-scenes operations. The load method then accepts a source path to an image, whether that's a remote URL on a web server or a local device location, as we'll see more of later. Finally, the into method expects an Android ImageView control to populate the retrieved image into. Of course, Picasso has many other features that provide solutions to the challenges we looked at previously. The library can load images from all kinds of sources and provides cache-management features to improve performance. Picasso allows us to rotate, resize, and transform our images in all kinds of ways. Picasso also provides error handling when things go wrong and other information through logging options. We can even closely manage the requests for our images using callback methods or group and prioritize them to meet our needs. These capabilities are very easy to implement using a similar syntax to what we just looked at, as we'll see later. On a more technical level, Picasso is added to an app project like many other Android libraries through the use of Gradle. To start using Picasso, we simply have to include it as a Gradle dependency in our project and then optionally add the Internet permission to the app manifest. There are no extensive setup configurations to worry about. Now one other question worth asking is why Picasso specifically? There are other image-management libraries for Android such as Glide or Fresco. Any of these tools are safe bets, so ultimately the decision comes down to personal preference and the needs of your app. For example, Glide has specific memory-management features that might benefit some apps. However, Picasso is arguably the most light weight and easiest to get started with. Simply put, Picasso has been around for a while and it's just a friendly choice for quickly getting started with image management. Now that we understand what Picasso has to offer, in the next clip let's quickly make sure this course is a good fit for where you are as a developer, and then we'll move on to actually working with our sample app.

Are You in the Right Place?
Before we begin, let's also make sure that you, as a developer, are in the right place and cover the essentials of what you should know before moving forward. There are two primary audiences for this course. The first would be Android developers who have little to no experience working with images and their apps. Maybe you're still newer to Android and want to learn how to load images dynamically rather than just using static ImageViews. Maybe you've heard that Picasso or other image libraries in general are a great place to start and would like to know more about what they can offer. The second audience would be Android developers who have experience working with images or dynamic content, but are interested to see specifically how to use Picasso. If you're wondering if Picasso might be a good fit for a new project coming up or how it compares to other libraries you've used, you're in the right place as well. Either way, this course does assume basic working knowledge of Android. You should already feel comfortable working with views and layouts, responding to user inputs, and be familiar with concepts like activities and fragments. There will be some light review of certain topics relevant to displaying images, but for the most part this course focuses mostly on just Picasso. Of course, any prior knowledge of working with images or network requests on Android is also useful, but certainly not required. So if any of this aligns well with your goals, let's continue on to the next clip where we'll really dive into our sample application.

Touring the Sample Application
Let's take a moment to walk through our sample application. This will demonstrate just how much we'll accomplish in this course and visualize the significant improvements Picasso can add to your apps. So in this course, we'll be finishing a mobile app built for the Wired Brain Coffee Company. Wired Brain hired a development team to build a small app for their coffee shop. They'd like for the app to be simple and easy to use, but also very visual to show off their great coffee products and services. So first, Wired Brain met with a design team to conceptualize the app. A development team then built out the basic structure and features of the app, but they've been waiting on the design team to send them appropriate images. So we'll be starting with that basic shell app with all of the content layouts stubbed in. We'll enhance those layouts using Picasso and the images the design team has finally provided. We'll also use this app to explore equally important concepts like caching and request management. Together, all of this will allow for an appealing app that's on its way to release. Let's switch over to the actual app to see what all of this looks like. I already have an Android emulator running for us to use for this clip, so let's go ahead and open up the Wired Brain Coffee Company app. First, we are greeted by this simple landing page, which features the company logo and a few notable pieces of information. Any images you see in this app are all being loaded using Picasso. So let's click GET STARTED to move into the app and then we should see this nice list of featured items. These are the products or marketing points that Wired Brain wants to feature front and center in the app. We'll see how to add images to a RecyclerView like this to create nice card-based layouts. Down at the bottom, you'll find a tab navigation to move between sections of the app. Since the app is pretty small and simple, the design team felt this was a minimalistic approach that works well for the content they want to display. So let's switch over to the Gallery tab where we'll find a nice GridView of various images of coffee or related images. Wired Brain really wants to engage customers by reminding them of the great aesthetics of their brand, so we'll see how to build nice galleries like this one. We'll also be looking at different ways of sizing, transforming, and even preloading these images along the way. The final tab gives us an informational page about the company. Here we'll see how to work with different types of icons that are included right within our project. Eventually, we'll also see how to add a stylistic filter to this image such as adding a grayscale to make the page more interesting. In the next clip, let's switch over to Android Studio and explore the codebase that we'll be working with and then start to get Picasso set up in our project.

Demo: Touring the Sample Android Project
Let's now turn our focus to the Android Studio project for our sample application. The codebase for this app is pretty simple, but it's still worth getting comfortable with its structure. Also, just to be clear, this is the starting codebase without any images or Picasso code added into it. We'll be building off of this project in the clips and modules ahead. To get started with this sample project, you can of course find it in the downloadable course exercise files. However, if you prefer working with Git, you can also clone the starter project from the repo at this URL. If you do prefer using Git, I'm assuming you already know how to clone repositories so I won't be covering that extra portion in this clip. The codebase for this project expands off of one of the Android starter templates, specifically the Bottom Navigation Activity template, which might be somewhat familiar to you. So if I close out of this dialog, you can see that we have this MainActivity that manages the navigation between fragments. There's a simple listener here to load the appropriate fragment for whatever tab the user selects. Further down, we are also setting the FeaturedFragment as the default when the app loads. Over in our project explorer, we have a fragment for each of the three bottom navigation tabs. Each fragment is surprisingly simple given how visual our app tabs will be. So for example, our GalleryFragment simply creates an instance of our gridAdapter and then assigns it to a GridView in our layout. Later, we'll see how to populate that grid with images using this empty imageUrls ArrayList as a starting point. We also have a FeaturedFragment that shows CardViews of the featured products. This fragment uses a more sophisticated RecyclerView adapter to create the data. We'll be exploring how to work with these types of adapters a bit more later on. However, it is assumed you have some working knowledge of RecyclerViews, ListViews, and other basic controls if you're watching this course. Both adapters for our project can be found under the Utilities folder, which also includes a UrlHelper that will set the base URL for our image requests. Finally, within our resources directory, we have the matching fragment and activity layouts. These are pretty straightforward so I'm not going to step through the XML in detail right now, but just know that they're here. We'll also be adding some additional drawables and image files to our project as we go along for various icons and images. Most of our images will be loaded through a web service though, which we'll look at shortly. So that's a basic overview of our project structure and what we'll be working with. If all of these pieces don't quite make sense at the moment, they should fall into place for you as we visit each one. In the next clip, let's really get started working with Picasso by exploring how to add it to our project.

Demo: Adding Picasso to an Android Project
In this clip, let's step through how to add Picasso to our Android project so we can start using it to load images. Picasso is included using the same steps as many other Android tools, so this process might feel very familiar. Back in Android Studio, I have our starter project open from the previous clip. There are two simple steps we need to take care of to begin using Picasso. First, we need to add a permissions entry into our manifests file. Most of our app images will be loaded from a web service so our app will require permission to use the device's Internet connection to make network requests. So let's open up the manifests file. And then near the top here, I'll start to type uses-permission, and then just make sure you select INTERNET. Once that's in place, Picasso will be able to communicate with our web service using its underlying network connection classes. The second step we need to complete is to add Picasso as a project dependency in our Gradle file. So let's open the module-level Gradle file over in our explorer and then move down to the bottom where our other dependencies are. Adding Picasso only takes a single line of code, but I'll paste it in to make sure that we get the naming and versioning correct. After we add a new dependency like this, we usually need to perform a Gradle sync, which will download the dependency and sync it with the rest of our project. So, I'll go ahead and run that and then wait for that to finish. And once it completes, we'll be ready to go. So that's really all there is to it. Picasso is now a part of our project and ready for use. In the next clip, let's load our first image into the app.

Demo: Retrieving and Displaying the First Image
In this clip, let's load and render our first image using Picasso. This demo will show just how simple working with Picasso can be and provide a glimpse of Picasso syntax. I have our emulator running with the starter version of our Android app. This landing page looks pretty bland without any images so let's spruce it up a bit by including the company logo. Let's switch to Android Studio, and make sure that you follow the steps in the previous clip of adding Picasso to your project so it's available for us to work with. Let's start with a simple example by loading the main Wired Brain logo and displaying it on our LandingActivity. If I open up that layout, you can see that right now it's pretty basic XML. So in the markup of this layout, let's add in an ImageView to contain the image we'll be loading using Picasso. So I'll just type out ImageView and then declare a height and width. For width, I'm going to specify match_parent and then declare a height of 250dp. Later in the course, we'll look more closely at image sizing techniques, but this will work for right now. Let's also give it an ID of image_logo so we're able to access it from our Activity class. Let's switch over to that class now, and inside of our onCreate method let's get a reference to that control. So I'll just type out ImageView landingLogo and then use our findViewByID method to retrieve that. Once we have our ImageView to work with, we can start adding Picasso code, following that process we looked at in the slides earlier. So below our first line of code, let's simply type Picasso, and then we need to call the. with method and pass in the context of our activity. Next, we can type load and then I'm going to paste in a URL for our logo. Remember, with Picasso we can load images from all kinds of sources so for right now we'll start out with a file out on a web server. Finally, we just need to call the into method, which specifies where to display our image. Let's pass in that landingLogo variable, and Picasso will just handle the rest for us. That's all we have to do to load our image onto the landing page. Now you might be wondering where I got this image URL or how to know what images to load into this app. In the next clip, we'll be looking at the web service associated with this URL more closely to see what images are available to us. For now, let's run our application and make sure this works as expected. Our LandingActivity is already specified as the launcher in our manifest so you should see the layout and our new logo pop up right away. And that's all there really is to it. We've successfully included our first image in our app with Picasso. You might also have noticed how this page has suddenly become more interesting and pleasant to look at versus just the plain text we had before. In the next clip, let's look more closely at the image web service we used to load this image.

Demo: Overview of the Image Web Service
Throughout the course, we'll be loading most of our images from a remote web server like we did in the previous clip. Real-world apps that utilize dynamic image content often request them from a server rather than including them directly in the app package. In the next module, we'll see how this works in a little more depth. For now, let's review where most of our images will actually come from and which ones are available to use. Here you can see the base URL to our web service that hosts the images for this course. If you're working with the starter project from the course exercise files, this URL is already included and you'll be good to go. However, there are a couple of extra features I added to this site to make it easier to use, so let's look more closely at what this URL provides us. I have our browser open for us, and let's type in the URL of alexwolfps. com/images and you should see this image gallery load. Now, this page is simply for informational purposes. If you're interested in seeing what images you can play around with in the sample app, you'll always find them listed here with their file names. So, if you see additional images to what's displayed here, it's because I added them later. As we work with our app, we'll usually be requesting one image at a time. So if you click on any of these images, it will take you to a page with just that full-size picture. You can then copy the direct URL for it and use it just like we did in the previous clip. I also want to mention that this site is just here for your convenience. I've designed the course so you never really have to go to this website if you don't want to since we'll be stepping through loading the images together. You also don't have to worry about how image file hosting or web services work since these topics are beyond the scope of this course. This site is just for you to explore and request images from. Now that we've explored both our sample app and this web service, we're ready to start working with our app in more depth. So let's wrap up this module in the next clip so we can get started on more exciting functionality in later modules.

Summary
For the rest of this course, we'll be working through practical demos of the types of problems and solutions we've discussed so far. So as we wrap up this module, there are just several key concepts to remember. If you're comfortable with these ideas, you'll be more than ready to move forward. Picasso is an Android image library designed to solve many technical challenges you'll run into when working with images. This could be anything from managing multiple network requests, to caching, to transforming an image's size or appearance. Picasso is a great choice for projects that just need a light-weight, easy-to-use library that can quickly get the job done. Although there are alternatives on Android, Picasso has been around a while and is a safe choice. At the most basic level, to render an image with Picasso we simply need to specify a source location and then a destination ImageView in our app layout. We can access most of Picasso's features directly through the main Picasso class, which gives us a fluent syntax to easily load images with a single line of code. Picasso can be included in an Android project by adding it as a Gradle dependency and then optionally requesting Internet permissions from the device if you need to load from a web server. In the next module, let's continue to enhance our sample application by looking more closely at how to retrieve and display images.

Retrieving and Displaying Images
Introduction
In this module, let's explore how to load and display images with Picasso in greater detail. This will include how to retrieve files from different locations, manage drawable resources in our project, and how to build interesting UI elements like galleries and lists. So first, we'll discuss the different locations or sources we can load images from using Picasso such as from a web server or local project assets. Next, we'll review some basic image-management concepts in Android. This will include how to work with various image file types and sizes for different devices and screens. Once we understand these basics, we'll move on to completing one of the tabs in our app. First, we'll see how to load images from our local project resources. We'll then see how to work with density-aware icons to further enhance our app design. Next, we'll review some of the essentials of working with ListViews and GridViews. Understanding these controls can help us build more interesting UI layouts such as galleries or CardViews. We'll then build out our first image gallery using Picasso and see how it integrates with our ListViews and adapters. Our starter project already has some of the ground work done for us, so we'll see how Picasso can finish this process for us. We'll also review the essentials of RecyclerViews and how they can be used to create more interesting list layouts like our featured items tab. We'll then put those concepts to work in another demo where we'll add Picasso to that existing RecyclerView structure. Finally, we'll see how to load image files on the device outside of our own app using URIs and intents. So by the end of this module, the visual design of our app will be largely complete. We have a lot of material to cover in this module, so let's get started in the next clip.

Exploring Image Loading Scenarios
In this clip, let's quickly review some of the different ways to load files using Picasso. The main differentiator between these methods is the original source location of the image. There are four main ways to request an image asset using Picasso, which are all driven by variations of the useful load method. Load accepts four different types of parameters, which are a string, a resource ID, a URI, or a file. Let's look at each of these a little more closely. The most common way to load an image is through an HTTP request to a web server. We can simply pass a URL string into Picasso's load method and it will make an HTTP request to retrieve that image. We completed a simple example of this in the first module, and we'll be looking at other use cases as we go along. Loading an image from a web server is a good choice for images that update frequently. For example, an app might market one featured product on Monday, but then a different item on Wednesday. Or maybe the company has a gallery of product images that are constantly updating from some external data source. Requesting the images from a web server allows us to change those files on the server and have them update without having to rerelease the app. The second way to retrieve an image is through resources included right with the Android project. These files are generally stored in the drawable folder. Drawable resources can include either standard image files like JPGs or PNGs, as well as drawable XML files, which we'll review in the next clip. As you can see, the syntax to load a drawable resource is almost identical to a remote image on a web server. We simply pass in a resource ID to the load method instead of a URL string. Drawable resources are actually included right in the APK of the app, meaning Picasso can load them right off the device after installation. Now it is possible to load a drawable resource into an ImageView without Picasso. However, this technique allows us to leverage other Picasso features on that image such as filters, caching, or event handlers, as we'll see later. Picasso can also load images that are stored on the device outside of our own app using a URI, which in simplified terms is just a pointer to a resource. For example, maybe your app allows the user to pick a profile photo. So first it creates an intent with a get content action, which prompts the user to select an image from another app. That intent result includes a URI for Picasso to use to load the image and maybe display a preview of the image the user selected before they finish their upload. We can also load a file directly into an in-memory object using Android environment helpers and pass that into the load method. This scenario isn't quite as common as the others, but it can be useful for features like loading assets off of SD cards and other filesystem-related functionality. In the next clip, let's discuss the different file types we'll be using with Picasso and how to manage them in Android Studio.

Understanding Android Image Resources
Before we start to work more extensively with Picasso, let's first review some fundamental concepts for managing images in Android apps. Understanding image basics like file types, different Android project resources, or how to handle various device sizes, these are all useful skills for working effectively with Picasso even if they aren't specific to the library itself. There are a huge number of image file types out there, but when working with Android apps, there are three that are arguably the most common. First, we have JPEGs, which are a widely-used format due to their small file size and quality compression. PNGs are another common type that support transparency and lossless compression. Finally, we have SVG images, which are small, XML-based files that can be scaled to any size and are great for icons, graphics, and logos, and that's because SVGs are a type of file known as vectors while JPEGs and PNGs are called raster files. It's important to understand the difference between raster and vector files. Raster files, like JPGs, are generally great for images like photographs or detailed renders. They contain a dense amount of pixel data in them, but this means that as they scale they can lose quality since the program has to try and duplicate or guess those additional pixels. Vector images are able to scale infinitely without loss because they are drawn using shapes and mathematical formulas. SVG files are an example of vector images that are XML based, which makes them a good fit for Android since it already has built-in drawing tools driven by XML. Android Studio provides options for managing both raster- and vector-based image resources. Raster images, like JPGs and PNGs, are generally added to the drawable folder of your Android project. So let's say we add two small-resolution images. You can then display these images in your app layouts. And if you display them at roughly their original size, they will usually look fine. The problem comes when we try to display a small- or medium-sized image on a very high-resolution, larger screen. This can create artifacting and loss in quality that can degrade the appearance of your app, which is obviously not great. To help combat this scenario, Android Studio offers support for different sizes of the same image. We can create additional drawable directories that map to different screen sizes such as a medium size or extra large. Android is smart enough to understand the screen size it's running on and pull from the right folder size when Picasso tries to load an image. If Android can't find a size in that location, it will keep looking for the nearest best size until it defaults back to a generic size. Vector files are handled a little bit differently such as in the case with the common SVG type. Android Studio allows us to import SVGs as drawable XML resources. These XML files use the Android vector shape and path tools to mathematically redraw the icon or logo to different sizes. This creates a nice one-size-fits-all scenario in some cases. Now unfortunately, Picasso is actually not able to load XML resources directly, but it's still good to be familiar with them. In the next clip, let's start with a simple example of loading a drawable resource with Picasso.

Demo: Loading Local Images
Let's use the concepts we just covered in the slides to load an image from our local project resources. I have our starter app open again in the emulator with the Company tab active. Right now, you can see there are no images on this layout so it looks pretty bland. First, let's add some sort of banner image across the top, and then in the next clip we'll add an icon next to each of these lines of text. Over in Android Studio, I have the company layout file open. Let's start by adding an ImageView near the top. So I'll type out ImageView and then specify a width of match_parent, and let's just give it a height of 200dp for now. Let's also give it an ID, so I'll call this image_banner. Now let's add an image as a drawable to our project. Now if you want, you could just copy down any image file into this main drawables folder from our web service, but let's make things more interesting by adding images for different screen densities. So first, let's right-click on the drawable folder and choose Show in Explorer. On the file system right now, you can see there is just one drawable folder, but as we saw in the slides, we can add additional folders to support different image sizes. In the exercise files for this module, you can find a couple folder size variations, which each include the same image at a different resolution. Let's move those folders into the main resource directory in our other window. When we switch back to Android Studio, you might notice that we now have this arrow next to our new image that we imported. As we expand that, you can see it lists the sizes available. Android Studio provides this convenient project view that collapses all the variations on our file system into one resource. You can also click on either one to open up a preview. So I've labeled both images so we can tell them apart when we load them on different devices using Picasso. So with those in place, let's now open up our CompanyFragment class so we can load this image into our app. Inside of onCreate, let's first get a reference to our ImageView. So I'll type out ImageView imgBanner, and then let's do our findViewById and search for that image banner we created. We'll be able to use this as the display target for Picasso. On the next line, let's type out Picasso. with and then get our context. And then for the load method, we want to pass in the ID of the drawable we just added. Android Studio will let us access that drawable directly by just typing R. drawable. beans. So let's provide that. And then finally, let's say into with the variable that references our ImageView. The most important concept to note here is that this Picasso load method accepts many different types of sources. In the previous module, we supplied a URL, and here we're supplying a drawable ID. There are additional overloads to this method as well, which help make Picasso easy to work with. Let's run the application and see how this looks. When the app starts, let's move past our landing page and we'll end up on the blank featured items layout. We'll be filling this in later so for now let's switch over to the Company tab. Sure enough, you can see our image has loaded successfully. The red label on the top left lets us know that Android selected the XX density image since this is a very high-resolution screen. Right now, the image doesn't extend the full width, but in the next module we'll see how we can clean up some of these sizing issues that'll come up. Now I also created a second emulator of a phone with a lower screen density to simulate retrieving our other image size. So if I pull that up quick, you can see I've already moved to the Company tab, and there we'll find the image is labeled HDPI instead of the XX. Android and Picasso together have loaded the appropriate drawables for the appropriate screen densities. So, this layout is already looking better, but let's improve things further by filling in these icons in the next clip.

Demo: Working with Icons
Icons are a great way to add visual interest to your app, so in this clip let's explore one way to include them using Picasso. So, there are a few different ways to implement icons in your app. For now, let's use a technique involving the Android material libraries to make these lines of text more interesting. To start off, in Android Studio I have our Company tab layout open. You can see there is a simple linear layout for each section of marketing text. I've added an ImageView into each one like we did in the previous clip. For now, we're just going to give these a size of 24dp, which is the default material icon size. So let's start by adding one of those icons to our project. Over in our explorer, let's right-click on the drawable node here and choose to add a new image asset. And let's switch the icon type to Action Bar and Tab Icons. In this dialog, let's click on the little Android icon, which will open another window of available icons for us to choose from. I'm going to select the Action category over on the left and then scroll to sort of a generic icon like this done checkmark. So, I'll select that and then hit OK. I also want to give this icon a better name so I'll switch this to something like ic_check. Let's leave the rest of these settings at their default and then hit Next to verify where it will be stored. And then finally, just hit Finish. You should see that icon pop into the drawable folder. Now, if you expand the arrow next to this new resource, you'll see that Android has added different size variations for this icon. This is a more complete example of what we started in the previous clip. If I right-click on the drawable folder and choose to show in explorer, you'll now see a folder for every common size variation. In a real project, as you continue to add image assets to your project, you can create as many variations of those files as you think are necessary and just drop them into these folders. Back in Android Studio, let's open up our CompanyFragment so we can actually load this icon into place. The code to load all three icons is very repetitive, so I'm going to paste in a completed code snippet. Any time I paste a code block like this, you can find the same snippet included in the module exercise files. So, just like in the previous clip, we simply need to obtain references to our new ImageViews and then we can use Picasso to load our new icon into each of them. Picasso and Android will pick the best fit for our emulator device based on all of our density folders that were added. So let's run our app to verify this works as expected. So once the coffee app loads, let's click on GET STARTED to navigate to our tabbed view. Let's select the Company tab again, and this time we should see our nice checkmarks populate next to the rows of text. Hopefully you can see how much nicer this screen looks already after just a small amount of work. For right now, we're using the same simple checkmark for all three lines, which looks okay since it's a pretty generic icon. However, I encourage you to maybe repeat this process and select different icons for each text callout to get more comfortable with this process and further improve the app. Also, although they aren't that relevant to our Picasso discussion, you might want to try adding an icon using a SVG. If you right-click on the drawable folder, you can try adding a vector asset, which if you complete that same dialoged process, will import an SVG icon as an XML file. These files can have advantages in that they don't need multiple copies for different screen sizes even if they don't work as well with Picasso. In the upcoming clips, now let's start to move on to some more sophisticated loading examples by learning how to populate our gallery.

ListView and GridView Essentials
Let's review a few essential concepts for building galleries in our app using Picasso. For this first example, we'll explore the more simplistic List and GridViews and see how they can integrate with Picasso. Now an in-depth discussion of all these controls is beyond the scope of this course, but let's review the fundamentals that are relevant to our goals. ListViews and GridViews can both be used to display a scrollable collection of views. A GridView is actually a more specialized type of ListView that allows for two-dimensional display of items versus the ListView's one-dimensional approach. Either of these setups could be used to build a gallery, but to make things more interesting we'll be using a GridView. The process to populate a ListView or GridView is fairly straightforward. For example, to build a gallery, first we need to add a GridView to our layout and then reference that view from an activity or fragment. GridViews rely on a component called an adapter, which for us serves two primary purposes. The first is to bind a data source to populate the list such as an in-memory array of image URLs or data retrieved from a web service. Second, the adapter handles retrieving a template that will be used to display each item from that data source. In the case of a gallery, that template might just be a simple ImageView. Android offers a few different adapters out of the box to work off of. You can start with the base adapter, which is the most low-level adapter that all others inherit from. Another option is the array adapter, which inherits from the base and streamlines some adapter functionality behind the scenes to make things simpler. An array adapter is not as flexible as the base adapter, but it provides an easy option for us to further inherit from with our own adapters that require more limited customization. The array list adapter exposes two methods that we will use to populate our GridView and build our gallery. The first is getCount where we simply specify the number of items in our data list. The second and more important method is called getView, which is called every time an item in our list of URLs needs to be displayed. We can use Picasso inside of this method to retrieve the image at that URL and then load it into the associated view template for each item in the ListView. Picasso is smart enough to manage all of these requests inside of an adapter without us having to manage anything ourselves. Let's take a closer look at how this process works in the next clip.

Demo: Completing the Image Gallery
Now that we've reviewed some essential concepts around GridViews, let's see how to use one to complete the gallery in our app. Back in Android Studio, we already have most of our GridView structure set up in our starter project. In this clip, we're mostly interested in seeing how Picasso integrates into these types of views. I have the gallery layout open, which you can see is simply a GridView element. There are a few notable properties here for us such as the number of columns in the stretchMode, but otherwise it's a pretty standard GridView. Over in the Fragment class, we can see how this layout is configured. We're simply creating a list of the names of the images we want to load and passing them into our grid adapter. We're then specifying the template to be used for each item in the grid and then setting the adapter. The gallery_item template is simply an ImageView, which we can confirm if we open that up quick. It contains a black background for styling and a default height of 150dp. The most interesting part of this GridView setup can be found in the GalleryAdapter class, so let's switch over there now. Inside this class, there are two methods we're interested in since we're inheriting from the array adapter. First, the getCount method simply provides the count of the image list we passed into the adapter. The more interesting section is this getView method. Remember, this method is called every time our GridView tries to render an item in the list. It's inside this method that we want to use Picasso to load our images. You can see we have this ItemView that's passed into the method. This ItemView represents the view that will be used for each grid item or in other words, the ImageView template we just looked at. Since the template we specified is an ImageView, we can cast it to that type and use it for Picasso to load images into. So, below our conditional here, let's type out Picasso. And then for the with method, we can use the context that's being passed into the adapter so I'll add that in. Let's then type load. And this part is interesting because we actually want to get the image from our list that's at the current position of this adapter. So remember, getView is called for each item as our adapter loops through the image list we passed in. So we want to get the image it's currently on. So I'll type UrlHelper. BaseUrl + this. data. get(position). And the position integer acts as sort of an index for us to know where we are in that list of data. Finally, let's type out into and then pass in our itemView. Now this UrlHelper is a simple class included with our starter project, which just allows us to set the root domain for our web requests in one spot. This will be useful as we start to make more requests. I have preconfigured it to point to our helper site, but if you want to pull in images from somewhere else, this is an easy way to change it. So all of this might seem like a lot of moving pieces, and to a certain extent it is, but the actual amount of code to get a nice-looking gallery working is actually very minimal. Picasso makes things extremely easy for us because it will que up asynchronous background requests for all of these as the grid loads. Let's run our app and see how this works. So as usual, when our app loads let's continue on to our tab navigation activity. This time, let's select the middle tab, which should load our GridView. At this point, a nice gallery should load for us, which will request some of the images sitting out on our web server. Right now, some of the sizes are a little awkward looking, but this is definitely a great start. We'll see options to improve those in the next module. So now that we have our gallery working, let's see how we can apply some of these same concepts to a RecyclerView in the next couple of clips.

Working with RecyclerViews
Let's now turn our attention to the main featured items list of our app. The layout and data set for this tab is more complex than our simple gallery, which makes it an ideal use case for a RecyclerView. In this clip, let's just review a few concepts around RecyclerViews that relate to loading and displaying our images. RecyclerViews are a newer and more recommended way to display complex data in your apps. These views have superior memory management over ListViews for scrolling through large sets of data. They also allow for the concept of a view holder, which can be thought of as a model that describes the view template for each item in your RecyclerView. Finally, these views also support improved layout options and the CardView design you might see in a lot of Android apps, which adheres well to Android material design standards. Conceptually, a RecyclerView works very similarly to a GridView. We still define a RecyclerView in our layout and then access it from the corresponding activity. A core advantage of a RecyclerView is the addition of the layout manager. This component allows you to customize how the items in your RecyclerView are displayed, whether that's a list or a grid, a staggered grid, or something custom. The layout manager also works in combination with an adapter, which still retrieves our source data and references the actual template file. For the purposes of our app, there are two methods on the RecyclerView that we are most concerned with. The first is onCreateViewHolder, which just allows us to define a model that represents each of our featured items. For our coffee app, that model includes an image, title text, and a description. Once that view holder is created, we can populate it from the onBindViewHolder method. This is where we set our text and, more importantly, make our Picasso call to get an image based on the URL that's passed in. Similar to the getView on our grid adapter, onBindViewHolder is called for each item as the RecyclerView displays them. Picasso is smart enough to load these images and handle all of the background details for us. Let's see how this works more closely in the next clip.

Demo: Adding Images to a RecyclerView
In this clip, let's review how a RecyclerView is set up and then see how Picasso can integrate with this type of component. Inside Android Studio, I have our FeaturedFragment layout open. Right now, this contains only a RecyclerView, similar to how our gallery was set up with our GridView. There isn't much else to see here so let's switch over to our Fragment class. Inside of the onCreateView method, we are creating instances of our LinearLayoutManager and FeaturedAdapter like we discussed in the slides. Together, these two components will take care of loading and displaying our data entities. The more interesting part of this method is that instead of just a list of URLs, like we used in our gallery, we now have a FeaturedItem class that represents the three pieces of information on each of our RecyclerView items. So for example, we're declaring the imageUrl, the title, and the description for each item in our RecyclerView. This FeaturedItem is just a plain Java class that's declared in our Utilities folder with properties for each piece of our recycler item. This is a pretty typical setup for a RecyclerView so let's look at our FeaturedAdapter to see where our layout really comes to life. Inside of this file, there are two methods we are most interested in. First, we have the onCreateViewHolder, which is called every time we need a layout to display one of the items in our RecyclerView. We can verify that using the layout inflator code here that creates a view using the template we provide and then uses it to create an instance of our ItemViewholder. That view holder closely mirrors our FeaturedItem model we looked at since it holds a view for each of the data types on that model. The most important part of this class though is the onBindViewHolder method. This method is called every time the RecyclerView needs to populate data for one of the items it's iterating through. It's inside this method that we want to call our Picasso code just like we did previously with the getView method inside of the GridView adapter. Right now, you can see that we're already assigning the title and description to our view holder's two TextViews. We simply need to add a third line of code in here for Picasso to load the associated image. So, I'll type out Picasso and then use the with method to pass in our context. We can then call load UrlHelper. BaseUrl and then get the item from our data using the position variable and then use the ImageUrl off of that item. Finally, we can load that into the ImageView of our view holder. So the main takeaway from all this is that you can use Picasso to retrieve items inside of the onBindViewHolder method of a RecyclerView. Just make sure your view holder structure has an ImageView for Picasso to work with and you'll be all set. Let's run our app and see how this turned out. When the app loads, let's again click GET STARTED to continue into our main activity. This time when the app loads, we should see our nice list of featured items. Picasso has successfully loaded our images for us inside of the RecyclerView setup. This should give you a good idea of how to use Picasso in the context of various lists and layouts. In the next clip, let's look at one more example of how to load images with Picasso using URIs.

Demo: Loading Images Using URIs
In this clip, let's load an image with Picasso using a URI. Although this scenario isn't quite as common as loading an image from a web server or app resources, it can still add really useful features to your app so let's walk through a basic example. With our image gallery complete, let's say we want users to be able to upload their own images of their experiences at the coffee shop. So over in the Company tab, I've added a couple text labels and this UPLOAD button where they can submit an image for the staff to review. Suppose we want the use to be able to choose an image from their phone with this button and have Picasso load a preview of that selected picture. Inside Android Studio, I've created that simple UPLOAD button on our Company tab layout. Aside from a few styling properties, there's nothing too special about it. Once they click that button and choose an image, it should appear in the ImageView I've added below. And that's really all there is to it from a layout perspective. In the matching CompanyFragment, I have added an onClickListener to that button. This method is really simple. It just relies on an Android intent to launch an external app for the user to pick an image from. Intents can be used to launch all kinds of functionality like this to retrieve data from other apps, among other purposes. For this clip, we are mostly interested in handling the result of that launched activity, which brings us to this empty onActivityResult method. This method can be overridden on any fragment or activity that is automatically called when our intent is finished and the user has picked an image. Inside this method, we can gain access to the URI of that chosen image through the Intent data object. So, I'll type out Uri imageUri = data. getData, and this will give us the URI Picasso will need to load a preview. Below that, let's type out ImageView and name that imgPreview = getActivity findViewById and then pass in our image_submission ID from the layout. Finally, on a new line, let's type out Picasso. with and then get our context, and then pass in that URI to our load method, and finally also pass in our imgPreview variable into the method here. With all that in place, Picasso will be able to load the image the user selected as a preview. Let's run the application and verify that all of this works. So once the app starts, we first need an external image for our app to work with. I have Chrome open on our emulator so let's switch over there and then navigate to our helper website with all of our images. Again, the URL for that is alexwolfps. com/images, but you can also find any other image on the web. We can click and hold any of these images to download it, so just save whatever one you'd like to use to the device. Let's switch back to our coffee app and this time navigate to our Company tab. Now we can click on this UPLOAD button and you'll see that our downloads app opens up for us where we'll find that image. So just select the item and then you'll see we immediately switch back to our app and the image pops into place. Picasso has leveraged the URI from the activity result data to load our image. Now obviously in a real app you'd want to finish the upload process, but for our purposes this demonstrates the important concepts. So that concludes our examples of loading images from different sources using Picasso. In the next clip, let's wrap up the module so we can move on to improving our app's appearance through image transformations.

Summary
Picasso provides a number of options for retrieving images from different sources and displaying them in different types of components. Picasso's load method provides several overloads to retrieve images using a URL string, a URI object, a resource ID, or even an in-memory file. These options allow us to load images from a remote web server, images included in our project, or other local files stored on the device. Android allows us to define sets of images for different resolutions and pixel densities and works well with Picasso to load the right asset for the right device. We can easily display many images in a list using Picasso in combination with ListViews, GridViews, and RecyclerViews. These components rely on adapters, which Picasso can seamlessly integrate with to load large numbers of images. Through the use of intents and URI data, we can also use Picasso to load images from other apps such as image gallery apps or downloaded files. Now that we have all of our images loaded into our app, let's see how we can improve and manipulate the way they are displayed. So in the next module, let's explore the concept of image transformations.

Controlling Image Transformations
Introduction
Picasso offers a number of useful image transformation features. In this module, let's see how to use those options to influence the way our images are displayed. First, we'll explore the full list of features Picasso offers for manipulating images and look at a few use cases for each one. We'll then start by resizing some of the icons and images in our app to more appropriate dimensions for our layouts. We'll also see how to use Picasso's autoscaling features to improve the appearance of our galleries and better adjust certain images to different screen sizes. Once we're done resizing our images, we'll also see how to rotate them into different positions and just add some visual interest to our app design. Picasso also provides more advanced options to change the appearance of images through custom transformations. We'll discuss what this feature is capable of and how to get started with a basic example. We'll then put those concepts to work with a simple demonstration of custom image cropping. Image transformations can be really rewarding to work with since they provide very quick results with minimal code. So let's get started improving our app in the next clip.

Exploring Image Transformations
In this clip, let's review the different types of image transformations offered by Picasso. Most of these options are implemented through easy-to-use helper methods, but it's still important to understand the technical nuances of each one. The first type of transformation to consider is image resizing, which is implemented through the appropriately named resize method. This method simply accepts pixel dimensions for the targeted image size. So for example, if we take a 300x300 image, we can manually resize it to 500x500 pixels. This is useful for scenarios where you want to programmatically set exact pixel dimensions for an image. Interestingly, the resize method by default does not consider aspect ratio in its sizing. So if we reuse that same 300x300px image, Picasso has no concerns or problem with resizing it to 600x400. This will obviously distort the appearance of the image so it's something important to keep in mind. One other consideration of the resize method is that the parameters are straight pixel values, which can cause problems on different devices. For example, a 1024px image might show up pretty large on a smaller, low resolution screen; however, that same image viewed on a very high resolution screen would appear much smaller because there are far more pixels in the display. Android can help us resolve this issue with a concept you might have worked with already called density pixels. Density pixels, which are also called DPs or dips, are a virtual, devise-independent unit of measurement for defining layouts. These units can be used to scale UI elements proportionately across different screen sizes and resolutions so that elements appear to take up similar amounts of space. So let's say we have a 4in screen with 480x640 resolution and another 4in screen at 960x1280. Android uses a formula that combines the physical screen size, the screen resolution, and a base reference density to calculate how many physical pixels 1dp should be for each device. Now using this formula, conceptually the higher resolution screen of the same size will have about twice as many physical pixels per density pixel. So in more practical terms, density pixels allow us to set an ImageView in our layout to be 150x150dp and expect it to take up roughly the same amount of screen space from one device to the next like we see here. There may be minor differences due to how DPs are calculated, but the results should be fairly close. We can then use Picasso to load an image and auto scale it to fit that ImageView using a few different helper methods. Now you can do pixel to density pixel conversions programmatically to resize images, but for general image sizing it can be easier to just set DP values in your XML markup. Picasso offers three scaling helper methods that take different approaches to fitting an image inside of a view. So let's say we have a source image with dimensions of 1000x500px and an ImageView of 300x300dp. The first scaling method is called fit, which simply changes the dimensions of the image to fit the target view, ignoring aspect ratio and potentially causing distortion. The second method is called centerCrop. This method builds on top of fit, but maintains aspect ratio. It will scale the image up until both dimensions fill the sides of the ImageView and then re-center the image and cut off any part that extends beyond the bounds. So in this case, the faded areas inside of the blue rectangle would be hidden. The third method is called centerInside and also builds off of the fit method. This option will, again, proportionately scale the image, but only until the entire picture fits inside the bounds of the ImageView. It will then also try to center the image and leaves empty space wherever the image doesn't fill. The third main type of transformation is image rotation. Picasso's rotation feature is pretty straightforward and provides just two different overloads. First, we can simply supply a number for the degree of rotation we'd like to apply. So for example, 180 would result in the image being flipped upside down. By default, Picasso rotates images from their center, but it also allows us to rotate an image based on a custom pivot point. In addition to the rotation degrees, we can also pass in additional coordinates for a new pivot point. So for a 300x300 image, if we pass those values in as x and y pivot point coordinates the rotation will then be based off of the lower right-hand corner instead of the center. In the next clip, let's start to look at a few examples of these transformations in action starting with image resizing.

Demo: Resizing Images
In this clip, let's use Picasso's resize method to change the appearance of a few images in our app and to understand the implications it has for different device sizes. So I have our coffee app open again, and on the Company tab we still have our checkmark icons in place. Right now I think these icons are a little too small so let's try making them larger using Picasso's resizing feature. Let's also try to scale this banner image up so that it fits the full width of the screen. Back in Android Studio, I have the CompanyFragment layout open. Right now, the size of these icons is explicitly declared in the XML markup. This will override the size we set using Picasso. So, for this clip, let's change this 24dp value to something more flexible. So, I'll just replace those with wrap_content so the ImageView scales to contain whatever size we set. I'll leave the other two icons their original dimensions for reference. Let's switch over to the CompanyFragment class now and try to adjust the size of that first icon programmatically. So let's find the code that references that first icon. And then right after the load method, let's add in the resize method. So I'll type resize and then we need to pass in exact pixel dimensions. For now, let's go with 96x96 and we'll be all set. At the top of this fragment, let's also use one of Picasso's resizing methods to adjust that company image. So again, after the load method there, I'll simply type fit without any of the additional scaling helpers we saw in the size. This will change the image to the exact dimensions of the ImageView, regardless of the aspect ratio. So let's run our emulator to see what this gives us. Now I'm actually going to start up both of our emulators since the second has a much lower screen density and will give us a good idea of what's actually going on with our resize methods. So, first let's see how this change looks in our high-density emulator that we've been using all along. As I navigate over to the Company tab, it's a bit hard to see at this size, but our image across the top is slightly stretched too wide and is distorted in order to fill the screen. Below that, our first checkmark is also now larger than the other two. Now in this case, I actually kind of like how this looks, but I might want to resize the others to look just like it. However, let's switch over to our other emulator and see how this renders over there. You can see on this example, that checkmark is now far too large on the less-dense device screen. That's because since there are fewer pixels, 96 pixels actually becomes much too large for that display. This is why you might want to define your image sizes using density pixels in your layout. We can then use Picasso helpers to scale images up and down to fit those sizes, as we'll see in the next clip.

Demo: Improving Image Scaling
In this clip, let's see how we can improve the appearance of our images using Picasso's scaling techniques. This will solve the sizing problems from the previous clip, as well as some of the other visual shortcomings of our current setup. If we revisit our coffee app in the emulator, it's easy to discover a few different use cases for image scaling. On this featured items tab, it would be nice if all of these images were uniform sizes, meaning they should have the same dimensions and aspect ratios. The same can be said for our gallery, so if we switch over there we can see the same sort of problem. Now with a gallery, you might prefer the images show their original ratios and sizes for visual variety, but in our case let's make them all uniform to draw out the cool grid look that we already set up. Finally, on the Company tab, it would be nice if this banner image we sized in the previous clip stretched across the screen without distortion. It's very subtle right now but could look worse on wider displays. An easy way to visualize this is to flip the app sideways in the emulator. At the moment, our activity doesn't preserve the tab state so we'll have to reselect the Company tab. That's something you'd want to fix in a production app, but we won't worry about it for right now. Once we're back on the tab, you can more easily see the distortion, especially if you focus on the letters in the upper left. All of this is extremely simple to fix using Picasso's scaling features, so let's switch back to Android Studio and do just that. Inside of our gallery_item template, you can see that each item is set to 150dp high and it's also set to match the column width of the parent GridView. Since we're using density pixels, this should scale fairly consistently across different devices if we tell Picasso to simply fill the ImageView. Our featured items tab and the Company tab also use these density pixels to set their dimensions so we can apply the same scaling concepts to them as well. So first, let's open up our featured items adapter. Let's find where we're using Picasso. And then after this load method, all we have to do is type fit and then centerCrop. This will scale our images up until both dimensions fill the container, center that image, and then hide whatever extends beyond the bounds. Let's repeat that process in our GalleryAdapter. So, let's switch over there and then find our Picasso method inside of getView. I'll once again add fit and centerCrop after our load method, and then this will be all set as well. Finally, on our CompanyFragment, let's again add the centerCrop method after the image has been loaded and fit. This will help the image to stretch the full width of the screen while fixing the issue of maintaining aspect ratio that we introduced in the previous clip. Let's run the app on our two emulators and verify that everything looks how we'd like it to. So I've started out both of our emulators and navigated to the featured items tab. Right away, you can see that our images are nicely filling up their available space with a slight crop where they go out of the bounds. More importantly, you can see that these images have been scaled to fill about the same amount of screen space on both devices. If we switch over to our Gallery tab, you can now see that we have a nice uniform look to our images and it's consistent across devices. I encourage you to experiment with different sizing techniques and options to make this look how you'd like. Finally, our Company tab image now stretches the full width of the device without any distortion. We can verify that again by rotating the device and reselecting that tab. You might notice that we can no longer see the letters in the upper left. That's because our image was scaled and cropped slightly to fit this ImageView, which proves our sizing is working as expected. In the next clip, let's see how we can add a little more visual interest to our app using image rotations.

Demo: Rotating Images
In this clip, let's use Picasso's image rotation feature to add a bit of visual interest to our app. This will also be a great example of how Picasso can turn a fairly tedious task into something quick and enjoyable. In the previous clip, we improved the appearance of this image gallery using Picasso's scaling features. So right now we have this uniform grid look, which might be what you want. However, for more creative apps, you might want to add a little more visual interest to this. So, let's say for example we want to add a slight random rotation to every image in this gallery to create sort of a scrapbook look or to just make it feel a little more active. Let's return to our GalleryAdapter and see how Picasso can help us. Before our two scaling methods, let's use another Picasso helper called rotate. So, I'll type that out. And then this method has two overloads. The first just accepts the number of degrees we want to rotate, and the second also accepts coordinates for a pivot point if want to rotate the image off center. For now, I'll populate the first one, but instead of a number I'll just type degrees, which will act as a variable to hold a random number. Above this Picasso code, I'm going to paste in a little snippet of logic. This code just uses the Random class to generate a number between -10 and 10. The next int method generates a number between 0 and the value we pass in. In order to support negative numbers, we want to pass in double the max rotation and then subtract the actual max rotation. This ensures if the random number is as high as 20 we'll still only end up with 10, but if it's as low as 0 we'll be able to get -10 on the other end of the spectrum. We're then storing that value in our degrees variable and passing it to Picasso. So this formula will randomize a slight rotation on every image in the gallery with very minimal code. Let's run the application and see the results. So after our app loads, let's navigate to the Gallery tab. As this populates, you should see an interesting rotation pattern across all the images. Of course, whether you like this look or not is completely personal preference. The point here is just that we can easily rotate images in different ways using Picasso. What's also interesting about this setup is that the gallery will actually look slightly different every time it loads. So if I switch back and forth between tabs a few times, as I do this you should notice different rotation patterns every time we come back to the layout. These types of small enhancements can go a long way to making your app feel a little more interesting. Rotations or transformations like this can also subconsciously imply action. So if you have more interesting pictures of people or places, this can be even more effective. So that concludes the more basic resizing and rotation tasks in our app. In the next clip, let's start to look at more advanced scenarios using custom image transformations.

Understanding Custom Transformations
Picasso's built-in resizing and rotation features are great for the majority of use cases, but there might be times when you need some sort of custom image transformation. Picasso includes support for this functionality as well, though the process is much more manual than the features we've looked at so far. The need for custom transformations could obviously apply to a wide range of scenarios. A common use for this feature is often to apply different types of image filters or effects such as grayscales, custom shape cropping, or blurring effects. Unfortunately, Picasso does not include any of these features by default, but you can certainly create your own or use examples found online. Custom transformations are implemented using the aptly named transformation interface. This interface defines only two methods, which are called key and transform. Key simply returns an identifier for the transformation. So it's the actual transform method that we're interested in. This is the method where all of your custom logic goes to manipulate the original source bitmap. Transform is both useful and challenging since it's open-ended enough to do just about anything, but also does not offer a lot of implementation guidance. If you have interest in creating advanced custom image transformations, you should look into some of the Android drawing APIs such as Canvas, Paint, ColorMatrix, and many others. In this module, we'll just be working through a simple example using the Bitmap class since custom transformations can quickly become an advanced topic. These types of custom transformations are often very specific to a particular app or design goal, so for now we're mostly interested in the general workflow of creating one. So, for our simple example, many images by default have this sort of square aspect ratio like the coffee picture we see here. Often, we can make these images more visually interesting by cropping out the center of them to create a wider, sort of banner-looking image like you see here. So in the next clip, let's step through an example of how to create a custom banner transformation.

Demo: Implementing a Custom Transformation
In this clip, let's create a simple custom transformation that crops our image to a wider aspect ratio. Inside our Android app, let's revisit this Company tab again. I've removed all of the scaling transforms off of this image at the top so we're just back to the regular image. This image looks fine, but it might be a little more interesting if we cropped out the center of it into more of a banner shape. On our Company tab layout in Android Studio, I've simply set the height of this ImageView to 150dp and kept the width at match_parent. I've also added a black background to the ImageView, which will produce a nice effect around the cropped image. To start things off, let's create a new class in our generic Utilities folder. So I'll right-click and then choose to add a new class. And in the dialog that pops up, let's name that BannerTransformation and then click OK to confirm. Inside this class, the first thing we want to do is add the interface. So after the class name, I'll type implements Transformation. Once that's in place, we can hit Alt+Enter and choose to implement the methods on that interface. After all those are stubbed in, let's first take care of the key method. So, I'll type out return BannerTransformation, which will provide an identifier for this. Next, inside of our transform method I'm going to paste in a small code snippet that handles our cropping logic. This code is much simpler than it looks. First, we are simply getting the height of our source image and then dividing that in half to get the total height of margin we want to crop out to create a wider appearance. Since we're cutting the image height in half, I've created another variable to store the new cropped height of the new image. These two variables are a bit redundant since they have the same value, but I'm just creating both of them for readability. The most important line is where we are creating a new bitmap. First, we pass in the original source image. Next, we give an x and y coordinate for where we want to start cropping the new image out of that original source. In our case, the x is 0, meaning we'll start on the far left of it. And then for the height, we want to start at half of the total margin. So that ensures we're cropping the new image out of the center. The second two parameters are the sizes of that newly cropped image. We still want the original width and then we want to cut out the cropped image height, which is half of the original. Since we're creating a new bitmap, we're also just making sure to recycle the old one and then returning the new image. So that completes our Transformation class. Now outside of all of these calculations, the important takeaway is just that we're cutting a shorter image out of the center of the original image, which will create the wide effect that we're going for. Let's switch over to our CompanyFragment and apply this to our image. You can see that I've removed all of the transformations that were applied to this earlier in the module so we just have our simple Picasso load method. So after that, let's type out the Picasso transform method, and then we simply need to pass in an instance of our new BannerTransformation class. And that's all there is to it. Picasso will consume our custom transformation and adjust the image output accordingly. Let's run the app and see how this looks. So on the landing page, let's click GET STARTED and then navigate over to our Company tab. Sure enough, you can see our transformation has worked. We have cut out a slice of the original image, which gives it a more interesting look and includes this nice black border that we declared in our XML. Although this is a simple example, hopefully you can see the potential of this transformation interface. As you identify uses for it in your own projects, I encourage you to take the time to research some of the drawing APIs that might be specific to your needs.

Summary
In this module, we explored the different features Picasso provides for working with image transformations. Most of these options are implemented through easy-to-use helper methods. Picasso allows us to resize images to exact pixel dimensions or make them fit the exact size of an ImageView. This could be useful in some scenarios, but can distort the image if you're not careful. Exact pixel dimensions can also cause sizing problems across different screen densities, so Picasso provides scaling methods to work with Android's improved density pixels. Features like centerCrop or centerInside nicely scale images across these different screen densities. Picasso can also rotate images using one of the overloads of its rotation method. By default, Picasso rotates images from their center, but we can also provide coordinates to rotate from a custom pivot point. Picasso supports custom transformations through the useful Transform interface. This is a great option when your app requires more advanced, specific image customizations. Common use cases for this feature include color or blurring filters, custom cropping, and much more. So far, we've seen how to load, display, and manipulate the appearance of images. In the next module, let's start to shift focus to some of the more technical or behind-the-scenes behavior of Picasso. Caching is a powerful feature of Picasso that can influence how quickly and smoothly your images load so let's explore the details of that in the next module.

Working with Caching
Introduction
In this module, let's explore the robust caching features offered by Picasso. Now traditionally, caching can be a somewhat bland topic, but I really encourage you to complete this module. Picasso makes caching more enjoyable through the use of simple helper methods and fairly straightforward concepts. Caching can have an extremely significant impact on the overall performance and usability of your app so it's definitely a concept worth mastering. So we'll begin by reviewing some high-level concepts around caching, specifically in the context of Picasso in mobile apps. Once we're comfortable with those ideas, we'll see what tools Picasso offers to manage and configure those caching features. Next, we'll see how to monitor the cache activity of our app. This will allow us to understand its current behavior so we can modify and optimize it according to our user-experience goals. After we understand how our app is caching images, we'll see how to make simple configuration changes to achieve different results. We'll also take a closer look at Picasso's network caching policy. This is an interesting feature that allows your web server to influence the way images are cached on a device. Finally, we'll see how to gain further insight into our app's caching behavior through Picasso's logging and analysis features. So let's get started with an overview of Picasso caching in the next clip.

Picasso Caching Concepts
When building mobile apps, there are a huge number of ways to design and implement caching strategies. In this clip, let's examine the details of what image caching means for us in the context of Picasso and then see what high-level features this library provides for us. As we've already seen from working with Picasso, the most common use case for loading images is from a web service over HTTP. This is actually a slow way to retrieve an image, especially on weaker devices or slower networks. So if we need to display an image for one layout, we want to avoid making another network request for that same image every time it needs to be displayed. Picasso can help us solve this problem through various caching techniques. Caching can involve all kinds of technologies and concepts, so let's establish a working definition of caching in the context of Picasso. Caching is simply the process of storing images locally in memory or disk storage to improve performance for future requests. The distinction between memory and disk cache is important. Memory cache is the fastest type of cache and directly uses the device RAM to store the image. Disk caching is actually controlled by the underlying HttpClient that Picasso is configured to use such as OkHttp. The HttpClient can manage cache directories on the device's internal storage to persist images locally. This means if you quit the app and its resources are removed from the device's RAM, images can still be stored in a slightly slower, but more persistent cache for later use. Picasso's HttpClient relies on HTTP headers to manipulate disk caching. These HTTP headers provide additional metadata for requests such as the originating host or what type of content the client wants to receive back. The server can also attach HTTP headers to the response to provide the client with more information. This can include caching headers such as the common Cache-Control, which includes a duration for how long the resource should be stored. So in this case, the header would instruct Picasso's HttpClient to cache this image for 60 seconds. After that, the image should be considered invalid and requested again from the server. Picasso actually implements this caching process by default. So let's say we want to load one of our coffee images using a URL. Picasso first checks to see if that image is already stored in memory and if so it grabs it from there. If the image is not in memory, it then checks the disk cache. If it is in the disk cache, Picasso will load it from there, which is still faster than a web request. If the image is not found in either cache, then Picasso will make a network call to retrieve the image. Once it has that image, by default it then stores that file in a cache to speed up this process for future requests. In the next clip, let's review more specific tools Picasso provides to manage and configure these caching concepts.

Configuring Picasso Caching
Now that we understand the high-level caching concepts surrounding Picasso, let's look at some of the more specific options for managing those features. Picasso manages caching through a variety of helper methods, though the two most important are memoryPolicy and networkPolicy. MemoryPolicy influences the cache behavior on the device's RAM while networkPolicy influences the disk cache. These two methods behave pretty much identically for the respective cache. Although the disk cache is still local to the device, it's referenced through a networkPolicy since the underlying HttpClient is what ultimately controls it. Both of these methods accept enumeration values called No_Cache and No_Store, which apply different configurations. So for the memoryPolicy helper, let's say we request an image from a web service. If we call memoryPolicy with a value of No_Cache, this tells Picasso to ignore the device memory cache. It's important to note that Picasso will still check the disk cache, but if it doesn't find the image there it will directly request it from the web service. If we make that same memoryPolicy with an additional configuration of No_Store, the returned image will also not be placed in the memory cache for future uses. So as you can see, applying both of these configurations essentially removes the memory cache from Picasso's loading process. The networkPolicy helper works in a similar way only at the disk cache level. If we call networkPolicy with a value of No_Cache, this time Picasso will check the memory cache, but skip retrieval from the disk cache. And likewise, if we provide a value of No_Store, the response image will not be saved to the cache directory for future use. You can, of course, also use all of these caching policies in combination. For example, calling both memoryPolicy and networkPolicy with both configuration values will result in no caching of any kind for that image, meaning a full HTTP request will always be made to retrieve it. This can be useful in some scenarios where you want the very latest image. Picasso also includes some basic logging features that allow us to analyze what's going on during our requests with different cache configurations. This can be useful for seeing information like which cache an image was retrieved from, how long a request took, what URL an image was retrieved from, and much more. You can also use Picasso to get a snapshot of the current caching state such as how much space it's using on the device. Picasso also includes a cool feature that lets you visually see the caching behavior of your images using colored indicators. These indicators show a different color for whether the image came from memory, the disk cache, or from the web service. This can be a useful way to browse your app and really tell what's happening and where you might want to make changes. In the next clip, let's use this technique to get a better idea of how our app is currently caching images, and then we can experiment with changes from there.

Demo: Viewing Cache Activity
Before we start adjusting any cache configurations in our app, let's first get a good idea of what's already going on. So in this clip, let's see how we can use Picasso's visual indicators to track our caching setup. Adding caching indicators to your app is very simple. In fact, it only requires one line of code. Our landing page is where we load our first image, so let's enable this setting right there. Indicators are turned on globally, so we'll see it in action on other layouts as well. So above where we're loading our image, I'm simply going to type out Picasso. with(this). setIndicatorsEnabled and then pass in a value of true. And that's all we have to do to make this work across our application. The interesting part of this setup can only be seen from the app itself, so let's go ahead and run the project to see what this produces. When the app loads, right away you should notice this red triangle in the corner of our landing page image. Red means that the image was requested over the network, which is the slowest option. This makes sense though since our app was freshly started on this emulator. Let's click GET STARTED to move further into the app, and you should see more red triangles appear as the images load from our web service for the first time. Things get a little more interesting if we switch over to our Gallery tab. You should notice that some of these images with a green triangle render almost instantly, whereas the red ones populate a bit slower. That's because these green images were already loaded on the first tab so now they were pulled from memory. The red images were not loaded on that first tab so Picasso had to make web requests to get them. If we now switch back to our first tab, you'll see that these show up almost instantly with a green triangle. Picasso is pulling them from memory now rather than making additional web requests since it's the same image again. This is much faster and makes our app feel more responsive. Finally, let's switch over to our Company tab. Interestingly, here we'll get blue triangles rather than green or red. That's because, if you remember from earlier in the course, all of these images are actually loaded from our drawable resources. This means, by default, they were pulled from local storage since there is no web request to be made. If we switch over to our gallery and then back again, you'll notice those same images now show green triangles. Picasso loaded them into memory the first time we retrieved them so now they will render even faster. In the next clip, let's see how we can start to use memoryPolicy configurations to modify this setup.

Demo: Configuring Cache Policies
In this clip, let's work through a few simple examples of how to configure Picasso's memory and network caching policies. I have our app running in an emulator, so let's consider a few caching changes we could potentially make. For example, let's say this featured items tab updates frequently. Maybe there are daily specials or even promotions throughout the same day for breakfast or lunch. Every time the users access the app, we want to make sure they see the most recent highlights. So maybe we're willing to make slight performance sacrifices to drive those featured items. One solution to this scenario is to prevent Picasso from ever using cached images on this screen. Over in Android Studio, I have the FeaturedAdapter open. To prevent these images from ever being loaded from a cache, we need to add two configurations. So first, I'll add memoryPolicy and pass in an enum value of NO_CACHE. Below that in the same way, I'll type out networkPolicy and again give it a value of NO_CACHE. Together, these two lines of code will prevent retrieval from both the memory and disk cache. Now if you remember from the slides, these methods can also take a second value of NO_STORE, which you can see if I start to type that in here. However, we don't want to use that value for this scenario. It's fine with us if Picasso adds those images to the cache for use elsewhere in the app where the same image might be displayed. We just want to make sure it doesn't retrieve them from the cache for this specific request. These configurations are easier to see visually in our app. So let's run the project and make sure this works as expected. Once the app loads, let's click GET STARTED to move to the featured items tab. You should see that all of these images have a red triangle in the upper left corner as Picasso initially requests them from the web server. However, watch what happens if we switch to the Company tab and then move back to that first one. Our images still take a moment to reload and still have the red triangle in the upper left. Instead of loading these images from a cache like we saw earlier, Picasso will continue to request them from the web server every time. This results in slower performance for more network calls, but it does ensure we always have the latest images. Another interesting side effect of this configuration can be seen if we switch over to our second Gallery tab. You'll see that all of the duplicate images from our first tab instantly load from memory while the new images are retrieved from the web server. Again, that's because the images from our first tab were still stored in cache for the rest of the app to use even if they aren't retrieved from the cache on that initial screen. In the next clip, let's look at networkPolicy caching in a little more detail.

Demo: Understanding Network Policies
Let's explore how Picasso's network caching policy works in a little more depth. In the previous clip, we disabled cache retrieval on this featured item's list to make sure the user always sees the most recent image. However, this is a bit of a sledgehammer approach since we could use something with a bit more granular control. If we know promotions only change a few times a day, it would be nice if we could cache these images for maybe 30 minutes or an hour. This means they won't be requested every time the user views the screen during their active session, but if they check the app later in the day it will get the latest images. Earlier in the module, we discussed how networkPolicy caching is controlled by Picasso's underlying HttpClient. That client relies on HTTP response headers from the server to make some of its decisions. This way, we can control how long our app caches certain images using settings that are controlled on the server. To better illustrate this, I have our images' web page open in Chrome along with the Chrome dev tools. These dev tools make it really easy to monitor network traffic and headers. So, let's click on one of these images to see what happens. In the Network tab on the right, we should see that request appear in the list. We can click on it to gain a preview of the request and response headers. Notice there is a Cache-Control header included on the response from our web service. Picasso's HTTP tooling is able to read this header and use it to provide network or disk-level caching. The max age value here states that this image should be cached for 10 seconds. This means if Picasso tries to load an image from disk and it's over 10 seconds old, it should retrieve it from the web service again instead. In a real app, you could set this to 30 minutes or however long you'd like, but I've shortened it for our demo. Let's see how to utilize this setting in our app. Over in Android Studio, let's focus on this FeaturedAdapter again. To keep things simple, let's completely disable the memory cache for the featured images and rely entirely on the disk cache using our networkPolicy settings. So I'll delete the second line here, and then let's pass an additional value to our memoryPolicy that prevents the memory cache from even storing these images. Now the default behavior of the networkPolicy is to store and retrieve images from the disk cache so we actually don't even have to add any additional settings. Since we've removed the memory cache functionality, images will be cached in disk storage for however long our HTTP header specifies. Let's run the app and prove that this works. So, in the emulator, let's navigate to our featured items tab. Right now, all of these images show as red, which means they were requested from the server, and that's what we'd expect. If we switch to the Company tab and then switch back, you should see that these colors have now shifted to blue. Blue means the image was loaded from the disk cache, which first verifies their top-level memory cache was skipped and, more importantly, that our HttpClient is indeed populating our disk cache. Now, the most interesting part of this can be seen if we again switch to our Company tab. And just make sure that 10 seconds or more have passed, and then switch back to the featured items again. You can see that all of these images, once again, are slower to load and have returned to red icons. So why did this happen? Well, if you remember from our Cache-Control header we saw in Chrome, the max age of those images is set to 10 seconds. Picasso tried to load these images, but the underlying component saw that they had technically expired past their cache duration so it ended up requesting them again from our web service. So this should give you a good idea of how memory and network cache policies work in Picasso. In the next clip, let's see how we can use Picasso's logging features to further explore our app's caching behavior.

Demo: Logging and Analyzing Caching
So far we've seen how to influence caching policies in our app and how to use indicators to generally understand where our images are coming from. If you'd like more detailed information about what's going on for troubleshooting or other reasons, Picasso does provide some decent logging options that are really easy to use. Like many features of Picasso, logging is very simple to use and is actually implemented through a single helper method. Picasso logging is turned on globally, so let's revisit our landing activity where Picasso first goes to work. Above our other Picasso code, let's simply type out Picasso. with(this) and then we can add setLoggingEnabled with a value of true. This one line of code will turn on Picasso logging across our app until we explicitly turn it off again. I've also removed the custom cache policies we set in previous clips on our two adapters so we can just view the default behaviors in our logs. That's really all there is to it in terms of code, so let's run the app and see what these logs actually look like. So, I have our emulator open and I've also cleared out our Logcat tab in the background in Android Studio so we have an empty session to start with. Let's click GET STARTED to navigate to our featured items. In the background, you'll see our logs populate. And if I scroll through here, you can see log details of many concepts we've discussed. For example, Picasso first creates four network requests for our images at the appropriate URL, and then we can see where it's queuing them up in the background and executing them. We can also see the total amount of time they took to be delivered. So using these logs, you can do some light performance analysis. Back in our emulator, let's switch over to the Company tab. In the Logcat window, you can see where it says four images were loaded from disk, each taking a couple hundred milliseconds. If we scroll up and compare that to our images, you can see those took on average two or three times longer to complete. This proves that our disk cache is faster than making a network request. Finally, let's switch back to our first tab again now that those images will be stored in memory. Logcat will report that four images were loading from memory, which is what we'd expect. Unfortunately, we don't get exact millisecond times for those loads, but it's clear they are much faster since they appear instantly. These logging features are useful for lightweight troubleshooting and debugging so I encourage you to play around with them and get comfortable with the output data. Let's wrap things up in the next clip so we can continue exploring more of Picasso's technical details in the next module.

Summary
In this module, we focused on caching, which is one of the most useful features of Picasso. Caching can really improve the performance and overall usability of your app. Picasso provides two layers of caching through the use of memory and disk caches. The memory cache stores data in the device's RAM while the disk cache stores images locally in a slightly slower, but more persistent space. Unlike memory cache, the disk cache can persist after the app has been closed or removed from memory. We're able to visually see whether images are loaded from a specific cache or a network request through Picasso's cache indicators. These icons provide an easy, color-coded option to get a feel for how your images are loaded as you browse the app. Picasso includes two primary methods for manipulating caching, which are called memoryPolicy and networkPolicy. These respectively control the memory in disk caches and allow us to configure storage and retrieval from each location. The networkPolicy and disk cache utilize Picasso's underlying HttpClient. Using HTTP header values from the server, we can manipulate how long images are stored on the device. Picasso also allows us to turn on logging functionality through an easy-to-use helper method. This provides us with useful information such as where an image was retrieved from, how long it took, and the execution steps involved. This module provided us with some useful information about the inner workings of Picasso. So in the next module, let's continue that journey by looking more closely at how to manage Picasso requests.

Managing Request Activity
Introduction
In this finale module, let's look more closely at some of the other features Picasso offers for managing image requests. This will include topics like how to improve our image gallery's performance and user experience, how to add more custom logic to the loading process, and much more. So first, we'll explore how to background request images with Picasso and not display them immediately in an ImageView. This can be useful in some specific scenarios, particularly in the context of caching, which conveniently builds off of the concepts from the previous module. We'll then start with a simple example of how to handle situations where Picasso fails to load an image. There are a few different ways to deal with these situations, but we'll start with a technique that can handle the majority of use cases. Picasso also includes a feature to use placeholder images during the loading process so we'll see how to use this and improve the overall experience of our app. We'll also discuss a powerful feature called tags and how they can be used to control groups of requests at once, as well as the request lifecycle itself. We'll then use those tagging concepts to improve the performance and responsiveness of our image gallery. Finally, we'll discuss a concept called Picasso targets and how they can be used as alternatives to loading images directly into ImageViews, handle additional error scenarios, and more. Now many of the concepts in this module are extensions of previous topics we've explored in depth, so let's dive right into the code and make some final enhancements to our app.

Demo: Preloading Images with Fetch
In this clip, let's walk through an example of how to use a Picasso method called fetch. Fetch is a useful method that allows us to request images without immediately displaying them anywhere. One of the primary uses for this method is to populate the cache ahead of time, but it can be used for other purposes as well. Let's look at one example of how to use this method to improve our app's user experience. If we revisit our app in the emulator again, by now it's obvious that we keep starting on this landing page every time we open the app. Now, in a real app you might want to hide these types of launcher or tutorial pages after the user has viewed it. However, even if the user only visits it one time, we could still use it to improve the first impression of the app. So for example, when we click GET STARTED, you'll notice we have these images that load from our web server as indicated by the red triangle. Well, if we know the user is going to navigate to this page, we could actually preload some of these images for them so their first impression of the app is quicker and more responsive. So over in Android Studio in our FeaturedAdapter, I've removed any custom caching behavior from the previous module so we have a standard load method. To prepopulate images into the cache for this adapter, we want to switch over to the LandingActivity since that gets viewed first. Inside this class, we can use the fetch method to request the images that we know will show up on the featured items tab. Make sure you have the cache indicators turned on as well to verify that this all works as expected. The actual logic to accomplish precaching is surprisingly simple, so I'll paste in one of our code snippets from the exercise files for us to work with. So first we must include the smallest of images that are currently passed to our featured items adapter. Next, we're simply using a for loop to iterate through each of those image names and load that file using Picasso's fetch method. Up until now, we've only used the into method to display the retrieved file in an ImageView. Again, fetch works differently in that it doesn't actually display the image, but still stores the image in our cache. This means that while the user is reading the LandingActivity content, Picasso will secretly be caching images for them ahead of time. Let's run the app and see how this works. So when the app starts again, our landing page will still look exactly the same. However, behind the scenes, Picasso is hard at work requesting those images for us. So let's say we're done reading these bits of text and we hit GET STARTED to move into the core of the app. Right away you can see these images all load with a blue icon in the upper left. Even though this is the first time we've ever viewed these images in this app instance, they are already being loaded from the cache thanks to the fetch method. Although this is just one simple example, these types of considerations can all add up and really go a long way to improving the overall perception of your app. Now in the next few clips, let's look at a few other request-management tools that can further improve the user experience of our app, particularly in the context of our gallery.

Demo: Handling Load Errors
Let's look at another way to improve the user experience of our app using Picasso. Up until now, we've explored image-loading scenarios where everything goes like we'd expect. However, sometimes in real-world apps when you're working with dynamic data, you might encounter errors trying to load an image. Let's see how Picasso can help us out in these situations. I have our emulator open on the first tab, and in this case all of our images have loaded successfully. However, let's switch over to the Gallery tab and see what it looks like when some of our images fail to load. As the gallery populates, you'll see some empty spaces appear. Obviously, that's not ideal for the user since it looks odd and doesn't explain why there are gaps. We don't want the user staring at the screen and waiting to see if an image will load. Instead, we should visually let them know that there was a problem. Over in Android Studio on our GalleryFragment, let's see what's causing these empty spaces. I've renamed a couple of our images to file names that don't exist on our web server. Maybe an admin forgot to upload the pictures or perhaps they were deleted from a content-management system. Regardless, we want Picasso to handle those scenarios more gracefully. In the project demo files, I've included this additional image called error. If we open that up, you can see it's just a placeholder PNG with an x and a message that the image failed to load. It's also slightly transparent to make it more subtle. Picasso includes a helper method that lets us use a local drawable file when an error occurs and an image could not be retrieved. Since it's a local file, we don't have to worry about it not being available unlike our network-requested images. So over in Android Studio, let's right-click on our drawable folder and choose to show in explorer. Let's then drag our error image over into the main drawable folder since we aren't concerned about density versions right now. Then let's switch over to our GalleryAdapter and find where we're loading our images. Handling errors is very simple. After our load method, we simply need to type. error and then pass in the R. drawable. error ID. Picasso will now automatically load this image for us in place of the failed image from our web server. Let's run the app and make sure that this works. When the app loads, let's click GET STARTED and then navigate over to our Gallery tab. As these images start to load, you should see those same two gaps are now filled with our error image rather than just empty space. Although it still isn't great that two of our images were lost, this certainly looks nicer and tells the user what happened. In the next clip, let's look at another feature we can add to this gallery to further improve the user experience.

Demo: Using Placeholders
In this clip, let's cover a quick example of how to improve our gallery using Picasso's placeholder feature. So I have our app open on the featured items tab again, but let's pay close attention when we switch over to our gallery. Even though we fixed the issue of empty spaces when an error happens, this screen is still mostly empty as the images initially load into place. Now in our app, we are requesting relatively small images from a fairly quick web server. However, for larger images or more complex loading scenarios, it might take quite a bit longer to populate this screen. In the same way that we can load an image when an error occurs, Picasso also has a feature to load a placeholder for an image before it's even requested. Once the loading process is completed then the placeholder is swapped with the real image. This can be useful in a variety of scenarios so let's see how it works. On our filesystem, I have another image included in the demo files called placeholder. Let's include this image in our project so we can use it with Picasso. So I'll right-click in Android Studio to open that folder in the explorer as well. And then we can drag our placeholder image over into that drawable folder. Because this is a local file, Picasso will be able to quickly load it before our image network requests finish. With that image included in our project, let's now transition over to the GalleryAdapter where we're loading our images. After our error helper method, we can add another method simply called placeholder and then pass in our new drawable placeholder ID as well. Now Picasso will display this image while it waits for our real image from the web server to load. That's all there is to it, so let's start the app and see how it looks. Once the app loads, let's navigate into our tabbed view and then select the Gallery tab. Right away, you should see our placeholder images pop in and then fade or transition into the real images as they load from the web server. In some cases, this can add a smoother or higher-quality feeling to your galleries or image content, but in other cases it might be a bit distracting or overkill. You'll just have to decide on a case-by-case basis if you want to use this, but it's there if you need it. In the next clip, let's start to look at a more technical example of how we can optimize the request traffic from our gallery.

Understanding Tagging
So far, we've seen how to improve our gallery with error handling and placeholders, but these are really just simple cosmetic enhancements. Picasso includes another more powerful feature called tags, which can help drastically improve the performance and request management of our gallery. So tags are essentially a way of labeling or grouping your image requests to control many of them at once. So let's say we have an app layout with different sets of images. The Picasso tag method allows us to associate whichever requests we want with a string name. We can then reference that name later from a variety of helper methods to influence the associated requests. There are three simple Picasso helper methods that work with tags. So, let's say Picasso makes several requests to load images into our app, which have tags of featured and gallery since a tag name can be anything you want. The first helper method is named cancelTag. So if we call that with a value of featured, Picasso will instantly stop processing the request with that matching tag. The next helper is called pauseTag. So if we call that with a value of gallery, Picasso will appropriately pause those requests. Finally, the third method is called resumeTag. So if we call that with a value of gallery as well, those same requests will resume their activity and complete like usual. You can probably think of a few scenarios where tags would be useful such as allowing the user to cancel a batch of image downloads or pause requests when the UI changes. One of the most common use cases for tags actually exists in the gallery of our coffee app. Galleries are a nice feature to have in an app, but one problem they can create is huge amounts of HTTP requests. Each image has to be requested from the server and rendered in the app as the user scrolls through them. It would be nice if we had a way to gain more control over this to avoid unnecessary requests. We can accomplish this using tags. So let's look at this problem and solution more closely in the next clip.

Demo: Improving the Gallery with Tagging
In this clip, let's look at how to use Picasso tags to optimize the performance of our gallery. So when building image galleries like this, you should be mindful of performance. For example, if your gallery has a huge number of large images, you probably don't want to load every single file as the user scrolls through them, you just want to load the images they're actually pausing to view. Our app gallery only has a handful of images to work with so for this clip I've duplicated the list of image URLs several times to make it larger and scrollable. I also have Picasso's logging feature we looked at in the previous modules turned on with Logcat open in the background. This is really useful for seeing all the requests our app is creating. Scrolling through a ton of images will create a lot of log data, so I'm also filtering those logs to only show when an item is successfully loaded from the server. So watch what happens now as we scroll through this gallery. Right away, you can see Picasso rapidly trying to load all of the images even though we aren't actively looking at these as they fly by. It would be nice if we could prevent this waste of resources by pausing Picasso's image retrieval while the app is scrolling and then resuming the request when the user pauses to look. This is a great use case for request tags. Back in Android Studio, I have our GalleryFragment open, and there are just a couple of steps to make this work. First, I have changed our fragments that it implements the OnScrollListener, which gives us events to hook into whenever the user starts to scroll. Now we just need to implement the listener methods to make this work and tell our GridView to use this scroll listener implementation. So let's move down to the bottom of the fragment. And below where we're setting our adapter on the GridView, let's also set a scroll listener. To do that, we just have to type gridGallery. setOnScrollListener, and then we can pass in this since our fragment implements the scroll listener interface. You can also see where I've collapsed the duplicated list of images that makes our gallery more scrollable. Once that's set, below our onCreate method I'll paste in a small code snippet from the exercise files to make this work. The OnScrollListener interface requires two methods, which are onScrollStateChanged and onSCroll. We're only interested in the first method right now, which has a simple conditional inside of it. All we are doing is checking if the current scroll state is ideal and if it is we allow Picasso to resume loading like normal. If the state is not idle, that means the user is scrolling so we want to pause Picasso using the pause tag method. To make these tag methods work properly though, we need to associate our images with a tag over in the adapter where they're loaded. So inside the familiar getView method, you'll see where I've disabled the cache to make our image loading behavior easier to see. After our memoryPolicy method, let's just type out a simple helper called. tag and then pass in our gallery string to label these requests. Now we'll be able to reference all of the requests that come out of this adapter using that OnScrollListener in our GalleryFragment. Let's run the application to verify that this all works. So, after the app loaded, I just switched over to this Gallery tab again and cleared out our logs in the background. Let's use these logs to compare our new performance to what we saw earlier. So now as I start to scroll through these images, we'll see in the background there are very few or even no requests firing as I scroll. When we finally reach the bottom and stop scrolling, you can see our images start to pop in, and our log reflects that. So with only several lines of code, we've drastically reduced the number of HTTP requests our app creates. This reduces network usage on the user's device and also decreases the load on your server. It's also great to see the different concepts we've discussed starting to work together really nicely. For example, by using placeholder images, our gallery still shows a default image while we scroll to give the user an idea of how many images they're passing by rather than just empty space. Although we disabled caching for this demo, obviously these two concepts would work together really well. In the next clip, as we approach the end of this course, let's shift away from our gallery to discuss one more way to gain control over our image requests.

Demo: Working with Targets
In this clip, let's look at one more way to manage request activity through the use of a concept called targets. Throughout the course, we've seen different ways to load these images into the cache and of course directly into ImageViews on our layouts while there might be scenarios where you'd like more programmatic access to the actual request and the file that was retrieved. For example, maybe you want to run custom logic right when the image-loading process either finishes or fails. So let's say on our landing page if this initial image request fails, we want to alert the user they might want to check their Internet connection before they go any further into the app. We can accomplish this using Picasso targets. Now, there are better ways to handle checking an Internet connection across this app. For now though, we're just interested in a simple example to illustrate a few concepts. So over in Android Studio, let's revisit the LandingActivity code. By now, this into method should look pretty familiar, but it actually has additional parameter options outside of just an ImageView. This method also accepts an instance of the Target class. Picasso has an interesting quirk that prevents us from just creating a new Target class inline within this method. If we were to do that, it will be garbage collected before it can be used, so we need to create a strong reference to store the target in. So at the top of our class, I'll type out private Target mTarget, and then we'll be able to use this to store our target instance. Further down in our activity, let's create that instance. So below our ImageView, I'll start to type mTarget = new Target, and then Android Studio can help us stub out the methods for us to override. These methods are very straightforward, but let's walk through them one at a time. First, we have onBitmapLoaded, which is called when our image is retrieved successfully. Inside of here, we want to pass our image into the ImageView like usual. So I'll type landingLogo, which is our ImageView variable from further up, and then. setImageBitmap and pass in that bitmap parameter. This will essentially recreate the loading scenario we've been using throughout the course. OnBitmapFailed is obviously called when the request fails. It is similar to the onError method we looked at earlier in the module except instead of just giving a placeholder image we can run any logic we'd like. So in this method, I'll type Toast. makeText and pass in our context. And then I'll type out some kind of message like Your internet connection needs more espresso and then a length for it to display and finally our show method. The third method is named onPrepareLoad and runs before the image is loaded. We don't have a use for that method right now, but you could use it to create a loading message or something for a slow image request. Finally, we just need to pass in our target object to Picasso's into method. That's all the code we need to get this working, so let's start our app and see what happens. When your app first loads, the landing page should look like it always has. That's a good thing. It lets us know that our onBitmapLoaded method ran successfully and populated our ImageView. Testing the onBitmapFailed method is a little more interesting. To get this working, let's actually force-quit the app. So I'll clear that out a moment. And then let's turn on airplane mode in our emulator. This will cut off our Internet connection to simulate a loss of service. So in the pulldown menu here, I'll check that off and then we can relaunch our app to see what will happen. After a brief pause, you'll see our toast message appears, letting the user know the request failed and that they should check their Internet connection settings. So great, both of our custom logic scenarios are working after the image finishes loading. Now for more general image loading, I'd still recommend just passing the image straight into the ImageView like we have been. This option is really one of those features you probably won't use all that often, but it is extremely useful in those scenarios where you do need more control. In the next clip, let's wrap up the course with a few final thoughts and takeaways.

Summary
In this module, we reviewed essential techniques for gaining more control over your image requests. Picasso allows us to request images in the background using a method called fetch, which is useful for certain scenarios like prepopulating the cache. We can also handle any errors that might occur during the loading process using Picasso's error method. This feature allows us to use a local drawable file in place of any requested images that failed to load. The Picasso placeholder method also provides similar functionality except it loads an image for us at the beginning of a request. This allows us to improve the look and usability of empty space with a nice image. One of the more interesting features of Picasso are tags, which allow us to label one or more requests with a specific name. Using other helper methods like cancelTag or pauseTag, we can control the life of those requests all at once from other areas of our code. Finally, remember that Picasso can also load images into an instance of the Target class rather than just an ImageView. Target allows us to inject logic before and after a successful request, as well as run logic if the request fails. This can be useful in scenarios where you need more custom control over the loading process. So we've finally reached the end of our exploration of Picasso. By now, you should feel comfortable building your own apps that make use of images. As you continue to leverage Picasso in your apps, you'll discover ways to add interesting new features driven by image content. Images are one of the simplest ways to elevate your app from feeling like a sample project to a more professional experience. I've really enjoyed working through our sample app and exploring the great features of Picasso and I hope you have as well. Thanks for your time and effort, and I'll see you next time.

Course author
Author: Alex Wolf	
Alex Wolf
Alex Wolf is passionate about software development and mastering new technologies. He has several years of experience working almost exclusively with .NET platforms, such as SharePoint, NopCommerce...

Course info
Level
Beginner
Rating
0 stars with 2 raters
My rating
null stars

Duration
1h 57m
Released
9 Mar 2018
Share course

