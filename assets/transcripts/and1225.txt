Android Threads: Getting Started
by Mitch Tabian

Every Android developer needs to have a solid understanding of threads. Learn how to complete tasks on background threads by leveraging the various threading options available with the Android SDK.

Every Android application performs tasks, and if a task requires a lot of system resources, you run the risk of freezing the application. In this course, Android Threads: Getting Started, you will learn how to leverage threads and the various threading options available with the Android SDK. First, you will learn about the threading basics, which helps you gain a fundamental understanding of threads. Then, you will see how to communicate between different threads. Finally, you will explore how to implement several different threading options and determine which work best in the various situations youâ€™re likely to encounter. When you are finished with this course, you will have a foundational knowledge of threading on Android that will help you as you move forward to develop mobile applications.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
4.7 stars with 15 raters(15)
My rating
null stars

Duration
2h 19m
Released
15 Nov 2018
Share course

Course Overview
Course Overview
Hi. My name is Mitch Tabian, and welcome to my course, Android Threads: Getting Started. I'm a self-employed Android developer, and I'm here to teach you about threading on Android. Having a solid understanding of threading and asynchronously completing tasks is fundamental to every Android developer. Performing tasks that demand a lot of resources should never be done on the main thread. If they're done on the main thread, your application might stop responding. Some of the major topics that we'll cover include threading basics. I'll show you how to build a custom thread class for completing work in the background. Thread-to-thread communication. There's several ways to facilitate thread- to-thread communication on Android. I'm going to focus on using Handlers. Threading methods. The Android SDK has several different options when it comes to constructing threads. I'm going to explore the Thread Looper Handler pattern, HandlerThread, AsyncTask, and ThreadPools. By the end of this course, you'll have an excellent understanding of how you can leverage the various threading options to complete tasks on a background thread. Before beginning the course, you should be familiar with Android Studio, object-oriented programming, activities, and the activity lifecycle. I hope you'll join me on this journey to learn about threads with my Android Threads: Getting Started course, at Pluralsight.

Getting Started
Introduction
My name is Mitch Tabian, and welcome to my course, Android Threads: Getting Started. The goal I have for this course is to shed some light on one of the most confusing topics when it comes to Android development, threading. First of all, what exactly is a thread? When an application first starts on a device, the Android system starts a new Linux process with a single thread of execution. So there's one process and one thread. You can think of the process thread relationship as a hierarchy. First comes the process and then inside the process can be any number of threads operating independently of one another. For example, you've probably heard of this thing called the main thread. The main thread is the first thing that's created in the new process. It's also known as the UI thread. You've probably heard from your peers, your teachers, or superiors to never do work on the main thread because if you do, you can freeze the application. And if you freeze the application, you'll end up seeing something like this. A dialog that says, This application isn't responding. Do you want to close it? This dialog is something you never, under any circumstances, want your users to see. It essentially means that you failed as a developer to anticipate the resources required to perform a certain task. The result is an application left hanging and an angry user who's likely to instantly uninstall. So what can we do to avoid freezing the application? Or in other words, what can we do to avoid doing work on the main thread? Because that's the issue. The UI components exist on the main thread, so if we do any heavy lifting there, it can cause the UI to freeze. The solution is surprisingly simple. We can create more threads, and on those threads we can do the tasks that require a lot of resources. If the work is being done on a different thread, then there's no risk of freezing the application. The solution sounds simple, but practically speaking, it's not so simple to implement. Threading on Android is a confusing subject. Do you use a thread? A HandlerThread? An AsyncTask? What about a thread pool? With so many options, where do you begin? My goal is to shed some light on these confusing topics. By the end of this course, you'll be able to implement your own threads, your own HandlerThreads, AsyncTasks, and thread pools. And on top of that, you're going to have a great understanding of the pros and the cons of each, you'll know when to use what, and why.

The Story Behind the App
For the duration of the course, I'm going to approach app development from the perspective of a freelance Android developer. One day, while searching the internet for a definition for a word, you realize you don't like the way the dictionary explains it. Seeing as though you are a developer, you decide to build a dictionary application for yourself. That way you can record your understanding of a word and not rely on the internet. You decide to use the Room persistence library to save definitions in a SQLite database on the device. Database operations must be done on a background thread. If they're not done on a background thread, the UI can freeze. Since there's so many options when it comes to threading on Android, you decide to explore a handful of them and decide which one is best. There's a Thread/Looper/Handler pattern, HandlerThreads, AsyncTasks, and thread pools. You'll build the application and test each threading method individually to see which one works best for the dictionary app.

How to Use the Source Code Files
There's two ways you can get the source code for the course. Number one is by clicking on the Exercise files tab for the course on Pluralsight. And number two is by getting the code on GitHub. I'm going to show you an example of both. Here's one of my other courses, it's called Android Data Binding: Getting Started. To get the source code, you would just click on the Exercise files tab and then click on Download exercise files. That would give you all the code for the different modules of the course. Personally, I don't recommend doing it this way because GitHub is much easier, which you'll see in just a second here. If you want to get the code from GitHub, you want to go to my GitHub profile, which is github. com/mitchtabian. Then you want to click on Repositories, and you want to go to the Dictionary app. Every video in the course has its own code, and the code is organized into branches. So if you click on the pull-down right here, you can see all of the branches for the course. Each video has a start and an end version for the code. So the video named building-a-custom- thread-class, you can see the start is right here, and the end is right here. So starting the video, you would want this code, and ending the video, you would want to compare it and look at this code. I designed this course to be very easy to follow along if you want to code along. I don't really add almost anything off camera, so it should be easy for you to follow along, and if you do get mixed up, just check the branch by clicking here, and then looking at the code and making sure you got the right stuff.

Getting Started with This Project
Before we get started with the course content, I think it's important that we go over the starting point for the source code. Right now I have the branch checked out named Starting-Point. And as you can see from the play button up here, I'm currently running the application. As its name implies, this branch is the starting point for the application. Currently, there's no database operations being done and there's no threading. It's just a bare bones version of the app. Basically, it's a skeleton with fake data. The application has two activities: DictionaryActivity and EditWordActivity. The activity that's in view right now is named DictionaryActivity; I'll open it up. There's nothing fancy in DictionaryActivity. It's essentially just a RecyclerView with a bunch of words. The fake data is being added in the retrieveWords method. You can see I'm adding all the words to an array list named Words and it's from the FakeData class. If I open the FakeData class, you can see it just contains an array of a list of words. DictionaryActivity is just a list of words, but in the finished version of the app, we can actually search for words too. The starting point doesn't have that functionality added in yet since it relies on a database query. The other activity is EditWordActivity. I can get to EditWordActivity two different ways. One way is by selecting a word from the list. So if I click on a word, I'm taken to EditWordActivity. EditWordActivity has two states. The state that it's currently in is called the view state. If I double-click on the screen somewhere, I enter something called the edit state, or what I like to call the edit state. It allows you to edit the title of the word and the content of the definition itself. I can go back to the view state by clicking the checkmark or pressing the back button. That will also automatically save that word to the database in the finished version of the app. The second way I can get to EditWordActivity is by clicking the floating action button at the bottom of the screen in DictionaryActivity. So if I click the floating action button, I'm taken to EditWordActivity, but as you see it looks a little different now. Because the floating action button represents the addition of a new word, EditWordActivity looks different. You can see I'm entered in the edit mode or the edit state where I can enter a title and I can enter some content. If I want to save that, I click the checkmark. Now I want to bring your attention to the two classes that are in the persistence package over here. There's the AppDatabase and the WordDao. As I mentioned earlier in this module, we're going to be using the Room persistence library to save data to the database, or to help facilitate database transactions is a better way to put it. The last thing I want to show you is the dependencies. You can see the dependencies by expanding Gradle Scripts down here, going to the build. gradle app file, and then scrolling down to the bottom. There's three dependencies. The first one is for the Room persistence library, the second is for the RecyclerView library, and the third is for the Support Design library. Now that you have an idea of what we're going to be building in the course, let's start exploring the different threading options.

How Threads Work
What exactly is a thread? Or in other words, what are the unique set of properties that define what it means to be a thread? First, let's talk about the structure of a thread. Inside every thread is something known as the message queue. You can think of the message queue as a stack of work. The units of work are called tasks. Just to clarify, the fact that I have five tasks in this diagram is completely arbitrary. I could have 1, 2, 3, or 100 tasks, it's just a diagram. The key point here is that it's a stack of tasks, or a stack of work, units of work. The task at the top of the message queue is executed, then it's destroyed, and the next task is moved to the top of the queue. These units of work can be runnable objects or message objects. The last piece of this mechanism is the Looper. Every thread has a Looper. The Looper is responsible for managing the tasks inside the message queue. I like to think of the Looper as an engine. It's an engine that keeps the whole system turning. That's the general mechanism that runs inside every thread, including the main thread. Now that you have an idea of the components that make up a thread, I'm going to walk you through how to leverage threads in this project. On the left is a diagram representing the main thread in DictionaryActivity. DictionaryActivity is pretty much just a RecyclerView containing a list of words. On the right is a diagram representing the background thread that I'm going to be using to do the database transactions. As you can see, it has a Looper and a message queue. When it comes to performing tasks on the background thread, the most difficult part isn't building the thread itself, it's communicating with the thread. That's where the Handler object comes in. Suppose we wanted to query the database and retrieve all the words in the dictionary. We need to tell the background thread to query the database and then send the words back to the main thread where they could be displayed in the RecyclerView. The first thing we need to do is send a message to the background thread and let it know what we want it to do. So we create a message object on the main thread, that message object will get sent to the background thread, using a Handler, the message is then added to the message queue, then it's executed when it reaches the top of the stack. Once the database query is complete, the Looper cleans up the message queue and it's time to send the queried data back to the main thread. Once again, another message object is created. The data is attached to the message object using a bundle, and a Handler facilitates the passage of the message from the background thread to the main thread. Once the message is received, it moves through the main thread's message queue, and then the data is eventually added to the RecyclerView. Generally speaking, that's the system that we're going to implement in this project.

Implementing the Thread/Looper/Handler Pattern
Introduction
In this module, we're going to implement the Thread/Looper/Handler structural pattern for completing tasks on a background thread. When it comes to threading on Android, there's a handful of options. There's a Thread/Looper/Handler pattern, HandlerThreads, AsyncTasks, and thread pools. You can think of the Thread/Looper/Handler pattern as the building block for the other options. Essentially, it's the lowest common denominator. HandlerThreads, AsyncTasks, and thread pools are all convenience classes meant to reduce the amount of code developers have to write when constructing new threads. So it makes logical sense to start with the Thread/Looper/Handler pattern. That way you'll have a solid understanding of how threading works on Android, and an appreciation for all the convenience classes. The overall objective of this module is to implement a system for completing tasks on a background thread. More specifically, we need our dictionary application to be able to do the following database operations. We need to be able to save new words in the database, we need to be able to update words, we need to be able to retrieve words, and delete words. We'll be using the Room persistence library to facilitate database transactions. If you're unfamiliar with the Room persistence library, it's just a set of convenience classes that make it easier to read and write to the device's internal SQLite database. If you want more information on the Room persistence library, I suggest watching Omri Erez's course on Pluralsight. It's named, Building Apps with Android Architecture Components. He has an entire module on the Room persistence library. If you are familiar with the Room persistence library, then you know all database transactions must be done on a background thread. The library will literally not allow you to do them on the main thread. It will throw an error and crash the app. As you'll see in the module, constructing a system to facilitate database transactions using the Thread/ Looper/Handler pattern is not a trivial task. Since we're going to building the thread from scratch, there's a lot of code to write. The first thing we'll do is actually build the custom thread class. That means creating a new class and extending it by thread. Inside of the custom thread class is where we're going to do all the database transactions. Next, we need to implement a system for communicating with the background thread. That means sending messages from the activities to the thread. The messages will tell the thread what work needs to be done. For example, we need to send a message that says retrieve all words from the database. When the thread receives the message, it will query all the words from the database. To send messages from the activities, aka from the main thread to the background thread, we'll be using something called a Handler. Handlers have the ability to hold message objects and then pass them to different threads. Similarly, when the work is completed on the background thread, we can use a Handler to send another message object back to the main thread. Message objects have the ability to hold objects in a bundle, so that's how we're going to send words back to the activity for the dictionary. An Android course on threading wouldn't be complete without at least touching on the subject of memory leaks. There's a number of ways applications can leak memory. In the context of threading, memory leaks usually occur when a reference to an activity is saved on a background thread. The Android garbage collector is unable to clean up activities if there's a reference to one saved in memory somewhere. So all the objects, the views, and the variables that are associated with the activity will get stuck in memory limbo. I don't think I need to tell you that this is a very bad thing for performance. Phones have a limited amount of memory, and wasting this valuable resource on an activity that's no longer being used is no good. Since Pluralsight already has a really great course on memory leaks and performance issues, I'm not going to be talking about this topic in very much detail. So if you want more information, make sure to watch the course named Overcoming Common Performance Barriers by Omri Erez. In this course, I'm going to focus on the points in time when memory leaks are most likely to occur. The most common trigger is when an activity is destroyed. If there's a reference to that activity saved somewhere on a background thread, you're going to get a memory leak. So the question becomes when are activities destroyed? We're going to focus on configuration changes, more specifically screen rotations. When the screen is rotated, the activity in view is destroyed, and then recreated. This is a prime point for a memory leak to occur.

Building a Custom Thread Class
When creating a custom thread class, they all follow the same general structure. If you take a look at the diagram on the right, that's what our system is going to look like. There's a Looper managing the message queue and tasks being moved through the queue. In this video, I just want to get started building the custom thread class. We'll talk about the Looper and how to set it up. Here I am in Android Studio. As you can see from the bottom right hand corner, I have the branch checked out that's named building-a-custom-thread- class-start. So it's this one right here. I have that branch checked out. That's going to give me the starting point code for this video. Now the first thing I want to do is actually create a new package where I'm going keep all the classes that are involved in threading. So I'm going to click on the main package directory, I'm going to right-click, go to New, and go down to Package, and I'm going to call it threading, all lowercase. And click OK. Now inside the threading package is where we're going to put our new thread class. So I right-clicked on it, I'm going to New, Java Class, and I'm going to call it MyThread. Now since we're building a custom thread class, the first thing we want to do is actually extend by the thread class. So I'm just typing extends by Thread, and you can see that there's no warnings or anything because there's no mandatory override methods that I need to insert. The first thing I want to do is actually type logt to insert a log for debugging, just so if we want to enter any logs later we're going to have a tag ready to go. And the first method that I want to insert, the only method that I'm going to insert actually in this video, is the run method. The run method is the one that's first executed when the thread is started. To get the run method inserted here I'm going to press Ctrl+O on Windows, or if you're on a Mac, you're going to want to press Cmd+O, and I'm going to search for the run method; you can see it's right there. I'm going to delete the super because we're going to be implementing our own custom system here. So when you implement your own custom thread class, you also need to initialize the Looper, because remember, every thread has a Looper that manages the message queue, but when you build a custom thread class, you need to initialize the Looper manually. And we can initialize the Looper by calling Looper. prepare. That's going to prepare the Looper. And after that, we want to call Looper. loop to loop it indefinitely. That's going to loop it forever as long as the thread exists. You can think of Looper. prepare as starting the engine and then Looper. loop as starting to drive the car at a constant pace and it's going to continue driving forever until that thread is stopped. Before we move on, I want to initialize one more thing. If we refer back to our diagram, every thread is going to need Handlers to pass messages to the message queue. We have our Handler, and that's going to facilitate messages coming in and then getting added to the message queue. So, we need a Handler. Later, we're going to be building a custom Handler, but for now I just want to initialize one just so you can kind of get the feel of what's going on here. So we're going to go private Handler, just a plain old Handler object, I'm going to import the android. os. Handler library, and I'm going to call it mMyHandler, and set it to null. Now inside the run method, after the prepare method is called on the Looper, we're going to go mMyHandler = new Handler and we want to do Looper. myLooper. You can see that there was a couple options there, let me just go back here. So there's Looper. myLooper, Looper. getMainLooper, those are actually the two options. You can see that they return a Looper object. GetMainLooper will return the Looper for the main thread. Obviously, that's not what we want because we're on a background thread. We want to do the work on the background thread, not the main thread. MyLooper will return a Looper from this thread, so that's the one we want. So when this thread is started, the run method will be executed, The Looper will be repaired, the Handler will initialized on the background thread because it's referencing the Looper from the background thread, and then we're calling Looper. loop to loop the Looper indefinitely. So this is the basic structure for a custom thread class. Every custom thread class will have to do this. Now you probably have all kinds of questions at this point. How are we going to use the Handler to pass messages? How are we going to execute methods on this background thread? Where are we going to execute methods on this background thread? I'm sure you have all kinds of questions like I said, but in this video, I just want to get through the basic structure of a custom thread. And now later in this module we're going to answer and address all those questions that you have.

Communicating with a Background Thread
In this video, I'm going to build a custom Handler class for receiving messages from the main thread and passing them to the background thread, just kind of like you see right here. There's a Handler on the thread named thread 2 and it's receiving messages from the main thread. Alright, so let's get started. This is going to be a private inner class, so I'm going to call it class MyThreadHandler, and it's going to extend the Handler class, so android. os. Handler. And the first thing I want to do is insert the default constructor, so I'm pressing Alt+Insert on Windows or Cmd+Insert on Mac. And we want to get the constructor that takes a Looper as an input, because remember, we're going to be passing the background thread's Looper right here by calling Looper. MyLooper, so we want to still do that, we need this constructor. Now the method that's going to be actually executing all the database operations is going to be called Handle message because the Handler actually takes the message, receives the message, carries the message, and we use the method named Handle message to then execute methods in. So I'm going to press Enter a couple of times to give myself some space. I want to press Ctrl+O to insert an override method. I'm looking for handleMessage. That's the one right there. This is the one that's going to execute all the code. This is where we're going to put all of our database operations inside this method right here. And there's actually a lot of code that I want to put into this method, so I suggest going to GitHub to get it. So if you go to my GitHub page and you go the Dictionary application, you can see that I'm in the MyThread class right here, and it's very important that you check out the correct branch. So you can go to the branch over here, and you want to select the one that says communicating-with-the- background-thread-end. Not the start version, the end version because that's the video that we're on right now. So you can see I clicked that, and that's going to change all the code in here. So what we want is here's our handleMessage method. I want to basically just copy this whole thing. So copy the handleMessage method, should go down to right here, just so I don't have to type all this out by hand. So I'm copying that, going back to Android Studio, and I'm going to paste it over right here. So this is basically just a big switch statement. The message is coming in, the incoming message, you can call msg. what, which returns an integer value, which is going to be a constant value. And then the switch statement will call one of these cases. So it will be either WORD_INSERT_NEW, WORD_UPDATE, WORDS_RETRIEVE, OR WORD_DELETE down here. And then inside these switch cases is where we're going to actually execute code. So, for example, it would be execute code required to insert a new word. So this is the general structure of our Handler. Now I want to scroll up and I want to change this global Handler to say MyThreadHandler, we want to use the custom one that we just built, and then change this. And we're still passing the Looper because remember the default constructor accepts that Looper. And we're pretty much ready to go. So the last piece of functionality that we want to implement in the MyThread class in this video is building a method to facilitate communication from the activity to the thread. The method name is sendMessageToBackgroundThread, and it accepts a message object as an input. Now we want to send the message using the Handler. So we want to go mMyThreadHandler. sendMessage, which is this method right here, and we want to send the message. Notice that the method is public because we're going to be calling it from the activity. Now I'm going to do something that you might think is a little strange, but from experience, this is a good idea. So I'm just going to type it out and then I'm going to explain it. So, why did I do that? So sometimes it takes a few seconds or a few extra milliseconds to actually start the thread, so it's a good idea to add this logic just in case a thread wasn't quite started yet and you tried to send a message. So, for example, if I tried to start the thread, but it wasn't quite up and running yet, I tried to send a message, it would cause a null pointer and it would crash. So if that does happen, now that we have this logic in place, the null pointer will get thrown, the thread will go to sleep for 100 ms, and it's going to continue to try. The only way that this loop will break is if the message is actually sent. Just a little bit of error handling and kind of preparing for the worst-case scenario because sometimes this does happen. So now we're done with the MyThread class for now. We're going to go into DictionaryActivity and we're going to instantiate the MyThread class, we're going to start the thread, and we're going to try and send a message to the thread and see if we're able to receive it. So let's first of all, we'll create the MyThread object, call it mMyThread. And I want to scroll down, and I want to go down to the onStart method, and this is where I'm going to instantiate the thread. So mMyThread = new MyThread. And we want to start the thread by calling start. Now I'm going to create a method for sending a test message to the thread. There's our sendTestMessage method. We have the message object with a null Handler referencing the Constant WORDS_RETRIEVE, and then sending the message to the background thread through the method sendMessageToBackgroundThread. Now I'm going to call that method in the onResume method down here, sendTestMessage, that's going to send a test message to our thread. So you can see how I use the Constant WORDS_RETRIEVE, so if I go to the MyThread class, we expect this case to be fired right here. The WORDS_RETRIEVE case. So we expect to see handleMessage printed to the log, retrieving words on thread, and then it will print out the thread name. Actually, one last thing before we run it. Back in DictionaryActivity in the sendTestMessage method, I want to print a log that says sending test message. And I want to say Thread. currentThread. getName. That way you can see printed to the log what thread the message is coming from, and then when that message is received in the MyThread class, which thread the message is being printed on because you're going to get that same log output down here. So let's run it and let's take a look. Okay, now I have the app running. I'm going to go to the Logcat down here and make sure I select the correct device, which is this Nexus 5. And let's take a look and see what we see here. So we can see that setupRecyclerView is called, we have onStart being called, we can see our sendTestMessage method is being called, and you can see the thread is main. So that's the thread right there that's being called. If I go to DictionaryActivity, and I go right here to sending test message, and then to printing out the thread name, the thread name in this case is main. And as you can see in our handleMessage method, we're able to retrieve that message and it says it's printing from Thread-4. So you can see the thread is different. The message coming from thread main and the message being received in Thread-4. So everything is working as we expect. The message is successfully being sent from the main thread to the background thread.

Communicating with the Main Thread
All threads are structured the same way, including the main thread. The main thread is structured the same way as our custom thread class. It has a thread, a Handler, and a Looper with a message queue. The only difference is that on the main thread, all the UI components exist. So any long running operations can potentially freeze the UI. Since it's structured the exact same way as the background thread, communicating with it is also done the same way. We want to send a message from the background thread to the main thread. Just like when sending a message from the main thread to the background thread, we need to use a Handler to manage the messages. In the MyThread class, we created a custom Handler class to manage the incoming messages. In DictionaryActivity, instead of building a custom Handler, I'm going to leverage an interface that's provided with the Android SDK. The interface is called Handler. Callback. So I'm going to open up DictionaryActivity and I'll close the directory over here. I'm going to scroll all the way up to the top and I'm going to implement the interface. Handler. Callback. It's giving us a warning. I'm going to press Alt+Enter and click Implement methods, and you can see there's that handleMessage method, the same one that we used in the custom Handler. So I'm going to click Enter on that. And in here is where we're going to handle all the incoming messages that are coming from the background thread. Once again, this handleMessage method contains a lot of code, so I suggest getting the updates from GitHub. Here I am back at GitHub. I'm in the MyThread class, but we want to DictionaryActivity, so I'm going to click on DictionaryActivity here. And I'm going to go to the branch communicating-with-the-main-thread-end. That's the one we want. And if you scroll down to the bottom, you can see the handleMessage methods. So I'm just going to copy everything inside the handleMessage method, goes to right there, we're going back to Android Studio, and I'm going to paste it in. I actually forgot a bracket there, and return false. There we go. So there is our handleMessage method. You can see there's a bunch of different Constants: RETRIEVE_SUCCESS, RETRIEVE-FAIL, INSERT_SUCCESS, INSERT_FAIL, and so on. And then you have the respective log output messages also printing out here. Just like we did in the background thread, we need a Handler to facilitate communication. So I'm going to scroll up to the top and I'm going to create a new object, a new Handler object. I'm going to call it mMainThreadHandler because it's going to be a Handler that exists on the main thread. I'm going to instantiate it, and on create, so mMainThreadHandler = new Handler and then I pass this to the constructor. Notice that it's referencing the callback. It's referencing the callback interface, the Handler callback interface. That's why I'm passing this. So all the callbacks are going to get routed through this handleMessage method down here. We have a Handler for receiving messages in DictionaryActivity, but we need a way to actually send the messages from the background thread. So let's go into the MyThread class, and we're going to change up the constructor a little bit and add a new object. I'm going to go private, Handler, call it mMainThreadHandler, so it's exactly the same name as what we added in the activity. Now I'm going to insert the default constructor because we don't have a constructor currently. So I'm going to press Alt+Insert, go to Constructor, and I'm just going to grab the empty one, which is the first one there. And we want to pass the mMainThreadHandler as an input. Before we move on to the next part in the MyThread class, I want to address the warning in DictionaryActivity. Because we changed the constructor, now we can actually pass the Handler to the MyThread class. So I'm passing the mMainThreadHandler through the default constructor to the MyThread class. Let's go back to MyThread and we're going to work on the next part. We want to send a message back to the activity once a message has been received on the background thread. So inside the WORD_INSERT_NEW case, we're going to create a message object and send it back to the activity. Now that's not the only way you can send a message. In this case, I reference the Handler as an argument here, but you don't have to do that. I can actually copy this, comment this out, paste this below. I'm going to delete this line. I'm going to pass null to the Handler in this case. I'm going to go mMainThreadHandler. sendMessage, and then pass the message. That's going to give you the exact same result. So let's run it and take a look. So the app's running, now I'm going to open the Logcat down here, make sure I have the right device selected. And if I scroll down you can see I get the message sending from the main thread, the message is received on Thread-4, and then you have the handleMessage method being called once more on the main thread. So the message goes from the main thread to the background thread and then onto the main thread once again. So everything is working as we expect. Now in the code's current state it's actually to leak memory. If you've never heard of what a memory leak is before, don't worry about what I'm saying right now, just know that it is going to leak memory and we're going to look at in the video named Managing Configuration Changes, that's where we're going to address the issue. But if you do know what a memory leak is, I want you to sit and I want you to think about how this code is leaking memory. I want that just to kind of percolate with you and then in the video named Managing Configuration Changes, we're going to resolve the issue.

Managing Configuration Changes
If you build a custom thread class like we've done, you need to make sure it's lifecycle aware, or in other words, you need to ensure it's cleaned up when the activity is destroyed, and created when the activity is created. I'm going to open up the MyThread class. I'm going to scroll all the way to the top, and I'm going to create a new variable, a new Boolean variable. So private boolean isRunning, and I'm going to set it to false by default because the thread is not running by default. Then in the default constructor, I'm going to say isRunning = true, meaning the thread has started. Inside the run method, I'm going to check to see if isRunning is true. If isRunning is true, then we want to call our logic as regular, and that's it. So the way that you'd stop a thread is we're going to create a public method named quitThread, and inside quitThread we can set the isRunning Boolean to false. Now all we need to do to stop the thread is go to the activity that's using the thread and call the quitThread method. So I'm going to open up DictionaryActivity. I'm going to scroll up to the onStop method, which it looks like it's not inserted into the activity, so I'm going to scroll up, and I'm actually going to insert it. Oh, it's right there. There's onStop, and all we need to do is actually quit the thread. So mMyThread. quitThread, and that's it. That will no longer allow the thread to be running. Now if you recall from the previous clip, I mentioned something called memory leaks. I said that this code in its current state will cause memory leaks. Why do you think that is? Memory leaks occur when you save a reference to a context or an activity on a background thread, and then the activity is destroyed or attempted to be destroyed. When have we done that? When could you see that possibly happening? If you take a look at the MyThread class, there's no context or activity reference, but we do have a reference to the main thread Handler, a Handler that exists in the activity. Since the Handler object was instantiated inside the activity, and it holds a reference to the Handler callback interface, by extension the Handler holds a reference to the activity. So what happens when an activity reference exists on a background thread? It causes a memory leak. The Handler that's passed to the constructor from the activity will cause a memory leak. The solution to this problem is actually surprisingly simple. Memory leaks occur when the garbage collector tries to clean up resources, but it can't. In this case, the garbage collector won't be able to clean up the activity because the thread holds a reference to the activity. So all I need to do is remove the reference. So inside the quitThread method we can just set the mMainThreadHandler to null. That way when the activity is destroyed, the quitThread method will be called and the mMainThreadHandler will be set to null. Therefore, the reference to the activity will be gone. If you're still a little unclear, we can go back to DictionaryActivity. So when the activity is destroyed, onStop will be called, the quitThread method will be called, and our reference to the mMainThreadHandler will get set to null.

Executing Tasks on the Background Thread
Now that we have all the proper infrastructure set up for doing work on the background thread, it's time to actually execute some database operations. So here we have the finished version of the app on the screen. This is DictionaryActivity. DictionaryActivity needs to be able to retrieve a list of all the words, and also search the words if I filter on a specific text. So if I start searching fascism with fas, it needs to query that word alone. Also, if I click on a word, I need to be able to edit this word. So if I double-click on the screen, I can update the word. If I press the back button, I'm taken back to the list. The last operation is being able to delete a word. So if I swipe to the right on a word, it will be deleted. The first thing we'll do is we'll make some changes in the MyThread class. If you scroll up to the top of the file, we need to add a new object. That new object is an AppDatabase object. Private AppDatabase, I'll call it mDb. The AppDatabase object is the object that we use to access the database. It's part of the Room persistence library. If you take a look over here in the Project view and go to the persistence package, you can see that AppDatabase is right there. Once again, the AppDatabase and the Room persistence library technical details are out of the scope of this course. If you want more information on that, make sure to watch Omri Erez's course on Android Architecture Components. Now to instantiate the AppDatabase object, we're going to go into the constructor. I'm going to type mDb = AppDatabase. getDatabase, and you can see it takes a context as an input. So to satisfy this object, we're going to pass a context object through the constructor. And there we go. Now I know what you're thinking. You're thinking, Mitch, but you told me not to save context in a background thread. Well, in this case it's actually okay. If you open up the AppDatabase class, you can see that it references the application context, and that's okay. Saving a reference to the application context is okay in a background thread, but saving a reference to an activity context is not. Now it's time to actually build the methods that are responsible for the four database transactions. And I've created a gist to save some time. Visit this URL to get the code. If I scroll down to the MyThread section, you can see that there's four methods: saveNewWord, retrieveWords, updateWord, and deleteWord. I'm going to copy all four of those. I'm going to go back to Android Studio. I'm going to scroll down just below the sendMessageToBackgroundThread method and I'm going to paste them in. Make sure to import everything you need. Just importing all the dependencies. There we go. So you can see that there's four methods here. SaveNewWord, which takes a word as an input and then saves that word to the database. RetrieveWords, which takes a string as an input, called title, and it searches that word from the database. Sorry, a better way to put it is it searches for words that are like that from the database. It executes a SQL-like query. UpdateWord takes a word as an input and updates that word. DeleteWord also takes a word as an input, but it deletes that word. Once again, if you want more information on the Room persistence library, make sure to watch Omri Erez's course on Android Architecture Components. Now the next thing we need to work on is where we're going to call these methods. If you recall from the previous videos in this module, I said that we're going to be calling these methods inside the handleMessage method of our custom Handler. So I'm actually going to delete all this message stuff, and this is where we're going to put our methods to insert a new one, update, retrieve, and delete. Once again, to save time, I have created a gist. So I'm going to visit that same URL. I'm going to scroll down just a little further this time and copy the MyThreadHandler class. I'm just going to copy this entire thing, you can see there's a ton of code there. I'm going back to Android Studio and I'm just going to paste over the MyThreadHandler class. So I'm just making sure I got the right bracket there, pasting that in, and now I'm going to get all the import. So Alt+Enter to get all the imports. So let's take a look at what's happening here. In the INSERT_NEW case, we have a word object being instantiated from the bundle, a message object being created, then the saveNewWord method being called. If the length of the object returned from the saveNewWord method is greater than 0, then we create a message object that lets the user know that the word was inserted successfully. Otherwise, the word was not inserted successfully. After that, we use our main thread Handler to send the message back to the main thread. Now each one of these cases is pretty much the same. The only real differences are you're calling the different methods. So in the insert word case, you're calling the saveNewWord method. In the update case, you're calling the updateWord method, retrieve is retrieveWords, and delete is obviously deleteWord. But they operate generally the same way. The only one that's a little different than the others is the retrieve case. The retrieve case is different because it actually sends results back to the main thread. We're retrieving the list of words, a list of words dependent on a search. We're searching for the title and retrieving a list of words that are similar to the title. So you can see we're using a bundle, and then attaching the array list to the bundle, setting the data, and attaching that to the message. Then that message gets sent back to the main thread. That's how we're retrieving and sending words back to the main thread. Now I'm going to open up DictionaryActivity and we're going to take a look at where those words are going to be retrieved. So you can see we're getting a warning, which I'm going to address later. But if you scroll down to the handleMessage method, which is at the bottom of the file, we have all of our cases for the return messages coming from the background thread. Now remember our WORDS_RETRIEVE_SUCCESS is going to return an array list of words. So this is where the list of words is going to be available. We're not going to code anything in here right now because currently we don't have any words in the database. We're going to do that in the clip named Calling Methods on the Background Thread. Alright, so the last thing I want to do in this video is actually just resolve this error. We changed the constructor of the MyThread class to accept a context as an input, so we need to type this. In the next video we'll work on actually getting started and inserting some words.

Calling Methods on the Background Thread
Before you start writing code for this video, make sure to check out the correct branch, I've added a lot of code changes. The branch is calling-methods-on-the- background-thread-start. All the code changes are mostly in EditWordActivity. Now in EditWordActivity, there's a thread and it's being started and stopped the same way it works in DictionaryActivity. If you scroll down a bit, you'll see what I'm talking about. So we have our thread object and our MainThreadHandler objects. If we scroll down in the onStart method, you can see that the thread is starting. And in the onStop method the thread is being stopped or quit. If I scroll to the top of the file, you can see that I'm implementing the Handler. Callback interface, and at the bottom we also have the handleMessage method, which is handling all the responses from the thread. So when a database operation happens on the background thread, a message is then sent to the main thread to tell you what happened. Exactly the same as DictionaryActivity. In EditWordActivity a save is initiated in the disableEditMode method. So if I scroll up to disableEditMode, right here, you can see that saveChanges is being called down here. If we scroll up to saveChanges, you can see that there's a little bit of logic in here for saving a new word or updating a new word. If it's a new word, we save a new one, if it's not, then we just want to update the word. Then of course these two methods are empty, which is what we're going to fill in, in this video. Once again, for the sake of saving time, I've created a gist that contains these methods. Visit this URL to get the code. If you scroll down, you're going to see two methods in the EditWordActivity section here. There's saveNewWord and updateWord. These are the first two that we want to enter. So I'm just highlighting those, I'm copying those, going back to Android Studio, I'm just going to paste over them right here. Now let's just walk through them. They're both very similar. The first thing that happens is a message object is instantiated with a null Handler and a Constant. This one's Constant is WORD_INSERT_NEW, and the other one is WORD_UPDATE. Next, a bundle is instantiated. Attached to the bundle is a new word, the word mWordFinal object. That's the final word that's showing in the activity. Next, the bundle is attached to the message object, and then that message is sent to the background thread. So both of these are very similar. The only difference is the Constant that's passed to the message object and the tag that's passed to the parcelable. So we have word_new and word_update. Now I'm going to go into DictionaryActivity and I'm going to write the code required to retrieve new words and delete words. Once again, I'm going to visit that same gist that we were just at. I just want to try to save as much time as possible. I don't want to make you watch me write these out manually. So I'm going to copy the retrieveWords method and the deleteWord method right here. I'm going to leave these for later. I'm going to come back and get those. Go back to Android Studio, scroll down a little bit, and you can see there's retrieveWords and deleteWord. I'm just going to paste right over top of those. The retrieveWords method takes a string as an input called title. That's the string that we're going to use to search the database. So once again, we're using a SQL-like query. We're searching the database for words that are similar to that string that's passed as an input. A message object is instantiated with the Constant WORDS_RETRIEVE, a bundle is instantiated, the title is attached to that bundle, the bundle is attached to the message, and then that message is sent to the background thread. So it's the same kind of process as you saw in EditWordActivity. DeleteWord is very similar. Of course, the Constant is different, the tag attached to the parcelable is different, but everything else is pretty much the same. Back in the gist I'm going to grab the rest of this code here. We have two switch cases. These switch cases are going to be in the handleMessage method down in the bottom of the file. So we have WORDS_RETRIEVE_FAIL and WORDS_RETRIEVE_SUCCESS. I'm just going to paste over top of those. So now once the words are successfully retrieved on the background thread and sent back to DictionaryActivity, the case WORDS_RETRIEVE_SUCCESS will be called, the current words in the list will be cleared, the new words will be retrieved into this array list, and then added to the list of words. That's pretty much it. It's time to test. Alright, I'm going to try inserting a new word by clicking the floating action button. I'm just going to give it a title of something random, and I'm going to give it some random text, it doesn't matter. Now I'm going to press the back button, and that'll take me back to the list, and there you can see that word is now in the list. If I click on the word, I'm taken to EditWordActivity where you can see what I just entered. I'm going to try editing the word, so I'm just going to add some periods to the end of the definition there. I'm going to save it and go back, click the word again, and there you can see the changes were saved. Now I'm going to try and delete the word by swiping to the right. Now if I search for something random, you can see it's not showing up. So everything's working as we expect. We have two activities that are able to send messages to the background thread, the background thread executes some database operations, and then sends messages back to the main thread.

Module Review
In this module, we covered everything involved in implementing the Thread/Looper/Handler pattern and how to communicate between threads. Now before we review the details, let's review the overall process of what we implemented. Suppose we wanted to retrieve a word from the database. A message object is created in DictionaryActivity, which is run on the main thread. That message will be sent to the background thread using a Handler, the message is added to the message queue of the custom thread class, and then executed when it reaches the top of the stack. Once the database query is complete, the Looper cleans up the message and it's time to send the query data back to the main thread. Once again, another message object is created, but this time it's created on the background thread. The data is attached to the message object using a bundle, and a secondary Handler facilitates the passage from the background thread to the main thread. Once the message is received, it moves to the main thread's message queue and the data is eventually added to the RecyclerView. That's the overall process of what we implemented. Now let's review the details. The first thing we did was build a custom thread class, we called it MyThread. What you see on the screen is the basic structure of the Thread/Looper/Handler pattern. There's a thread, which is a class itself, the Handler, and the Looper being passed as an argument to the constructor of the Handler. When extending a class by the thread class, you must initialize the Looper by calling Looper. prepare, and you tell the Looper to begin looping by calling Looper. Loop. After that, it will loop indefinitely until the thread is destroyed. Next, we built a custom Handler class for doing the database transactions on the background thread. Everything inside the handleMessage method is executed on the background thread. There's four switch cases. Inserting a new word, updating a word, retrieving a word, and deleting a word. Also, remember the default constructor accepts a Looper as an input. This is so we can reference the background thread's Looper. Inside the custom thread class, we made four methods for doing the database transactions: saveNewWord, which inserted new words into the database, retrieveWords, which retrieved a list of words that are similar to the argument passed as an input, updateWord, which updates a word, and deleteWord, which deletes a word. As I stated a few moments ago, each of these words were called in the custom Handler class, which is inside the custom thread class. So this saveNewWord method was called within this switch case, the updateWord method was called within this switch case, and so on. Next we talked a little bit about memory leaks. Memory leaks can occur when a context reference is saved on a background thread. It might look something like this. A global context variable is inside of a thread, and it's being set in the constructor. This would definitely cause a memory leak. Explicitly saving a reference to an activity isn't the only way you can get a memory leak. You also need to watch out for objects with implicit reference to activities. Consider this. In the custom thread class we saved a reference to a Handler that existed in the activity. The reference was set in a constructor. Because this Handler was first instantiated in the activity, and then passed as an argument to the thread constructor, it holds an implicit reference to the activity it was created in. Therefore, it will cause a memory leak, or it could potentially cause a memory leak. Fortunately for us, the solution is surprisingly simple. We just need to remove the reference before the activity is destroyed. To remove the reference, we created a method inside the custom thread class named quitThread. Inside quitThread we set the Handler to null, but where do we call the quitThread method? The issue lies with when the activity is destroyed. The most common time for the activity to be destroyed is when a configuration change occurs, so if the screen is rotated. So in the onStop method, that's the ideal place to quit the thread. In summary, here are my thoughts on the Thread/Looper/Handler pattern. It's not exactly elegant, there's a lot of code. Once we look at the other threading options, you'll see just how much more code is required to do things this way. To build something custom, you basically need to extend a class by the thread class, which once again requires a lot of code. You'll see when we look at the HandlerThread option just how much code can be saved with some very subtle changes. Keep in mind this is not always the case, but to build any kind of a complex system you'll probably end up having to do this. Up next, we're going to take a look at implementing the exact same system, but this time we're going to do it using a HandlerThread.

Implementing a HandlerThread
Introduction
In this module, we're going to use the HandlerThread as an alternative to the classic Thread/Looper/Handler pattern. So what exactly is a HandlerThread and why was it created? HandlerThreads were created to make life a little easier for developers. As you saw in the module on the Thread/Looper/Handler pattern, building a custom thread class requires a lot of work. And it's not all custom code either. There's some static methods that need to be called inside every single custom thread class. Things like the Looper. prepare and the Looper. Loop methods. If you don't call these methods inside the run method of the thread, the Looper never gets initialized, and the thread can't process incoming messages. Basically, it means the thread is pretty much useless. A HandlerThread, on the other hand, has its functionality built in, and as you'll see in the module, we don't even need to build a custom class. We can use the plain old, out-of-the-box HandlerThread class, and it'll get the job done just fine.

How a HandlerThread Works
In the module named Implementing the Thread/Looper/Handler pattern, you learned that all threads on Android have the same general structure. This is what it looks like. There's a message queue where all the tasks go, and a Looper that facilitates the movement of the tasks through the queue. If you build a custom thread class that is a class that extends by thread, the Looper must be prepared by calling the prepare method, and the Looper must be started by calling the Loop method. Then, and only then, can you initialize a Handler to manage the incoming messages on the background thread. A HandlerThread has all that functionality built in. You can think of it as a secondary layer of abstraction built on top of the Thread/Looper/Handler pattern. The thread mechanism still exists, it's just packaged in a convenient way. We don't need to initialize the Looper and there's come other convenience methods for making our lives easier. Suppose we wanted to some kind of a database operation. Now suppose the method responsible for doing this database operation is called doSomeDatabaseOperation. So essentially this method needs to be executed on a background thread or we're going to have some problems. If we're using a HandlerThread, the simplest way to do this is with a Runnable object. Inside the run method of the Runnable is where we'd call the method. Next, we need to initialize the HandlerThread. We need to start the HandlerThread, initialize the Handler, and then finally post the Runnable. That's basically it. Doing it this way saves a little bit of code, and there's some conveniences. I didn't need to build a custom thread class, there's no initialization required for the Looper, I didn't need to build a custom Handler, or implement the Handler. Callback interface. I just created a task, otherwise known as a Runnable, and then I posted that Runnable to the HandlerThread. Compared to the Thread/Looper/Handler pattern, this feels a little more elegant and a little more organized.

Starting and Stopping a HandlerThread
HandlerThreads have a lot of things going for them, but they're still not lifecycle aware. Meaning we need to make sure to clean them up, or we'll get memory leaks. Starting a HandlerThread is no different than starting a regular thread, but when it comes to stopping a HandlerThread, there's some convenience methods that we can take advantage of. To get started, open up DictionaryActivity, and we're going to create a new HandlerThread object at the top of the file. Private HandlerThread, I'll call it mHandlerThread, now we want to instantiate the HandlerThread inside the onStart method, so that's going to be right here, mHandlerThread = new HandlerThread. And inside we want to pass a name to the thread. I'm just going to say DictionaryActivity HandlerThread. Now to start the thread, it's exactly the same as starting any thread. So I do mHandlerThread. start, and just like with our thread class, we want to stop the thread in the onStop method. As you can see, there is no longer a stop method, it's actually been deprecated, but there's an alternative. It's called quit or quitSafely, there's two options. Quit will stop it immediately, that means whatever messages are currently in the message queue will not process, it's just going to stop the Looper immediately. Whereas quitSafely, so you can see there's another option, quitSafely, that will finish processing all the messages in the message queue, and then it will quit, then it will stop the Looper. That's all there is to starting and stopping a HandlerThread. As you can see, it's a little bit more convenient than the thread class since we don't have to build our own quit method, but it's largely the same.

Building Custom Runnables
I like to think of Runnables as units of work, units of work that you can pass to a thread for completion. Technically, it doesn't even need to be a background thread. Runnables can be executed on any thread, including the main thread, but obviously since this course is on doing work on a background thread and threading, we're going to be passing these Runnables to a background thread. In this video, I'm going to build two custom Runnable classes, one's going to be for retrieving words form the database, and one's going to be for deleting words from the database. I'm going to start with the Runnable for retrieving words. So I'm going to open up the Project View, I'm going to right-click on the threading package, and go to New, Java Class, I'm going to call this RetrieveWordsRunnable. Of course, this is a Runnable, so we're not actually going to extend because Runnable is actually an interface, we're going to be implementing the Runnable interface. You can see it's giving us a warning. I'm going to press Alt+Enter, click Implement methods, and I'm going to add the run method. Inside the run method is where you want to put the work that you want completed. It's essentially the job. But before we write in our job, we need to declare a couple objects. The first object is a Handler, and I'm going to call it mMainThreadHandler. This is the Handler that we're going to use to pass a message back to the main thread once the job is complete. Very similar to how we did it in the MyThread class. So I open up to the MyThread class, we have our mMainThreadHandler, which is passed through the constructor, and then once the job is complete, so if we go down to the handleMessage method, you can see that a message is sent back to the main thread. We're going to follow that same sort of pattern here. And actually, since I'm already in the class, I'm going to scroll down to the WORDS_RETRIEVE case, and I'm going to copy all of this code right here because this is the job that's being done. This is actually the job that we want to execute in our Runnable. So I'm copying that, I'm going back to RetrieveWordsRunnable, and I'm going to paste that inside of the run method. Of course, there's a few changes that we need to make, the first of which is the title. No longer are we going to be able to get the title from a bundle, so I'm going to delete that. We're going to be retrieving words using the AppDatabase, so I'm going to delete that for now, but we're going to be typing something in there later. And down here, this is actually an abnormal error, this shouldn't be happening. It's telling me that the sendMessage method is not working on a Handler object, which is wrong. So that makes me think that the library is wrong, and if I look up here, it is. So I need to delete that library. I want to get the Handler android. os library, that's the right one right there. Okay, so let's declare the next object. The next object is the AppDatabase object. We need the AppDatabase object because we're going to be making queries to the database in this class. The last object is going to be a string named mQuery. This is actually going to be the query that we're making to the database, or in other words, the search query. If you go back to the MyThread class, that was called the title, so that's replacing this object right here. Next is the constructor. I'm going to press Alt+Enter to get the Constructor, select Constructor, and we need to pass in all these parameters. Actually, the AppDatabase isn't true, I'm going to hold down Ctrl and click that so that gets unselected. We're going to actually have to pass a context, so I'm typing Context context. So the mMainThreadHandler and the mQuery are fine, but we need to initialize the AppDatabase. So mDb = AppDatabse. getDatabase, and then get the context. We're almost ready to go. Now inside of the run method, we can call the retrieveWords method, so mDb. wordDataDao, and then. getWords and pass our query. And we're almost done, we just got one last step. I just want to type logd to get a log for debugging. Looks like I forgot to add a tag, so I'm going to have to go up here, going to type logt to get our log for debugging. So I'm going to close the Project view over here to give myself some more room, and I'm going to write in a message. So there we go, it says retrieving words. This is from thread, and then it's going to print out the thread name. So that's it, that's our Runnable. This Runnable can now be passed to the HandlerThread and executed like a job. But before we actually execute this, we want to create a secondary one for deleting words. So I want to open up the Project view, I'm actually going to copy this RetrieveWordsRunnable, I'm just pressing Ctrl+C on it, I'm going to click the threading package, press Ctrl+V, and now I'm going to call this DeleteWordRunnable. Now the reason I didn't create a brand new class from scratch is because it's going to be largely the same, there's only going to be few differences here. First, I'm going to change the log, so I'm just copying that and pasting it in here. We need to change the string query to a word object because we're going to be deleting a word, so change that to mWord. That means I'm changing the input also to a word object. So this. mWord = word. Everything else is the same here. Of course, change this to say deleting words. This is from thread, and change the method, so delete mWord, and pass the word. A couple more changes down here. We have WORD_DELETE_SUCCESS, this one's going to be WORD_DELETE_FAIL. And of course, we don't need all of this bundle stuff because we're not actually sending any data back to the main thread, it's just either a success or a failure message that's getting sent back. But that's it. That's our DeleteWordRunnable. Now before we move on, I just want to mention that these Runnables could potentially leak memory. If you recall back to when we were building our custom thread class, I mentioned that the Handlers can leak memory if they're not taken care of properly. So if we refer back to our MyThread class, if we scroll up the quitThread method, which is right here, you can see that we set the mMainThreadHandler to null when the thread ends or when it's destroyed. But in these Runnables, we don't see anything like that, so we still run the risk of having a memory leak. We're going to address this issue in a clip named Preventing Memory Leaks using a WeakReference.

Executing Work with Runnables
We have our Runnables, we have our HandlerThread started and ready to go, now it's time to actually execute some work. So the first new object we need to create is actually a Handler. Go private Handler mMainThreadHandler. This is the Handler that's going to be receiving the messages from the Runnables once they're complete. I'm going to instantiate it inside of the OnCreate method. So = new Handler, and I'm going to reference the Handler. Callback interface, just like we did in the module on the Thread/Looper/Handler. Still just referencing that thread Handler. Callback interface. Now we're ready to pass some work to the background thread. So I'm going to go down into the retrieveWords method, I'm going to create another new Handler object, I'll call it actually backgroundHandler = new Handler. And this is the beauty of a HandlerThread. This is kind of the main thing about a HandlerThread that makes it a little better than using the Thread/Looper/Handler pattern. Right here, I can go mHandlerThread. getLooper. So I don't need to initialize a Looper, I don't need to loop it, I don't need to do anything inside the class, I can just get a reference to the Looper just like that. Now I can use this backgroundHandler, and I can pass a Runnable to it. So I'm going to go backgroundHandler. post, as you saw, I'll just go back here, there's a few methods here, I'll talk about a couple other of those, but for now we're going to be calling the post method. Then I'm going to write new RetrieveWordsRunnable, I'm going to pass the context, the mMainThreadHandler, and then of course the title, which is the query. Now let's go back and talk about a few of those methods. You should already have a good idea what sendMessage does. That's going to send a message object to the message queue of the background thread. Post will send a Runnable, so this is basically the same idea, but instead of sending a message object, you send a Runnable object, but it still goes into the message queue. PostDelayed is similar, it takes a Runnable object, but that Runnable will only get executed after a time delay. So you can see it takes a second parameter, a long, it's called delayMillis, so that's the amount of time in milliseconds later in the future that you want this Runnable to be executed. This next postDelayed does exactly the same thing, except it has an option to pass a token. This is a way to make the Runnable unique. It's a way to mark the Runnable in a way, so that later if you want to remove the callbacks or anything like that, you know that you can reference that token. You can see down here in the removeCallbacks method, there's that token again. So you can reference that same token so that you can kind of target a single Runnable. So all kinds of different options. But we're just going to use the basic post option to send our Runnable. Next is deleting the word. So I'm just going to actually copy these two lines here, I'm going to post them down here in the deleteWord method, and then I'm just going to change this to DeleteWordRunnable, and we want to reference a word that we want to delete. So I'll just change this, and we should be good to go. It's time to run it and test it out. Alright, so here we have the application on the screen. As you can see, I've added a bunch of words, just ahead of time I did this off-screen so don't worry if you have no words in here, I'm going to add one in a second. So the first thing we want to test is actually retrieving words, but if you didn't add any words ahead of time, you're not going to be seeing anything here. So let's add one and make sure it's added to the list. So I'm going to click the floating action button, I'm just going to type some random text up here, some random text, press the back button to save the word, now I'm going to refresh the list, and there's the word that I added down at the bottom. If I click it, there's everything that I entered. So the last test is to see if it deletes. So I'm going to swipe to the right, I'm going to refresh, and there you can see the word was deleted. So you'll probably see that this isn't all that much different than what we did with the Thread/Looper/Handler pattern. There's not a lot of savings in code, the only thing that's really convenient is that you can access the Looper so easily through the HandlerThread. Other than that, I guess there's some organization benefits, like we can build the Runnable classes and kind of organize them into the correct packages. It just kind helps things be segmented a little better, which is usually better for testing and figuring out problems. So in general, you're not saving a ton of code, just kind of a bunch of other things that make it a little better, things like organization and clarity.

Preventing Memory Leaks Using a Weak Reference
In the code's current state, these Runnables could leak memory. They could potentially leak memory through the mMainThreadHandler that's passed through the Constructor. The mMainThreadHandler is instantiated in an activity, but it also holds a reference to a Handler. Callback interface in the activity. It follows that the mMainThreadHandler holds an implicit reference to the activity. And as you know, when an activity reference is saved on a background thread, you run the risk of memory leaks. Now I want to be clear. This application probably wouldn't leak memory if you left it the way it was. It wouldn't leak memory because the Runnables don't take very long to complete, however, if these Runnables didn't complete by the time the activity was destroyed, you'd probably get a memory leak. So you're playing a dangerous game. But there's a solution to this problem, one that's extremely easy to implement. It's called a weak reference. In Android development, we can use weak references to mark objects for garbage collection. Like when an activity reference is saved on a background thread, if we use a weak reference, the garbage collector can do its job and clean up the resources when the activity is destroyed. Here's an example. On the left is the Android garbage collector, and on the right is a bunch of resources for the garbage collector to clean up. The gray tasks represent the resources that the garbage collector has no problem cleaning up. But as the garbage collector moves through the resources, it runs into a problem. If the garbage collector tries to clean up an activity, but that activity has a reference saved somewhere on a background thread, it doesn't know what to do with it. But if that reference is declared a weak reference, the garbage collector does its thing and cleans it up. We're going to leverage weak references in the custom Runnables. At first weak references probably seem a little confusing, but they're actually very, very easy to set up. Right now, I'm in RetrieveWordsRunnable, and the first thing I want to do is change this to a WeakReference object. And I want to specify a type of Handler. Now inside the constructor, I want to replace this with new WeakReference, and then just pass the mMainThreadHandler. That's pretty much it. Now all you need to do to get a reference to the mMainThreadHandler is call. get and then everything works just like it did before. Now I'm going to go into DeleteWordRunnable, and I'm going to do the exact same thing. So I'm going to type WeakReference, specify a type of Handler, then inside the constructor I'm going to write new WeakReference, and pass the mMainThreadHandler. And lastly, call get. That's it. The Handler will work exactly as it did before, but now the garbage collector will have no problem cleaning it up.

Module Review
In this module, we looked at a secondary threading option, the HandlerThread. I think the name of this threading option is actually kind of misleading. The name suggests that a built-in Handler exists, or something like that, which is definitely not the case. Compared to the Thread/Looper/Handler pattern, the biggest difference is actually the Looper. With a HandlerThread, we don't need to initialize a Looper, it's packaged into the class. Having a Looper pre-packaged and initialized is a subtle change, but it adds a lot of conveniences. Because we don't need to initialize the Looper, Handlers can be easily created from whatever activity or fragment the HandlerThread exists in. You can easily get a reference to the Looper by calling getLooper on the HandlerThread object. It's a subtle change, but in the right situations, it can make threading a lot easier. In this module, I chose a different approach to how I passed work to the background thread. With the Thread/Looper/Handler pattern, I used a Handler, and then sent the message objects to the background. Those message objects triggered certain database operations. But with the HandlerThread, I used Runnables. The message queue knows how to deal with two types of tasks, message objects and Runnable objects. The overall procedure for each type of task is pretty much the same. You create a unit of work. In the case of the HandlerThread, that was a Runnable. You send that unit of work to a Handler, the Handler then passes that unit of work to the message queue. After the work is complete, I created a message object, and then sent that to the main thread. This is exactly the same thing we did with the Thread/Looper/Handler pattern. The last thing we talked about was memory leaks. Remember, any reference to an activity saved on a background thread can potentially cause a memory leak. For example, this Runnable could potentially cause a memory leak because the Handler holds an implicit reference to the activity that it was created in. A simple solution to this problem is to use a weak reference. Using a weak reference is like marking an object for garbage collection. If it's a weak reference, the garbage collector has no issue cleaning up the resources.

Implementing an AsyncTask
Introduction
If you talk to experienced Android developers, usually they have a love-hate relationship with the AsyncTask class. I'm going to show you the best practice way to utilize AsyncTask, and then you can decide whether you want to love it or you want to hate it. The AsyncTask class is a class that allows you to perform background operations and then publish results on the UI thread without having to deal with threads and/or Handlers. AsyncTask is designed to be a helper class built around the thread in the Handler classes. When you use an AsyncTask, you have no direct interaction with any thread or Handler objects. The functionality is packaged into the AsyncTask class. In this project, we're going to build two custom AsyncTask classes, one for retrieving words from the database, and one for deleting words from the database. That way you can compare and contrast with the other threading options that we looked at in the course.

How AsyncTask Works
Before we take a look at the code, I want to talk about the structure of a class that extends AsyncTask. For right now, don't worry about these input types, I'm going to talk about those shortly. AsyncTask has four main override methods, onPreExecute, doInBackground, onProgressUpdate, and onPostExecute. The only one of these methods that actually executes on a background thread is doInBackground. The other three execute on the main thread, or in other words, the UI thread. When an AsyncTask is executed, the methods are executed in a specific order. You can probably guess the order from the naming. First is onPreExecute, then doInBackground, onProgressUpdate executes at the same time as doInBackground, and then once doInBackground completes, onPostExecute is called. Now let's talk about the data types. In this example, there's a String, an Integer, and an ArrayList. These data types can be anything you want, I just added these randomly as an example. The first parameter, the String, is passed as an input to the doInBackground method, however, it's not a single string object, it's actually an array of strings. That's what this ellipsis means. The three dots indicate this is an array of strings. The second parameter is an Integer. Once again, this data type was chosen completely randomly, but you'll probably find yourself using the Integer data type here more often than not. It's just convenient for updating the progress on the main thread. This designates the data type passed to the OnProgressUpdate method. Once again, it's an array of integers as indicated by the ellipses. The final parameter is an ArrayList. This designates the data type returned from the doInBackground method, and also the input data type for the OnPostExecute method. So the data is returned from doInBackground and then received in OnPostExecute. When starting up an AsyncTask, this is what you do. Instantiate a new AsyncTask object, prepare your data, in this example we need an array of strings, and then call execute on the AsyncTask object, and pass the data. The data type that you pass to the execute method is the one designated as an input to the doInBackground method.

Building a Custom AsyncTask Class
In this video, I'm going to build a custom AsyncTask class, actually two custom AsyncTask classes, one for retrieving words from the database and one for deleting words from the database. Alright, so the first thing we want to do is right-click on the threading package, go to New, Java Class, and we're going to call this one RetrieveWordsAsyncTask. And of course, we want to extend by the AsyncTask class, and our three input parameters are going to be a String, a Void, and an ArrayList, an ArrayList of type Word. I'm going to close the Project view over here just to give myself some more room, import the word dependency, and we're ready to go. So it's giving me a warning, so I'm going to put my cursor on the warning and press Alt+Enter, click on Implement methods, and we're going get the doInBackground method. I only imported doInBackground because that's the only one that's required for the AsyncTask class. I recommend using the other ones like onPreExecute, onPostExecute, onProgressUpdate, but the only that's actually required is doInBackground. Okay, so let's get those other methods. I'm going to press Ctrl+O on Windows, or Cmd+O on Mac, and we get onPreExecute, onPostExecute, and onProgressUpdate. Notice there's also an onCancelled method. AsyncTask has a method called cancel that you can call on it to basically shut it down and stop it from doing anything. If you want to call some method after you've cancelled it, you'd want to use onCancelled. But I'm just going to use these three. We're not actually even going to use all three of these in the project, I just want to get them in here so you can see what they do and I can talk about them a little bit. Okay, so I'm going to write a few comments in here before I do anything. This one is actually executed on the main thread. And I'm going to copy this, this is just for your own kind of study purposes so that you know which ones are executed on the main thread and which ones are actually executed on the background thread, on the background Thread. So it's going to be really easy for you to tell. The naming is pretty obvious too, doInBackground is on the background, all the other ones execute on the main thread. Okay, now that we have our four methods, I'm going to put a log up here for debugging, so I'm just typing logt. And the only object that we're going to put in this class at this point is the AppDatabase object. So I'm going to go private AppDatabase mDb, remember we need this to do the database operations. Now I'm going to insert the default constructor. So I'm pressing Alt+Insert, going to Constructor, and I'm going to actually deselect this, and just do an empty constructor for now because we actually need to pass a context as an input. So Context context, and then I'm going to set the AppDatabase object just like we've done before,. getDatabase and then passing the context. Okay, so we have our basic kind of structure. Now this class is just going to be specifically for querying words. So at the bottom here, I'm going to create a method for querying the words. And we're going to need to pass a string as an input, I'll just call it query. Since we are querying the database using an SQL-like query, remember, we have to pass some kind of a text when we're searching for these words. This is going to be pretty straightforward. I'm just going to enter a little log here saying retrieving words, and then This is from thread, just so that we know which thread it's coming from, Thread. currentThread. getName, just like we've been doing before, that way you can really see which thread is executing which methods. And we want to return a new ArrayList, and write mDb, get our wordDataDao, and then getWords and pass our query. Pretty straightforward, should be nothing new here. Now in the doInBackground method, I'm just going to call our method retrieveWordsAsync, and I'm going to pass the query. In this case, the query is going to be the very first position of the array passed in doInBackground. Okay, let's quickly just run through what we've done here. So if we go up to the top, we have three input types. We have String, Void, and an ArrayList that holds a list of words. The String data type represents the input to the doInBackground method, and that's what we see down here. The ArrayList data type represents what we're returning from the doInBackground method, and also what we're receiving as an input to the onPostExecute method. So right now, we're not worrying about the onPostExecute, I just want to make sure that we're able to start the query and kind of get things rolling here. Afterwards, we're going to worry about how we're going to send data from the AsyncTask back to the main thread, but for now we're just worrying about actually making the query in the AsyncTask. And we're not going to be using it in this course, but if you wanted to post any kind of a progress update, if you had kind of a long-running task happening in the doInBackground method, if you wanted to update the UI as it was going, then you would call your onProgressUpdate and you would pass, you know, whatever value you wanted to. In this case, I have a Void data type specified, but if I change this to an Integer, I could change the onProgressUpdate to an Integer, and then pass Integer values, maybe if you had 1 out of 100 progress, maybe if you had 2 out of 100 progress, and that's kind of how you would do that. But in this case, it doesn't really make sense since our queries are so fast, there's no point in updating the UI. So I'm just going to change these all back to Void types. But just kind of so you know how that works. And of course, onPreExecute is what you would do to prepare anything before you wanted to start the AsyncTask, but once again in this case, we're not going to need to prepare anything, so I have it in here even though it's not going to be doing anything in this project. Okay, so there's a good start to our RetrieveWordsAsyncTask class. Now let's build a class for deleting the words. I'm going to copy the RetrieveWordsAsyncTask, I'm going to press Ctrl+V on the threading package, and I'm just going to change the name to DeleteWordAsyncTask. Now I'm copying this because it's going to be largely the same, we just have a few small changes to make. First, we'll change this log here, and change the data types. The first data type is going to be a Word object. We're going to be deleting a word, so it makes sense to be passing a Word object into the class. The last parameter is going to be an Integer, and we're leaving Void here since we're not going to be updating the UI. Now we need to update our data types here. So the doInBackground method now is going to be returning an Integer because I specified an Integer as the third parameter up there. It's going to be taking a Word object as an input, so I'll do Word words. We can delete this for now, I'm just going to say return null. OnPostExecute is accepting an Integer, so I'm changing this to an Integer here, since that's what's returning from the doInBackground method right here. And it looks like we're pretty much ready to go. The only thing we've got to change is the actual method here. We want to change this to deleteWord, and of course we're not going to be returning an ArrayList of words, this is going to be returning an Integer. The input is going to be a word object. I'm going to change this, say deleting word. This is from thread, and then print out the thread name. And we want to change this also, so return mDb. wordDataDao, and then delete, and we want to delete that word. And the last step is going to be actually calling this method in doInBackground. So I'm just calling deleteWord and we want to pass the first position of the array that's passed as input here. Too many brackets, there we go. So those are our two methods. We have deleteWordAsyncTask, and we have RetrieveWordsAsyncTask. Right now, we're just executing the methods in the background, we're not actually publishing anything to the main UI thread, but we're going to work on that in the next video.

Executing an AsyncTask
In this video, we're going to work on executing the two custom AsyncTasks. So here I am in DictionaryActivity. I'm just going to actually scroll down to the retrieveWords method because this is where we want to retrieve the words. And this is a pretty straightforward process. Starting an AsyncTask is a very straightforward process. All I'm going to do is type new RetrieveWordsAsyncTask. You can see it takes a context as an input, and to execute it, I just want to call execute. Now the input here is very important. If we refer back to our RetrieveWordsAsyncTask, then we scroll down to the doInBackground method, we can see that the RetrieveWordsAsyncTask method takes a string array. The first position of a string array is an input. So where does this come from? Where does this string come from? That comes from the execute method right here. So whatever I pass to this execute method is what gets passed to the doInBackground method. So of course, we want to pass our query. But that's it, it's a pretty simple process. Next, in the delete method, we're going to do generally the same thing. So new DeleteWordAsyncTask, I want to pass the context, and then call execute, and we want to pass the word that we want to delete. So it's exactly the same kind of process here. To put some more emphasis on the order that the methods are executed in the AsyncTask, I'm going to add some more logs before we actually run and test this. So in the onPreExecute method, I'm just going write called. In the doInBackground method, I'm going to do the same thing, OnProgressUpdate, and then onPostExecute. Now of course, onProgressUpdate isn't going to be called at all since you have to call it yourself, so I'll add another method call in here, onProgressUpdate and then I'll just pass nothing, just to get it to actually call. Now I'm going to run it and you can see the log outputs as the AsyncTask is executed. So here I have the application running. Keep in mind that you shouldn't see anything in the list right now because the onPostExecute method doesn't have any code, so there's nothing being sent to the UI. But we should still see the log outputs. So I'm going to open up the logcat here. I'm going to bring the app, I'm going to refresh the list. That's going to execute the AsyncTask, and now let's take a look at what we see. So we have our retrieveWords method called, we have onPreExecute called, doInBackground, onProgressUpdate, and then the message from the retrieving words method that says we're retrieving the words. This is from AsyncTask #1. And then finally, at the bottom is the onPostExecute method. So you can see the order that they're executed in. You have the AsyncTask that's executed in DictionaryActivity, onPreExecute, doInBackground, onProgressUpdate, the retrieveWords method executed in the background on the AsyncTask, and then onPostExecute is executed at the very end. It's kind of a tongue twister, onPostExecute is executed. Next, we'll work on actually returning results to the main thread so that we can display all the words in the RecyclerView.

Posting Results Using a Task Delegate
In the application's current state, we have a way to execute an AsyncTask and retrieve words, but we don't have a way to post those words back to the main thread. So that's what we're going to work on in this video. The first thing I want to do is create a new interface. So I'm right-clicking on the threading package, going to New, Java Class, change this to an interface, and I'm going to call this interface TaskDelegate. I'm calling it TaskDelegate because this is the common naming that Android developers use when they're returning something from a background thread from a task to the main thread. And inside this interface we're just going to have a single method. We'll write void onWordsRetrieved, and in these too, return an ArrayList of Word objects, just like that. So, the goal of this interface is to pass the words from the AsyncTask back to the main thread once we've retrieved them. So let's open up our RetrieveWordsAsyncTask, and we want to declare the interface in here. So, private TaskDelegate, I'll call it mDelegate, and we want to pass it through the constructor. So TaskDelegate delegate, mDelegate = delegate. Now we can use this interface in the onPostExecute method to send the results back to the main thread. So mDelegate. onWordsRetrieved, and we just want to pass the words that are passed to the input of the onPostExecute method. Now before we move forward, I do want to mention that, yes, this could potentially leak memory because we're going to be implementing this interface in DictionaryActivity, and therefore, the interface will hold a reference to DictionaryActivity. We'll discuss how we're going to solve that issue later in the module. If you've been following along with the entire course, you know that what we just did could potentially leak memory. Since we're referencing an interface that's going to exist in DictionaryActivity, we're going to implement this interface in DictionaryActivity. Since the interface is implemented in DictionaryActivity, it holds a reference to DictionaryActivity, and therefore could cause a memory leak in this AsyncTask. So what can we do to solve that? We can use a weak reference. So instead of declaring a TaskDelegate object, I'm going to create a WeakReference of type TaskDelegate. Then inside the constructor, I'll go new WeakReference, and then pass our TaskDelegate. If you need a review on what I just did, make sure to re-watch the clip when I talk about preventing memory leaks. Lastly, since we declared a WeakReference, I need to call get on the WeakReference object to get the actual object. Okay, so we're all done in the RetrieveWordsAsyncTask class. Now we're going to go into DictionaryActivity, and I'm going to implement the interface. So I'm going to the top, write a comma, and implement the TaskDelegate interface. You can see I'm getting a warning. I'm going to press Alt+Enter, Implement methods, and get the onWordsRetrieved method. Before I write the logic for this, I'm going to scroll up to the constructor of the AsyncTask, and I'm going to pass this. That's going to refer to the interface. You can see the first input is the context, and the second input is the TaskDelegate interface. Now I'll scroll down and write the logic for the onWordsRetrieved method. First I want to clear the words, which is going to clear the list. Then do mWords. addAll, and I want to add the words that we retrieved, and then just notify the adapter that the dataset has changed. And we should be good to go. It's time to test it and take a look. So here we have the application running. I'm going to refresh the feed, and you can see there's all the words retrieved from the database.

AsyncTask Lifecycle
By default, all AsyncTasks will run until completion. But what happens if the user switches activities or closes the app? We don't want the AsyncTask tying up unnecessary resources. And lucky for us, there's a convenient method in the AsyncTask class that forces it to stop. Open up DictionaryActivity. So the goal here is going to be to manage the lifecycle of the AsyncTasks. Or, in other words, get rid of them when they're not needed, and only start them up when they are needed. To do that, I'm going to create two global AsyncTasks, one for the RetrieveWordsAsyncTask, and one for deleting words. The first method we'll work on is the retrieveWords method. I'm going to delete this, and I'll instantiate our global mRetrieveWordsAsyncTask object, new RetrieveWordsAsyncTask, this for the context, and this for the interface, and then I'm going to call execute and pass our title. Next, I'll do the deleteWords, so same sort of thing, mDeleteWordAsyncTask = new DeleteWordAsyncTask, pass this for the context, and then execute that task, and pass the word that we want to delete. So that's all fine, that's what we were doing before, but now what I want to do is go up into the onStop method and cancel these AsyncTasks if they're not null. So first, I'll check for null on the RetrieveWordsAsyncTask. Now if it's not null, I want to cancel it. The Boolean that I'm passing here is to tell the AsyncTask whether or not it can be interrupted. So if the doInBackground method is executing, if I pass true here, it's going to immediately cancel it regardless of what's happening. It's kind of like a hard stop. Now I want to do the exact same thing for the delete method. So I'm going to copy that, post it below, change this to mDeleteWordsAsyncTask, and mDeleteWordsAsyncTask. So now if the activity is destroyed or closed, if anything happens, the AsyncTasks will stop.

Linear Thread Execution
AsyncTasks have a unique property that only allows them to execute one at a time. Or in other words, there can never be more than one AsyncTask running at any given time. Let me show you an example of how this could cause problems. I'm going to open up the RetrieveWordsAsyncTask class, and inside the doInBackground method, I'm going to put the thread to sleep for 3 seconds. So I'm going to write Thread. sleep 3000, can see it's giving me a warning, I'm going to press Alt+Enter, and just surround this in a try/catch. So when doing background runs, it's going to sleep the thread, so it's going to do nothing for 3 seconds before it actually executes the RetrieveWordsAsyncTask method. And the reason I'm doing this is I want to show you that if I continue to refresh the feed and basically calling the AsyncTask class to execute and retrieve the words, the AsyncTasks are going to stack on top of each other. So I'm going to call one, and then another, and another, and so on and you'll see in the log that there just going to stack on top of each other. So I'm going to run it like this, and I'll show you what the log output looks like. Okay, so here we have the app running. I'm going to refresh the feed in it, and I'm going to refresh it very quickly, so I'm not going to wait at all. I'm just going to refresh, refresh, refresh, and you'll see the AsyncTasks stacking one on top of each other. So there's a refresh, refresh, refresh, refresh, and then you can see them executing. So now if I analyze the log, if I look at this and scroll over here, you can see the first refresh said executing from thread AsyncTask #1, AsyncTask #2, AsyncTask #3, and AsyncTask #4. And they were just stacking one on top of each other. So, before this one had even completed because the thread was sleeping, another one was queued up, and another one was queued up, and another one was queued up. Obviously, you don't want this type of functionality. You don't want the user to be able to call a task and execute a task, one after another, before even waiting for the other one to finish, you're just tying up unnecessary resources. So what we can do to prevent this is we'll go into DictionaryActivity, and we're going to cancel the task if they refresh the feed. So inside the retrieveWords method, I'm going to first of all check to make sure if the task is null. So if it does not equal null, then I want to cancel it. If it's not null, that means there's already one running. I want to cancel it before I call and execute the second one. So I'm going to just copy this, and I'm going to do the exact same thing inside the delete case, just copying that, pasting there, pasting it there. So it's the same thing. So they're not going to be able to just spam refresh and have the tasks queue up one after another, this will cancel them before executing the next one. And of course, don't forget to delete this right here. You don't want your thread going to sleep for 3 seconds for no reason.

Module Review
AsyncTask is a convenience class provided with the Android SDK that makes it a little easier to complete tasks on a background thread. But it's not good to use in all situations. There's a lot of benefits, but there's also a few shortcomings. First, I'll talk about the benefits. The first, and probably most obvious benefit, is it's pretty easy to set up. The methods are very intuitive and you don't need to worry about setting up a thread or any Handlers. AsyncTask has a thread and a Handler class that's packaged into it. So all you need to know how to use is the provided override methods. And that gives me a nice segue into the override methods. Probably the best thing about the AsyncTask override methods is just how intuitively they're named. OnPreExecute runs on the main thread and runs first. DoInBackground runs on the background thread and it runs second. OnProgressUpdate is also on the main thread and it runs third. OnPostExecute runs on the main thread, and it's the last one to be executed. AsyncTask has three data types that you need to specify. The first one is what data type is passed to the doInBackground method, the second is the data type passed to the onProgressUpdate method, and the third is what's returned from doInBackground and passed to onPostExecute. The first data type is also what's passed to the execute method. So when you instantiate a new AsyncTask, figure out what data you're going to send it, then you pass that into the execute method. The execute method is what's used to start the task. The last benefit I want to talk about is the cancel method. If you ever need to stop an AsyncTask in a hurry, you can just call the cancel method. The cancel method accepts a Boolean as an input. If the Boolean is true, then the AsyncTask will stop immediately, regardless of what it's doing. Overall, AsyncTask has a pretty simple and intuitive setup. And you have the added benefit of being able to update the UI in some methods and execute background work in another. Now let's talk about the downside. I think the biggest downside of using AsyncTask is that only one AsyncTask can run at any given time. This is known as linear thread execution. I like to think of it as a queue of AsyncTasks. They execute linearly one after another. For example, AsyncTask #2 cannot execute until AsyncTask #1 is complete, then AsyncTask #3 can't execute until AsyncTask #2 is complete, and so on. Because they're executed linearly, AsyncTasks are not good for long-running operations.

Implementing a Thread Pool
Introduction
In this module, I'm going to talk about thread pools and how you can leverage them in your Android projects. So what exactly is a thread pool? On Android, a thread pool refers to a grouping or a collection of threads. I like to use the analogy of a bucket. It's a bucket filled with threads. These threads can be used to complete work. The threads in the pool are no different than any other thread in your application. The difference lies in how they're used. In this project, we're going to use a thread pool to make database queries more efficient. Suppose we had 50, 000 words in a database. In the application's current state, if we wanted to query all the words, we would do it on a single background thread. But in this module, we're going to use a thread pool to execute multiple queries simultaneously. For example, suppose we had five threads in the thread pool. Each thread would be responsible for querying 10, 000 words. Each thread can execute at the same time, so theoretically the query should be faster, theoretically. To see which is faster, using a thread pool or using a single thread, I'm going to record the time it takes for the queries to complete, and as you'll see in the module, there's going to be some very interesting results. Which one do you think will be faster, a thread pool or a single thread?

How a Thread Pool Works
Technically speaking, there's no such thing as a thread pool object, it's a conceptual term. When someone is talking about a thread pool, what they're actually talking about is Executors or an ExecutorService. Here I am in the Android documentation looking at the Executor class. If I scroll down to look at the definition, it says An object that executes submitted Runnable tasks. So that sounds pretty good, that's what I want to do. I want to execute Runnables, but I want to execute Runnables on background threads. If I scroll down, there's some examples. There's one of a task executed on the same thread that the Executor exists, and there's one of an Executor spawning a new thread to complete a task. If I scroll down to the bottom, I can see there's some more information. It says The Executor implementations provided in this package implement ExecutorService, which is a more extensive interface. The ThreadPoolExecutor class provides an extensible thread pool implementation. The Executors class provides convenient factory methods for these Executors. That's what we're interested in. The Executors class provides convenient factory methods for these Executors. I'm all about convenience. I'll click on Executors. This is the Executors class, it's plural. It contains a number of static methods that make it very simple to set up a thread pool. But once again, I want to remind you that a thread pool is a purely conceptual term. There is actually no thread pool object. A thread pool is just a term used to describe a grouping or a collection of threads. If I scroll down a bit, I can see a whole bunch of static methods. There's methods that return Callables, methods that return ThreadFactories, ExecutorServices, and if I go down a bit more, ScheduledExecutorServices. We're interested in the ones that return an ExecutorService, and more specifically, the newFixedThreadPool method. An ExecutorService is a more extensive version of an Executor. It has more functionality. Think of it as an Executor, but more. Executors just execute Runnables, but an ExecutorService can do much more. At this point, your head is probably spinning. I know mine starts to spin when I read the documentation for too long. On top of that, I could easily make an entire course on Executors, but have no fear, I promise you'll have clarity by the end of this module. I'm going to keep things extremely simple. Practically speaking, here's exactly what we're going to do. We're going to use the method newFixedThreadPool to initialize an ExecutorService object. It accepts an integer representing the number of threads that we want in our thread pool. After that, all we have to do is pass Runnables to the ExecutorService, and it will automatically manage everything else for us. That means spawning new threads, executing the Runnables, and managing all the tasks in the queue. All we have to do is shut it down when we're done. Pretty simple stuff.

Initializing a ThreadPool
In this video, I'm going to show you how to set up a thread pool with a fixed number of threads. The number of threads will depend on how many processors the device has. Before we get started writing any code, I just want to show you the changes that I've made. If you scroll down to the retrieveWords method, notice that I've removed the AsyncTask. The AsyncTask actually no longer even exists in the activity. If you scroll up to the top, notice the only one you see is the DeleteWordAsyncTask. So the retrieveWordAsyncTask has been removed. Alright, so the first step is going to be declaring an ExecutorService object. This is the object that's going to help us manage our thread pool. So it's called an ExecutorService object, I'm going to call it mExecutorService. The alternative to using an ExecutorService would be to use a ThreadPoolExecutor. A ThreadPoolExecutor is actually a class that is extended by ExecutorService. The difference being in the setup properties. With the ThreadPoolExecutor you have more options when it comes to the setup properties. Things like the maximum pool size, how long it's going to stay alive, when it should time out, things like that. There's more options essentially. So we're not going to be using a ThreadPoolExecutor because there's more options. I want to keep it simple, so we're going to use an ExecutorService. But just know that a ThreadPoolExecutor actually extends the ExecutorService class so it's pretty much the same thing. Now that we have our object, we can initialize it. We're going to build a method just below the onCreate method, and I'm going to call it InitExecutorThreadPool. If I go to instantiate the ExecutorService, I'm going to reference the Executors class. I'm going to reference the Executors class because it has a whole bunch of convenience methods, static convenience methods, for setting up thread pools. So you can see there's a bunch of options here. The one we're interested in is newFixedThreadPool. NewFixedThreadPool has a few options, the first one being the one that accepts an integer describing the number of threads that you want in your thread pool. So that's the one we're going to use. So how do I get the number of threads? How do I know how many threads I want? The maximum number of threads you can use is the number of cores that are available on the device. And you can get a reference to how many cores you have like this, int cores = Runtime. getRuntime, and then availableProcessors. I compare that to the log if you're interested. That way when you're watching the log, you can see how many cores your device has. And then you just want to pass that number of cores to your thread pool. Now I want to mention that, in general, in a production app, you probably don't want to pass the maximum number of cores to you thread pool, but this is just a lesson, so that's what we're going to do. Now inside onCreate, I'm going to call the InitExecutorThreadPool method, and our thread pool will be ready to go. One of the beautiful things about using the Executors class and the static methods that are available in there is that all the fine tuning's already done for you. So no matter how many tasks you pass to the thread pool, how long the tasks take, anything like that, everything's automatically managed. So essentially all you need to do is create Runnables, and then pass those Runnables to the ExecutorService, and they'll get executed whenever resources are available, or whenever those threads are available. If all of them are busy, it'll get added to the queue until something is available, then it will get executed. Pretty much full automation.

Leveraging a Thread Pool
In this project, I'm going to use a thread pool to split up the database queries. It isn't going to make much sense with a small number of rows, but as you'll see at the end of the module, splitting up the work when there's thousands of database rows can pay big dividends. Here's what I'm going to do. Suppose there was a database with 50 rows. Inside the wordDataDao class, there's a method named getSomeWords. GetSomeWords takes two arguments as input, an integer named row and an integer named numRows. Row represents the row that the query starts on. NumRows represents the number of rows to query. So if row equals 0 and numRows equals 10, the getSomeWords method will return the first 10 rows. If row equals 10 and numRows equals 10, the getSomeWords method will return the second 10 rows. Basically, row denotes the starting index, and numRows denotes the chunk size. In DictionaryActivity, when I initialize the thread pool, I pass to the number of cores as an input. The device I'm testing on has eight cores, so the thread pool will have eight threads. Since I have eight threads, I'm going to instantiate eight Runnables. Each Runnable will be responsible for querying one-eighth of the database rows. Essentially, what I'm doing is I'm dividing up the total work by the number of threads. Then each thread is responsible for doing an equal portion of the query.

Querying the Number of Database Rows
The first step in this entire process is getting the number of database rows. If we don't know how many rows are in the database, we can't split up the work evenly on the thread pool. To retrieve the number of rows, I've created a new class named RetrieveRowsAsyncTask. I'm just going to go over this quickly because it's pretty much just repetitions of what we looked already in the AsyncTask module. There should be nothing new here. We have our AppDatabase object, our WeakReference of our TaskDelegate for sending work back to the main thread. The constructor initializes those two objects. Inside the doInBackground method, we have a method called retrieveRowsAsync, and all retrieveRowsAsync does is retrieve the number of rows in the database. So just an integer value, literally just a count of how many rows there are. Once they're retrieved, the TaskDelegate interface returns those rows using the onRowsRetrieved method. So that's another new method that I created, let's take a look at that. So I'm going to open up the interface TaskDelegate. And you can see I added another method named onRowsRetrieved, which just returns an integer. Pretty straightforward stuff, there should be nothing new here. Now let's take a look at the changes in DictionaryActivity. At the top of the file, I've created a new variable named mNumRows. That's going to be the number of rows in the database. And if we scroll to the bottom of the file, you can see the onRowsRetrieved method is now in the activity, and that's setting the number of rows. So that's returning it from the AsyncTask. The last step of this whole procedure is kicking it off, so starting it up. I'm going to scroll up to the retrieveWords method. Now it's responsible for retrieving the rows from the database, so all that's happening here is the RetrieveRowsAsyncTask is being executed. And that's going to kick off the whole process.

ThreadPool Runnables
In this video, I'm going to build the Runnable responsible for executing the database query in the thread pool. I'll start by creating a new class. So I'm going to right-click on the threading package, go to New, Java Class, and I'm going to call this ThreadPoolRunnable. Of course, this is going to implement the Runnable interface. And we're getting a warning. I'm going to press Alt+Enter, like we've done a couple times already before, go to Implement methods, and insert the run method. First, I'll get a log for debugging, so I'm pressing logt, and now I'm going to declare all the variables that we need in this class. The first one is an integer representing the starting index of the query. The second one is another integer representing the chunk size, or how many database rows we're going to query in each task, or each Runnable. Next is the AppDatabase object. We're making database queries, so we need an AppDatabase object. And the last one's going to be a WeakReference to the Handler that's going to send the message back to the main thread after the query is complete. So there shouldn't be anything really new here. We're just creating a Runnable like we've done a couple times already before. The next step is inserting the Constructor. So I'm pressing Alt+Insert and selecting Constructor. I'm going to select all these fields, and then I'm just going to change it to suit our needs. I'm going to close the Project view over here just to give myself some more room. Okay, so the first one I want to accept, I'm going to get rid of the AppDatabase because we don't actually pass the AppDatabase, I'm going to change this to a context since that's what we're going to use to initialize the AppDatabase. And I'm going to move these two to the end, this is just my preference, I'm not doing this for any particular reason. I just want the starting index and the chunk size to be at the end of the constructor, and not second in the constructor. And the last change is I want to pass the actual Handler itself, not a WeakReference. So of course I've got to change this a little bit. So mDb = AppDatabase. getDatabase, and we get the context. And then to initialize the WeakReference, we do new WeakReference and pass the mMainThreadHandler. So once again, nothing really new here. It should be all review for you. Lastly, we need to write everything into the run method. First, I'm going to enter a log for debugging so that we know what thread all this code is being executed on. So I just have a log that says retrieving some words, and then it prints out that will tell us what thread that message is coming from. Next, I'm going to get an ArrayList of all the words returned from the query. So I'm using the AppDatabase object calling wordDataDao, and then calling the method getSomeWords, passing the mStartingIndex and passing the mChunkSize. As you can see, I have a little typo here, the ChunkSize is spelled wrong, so I'm just going to get rid of that e up there. So the getSomeWords method we talked about in a previous video, it takes a mStartingIndex as an input and the mChunkSize as an input. So the query starts with the StartingIndex, and then it queries the ChunkSize, so the amount that it takes is the ChunkSize, or I guess, at most the ChunkSize. The last thing we need to do is actually send a message back to the main thread containing the list of words. So of course, instantiate a Message object, Message. obtain, and we can pass null here, or you can pass the MainThreadHandler, whatever your preference is. The Constant that we're going to use is MSG_THREAD_POOL_TASK_COMPLETE. We need a bundle to attach the words to, so new Bundle, and then bundle. putParcelableArrayList. We want to pass the key word_data_from_thread_pool, and pass our words. And then set the Data to the message, and call our mMainThreadHandler. get, and then send the Message and pass that message. So that's everything we need. That Runnable will execute on a background thread, and then send that list of words back to the main thread. The last thing I want to do before we go is show a couple changes that I made in DictionaryActivity. So if you scroll up to the top, you can see that I've added a mMainThreadHandler. If you scroll right up to the top, you can see I've implemented the Handler. Callback interface. And if I scroll all the way to the bottom, you can see the handleMessage method is here for the Handler. Callback interface, and it's receiving the Constant MSG_THREAD_POOL_TASK_COMPLETE.

Executing Runnables in a ThreadPool
The last step in our procedure to execute these Runnables is to actually submit them to the thread pool. And the only tricky part about this is going to be dividing up the work evenly. We need to make sure that each thread has the exact same amount of work. To do all this, we're going to create a new method, and this new method is going to be called executeThreadPool. It's going to take no input, and it's going to return nothing. The first variable is going to be the number of tasks. The number of tasks is defined by the number of cores that your device has, or the availableProcessors. Next is determining how much work is going to each Runnable or each thread. And what I mean by the amount of work, I mean the amount of database rows. That's what we're calling the chunk size. So I'm going to create a new variable named chunkSize, and setting this value isn't as easy as you might think. I'm going to write it out here, and then I'm going to talk about it and explain what I did. Okay, so here we have our chunkSize. Now this probably looks very confusing to you, but I promise it's not as confusing as it looks. So the first part of this is a number of rows modulus the number of tasks. And we're checking to see if that does not equal 0. Basically what we're looking for is a remainder. If the number of rows divided by the number of tasks has a remainder, then we want to round up. If it doesn't, then we want to round down. Now I'll tell you why we're doing that. Suppose the number of rows equals 12. On the device that I'm using, the number of tasks is the number of cores, which equals 8. So the number of rows divided by the number of tasks equals 12 divided by 8, which is like 1. 4 or something like that, it's actually 1. 5. So, in that case, we would have a remainder of. 5, or in other words, number of rows modulus number of tasks would not equal 0. So in that case, we want to round up. So in that case, our chunkSize would be 2. What would happen if our chunkSize was 1? If our chunkSize was 1, that would mean that each thread would only be querying a single word, but there's 12 words, so that's definitely not the most efficient way to do it. We want to maximize the amount of threads we use to minimize the total query time. There's only 12 words and there's 8 threads, so each thread should definitely carry at least 2 words. Now that example's okay, but consider a different example. So I have eight cores, or eight processors, or eight threads on my device. What happens if I had 17 words? My number of tasks is still 8, but here we have 17 divided by 8, which is about 2. 12, I believe it's an eighth, so yeah, I think it's like 2. 12. So what happens in this situation? The number of rows divided by the number of tasks still isn't a whole number, so our chunkSize therefore becomes 3. But what happens if we would have put our chunkSize to 2? If we would've put our chunkSize to 2, we wouldn't have been able to query all the words because each thread would have only query 2 words, which would have given us 16 words, leaving 1 word behind. That's why you always have to round up. If there's ever a remainder, you always have to round up or you're going end up having some words behind in some cases. If there's no remainder, everything works fine, but if there's ever a remainder, you always need to round up. So this basic logic that I just outlined can extrapolate to 1, 000 words, 5, 000 words, 100, 000 words, as far as you want to go. Okay, let's continue writing our method. The next step is building the loop. So we have our integer i starting at 0, and we want to loop all the way up to, and including the number of tasks. Inside here, I'm going to write a log for debugging just saying starting the query at row#, and then we want to write chunkSize * i. That's going to be the starting row of each query. Now we want to create a ThreadPoolRunnable for each one of these. So new ThreadPoolRunnable. The first input is the context, the second is the mMainThreadHandler, the third is the chunkSize multiplied by the loop iterator, and the fourth is the chunkSize. And finally, the last step is just submitting all of these to our ExecutorService. So just submit and then runnable. I'm going to call this method in our onRowsRetrieved method up here. Now let's run it and take a look at the log output and see what we see. It's going to be much easier to explain what's happening from looking at the log. Okay, I'll pull the log out to give us lots of room. Going to get the phone on the screen. So now I'm going to refresh the view to query all the words. And now let's take a look at the log. So if I scroll up, the first thing we want to see is the number of database rows. So you can see right here that's the number of rows, we have 14. My device has eight cores. Because it has 8 cores, we expect to see a chunkSize of 2, which is what you see right here, chunkSize of 2. Now there should be eight total threads. So we have 1, 2, 3, 4, 5, 6, 7, 8. And then you can see thread 4 actually gets reused. That shouldn't be happening. The way we designed this, there should never be a thread doing more than one set of data. So we know we have an issue here. We have eight threads, and we only intend to use them each once, that's the way we designed this. And if you look here, you can see that the query is starting at row 16, but row 16 doesn't exist because there's only 14 rows. That's where our problem is. If we go into our loop, we need to remove this equal sign because it's looping one too many times. Now if I run this again, everything should be good. I'm going to refresh it again, and let's take a look at the log. If I scroll over, we have our eight threads over here, which is perfect. We only want eight threads because I have eight cores. Our number of rows is 14, our chunkSize is 2, that looks good. We have our handleMessage method retrieving the words, there's 2, 4, 6, 8, all the way up to 14. This is a double output it looks like here. It retrieved 0 words because we have 8 threads, and the chunkSize is 2, but we only have 14 words, so that last thread is returning 0 words, which is what we expect to see. Now before we move forward, I just want to do a couple of quick things. Number one is we need to fix an issue. Right now if I refresh the feed more than once, the words are going to duplicate. They're going to duplicate because we never clear the list before adding all the new words. If you scroll down here, there's nothing in here that clears the list and anywhere, onRowsRetrieved, executeThreadPool, not anything to clear the list, so we need to add that. That way when the query is first executed, when all the thread pools are set up, the list will be cleared, and then fresh data is going to come in there. The second thing I want to do is I want to test what it's like to query more than 16 words because right now I have 8 cores on the device I'm testing, so what happens if we go on the higher end of the spectrum? We test below when we have less words. Right now we have 14 words, so let's see what happens when we query 17 words. So here I have the application open. I'm just going to add a couple random words here, just some completely random text. So I've added three new words, now I'm going to refresh the feed, and now let's open the log and see what's going on here. Everything's looking good from first glance. We have 17 rows, the chunkSize is 3, so that's good, it's rounding up. We have our eight threads over on the right. You can see it's receiving 3 words at a time all the way up to 17 total words.

Shutting Down a Thread Pool
By default, thread pools will not stop when an activity is destroyed. It will continue running until the tasks are complete. There's a couple methods we can use to control that. The first one I want to talk about is shutdownNow. So I'm going to go into the onStop method, and I'm going to call mExecutorService. shutdownNow. ShutdownNow is similar to the cancel method in the AsyncTask. It's going to stop it immediately, regardless of what's happening. Shutdown, on the other hand, will allow all the tasks that have been submitted to the thread pool to complete, and then it will shut down. ShutdownNow is more of an immediate thing, shutdown will allow the task to complete, and then it will shut down. Those are your two options when it comes to stopping the thread pool.

ThreadPool Performance Comparison
In this video, we're going to test the efficiency of using a thread pool versus using a AsyncTask when querying over 50, 000 words from a database. Personally, I think this is going to be the coolest video in the entire module. This is where you're going to actually be able to see the performance difference of a thread pool compared to a regular query that just operates on a single thread. So I'm going to open up DictionaryActivity, and we're going to get started. I'm going to record the time it takes to make the query. First, we're going to query the regular amount of words, so the 17 words in the database, we're going to query that and see how long it takes using a thread pool and using AsyncTask. And then I'm going to insert 50, 000 words, and we're going to do the same thing and see which one wins. So first of all, we need a new variable, a new integer variable, and it's going to be called mStartTime, and I'm going to set that to 0. Then down in the retrieveWords method, so this is when kind of everything kicks off, I'm going to set mStartTime to the System Time. It's giving me an error. That's because I declared the wrong data type, this needs to be a long. Now I'm going to scroll to the bottom of the file and I'm going to create a method for logging the time elapsed. I'm going to declare a string that represents the time difference of the current time minus the StartTime, and I'm going to call this method right here inside the thread pool, so getTimeElapsed. Okay, so let's test this using a thread pool. I'll open up the log, get the device on the screen. Now I'm going to refresh. And let's take a look. So I'm going to filter on time elapsed. So the first query was completed in 97 ms, and the last one was completed in 101 ms. So total time to complete the entire query was 101 ms. Keep in mind, we're making a lot of queries here. We're setting up the thread pool, but we're also using an AsyncTask to query the total number of rows, and that's included in the total query time. So there's a lot happening here. Now let's try this using just an AsyncTask. So I'm going to comment this out, I'm going to new RetrieveWordsAsyncTask, pass the context, the TaskDelegate, and then execute and pass the title. We still need to wait to see the results, so scroll down to the onWordsRetrieved method and call getTimeElapsed. Now run it and let's see how long the AsyncTask will take to retrieve all the words. I'll bring the log up here, I'll filter on time elaps, now I'll drag downwards. It takes 43 ms. So quite a significant difference. If I take a look at the calculator, and I do 43 divided by 101, which was the time it took the thread pool to complete, I get. 42. So subtracting 42 from 100, the AsyncTask completed roughly 58% faster than the thread pool. So now that we know the AsyncTask works a little better with a smaller amount of words, I'm going to insert 50, 000 words and see how that performs. So I'm going to open up the MyThread class, and inside the MyThread class I'm going to create a new method for inserting 50, 000 words. The method's pretty straightforward. It's just calling the saveNewWord method, but it's calling it 50, 000 times. Each word will have the same title, roughly. It's just going to have the integer representing which iteration the loop is on, and then some random text for the content. Now I want to call this inside of the WORD_INSERT_NEW case. So if I go to try and insert a new word, 50, 000 will get inserted. Now I'll run the app, and we'll insert those new words. To insert the words, I just need to create a new word, it can be anything, press back, and that should start the upload of all the words. As you can see, the words are being inserted into the database, so I'm going to pause the video and skip ahead to when it's all done because this is going to take a few minutes. The 50, 000 words have been inserted. Now I'm going to delete the insertWords method because we don't want to accidentally add another 50, 000. And now I'm going to run it and we're going to test it and take a look at the log outputs. Okay, I'm going to expand the log here and bring the device onto the screen. Now I'm going to drag downwards to refresh the feed, and let's take a look at the time. So, I'll filter on time elapsed, that's probably easiest. So the first word, or the first thread, was called in 250 ms, the last one was called in 380 ms. So the total time it took was 380 ms. I'm actually just going to write this down here, 380 ms, just so that we remember. Now I'm going to go back to DictionaryActivity, and I'm going to scroll up, and I'm going to comment out this, and do new RetrieveWordsAsyncTask this, this, and execute, and pass the title. Now we're going to see how long it takes to query that same 50, 000 words, but using an AsyncTask. Once again, I have the app open, and I'm filtering the log on time elapsed. I'm going to drag downwards, and the time elapsed is 727 ms. So quite a big difference. So it's 727 ms compared to 380 ms. If I pull out my trusty calculator, I can do 380 divided by 727, so the thread pool performed 100 minus 52, which is 48% faster. That's quite a significant difference. And as the queries get larger and larger, this gap is going to get bigger and bigger. Thread pools will continue to outperform a single thread as the dataset gets larger and larger. So pretty cool stuff. It would be a cool experiment to see at which point the thread pool starts to outperform the single thread. I'll leave that up to you for an experiment.

Module Review
We started the module by talking about Executors. As you now know, there's no such thing as a thread pool object. It's a conceptual term used to describe a grouping or a collection of threads. Executors are the actual objects involved in creating "thread pools. " When it comes to thread pool customization, there's a lot of options. I could easily make an entire course on thread pools alone, but since this is an introductory course, I kept it simple. As it turns out, there's actually a class made specifically for simple use cases of thread pools. It's called Executors. The Executors class contains static methods that return pre-configured thread pools. The static method that we focused on was the newFixedThreadPool method. NewFixedThreadPool returns an ExecutorService object. Using this method, initializing a thread pool was very simple. It requires a single input, an integer, representing the number of threads that you want in the pool. After that, the thread pool is ready to accept work. But what is work? What kind of work do you send to a thread pool? In this project, we sent Runnables to the thread pool. We built a custom Runnable class named ThreadPoolRunnable that retrieved a specific number of words from the database. The Runnables were instantiated in DictionaryActivity within a loop, and then submitted to the thread pool. Each Runnable was responsible for querying a portion of the total words. That's really all there was to it. Implementing a thread pool using the Executors class is a very straightforward process.

Tying It All Together
Review Thread Looper Handler
This course was all about threads and exploring the different threading options available on Android. The first threading option that we looked at was the Thread/Looper/Handler pattern. The Thread class stands out from the other threading options because the other threading options are composed of the Thread class. The Thread class is the lowest common denominator. The other classes are built on top of the Thread class. Let's review the structure for implementing your own custom thread. First, you need to create a new class that extends Thread. Next, you insert the run method. The run method is the first method that's executed when a new thread is started. Inside the run method, you need to do two things. You need to prepare the Looper and you need to loop the Looper. Once the Looper is prepared, you can instantiate a Handler, and then use that Handler to send work to the message queue. When I say work, I'm referring to Runnable objects and message objects. Now let's talk about the Looper. The Looper's job is to manage the message queue of a thread. By default, threads do not have a Looper. You can create one by calling Looper. prepare and you can start it up by calling Looper. loop. The message queue is the mechanism that the Looper manages. Without the Looper, there's no way to push tasks to the queue. I believe the best way to think of the message queue is like a stack of work. The work can be Runnable objects, or it can be message objects. When a task at the top of the stack is executed, it's destroyed and then a new task takes the top position. The Looper is responsible for keeping the whole system turning. That's the basic structure of every thread mechanism. Here's a review of the entire mechanism that we implemented. There's two threads, the main thread and the background thread. The main thread is running in DictionaryActivity. The background thread is responsible for executing all the database operations. DictionaryActivity holds a list of words. The only way it can retrieve the words is by asking the background thread to query them. The background thread then needs to send those words back to the main thread. The first step in this process is sending a message object to the background thread. The message object will tell the background thread what to do. In order to send a message object, you need a Handler to facilitate the communication. The message object is then added to the message queue of the background thread. The message object is placed at the bottom of the stack. Eventually, the message makes its way to the top of the stack where it's deciphered. At that point, the background thread would query the database and retrieve a list of words. The job of the message queue is to complete the task and then it can be destroyed by the Looper. The next step is sending the data back to the main thread. A second message object is instantiated on the background thread, and then a list of words is added to a bundle and attached to the message object. That message object is sent back to the main thread through the use of a second Handler. The list of words is retrieved from the bundle, and then eventually added to the RecyclerView.

Review HandlerThread
The HandlerThread class was designed to help developers save a little bit of time when working on a background thread. The name of the class suggests it has some kind of a built-in Handler. At least that's what I thought the first time I heard about it, but that's definitely not the case. There is no built-in Handler. What it does have is a pre-packaged and prepared Looper, so a more suitable name would be something like LooperThread. If you recall from the module on the Thread/Looper/Handler pattern, we built a custom thread class. As you now know, if you build a custom thread class and you want to have a functioning message queue, you need to prepare and start the Looper. With a HandlerThread, you don't need to do any of that. If you look at the source code for the HandlerThread class, it has a run method that looks like this. By the way, if you're curious, I got this from the GitHub page for the Android Open Source Project. It contains all the code in the Android SDK. Anyway, the thing to notice here is the Looper. prepare and the Looper. loop method calls. Also notice this global variable named mLooper. In essence, this is what makes using a HandlerThread advantageous over a regular thread. You don't have to set up the Looper, and you can get a reference to the Looper through this global variable named mLooper. These changes are subtle, but when sending some work to a background thread, it makes life much easier. You just instantiate the HandlerThread object, you start up the thread, you instantiate a Handler and pass a reference to the thread's Looper, getLooper will return a reference to the mLooper global variable that I was just talking about, then you just post the job. In this case, it's a Runnable.

Review AsyncTask
Like the HandlerThread class, the AsyncTask class was designed to save developers some time when doing work on background threads. AsyncTask has Thread and Handler classes packaged into it. All you have to know is how to use the provided methods. There's four main methods that you'll find yourself using almost every time you implement an AsyncTask. There's onPreExecute, doInBackground, onProgressUpdate, and onPostExecute. After the AsyncTask is started, onPreExecute is the first method that's called. OnPreExecute is called on the main thread. Because it's executed before the background task has started, it's typically used to prepare UI elements for the incoming data. The second method that's executed is doInBackground. This is the bread and butter of the AsyncTask class. As its name suggests, all the code in the doInBackground method is executed on the background thread. OnProgressUpdate has the unique ability to execute on the main thread, even if it's called within the doInBackground method. Because of this unique property, it's used to update the main thread with the progress of the task that's being executed in the background. When the task in the doInBackground method is complete, a result is returned. That result is passed as an input to the onPostExecute method. The onPostExecute method is executed on the main thread. This is the last step in the process. At this point, something was done on the background thread and the result is posted to the main thread via the onPostExecute method. The biggest downside of using an AsyncTask is the fact that only one can execute at any given time. For example, suppose I have two custom AsyncTask classes, AsyncTask1 and AsyncTask2. If AsyncTask1 is executed, then immediately after AsyncTask2 is executed, AsyncTask2 will not run until AsyncTask1 is complete. I'm sure you see the potential problems associated with having a system like that. If for some reason AsyncTask1 takes longer to complete, or worse, it doesn't complete at all, AsyncTask2 will never run. It's like having a dependent system that isn't actually dependent. For this reason, you should always avoid doing long-running operations using an AsyncTask. And make sure to write your code such that it's protected from these situations, or in other words, have a failsafe system in place.

Review ThreadPools
In the module on thread pools, we looked at a very simple use case for executing Runnables using an ExecutorService. Remember that thread pool is a purely conceptual term. There is no such thing as a thread pool object. What we're actually talking about is Executors. By definition, an Executor is an object that executes submitted Runnable tasks. These tasks can be executed on a background thread or they can be executed on the main thread. An ExecutorService is a class that implements Executor. It's essentially an Executor with more functionality. The simplest way to implement a thread pool using an ExecutorService is by taking advantage of the static methods in the Executors class. In particular, the static method that we looked at was newFixedThreadPool. NewFixedThreadPool accepts an integer as input representing the number of threads that you want in the thread pool. Technically speaking, you could have any number of threads in the pool, but the device can only support a certain amount. What I mean by that is the device can only have a certain amount of threads running in parallel at any given time. The number of threads depends on the number of processors, or in other words, the number of cores. You can determine how many processors a device has by running Runtime. getRuntime and then. availableProcessors. In the module, I initialized an ExecutorService object using the total number of processors on the device. At that point, the thread pool is ready to accept work. And because we used the newFixedThreadPool method, everything is pretty much managed for us. I don't have to worry about spawning new threads, I don't have to worry about load balancing, I don't have to worry about cleaning up the threads, all I need to do is send work to the thread pool using the submit method, and the Runnables will be executed when the resources become available. Actually, that's not entirely true. I need to shut down the thread pool when it's no longer needed. And conveniently enough, there's two methods for doing just that, shutdown and shutdownNow. Shutdown will wait until all the submitted Runnables have been completed. ShutdownNow will stop any Runnables currently executing and destroy the thread pool immediately. When should you use a thread pool? Like most other design questions, the answer is it depends, but in general, thread pools tend to outperform single threads when a task gets longer, or in other words, when a task becomes more long-running. And that's what we saw in our test. The AsyncTask outperformed the thread pool when there was a small number of words to query. But when we queried 50, 000 words, the thread pool completed the task almost 50% faster, which is a very significant difference.

Final Thoughts
Because of some of the modern Android libraries like RxAndroid and Glide, many developers think it's not that important to have a solid understanding of Threads, Handlers, and the various threading options. I think that's partially true. For example, consider the Glide library. Glide is used for downloading, caching, and displaying images from the internet. With only a few lines of code, you can reference an image from the internet and it will be asynchronously downloaded and displayed on the screen. This is absolutely incredible. Years ago, developers would have to construct a threading system to download the image on a background thread, cache the image, convert the image to a bitmap, check if it's oriented properly, i. e. it's not rotated sideways, and then send the bitmap to the main thread where it could be displayed. That is a monstrous amount of work. I don't think it's a good use of time to manually construct a system like this every single time you want to display an image, not when such a powerful library exists. However, I do think you should understand how it works. You should understand that the image is downloaded asynchronously on a background thread, some kind of processing happens, and then the bitmap is sent to the main thread where it can be displayed. If you don't understand the low-level constructs, like the thread class, how could you ever build something custom? What if a new image type is invented and the Glide library doesn't know what to do with it? You need to know how to look deep into the library's code and make alterations. Essentially, you need to know how to tinker, because at the end of the day, that's what you are. You're a creator, a tinkerer, and a problem solver. If you don't know how to use the tools, you're probably going to struggle when you encounter problems that you haven't seen before. I'm interested in hearing what you think about that topic. Leave me a message in the discussion section for the course on Pluralsight, or add me on Instagram or one of the other social media platforms and send me a message. Tell me your thoughts, give me feedback on my courses, or just say hi. It's all the same to me. Staying in touch is what's important. I hope you enjoyed the course as much as I enjoyed making it. My name is Mitch Tabian, and as always, thanks for watching.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
4.7 stars with 15 raters(15)
My rating
null stars

Duration
2h 19m
Released
15 Nov 2018
Share course