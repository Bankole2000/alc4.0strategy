Firebase on Android: Cloud Messaging, Cloud Functions and Crashlytics
by Mitch Tabian

At the core of Push Notifications and user engagement is a thorough understanding of Firebase Cloud Messaging. In this course, you'll learn how to send and receive Cloud Messages, build and deploy Cloud Functions, and how to integrate Crashlytics.

At the core of Push Notifications and user engagement is a thorough understanding of Firebase Cloud Messaging. In this course, Firebase on Android: Cloud Messaging, Cloud Functions and Crashlytics, you will first learn how to leverage Firebase Cloud Functions to send Cloud Messages which will then trigger the generation of Push Notifications. Next, you will explore how to build a service class that receives Cloud Messages on the Android client, how to build and deploy Cloud Functions, and how to send Cloud Messages using a Cloud Function. Finally, you will learn how to integrate Firebase Crashlytics. When youâ€™re finished with this course, you will have a foundational knowledge of Firebase Cloud Messaging, Firebase Cloud Functions, and Firebase Crashlytics that will help you as you move forward to develop engaging mobile applications.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
4.9 stars with 25 raters(25)
My rating
null stars

Duration
2h 6m
Released
4 Jan 2018
Share course

Course Overview
Course Overview
Hi, my name is Mitch Tabian, and welcome to my course: Firebase on Android, Cloud Messaging, Cloud Functions, and Crashlytics. I'm a self-employed Android developer, and I'm here to teach you about three incredible developer tools: Firebased cloud messaging, Firebased cloud functions, and Firebased crashlytics. Every mobile application uses push notifications to drive user engagement, and make sure users are alerted when special events occur. In the past, most developers used Google Cloud Messaging, or GCM for short, to trigger the creation of push notifications. Google has announced that they'll be investing in Firebase and making it their unified platform. What does that mean for the state of push notifications and cloud messaging? Google now recommends using Firebased cloud messaging, or FCM for short, instead of Google cloud messaging. There's never been a better time to get comfortable with Firebased cloud messaging, as it's now the preferred method for sending notifications to users. Some of the major topics that we'll cover include: building custom push notifications. In the course, we'll build custom push notifications that will be sent to specific users. Firebased cloud messaging. We'll learn to leverage the power of Firebased cloud messaging and use it to trigger the creation of push notifications. Firebase cloud functions. To generate the cloud messages, we'll need the help of Firebased cloud functions. Firebase crashlytics. We'll learn to integrate Firebased crashlytics so you can get detailed crash reports on all your application's failures. By the end of the course, you'll have a complete understanding of how you can use cloud messaging and cloud functions to send push notifications to any of your apps users. Before beginning the course, you should be familiar with Android Studio, but I'll guide you through everything, so if you're fairly new, you should still be okay. I hope you'll join me on this journey to learn about Firebase, with the Cloud Messaging, Cloud Functions, and Crashlytics course, at Pluralsight.

Getting Started
Introduction
My name's Mitch Tabian, and welcome to my course: Firebase on Android: Cloud Messaging, Cloud Functions, and Crashlytics. Every mobile application has what I like to call the three core pillars. The pillars I'm referring to are an authentication system, a database and storage system, and a cloud messaging system. In my previous course, Firebase on Android: Real-time Database and Cloud Storage, I mentioned the three core tools as authentication, a database, and a storage system. I've decided to rephrase that and lump the database and storage together because cloud messaging is also very important. If you've been following my Firebase on Android series, you know that in the first course we implemented an email authentication system, and in the second course, we implemented the Firebase database and the storage tools. So referring back to the three core pillars I just mentioned, we have one component left: a cloud messaging system. So what exactly is a cloud messaging system? Sending cloud messages refers to the ability an application has to communicate with users or groups of users in bulk. Typically, cloud messages are sent out and received by client apps in the form of push notifications. Push notifications are those little messages you receive in a system tray of your mobile phone. They come in many different forms. There's alert notifications, sales channel notifications, notifications letting you know that you've received a message from another user; the list goes on. I'm sure you're very familiar with them, as all apps send them out for many different reasons. So now that you know what cloud messaging is, you might be thinking: so what is this cloud functions thing? I've already told you the three core pillars of mobile development, and cloud functions isn't one of them. Cloud functions is something unique to Firebase. As you already know, Firebase tools are completely serverless. That is, you don't need to purchase a domain and set up a server to start using the tools that they offer. Everything is hosted from your personalized Firebased console. Now, that type of a system has many advantages, but there's also a few disadvantages. Not everything can be done from the Android Client. What happens if you need to execute some special server-side code? Or if you need to execute a complex algorithm that requires a lot of computational resources? How about listening for changes in the database? If a user hasn't opened the app yet, you can't listen to the database. Firebased cloud functions fills this gap in functionality. You can write functions or small segments of standalone code that execute on their own on the Firebased servers. They're extremely flexible. To execute the functions, you can set up triggers on pretty much any of the Firebase tools. There's Authentication Triggers, Database Triggers, Storage Triggers, Analytics Triggers, Firestore Triggers, HTTP Triggers, or Cloud Pub/Sub Triggers. So how do cloud functions fit into this course? Actually, one of the main ways they're used is in conjunction with cloud messaging. We're going to build a cloud function that triggers when users send messages to one another in the chat rooms. The function will be constantly listening for rights to the database, and will send out cloud messages to all users in a chat room. And finally, in the last section of this course, we're going to talk about crashlytics. Firebased crashlytics is a tool that doesn't get enough attention. It's very valuable for developers. In a nutshell, crashlytics saves detailed information on application failures in the Firebase console. You can use information it produces to pinpoint issues with your application without ever having to talk to the app users. This can save a massive amount of time. The reports organize information in an analytical fashion, so it's really easy to identify urgent issues affecting most users. In the next section, we'll take a look at the prerequisites for this course.

Prerequisites
In this section, we're going to talk about all the prerequisites related to the course. To get the most value from this course, I recommended you watch the two courses that proceeded this one: Firebase on Android: Email Authentication and Verification, and Firebase on Android: Real-time Database and Cloud Storage. After watching those courses, you'll have a great understanding of how to implement the firebase authentication system, how to use the firebase database, and how to upload and save files using firebase storage. However, if you only want to learn about cloud messaging, cloud functions, and crashlytics, this course can stand alone, but there will likely be things you don't fully understand. Other than that, I recommend you know your way around Android Studio and how to use the Android Emulator. This course technically does not require any prior experience with Firebase, but as I mentioned, I do recommend checking out my Firebase on Android series. Here's some information on the software versions we'll be using. We'll be using Android Version 26, otherwise known as Android O, Firebase Version 11. 4. 0, Android Studio Version 2. 3; yes, I know Version 3 has been released, but I wanted to finish this course trilogy using the same version, and we'll be using the Firebase SDK, and Google Play Services SDK. For testing the application, I'll be using two phones: a Samsung Galaxy J5, and a OnePlus2. I'll be mirroring the screens using a Google Chrome extension called Vysor. I'm using two phones because we'll be posting chat messages into chat rooms and testing notifications. You need two phones to do this effectively. Just to be clear, you don't need two phones, just I do, because I need to portray information effectively. In the next section, we're going to talk about the story behind the application we're building, that way you'll have some real context as to why we're using Firebased for the application.

The Story Behind the App
For the duration of the course, we'll approach app development from the perspective of an imaginary company: Tabian Consulting Inc. For those of you who've watched my Firebase Authentication course, we're literally continuing from where we left off at the end of that course. For those of you who haven't seen my Firebase Authentication course, here's a scenario of Tabian Consulting. Tabian Consulting is currently a 10 person company that is looking to expand their personnel to 100 employees in just 12 months. For those of you with no experience in the corporate world, that's a sizeable increase. The CEO recognizes there's too much manual work being done with respect to their current infrastructure around employee scheduling and communication. The current employees are a tightly-knit group who send out schedules via email, and communicate through text, phone calls, and emails. With 100 employees, there needs to be a more efficient system. The CEO has decided to invest in the development of a mobile application that will manage employee scheduling, and provide a means of communication. The CEO has the following criteria in mind: it must be secure and only allow employees to access, it must be scalable as the company is growing, and she wants to minimize development cost; in other words, development time. The first point here specifies that the application must only allow employees to register with an email address at Tabian. ca. So someone named Mitch would have the company email mitch@Tabian. ca. The CEO is unsure about Firebase, as it's a relatively new technology, but you as the developer, ensure her that it meets every criteria perfectly, and is owned by a very reputable company: Google. In the next section, we're going to do a complete application demo, and showcase all the features for the Tabian Consulting app.

App Demo
In this section, we're going to do a complete application demo of what we'll be building in this course. As I mentioned in earlier sections, this is the third of my Firebase on Android course series on Pluralsight. In this demo, I won't be going over the authentication, database, or storage features, I'm just going to demo the content from this particular course. Since I'm going to be demonstrating a real-time chat system, I'll be using two devices for the demo. I'll log into two separate accounts, for the first one I'll type my email: mitch@tabian. ca, type in my password of password, and click SIGN IN. Note that this account has admin privileges, the other does not. For the second, I'll type in a dummy email I just created: mitchelltabian@gmail. com, and the password of password. Here we have the employee dashboard of the Tabian Consulting employees. These widgets don't do anything, this screen is basically just for show. The only button that does do something is this menu button up in the top right. If we click it, we see four options: Sign out, which obviously signs out the user; Account Settings, which brings us to an account settings screen; Chat, which will bring us to an activity where we can create or join chatrooms and chat with employees; and a new section unique to this course labeled Admin. Let's check out the Admin section first. Notice that I can only get into the admin section if I'm logged into an admin account. The account on this screen can't get in. The main purpose of the admin screen is to allow admin users to send out broadcasts to the Tabian Consulting employees. At the bottom is a list of all the employees, and you can see a subscript that denotes the department that they're part of. The admin also has the ability to assign employees to different departments. So you just click on an employee, and choose a department, if you want to add a new department, you just click on the Add button right here, and type in a department name. I'll type in Customer Service. Once entered, the new department will show up as an option when you select an employee. Notice that Customer Service is now an option in the list. I'll assign this user name to Mitch to the customer service department. As I mentioned, the admin has the ability to send broadcasts to the departments. All the admin has to do is select a department and type in a title and a message. Then click Send. I'll type in a title of URGENT and a message that says: see schedule immediately. Now select the departments that you want to send the message to, since I'm logged into the account: mitchelltabian@gmail. com, I'll choose the Projects department, so we'll see a notification on this device. Before we send the messages, I'll open the system tray on this other device so we can see the notification come in. We're ready to send it. So pretty much immediately you can see the message pop up on the screen, and because this is a broadcast message from the admin, it will show up no matter what state the phone is in; whether it's closed, in the background, or in the foreground. The message will show the same as you see right now. So that's one way we'll be sending cloud messages. Now let's take a look at the chat notifications. Go back to the main screen, now click on the menu and select Chat, there's currently on chatrooms, so let's make one. I'll call it Human Resources and give it a security level of one. Now let's join the chatroom on both devices. Now press the back button on both devices. Notice there's an option to leave the chatroom. This is how we differentiate between users who receive chat notifications, and users who don't. If they've joined it, then they'll receive notifications, if they don't, then they won't. Pretty straightforward. Back to the chatroom. I'm going to type a message from this user saying hello. Notice that neither user received a notification on their phone. The app is designed not to send notifications if the user currently is using the app, or in other words, if the app is in the foreground. But watch what happens when I close the application on one of the devices. Now say, hello, is anyone there? It can take a few seconds. Look. There's a notification. So let's talk about the notification. We've got some basic material design on the notification, but nothing too crazy since this course isn't on push notifications. So here we have the Tabian Consulting icon, the chatroom name that the message was posted in, the user who sent the chat message, and the message itself. It also displays the number of messages that have posted since the last time the user was in the chatroom. To prevent the user from getting annoyed by notifications, there's only a noise on the first message they receive. If they have any pending notifications, there will be no noise. Additionally, each new chatroom message will replace the previous notification so users won't get spammed by hundreds of push notifications in an active chatroom. Each chatroom has a unique notification ID denoted by the chatroom ID. If a user clicks on the notification, the app will open to the chatroom the message was sent from. That's it for the new and improved Tabian Consulting app. In the next module, we'll get started with enabling all the tools required for this project.

Integrating the Firebase Tools with Android
Software Requirements
In this module, we're going to get started integrating the Firebase tools with our Android project. For the duration of the module, we'll be working with the source code files in the directory: module_2/start/TabianConsulting. As I mentioned before, there's two courses preceding this one: Firebase on Android: User Email Authentication and Verification, and Firebase on Android: Real-time Database and Cloud Storage. We'll be continuing from the endpoint of the second course, and working on the Tabian Consulting application. If you've watched that course, then you can skip this section and move onto the section named Syncing the Android Project with the Firebase Project. We're going to be working with Android Studio Version 2. 3 and Android Version 26, which is otherwise known as Android Oreo, or Android O. To use Firebase with Android Studio, we're required to install the Firebase SDK and Google Play Services SDK. We need to take a quick look at the SDK manager in Android Studio to make sure you meet all the requirements, and since we're going to be looking at the SDK Manager, we might as well open the project. Once you've downloaded and opened the project in Android Studio, you're ready to proceed. Let's navigate to the SDK Manager and see if we meet all the dependency requirements. To navigate to the SDK Manager, click on Tools, Android, and select SDK Manager. First make sure you have Android O installed, if it isn't, simply check the checkbox for Android O, and click Apply. Next, take a look at the SDK Tools. Here we need to make sure that Google Repository is installed under Support Repository, and Google Play Services is also installed. If they aren't, simply check the checkbox and click Apply. That's all we need to do to start using Firebase. Also note that if you're going to be using the emulator to test your application, ensure that it's updated. You can check that by viewing the status here. If it says it needs an update, just click the checkbox and hit Apply. In the next section, we'll head over to firebase. google. com, and get started connecting our Android application to the Firebase servers.

Creating a New Firebase Project
In this section, we're going to take our first look at the Firebase cloud console, and create a new Firebase project. Once again, if you've already watched the course preceding this one called Firebase on Android: Real-time Database and Cloud Storage, you can skip this section and move onto the section named Syncing the Android Project with the Firebase Project. For the remainder of this video, I will assume those of you who are watching have not completed my Firebase Database and Cloud Storage course. So now we're ready to create a new Firebase project so we can integrate the Firebase Database and Cloud Storage Tools into our application. As I mentioned before, Firebase is a cloud-based framework so all we need to do is essentially point the Firebase project to our Android project, and vice-versa. After that, they'll be connected forever unless you break the connection. To get started with Firebase, just head over to Firebase. google. com. Once you're there, ensure that you're signed into your Google account. Firebase automatically syncs to your Google account, so you can manage your projects from anywhere in the world. This course focuses on the Firebase database and cloud storage tools, so I'm not going to go over the other tools, but if you want to learn more about them, check out these links down here. In the top right of the browser window, there's a button labeled GO TO CONSOLE. Click it, and you'll be redirected to your personalized Firebase console. On this page, all of your Firebase projects will be listed below. If this isn't your first interaction with Firebase, then you'll have any number of projects already here. If this is your first interaction with Firebase, there will only be one button, and it will say: Add to project. Let's click it. Let's follow the instructions and give our project a name. Keep in mind the Firebase project name doesn't have to match your Android project name, it's just something that I prefer to do. Now select your region. My region is Canada, but you can enter your own region here, and click CREATE PROJECT, and let Firebase build your project. This is now the project dashboard. It's a custom view where you can access all the Firebase tools your application uses. They're shown in a column on the left. Currently, we don't have any of these features enabled, but in the next part, we'll take a look at the database and storage tabs, and integrate Firebase into our Android Studio project.

Syncing the Android Project with Firebase
In this section, we're going to connect our Android Studio project to our cloud-based Firebase project. For those of you who have not completed my other Firebase courses, this is going to be mostly review. We're going to connect our Firebase project to our Android application by referencing the package name and acquiring a Google Services JSON file. Remember, you must use your own Google Services JSON file from your Firebase console. You can't use mine, or the application will try to communicate with my Firebase console. For those of you who have not taken my other Firebase courses, that statement will make no sense to you right now, but it will in a few minutes. Let's head over the Firebase console. So here I am in the Firebase console with the TabianConsulting Firebase project selected, as you can see from the pulldown menu right here. Select the Add Firebase to your Android app icon in the middle of the screen. As you can see from the top of the popup window, there's there steps we need to complete. In the first step, we have three fields available to us: Android package name, App nickname, and Debug signing certificate SHA-1. The app nickname is 100% up to you and I'm just going to be leaving that field blank. The SHA-1 certificate isn't needed to use the Firebase database or cloud storage. As you can see below, it's only required for dynamic links, invites, Google sign-in, or phone number authentication. So, I'll just be leaving that blank also. We can get the application package name from our Android Studio project. You can get it from any of the Java files in the main package directory. So let's open up Android Studio, and we'll navigate to any of the Java files. I'll just open up LoginActivity, and copy the package name from the top of the file, now go back to Firebase, and paste in the package name. Now press REGISTER APP. Next is adding the Google Services JSON file to your application. This is the most important step. Anytime you open my source code in Android Studio, you'll need to add this Google Services JSON file from your Firebase console. Your package name must also match, so that's why I recommend using the same package name that I'm using. If you use the same one, you'll only have to worry about the Google Services JSON file. The Google Services JSON file will allow Firebase to identify your Android application. Once again, do not copy mine from the source code files. You need to get your own from the Firebase console, just as I'm doing in this video. Now let's download the file and add it to our project. After downloading, navigate to the project pane in Android Studio. You can get to the project pane by selecting this double-sided arrow, and then you select Project, and now expand the directory and drag the Google Services file into the app folder. That's it. Now let's go back to Firebase and see what's next. So this is the final step. Add this first dependency to your Project- level build. gradle file, and add this second dependency to your App- level build. gradle file. The two build. gradle files can be found in the same directory in Android Studio. One is labeled Project and the other one's labeled App. So, we'll start by copying the dependency for the build. gradle app file right here, and then we'll navigate back to Android Studio. The two build. gradle files can be found in the Android pane. Expand Gradle Scripts, choose the gradle file labeled app, and paste in the dependency. Now go back to Firebase, copy that second dependency for the build. gradle project file, now go back to Android Studio once again, and paste it in the correct folder. Once you've added the dependencies, click on the sync button, wait for gradle to finish, and head back to Firebase. Now click FINISH, and we're done. The Firebase project and the Android application are now connected. In the next video, we'll take a look at enabling the Firebase tools we'll be using in this course.

Integrating the Firebase Tools
We've connected our new Firebase and Android projects, now we're ready to integrate the Firebase tools. If you've watched the two courses preceding this one, almost all the Firebase tools should already be enabled, and all you need to do is get the dependency for cloud messaging. There's no dependency for cloud functions since they're executed on the Firebase Server, and not on the Android client. We won't need the dependency crashlytics until later in the course. I can't guarantee everyone watching this course has watched the two courses preceding this one, but because it's now the third one in the series, I'm just going to paste in the dependencies instead of guiding you through it. If you want to watch me get the dependencies from the Firebase docks, take a look at the two courses preceding this one and watch the section named Integrating the Firebase Tools. So open up Android Studio and navigate to the build. gradle app file, and add these dependencies. This is everything we need for the course. If you don't want to type it out, just go to the project files in any one of the modules, and copy them from the build. gradle app file. Before you press sync, we need to add one more line to the build. gradle project file. Open it up and add the following underneath jcenter right here. Alright, press Sync. Now that we have the dependencies, we just need to enable a sign-in method from the Firebase console. Once again, if you've watched my previous courses, then this should already be enabled. From the console, select the Authentication section on the left, I've already got some users registered, as you can see here, this should be empty if this is your first time watching my Firebase on Android series. Navigate to the SIGN-IN METHOD tab, click on Email and Password, flip the switch, and click SAVE. We have everything we need to get started with the course. In the next section, we're going to get started sending our first cloud messages.

Sending Firebase Cloud Messages from the Firebase Console
Sending Firebase Cloud Messages from the Firebase Console
In this module, we're going to get started with Firebase cloud messaging. For the duration of the module, we'll be looking at the source code files in the directory: module_3\start\TabianConsulting. As I mentioned in the course introduction, there's many ways to send cloud messages. You can send them directly from the Firebase console using the GUI interface Firebase provides, you can send them from the Android client via HTTP, and you can send them via cloud functions or by executing server side code you might have on your website. This module is going to serve as a sort of introduction to cloud messaging. This module is going to serve as a sort of introduction to cloud messaging. We're going to cover everything you need to know in order to receive messages on your Android client, and then we'll send some messages from the console to test. In other words, we'll be working on number one in the list here. In the following modules, we'll take a look at the methods from number two and from number three. Do not skip this module, as it contains important regarding your app's ability to actually receive the cloud messages. Before we take a look at the code, I want to quickly talk about the different scenarios surrounding the application state when receiving cloud messages. By application state, I mean whether you're app is in the foreground, in other words, open and currently being used; in the background, in other words, open and not being currently used; or closed. This is pretty self-explanatory, it means the app is not open. This short demonstration is going to save a lot of confusion for some people later on. I don't think the documentation does a great job of describing these details. So just sit back, watch the demonstration, and don't stress out if you don't understand. I'm going to be talking about some things that are going to feel a bit abstract if you haven't worked with cloud messaging before. The goal of this demonstration is to get you thinking about process. I'll start by describing how the messages are received by the app. We'll be covering this in detail in the next section, but here's a brief overview. Every inbound message is routed through a service class that extends FirebaseMessagingService. In this course, we're going to call this class, MyFirebaseMessagingService. The messages are captured by the onMessageReceived override method inside the class. All that is pretty straightforward. Basically, messages come in through the class, and will be captured by the onMessageReceived method. They're received as this RemoteMessage object. Nothing fancy here. Here's where it gets a little confusing. The messages will only be received if the data contained in the messages meets certain criteria. So the override method: onMessageReceived, won't even be triggered if these conditions aren't met. So what are these conditions? To accurately describe them, we need to talk about the data structure of the messages. In general, this is what the data structure of the messages will look like. You have a to parameter that defines who you're sending the message to. A notification parameter that contains a body and title to the message, and a data parameter that you can basically put anything into. You can define custom key value pairs and then you can decide how to interpret them on the client side. What the documentation doesn't do is give you a good explanation on how your Firebase messaging service interprets these messages. Let's take a look at what happens in each of the application states when receiving this example message. So suppose your app just received a data payload from the cloud message containing this data. So we're sending it to a specific user by referencing their unique FCM token, don't worry we'll be covering that in great detail later on, and the message contains a notification and also some data key value pairs. So, Case 1: App in the Foreground. If the app is in the foreground, the message will be received by the onMessageReceived method in the Firebase messaging service class, and nothing shows in the system tray. This RemoteMessage object contains the data from the message. You could call remoteMessage. getdata or remoteMessage. getNotification to get the notification. Basically, everything acts exactly as you'd expect. Nothing really special or confusing here. Case 2: App in the Background. If the app is in the background, that message will not trigger the onMessageReceived method from the Firebase messaging service class. The log will show absolutely nothing, but a notification will appear in the system tray of the app. Receiving a notification this way has a huge amount of limitations because it isn't even received by the app, it just prints to the system tray. You can't execute custom methods, you can't open a fragment or an activity when the user clicks it, and you can't attach anything other than a message, title, or icon. Overall, in my opinion, this is pretty useless. Case 3: when the app is closed. This acts exactly the same way as when the app is in the background. You get the same notification showing in the system tray, and the onMessageReceived override method is not triggered. So overall, I think sending messages this way basically sucks. The only scenario that works effectively is when the app is actually open, which ironically is when you probably don't even need to send notifications because the user is in the app and can see them from there. Now let's talk about how we'll be sending notifications in this course. We're going to remove the notification parameter from the messages so the messages will look like this. They'll only contain the data portion. What does that achieve, you might ask? This is the secret of cloud messaging. When the payload of the message, aka the contents of the message, does not contain a notification parameter, everything is captured by the onMessageReceived override method in all application states. So, looking at our three cases again, if the app is in the foreground, background, or closed, the message is received by the onMessageReceived override method in the exact same way. So, we just call remoteMessage. getdata, and we have access to the data. So this is how we'll be sending cloud messages in this course. We'll be leaving out the notification parameter completely so every message will be received by the onMessageReceived override method of our service. Then we'll build notifications manually from the service itself. We can set custom notification properties, set custom colors, set an icon, open the app to specific activities when the user clicks on the notification, anything. The possibilities are limitless. Here's a preview of what the notifications will look like. Compared to the blind default version, I'd say this is much better. You're probably still a little confused, but I wanted to talk about this before getting into the details. Everything will make more 100% sense by the end of the course. In the next section, we'll set up our Firebase messaging service class and you'll have a better idea of what I'm talking about.

Implementing the Firebase Messaging Service
In this section, we're going to implement everything needed to capture cloud messages in our Android application. As I mentioned in the previous section, we need to implement a service class that will capture incoming cloud messages whether the app is in the foreground, background, or closed. We'll start by creating the Firebase messaging service class. Right-click on the utility package, select New, Java Class, and we'll call it MyFirebaseMessagingService. We want to extend FirebaseMessagingService. Let's add a log for debugging by typing logt, now implement the methods by pressing Ctrl+O on Windows and Command+O on Mac. We need the onMessageReceived method and we can also get the onMessageDeleted method also. This is the onMessageReceived method that I was referring to in the previous video. For those of you who are unfamiliar with an Android service, here's a definition that was taken right from the developer official documentation. A service is an application component that can perform long-running operations in the background and does not provide a user interface. Another application component can start a service and it continues to run in the background even if the user switches to another application. Because this is a service, we need to declare it in the manifest. Open up your application's manifest file and add the following. Open up a service tag and then type name, and then type utility and MyFirebaseMessagingService. You should just have to put a decimal, and the rest of it should pop up. Now we need to add an intent filter to the service. This is telling the service what kind of incoming intent it needs to watch out for. So add an intent filter tag, now add an action tag, and inside the action tag, we can put the name of com. google. firebase. MESSAGING_EVENT. Make sure you don't type this incorrectly. The message service won't work if you do. We're done in the manifest for now. Go back to MyFirebaseMessagingService. So currently the app will receive notifications through the onMessageReceived method, but there's no code to execute. Let's add some variables and lot outputs so we can test an inbound cloud message. The first variable will be a string named notificationBody. Then we'll create a notificationTitle, and one more named notificationData. Now insert a try catch block. We need to catch the NullPointerException here because we can't guarantee the messages will contain data or a notification. Now we can assign the variables. To get the notificationData, we go remoteMessage. getData. toString. To get the notificationTitle, we go remoteMessage. getNotification. getTitle, and to get the notificationBody, we go remoteMessage. getNotification. getBody. Now let's write some log outputs for each one. So here's the one for the data, here's the one for the body, and here's the one for the title. So now if a message is received, we'll know because it will print out into the log. Now let's run the app because we're going to test it in just a moment here. The first type of notification we're going to take a look at is the one sent from the Firebase console. So open up your Firebase console, expand the GROW section down here, and click on Notifications. This is where you can create messages and send them to your application's users. Essentially what you want to use this for is when you want to target large groups of users or send messages to a single app user. Personally, I like using the Google Chrome extension called Postman for this, but we're going to take a look at that later. Sending notifications this way is good for advertising, sales promotions, or maybe highlighting a new feature. Click on new message, and let's see what kind of options we have. The first parameter is a required field called message text. I'll just type some message text. The next required parameter is the Target. This defines who or what group of users receive the message. We'll talk more about the different target types later in the course, but for now, I'm just going to select the User segment option, and select every user of the application from this pulldown. If we look at the Advanced options, there are some other parametesr. I'll enter a title of some title, and I'll enter a custom key value pair, the key will be some_key, and the value will be some_value. I want to point out that sending notifications from the console operates in the exact same fashion as what we talked about in the previous section. If the message has a notification payload and the apps in the background are closed, then it won't be captured by the onMessageReceived method of the Firebase messaging service class. The fields that define having a notification payload are the title field right here, and the message text field right here. These fields are the title and the body of the notification. If we take a look at the Message text field, we see that it's actually required to send a message. The console won't let you send a message that doesn't have a message text field, and if the message has a message text field, that means by definition, it must have a notification payload. So what does all that mean? That means the console won't let you send a message without a notification payload. Therefore, the console won't deliver messages when the app is in the background or closed, which makes its usefulness very limited. But one thing it is good for is testing to make sure that our service is working correctly. So let's send the message. So notice right away, the notification was received by the application. Open up Android Studio, and let's take a look at the log output. Cool. There's our title, our body, and our custom data. At this point, everything is working as we expect, and we're able to successfully receive notifications via our Firebase messaging service class. In the next section, we'll set up our Firebase messaging ID service, so we can identify users and send cloud messages to specific devices.

Implementing the Firebase Messaging ID Service
In this section, we're going to implement the Firebase Messaging ID Service class so we have a way of sending cloud messages to specific users. In the previous section, we sent a message notification from the Firebase console using this GUI interface. When choosing who to send the message to, we selected User segment, and then selected all the application's users. Now we're going to work on a way to send messages to specific device instances, or in other words, to specific users. With Firebase cloud messaging, this is done by referencing a user's unique ID token. Don't confuse this with their user ID, they're two completely different things. Notice from the console that I can select an option here that says Single device, and now a field appears named FCM registration token. This is the token that I'm referring to. This is where you would enter a user's unique token if you only wanted to send them a notification. So how do I get this token, and how do you access it when you want to send a message? That's what we're going to set up right now. Open up Android, we're going to create another class in the utility package, name this one MyFirebaseInstanceIdService. We need to extend FirebaseInstantIdService. Add a log tag by typing logt, now get the override methods by pressing Ctrl+O on Windows, and Command+O on Mac. This time we just need the onTokenRefresh method. Notice it takes no input parameters. Here's how this method works. Every so often, I'm not sure of the exact timing or the triggers, a user's unique token will be refreshed and sent to their app instance. This onTokenRefresh method will capture the incoming token whether the app is in the background, foreground, or closed. That's why we need to implement it as a service. When this method is called, it's up to us as the developer to save it somewhere it can be accessed and referenced. We're going to be saving it in the Firebase database so we can query it when we need it. Before we write the code for that, let's add a service declaration to the manifest. Open up the manifest file, now just copy the service declaration from the message service, paste it below, change the name to reference the correct service, now change the action to com. google. firebase. INSTANCE_ID_EVENT. Now go back to MyFirebaseInstanceIdService; the first thing we want to do is actually get the token. The token is technically received by the onTokenRefresh method, as you can probably tell from the lack of input parameters. It's just a method that signifies a user's token has been refreshed by some magical process from Firebase. In other words, they've changed it, and now we need to update our records. So we'll start by writing String refreshedToken = FirebaseInstanceId. getInstance. getToken, and then log it for debugging. Now we need to build a method for sending the token to our Firebase database. We'll call it sendRegistrationToServer, and it will take the token as an input. So, private void sendRegistrationToServer(String_token). Log the token once again for debugging. Now we're ready to send it to our database. If you watched the course preceding this one: Firebase on Android: Real-time Database and Cloud Storage, you'll be very familiar with this process. First, we get our database reference by going DatabaseReference reference = FirebaseDatabase. getInstance. getReference. Now reference the node we want to insert it into. We're going to be saving the tokens to the user's node since they're unique to that particular user. So we'll go reference. child(getString(R. string. dbnode_users)). child(DirebaseAuth). getInstance(). getCurrentUser(). getUid(), then. child(getString(R. string. field_messaging_token)), and then finally set the value to the token, and that's it. That will send the token to our server. Now there's one last _____ refresh method will only be called seemingly randomly whenever Firebase decides to refresh the user's token. So if we ran the app right now, the token would not be inserted into the database. So it's a good idea to manually insert the token right when the user signs in. That way the token will definitely be there. Copy the sendRegistrationTokenToServer method, and open up SignedInActivity since that's the first activity that runs once a user has been successfully authenticated. Now write private void initFCM, and we'll take no parameters. Now get the token by going String token = FirebaseInstanceId. getInstance. getToken. Log the token for debugging, and call the sendRegistrationToServer method, and pass the token. Now we just need to call initFCM inside of onCreate, and we're done. Let's run the app and make sure the user's token is being inserted into the database. So the app is running and there's our token. Now let's send a test message to the specific user from the console. So, copy the token, open up the notification section of the Firebase console, click on NEW MESSAGE. We'll send some text for the message text, select Single device, paste in the token, and now press SEND. Cool. The message was received. So at this point, everything is working as we expect. In the next section, we're going to briefly review everything we've covered in this module.

Module Review
In this section, we're going to review everything we covered in the module. We started by talking about the different cloud messaging scenarios defined by the different application states. By application states, I mean whether your app is in the foreground, in other words, open and currently used; in the background, in other words, open and not being currently used; and closed, which means the app is closed. We talked about the data structure of the cloud messages, and how if it contains a notification payload, then the message won't be received by the onMessageReceived override method when the app is in the background or closed. We can work around this by removing the notification payload from the cloud messages so they only contain a data section. Then we can just build the notifications manually inside the Firebase messaging service class. That will give us way more flexibility in terms of customizing push notifications, and it will ensure all cloud messages are received by the onMessageReceived method no matter what the application state is. Once again, I just want to mention that we're going to be looking at this in great detail later on. This was just an introduction so you'll be familiar with the message structure. Next, we implemented the MyFirebaseMessagingService class. This is the class that all cloud messages will be routed through. Remember we added a service declaration of this class in the apps manifest file because it's a service and will run even if the app is closed; and finally, we implemented the MyFirebaseInstanceIdService. This class is responsible for refreshing the cloud messaging client tokens that are unique to each device instance. I don't think I mentioned it in this section, but the tokens are different for each device. The MyFirebaseInstanceIdService is responsible for keeping the user's unique messaging token up to date since Firebase will change them to retain authenticity. Similar to the MyFirebaseMessagingService class, we also added a service declaration to the app's manifest file, since the service will run in any app state; be it the foreground, the background, or closed. And one last thing to remember: we retrieved the client token and inserted it into the database in the onTokenRefresh method, and also inside an activity when the user first is authenticated. We saved the token in the database in the user's node. In the next module, we'll write the code required to send cloud messages from the Android client.

Sending Cloud Messages from the Android Client
Sending Cloud Messages from the Android Client
In this module, we're going to write the code required to send cloud messages from the Android client. For the duration of the module, we'll be working with the source code files in the directory: module_4\start\TabianConsulting. Make sure to update the source code files with your Google Services JSON file. If you try to use mine, the application won't be able to communicate with your Firebase server. This module is all about sending cloud messages to your apps users from the app itself. That means making HTTP post requests to the endpoint URL that Firebase cloud messaging provides. The URL endpoint I'm referring to is fcm. googleapis. com/fcm/send. To make the HTTP request, we'll be using an external library called Retrofit. The body of the messages will contain the data structure we talked about in the previous sections. It's going to look like this. The to parameters we will put the unique tokens that identify each user. We haven't talked about the headers yet, but here's the two that are required: Content-Type :application/json and Authorization and then your Server Key. The Server Key is unique to your Firebase project. You can get it from your Firebase console. If you're confused, don't worry, shortly we're going to be going over all of this in great detail. To send cloud messages from the application, we're going to build an admin console for the Tabian Consulting application. Let's take a look at it. Here's the admin console we'll be building. From the admin console, users with a security level of 10 can send cloud messages to the Tabian Consulting employees. The admin won't be able to send cloud messages directly to individual users, instead they'll be able to send messages to various departments of Tabian Consulting. The admin will also have the ability to create new departments and assign employees to departments. For example: the admin could create a department named Human Resources, then they could add a handful of employees to that department, then they could send a cloud message to that department. The cloud messages will be received by the onMessageReceived method, and produce a push notification that will appear in the employee's system tray. Keep in mind there's no way to assign a security level of 10 from the application. You have to do it manually by going to the Firebase database and typing in the security level. So, from the console, you go to the database, then expand the user's node, and change the security level of a user. In the next section, we'll retrieve a list of tokens for the employees in each department, and get the server key that identifies your Firebase project.

Retrieving the FCM Tokens and Server Key
In this section, we're going to retrieve the tokens for the employees in each department and get the server key that identifies your Firebase project. Open up Android Studio and navigate to the class named AdminActivity. There's a lot of code in this class. I debated back and forth over whether or not to talk about everything in here or just to talk about the code pertaining to cloud messaging. I've decided to only talk about the code related to cloud messaging, since that's the topic of the course. So I won't be talking about how the users are assigned to departments, how the departments are inserted into the database, or how the recycler view list is set up at the bottom of the activity. I want to stay on topic as much as possible. That being said, we're going to start off by retrieving the tokens for each user in the departments selected by the admin, and yes, I said departments, that's plural. The admin has the option to send messages to multiple departments at once. They can just click here, select a bunch of departments, type in a message, and press SEND. So we need to get the tokens for every user in those departments. Scroll down to the method named getDepartmentTokens. We start off by getting a database reference since we'll need to query the user's node to retrieve the tokens. Remember, the tokens are saved in each user's node under their user ID. Let's take a look. Each user is assigned a department. This data is inserted when the admin sets a user to a department. So we need to query it and find all the users in the departments selected by the admin, then retrieve the token. Back to Android Studio. So we'll use a foreach loop to iterate through each department. In the query we're use the orderByChild method accompanied by the. equalTo method, and then pass the department. If you've watched my Firebase on Android: Real-time Database and Storage course, you'll be very familiar with this process. Since that course is a prerequisite to this one, I'm not going to be talking about the queries in detail. I suggest checking out that course if you want a little extra help. This is going to retrieve a list of all the users who are assigned to that department. Since it retrieves a list, we need to loop through each user by calling getChildren on the dataSnapshot. Now we can extract the token and add it to our tokens list. Note that the data structure for the tokens list is a set. That's going to ensure that each token added to the list is unique. They should be unique anyway, but this is just a precaution. That way we know each user won't receive more than one message. Now that we have the tokens, we just need to get the server key. Then we'll have everything we need to send cloud messages. Open up your Firebase console, and I'll show you where to get the server key. You need to create a node and save the server key in a database so we can query it. You can't access it using any Firebase method calls. You'll have to insert it manually. Your server key is unique to your Firebase project and can be found in the project settings section. You can get to the project settings section by clicking on this gear icon, and then selecting Project settings. Now select the CLOUD MESSAGING tab. Here is where your server key will be. Copy it, and head back to the database. Insert a new node named server, just like I have here, add a single child, and call it server_key. Now paste in the server key. We're saving it to the database because it's not a good idea to save it in the Android client. Someone could decompile your code and find it. It's more secure to save it in the database and then just query it when you need it. Now that the server key is somewhere where you can get it, head back to Android Studio. Back in AdminActivity, search for the method named getServerKey. It's just below the onCreate method. This is where we query the database for the server key, and assign it to a global variable named mServerKey. Now we have everything we need to create cloud messages from the Android client. In the next section, we'll add the dependencies for the Retrofit library, and set up all the object classes required to make HTTP post requests.

Getting Started with Retrofit
In this section, we're going to add the dependencies for the Retrofit library. For those of you who aren't familiar with retrofit, it's an external library that makes it easier to do HTTP requests. It's my favorite library when it comes to doing this sort of thing because you can create Java object classes that represent models of the data that you're sending or retrieving. It's actually very similar to the way Firebase inserts and retrieves data from the database. Compared to other external libraries like Volley, it takes a little longer to set up, but you reap the benefits after the initial setup is done. The first step is getting the dependency. Head over to square. github. io/retrofit. Here is the official documentation for Retrofit. If you're curious and want to know what else it can do, I encourage you to read the docs, but for this course, I'm going to get straight to the point. Search the page for the word GRADLE, and it will bring you to where the dependency is. Copy it, and open Android Studio, navigate to the build. gradle app file, add a short heading: Retrofit, and paste in the dependency. We need to get one more dependency for Retrofit. As I mentioned earlier, to use this library, we can create custom Java object classes to model the data, but we need to tell Retrofit what type of data it's going to be. It could XML, it could be JSON, it could be Jackson, there's many different options. So, head back to the docs, scroll up a little bit until you can see the heading: Converters. We want the Gson converter. Don't let the name confuse you. Gson is just the name of a Java library for converting Java objects to JSON objects. Now add a short heading: Retrofit GSON converter, and paste in the dependency. Now press Sync. Whoops. Looks like we forgot to enter the version. Just match whatever version Retrofit has down here, and press Sync. Now we're ready to start building our Java object classes for Retrofit. But before we do that, we need to identify the data structure of the post request we'll be sending, and it's also a good idea to make sure everything is working before investing time setting up the object classes. So in the next section, we'll send some test cloud messages using the Google Chrome add-on named Postman.

Testing HTTP Requests with Postman
In this section, we're going to test the HTTP post request for sending cloud messages using the Google Chrome extension named Postman. If you don't know what Postman is, it's just a simple developer tool we can use to test various HTTP requests. If you don't have it, open up Google Chrome, and let's install it. Click on Apps in the top left-hand corner, now go to the Web Store, and search Postman. This is the one right here. After it's installed, open it up, and you should be seeing something like this. If this is your first time, then you won't see all these options over here. These are all my saved requests. To start off, we need an endpoint URL. The endpoint URL is the URL that you're sending the request to. You can find that in the cloud messaging section of the documentation. Head over to firebase. google. com/docs/cloud-messaging/android/device-group, and we'll find all the information we need. Search for Device Group HTTP POST Request on the page. Here is an exact example of what we're trying to do. We have the URL endpoint, the Content-Type, the Authorization, and our data payload. For those of you who are unfamiliar with HTTP requests, this is a URL endpoint. These are known as the headers, and here is the request body. Copy the URL and open up Postman. The next step is the headers. If we recall the Firebase documentation, the first one was Content- Type, and the value was application/json; and the second was Authorization, and the value was key=, then the server key. Remember to get the server key, we need to go to the Firebase console and copy the server key. Now go back to Postman, paste in the server key, remember to remove the quotation marks on either end. There we go. That's the headers out of the way. Now let's work on the body. Let's head back to the docs, I'm just going to copy this body since it's basically exactly what we're after, now go back to Postman. Notice that we can't click on the body tab. That's because we have our request type set to GET, but we're making a post request, so we need to change that up here. Now click on the body section, select raw, and select data type of JSON, and finally now we can paste in the body. So the to parameter here is going to be the unique cloud messaging token for each user. Remember that those are saved in the database. So let's go to the database, scroll down to the users node and copy the messaging_token parameter for a user. Now go back to Postman and paste in the token right here. The keys we'll define will be message and title. Remember these key value pairs can be anything you want them to be. There's no required format for these. I just used message and title since that just makes the most sense. I'll just type a message of this is my data message, and a title of This is my data title. We need to include one more field for identifying what type of message it is. This is for later when our Firebase messaging service class needs to differentiate between admin broadcast and the chatroom message notifications. So just write data_type: then data_type_admin_broadcast. So we're going to be simulating what it's going to be like to send an admin broadcast from the Android client, but we're using Postman. So that's it. We're ready to test. Open up Android Studio and make sure your device is connected, remember the MyFirebaseMessagingService class, we have the logs that will print out the data from the cloud message it receives. So when we press Send, we expect to see some kind of log output here. Let's press Send. Now if we look at the Android monitor, we see data showing in the log. That means our MyFirebaseMessagingService class is working exactly as intended. Now we have all the information we need to set up our Retrofit object classes. In the next section, we'll write all the code required to send cloud messaging post requests with Retrofit.

Sending a Cloud Message from the Android Client
In this section, we're going to send our first cloud message from the Android client. Let's start by creating the Java object classes that model the data. Create a new folder inside your models package, call it FCM for Firebase Cloud Messaging, now click on FCM and create a new class named Data. This is going to define the data portion for our cloud message payload. If you recall from our post requests with Postman, there was a title and a message. So we just need to write private String title, and private String message, but we're going to add one more parameter. It's going to be the data_type parameter. Data_type will be used for defining what type of notification we want to make later on. I'm not going to explain it in detail now, but we'll look at it in detail later on. Now press Alt+Insert on Windows, or Command+Insert on Mac, select constructor, and choose all the parameters. Now copy the constructor and paste it below, and remove everything to create an empty constructor. Now press Alt+Insert again and insert the getter and setter methods, and finally, insert the to string method. Now we're ready to build the next class. Right-click on the FCM package, and create another new class. We're going to call this one FirebaseCloudMessage. Inside FirebaseCloudMessage, we need to put the rest of the request parameters. The first of which is a string named to. So write private String to, and now we can add the data object. So write private Data data. Now insert the constructor, copy the constructor, delete the fields, insert the getter and setter fields, and finally, the to string method. If you were confused, I think now everything should be cleating up for you. Open up Postman and let's take a look. This is the exact data model of the request body we need to send. We have our FirebaseCloudMessage object with the data and to fields, and then we have our data object that contains the message, title, and data_type fields. Next we need to create an interface for sending the request. Right-click on the utility package and then the new class, FCM. Make sure to change it to an interface and not a Java class. Here is where we define the post request. It's simple. We just type @POST, then we need to write in the end of the URL. This is a requirement for Retrofit. I can't leave this empty. Then define a Call object, and reference the datatype we'll be retrieving from the request. A ResponseBody datatype is the generalized datatype. We don't really care what the request responds with as long as it's successful. Now define a name for the interface method; I'm just going to call it send. Think of this as a method, the same as any method you would define, and whatever you put in these brackets are the input parameters. The first input parameter is the headers. So we'll define a HeaderMap, which is just a collection of headers. So we go @HeaderMap, and then Map String, String, and then call it headers. Then define the body of the request by typing @body and referencing the object for the body. For us, that's just the FirebaseCloudMessage object that we just created, and just call it message. The name doesn't matter, it's just a placeholder. That's it for the interface. Now open up AdminActivity. To send the request, we'll create a method named sendMessageToDepartment, and it will just take two input parameters: the title and the message. Write a log for debugging. Now start by creating a Retrofit object by writing Retrofit retrofit = new Retrofit. Builder, then. baseurl and pass the endpoint URL. I've defined a global variable for this named BASE_URL. It's defined at the top here. Notice that I cut off the end of the URL. That's because Retrofit requires you to put something inside the post method of the interface we defined. If you don't remember, open up FCM, remember this portion right here. Retrofit does not allow this to be empty, so we have to put the last portion of the URL in here. Back to AdminActivity. Next, we need to tell Retrofit what kind of data we'll be converting to. Remember we made the Java object classes, and we want to convert it to JSON data for the request body. So we'll use the GSON converter. It says GSON because that's the name of the Java library that converts java objects to JSON. So we write. addConverterFactory, and then pass the GsonConverterFactory. create, and finally, we call. build. Next, we need to create our interface. So we write FCM fcmAPI = retrofit. create, and then reference the FCM. class. We're almost ready to make the request. We just need to attach the headers and the tokens we're sending the messages to. For the headers we'll create a HashMap, and we'll call it headers = new HashMap. Now do headers. put, and use the Content-Type header, and then application/json, then headers. put, and then the Authorization header, and then key= +mServerKey, and those are our two headers. So now for the tokens. We have saved the tokens in a set called mTokens. Because there's potentially a bunch of them, we'll need to iterate through the set and send a request to each token. So we'll write a foreach loop and go String token to mTokens. Then write a log for debugging, and we'll create our data object, so go Data data = new Data, then data. setMessage to the message, and data. setTitle to the title, data. setData_type to getString(R. string. data_type_admin_broadcast. Now create the FirebaseCloudMessage object, FirebaseCloudMessage firebaseCloudMessage = new FirebaseCloudMessage, then firebaseCloudMessage. setData to the data, and firebaseCloudMessage. setTo to the token. So that's all of our data. Now create a call object, so Call, and then pass ResponseBody, call it call = fcmAPI. send, and then pass the headers and pass the firebaseCloudMessage. Now, queue up the request by calling. enqueue on the call, write new Callback, and implement the interface. Inside the onResponse method, we'll want to write a log for debugging so we can see if there was anything wrong with the request, and in the onFailure method, we'll just write a log and print a toast letting the user know that there was an error. Now call the method after the user clicks the send button, and we're done. We're ready to test. Let's run it. Make sure to open the log so we can see the message that's coming in. So navigate to AdminActivity, I'll select the customer service department since that's the account of the user named Mitch, which is what's logged into this device, and type a title and a message, and press Send. Cool. There's the notification. In the next section, we'll briefly talk about the other ways that we could've sent the cloud message from the Android client.

Cloud Messaging with Topics and Device Groups
In the last section, we sent a cloud message by referencing the unique FCM token that each user has on their account instance. But that isn't the only way we could've done it. It was just the most suited way for our application. In this section, we're going to talk about sending cloud messages to topics and device groups. Head over to firebase. google. com/docs/cloud-messaging/android/topic- messaging, and let's explore some other ways we could've sent cloud messages. Sending cloud messages using tokens is best suited for situations when there are under 1000 users that will be receiving the notification. Sending cloud messages using topics is better for situations when you have higher number of users. It's very similar, but there are a few differences. The biggest difference is users have to subscribe to a topic from their Firebase instance. So as an admin or any other user, you can't subscribe anyone else to a topic, they have to do it themselves. Other than that, when you send a request, all you have to do is change the to parameter, and make it reference the topic. If we scroll down, you can see an example, but it's actually easier than that. I'll show you what we'd have to change in our code. Don't copy what I'm doing, just watch. First, we need to subscribe to a topic. So I'll open up SignedInActivity, and inside the onCreate method, I'll write FirebaseMessaging. getInstance. subscribeToTopic, and just write TEST_TOPIC. This can be any string you choose. So now the user instance will be subscribed to the topic called TEST_TOPIC. Now I'll head back to AdminActivity. The only thing I need to change here is the to parameter. Down here where we assigned the to parameter, just write /topics/TEST_TOPIC. We don't need any tokens, so we can just comment out this for loop. That's it. Now this request will get sent to all the users who have subscribed to the topic called TEST_TOPIC. I'll run it, and let's test it. Navigate to AdminActivity, notice I'm not even selecting a department because I don't need to. The request is getting sent to the topic regardless. There's the notification. So as you can see, literally everything is the same as a token method, except the user needs to subscribe to a topic and the request needs to be altered very slightly. Overall, it's pretty simple though, and just to reiterate, we didn't use this method to send notifications to departments because the user has to subscribe on their device. There's no way for another user or an admin to manually subscribe users. So it doesn't really fit the needs of our application, but I wanted to make sure I showed you it anyway. Now let's talk about one more method for sending cloud messages. This way is quite different than what we've done so far, so I won't be able to demonstrate, but I'll talk about it briefly so you get an idea of what it's about. Head over to firebase. google. com/docs/cloud-messaging/android/device-group. As you probably guessed, this is outlining how to send cloud messages to device groups. What defines a device group you ask? Typically a device group refers to a bunch of devices that are all owned by a single user. This method of sending notifications was created because when you send notifications via the token method, the message will only be sent to the last device these were logged into on their account. To get started, you need to create a device group. You can create one by sending an HTTP request fitting this format. The request needs to contain a name and a list with all the unique registration tokens for that user. The sender ID is a parameter you get from the cloud messaging tab of your Firebase console. The response of the request will return a notification key. This key is what you'll use to send the cloud messages to this device group. After completing the rest of the setup process, you'll be able to send messages using this HTTP post format. You use the exact same URL and headers as we use when sending the messages via the token method, then you just change the to parameter to the notification key I just mentioned. That's it. In the next section, we'll do a brief review of everything we covered in this module.

Module Review
In this section, we're going to review everything covered in the module. We started the module by talking about the data structure of the HTTP post request required to send cloud messages from the Android client. Here's a structure of the request. We have the endpoint URL, our headers, and the body of the request. The server key is unique to your Firebase project, and you can get it from the project settings section of your Firebase console. The user FCM token is a unique token that identifies each user's device. The token is how Firebase cloud messaging is able to send notifications to individual devices. If you recall from the previous module, we saved the tokens in the Firebase database for easy access. This is also where we save the server key. We save the server key in the database because it's not a good idea to store it as a variable on the Android client. Your code could get decompiled and someone could get your server key. After we retrieved the tokens and the server key from the database, we began setting up Retrofit. Retrofit is an external Android library designed for making HTTP requests. I prefer using Retrofit over other libraries such as Volley because you can build custom Java object classes and convert them to whatever data format you need for your request. Retrofit has converters for JSON, XML, JACKSON, and many others. There's a bit of initial setup involved, but it pays dividends later on. Before building our Java object classes to model the request format, we tested the HTTP post request using a Google Chrome add-on named Postman. Postman is used to mimic exactly what our request will look like so we can, number one, test the request and make sure it's working, and number two, get an idea of what exactly the data structure needs to look like. To send the request with Postman, we first select POST as a request method, then we enter an endpoint URL, which in our case was fcm. googleapis. com/fcm/send, and then we enter our headers, and then finally, the body. We can get a token from the database for one of our users and then press Send. Currently we don't have any methods that build a notification, but we can still tell it's working by looking at the Android monitor and making sure the data was received in the onMessageReceived method of our Firebase messaging service class. We can see the data from the message, so we know everything's working. Next, we built the object classes for modeling the JSON request. Basically, we just matched the fields of the request. We started by creating a data class with the fields title, and message, and data_type. Title and message are pretty self- explanatory, the data_type field we'll take a closer look at in the next module. The next class was named FirebaseCloudMessage, and it contained two fields. The to field, which is just a string, and then a data field, which contained our data object class that we just built. Once we had the models ready to go, we began building the request with Retrofit. This process was pretty straightforward. We define the Retrofit object, we declare the interface, we attach headers, iterate through the list of tokens, instantiate the request objects, create a call object, and then finally we queue up the call. After that, we tested the process with a real demo, and confirmed the data was appearing in the log. In the next module, we'll write the code required to actually create notifications from the MyFirebaseMessagingService class.

Constructing Push Notifications
Introduction
In this module, we're going to write the code required to actually create notifications from the MyFirebaseMessagingService class. For the duration of the module, we'll be working with the source code files in the directory: module_5\start\TabianConsulting. Make sure to update the source code files with your Google Services JSON file. If you try to use mine, the application won't be able to communicate with your Firebase server. Let's start with an overview of what we're trying to accomplish here. We need to define two different scenarios for displaying notifications in the system tray. The first scenario is if an admin broadcast is sent. In this scenario, we want the notification to display no matter what state the app is in - be it the foreground, the background, or closed. The second scenario is if new chatroom messages are posted and the user currently isn't viewing the chatroom. In that case, we want notifications to only be sent if the app is in the background or closed, not if it's in the foreground. The structure of the chatroom notifications will be as follows: The Tabian Consulting icon will show here, the Tabian Consulting name will show here, the chatroom name will show here, the user who sent the most recent message will show here, and also what it said, and the number of messages that have been posted to the chatroom since the last time the user saw will show here. The structure of the broadcast notifications will be as follows: the Tabian Consulting icon will be displayed, the title of the broadcast, and the message of the broadcast. We don't want the notifications to be annoying, so we'll only make a noise if there's no pending notifications. Each new message sent to the chatroom will replace the previous notification so the user system tray won't get spammed, and if it was a chat room notification, when the user clicks the notification, the app will open to the chatroom that the message was posted from. If it's a broadcast notification, then it will just open the app. We'll start by building notifications in the MyFirebaseMessagingService class. To discriminate between the two different scenarios, we'll attach a key value pair to the message request. It's going to be that data_type field that I mentioned in the previous sections. It will either have a value of data_type_admin_broadcast, or a value of data_type_chat_message. We can test the notifications using Postman before moving onto the next section and building the cloud function. Testing things before moving onto the next stage of development is always the best way to do it. So in the next section, we'll write the code required to build notifications in the MyFirebaseMessagingService class.

Determining the Application State
In this module, we're going to determine the application state when a cloud message is received by the MyFirebaseCloudMessagingService class. Because we have different criteria for our notifications that are dependent on if the app is in the foreground, in the background, or closed, first we need to write the methods to figure that out. At first glance, it might seem as though we have three different scenarios, but in actuality, we only have two. The broadcast messages are sent no matter what state the app is in, so that doesn't matter. With the chatroom messages, we only have a single criteria. There needs to be no messages sent when the app is in the foreground. That's all we need to figure out. So to figure out if the app is in the foreground, we'll build a method named isApplicationInForeground. If the app is not in the foreground, then we just check for our data_type field and build the respective notification. Open up MyFirebaseMessagingService, and scroll down to the method named isApplicationInForeground. In each activity, I've created a public static boolean named IsActivityRunning. In the onStart method, the boolean is assigned to a value of true, and in the onDestroy method, the boolean is assigned a value of false. So all this method does is check all the static variables and look for any one of them that's true. If even a single one is true, that means the activity is running, and therefore the application is in the foreground. The method returns true if the application is running, and false if it isn't. Pretty simple stuff. Now that we have a way to determine the application state, we can move onto the next section, and build a notification for an admin broadcast.

Building an Admin Broadcast Notification
In this module, we're going to build the notification for when the admin sends a broadcast cloud message. All cloud messages are received through the onMessageReceived override method. So, that's where we can write the logic to handle the different cloud messaging scenarios. The first thing we need to do is initialize the ImageLoader. We need to do this because if the user opens the app using the notification, this is the first code that will execute, and if you recall from the universal image loader setup procedure, the image loader must be initialized before use, otherwise, the app will crash. Next, we have the logic for checking if the application is in the foreground or the background. Here's the two scenarios. If the application is in the foreground, we only want to create a notification if it's an admin broadcast. If the application is in the background or closed, as denoted by this if statement, then we have two possibilities: it can either be a broadcast message, or it can be a chatroom message. We'll look at the code for the case when the application is in the foreground first. So we need to get the data from the message by using remoteMessage. getData, and then get the value of the data_type field. If the value of the data_type field represents an admin broadcast, then we can build a notification. The method that will actually build the notification is called sendBroadcastNotification. The if statement down here contains the exact same code. Remember, this is the case when the application is in the background or closed, but the data_type is an admin broadcast. So let's build the notification. Start by getting the title by writing remoteMessage. getData. get(getString(R. string. data_title. Then get the message by writing remoteMessage. getData. get, then getString(R. string. data_message, and finally, send the title and the message to the sendBroadcastNotification method. The if statement down here contains the exact same code. Now let's take a look at the sendBroadcastNotification method. All notifications follow a similar structure. You start by defining a pending intent. This intent will start when the user clicks the notification. This notification is simple. We just want the app to open to SignedInActivity. Next, we actually build the notification. We use NotificationCompat. Builder, and declare a new notification builder. In the builder, we just need to specify the context and reference the channel ID. All notifications in this course are just going to use a default channel ID. If you want more information on channel IDs, check out the official Android developer documentation at developer. android. com. Now we're ready to set some properties to the notification. First, we set the large and small icons, then set the color to match the Tabian Consulting theme, set the title of the message, set the body of the message, set AutoCancel true, which makes the notification dismiss when the user touches it, set the sound, and then attach the pending intent. Now we create a notification manager object and add the notification by calling. notify. Notice the first parameter I'm passing to the notify method. This is the ID for the type of notification I'm sending. It's a global variable that I've defined above that's telling the notification manager that this is an admin broadcast notification. This is important because we want new broadcast notifications to replace the old ones in the system tray. If the IDs aren't the same, then the notifications will just pile up in the system tray. That's it for building an admin broadcast notification. Run it, and let's test it using Postman, and then test it using the app. Notice the keys I'm using here. We have title, message, and data_type. The data_type is specifying an admin broadcast type. Now let's press Send. Great, so that worked. Now let's try it with the app in the background. There we go. Everything's working as expected. Now we'll test it using the app. Navigate to AdminActivity, I'll just select the department of this device's user. I'll give it a title of hi, and a message saying yo. Cool. Everything is working as we expect. In the next section, we'll write the code required to build notifications when users add new chatroom messages.

Building a Chatroom Message Notification
In this section, we'll take a look at the code required to build push notifications for new chatroom messages. We don't actually have a way to initiate the creation of a chatroom cloud message yet, but we can still write the code for the notification, and test it using Postman. That way in the next module, we can focus on building and deploying the cloud function for that task. We're back inside MyFirebaseMessagingService, in the onMessageReceived method, we're ready to build the second type of notification. The code starts off by checking the data_type parameter and confirming that the message is a chat message. Before we can build the notification, we need to figure out how many chat messages have been posted since the last time the user viewed the chatroom. Unfortunately, there's no easy way to do this, so I'll explain what we're going to do. Open your Firebase console and navigate to the database. Every time a user enters a chatroom, there's a record saved in the chatroom's unique node. You can see the records here. Having a running total will give us the ability to determine the total number of messages the user has seen. Then we can compare it with the number of messages currently in the chatroom, and calculate the difference. So whenever a user enters a chatroom, the client will sum the total amount of messages currently in the chatroom and input them right here. Let's head back to Android Studio, and into MyFirebaseMessagingService. To start off, we get three parameters. The title, the message, and the chatroomId; and yes, that means the data structure for the chatroom cloud message is going to be slightly different than the broadcast ones. The chatroom cloud message body will contain a fourth field: the chatroomId. We need the chatroomId because we need to get the details for the chatroom that the message was posted in. Remember in our notification criteria, this notification will show the chatroom name, the last message that was posted, and the number of messages that have been posted since the last time the user viewed the chatroom. Now we need to query the database and get some details about the chatroom that the message has been posted in. If you've seen my Firebase Database course on Pluralsight, then this will be very familiar to you. We reference the chatroomId and use the addListenerForSingleValueEvent method to get the data snapshot. Now in the onDataChange method, we can create the chatroom object and assign the fields from the database. But we're not ready to build the notification quite yet. We still need to get the number of messages the user has missed. To get the total number of messages that the user has seen, we can do Interger. parseInt data snapshot. child(getString(R. String. field_users to reference the user's field in the database. Then. child(FirebaseAuth. getInstance. getCurrentUser. getUid to then go inside of the child containing their user ID, and then. child(getString(R. string. field_Last_message_seen to get into the field of the last message seen by the user, and then we just call getValue and toString. Now we need to get the total number of messages in the chatroom. We can do this by writing integer data snapshot. child(getString(R. string. field_chatroom_messages and then get the children count. Now subtract the two and save it to a global variable named mNumPendingMessages. That's it. We have everything we need to build the notification. The notification is constructed in the method named sendChatmessageNotification. Let's take a look at it. The first thing we need to do is get the ID for the notification. We want each notification to be unique to the chatroom that it came from. So it makes sense to use a chatroomId for this since they're already unique. Notification IDs need to be integers so the method buildNotificationId takes the chatroomId and turns the first six characters into an integer. The integer is returned and assigned to this variable called ID. Next, we build the pendingIntent. This pendingIntent is a little different than the one from sendBroadcastNotification because there's a string extra attached named intentChatroom. This string extra will be retrieved and read by SignedInActivity. Once read, another intent will start and navigate to the chatroom the message was sent from. Let's take a quick look at SignedInActivity. Scroll down to the getPendingIntent method. In this method, we look for the intent extra that's attached to the MyFirebaseMessagingService. If it's found, we navigate to the chatroom the message was sent from. Let's head back to MyFirebaseMessagingService. You're probably wondering why we set the pendingIntent to SignedInActivity if it's just going to send the user to the chatroom that the message was sent from anyway. If we set the pendingIntent to chatroomActivity, it would be the only activity in the activity stack. So if the user clicked on notification, then navigated to the chatroom, and then pressed the back button on the phone, the app would close. That's obviously not a good user experience. So instead, we set the pendingIntent to SignedInActivity, which then navigates the user to the chatroom. That way, if they press the back button, the app won't close, they'll just get sent to SignedInActivity. We're ready to build the notification. Just like with the broadcast notification, we start by creating the notification builder object and setting the channel ID. Once again, I'm just setting a default channel ID, so it's the same for all notifications. The notification is mostly the same as the one for the broadcast, there's only a few small differences. The first difference is this setSubText method. The subtext will only show when the notification is in a squished state. So if I was to send an email right now to myself, like this, I would get a notification and it would squish the other notifications. The subtext is right here at the bottom. The second difference you'll notice is this setStyle method. These two fields are the only ones the setStyle method displays. Basically, setStyle is for displaying the non-squished state, and the setSubtext is for displaying the squished state. So it also makes that line separating the big text and the summary text. Now we setAutoCancel to true, so the notification goes away when the user clicks it. Set the pendingIntent, and use setNumber to set the number of messages the user has seen. Now there's one more thing that's different about this notification. To make sure the user doesn't get spammed with noises with from the notifications, we need to use the method: setOnlyAlertOnce to true. This will inhibit the noise and vibration if there's already a notification showing. That's it. That's all there is to it. We just need to get our NotificationManager object and call. notify, and then pass the notificationId and the notificationBuilder. Let's test it using Postman. We'll need to change the request body a bit. First, we need to change the data_type to data_type_chat_message, and we need to add the chatroom_id key value pair. So I'll go to the Firebase console and copy the chatroom_id. Now open Postman and paste in the ID. We should have everything we need now to test the cloud message. Make sure your application is either closed or in the background. Also ensure this token is up to date. As I mentioned in earlier sections, Firebase will refresh them seemingly randomly. Confirm it's correct by viewing it in the user's node. Let's send the request. Cool. The notification is visible almost immediately. So at this point, everything seems to be working as we expect. With the hard parts behind us, all that's left is to build and deploy a Firebase cloud function that sends cloud messages automatically. But before we move onto the next section, let's spend some time reviewing what we've covered in this module.

Module Review
In this section, we're going to briefly review everything covered in the module. First, we talked about the two different scenarios we'll run into when sending cloud messages. Number one is sending cloud messages via an admin broadcast, and number two is sending cloud messages when new messages are posted to a chatroom, and a user is currently not using the app. The two different scenarios will have different request bodies and different notification layouts. Here is the request body for the admin notifications, and also what the layout will look like. The body will have a token that references a user we want to send the notification to, and three key value pairs representing the title of the message, the actual message text, and then the data_type which defines it as an admin broadcast. And remember, the headers will be Content-Type:application/json, and authorization with your server key, and here is the request body for the chat messages and what the notifications will look like. Everything is the same here except the data_type tells us that it's a chatroom message instead of an admin broadcast, and then there's a fourth parameter that references the chatroom ID. Next, we needed to determine the application state because the conditions are different depending on if the app is in the foreground, the background, or closed. If we're sending an admin broadcast, then the application state doesn't matter because the cloud messages are identical in each situation. But if the cloud message is triggered by a chatroom message, then we only want to send the notification if the app is in the background or closed. To determine the application state, we built a method named isApplicationInForeground. IsApplicationInForeground checks for the presence of a static variable that exists in each activity class. If it's true, then we know the user is looking at an activity, and therefore the app is in the foreground. After determining the application state, we're ready to write the code for building notifications. Here's the general outline of the logic. So if the application is in the foreground, check to make sure the cloud message is of the admin broadcast type, then create the corresponding notification. If the application is in the background, it can either ben an admin broadcast, or it could be a chatroom message. So we check to see which one it is, and then we make the corresponding notification. Here's a diagram outlining the entire process. First, an incoming cloud message is received by the onMessageReceived method, next, we check to see if the application is in the foreground. If it is, we only care if it's an admin broadcast. So, we check for the admin broadcast data_type, and then we build the notification. If the application is not in the foreground, then there's two scenarios. If the data_type is a broadcast message or if the data_type is a chat message. That's all there is to it. That handles every scenario we need to watch out for when building the notifications. In the next section, we'll build and deploy a Firebase cloud function that will automatically send cloud messages to users when they miss messages posted to chatrooms.

Sending Cloud Messages Using a Cloud Function
Introduction
In this module, we're going to build and deploy a Firebase cloud function that sends cloud messages automatically from the Firebase server. For the duration of the module, we'll be working with the source code files in the directory: Module_6\start\TabianConsulting. Make sure to update the source code files with your Google Services JSON file. If you try to use mine, the application won't be able to communicate with your Firebase server. If you ask me, Firebase cloud functions are the future of mobile development, and here's why. Firebase cloud functions can operate with no server. That means you don't need a domain or do any initial setup outside of creating a Firebase project. You can build functions that basically do anything you could do using a traditional server function. You can interact with other servers, this can be done by sending HTTP requests, and of course, you can seamlessly interact with any of the other Firebase tools. Some of the other ways you can interact with the other Firebase tools are Cloud Firestore triggers. An example of this could be someone writing to Firestore or uploading a document. The document upload could trigger a Firebase function, which could then execute some action, such as notifying employees a document has been uploaded. Real-time Database triggers. This is essentially what we're doing in this course. When a message is added to a chatroom, the cloud message is triggered, then it queries the database for all users who have joined the chatroom, and sends a cloud message to each one of them. Authentication triggers. A good example of this would be a function that's triggered when a new user registers. The function would activate and then send a notification or an email to the new user. I think you get the idea. You write a function that triggers because of some event, then the function executes the action you designate. All cloud functions are written in the programming language: Node. js, so we'll need to install that before we can start. Node. js is a runtime environment built on a JavaScript engine, making it very similar to JavaScript with some subtle differences. If you have any experience with JavaScript, then you'll be very comfortable with Node. js, but even if you don't, I'll guide you through everything so that you'll have no problems. Here's an overview of what we'll be doing in this module. First, we'll install everything required to build and deploy cloud functions on your local machine. That means first installing Node. js, and then installing the Firebase Command Line Interface, otherwise known as the Firebase CLI, so we can use the Firebase tools locally. Then we'll enable the use of Firebase cloud functions in our Android project using the Firebase CLI. We'll use Node. js for the installation. Next, we'll actually code the cloud function using a program called Notepad++. Any text editor will work for this, and finally, we'll deploy the cloud function to the Firebase server, therefore rendering it active. In the next section, we'll get started installing everything we need to build and deploy Firebase cloud functions.

Installing Node.js and the Firebase CLI
In this section, we're going to install Node. js on our local machine, and then we're going to use it to install the Firebase Command Line Interface. To get the latest version of Node. js, head over to nodejs. org/download. Click on the LTS heading that says Recommended for Most Users, and select the download for whatever system you have. I've already uninstalled, so I'm not going to go through this process, but just follow the instructions on the installation wizard. Keep in mind this installation will automatically add Node. js to your system variables path, so you won't have to do that. Once Node. js is installed, open a new command prompt and type npm to make sure everything was installed correctly. You should see something that looks like this. If you get a message saying npm is not recognized as an internal or external command, operate program or batch file; then you know something is wrong with the installation. Go back and make sure you downloaded the correct version for your computer system. Now we're ready to install the Firebase Command Line Interface. The Firebase Command Line Interface will allow us to interact with our Firebase projects from our local machine without using an internet browser. Type npm install -g firebase tools. In case you were wondering, it doesn't matter what directory we're in right now. Now log into your Firebase account by typing firebase login. If you're already logged into your console from a browser, then you'll see a message like what's showing on my screen. It's letting me know that I'm already logged in. Now, everything is installed that's needed to get started building cloud functions. In the next section, we'll enable the use of cloud functions in our Android project.

Enabling Cloud Functions
In this section, we're going to enable the use of cloud functions in our Android project. Start by navigating to the directory where your Android project is saved. For me, that's F: AndroidStudio Projects, Pluralsight, TabianConsulting. Inside the Tabian Consulting directory, open a new command prompt. On Windows, you can do this by holding Ctrl+Shift, right-clicking, and then selecting Open command window here. Alternatively, you can just open command prompt from anywhere, and then navigate to that directory. Now type firebase init functions. It will ask you if you're ready to proceed. Type y and then press Enter. In this step, it asks you to choose the Firebase project that's associated with this Android project. So I'll use the arrow keys and find our project, there it is right there, now press Enter. That will generate the configuration files required to communicate with your Firebase project. Now we need to install the Node. js packages required to write the functions. Type y and press Enter, the packages will be saved in this folder named functions. This will likely take a few minutes, so I'll fast-forward the video. When it's done, there'll be a new folder named functions, a. firebaserc file, and a firebase. json file in your project directory. The. firebaserc file and the JSON file are configuration files and inside the functions folder is where we'll find our Node. js packages. Also inside the functions folder is where we're going to be writing our cloud function. Now the only thing left to do is actually write the cloud function and deploy to the Firebase server.

Building and Deploying the Cloud Function
In this section, we're going to build and deploy our cloud function for sending cloud messages. Let's start by outlining the criteria for the function that we're building. The first criteria is that the cloud function needs to be triggered when a user writes a message to a chatroom. So if a user said hey, then other users in the chatroom would see that message as a push notification. The second criteria. In order to send cloud messages, the function needs to retrieve a list of tokens. The tokens are saved in the main users node in the database. To query the tokens, we need the ID of each user who's joined the chatroom. If you recall our database structure, there's a node inside each chatroom that contains a list of users who have joined. Each user node contains their user ID as the key, and a field containing the total number of messages that they've seen. So basically the function needs to get the user IDs from the node, and then use the ID to query the main user's node and retrieve the tokens. The third criteria. We need to retrieve the last message posted to the chatroom, and also the user's name who posted that message. That's going to be displayed right here in the push notification. That's all the criteria. Let's build it. Open up the index. js file that's located inside the functions directory of your Android project. I'm going to be editing the file using Notepad++, but you can use any text editor you want. I'm going to delete these nodes, but feel free to leave them if you like. To start off, we need to declare a variable named admin that will require the Firebase admin package. This will give us access to some methods we'll be using, such as referencing the database. So we'll just write let admin = require('firebase-admin'). Now initialize the app file by getting the configuration properties for our project. We just write admin. initializeApp(functions. config and then. firebase. Now we're ready to build our function. To build a cloud function, we start off with the keyword: exports. That lets the interpreter know we're about to declare a new function for export to the Firebase server. So let's write exports and then whatever we want to name the function. I'll name it sendNotification. Then write = functions. database. ref, and here's where we reference the database path that we want it to look at. But there's a problem. How do we reference the path of a chatroom if every chatroom has a different ID? Remember the hierarchy goes like this. Chatrooms/chatroomId/chatroom_messages/messageId, and then message. So we need a way to reference a variable chatroomId, and then a variable chatroomMessageId. That's actually pretty easy. We can just write chatrooms/ squiqqly bracket chatroomId close squiqqly bracket, then chatroom_messages, and then squiggly bracket chatmessageId, and then close squiggly bracket. By including these squiggly brackets, we're telling the function that this is a variable parameter. So no matter what it is, it will still look into that node. Now we define our trigger by typing onWrite event, and then arrow, and then close it. That defines our function as one that listens to any data written to the node we specified. So everything inside this function is what will be executed when a new message is written to a chatroom. So the first thing we need to do is get the message. To do that, we just reference the event. You can think of the event as essentially the same thing as a data snapshot. It's a picture of the database at the moment when the message is written. To get the message, we just write let message = event. data. child, and then reference the name of the field, which is message, then call. val to get the value. Next, we'll get the user ID of the user who wrote the message. This is very similar. We just write let messageUserId = event. data. child, then reference UserId, and then. val; and lastly, we need to get the chatroomId. This is going to be a little different. We just write let chatroomId = event. params. chatroomId. The reason we're able to write params, then chatroomId is because this is one of the variable names from the database reference up here. When you use variables like this in a reference, you can retrieve their value like this. Using event. params tells the function that you're talking about the reference URL. Then you can tell is what part of the reference URL you're talking about by writing. and then the name you gave it. I named the variable chatroomId, so we can just write. chatroomId. It's always a good idea to write to the logs for debugging. To write to the log, we just go console. log, then message:, message: console. log user_id:, messageUserId: console. log chatroom_id:, chatroomId. Now we can use this information to get the next values we need, which is the tokens. To get the tokens, we need to query the database again and look in a different node. To do that, we just write return event. data. ref. parent. parent. once, then the keyword value. then snap arrow and then close it. Now that probably seems confusing, so let's walk through it. We want to look in the users node contained in the chatroom, so we use return event. data. ref. parent. parent to move up the hierarchy to get there. Take a look at this image. So we're going from this node to this node. Also note that all functions need to start with the return because the sendNotification function as a whole expects a return value. Basically as a rule, just start every new query with return. If you don't, the function will still work, but there will be errors in your log. The variable snap is essentially a data snapshot of the query. Now let's get the contents of the user's node. To do that, we just write let data - snap. child users, and then. val, and then write a log for debugging. Now we want to count the number of users who are part of the chatroom. We'll just use a for loop and increment a new variable named length. So let length = 0, then for(value in data) length++, and log the length. Note that all we need to do to get the user IDs is iterate through each position in data. Remember, data is essentially a data snapshot, so we can iterate through its results just as we do using Java code by calling dataSnapshot. getChildren. So, we just write for(var user_id in data), and that will loop through the entire data snapshot, and that will give us access to each user_id in the user's node of the chatroom. The goal of this loop is to use each user_id to query the main users node, and then retrieve the tokens. So above the for loop, create two new variables: let tokens = empty array, and then let i = 0. Tokens will be the array of tokens, and i is what we'll use to break the loop once we get through every user. I'm going to go a little faster here since now we're doing the same sort of thing over again. First, log the user_id we're looking at, then create a database reference using admin. database. Remember, I mentioned at the beginning of the video, we'd be using admin to reference the database. Then. ref and reference the users node, and then user_id in question. Then make the query once again using. once ('value'). then(snap), and then get the token, so let token = snap. child('messaging_token'). val. Log the token, add the token to the tokens array by writing tokens. push(token), and then lastly, increment i. Now we just need one last thing: the user's name who posted the message. To get that, it's actually quite easy. We're already inside the users node, so we just have to look for the user_id of the user who posted the message, and then retrieve that name. So let messageUserName = blank, then if(snap. child(user_id) = messageUserId, then we know we have a match. So, messageUserName =snap. child(name), and log it, then alter the message to include that name. So messageUserName + : + message. That will get everything we need. We just need a break the loop when it's done and create the cloud messages, and that's what i is for. So we can write if(I = length), then we know we've iterated through each user of the chatroom. Start by writing to the log that we're ready to build the notification, now to build the cloud message we start by declaring a payload. This is essentially going to be the body of the message. So go constant. payload =, and then data. Then inside data we can put all of our key value pairs. So we have data_type, data_type_chat_message, title is Tabian Consulting, message is our message, and then chatroom_id is the chatroomId. You'll notice that there's no need to attach headers to our request since it's being sent from the Firebase servers already. It doesn't need to specify authorization; and finally now let's send the message. So return admin. messaging(). sendToDevice, pass the tokens and then pass our payload. Then check for a response by writing. then(function(response) console. log('successfully send message', and the response, and then catch an error and console. log that error. Well, that took way longer than I expected to walk through. Hopefully I managed to maintain your attention and you understand what we just did. Before we proceed, I found a couple spelling mistakes we need to fix. Go up to the top, this should say require, not requre. Now go to line seven, functions is spelled incorrectly. Now go to line 63, and add a semicolon after the payload. This is kind of the only thing that sucks about building cloud functions in Notepad++, there's no way to find errors until you actually deploy to Firebase and it fails. Anyway, let's move on. Now that it's built, we need to deploy it to Firebase and test it out. So first save the file, open a command prompt, and navigate to the directory the project is in. Now write firebase deploy --only functions. This will begin the deployment process. Be patient because this could take up to five minutes or even longer sometimes. This is one last thing that I dislike about cloud functions, because if you have a typo or a bug, you have to wait at least five minutes to find it, and then repeat the process. I'll fast-forward the video to when the deployment is complete. Great. No errors on my end. If you get any errors, just copy my index. js file from the source code files. It'll save you a lot of time looking for spelling mistakes. Open up your Firebase console and let's test it. We can view the log outputs for the cloud functions by navigating to the cloud function section right here. Here you can see our function. Notice the name is sendNotification. It also tells you that it's a write function and the node it's listening to. Click the LOGS tab. This is where all the log outputs from the function will be written. Note that you should have no log outputs yet. I only have logs from testing. Let's test. Here I have two devices logged into two different accounts. I'm going to join the same chatroom on both devices. I'll quickly write a message from each user just to say hello and make sure everything's working. Notice we didn't receive any push notifications because the app is in the foreground. So I'll move the app to the background on one device, and now send another chat message. It can take a few seconds to receive the notification. There it is. Now if we click it, it opens right back to the chatroom. Now I'll close the app this time and test again. There's the notification. Great. So everything is working as we expected. In the next section, we're going to review everything covered in this module.

Module Review
In this section, we're going to review everything we covered in the module. We began by installing everything we need to deploy Firebase cloud functions. The first thing we needed is Node. js installed on our local machine. After getting Node. js installed, we installed the Firebase Command Line interface, otherwise known as the Firebase CLI. The Firebase CLI gives us the ability to interact with our Firebase projects from our local machine. You install the Firebase CLI by opening up a command prompt and typing npm install -g firebase tools. Once the Firebase CLI has been installed, we navigate to the local directory where our Android project is saved, and opened a new command prompt. From here, we can initialize the use of Firebase cloud functions by writing firebase init functions. Then we chose the Firebase project that's associated with this Android project. WE followed the instructions to begin the initialization. Once installed, there will be a folder named functions and two new files in your Android directory called firebase. json and. firebaserc. Inside the functions folder, there's a file named index. js. That's where we wrote our cloud function. Let's do a quick overview of the function. We start by referencing the node we want the function to watch. We can specify the type of trigger by calling. onWrite to the database reference. After the cloud function is triggered, we needed to retrieve a list of users who have joined the chatroom. We can do that by writing return event. data. ref. parent. parent. once('value'). then, and then getting the data snapshot. This will return a snapshot of the users node contained within the chatrooms node. Next, we needed to get the tokens associated with each user who's part of the chatroom. Similar to the previous query, we can write let reference = admin. database(). ref, then reference the users node and the user_id, then reference. once('value'). then, then get the data snapshot. Now we get the token by writing let token = snap. child('messaging_token'). val. Then we logged the token and added the token to our tokens array, and finally, once all the tokens have been added to the tokens array, we create a data payload and send the cloud messages. The data payload contains a data parameter and then inside the data parameter is our data_type variable, our title variable, our message, and our chatroomId. Then to actually send the cloud message, we just write return admin. messaging(). sendToDevice, then pass the tokens and the payload. Then we handle the response, and we handle a possible error. Now that the cloud function is built, we can deploy it to the Firebase server by writing firebase deploy --only functions in the command prompt. Remember, it takes 5-10 minutes to deploy, so be patient. Once the function is deployed, we can view the function from the functions section of your Firebase console, and view the logs by clicking on the LOGS tab. Then we tested the notifications to see if it was working exactly as intended by viewing the logs from the Firebase console. That's it for Firebase cloud functions. In the next section, we'll get started with a very underrated developer tool: Firebase Crashlytics.

Implementing Firebase Crashlytics
Introduction
In this module, we're going to install everything we need to get started with Firebase Crashlytics. There isn't much code involved in this section, so I didn't include any source code files. I suggest just following along with me. When I originally planned this course, I was going to make this section about Firebase crash reporting. But as of approximately November 1, 2017, Firebase crash reporting is basically deprecated in place of Firebase Crashlytics. Keep in mind this course is only intended to provide a very basic introduction of crashlytics. However, even at the most basic level, it's still incredibly useful and will save you a ton of time debugging production apps or even debugging your personal projects. Regarding debugging production apps, I'm sure you know that acquiring useful information about issues and bugs can prove very difficult. If you talk to app users about the problems they're experiencing, the information they provide is often vague and not very helpful. With crashlytics, all application errors, fatal or non-fatal, will be logged and documented in the Firebase console. Basically, what you see is a snapshot of the Android monitor as if you were debugging at your own computer. It will even generate useful analytics and metrics from the crash data. You can see information on device versions, operating system versions, how often specific errors are occurring, what days the errors are occurring, all kinds of useful information. Here's something I personally like to use it for when working on apps that aren't in production. I'm sure you know or have seen this before, that sometimes applications can crash and will automatically reset before you get a chance to look at the log. This can be very frustrating when you're trying to determine the source of a problem. If the log resets before you can see where the error came from, or even what the error was, how are you going to debug it? In the past, I used to film my screen, cause the crash, and then go back and watch the video in slow motion so I could maybe catch the frame where the error occurred. Not the most efficient way to do things. But with crashlytics, I can just open my Firebase console and view every crash in detail. Pretty convenient. There isn't much needed to get started with crashlytics, and we'll take a look at that in the next section.

Implementing Firebase Crashlytics
In this section, we'll enable Firebase crashlytics in our Android project. Installing Firebase crashlytics is incredibly simple. We literally just need to add the dependencies and we're ready to go. Head over to firebase. google. com/docs/crashlytics/get-started. The first step is to add a reference to the maven fabric repository. So just copy that, open Android Studio, open your build. gradle project file, and paste it in right here. Now go back to the docs. next, is adding this is io. fabric classpath. I'll copy that, open Android Studio, paste it in right here. Now head back to the docs. Now we're ready to add the dependencies to the app level build. gradle file. Copy the apply plugin line right here, open Android Studio, open the build. gradle app file, paste it just below the application plugin. Now back to the docs. Last one. Copy the crashlytics dependency, open up Android Studio, write a short heading: firebase crashlytics, and paste it in. Now press Sync. Oh whoops, looks like I forgot to change the version. So just change it from 11. 4. 2 to 11. 4. 0 to match the rest of the versions, and press Sync again. We're done. We can test it by causing a crash in our application. Navigate to SignedInActivity. In the onCreate method, I'll create an array list and call a method on it, even though it's null. So we'll go ArrayList String list = null, and then call list. size, and that will cause a crash. So now let's run it, and there's the crash. Now let's go to the console. I actually caused it to crash a bunch of times because I got impatient when crashlytics wasn't showing the crash, so that's why there's a bunch of crashes here. But your app should only show one. There's also some other data here from when I was testing the app a few days ago. But if we filter it in terms of today by clicking in the top right here, and then selecting last 60 minutes, there's our crashes. Keep in mind it can take a few minutes for your crash to show up in the console. Don't get impatient like I did. If we want to see more detailed information about our crash, we can click here. There's the device, the operating system, the total number of crashes, what state the app was in during the crash, the STACK TRACE, KEYS, and LOGS are a more advanced feature of crashlytics. They're custom crash settings. If you want more information on those, check out the documentation at firebase. google. com/docs/crashlytics/ custom-crash-reports. But this DATA tab has some more useful information. You can see more detailed information about the model, how much RAM and disk was free at the time of the crash, the operating system, and even the orientation the phone was in during the time of the crash. Once you think you've solved the issue, you can mute it or close it by clicking up here. As the developer, you'll also get email notifications when crashes occur. It's all pretty incredible stuff. The fact that you can get this type of detailed information is pretty amazing and all you need to do is add a few lines of code in your build. gradle files. And with that, we're now nearing the end of the course. In the next module, we'll do a brief review of everything we've covered.

Tying It All Together
Tying It All Together
Looks like you did it. You've reached the end of the course. In this module, we're going to review everything we've covered. We began the course by talking about the importance of cloud messaging. Cloud messaging is mostly used to create push notifications, and push notifications are a vital part of keeping user engagement high. I'm sure you get at least 10-20 of these everyday on your own mobile device. It could be notifications about new emails, likes on your photos, text messages, missed phone calls, sales promotions; the list goes on. After an introduction to cloud messaging, we talked about Firebase cloud functions. Cloud functions give the developers the ability to execute server-less bits of code that perform specific tasks. The possibilities are endless when it comes to cloud functions, so it pretty much depends on your creativity as the developer. But in a nutshell, you can build something that interacts with any of the Firebase tools, or your application's users. Cloud functions are executed by triggers that you define within the function. Some of the triggers are authentication triggers, database triggers, storage triggers, analytics triggers, Firestore triggers, HTTP triggers, or cloud pub/sub triggers. One last thing we talked about in the introduction was crashlytics. In my opinion, crashlytics is a massively underrated developer tool. It doesn't get enough attention. The kind of information it provides about application failures is incredible. It documents every application crash, whether it's fatal or non-fatal, the information is then organized in an analytical way and easily accessible from your Firebase console. And above all else, it's implemented within 10 lines of code. In the next module, we went over how to integrate an Android Studio project with a Firebase project. In other words, we connected our application to the Firebase servers, and added all the required dependencies for using cloud messaging. We covered the SDK requirements for using Firebase, how to create a new Firebase project at firebase. google. com, how to sync your Android projects with a Firebase project; this entailed referencing your package name, downloading a Google Services JSON file so Firebase could identify your application, and adding the required dependencies. Although it wasn't featured in the course, we also enabled email sign-in from the Firebase console so users could register. Don't forget that you can use multiple Android Studio projects with a single Firebase project. Your application can share users, a database, or other features Firebase offers. The next module basically served as an introduction to Firebase cloud messaging. We set up the FirebaseMessagingService class, the FirebaseInstanceIdService, and then sent some cloud messages from the Firebase console. We talked about the data structure of cloud messages, and how the presence of a notification key value pair in the data payload will have an effect on whether the application receives the notification in the background, or when it's closed. Remember if the payload looks like this, the cloud message will not be received if the app is in the background or closed. But if we remove the notification key, then it will be received in all application states. The app can be in the foreground, in the background, or closed. In the next module, we built the functionality to send cloud messages from the Android client. The module was broken down into five sub-sections. Retrieving FCM tokens and the server key. This is where we queried the unique cloud messaging token for each user, and then also the server key. Remember we saved the server key in the database because it's not a good idea to save it on the Android client. Getting started with Retrofit. In this section, we introduced Retrofit, an external Android library used for sending various HTTP requests. I prefer Retrofit over other libraries like Volley, because you can convert Java classes to fit your request data structures, like JSON. Testing HTTP requests with Postman. Before sending requests from the client, it's always a good idea to test. That's where Postman comes in. We tested our cloud messaging request and fine-tune the request data structure. Sending cloud message from the Android client. In this section, we sent our cloud messages for the first time from the Android client. The cloud messages are sent by the application admin and received by whatever departments they've chosen. Cloud messaging with topics and device groups. In this section, we only sent cloud messages by referencing user's unique messaging tokens. That's not the only way to do it. We talked about the two other ways: cloud messaging using topics, and cloud messaging with device groups. Remember, for more information on these methods, check out the Firebase documentation. In the next section, we constructed push notifications for the various situations our app has to deal with. The situations we had to handle were receiving cloud messages from admin broadcasts, receiving cloud messages when users post new chatroom messages, and determining what the application state is when cloud messages are received. Here's a diagram outlining the logic. First, an incoming cloud message is received by the onMessageReceived override method. Next, we check to see if the application is in the foreground. If it is, then we only care if it's a broadcast notification. So, we check for the admin broadcast data_type, and then build the notification. If the application is not in the foreground, then there's two scenarios. If the data_type is a broadcast message or if the data_type is a chat message. That's all there is to it. That handles every scenario we need to watch out for when building notifications. Next, we worked on sending cloud messages usign a cloud function. This section was broken down into three sub-sections. The first sub-section was installing node. js on our local machine. We needed to install node. js because that's the programming language cloud functions are written in. The second sub-section was enabling the use of Firebase cloud functions in our Android project. To do this, we installed the Firebase Command Line Interface, otherwise known as the Firebase CLI, by typing npm install -g firebase tools in a command prompt. Next, we initialized our project for the use of Firebase functions by navigating to our Android project directory and typing npm init functions. We then followed the instructions and referenced the Tabian Consulting Firebase project. Next, we actually coded the cloud function responsible for sending the cloud messages. Let's review the criteria for the cloud function. The criteria were: number one: execute when users write messages to a chatroom, number two: retrieve the unique cloud messaging token for each user in the chatroom, and number three: send cloud messages to every user in the chatroom. In the final module, we integrated Firebase Crashlytics into the application. Remember with crashlytics, we can get detailed information about all your application failures, whether they're fatal or non-fatal. All the information is organized in an analytical fashion so it's easy for you to identify the most important issues. You can see information on device versions, operating system versions, how often specific errors are occurring, what days the errors are occurring; all kinds of useful information. I highly, highly recommend installing crashlytics into your next Android project. Congratulations on completing the course, and an additional congrats is in order if you finished the entire Firebase on Android series. I'd really love to hear your feedback or any suggestions you might have. I worked very hard to anticipate areas of confusion, but I'm sure I missed something that may have appeared unclear. Please send me an email at mitch@tabian. ca, leave a rating on the course, or leave comments in the discussion section of this course. And as always, thanks for watching.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
4.9 stars with 25 raters(25)
My rating
null stars

Duration
2h 6m
Released
4 Jan 2018
Share course

