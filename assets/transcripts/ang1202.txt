Angular Architecture and Best Practices
by Dan Wahlin

Learn how to build a solid Angular application architecture that is easy to refactor and maintain. Topics covered include code/component/module organization, component communication, RxJS, state management, best practices, and more.

There's a lot of questions out there about the core concepts of Angular, including: are you following established best practices? How easy will it be to maintain and refactor the application in the future? If you're starting a new application from scratch, what application architecture should be used? In this course, Angular Architecture and Best Practices, you'll learn architectural concepts, best practices, and how to solve some of the more challenging tasks that come up. First, you'll discover component communication techniques. Next, you'll learn state management and code organization. Finally, you'll explore general best practices, performance considerations, and more. When you're finished with this course, you'll have the skills and knowledge of Angular application architecture needed to think through the process of building a solid application architecture that is easy to refactor and maintain.

Course author
Author: Dan Wahlin	
Dan Wahlin
Dan Wahlin founded Wahlin Consulting, which provides consulting and training services on JavaScript, Angular, Node.js, C#, ASP.NET MVC, Web API, and Docker. He is a Google GDE, Microsoft MVP and...

Course info
Level
Intermediate
Rating
4.9 stars with 118 raters(118)
My rating
null stars

Duration
5h 21m
Released
15 Jan 2019
Share course

Course Overview
Course Overview
(Music) Welcome to the Angular Architecture and Best Practices course. My name's Dan Wahlin, and I'm a software developer, architect, and trainer specializing in web technologies. Over the years, I've had the opportunity to work with many companies around the world on front end and back-end architecture, and I'm really excited to share some of the information I've learned with you. Application architecture is a big topic, and one that can be very subjective, so the overall goal of this course is to provide you with solid, proven guides that can be used as you plan and build your applications. The course starts out by discussing key architecture considerations to take into account when doing initial planning of your application. Over the years, I've created a simple architecture planning template that I use with companies, and I'll show you how you can get started using it. From there, you'll learn how to structure features and modules in a self-contained manner that allows team members to develop and deploy features independently. Sharing functionality across an application or across multiple applications is also key as you plan any architecture, and you'll learn about the role that custom Angular libraries can play there. As the course progresses, you'll learn about the container presentation pattern and how it can be used to structure components, component communication techniques, and the importance of RxJS subjects, and learn about the need for state management and the different options that exist. Finally, additional considerations such as pipes versus functions and different RxJS operators that can be used with HTTP calls will also be covered. So, let's get started and jump right in.

Introduction
Introduction
Over the years I've had the opportunity to work with many developers and many companies around the world on Angular applications. This has consisted of on-site training, as well as on-site architecture engagements where we talk about what their app is and how they can get from point A to Z and be successful in the end and also have a successful maintenance approach as the application changes over time. So, I'm really excited to share some of the information that I've gleaned over the years, I've learned this not only from my research, but in also working with many developers like you and getting feedback on what works for them and what doesn't. So thanks for making the time to listen to what I have to say and I hope you get a lot out of this course. So we're going to start things off in this module by talking about the prereqs to maximize your learning. From there we're going to go into the key concepts and learning goals that I have for you so that by the time you get to the end of this course, you'll know right up front what to expect and really where you should be at from a knowledge perspective by the time you get to the end of the course. From there I'll introduce where you can get the sample application that I'll be using and the code and introduce the basic software requirements that you're going to need if you want to run it. And then we'll wrap up with an overview of the modules that we're going to cover throughout the remainder of the course and talk about those topics briefly. So let's go ahead and get started by talking about the prereqs that you need to have to get the most out of this course.

Prerequisites to Maximize Learning
So what knowledge do you need to get the most out of this course? Well, let's talk about that really quickly, and if you've done any Angular at all you'll probably meet the prereqs, but at a minimum, you need to have some experience with TypeScript. So if you haven't worked with TypeScript at all, I'd recommend you go check out some of the other courses on Pluralsight and get that background first. Second off, you absolutely need experience with Angular. This is not a course where I'm going to cover the fundamentals of Angular at all, we're instead going to focus on different architecture and best practice concepts of course, so that would be another essential thing that you need to have some experience with. And finally, you'll need some experience working with the Angular CLI as we'll be using that for a few of the concepts we're going to be talking about throughout the course. So the bottom line is as long as you have a foundation in TypeScript and you've worked with and built some Angular applications, then you should get a lot out of this course. If you don't have those prereqs, there are plenty of courses up on Pluralsight.com that will help you get started there, and then you can always come back to this course and continue on your journey.

Key Concepts and Learning Goals
One of the goals I always have when creating courses is to make sure people know up front what to expect and what not to expect, so let's talk about some of the key concepts and learning goals that I have for you throughout this course. If you've built Angular apps before, you'll know that it's really like putting a bunch of LEGO blocks together, and so what this course will cover is different techniques we can use to put those LEGO blocks together, and by LEGO blocks I mean components and services and other features we're going to be working with so that we can build a very coherent, easy to maintain type of application that also maybe looks good, maybe you're building a castle for your application or something out of LEGOs. Now really, building something like this though, if you think about an actual building, we of course need a solid blueprint. We wouldn't want to start just from scratch and start putting together this castle here without a blueprint for where the turrets are going to go, how many rooms, how high, structure of the roof, foundation, all those types of things, and so why would we start our application without doing those same types of things? And those are some of the things we're going to talk about. Now specifically, we're going to focus on planning our application, communication throughout the application, how do we structure the project, how do you do your folders? Now you've probably heard of feature-based, and we'll kind of stick to that approach, but as the app gets bigger, there are some decisions that need to be made, and we'll talk about some of those decisions. We'll also introduce best practices that you can find in the style guide and other things that I've just personally learned from my own research and experience and from just working with others over the years. We'll get into a little bit on RxJS and some things you can do there, as well as topics such as state management, which is a huge topic in and of itself, but I'll provide some information for you so that you can at least know the different options that are available. Now specifically, we're going to talk about structuring our modules. That's a very, very important part of building a solid, Angular application architecture, especially if you think your application's going to get very large, and I'd offer, even if it's not very large, you still want to think through this very well and spend some time on it. We'll go into organizing our components within these modules so we can maximize reuse and shareability and just make it easier to maintain. Maintenance is always a big goal of mine. I have a little bit of a background in that, back in my early years. We're also going to discuss custom libraries. At some point you may say, hey, I want to share this component, but I want to share it across many apps, not just one app. We'll talk about some Angular CLI features there that'll help with that. A big one that comes up that I know a lot of people struggle with at some point in their Angular career is component communication. Now we have the normal stuff like input and output properties, but what happens when it's a little more involved than just that where we need to communicate between many levels of an application? How do we do that? What are some of the techniques? What are the pros and cons of those techniques? And, that's really what we're going to cover here. We'll also get into observables and something called subjects, very, very useful actually with communication in the previous section there, so we'll talk about some of that. I've already mentioned a little bit on managing state. A very big topic, but we'll identify some of the key players in this space, and I'll give you more complex solutions to more simple solutions that you can go with. Now in addition to these topics, throughout the course I'll sprinkle in a few others as well such as using custom decorators, some pretty interesting things you can do with those. We'll talk about pipes and the role they can play for performance that you may or may not have run into, and we'll get into some other things with HTTP and other topics along the way. Now, what's the right way to architect your Angular app? Well, I think if you talk to five different developers, you're going to probably get five different answers. There is no one right way, and I want to emphasize that up front that this course is not about what is the right way to build your Angular application architecture. Instead, this course is about different techniques that I think you should consider that have proven themselves out very well. Now they may or may not be appropriate for your application, but in this case knowledge is power because as you know about the different options, you'll be able to apply those where appropriate, and of course know when they're not appropriate, and that's super important. Now the three key things I want to emphasize throughout this entire course, yes, we are going to look at quite a bit of code in different modules, but if there were three things I think all five of these developers, and that you and I can agree upon, it's that we should just keep it simple. If there's one thing I see that developers really run into, it's the problem with, I'm going to start out really simple and by the time they're done, it looks like a Dr. Seuss house or something and it's just very complex to maintain. I've always found that keeping it simple is almost always the best solution, and I'm going to attempt to do that as well as we go throughout this course. So now that we've talked about some of the key concepts and learning goals, let's talk about the sample app and some software requirements real quickly.

Sample Application and Software Requirements
So where can you get the sample application and code and what are the software requirements to run it for this particular course? To get the code for the course, you can go to my GitHub repository, github.com /DanWahlin. The first link that you're going to see here is going to be more targeted demonstrations that are going to tie into some of the different modules coming up in this course. The second is an application that's just a demo app, but we're going to refer back to it for various best practices and some different architecture concepts as we move along through the course. So you'll have quite a bit of code you can refer to, especially if you're newer to this at all, and if you're more experienced this will provide a nice reference architecture type of application, and then you of course can make your adjustments for your company. Now to run it of course, you'll need the proper software, so we'll need the standard suspects here. We'll need Node, and specifically I would recommend the latest LTS version. Once you have Node installed, of course, you can install the Angular CLI, and that will be something we'll also be using heavily to build and run the projects, and then of course you need an editor. Now any editor can be used, I'll be using VS Code throughout the course, a very, very good editor if you haven't checked it out before, but you could use something as simple as Notepad if you want. So those are the basics as far as the software requirements go. Once you have the required software installed, you can jump over to the demos I mentioned earlier with the two links, and there's going to be a ReadMe for both of these that'll get you up and running if you'd like to try these out sooner than later. The Angular Architecture one is very, very simple to get going. You'll see Install the CLI, go to a specific folder, and then kind of do the normal things, npm install, then ng serve. The next one takes a little bit more, but it's very minimal. This one actually has a Node.js back end, and so what we're going to be doing here is also an npm install and a build with a watch, and then npm start will fire up our back-end server, which will also serve the Angular app in this particular example, and then there's some screenshots of what the application looks like if you're interested. So, both of those are very easy to get going. I'll bring them up a little bit later in the course, but that would be all you need to know for the demo code and the required software.

Course Overview
Now that we've talked about the course prereqs, the learning goals, and the required software, let's wrap up by talking about the different modules and topics we're going to be covering throughout the remainder of the course. Now we're going to start off by planning the blueprint. I mentioned earlier that we don't build a house, and definitely not a castle, without some planning going into everything. We'd want to plan the foundation, we'd want to plan the framing, the roofing, the electrical, everything we would need would need to be planned of course. Well, applications are really no different. Now there's a lot of different strategies, of course, that can be used to plan your application architecture, and I'm going to present a very simple approach that, number one, is going to force us to focus and not kind of go off on a bunch of tangents, and number two is very, very simple. I've used this with small and large teams to get everybody on the same page as we plan an application's architecture. Now once we go through that, we'll talk about techniques for organizing features and modules. Very important to plan this out, especially in larger applications, so that not only do we get a lot of reuse where appropriate, but we also simplify our maintenance down the road. We'll also talk about structuring components and different techniques that can be used there as you work with, for instance, a parent and a child, or maybe even a great-grandparent component and a great-grandchild, or something along those lines. Next up will be component communication. I mentioned earlier that this is something that I find a lot of people struggle with early on. We learn about inputs and outputs, but that only satisfies one small aspect of an application. So we're going to learn about different strategies that can be used to communicate between different levels of an application, and we'll also talk about when some are appropriate and when maybe some of these techniques are not appropriate. From there, we're going to get into an introduction to various state management techniques that I think every developer building Angular applications, or really any front-end application, should consider. This is one of those things that, it really doesn't become apparent that you need it until later in the application development lifecycle. If it's a small app, it may not bite you much but if it's a mid-size to a large app, this becomes very important, and as mentioned earlier as well, I'm going to introduce more complex solutions to very simple solutions that you can consider. And then from there we're going to wrap up with some different techniques that you can use and apply in your applications, and this will include topics such as functions versus pipes, we'll talk about custom decorators that can be used in an application, and even how RxJS and HttpClient can be used together in different scenarios to increase performance and just make more efficient calls to the server. Now from there we'll end with a course summary, and I'll give you a nice overview of everything that we just covered. Now at this point I want to emphasize that while there's a lot of great content we're going to cover, it's just not possible to cover everything. I guarantee there's going to be a topic that you're going to say, Dan, why didn't you cover that? And why didn't you cover this? And short answer there is the course has to be kept to a reasonable length. I can't, unfortunately, make a multi, many, many, many hour course. It just doesn't work these days. People just don't have the time. So, while there are other topics, we're going to focus on what I consider to be the key topics, and definitely the key topics as I work with various teams, that I find are the biggest benefit to them. The other topics, well, those are things that we can certainly research, but I want to make sure that everybody's clear here. I realize there's other topics. We just can't fit everything into one single course. Now having said that, we have a lot of great content to cover, so let's jump right in to the next module and we'll start talking about how we can plan for our application architecture.

Planning the Application Architecture
Introduction
In this module, we're going to take a look at one of the most important aspects of any application, and that's planning the application architecture. Now I'm sure you've probably worked on an application where you or the development team just jumped right into the code and just started coding away. I know I've been on teams that have done that, and in some cases the application ends up working out, and in other cases, usually when the application is larger, that technique oftentimes doesn't work out so well because there's many things that you didn't take the time to plan for. So really this is all about deciding on what are the different pieces of our app and how we're going to make these pieces fit together. You can also word it a different way and say, measure twice cut once. You might have heard that saying before. Regardless of how you want to think about it, this is an important aspect of any app, of course, because just like a blueprint for a building, we're not going to jump into building the foundation and the frame and the roof, and all that, without taking the time to adequately plan and to create a blueprint that can be used. And for those outside of the US who are really paying attention to this particular slide, yes it's true, we still use non-metric measurements here. What can I say? But I digress; let's move on. So we're going to cover some very simple things in this module, simple in principle, but maybe harder to actually implement and get into practice. Specifically some architecture considerations that I think every team in every application should at least take a moment to think through at a minimum. A planning template that I use that's very, very simple, but very effective and very proven out over the years as I've worked with different companies and used it. We're going to introduce the Angular Style Guide, and if you haven't read through it, we'll explain what it is and why this should play a big part in your architecture planning for your application. And then I'll also introduce some other considerations that while we won't have time to cover everything in this course, there's some other things you still would want to think through of course. So let's get started by talking about some of the important architecture considerations you might want to take into account before you start building your application.

Architecture Considerations
Building any application is a lot like putting LEGO blocks together as I mentioned earlier. So, if you think about a large LEGO set out there, without a manual to help you know how those pieces integrate together, it'd be pretty tough to put those LEGO sets together. I'm talking about some of the multiple piece type of sets, thousands of pieces potentially. So earlier I mentioned and showed this picture of LEGOs, and if you think of Angular apps as a bunch of LEGOs that ultimately we want to snap together to build an application, or a building in this case, then of course we would want to put some planning into this. Now, if we go to strictly talking about buildings, think about a blueprint and the value a blueprint has, especially these days with the large skyscrapers that might be built, that are out there. Imagine not planning for the proper size of the foundation, just that one piece alone could cause the skyscraper to fail down the road potentially. Imagine not planning for the proper wiring for electrical or the proper piping for plumbing. That could be a disaster down the road as the building ages of course. Now while we're not building buildings and we're not architects in the sense of blueprints like this, I think the same exact principles apply, just like a blueprint and an architect would have all the information necessary to build a successful building, there's very specific things we also need to plan for in our applications. Now there's many considerations you could think through, but there's nine I'm going to mention here. Some are very obvious, some maybe you haven't thought through, but there's nine that I think every application, regardless if it's front end or back end, should take the time to think through, you as an individual, or if you're on a team, your team. Now the most obvious would be you need an app overview. What is the application for, what are the goals, how is the client going to use it, what are the business benefits and strategic benefits we're bringing to the table here? Now number two, what are the app features? Now depending on if you're a waterfall approach, or agile, or a mix of that, you may not know every app feature up front, but you should know some of course. So let's list those app features here, and the reason for that is now we can start talking about specifics. What is the domain security? Are we using rules on the server side, groups, claims? How are those going to be communicated down to our Angular app? How's the Angular app going to communicate with our APIs, is it going to use token- based, an LDAP server with Active Directory? In some applications, there might be a lot of security involved where you need to plan for that up front. Likewise, what domain rules do you have? Are the rules going to run client side strictly or are you going to run them again on the server? Now in most cases you want to run them in both places, especially things like validation of course. But you might have some really heavy number crunching rules that take a lot of time to run that might require an API call, and those might run on the server. Well, we should plan for those types of things. Now the next one is one that I think is maybe underestimated by many applications out there, and that's logging. What are we doing when an error is encountered in our front-end application? Are we just writing it to the console? Probably not a good solution. Are we writing it maybe to local storage? Or are we actually going to create an API or maybe integrate with a cloud option out there, or a third-party option, that provides excellent logging capabilities. Now if you work with a help desk and get help desk support tickets that you have to support, or your production support team supports, having logs and having good logs is just essential, because there's nothing worse than what I call the needle in the haystack ticket, and that's where you're given a ticket, there's very little details on the bug, but the client says there's a problem, but you have no idea where to go look for that. Well, by planning for logging and building this in from the get go into your application architecture, we can avoid those types of scenarios and not only provide good bug support, but also provide good statistics on things that might be happening in the app that we just didn't know about. Now the next thing is how is the Angular app going to talk to the server. Now this might seem kind of very obvious up front, like well Dan, it's going to be a HTTP, what else is there? And I would argue in most apps that's probably true, you'll use HTTP concepts, of course, over HTTPS. However, your app might have some real-time data considerations and WebSockets might be more appropriate. Well that's good to know up front because that's going to change some of the architecture on how data is exchanged between not only the back end and the front end, but even between services and components in your front end in your Angular application, so important to talk through what are we going to do there and what are we going to create as far as services go, or later we'll talk about state management techniques that might also use this. What are our data models? What's the data from the API down to Angular, from a given service, let's say, in Angular? What are we passing to components? Are we getting what we want from the API, is it exactly what we want? In many cases I'd argue no, a lot of times APIs are reusable, they give you back a chunk of data, and then you only need a subset of that. So we should plan for what's the most efficient way to get data passed around throughout the application. Now you may not know everything about your data models up front, and that's okay, this is more an exercise in discussing what are we going to pass, how's it going to be passed, are we going to create view models, models that just have the data that the component needs, or use some other technique? What are our feature components and how are we going to structure our components? Now we're going to talk about different techniques such as the presentation container pattern, but there might be some other things you need to do, and this also gets into communication between components. If two features can be alive at the same time in the app and they need to communicate, how are they going to do that in a loosely coupled way? And we'll talk about some communication techniques that we can apply here as well. But identifying the key features you're going to be starting with would be very critical here. And then finally, what shared functionality do we have? Are we using third-party components, and if so, there's a lot of options out there, which ones? Are we just going to use them natively and directly, are we going to write some wrapper components around the shared components so that we can actually swap out those third-party ones if we wanted down the road? Also, is the shared functionality just sharable in this one app or could it be reusable across many of your apps at work. Well, now we need to start talking about libraries, and fortunately the Angular CLI provides some nice functionality there, but these are things we need to plan for as well. Now there's certainly many other things we could discuss, and I'll bring up a few of those at the end of this module, but these nine are the main ones I think are at the top of my list. Your list may be different, and that's okay. The point here is to think through some of these critical aspects up front, especially if you have a larger team, to make sure we know which direction we're going and get a general blueprint. Now, how do we organize all this information? Well, I'm going to tell you the approach I use next.

Architecture Planning Template
If you're not currently taking into account some of the different items I mentioned earlier, then probably it's because it feels like it's just too much work, and now you can't meet our deadline, we have to delay coding, and we don't generally want to do that. Well, I don't think that the process of thinking through these things has to be something that takes multiple weeks or even months potentially. Instead, what I do is I have a really simple architecture planning template that lists those nine things, then any others that a company might want to include. But instead of leaving it very open ended, I kind of narrow it down and force it to be focused, and I'll explain what I mean here. So, the template that I use is slides, and you might kind of laugh at that. I did an engagement a few years back with a very, very large financial company here in the United States and ended up without them really knowing it, documenting everything we did at the time, it was PowerPoint. And then I gave a presentation at the end and everybody was just blown away by some of the diagrams I had, and things like that, and everybody was like, well, what are you using? I said well, slides? Because it's focused, it allows you to draw shapes, and you can easily do lists and things like that. It works very, very well. Now that may not be your thing, and that's okay, but at the link that you're going to see here, which I'm going to jump to in a moment, I'll show you what I use and then we'll actually look at a sample of an actual engagement that's been greatly simplified, but at least it'll give you an idea of how to put this template into action. Now, we're going to use that then as a planning template, and then of course we'll take that template and fill in the blanks, and that's where the example I'll show you will come into play here, and you'll see a link to this as well. Now these particular links will just simply take you to Google Slides. I like that, or maybe you're using Office 365, or some other solution where multiple people can simultaneously contribute ideas into your content. This works really well as you get into a meeting. Instead of the team lead, or whoever's leading the meeting, sort of being the bottleneck for internet ideas, everybody can start entering in it. In fact, normally what I'll do is divide people up, we'll still be in the same room, we'll focus on some of the different areas of those nine items I mentioned earlier, and the others that the company wants of course, and then we'll start just getting to work. And in literally less than half a day, we'll be way further along in our knowledge about the app than we would have had we not taken the time to do that. I've done that with many companies now over the years, and you can be extremely productive if you just stay organized. So, let me jump over to an example of the template, and you're going to kind of laugh at how simple it is, but having used it many times you're going to see it works really well because it keeps everyone focused. So here's an example of a Google Slides template that I use. And this has the nine things that I mentioned earlier in here, so no surprise there at all. Now I'm not going to say that I narrow this down to just nine slides because it's never that simple, I realize, but this provides a really good starting point. First off, it gives us in a meeting a very nice agenda to work through. Maybe some of these things take a lot longer as far as the discussion goes and we need to have multiple meetings, that's fine of course. But at least we have an agenda, there's nothing I hate more than meetings that have no agenda. First off, we'll go through and we'll plan the app overview, and right here we'll be in Google Slides, or PowerPoint, or whatever you like, and everybody can start inputting ideas, but the goal of this would be to keep it to one slide, one single slide, very focused. So we're going to kind of eliminate all the extraneous information and just keep it really boiled down to the core concept. The app features from a very high level would be listed. Domain security. Now, depending on how complex this one is, you might actually have some diagrams you now start to put in here, and that will allow us to also start the Docs, even if you don't have Docs you could refer back to this potentially, and if you need more slides you can of course do that. Domain rules, logging, services and communication, data models, feature components, and the shared functionality we talked about. Now that we've seen the simple template, let's look at a quick example of using it.

Architecture Planning Template Example - Part 1
Let's take a look at using the architecture planning template for a sample application, which is the jump start app I mentioned earlier. Let's assume that we haven't actually planned that out yet, we're starting completely from scratch, we know some information for maybe a business analyst at work or some other source, but now we need to actually start this process. So I'm going to switch over to the template, and this is actually the slides with some information now plugged in online. So we have those nine key areas that we want to talk about. So from an app overview standpoint, the overall goals of the app are to view and edit customers, display orders, and provide a secure way to edit those customers. We're going to need some login/logout functionality, and you'll see some of the requirements are to display the customers in different ways. We need to support kind of standard things like filtering, sorting, paging, this'll be server- side paging we're going to assume. We do need to map our customers, we're going to use Google Maps for that. As mentioned, we need a way to edit the customer, so that is not only inserting, but also updating and deleting, so the full CRUD operations. And then for the orders, we also want to be able to page those. And as mentioned we want to support login/logout. We're being told at this point we're going to assume that it's just email and password, but down the road that could change to a more of a token-based authentication. Now some of the app features then would be we need a way to work with the customers, and this would be displaying them in the different modes, card views or grid views. We need to work with individual customers, so that would be a separate feature. We need the orders of course, that'd be a separate feature. And then we have the login and logout capability, and that would be a separate feature. Now there are some others in the actual application, but these would be the key ones that we're going to focus on. Now domain security is pretty easy on this one, it's just email/password for login, we're not going to focus on that a whole lot because normally the back end will be very variable depending on your company and how you do things. But, we're going to assume that maybe we're going to consider tokens for a future release, and that we might need, for instance, an HttpInterceptor in Angular to set an off header, and we would also have to discuss what is the back end that would be the issuer of those tokens and issue refresh tokens and things like that. Now as mentioned, we're not going to focus on that here, there's other courses on Pluralsight if you want to focus on Angular and security, or just security in general. The overall goal here is this discussion to get the team talking about what are our current plans, what do we think might happen down the road, do we need to plan for that now or can we hold off on some of those things? Now the rules are really simple for this app, each order must have a customer of course. We are going to need to convert orders into an order total for each customer. We're going to assume the server doesn't give us that, so that'd be a rule we'll have to incorporate. The customer edit form needs to validate the data entry, and we'll talk about how that's being done actually. And then the user of course needs to be able to log in in order to edit a customer, so we're going to talk about a route guard we might need to secure that route, at least on the client side. And then of course we'd have to validate the email and password against the server and do some front-end validation as well. So that'd be an example of some of the rules you can start talking about in an app. Now these are very simple, your app may have many, many rules, and this is a good opportunity to start listing those. Now logging is really important, I mentioned this earlier. And for this one we're going to have a logging service, we're going to say, that for development maybe just writes to console log, but we're going to assume that maybe the client would ultimately like to use Azure AppInsights or some other third-party or cloud service to actually log our errors that occur on the front end. So that would be another, in my opinion, very important discussion point for your team to go over, to talk about how are we going to log these errors. Now maybe you already have something great in place, if you do that's awesome, if you don't, and I find that many don't, don't just let that slide. This is one of those most important areas when it comes to satisfying and kind of answering the help desk tickets and getting those resolved, so don't skimp on this one. Now, services communication for this app we're going to assume we've been told is just a standard RESTful service on the back end, and we're going to use Node.js. Now it could be anything of course, it could be Java, ASP.NET Core, PHP, whatever it may be, but we're going to assume in this one Node.js. And then as far as Angular services, we need a way to get customers and orders, and we need a way for the user to be able to log in and log out by authenticating against the server of course. So we're going to need some services for that. We're going to need something for sorting, so rather than putting all the sorting inside of a component, we're going to put that in a service. Same for filtering. We've already mentioned the logger. And then we might even need to communicate in different ways between different levels of our app, between different component levels, and we're going to be talking about component communication later in the course, so that's another thing we might plan for up front. Now earlier I mentioned that for now we're just going to use email password for security to log them in, and then that would just set an encrypted ticket in a cookie. But we might end up using something else, we might use a token, for example, with OAuth. And in that case, we might have an HttpInterceptor that might interact with the request and responses to do different checks or to set headers. Now another discussion point here that I think is always important on services and communication is when it comes to RESTful services, if that's what you're using, are we just going to do GET and POST? I would offer that's maybe a little too simplistic. I always at a minimum do GET, PUT, POST and DELETE, but another important one that a lot of people don't seem to dive into as much is PATCH. Now, PUT is typically when you want to update the whole object, but a lot of us have forms that they're not just the whole object, they're part of an object and then ultimately we want to kind of overlay the data from the form over the object that may be in our data source. Well that's a perfect example of PATCH, PATCH is for I want to patch or change one or two properties maybe. It could be more of course, but one or two would be a good example. So that's another discussion point that I think is important to have.

Architecture Planning Template Example - Part 2
Now data models in this app, we pretty much have customers and orders, but we're not going to be editing the orders. So we're going to focus mostly on a customer model, we of course also would need something for authentication, send those credentials. And what are we going to do with the orders, are going to have a separate one, are we going to include that with the customer? How are we going to do that? That would be a good discussion point. Now, I also think a great discussion point here is, are we going to create a class for the models that we're ultimately going to get back from the server, and then we'd have to write some code to fill those models of course, or are we just going to use an interface? Now the benefit of an interface is there'd be zero impact on the bundle size for production, because of course TypeScript compiles that out, so I opt to go for interfaces unless my classes are more specialized. Now if you said, hey Dan, my model is not just properties, but it also maybe has some functions in it that are going to do something for a given model, then I think a class is absolutely appropriate. But if you're literally just exchanging the data from the server and using that for the most part, or maybe scaling that object back to a smaller object, you can get away with just an interface. There's really no need to build that class if you're really only using it for IntelliSense and code help. An interface would work great there. Now this is a very subjective thing, there's no right way, everybody likes to say there is, but of course there's not. So, this is definitely something you would want to talk about with you or your team, depending on how many people you're working with. And I always opt for interfaces if I can. I know some folks who prefer to always do classes, but that means they're going to have to map that data coming from the server into that object ultimately. No right way to do it, it's definitely something worth discussing though. Now here would be an example of what we might then put, we might start to document the basics of our model objects. Now obviously this is a very, very simple one, but you can see it just has the standard customer properties and then an orders array. Now we'd also go in and say what are our main feature components? This'll help us start to spec out or scaffold out with the Angular CLI our various feature components. So, we know we have to display customers, that'd be a featured component. We know we have to work with an individual customer, that could be a customer component. We know we have to work with orders, and we know we have to do to login, and there's a few other minor things included in the app as well. This is a good opportunity to start thinking about the top-level feature components. Now you'll notice we're not going deeper into how we're going to organize any children that we have. We'll be talking about that later as we talk about structuring components. But for now, we're going to keep it at this level, and then of course you could certainly go deeper into this if you wanted. Now here would be an example of what we might end up doing. Maybe we had an initial diagram that a business analyst gave us, and now we're going to put this in the slides, which is another reason I really like using slides because anybody can get to them and it's very easy to add shapes and things that are very simple, or even complex ones in some cases. So in this example we have our customers and orders menu at the top. Looks like we're going to load that immediately when the app loads. But then we are considering lazy loading the stuff below it, such as the customers feature. It might have a toolbar potentially, it looks like, and we're going to display cards or a grid we're being told from the docs we've been given, maybe by a business analyst. So now we'd of course have to talk about how are we going to structure the cards or the grid, how detailed are we going to get there? Are we just going to put it all in the customers feature component, or are we going to break that out. And we'll be talking about that as we move along. Now the last main piece, of the nine anyway, is what shared functionality might we have. Well, in this particular app that we're going to be talking about we have a toast and a growl, we have a modal dialog, we mentioned Google Maps, there's a pager for the paging aspect, of course, we need a menu, and then we need the grid and the cards. And we need to start making some decisions here, are these truly shared, are they just used by one feature, that's going to determine where do you put these components in your overall folder hierarchy, in your folder structure. Now another thing we'd have to talk about here that I mentioned earlier is, are any of these going to be reused across apps? Well that'd be a good opportunity to talk about a shared library, and we'll be talking about that as well in the course. And then finally, any third-party shared functionality. Maybe for a calendar you don't really want to write that, or an autocomplete or something like that, you might go out to a third party. Well there's a lot of them out there, here's a few just from a company I recently worked with that they considered. Prime Ng, Ng Bootstrap, Angular Material, then they were even looking at a specialized grid called ag-grid. A lot of other options out there, but this is where you can also, if you don't have any of these widgets I'll call them lined up as far as what you're going to use, this would be a good opportunity to discuss that. Now that we're at the end of this you can kind of see that if you could just take some time as a group to work through this, you'll be so much further ahead in planning the initial application architecture, the folder layout, the reuse of code. Now are you going to change? Absolutely, we're way too early in the blueprint process here, but this gives us some really simple guidance to start addressing some of these big areas of the nine I mentioned. And of course, you may have more than the 9, you might not even use all the 9, you might have 5, who knows, you might have 20. This is something your team needs to come up with, I'm just providing a basic template you can look at. So that's an example of actually using the template, and I hope that provides some food for thought there on what you can do with it.

The Angular Style Guide
In addition to coming up with your own architecture guidance and template that you can reuse across applications, I think the Angular style guide should also be something that should play a big role in this process. Now if you haven't looked at it before, you can go to the angular.io site, and specifically go to the docs and get to the style guide, you'll see a link here. But once you get there, this could provide some excellent guidance about a lot of different things that you'll want to factor in to your architecture. So for example, it'll have some coding conventions, some naming rules that you want to follow, very good to have consistency across your team, and if you ever have to involve outside contractors that are also working with your team, this is a big deal to have coding conventions and your naming rules all defined. It'll have your application structure, how that should work, or at least a recommendation on how that should work. How do we organize our modules? How do we create and work with components, and services, and even some information on lifecycle hooks? Now, let me jump over to it really quickly here and we'll just take a quick look, and then I'll talk about why I think it's important you should include this. So here's an example of the style guide at the time I recorded this, this will certainly change, and probably even the look of this page will change, but you'll notice on the left you can actually jump down to single responsibility info, naming conventions, and there's coding conventions. You'll see NgModules here. Move on down, components, and there's a lot of good info. Now some of this is really basic, you know, things that if you've done anything at all with Angular, and if you use the CLI, that it will do for you. But some other things you might not have come across before, and they're good to know, not only as an individual on a team, but as a team as a whole, especially a team that has to maintain their own apps, or even if you have to hand them off to production support, I mean let's face it, you've got to be nice to them too, so we want things to be consistent. Now what I recommend is in addition to going through your architecture and going through those nine items, or whatever items your team comes up with, I think every team should take the style guide, find things that maybe you want to tweak because there will be things that you may or may not agree with a 100%, it is a guide after all, and then publish those. In fact, if you could boil it down to the diffs between the style guide and what your team wants to do, maybe do a page or two, that would be perfect. Now as new team members come in, as team members switch teams or get on loan to another team, or go on vacation, or whatever it may be, or maybe working with contractors, everybody knows here's what we're doing, here's the plan. We've already gone through our architecture design guideline from a very high level again. We've now said what our style guide is, which will influence some of the architecture guidance and information we're going to record, and now everybody knows what direction we're going. You're not leaving things to chance, and hopefully, we can only hope, that will lead us to better maintenance down the road. So if you haven't looked through the style guide, I would highly recommend looking through that. Definitely something that should play a big role as you write your applications.

Other Considerations
I mentioned at the very beginning of the course that this particular course is all focused on the Angular coding aspect and that there's many other things we could take into consideration. So I want to acknowledge that here, if you are an architect you're probably saying at this point, hey Dan, that's great, like what you have we need to cover, but there's more to the story. So I wanted to go over just really quickly some of the other considerations that I would also factor in. These aren't necessarily code considerations, some of them are actually, but some of them aren't, so let's talk about them real quickly. One of the things that I think is important for any app, regardless if you have to do it by law or not, is accessibility as an example. Well if you're including accessibility in your app, this might be another design consideration, maybe even something that affects the architecture of your app potentially because there might be something specific you're doing to meet some of the WCAG guidelines out there. Maybe you're doing internationalization. Well this definitely could affect your architecture because now you have to have a way to load your different language resources and make sure they're getting in your components correctly and things like that, so that'd be another factor. What environments are you going to have? As you move the code between the environments, how are we doing that? That can get us into CI/CD, continuous integration, continuous deployment. How are we actually deploying the code to production, are we going to move to a CDN, a content delivery network? Are we're going to use containers and maybe Docker, or are we just deploying to a server? If you're interested in more on that, that's something I cover in my other Pluralsight course called Containerizing Angular Applications with Docker. But there's a lot of different options to consider there, and that's going to affect not so much the architecture of the code per se, but definitely the overall DevOps from kind of cradle to grave type of approach that you're going to take. What are you doing for unit testing? What are we using for unit testing? Are we using the built-in CLI tools, we can use the Karma test runner, things like that. What are we doing for end-to-end testing? Are we using Protractor, are we using Cypress? I personally use Cypress, I prefer that for my end-to-end type of tests, but there's a lot of different options out there. That might actually influence how you design your code as well because your end-to-end testers, if there's another team doing that, they may prefer to have IDs on some or maybe all of your tags to make them easier to find for the test, really depends on the group and how they like to work. What about your APIs on the back end? Well, obviously, we still have to talk about that and architect our back end as well, in fact I would argue a lot of the key work goes into there because that's where the true security happens, the true data validation, and more, so definitely something to consider. And then there's even other things we could talk about. The bottom line here is although we can't cover everything in this course, up to this point in the module, I hope you get an idea about some of the things that you should consider. Are there even more? Absolutely, every app is different, every company is different. But that's the point of this, come up with something that works for your team, your company, or you. Maybe you're just a contractor that works on your own and now you need to come up with this thought process, and that's really all this is, is a thought process with some documentation hopefully, but minimal, we're going to keep it to a minimum if we can. Now maybe you worked with a company where the concept of architecture means some big-time docs, and if that's the case that's great to have, but not every company, I realize, has that type of set up or even has that type of infrastructure or team available to them. So, hopefully what we've covered at this point will give you some ideas, some food for thought if you will.

Summary
The overall goal in this module was to create a thought process, a methodology that could be followed. Now, I showed what I like to use, and it's very simple, very to the point, and very efficient actually to get a team thinking about these different areas of an architecture that we should take into account for an app. So we talked about taking time to discuss and document these key architecture concepts and doing that up front. I mean, doing this after the fact, it's nice to have as documentation, but really you'll see this will save us quite a bit of time down the road if we think through these type of items up front. We also talked about creating a simple architecture template that can be reused across projects. Now if you already have that type of thing or maybe even have people that do the analysis and the initial architecture, you know more power to you, you're more ahead of most companies out there. Many teams are left to their own devices, they live on their own island, and expected to deliver on time while also delivering solid, maintainable applications. So by creating this template and having a very crisp and easy to think through process, I think that would go a long way towards helping to spec out your applications more thoroughly. And then we also talked about how you can take the Angular Style Guide, use that as maybe your foundation, come up with any differences that you're going to have on your team, publish those differences, and then make sure everybody on the team, and I again would involve other contractors if you're in that type of a scenario, so that they understand this is what we're doing. If you don't meet these guidelines, you shouldn't be checking in code, and then in code reviews, if you do those at work, we can very easily call out, hey, we're not meeting the style guide here so let's go fix that first and then come back. And that would give us some consistency across our team. Architecture itself is a very huge concept, and as I've mentioned a few times, there's just not one size fits all. Everybody has a different opinion, it's very subjective, and that's okay. But, by thinking through this, we can have a more solid app. Now what we're going to do moving forward in the modules that follow throughout the course is start diving into some of the different considerations from a code standpoint that you might want to make. Hopefully you've already gone through the analysis that I mentioned. You already have that ready to go, now we're going to start talking about things like organizing our features, our components, communication, state management, and more. So, let's continue onward.

Organizing Features and Modules
Introduction
Let's assume you've taken the time to go through the planning template mentioned earlier, and now you're ready to kick off the project and start actually adding some folders and some code. How are we going to do that? Well, of course, we're going to start off with the CLI, so we can do our ng new, and then we can create that project, but that's not going to give you a lot as far as folder structure and organizing the features and the modules that you might have in the application. So that's what we're going to talk about in this particular module of the course. We're going to start off by talking about how we can organize features and some general techniques. Now I'm going to go back to the style guide and mention a few things there, but I'll add a little bit of my opinion into the mix as we move along. From there we're going to talk about modules, and specifically how we organize modules and features. Now this is extremely important. In fact, this is one of the number one things that I see companies do wrong when they first start an app is they don't plan for this, and that blocks them from using potentially some other Angular features, as well as it can make maintenance a little bit more difficult. We're also going to talk about core and shared modules. Now these are directly from the style guide, and these are the recommended folders. However, we're going to talk about that you certainly can rename them if you want, but more importantly we're going to talk about, what do you use these for? And what would you put in and what wouldn't you put in these different folders? Then we're going to wrap up with talking about custom libraries. You might have some shared widgets, we'll call them, but the shared widgets might be shareable across multiple applications throughout your company. Fortunately, the CLI makes creating a custom library a very straightforward process now, so we're going to talk about how to do that, and then we'll wrap up by talking about how we could consume that custom library, and even publish it to npm or maybe a local private npm that you might have within your company. So let's go ahead and jump right into our discussion of organizing features and kicking off our project.

Organizing Features
I think one of the biggest factors that affect a solid Angular architecture is how we organize our features of the application. Now, some of the applications you may be working on maybe just have a handful of features, and it's really not that hard to think about, while others may have many features, and that's where we really do need to think about not only how we structure the features, but how we structure the child components within those, the modules, and more. So let's start off by talking about how we organize the features. Now as mentioned, we could have many features in an app. We could say that each of these LEGO blocks is a feature, and we want to make sure that we organize these in a way that it's easier to work with, as I've already mentioned a few times up to this point. Now, if you go look at the style guide, they have the following statement that they'll say: Do structure the app such that you can locate code quickly, identify the code at a glance, keep the flattest structure you can, and try to be DRY. Do not repeat yourself, in other words. Now, if we break that down, we can call this LIFT, and the L, of course, is locate code quickly. Well, we want to be able to go into our editor, locate that code very quickly, and not have to be digging around a lot, and especially not having to dig through a ton of folders to get to it. Now, one of the things that's kind of funny here is we could argue for ages as developers about the best way to structure this code, and ultimately once it builds and we get our bundles, it just doesn't matter. I seriously doubt one of your users is going to come to you and say, hey Jim, how did you structure your folders that ultimately led to the production version of this app? I mean, it's just not going to happen unless, I suppose, they're technical. But this will be something we'll talk about a little bit more. Now the second part, the I, identify the code at a glance, this is going to relate to how we name our files. Now, of course, if you've done any Angular at all, you'll know components have the word component in the name, services have the word service, route guards oftentimes have the word guard, and so on and so forth. So while the names are a little bit longer, it makes it really easy to identify what's in that file just at a glance. Next up is the F in LIFT. Keep the flattest structure you can. I'm going to talk more to that at the end of this section. I went down a road of a little deeply nested type of hierarchy and regretted it. So I'll talk about that experience as we move along here. And then finally, try to be DRY, do not repeat yourself. Now fortunately, Angular being a framework really helps us out here by offering things like services. Of course, we can reuse those services in many different ways. We can reuse components and directives. So if you architect and design your app appropriately, you get that solid blueprint in place, then DRY should be kind of a no-brainer, as long as you plan it right. Now, there's really two ways we could organize code though, of course there's never just one way, and that is we could use convention-based or feature-based. Now, let's start with convention-based. This is something that many companies or many developers are kind of used to. If you've ever done, for instance, the model-view-controller, or MVC, pattern before, many of the frameworks out there use convention-based, and convention-based plays a huge role, even in Angular potentially. But when it comes to organizing your code, and specifically your features, I would not recommend, and the style guide will agree with me here, that you organize them by convention. In other words, don't have a folder called components where you just dump all your components and a folder called services where you dump all your services. That will work, you can certainly make it happen, but with components, now our view or template would be completely separate, our CSS would be separate, and now you're going to be digging around a little bit more. Now I've heard people argue, yeah Dan, but if you open up all those files as tabs in the editor, it's not a big deal. Yeah, but at some point you've got to close those tabs, so then you've got to reopen them, and that's why we're going to go with a feature-based. But convention-based may actually play a small role. You might have a feature folder called customers, and then under that, maybe you have a ton of components that are children, part of that feature. Well, if you have too many of those, then you could certainly make a subfolder called components and put them in there. Now that's optional. It adds one layer of nesting when it comes to our ES2015 import statements. However, it would work, so something to think about. The downside of convention is it typically results in a lot of files in a single folder, such as a components or services folder, but would it work? Yes. Now, the recommended approach, of course, is the feature-based, and this is what the CLI will do by default. Features are all organized into their own folder, they're all self-contained, we're going to talk more about that, that's going to play a role with routing and modules and more, and everything's pretty easy to find for that given feature, so the bottom line is the recommendation, and I can definitely back this up myself, having seen many apps over the years now at various companies, feature-based is a great way to go. Now, when it comes to organizing the features, here's a little bit more info. So first off, use a feature-based approach, as we just discussed. Second, use the Angular CLI. It's going to help you out here tremendously. Sure, it has a way to flatten out structures and not make subfolders if you want, but by default, especially for your top-level features, you could just use the CLI to kind of whip those out very quickly. Now from there, we're going to talk more about modules coming up next, but for me, I have a minimum of one module per feature that I'm going to add as appropriate. Every situation is different, but in general, I have one module per feature, and that is a very good approach to follow. That's going to set you up for lazy loading. That's going to set your feature up to be self-contained so it just can be imported in, for instance, the root module or some other feature if needed. And also, it just makes it so it's good for maintenance. Everything's self-contained and we can leverage all the cool Angular features. Now you also want to avoid deeply nested folders, and you want to flatten feature hierarchies. So let's talk about that a little more, actually. So, here is an example of at least the top level type of features, if you will, in an app. Now, this was for a video labs-type course that I do with companies, and the course was the root feature, and then I had a lab under that, and then labs had exercises, exercises had steps, and items and things like that. And this is the road I went down initially, I went through this for several months, actually, and it finally got to the point where typing.. /,.. /,..., you know, all the way up was just a mess. Now yes, VS Code and WebStorm and other editors will help you with your imports, but any time we refactored something, it was just too painful. So, the recommendation in the style guide is flatten your structure. Now here is today, actually as I'm recording this, what it would look like, and you'll notice that course is still there, that's the root feature, but notice that exercise, items, and lab have all been moved as top level. So I really avoided a lot of nested hierarchies. Now, the one on the right here does not mirror the exact application, because the app does have a hierarchy, but it is immensely easier to find things, maintenance is much easier, and it's just a win all the way around. So I highly recommend stick with what the style guide says at this link here, and flatten out your top-level features as much as possible. And if you have nested features, that's okay. You might have sub-features, of course, within a feature, but just be careful on how deeply nested you make those. You'll thank yourself in the end because your imports will be easier, refactoring's going to be easier, and things will be easier to find as far as the code is concerned.

Feature Modules
In the previous section we talked about how we can organize our code in the feature-based approach, so now we're going to talk a little bit more about features, but specifically focus on modules and the role they can play in our Angular architecture and applications. Now, if you go to the style guide, you'll see a link here for feature modules, and they give you a lot of information. I'm going to walk through what they say, and then I'll add in my own opinion here as we work with these feature modules. So, let's go back to our original application architecture template and the example I gave of customers and orders, and let's assume that we do have a customers feature and we also have maybe an orders feature as well. How are we going to do that? Well, first off we would do ng g c, and we would name it Customers, probably, and that would add the subfolder Customers at the top level. Now what do we do from there though? Well, this is where a lot of people kind of stop and they end up adding this feature into the root module. And while there's nothing wrong with that, as the app grows and grows and you get more features, now you have one module, so you can't use lazy loading, and the feature is no longer self-contained, so if that feature gets more complex into the future based on maybe change requests, then we have a little bit more of a challenge now because whoever owns the root module on the team kind of needs to know about this feature as well, and that's really not how it should be. So, at a minimum I mentioned I have one module per feature, but oftentimes I have two because a feature oftentimes has routing, and so I'll have my feature routes defined within a module in the feature itself. So in this case it'd be customers.routing .module .ts, and then of course that would be imported into the module for this feature, which would be customers.module .ts. Now, you may have other modules as well if you have more complex sub-features, because you might actually want those to be self-contained. Maybe a portion of your team is working on those, for example, and whoever owns the root customers module, maybe you don't want them knowing about all the sub-features. You want to keep it as separate as possible so that it's easier to maintain and it's self-contained. Now likewise if we had orders, I would do the same thing. We're probably going to have some routes for orders, so I would put those in the orders feature routing module. That would then be imported into the feature module itself, which would be orders.module .ts. And we would kind of go from there. Now, the benefits of doing this are many fold, but one of the biggest benefits is by having self-contained features, we can now have different members of a team work on a given feature and pretty much own that feature. They are in charge of the routing. They're in charge of any services needed by this. Now, if I was the team lead, and let's say my job is to import the customers module into the root module, the app module, then I no longer have to know any details about that feature. Now the exception would be if we lazy load the module. Now, that certainly would mean I'd have to define the route if I owned the root module. But aside from that, any child routes or sub-modules that are in the customers module, I would know nothing about. I simply import that and I'm good to go. Now likewise, we could divide up the orders feature and maybe some different team members take on that one, and it's also self-contained, can be updated independently of these other features and these modules. Now, this is the area I mentioned. I've seen a lot of companies, especially when they're new to Angular, put everything into the root module. And while that works, there's nothing wrong with it, long term I think you'll probably regret it because number one, you'd have to refactor it into this approach I'm showing you here if you want to lazy load, but number two, the feature's just not self-contained if you do that. And anytime we could have a single responsibility in our application, that's a good thing. So that would be the recommendation for our self-contained feature modules. Now let's jump over to the application we've been talking about that has customers and orders, and let's just take a quick look at what it does. So, jumping over to the editor, you'll see the app here, and the main features are customer, customers, login, and orders. Now, you'll notice there's an about. Let's start there because it's a really simple feature. Well, if I open that up, you'll notice that it has its own routing. Now this one happens to be lazy loaded, which is why the path is empty. You'll also notice, though, that it has its own module, about.module, and that imports the routing module. Now, something I like to do oftentimes with my routing modules is, I have already imported my components for my different routes, so oftentimes I'll add a static property, I just call it components, into my routing module. That way in the feature module, I can just do this. I no longer have to re-import all those. And oftentimes, even if there's child routes, we'll have those components in this routing module, of course, so I'll just add them to the array and then we can just merge that into our declarations in that feature module. Now, this one's lazy loaded, but if it wasn't, we of course would then have to import that into our root module, and you'll see that it's not here, and that's because it's going to be lazy loaded. So you'll notice here's our about, there's our loadChildren, and because we have modules for all of these, I can lazy load all these different modules. That's a good thing. Just really quickly to recap this, we're going to see the same thing in customer. Here's the child components we'll talk about later, but here's my customer-routing for this. Now this one has some child routes we'll get into. Here's my customer.module that then loads that. Notice how simple it is. And I just repeat and rinse and repeat and rinse. I repeat this pattern over and over. Here's my routes for customers, and those get imported into my customers module. And then the same thing's going to happen for login and for orders. Do you have to do it this way? Well hopefully by now in the course you'll know the answer is no. Dan does not believe in one size fits all. I always joke, try going into a shoe store and saying I'd like to buy some shoes, and when they ask you what size, just say, oh, it doesn't matter. One size fits all. And they're probably going to laugh at you, right? Well, shoes are no different than applications and architectures, everything's different. I think, though, if you go with this approach from the start and then modify as needed, you'll set yourself up very, very well for success.

Core and Shared Modules
In the previous section we looked at feature modules and how at a minimum we'll normally have one module per feature, but how we could have multiple modules potentially, especially once you add in routing and maybe some larger sub-features. Now we're going to switch gears to more of the reusable code in an app, the DRY code, if you will, the do not repeat yourself. We're going to talk about the core and the shared modules. Now, if you've already done a lot with Angular, you're probably pretty familiar with these, but I'm going to talk through my opinion and what I'm seeing out there with many different companies and developers on what they're used for and what they're not used for. So before we jump into the application and look at some of the code, let's first talk through the core and the shared modules and what their purpose is. Core really is designed for your singleton type of services. Anything that would be shared throughout the app, and obviously any singleton would be good for that. Now, core isn't only for singleton services, though, and this is where things can get a little bit subjective, a little bit gray, and I'll talk about what I like to do there in just a moment. Services that are specific to a feature. For instance, maybe we have an order service and the orders feature is the only one that's going to use that. Then oftentimes in that case, I would make a subfolder, call it services, put that in your feature, and then that particular service would just be imported or provided directly into the feature module. Now, that makes a lot of sense to do if that particular service is not going to be reused elsewhere or injected elsewhere throughout your application. So keep that in mind, there's nothing wrong with putting services in a given feature. Now, some examples of these would be the LoggingService we talked about. You might have an ErrorService that just intercepts errors in general. You might have some type of a DataService specific to maybe customers and one specific to orders, and on and on and on. Now, do we have to call it core? No, I've seen a few people call it common, and even seen a few other names. You may not like the name core, and obviously that doesn't matter. What I think matters is, is the team all on the same page so that if you get a new hire, if you have contractors, if somebody leaves on vacation and you have to maintain their code for a while, does everybody know what's going on? And that's what really matters here, not so much the name. Now, when it comes to shared functionality, this is your shared module, of course, and this one's a little more intuitive to most people, even if they are new to Angular in general. Now, as it says here, we're going to have our reusable components, pipes, and directives, so that's the type of thing that's going to go in there, and some examples would be your CalendarComponent, maybe an AutoComplete that you wrote. If you wrote any custom grid maybe that's reused throughout your app, that could go in here as well. Now an important distinguishing factor of this is will the widget, if you will, we'll just kind of classify components, pipes, and directives as a widget of some sort, will it be only used in this app, or could it be used across apps? Is it so generic that you could reuse it over and over and over across applications? Well if that's the case, don't put it in shared. That's when we'd want to talk about creating an Angular library, which we'll be talking about coming up here. Now, when it comes to working with these modules, shared would normally be imported potentially multiple times. It might be imported into the root because maybe the root component needs something in here. It might be imported into, for instance, the customers feature because it needs something in here, or any other feature for that matter. So shared would be imported many times. Core, on the other hand, should only be imported once, and that should only happen into the root or app module.

Core and Shared in Action
Now, you could leave it up to your team to make sure that core isn't reimported somewhere else other than the root module, but if you read the style guide, they actually have a short little function, a little bit of trickery you can do, to make sure core's only imported once at the root level. Here's what it looks like. So in the docs you'll see this throwIfAlreadyLoaded, and this is a direct copy from the style guide. And you'll notice it takes a parent module as the first parameter, and then the name of the module we're monitoring as the second. Now that on its own isn't super exciting, you can see that if there is a parent module, if that's truthy, then in this case that's bad, we're going to throw an error and give some information. Now here's how we would use it, and this is where it gets interesting. First off, notice we're going to import this file called import.guard, of course you can name that whatever you want, and in the CoreModule constructor, you'll notice a very interesting use of decorators here, Optional, SkipSelf, and then we have this parentModule of type CoreModule. Now we know that's dependency injection, so what this is going to do is first off say, Optional means it's okay if there's nothing for this to inject. That's fine, it's optional. SkipSelf is going to say, go to the parent injector, this influences the DI system, the dependency injection system, and it says go to the parent injector and see if we can inject a core module. And that's why we're skipping self going up to the parent. Now, when this happens at runtime, we hope this parent module doesn't exist. We hope that when core is injected that there is no parent module at this point. That would be where optional kicks in. It's okay if there's not. In fact, that's what we want. Because if there is, parent module then gets passed to throwIfAlreadyLoaded up top here like this, and now if there is a parent module we throw the error. Now that's how we would detect if someone else imported core into another module, such as a feature module, which is what we don't want here. So it's a little bit tricky, but again, the optional means it's okay if there's nothing here for the dependency injection, it's optional for the DI. And the SkipSelf means, go to the parent injector to try to get this. If it's found, that's a bad thing. That means it's been imported, and it didn't come from the root. Now, I like to use an alternative approach, and this is for some of the companies I've worked with, what they've gone with as well. So I have this class called EnsureModuleLoadedOnceGuard, and it takes the target module, and then if there is one, throws the error. It's a little more dynamic, you'll see. I grab targetModule.constructor .name. So, this would provide just a really simple way to do exactly what the function shown previously here up top actually does, except for I've wrapped it inside of a class. Now, what you would do then is on your module, such as CoreModule, you can then go in and extend it. The constructor part stays exactly the same. Really, the only thing I change is the call to super here, and I pass in the parent module. Now if there is a module, that's bad. That means core was already imported from some other level, and we don't want that, so then that would trigger my error back here. These two options, either one works, they do exactly the same thing. But, regardless of which way you choose, this is a good approach to take because now you don't have team members just leaving it up to chance that nobody accidentally imports it multiple times. Instead, it would just be imported one time, and that would always be at the root. Now the reason I like the class is I actually have other modules I do this to as well that I only want to be loaded in one particular area, such as the root. So then I can just extend it and add something like this, and it's very easy, but to be honest, it'd be just as easy to do the function. Pick your poison. Whichever one you like better, you could go with. But hopefully if you have seen this and wondered about the optional and the SkipSelf and what it's actually doing, hopefully that explanation helps a little bit. To wrap this section up, let's jump into the customers and orders app really quickly here and take a look at this particular feature, as well as how shared is being used, and talk through some other things. So when I go into the application, you'll notice here's my core. If I go into core.module, you'll see I extend my EnsureModuleLoadedOnceGuard, and then there's my Optional and my SkipSelf. Now, this will cause the dependency injection to occur. If it finds it, that means it's already been defined and imported somewhere else, and that would cause our error to be thrown. The rest of this, though, I want to talk through really quickly. You'll notice looking through the folders here that I do have my services. That's what most people would say goes in core. I even have some preload strategies for lazy loading in here. That's fine to put in core because technically those are just services. But you'll also notice I have some components in here, and that one is a little bit subjective. So, the reason these are here is if I go into our root component and go into the template, you'll notice I have the navbar defined there, a growler, which is a type of toast message, a modal dialog that's reusable throughout the whole app, and an overlay, which provides a spinner effect any time there's a request to the server. And when the response comes back, it'll of course hide the spinner automatically. Now, these particular components I only want to be used one single time in the app. Now there's no way to technically prevent people from using them somewhere else, so what I do is I put them in core because to me, they're almost like singletons. Now, they don't have to be, but by putting them here, it's a convention I like to follow, and several other people I know, several companies, follow this same convention where anything that's in core would be used one time in the application, kind of like a singleton. Now as mentioned with components, that's not really the case. But by having them here, as long as team members know that core is for our single usage type of scenarios, then they should know they should never ever go in and add the selectors for these in multiple places in the application. Now, that's where it gets very subjective. Some people may say, no Dan, you should put those in shared. If the whole team's on board with that, I don't really care, and it really doesn't matter. What matters is, I've provided a way to define via convention that anything in core should only be used once. But if you don't like that, that's okay. Not going to hurt my feelings at all. Now, going down into shared, you'll see the kind of normal things down here. We have some directives, some components. Here's our Google Map component. That's used multiple times in the app, the selector. So it goes in shared. Same thing with pagination, same with the pipes. All these could be reused many times throughout the app. That's why they're in shared. Now again, how you do that is totally up to you, but that's the approach I like to take. I know several companies that follow this, and I know some who don't, so really what matters, I think, is that all of your team is on the same page, you've documented this, so if new hires come in, they get it. If contractors come in, they get it. And everybody's on the same page when it comes to maintenance down the road. Now if we go look at core again, you're going to notice in here this is where I import some other modules. In fact, Growler, Modal, and Overlay, you'll notice, have their own modules. Now, why did I do that? They're already in core. Well, because they have multiple things going on. Anytime I have that, I want it to be self-contained, and it also would give the option to just import Growler on its own if it wasn't in core. Now in this case I only want it once, which is why I loaded it into core, and you can think of these as submodules. Now, you can obviously go crazy with this, and I wouldn't recommend having just tons of nested modules, but in cases where you have some features that need to be self-contained so you can develop them on their own and even test them and use them on their own, then this makes a lot of sense. If it was a more simple thing, I would just import it into core directly and call it good. But this way, the Growler module, for instance, if we go into that, it's responsible for all the imports it needs, in this case just Common, but it also exports and declares any components it needs. Same thing for Modal, same thing for Navbar, and you get the idea here. So, that would be an example of core and shared in the application, and I hope if you haven't worked with some of these other things we've talked through that you have a better idea, number one, why we would use those two folders, number two, what goes in those two folders, and, again, there's a little gray area there. And then number three, we talked about how you can even prevent certain modules, like core, from actually being imported where it shouldn't be imported.

Creating a Custom Library
As you're doing your initial planning on your Angular architecture, you may determine that one of your shared items needs to be shared across multiple applications. You want to put it up in npm, for example, or maybe in an internal npm that your company may use. That way, multiple applications could take advantage of it. Well in the past, doing that was possible, but it was a little more challenging. There was a lot of hoops you had to jump through. Fortunately, this is very simple now due to a feature that's been added to the Angular CLI, starting with Angular 6 or higher. And we're going to talk about that now, and talk about the process of creating and publishing a custom library. To get started doing this, you'll first need to create a new project using the CLI. We're all pretty good at that at this point. From there though, we're going to use a command that the CLI provides in Angular 6 or higher, which is an ng generate. And this ng generate library is specific to creating a custom shared library. You'll see that we then give that library a name, and what that's going to do is add a separate project into what's called a workspace. When you do ng new, you get a workspace with one project in it, which is your web project, if you will, your Angular project. This will add a secondary one into the workspace so that we can actually test out our library in the Angular app without publishing to npm or some other resource out there. Now, what this does is it's going to modify a tsconfig file, and that's going to be updated so that the Angular project, the separate one in the workspace, understands how to get to the library, the shared library that we're going to be building. Then what you can do is build your library using this ng build command, and then give it the name of your project. Now you could use it and test it directly in the other Angular project that's within your workspace. So it makes it really easy to do this without having to publish into npm somewhere. Now once we've done that, we would want to publish to npm once we're ready to go, we've tested it out and it looks good, because we want to be able to pull in from npm, whether it's the npm that's just out there that anybody can get to, or if it's an internal npm you may have at your company, we want to pull from those into our different applications so we can get reuse. Now, there's a link at the bottom here if you're new to contributing to npm that's out there, and what we're going to do then is we're first going to build our library We'll then cd into the dist folder, and there will be a packaged.json file included. That's going to be used to then publish up to npm. Now if you're publishing up to the normal npm, you'll have to log in and you'd have to have an account, of course, to do that, and then you could publish your package up there, and then anyone could then pull it down into their application. If you're publishing to a local npm, then you'll of course need to get more details on that process, and there will be a little bit more you would have to put here based on the path to that npm server that might be internal to your company. So now that we've seen how to create the shared library with the CLI, let's try this out. The first thing we're going to do is create a new project with ng new, so let's go ahead and do that. We'll just call it my-project, and I'll go through the little wizard here. Now through the magic of video, I'll speed up the npm process for you. So it looks like that completed successfully, and now if I list what's in here, there's my project. So I'm going to cd into that. We'll clear that screen, and now we're going to do ng generate. I'm just going to do g, and library, and we'll just call it, maybe our company was Acme Corporation or something, so we'll call it acme-shared. And we'll hit Enter. Now this is going to scaffold out an entirely new project, which is the library project. You'll notice it made a new folder called projects here. Now that that's done, let me go ahead and do code. to open this in VS Code, and let's take a look at some of the modifications it made. So first off, you'll notice that we have a projects folder. We also now have an updated tsconfig. It added the paths to where ultimately we're going to be building our dist folder once we do a build, and that's why you have to build first before you can do this because TypeScript is actually going to look here to be able to make this all work. Now the other big thing that's been done is our angular.json file has a new project in it. So we have our workspace up top, which has our projects. Here's the Angular project itself, but then it added a secondary project right here, which is our acme-shared, and you'll notice the path there for the root of the project. Now everything else needed to build and test and all of that is included. So those are the main things it modifies. Now what we can do from here is go mess with our library. So if we come on in, you'll see some normal files in here, and a src folder, and then what they add is a lib. Now the lib is going to have our component, our module, and even a service if you want it. Now these are pretty empty at this point. If we open up the component, it pretty much just says acme-shared works. I'm going to add really, really well just so we know it's truly working. Now of course this is where you'd go in and add one or more components that you want to work with. They add one by default. We can certainly add many into this shared library. Now notice the selector here, lib-acme-shared. Now you can certainly change that, but that's something we're going to need, because ultimately what I want to do is go back into my Angular project and use this shared library component. Let's take a look at how we can do that.

Consuming a Custom Library
Let's take a look now at how we can consume our shared library. So I'm going to go back into the app.component .html, I'm going to delete most of what they put here, let's add a br, and then we're going to add our shared library tag. Now you'll notice this goes red. Well, that's because, of course, we haven't imported the shared library module. So that's easy to fix, we can go back to app.module and we'll put a comma here, and because I called this library acme-shared, it should be AcmeSharedModule. And there it is. Now watch what gets imported here. You'll notice projects/acme-shared/src/public_api. Now what they've done is created what we typically called, especially back in the old days, a barrel, and they're exporting what's inside of this particular shared component. This is the public API service, as it says. And notice that the shared module is one of the things they're exporting. So that's why it's referring back to that path there. While that works, we don't want to have to constantly change this. Especially once we publish this package to .mpm. So, we can just take the name of our package which will ultimately be AcmeShared and put that there as well, and that's actually going to get the job done for us. Now what they're doing is a little magic behind the scenes to make it so it knows how to get those exports that i mentioned earlier. Now that will be enough, though to allow us to test this. So if we go back and we just put a space and backspace here to trigger the language service to update, there we go, notice the red now goes away. So now we're ready to go. I can come in and we can first try to run the project like this, but we would get an error because there's no dist folder yet for our shared library. So the first thing we want to do is we want to do an ng build, and then we want to build our acme-shared project, not the root project. So let's go ahead and do that first and that'll get that taken care of. Alright, so that's looking good. Now, the next thing we're going to do is just a regular ng serve -o. That now launches my project, and there we have it. There's my acme-shared works really, really well, and we're ready to go here. So what's so nice about this is now, with just a minimal amount of effort, literally in a matter of minutes, you can get a shared library up and running. The final step would be to actually publish to npm. Now, I'd have to log in to do this, but in general we'd do an npm publish. We would do that though in the proper folder. You'll notice if I go up to dist, we now have an acme-shared up here because I didn't do an ng build on my core project, and in there is a package.json. Now you'll notice in the package.json, that's going to be the name of the project that would be published. This would be the version that we're publishing, and then we have some other information that's needed in here, and of course you could even put some other properties, like who the author is and things along those lines. Once you're in that particular folder, let me go ahead and just jump in there, now we would do the npm publish. In this case, as I mentioned, if I try to do a publish here, it's going to say auth is required because I haven't logged in, but that's all we would do, whether it's the regular npm that everybody can hit, or if it's an internal npm. And I showed a link earlier if you're interested in more details about contributing to the regular, global npm that's out there. Now if you're using an internal one, you'll have to talk to whoever manages that to get the information about how to publish to that. But it'd be a very simple process, assuming it's all set up for you. So that would be an example of creating and then publishing an actual shared library project. Very, very useful, very easy to get started with now, especially compared to the old days. So now as you're doing that initial planning in your template that I showed earlier in the course, you can say, well, these particular widgets, we'll call them, are going to be used by many of our apps, so let's just plan on making a library rather than putting them in the shared folder of the app and then having to copy and paste between applications. Now we just do an npm install of our custom shared package and we're ready to go.

Putting All the Modules Together
Now that we've talked through different types of modules, including feature, core, shared, and library modules, let's wrap up here by putting them all together and talking about different scenarios where some modules may have some variability. So let's say on the left here that these are the main things we're concerned about. We have some widgets in the application, this might be things like menus or calendars or an autocomplete or something like that. We have our feature or child components. We have services. We have components that might be associated with a route. We have pipes, and there could even be possibly more, but these would be the key things. Now, let's start with widgets. Where would widgets go? And the answer is, it really depends. Now I think you'll probably say it goes down to shared, and that would be a correct answer in many cases. But if a given widget is only used by a feature, then we would probably import it directly into that feature. And that's where things get a little bit subjective. The feature and child components, this one's pretty easy. If it's a feature component, obviously it's going to go into the feature module. If it's a child component for a given feature, of course it'll go there as well. Now what about services? Well, if the service is reusable, then we'll of course want to put that into our core module. That's what it's for. But if that particular service is only used by the feature module, we'll probably want to move that file into that particular feature module area. Now, components that would be called routed components, these would be, for instance, your features typically. Well, we're going to define the path that routes to that given component in a routing module. Oftentimes that routing module will be part of the feature module and actually imported into the feature module. The last one, pipes, where would those be used? Well again, we can put those in shared, that would be the most logical place, but if you did have a scenario where a given feature is using a pipe and it's the only feature that needs it, then, of course, you might actually load that into the feature module. Now, when it comes to exporting, which of these would we probably export from? Well, a feature normally is a standalone, and it'll just be imported into the root, and the root doesn't really have to know anything about it, so we probably won't export many things, if ever, out of a feature module. Routing module, well, typically we will import our routing functionality and then export that, but that's about it. Core module. Well, core is only going to be imported into our root module, which we'll talk about in a moment again. So that one probably won't have really any exports. The exception to that would be if you put single-use components, such as a menu that should be used one time in the entire app into core, like I showed earlier. Now if you do that, you'll of course have to export that particular component, and any others that are single-use components in core. And then finally, shared. Now shared is the one that almost always will have some exports, because otherwise, it wouldn't be shareable, of course. If we imported shared into a feature module up top, for example, and we didn't export anything, then of course we couldn't get to it. So shared will be your main one that's going to have exports. Is it possible for a feature to have them? Absolutely. You may have a feature that's kind of a sub-feature, we'll call it, that's going to be self-responsible, exporting what it needs to, and then maybe that module is imported into the feature module itself. So putting all of the modules together, we'll have our root module. We know we're going to have core for our singleton-type objects. We're going to have our shared functionality. Now, we'll then have our features. A feature module will typically have its own routing module. That way it's self-contained again. Any child components and potentially any child modules, especially in a larger feature, would also be defined in this and imported. Then we might have another one like orders, and it would have its own routing module. Now the last piece that we talked about would be the shared library. Of course shared libraries would need to be imported into the project through an npm install, and oftentimes they'll be imported into the shared module, but it may be that a shared library feature is only used by a given feature, like Customers module. So import it where it's needed, of course. That would be a quick look at putting all of this together, and that's why I took the time earlier in the course to go through some of the planning template functionality that you can do so that you start to think through these different things. Now, is what I'm presenting here the only way? Well, I've probably said it at least five times up to this point: no. There's never one right way. What the right way is is what your team decides the right way is. Now I think this is a good starting point, but you might certainly tweak it and come up with something that's a little bit different for your team. As long as everybody's in agreement, I think that's a great way to go.

Summary
We've covered a lot of ground in this module, so let's wrap up with a quick review. First off we talked about using a feature-based approach over a convention-based. Now I mentioned that you may still use a convention-based approach, maybe for some of the child components, for example, within a feature, but I would definitely recommend using a feature-based approach for your top level and your child components themselves. Now, how you organize as you get deeper is certainly up to you. There's no specific guidance there. However, do something that's not too deeply nested. Keep things as flat as possible and you'll be happy in the end that you made that choice. We also want to take time to plan our features, and specifically our modules in our features. If we do, we can leverage lazy loading down the road if we need to in the application. We can have different members of a team own that feature, and that's because the feature would be self-responsible, self-contained, if you will. So it's really, really important to plan this out. I mentioned earlier that this is one of the areas where I see a lot of people jump in, especially when they're newer to Angular. They don't really know about modules at that point, and they put everything in the root module. And while that works, now if they want to do some more fancy things down the road or they want to divide the team up and make it completely self-contained, they have to re-think through that to get the modules set up properly. Now, I always have one module per feature, and as I mentioned earlier as well, as appropriate. I'm not going to say that that is always going to be the case. There's never one size fits all, again. But in general, that's what I shoot for. Now, normally I have two modules per feature, because I'll have my routing module. That will be loaded into the feature module, and then of course the feature module either gets lazy loaded or is loaded into the root module. So that's another thing I think you'll want to talk through, either with yourself if you're a single developer or with your team, to make sure everybody's on board with how are we going to do this. Now, we also talked about core and shared modules. Core typically is for services, but I mentioned I even like to put my single-use components in that area. You certainly don't have to name it core, as mentioned, but this is what the style guide recommends. It's what I use, and I think it makes sense. Any of your components, your pipes, your directives, things that'll be reused throughout the app many times potentially, those, of course, would go into your shared module. From there we wrapped up by talking about the Angular CLI and how it can be used to create a custom library with Angular 6 or higher. A really, really cool feature that makes it super easy to do so that now you can publish these up to npm, or your internal npm, and it makes it much easier now to share these in an enterprise scenario where you have a lot of applications that might need this functionality. So I hope that gives you a good idea about the process of working with features and modules, our services and how to organize those, and our shared functionality. Now we're going to move in and start diving more into some code and start talking about things like structuring our components, a little later we'll get into communicating, and more.

Structuring Components
Introduction
A big part of our job as Angular developers is creating components. We do that a lot, that's obviously one of the core aspects that's part of Angular. So in this module, we're going to specifically focus on different techniques you can follow for structuring components. Now, I hope that if you've done a lot with Angular up to this point that some of these concepts you have either used or have heard about, and if you haven't done Angular, I hope to fill in some of the gaps there for you. But as we go along, if you have seen something, feel free to skip on ahead, and we'll kind of go from there. So let's jump on in to the agenda. So we're going to start off by talking about a pattern called container presentation, and this is a way to structure your components in cases where you have a lot of functionality and you need to keep it clean and maintainable. Now from there, we're going to talk about passing state between components, and this is one of those areas you've hopefully worked with, but if not, we'll quickly review it, and that is input and output properties, and I'm going to show how that works, but I'm also going to talk about some scenarios where this might be a little bit challenging. From there, we're going to keep going along this train of thought and talk about change detection strategies that child or presentation components can have. We'll look at reference versus value types as you're passing data and wanting to intercept when changes occur in a child component using ngOnChanges, there's some challenges that can come up there we'll cover. That's going to relate to cloning of our data, and so we're going to talk about some cloning techniques that you could use. Then finally, we're going to wrap up with a lesser used feature, but something that on occasion could be appropriate, and we'll address the pros and cons of it with component inheritance. So let's get started by talking about container and presentation components.

Container and Presentation Components
How big do you make your components? Do you make one that has everything in it that represents the entire page? Do you add child components? Do you do a mix of that? And probably the answer for everybody is we do a mix of that, typically. I have heard of some scenarios where you have multi-thousand-line components, and I think that would definitely be going way overboard. So, we're going to talk about different techniques for structuring components, and while you may have done some of these, you may or may not have called them after the official pattern that we're going to discuss here, which is the container presentation pattern. Now most of us when we get started with Angular start out writing a simple component. We do ng generate component, or ng g c, give it a name, that gives us our HTML template, our CSS or Sass or LESS, whatever you picked there, and we're kind of ready to go. Now, if you're newer to this world and you come from a page mode of thinking, which if you've done a lot with the web and server-side rendering, we typically think there in terms of the page. Of course in Angular, we know we think more in terms of LEGO blocks that we want to snap together. Now, as we start out, we can have our feature component, which might be this simple component here, maybe a customer component, or customers, as an example, and we start adding the functionality, and then over time that starts to grow and grow, and before you know it, it's out of control. So then we break it down, we make a more complex component that would have some child components, pretty standard, and very easy to work with. We're going to talk about some different things we can do with this approach here. Really if you want to be a little more formal on naming this second type of complex type component, we can call this a container presentation component if you do a few things. First off, if that container component is 100% responsible for managing the state, in other words it interacts with a service or some type of a store, whatever it may be, to get the data, it's the boss, it's the manager. And if you then pass that data down to the children, which we're going to call presentational components, then this is the container presentation pattern. Now, the reason I kind of emphasized this is some folks may do this, but the child might actually go get its own data. What this pattern says is, let's get the data from one starting point, that's our container, it's responsible for retrieving the state. Let's then hand that data down to our child components, and they're going to be responsible 100% for presenting the data, but that's it. They don't know how to get the data, they don't know how to interact with the store, they're just presentational components. That's why we have this name. Now this is a great pattern to follow, especially when you have more complex components that you want to divide up. Where I think from an architecture standpoint some people get in trouble is they start mixing and matching who gets the data. And now before you know it, you have a presentation component and a container, or the parent we could call it, both getting data, and now you or somebody down the road has to maintain this app, it's a lot more complex and more involved to know where this data comes from. Now you kind of have to go look at the code in multiple places, and it gets a little more challenging. So the general idea here is the container always gets the data, it may possibly render some as well, it may render a heading, for instance, in the container component, but what it will do is for the more involved type of presentational type things, we're going to hand that data down. Now obviously if you're currently working with components that are very large, even if you just added some child components, that would be a good first step, but as you're doing that, from an architecture standpoint, let's try to do this container presentation approach where we only get the data from one spot, it acts as the boss of the data, if you will. Now it's going to of course delegate as mentioned in the upper bubble here to a service or store, it's not going to know how to maybe call a RESTful service, but it is going to know about the service or store that it wants to interact with. By breaking your components down this way, even if you're not doing the container presentation, and instead you need to break up a complex component in the children, then this sets you up really well for child routes as well. So you might have a toolbar, or a tabbed interface, or something like that where when they go to customers/44, that might automatically load the customer component in this case. The customer component then might have a child, CustomerEdit, and that child route might look like this, as you can see. So, by breaking that functionality out, even if you just have the child component, you would have more flexibility down the road to load that child component dynamically, and that would be done through a child route, of course. Likewise, if we go to customers/44 for the ID, /details, that might load this CustomerDetails component. So, the point of all this is two things to think about. Number one, don't build ridiculously complex components. At a minimum, you're going to want to chop those up and make some child components. Now that's the first thing to think about, and hopefully you've already done that in your application. Number two, as you're doing this chopping up of a big template, for example, into some smaller child components, let's try to stick with this container presentation where we have that one boss that gets the data, and then the children just present the data. If you didn't need that, because you don't want to load the children all at once maybe, then even by having the child components, you'd be set up well for child routes. Now that can be really useful if some of these children have quite a bit of information and you don't want to load them all at once, you want to load them individually based on a route. Well, this would let us do that. So moving forward, what we're going to be looking at now is some general rules that we want to do as we're working with parent and child components or container presentation components. As we pass data from our container to our presentation component, we're of course going to use input properties. We'll be talking more about that. Now to go the other way and communicate from the presentation up to the container, we'll be using output properties. We're also going to talk about the change detection strategy on our presentation components, and talk about why OnPush is a really good idea for those. We're going to get into a comparison of reference versus value type objects that are passed into a presentational component, and talk about why cloning can be very helpful there. And as we've already discussed, if you have a parent and a child component, then it's very easy to switch that child component to be loaded when a route is triggered in the Angular application, and that can be very appropriate when you just want to show one child, you want the user to bookmark it, or maybe a child component has a lot of data, you don't want to keep it in memory along with other children, you just want to load it when a route triggers it. These are all these different types of things we can think about. So now that we've discussed this general concept of container presentation components, let's look at an example in the jump start application.

Container and Presentation Components in Action
Let's look at an example of container and presentation components in action, and I'm also going to show how child routes could be used as appropriate as well. So going back into the Angular-JumpStart application, I'm going to open up our customers feature, and as a review our customers feature has its own module and its own routing module, but you'll notice that there's just one component at the root of the feature folder here, and that's our customers.component. Now if I open that up and go down just a little ways here, you're going to notice we have some child components, we have a customers-card, customers-grid, and then there's a reusable map component that's located in shared that's being used here. This type of structure is fairly normal in Angular, you have a parent component and a child; however, you'll notice that I'm actually passing using input properties, some data into these two children. They both have a customers property. We're going to review input properties coming up in this module, actually, if you happen to be a little newer to it. Now the reason I want to point that out is if I go into one of these, and let's just go to the customers-card and I'm going to go to the TypeScript file here, there is not much in here. You'll notice there's very little actually, and there's nothing that knows how to get the data. Now let me go look at the grid, and you'll notice the same exact story, there's very, very little in here. Now that's because this is following the container presentation. So what we're doing is in the container, which is our customers component, this is responsible for using a service, in this example, to go get the data. So it calls getCustomersPage, that calls our service, and then we return that data. That gets stored up in property here, we have customers and filteredCustomers, which'll be equal initially when the app first loads. Now by doing that, we can get pass that data to the presentation components, which is our card and our grid, and they then render the data. Now several benefits of this. Number one, I'm only retrieving the data from a component standpoint in one place, and that's in the container. That keeps our maintenance simple, we know exactly where to go if we have to tweak that at all. Number two, we don't have a just tremendous amount of HTML. Now this does have some because I have my children here, but you can see, the HTML's pretty minimal in this particular template, so that's good for maintenance. If I wanted to enable child routes, we could do that. Now of course in that case, the children would have to go get their own data, we wouldn't use input properties in that example, but at least we would be set up for that because I could simply take this part out, add a child router outlet here, and then we could dynamically load the customers card, and maybe the grid and map if we wanted. So that would be an example of container presentation. You can see it's a very simple pattern, but the whole premise is keep it clean, keep the container as the manager, the one responsible for knowing how to get the data. Now, I want to reemphasize, it shouldn't get the data, that should be delegated to a service or some type of a store, but that would be an example of using it. Now if we go back to the application here, this is what you'll see. So, here's the card, and this particular area down here is the card component. Here's the, what I call list, but it's really a grid component behind the scenes, and then here is the map component, which'll then map the customers. And then of course we can do paging and stuff like that if we wanted as well. So that's an example of how we can actually use these types of components in our application. Now an example of actually using child routes and not using container presentation would be if I drill down into a customer. So let me go to Ted James. You'll notice I go to the details for Ted James. Now this is kind of a toolbar here, and instead of loading the details, the orders, and the edit all at once, and then just showing and hiding those, that might be appropriate, that might be expensive, really depends on what you want to do. We could instead load these through child routes. So you'll notice up top I have customers/1/details, if I go to the orders, that's going to replace the router outlet with my child route, and this would get the orders now, notice the router has changed. Now edit will redirect me, I'm just going to put in any email here, and at least six characters with a digit, and we'll log in, and that takes me back to the route for the edit. Now, why is this cool? Could I have used container presentation here? Absolutely, I could've, but this would now allow a user to actually bookmark this particular route, or this one, or this one, and I'm only loading one at a time. Now these are the things we want to be thinking about from an architecture standpoint, of course, is do we want container presentation, or do we just want to load the children dynamically through a child route? Now if I go back to the home screen here, I'm just showing and hiding these particular items, and so they're all loading at once, not a ton of data, so not really a big deal. Now the downside of this though is if I go to List, I can't email somebody the direct link to this. This is just container presentation. Now that might be appropriate for your app, maybe not. But if I refresh, you'll notice it's going to go back to the card because there wasn't a route up here for these individual items, whereas if we go to one of the others, like I just showed, we can obviously bookmark this and somebody can email it or get to it the next day very easily. So that would be an example of kind of both techniques there, container presentation, and then the child routes. Which one is most appropriate? It really depends on your app, that's something you're going to have to discuss as a team, but at least you'll know the different options there.

Passing State with Input and Output Properties
As we move forward, we're going to be talking about passing state or data between parent and child components, or container presentation depending on what you're doing, and I want to make sure that everybody's on the same foundation of how this works. We're going to quickly review the concept of input and output properties, but we're also going to address a challenge that typically comes up as you get more complex applications with nested children. From a component standpoint, we know we can get data from the component into a template through typical binding, square bracket type binding or interpolation, the squiggly brackets if you will, or curly braces. We know we can get data out through the parentheses binding, or event binding, and that's a pretty standard part of Angular. Now, taking it up to the next level then, if we have a parent and a child, we know that the container component could go get some data from a service, and then we could have an input property, which then allows that data to be passed from the parent down into the child, like you see here. Pretty standard Angular code, again, that we would write here, and I'll show a quick demonstration of this coming up. Now going the other way, if we want to work with getting data from the child, or the presentation component, back up to the container or parent, then we could of course use output properties. This simply involves using an event emitter, which then emits that data up to the subscriber, which would be the container, and then it might interact with a service to ultimately push that data to the server. So it might look like this in that particular case, and that's how the data would flow. Now, working with input and output properties is pretty standard, and if you've done any Angular then you've used these. If you haven't, I'll do a quick demonstration of it. Here's where things get a little bit challenging though and invoke a little bit more thought from an architecture standpoint. What happens when you have this type of scenario? So you have a container that can go get the data, through an input, it passes it down, and then maybe we have kind of the two-way flow of data, input and then maybe an output. Well if you're only at this level right here, that works great. Now what happens though if your presentation component has gotten pretty big and you've decided to delegate part of the rendering down to a child of that? Now what do you do? Do you use an input property again? Well, I'm going to argue that's okay. I think input properties are pretty straightforward, and because all these components are related in a family tree, not really a big deal there. What happens when you go the opposite way, though? Okay, now you'd have to have an event emitter, which emits up to here, which emits up to here, and where does this stop? Because if you go too deep, you're kind of in the land of madness, if you will. So we'll talk later about some component communication techniques, but I wanted to throw this out here that while input/output properties are very straightforward, a very crucial part of Angular that just about everybody uses if you work with child components, they aren't necessarily straightforward when things start getting a little deeper. Maybe the data that you're going to grab, you want this component down here grabbing the data all on its own, as an example. Well, what are we going to do there? And that's what we would need to talk about as a team. So I kind of want to through that out there, and to be real honest in this particular case, I think you have to take it on an application and particular scenario by scenario basis. I don't think there is one way to do this. It could work with many different techniques, but I think it's worthwhile to discuss if you discover you're going to have some nested hierarchies for your child components, as an example. So let's look at a really quick example of input/output properties, just in case you need a review, and then we'll move on to some other techniques we can apply to input and output scenarios where we have container presentation components.

Input and Output Properties in Action
Let's do a quick review of input and output properties in action. Now, if you're already familiar with these and have used them a lot, you can probably skip over this section, but since we're going to be talking about these quite a bit coming up, want to make sure everybody's on the same foundation, so we'll do a really quick code demo here. So the first thing I'm going to do is create a project. Now, I'm going to speed this up quite a bit because it is just a review, and mainly just show the process of creating some components using the CLI, and then creating an input property, we'll get that working, and then we'll create an output property. So let's start by creating the project. Now I'm going to go ahead and cd into that, and let's open this in VS Code. All right, so, I'm already at the root of the project in my console, so now what we're going to do is I'm going to go ahead and follow what we talked about earlier with modules, and although I don't really need to create a child module here, we're going to do it for a given feature called customer. So the first thing I'm going to do is an ng g m, and I'm going to call this customer, and this'll generate our module for us. So let's go into the folder, and notice we now have customer, and we kind of have an empty module. Now we'll create our container component, and you can see that's automatically been updated in our customer module. Now, the last thing I'm going to do to get this going is we're going to create another child component, and we're good to go there. So let's go into our container component, that would be our customer.html here, and let's assume that we're just going to display Customer, and then under that I'm going to go ahead and add my presentation component. We're going to hand the data off to that. Now, ultimately what we want is we're going to make a customer property, and that's going to be our input property, and then we'll have some property in our container that would have that data we're going to pass down, and I'm just going to go ahead and call it customer in this case. So, I'm going to go into the container component, we need some data. So for now, I'm just going to hard code it here, we'll just do an any, keep it quick. And we're just going to give it a simple object with a name, and we'll give it maybe a complex property here with a city. And we're good to go there. So now we have a customer property, we're going to pass that into our details. So now we can add our input property. So we'll come on in, we'll say @Input tab, that'll import the symbol up top, and we'll call it customer, and just in the interest of time, again, we're going to leave it as an any. And now what we're going to do in that template is we'll simply write out the name, and we'll go ahead and write out the city. All right, very simple, but this'll be a quick demo of our input property here. Now, the whole goal of this is we'll assume this wasn't hard coded, instead we maybe call the service, or some type of a store that we have in the application, and that gets our customer, but the point is we're going to delegate to the child and pass the data to that child with our input property, which then renders it. Okay, so if we go to the customer.module, we should be good there. The CLI took care of updating that for us, so that's perfect. Now we need to go to our app.module, and I need to import the CustomerModule. Okay, so we're good there, and then of course I need to go into our root component here, I'm going to strip this out, and we're going to put the app-customer selector. Now, notice this goes red. Why is that? Well, because I'm using that component at the root level to kick this off, this is kind of my root feature, if you will, we're going to need to export it. And you'll notice it didn't do that for us, so I'm going to go ahead and export my CustomerComponent. All right, and that will now make it available up here. Let me just hit a space and back, and there we go, we should be good to go. Okay, so now we have an entire new project, we have our root component, our customer container, and then we have our details component, and that's going to be getting the data from our input property, so let's go ahead and try it out. And it looks like it worked perfectly. We have our data, so let me just go ahead and minimize that and we'll leave this running. Now the last part is, we have our input working between the container presentation, let's talk about an output property. So let's go into our customer details, and let's just assume that there's a way to maybe change the details. Now we're not going to really add a text box, we're just going to add a button for now, but we'll simulate it with that, and we're going to do an output property now. And let's call this customerChanged, and it's going to be equal to a new EventEmitter, and I'm just going to say of any in this case. Now EventEmitter, we need to import up top. And that would be how we'd create an output property that can emit an event. Now, we're going to simulate this through adding a button. So let me go ahead, we'll just add a standard button, and when it's clicked, we'll call a change, we'll say it, function, and let's go back into our component code, and we'll add that change function. Okay, so now we just need to use the EventEmitter to send the data, and I'm just going to send the actual customer back. What I'm going to do is say this.customer .name = Michelle Doe, so we'll kind of simulate a change. And then we'll raise the event, if you will, through the output property by doing customerChanged.emit, and then we'll send this.customer. Okay, so that would be the output property. Now, all we have to do is subscribe to it, so we'll come back to our container, and let's say that we call a changed, we're going to pass the event object. This is how we can get to it in the Angular world. So now we need to go into our customer template, or our TypeScript file I should say, and we'll add a changed, and that's going to take our customer in this case. Now right off the bat you can see where creating either an interface or a class would be very helpful here because now I'm going to get zero IntelliSense of course. But since we're not focused on that, we'll keep going. From here I'm just going to say this.customer = the customer, and we're just going to update it directly here. So as a review, we go into our details, once the change fires, that's going to cause the customer name to be changed, we'll kind of pretend that there was maybe a text box they would've entered this into. We then emit the event, that now goes back up to our container component, which is customer component, and we'll handle that here, let me make sure that's all working correctly, looks like it. There's our customerChanged that we actually emitted from right here. Okay, so let's go back, and we'll refresh this just to make sure, we'll change, and then we'd hope it would push the data back down to the input, and there we go, we get Michelle Doe. So that would be a really quick review of input and output properties just in case you haven't worked with them. There are other courses out on Pluralsight if you want more details on these. I'm only covering these because we're going to start talking more about some different architecture things you might want to consider when working with input and output properties as we move along.

Change Detection Strategies
As you work with presentation components, there's something you should consider when it comes to change detection. Now normally when data's passed down from a container to a presentation, or from a parent to a child, if that child changes the data, the UI would reflect that change. We would expect that to happen. However, in the case of container presentation, we don't want the child component changing the state or the data at all. Now if the user changes it at that level, that's fine, because we would reflect that back up with an output property as we showed earlier, but we want to make it where any given presentation component can't actually change the data. So we're going to talk about how we can do that here, and this is something I'm a huge believer in, and I'll tell you why as I share a little story. So let's go back to the code that covered input and output properties, and if you recall we had a container component called customer.component, it had an input property it used from customer-details, and then we sent that data down. Now if we were to come in and change the data here, and let's change the name to Gina Doe, and let's go back to the browser, you could see, Gina Doe is reflected. Now we would expect that. If we were to come in and do a setTimeout to simulate data changing later, but not the user changing it, the presentation component changing it via code, then we could simulate that by doing a setTimeout, and we're going to do the same thing here, so I'm going to copy that down. Let's change this to Tina Doe now, and then we'll say that's going to happen after a second, just to simulate something happening. If we do that, let's go back to the code, you could see it just changed to Tina Doe as we would expect. When you're working with a container presentation pattern, we don't want the presenter component to be able to do this type of thing. Now it's okay if they maybe initialize some data, that's fine, that's one thing, but changing the data later would be a very bad thing, we don't want that to happen. And that's because any data it presents should come from the container, the parent. So what we can do is come on up and we can change the changeDetection strategy. Now there's two main ones you could set through the decorator property here, the component decorator, and the first is called default, and that is the default, that's what happens out of the box, and then the second is called OnPush. So we're going to go ahead and grab this ChangeDetectionStrategy., and then we're going to add OnPush. Now, let's see what happens just by changing that. So I'm going to go ahead and save. Let's now go back, and you'll notice Gina still shows. So, it initialized to this, but the setTimeout, which is again simulating something happened, and then some code ran to update the data, that part did not work. Let's go ahead and comment this out again, and we want Tina to show when this fires. And Tina now shows, so okay, so a default as you'd expect, it would update. As mentioned, with the container presentation pattern, we don't want this to happen. Now let me share a little story about this. So, I have an application I'm working on that's fairly involved, lot of hierarchies, a lot of input properties, output properties, things like that, and I'm using container presentation. I was going in one day and trying to modify something in a component, not really paying attention to where I was, but the component had this set, I just didn't realize it. The reason I set this is kind of twofold. What OnPush does, is number one, it'll make it where only an input property, an output property firing, or an EventEmitter, or an event that fires within the code itself would cause the UI to update. So, that makes sense. If we push data in or out, then we would want the UI to update. However, if we don't push data in or out, or a button click doesn't fire, we don't want the UI to update because where should the data be coming from in this type of component? Well, from the container, the parent. So in this particular example, going back to my story, I was trying to change the data and wasted more time than I care to admit trying to figure out why the UI wasn't updating. Well, it's because I had OnPush set on purpose so that I didn't do that type of code. So I of course eventually realized I had it OnPush, and kind of wanted to slap myself at that point, but it was a good thing, it protected me. So this pulls it out of the ChangeDetection lifecycle when it comes to changes in the component. It has to be pushed in or out, or an event has to fire for the UI to update with this change detector. So in this case, this would protect us from accidentally writing code that could update the state that then updates the UI, we don't want that. So I highly recommend, in your presentation components, unless you have a good reason not to, to put OnPush on all of those. Here's an example of the few of the benefits, including performance and protecting ourselves, and in unique cases, you can always remove it when you don't need it. Now let me jump on over to the JumpStart app, and you're going to see this, and Victor Savkin who was originally on the Angular team and heavily involved with writing the ChangeDetection mechanism, he gave this little quote. "When using OnPush detectors, then the framework will check an OnPush component when any of its input properties changes, when it fires an event, or when an observable fires an event. In this case, I have OnPush. That means if I came in and updated the data, it's not going to reflect in the UI without some type of an event firing. Now in the case of a sort, that's an event firing, and so as a result, that would update, for instance, in the grid, sorting the columns. Now if we go to the customers-card, you're going to see the exact same thing, and I put the quote again from Victor here, and this one doesn't really have any code, but if I started adding code to change the customers, it's not going to reflect in the UI unless it comes from an input or something else fires, as is mentioned up here. So that's an example of the ChangeDetection property of a component, and if you're not using that currently, even in just a parent/child scenario, it's something I would definitely recommend you look into.

Reference vs. Value Types
As you're working with parent and child components, you may run into some interesting scenarios when handling events like ngOnChanges. So in this section we're going to talk about passing reference types versus value types and the effect that can have on the ChangeDetection mechanism. So, I'm going to jump over to the Angular-Architecture project, and in that you're going to see a structuring- components folder, and in this you'll have a container component, structuring-components, and then two children, customer-details and customers-list. Now let me go ahead and run off to the browser, and when I run this, this is what you'll see, this is our container, everything here, and then here's our presentation for the list, and here's our presentation for the details. So as expected, if I click on one of these it'll update over to the right, and we can get some details. So this is using input properties with OnPush on both of these children, and as the data comes in, we render it. As I click on one of these, I then pass that data up to the parent through an output property, that's passed back down through the input of the details, and then it updates the UI. Now, nothing really unique there, that's what we would expect. Now I had the same scenario over here, and you'll notice my customers, and I can drill in, same exact type of code, but notice this time I have an ngOnChanges Fired: Customers changed. Now what I'm going to do is the container is going to call a service that'll update the customers, but it's simply going to update the array that's displayed in the list. So it's going to push a new customer in, and let's watch what happens here. And nothing happens. The funny part about this is there are four customers. In fact, we'll talk later in the component communication module of the course about updating this value up here, which shows the number of customers. I have four in here, actually, but only three are showing, and that's because of how data is passed when we use input properties and past reference types versus value types. So let's go take a look at the code for this and see what's happening here. So, I'm going to go into the same exact code. So we have a container component here. Now, this container component is very simple, it calls getCustomers, but then it also has an addCustomerPush, and that really just calls addCustomer on my service, which pushes a new customer in. So, if I were to run off to my core, we can open up our services and go to data.service, you'll see that we push a new customer in here. The question is, if that customer's being pushed in, and then being returned, as you can see here and we're updating the customers, why is that not being reflected down in the UI of our customers list? Because that would update our input property that you see here, and then the UI, which is our template, should loop through and write out that value. Well, the answer relates to passing reference types versus value. If our container component was updating a value type, now this would be a primitive type, a number, a string, something like that, a Boolean, then in this case that would work, it would update the child because the ChangeDetection mechanism would catch that. Now in this example though, what's happening is when we went to the service, let's go back to there, it's pushing in a new object, that's adding a new item to the array, but did the array itself change? And the answer is no, it didn't. The array itself is still there in this case, and we added a new item, but the ChangeDetection mechanism that's now firing once this input property is updated here is only looking for a change to the overall array. That didn't happen here, therefore, the UI didn't update. Now this is a super critical thing to understand because you may have a list, like I have here, and then wonder why it's not being updated. Or maybe you're handling ngOnChanges, and in ngOnChanges you want to do a calculation, maybe, based on the data that was passed in, because that data changed. So, the big thing to understand here is that when you pass an object by reference, if anything in the object changes, that's not going to be reflected in the presentation component. And the reason, again, is because the outer object, which could be an array, or it could just be an object like a customer object. If you change a property in the customer object, that too will not be reflected in the UI, and that's because the outer object didn't change its memory location, it's a by reference, it references a pointer in memory when it really boils down to it. So, we're going to talk in the next section about some different techniques to help with this, we're going to talk about cloning, something I'm a huge believer in. This gets us into immutable type of data and state. So now that we've seen that, let's move on and talk a little bit about cloning techniques.

Cloning Techniques
In this section, I'm going to talk about why cloning can play an important role in your Angular applications, and why it's something that you really do need to plan for up front in your architecture. So there's a few different techniques for making a copy of an object, or cloning an object. Now a lot of times you'll hear people refer to this as an immutable approach where we never change the object, we always make a fresh copy of it, and then pass that fresh copy around. There's several ways that we can do this. The simplest would be a JSON.parse and a JSON.stringify, and I'm going to show you all of these in a moment. Now this has some limitations, and I'll get into that. You could write something custom that overcomes the limitation, or maybe just use a really little script that's out there. And then finally, you could go into a full blown library design for this type of thing. One of those would be Immutable.js, and there's a few others out there. So let's jump on over to a sample app and take a look at cloning in action.

Cloning in Action
Let's start things off by talking about the problem we're trying to solve with cloning or immutability. Now, earlier I showed an input/output demo, and we're doing the same thing here. I have a container component, it goes to a service now, you'll see in a moment, gets a customer, returns it, passes it in with an input property. Then when the button is clicked, an output property is emitted, the edited customer, or changed customer, now goes back up to the parent, it then sends it up to the service, which updates the datastore, in this case. Now, I've also added another presentation component that just shows a list of customers. Both of these presentation components have an ngOnChanges, and that'll allow us to easily see when it thinks a new object is coming in through the input property, because that could be very important. I came up with a really simple use for ngOnChanges here. When order total changes and the customer comes back to the presentation, I'm going to go ahead and take that new amount and add on some tax to it. Now that's something we might have a service do, but in this case I just wanted to show an example where sometimes ngOnChanges getting called, or maybe the set block of a property, if you have getter/setter blocks, could be really important. So, I'm going to come in and the second object in the collection is Jane Doe. Now, I'm going to go ahead and change that to Johnny Doe, as you see here. Now notice up top, it changed the data as we would expect because the container passed the object through an input property to here, they're both referencing the same memory location, so that's why they both changed. This object I'm writing now with a JSON pipe, it's referencing the same object as well, so that's why all three of those places changed. Now, when I emit and send this customer back up to the parent so it can call the service, what should happen is then it goes and grabs the fresh customer from the service, and we should see ngOnChanges called, and we should see the update down here. The problem is when we're not cloning, if the object in memory hasn't changed, or at least Angular thinks it hasn't changed, then ngOnChanges isn't going to fire, and this is something you need to plan for with your services and your architecture of your application. So let me hit the button, and nothing happens. Now it worked, you don't know it worked, but it worked. And you'll notice though, it sure doesn't look like it worked, we didn't get the new item here, didn't fire a new ngOnChanges for the array change, this didn't fire again, and that's because the service has a reference to the object, the container has a reference, and both of the presentation components have a reference, therefore, nothing changed because the actual customer object didn't change, just the inner property called name change. And Angular, at least for ngOnChanges, doesn't monitor that type of a change. So, how do we fix this? Well, let's go into the code now, and before I go too far, let me show you that this is pretty much the same setup that I showed in the input/output part of the course, and I have a container, which is customer, I have customer-details, that's presentation, and then I added one more presentation component, it's very simple though. It has an input property for an array of customers, and this time instead of using any, I went ahead, and let's just peek at this, I made some interfaces here. Now, what's going on though is if we go to customer, when it loads, it calls .getCustomer and .getCustomers, and that updates these two properties, which then are passed through the input properties to the presentation components. Now that calls into our customer service, which is injected in our constructor, calls getCustomer and updateCustomer when it changes, and getCustomers when it needs all those. Now notice when we update the customer though, we go and get a fresh customer and a fresh set of customers, our array here. What's going on here is if we now go to our service, when getCustomers is called, it's just returning the data it has. Now in this service I went ahead and just put the data, kind of a caching type scenario. We'll assume that maybe this data came from the server, and now we're storing it in the service, and need to divvy it out, if you will, to the component. Well, I'm just returning the actual array, you can see right here. Now likewise in getCustomer, I filter the customers based on the customer ID that's passed in up top, and then I say if we have a customer, grab that customer, and then return it, but it is the exact copy that this service has as well, and it's the original customer object when the page first loaded. So therefore, the outer object in memory, the customer, didn't change in this case. Again, just the property inside of it did, that's why ngOnChanges isn't firing. So, let's show some options here. So to fix it so that the bottom list can update properly, and ngOnChanges would fire, we can clone the object. So I'm going to comment this one out, and instead we're going to stringify our customers array, and then reconstitute it with JSON.parse. Now what that's going to do is a deep copy. Now likewise down here, I'm going to come in, we'll do the filtering, we're going to not return the customer, and instead, we're going to deep copy it using this same technique. Let's go ahead and save it. This will now call the service, we update the customer, but we clone not only the customer coming back, but also the array. And let's see what happens. And there we go, customer changed, and look at that, Johnny Doe changed, and notice that the data down here also changed. Perfect, that's what we want. I could just stop there and say, there you have it. Use cloning as appropriate. Well, there are some problems with this approach. If you have things like dates, and there's a few other scenarios, this won't work right, and that's where you need to take it up to maybe a more custom third-party option or a custom solution you write. Now, I wrote a little custom service called clonerService, which I inject into this service, and I added a little deep clone. In this case I'm going to say what the type is I want to clone, and then I pass in the array. Now this cloner, which I'll show you in a moment, is going to use a third party, just open source npm package I found called clone, and it does deal with things like dates properly. Now likewise, I can come down to here, we'll take this out, put in the same exact scenario, and I'm going to deep clone it. Now this is a very light lightweight solution, so it's very good as far as your bundle size when you go to production and things because it's a very minimal library, and that's why I really like this option. This is actually, of the ones I'm going to show, this is what I normally use when I want to work with cloning. Now let's go ahead and save that. We'll come on back, and everything works exactly the same, and that's what we would expect. Now, is there anything better in this case between these two options? Not really because I don't have any dates, but I may, let's face it, what app doesn't have dates in it? So, I would prefer this cloner service, I don't really use this one anymore. The cloner service is very simple. All I did is made a little generic so I can pass in the data type. Here's my return type, which is my generic type, and then I import from clone. Clone is a library up on npm, there's several of these out there, this is just one, and it has a little clone function where you pass in the value, and that does a deep copy, a deep clone, if you will. And that's all I'm doing. So I'm just kind of wrapping that with my own service so I could easily substitute this one out if I wanted to.

Cloning with Immutable.js
When you start to get a little more tricky and have a lot of things that should be immutable and cloneable, if you will, then you might start to use something called Immutable.js, and there's even some other options for this too, but Immutable.js is very popular. This is from Facebook, and it has an object called List, which can work with arrays, list of items; Map, which can work with key value pairs, objects; fromJS, which can do a deep copy and create what's called a map, and then we can convert that map into a normal JavaScript object. Now, I'm not going to have time to go into Immutable.js because that's a whole other class actually, it's a pretty robust API, but let's look at how we can use it. So what I'm going to do is create a different array of customers called immutableCustomers, and that's going to be a list of customer that is these customers, but by wrapping it with the list, these are now immutable. So now we can't really change the array. If we do, it'll give us a new array. So coming on down, now what I can do is the following. We can say, go to those immutableCustomers and say toArray. Now that's going to clone those for me. Very nice and easy. Now coming on down to here, we can comment out this one, and in this case I want to return a single object. Now there's multiple ways to do this, I picked a very simple way. FromJS is from a JavaScript object, that returns an any, but under the covers it's what's called a map, and then I'm going to convert that to a JavaScript object. So this is another way to kind of rehydrate a fresh copy or clone of an object, and then I'm going to cast it just because I'm using an observable up here of customer. Now in this example, it's going to do exactly the same thing, and to be honest, in this example, Immutable.js is probably a little overkill, but it can do a ton of powerful things if you're going to be using immutability throughout your app. So let's just make sure it works, and it does. And we're good to go there. Now, this is important, again, because if we go back into my customer-details, I have an ngOnChanges. Now I put in a real simple example here of it, where as a new customer comes in, we detect that, and if there is a change to that input property, I'm going to add tax to a particular value called orderTotal. And I'm going to update a property. Now, you may do that at the service level, I would prefer to do that at the service level, but I wanted to show an example of where maybe you have something that ngOnChanges that you always want to make sure it gets called. Now likewise, customer-list also has an ngOnChanges. Now it doesn't do much in this case, it just logs. But if you had something where you want to loop through the array as it changes and you want to be notified when it changes, then this would be the normal way. Now likewise though, if I had an input with a getter/setter up here, an ES2015 get/set property, we'd also want the set block to be called. Well again, that's not going to happen unless the outer object changes, the array reference, or pointer and memory, or the customer reference in the other one. Later, I'm going to talk about how some of the state management options out there do this out of the box. You won't really have to worry about it, but if you are using services today, you might've run into this challenge where why isn't my ngOnChanges being called? Why isn't my set block being called, and my property? And that's because it didn't think, it being Angular, didn't think that the outer object itself changed, and that's why cloning it will solve this problem, and now everything updates as expected.

Component Inheritance
The next topic we're going to discuss that relates to structure in your components is component inheritance. This is a feature of Angular that can provide some reuse in specific scenarios. Now, it's one that I use very, very sparingly, but I would argue that there are some scenarios where this can save you a lot of code and make your code base more maintainable. So let's take a look at what it is. So let's say that we had some widgets, the widgets may render text boxes, or text areas, or other types of controls on the screen. Let's assume that these widgets have very similar input and output properties. So for example, Widget1 maybe has a label and a value as an input property, also tracks if the data is dirty, and then has a valueChange output property, and let's say that one maybe is a text box that does all that. Then a little later in the development cycle you create Widget2, and it also has the same exact input and outputs. Now of course it might have some additional, these are the common ones, between the two widgets. So what if we could get rid of the commonality and move it somewhere else into a base component, and then inherit from that component in Widget1 and Widget2, so it'd look like this. We'll get rid of that, we'll get rid of Widget2's, and instead we're going to move it into a base component that won't have a template, but it will have component code, including functions, and of course the inputs and outputs and things of that nature. Now we can share that functionality between Widget1 and Widget2, and in this case that can make a lot of sense. Now, I think component inheritance, as I mentioned earlier, is one of those things that would not be my first choice. I think there are many scenarios out there, arguably most scenarios out there, where you don't need to use component inheritance. But in cases where you do find yourself duplicating code between your components, specifically the input and output properties, then this can make a lot of sense, especially in cases where you have these widgets, as I mentioned. So now that you've seen an overview of this, let's look at an example of component inheritance in action.

Component Inheritance in Action
Let's look at how we could create a base component, and then inherent from that with some widget type of components. Coming into the Angular Architecture project, there's a folder called component-inheritance, and in that I have two widgets. Now, these widgets are going to do one of two things. One's going to render a text box, let me go ahead and open this one. Notice it has a label and a value. And then we also are tracking the dirty state and setting a class called dirty, which is in our CSS, to red in this example. Now the second one, this renders a text area, and we're also setting the dirty state, tracking the value, and we have a label. To do that, we'd obviously need an input property for the value, a way to track the dirty state, and we could do that by writing that code in each of the widgets, but, you know, after doing that a few times, you might be a little bit bored and say there's got to be a better way. Well in this case, because we have input and output properties that we wanted to track, let's say, we could create a base component. Here it is. Now you'll note that the template is empty, I set the ChangeDetection to OnPush in this case, and notice that I have my input. So we have a label, we have a value with a getter/setter, an isDirty, and a valueChange output property, and then it's also tracking an ngOnChanges here to log some values, and who knows, this could even communicate with a service, for example. Now the point of this though is that while this isn't a ton of code, we wouldn't want to duplicate this across many widgets. I only showed two here, but let's say that we had many of these, and we'd probably even have a lot more code than this. So by using a base component, we can put those input and output properties, and even functions that we need into that base so that we don't have to duplicate that across all of our widgets. To apply this base component, all we'd have to do is come into our widget component class, and we can extend base component. Now you can see how clean this is. Really, the only thing I had to do besides the extension is call super, since that's an ES2015 rule, and if we go into Widget2, it's identical. Very, very simple, in fact, in these widgets, really what we're after is just a customized template, and as I showed earlier, this top one renders a text box, and this bottom one, Widget2, renders a text area. And I want to emphasize, I wouldn't go crazy with this. This is one of those scenarios where you really need to have a good reason to use this. And if you don't have this commonality of inputs and outputs and things like that across your components, then you definitely wouldn't want to go obviously with component inheritance. But in this case, it can make a ton of sense, and an app I'm working on currently, we're using this because we have about probably 10 to 15, I'd have to count them, widgets, where they have a ton of common functionality, and there's a lot more code than I'm showing here, but I have a state manager BaseComponent, and that serves as the base for all these widgets, and that way I can change the code in one place, I could add new input properties as needed, and we can do all that, and automatically inherit it, which makes it a lot cleaner. So, if you don't have that scenario, don't look to this as the first point of designing your architecture. So in other words, right tool for the right job. I'll show you an example. Now, all it does is here's my Widget1, here's my Widget2, I'm binding a label for each of these, and as I type it's going to update the value, fire a valueChange event through the output properties event emitter, and track the dirty state of when the value changes. So as an example, I can come in, we could say my name is Dan Wahlin, now the widget, you'll see, is not only tracking all of that, there's my dirty state being updated, but it's also writing out to an h3 tag I have. Likewise, the notes, as I type here, is going to update, and in this case I chose a navy blue for my dirty state of that component. Now that's a very simple example, but you could see where as you duplicate this type of code across your components, you might decide to go with component inheritance. So while I don't use this all the time, it's definitely something you should at least be aware of and know about as you architect your applications.

Summary
We've reached the end of another module with a lot of information about structuring components. We started off by talking about breaking complex components into child components. From there, we talked about more specifics though and how we could follow the container presentation pattern wherever possible, and how if we do that, the container retrieves the state, and the presentation components render that state. By doing that, we can keep our code much cleaner because we're going to know exactly where to go if we need to change the retrieval of the data from a service, for example, instead of scattering that between the parents and the children. We also talked about the change detection strategy of OnPush and how we can change from default to OnPush and the effect that can have on your presentation components. From there, we talked about how we can leverage cloning, or the concept of immutable data, or state, and that it's not always appropriate, but when it's appropriate, it can be extremely helpful. Now if your service, for example, always gets fresh data from the server, so let's say that all your gets come from the server, and then that fresh data is passed down the components, well, you don't really need to clone that per se because it's always a new object. Likewise, if your post, put, or delete operations are always returning a fresh status object, or something like that, then of course you don't need to clone it. As long as the object is constantly changing, then your ngOnChanges and other things within your components will fire as you'd expect. But in cases where you are calling the server, maybe caching some data for a while, maybe while the user edits it or something like that, or other types of data, such as even lookup data, then you're going to want to definitely look at cloning and using one of the techniques that I discussed. We wrapped up by talking about component inheritance and how we want to use it sparingly, but do use it when it makes sense. If you have a lot of input and output properties being duplicated across components, then this may be a good way for you to go to clean up that code base. It's not something that I find myself using every day by any means, but I mentioned it has been helpful for a project I'm working on that has a very specific scenario that it applies to. So that's a wrap on structuring components, and I hope that gives you a lot of things to think about as you start to architect and plan your projects. This is one of those things that the more you know about some best practices, some different techniques, then I think down the road, the better your code base is going to be, and the easier your maintenance is going to be.

Component Communication
Introduction
Component communication is an important part of any Angular application. Now up until this point in the course we've already seen how parent and child components can communicate with input and output properties, and that's the standard way you would want to do that. But what happens when you have some nested hierarchies with components at many levels of the app, and they need to talk? Or maybe you're building a dashboard, and in the dashboard you have sibling components that need to talk, how are you going to do that? Because input and output properties don't always work in every single scenario. So in this module, we're going to address that topic and discuss some different concepts you can apply to your Angular architecture and to the codes you build as you're actually developing an application. So we're going to start off by talking about the challenges that come up with component communication, and then we're going to talk about some things we can use to address that. One of those is RxJS subjects. Subjects are a very, very powerful feature of RxJS. They can allow different items within an application to talk to each other it provides a very flexible way to do that. Now there's different types of subjects available, so we'll address some of those and discuss the differences. Now from there we're going to talk about different ways we can communicate. One of those is something called an event bus. And we're going to talk about how we can create an event bus service and the pros and cons of going that route. From there we're also going to look at creating an observable service. Both the event bus and the observable service are going to use subjects, but we're going to do it in a different way. And we'll also talk about the pros and cons of an observable service. From there we're going to wrap up by talking about unsubscribing from observables. Now you've probably used ngOnDestroy before to unsubscribe, and you're still going to use that technique here. However, there are some other techniques out there that I'm going to discuss, and although they're not built in to Angular, with a little bit of effort on your part you can get those into your Angular applications and it can actually save you a lot of code. So let's go ahead and get started by talking about component communication challenges and how we can start to address those.

Component Communication
Let's start by talking about some of the challenges that come into play as we have different components in our app and they need to communicate. Now while I'm going to focus on component communication, it may be that you have a need for services to communicate as well. And the good news is you can use a lot of the techniques we'll be discussing in this module for that scenario too. Now one of the things that comes up as we start to build features in our app is deeply nested hierarchies. You may use input properties to pass data from a feature or a parent component down to a child, and that's pretty straightforward. We may use an output property to get data back up as an event fires. But what happens when our components are really deeply nested? Are we going to continue to use input properties all the way down and output properties all the way up? Or do we maybe consider a different technique? Now there's not one right way, as with many things we've covered in this course, but knowing the techniques we'll discuss here could help in that scenario. Now another scenario is you might have a component that needs to communicate with one or more components that could be anywhere in the application, not necessarily a parent or a child. So for example in this case, we might have a NavBar component and some child in the app needs to send out information that ultimately makes it all the way up to the nav bar to maybe display a status message or something. How are we going to handle that? Now input and output properties are pretty much out here, so we need a different technique in this particular scenario, and we'll discuss several techniques that can be used. So what can be done here? Well as we have a child communicating up to other components or even down potentially, we could use an event bus technique or an observable service technique. Now as mentioned in the introduction, both of these are going to be using RxJS subjects, and we'll talk more about that coming up. But this will provide an extremely flexible way to communicate between any area of an application. And although we're going to focus on components here, it can also be used to communicate between services. Now comparing these two options, they're very similar in some ways and they're very different in other ways. Now both of them are going to allow us to communicate between different areas of an application. But the event bus is based more on what we'd call the mediator pattern. This is where you have a middle man service that's injected into both sides, so both components that want to get data exchanged, and then it'll act as the middle man between these. Now doing this will allow us to send data from one component up to the event bus, and then anyone subscribed to event bus events can then get that information. One of the big benefits of this is it's very, very loosely coupled, but you'll see that that also could be a challenge when it comes to maintenance, and we'll talk more about that. And as mentioned, this is going to rely on subjects and observables. Now the observable service technique would follow more of the observer pattern, although there are some scenarios where you could argue it could also be a mediator pattern. We're going to focus more on the observer pattern here. Now this is a pattern where you can have a subject and many observers, and as that subject changes, we of course subscribe and then we can get that data. Really no different than any of the observable subscriptions you might have done before. So in this approach we're going to have an Angular service that does expose an observable, and any component can now subscribe to it. Now components are going to know, though, where the data's coming from. The service kind of acts as the source of truth, and then we can subscribe to that data that's being emitted. Now it's not as loosely coupled as the event bus technique you'll see, but that can provide some benefits actually because we'll know more about where the data's coming from exactly. This also relies on subjects and observables, and we'll discuss the different types of those coming up shortly. So when it comes to architecting and building your app, you may not use either of these options. But knowing about these is very, very powerful and kind of add to your toolbelt if you will when you have these scenarios and need components to communicate across the different levels of an application.

Understanding RxJS Subjects
RxJS brings a lot of great functionality into our Angular applications, and one of the things I really like about RxJS is its support for subjects. Now whether you've worked with subjects a lot or maybe a very little, we're going to discuss the role that subjects can play. And we're going to integrate those into our event bus and observable service scenarios a little bit later. We're going to focus on four main types of subjects, and the first is just the generic subject and we'll talk about what that does and what it's for. Then we're going to talk about BehaviorSubject, ReplaySubject, and AsyncSubject. Now you can find more information at the link below if you want to go to the RxJS documentation, but I'm going to walk you through some visual scenarios here to help you better understand what these are for, and then we're going to actually show the code a little bit later and put them into practice. Now the first thing I want to cover with you is subject. Subject provides a way to send one or more data values to listeners. Now listeners are of course going to subscribe, and as they subscribe they'll get the data. Now what's different about subject from the others we're going to discuss is that if another component subscribes, but later they're not going to get all the data that was sent earlier. So let me show you an example here. Let's say we have this component on the right and it subscribes. The subject then sends some data down such as the number one there. Now in the meantime the component at the bottom here has not subscribed, so it of course did not get number one. Now let's say that it does subscribe though, and now two is emitted or sent out of the subject. Well that would go to both, and likewise, three would go to both because they're subscribed. So with subject, you're only going to get the data after you've subscribed, of course. You won't get any of the previous data, and that's going to be one of the distinguishing facts of subject versus some of the others. Now let's look at another type of subject called BehaviorSubject. So BehaviorSubject is very similar to subject, except that it has one big feature that subject doesn't have, and that's the ability for subscribers that come in later in the game to still get some of the previous data. So here's another example. Let's say that this component subscribes and we get number 1. Now if the component below were to subscribe, they're not going to get number 1 or number 2, you would think, because it's already been passed and the component at the bottom doesn't have the information. The difference between BehaviorSubject and subject though is the last value that was emitted can still be retrieved by someone who subscribes later in the game. So for example, we've already seen 1 and 2 have been sent to the component up top, but if the one on the bottom here now subscribes, they're going to get the last value that was emitted, so that would be 2. And then they'll get any future values as you can see here, such as number 3. So the big difference between subject and BehaviorSubject is that with subject you only get data after you subscribe and you don't get any of the previous data. With BehaviorSubject, you can get the last value that was sent out, even if you subscribe 5 minutes, 6 minutes, whatever it may be, down the road. And that's a really powerful feature when you have components that you want to keep up to date that subscribe a little bit later. Now the next type of subject is ReplaySubject. BehaviorSubject is a type of ReplaySubject, actually. It replays the last value that was sent out to any new subscribers. ReplaySubject could replay just the last value, but it can also replay all of the previous values if you'd like. And this is something you can actually configure. So you can think of this as kind of caching any data that's been sent out so that any other components that subscribe still can get that data. So here would be an example of this one. So let's say we subscribe and we get number 1 comes down as the data and number 2, and we have this data kind of flowing here. Now later on another component now subscribes. Now if it was subject, we know they wouldn't get anything. If it was a BehaviorSubject, they would get the last. But with ReplaySubject we can replay all of the previous items to this new subscriber. So here would be an example of that. Now 1 and 2, which were already sent to the top component, are replayed, 3 is a new piece of data, and because they both subscribed, they would both get that. So this can be really powerful if you want to replay a sequence of data, really a stream of data, to late subscribers in the game. Now the final one we're going to talk about is called AsyncSubject. Now this one's very different than the others. With AsyncSubject, you're only wanting the very last value as the subject completes. So we have a bunch of values that can be sent out potentially, but you're only interested in the most up to date value for whatever reason in your app. So here's an example. We subscribe, 1 is passed out, but we're not going to get that. Two comes out, we're not going to get that either. Let's say 3 is the last value and then the AsyncSubject completes. Well, this allows our component to get the freshest, or last piece of data, and ignore all the others. And so this is used in any case where the very last most relevant piece of data would be required by our component or components that have subscribed. So to review the three of these, with subject we send data to subscribed observers, but any previously emitted data is not going to be sent as you subscribed later. You're only going to get the data that occurs after you've subscribed. Now with BehaviorSubject, which is one of my favorites, we can send the last piece of data to any new observers, any new subscribers. That way they can still stay in sync. They're not going to have all the previous values, but at least they'd have the latest value. With ReplaySubject we can replay everything that was previously sent. Now you can control that on how much of the data is sent, but that way any new subscribers can get all of the data that might have gone out to other components if you have that type of scenario. And then finally we have AsyncSubject and AsyncSubject, as mentioned, emits the last value, and only the last value, to subscribers or observers when the sequence of data that's being sent out is actually completed. Now the two of these four that I find myself personally using the most are subject and BehaviorSubject. And as mentioned, BehaviorSubject really is a type of ReplaySubject. If you have the need to send out many pieces of data and replay all of it, then ReplaySubject might be more appropriate. Or maybe you just want the freshest, the last piece of data that was sent out. And that could be the AsyncSubject. Regardless of what you need, those are the four big types of subjects that you need to know about. So now let's jump into some code and look at these in action.

RxJS Subjects in Action - Part 1
Let's take a look at RxJS subjects in action. So I have a sample application here that's part of the Angular-Architecture project, and this has four subjects that we're going to subscribe to from a single component that you see here. Now when I hit the Start button, that's going to trigger the subscriptions, but they're going to be delayed. Now the first is going to happen about 2 seconds in and then the BehaviorSubject will follow a little bit later, followed by ReplaySubject and AsyncSubject. Now what's going to happen is you're going to see that while subject only gives you the data that you subscribe to, BehaviorSubject, as we already talked about, will give you the last data, ReplaySubject in this example is going to give us all of the previous data, even if we missed it, and then AsyncSubject will give me that last value once the subject completes. So let me go ahead and run it first, and then we'll take a quick look at the code and see what's going on. All right, so we started it, and now we're subscribing. Now each of these subjects gets a list of customers. It's an array. And it's just echoing out the items. So we're really pushing a customer, pushing a customer over and over. Now you'll notice subject is picking up everything because BehaviorSubject, though it started later, it didn't pick up number 1, but it did get number 2. Now it missed that. But because of how BehaviorSubject always returns the last value, we were able to get it. Now let me start that one more time and let's watch for BehaviorSubject. Now this started subscribing, and you'll notice we did pick up the two immediately, and then everything else flows from there once we've subscribed. Now ReplaySubject started even later than that, but yet it picked up everything. Now the reason for that of course is it does what it says. It replays the data values that it had. In this case I told it to replay everything. Now the last one is about to fire. There we go. So this one waited until the very end, until it hits greater than 10, and then it completes. And then it returns the next value, which is 11 in this case. So that one actually stops, whereas you can see that all the others are still running and they're all in sequence here. Now that would be an example of RxJS subjects in a page. And as mentioned, you wouldn't ever use all four of these, more than likely, at once. But this provides a nice demonstration of how even when you subscribe a little bit later, you're still able to get the data that you want. Now in the case of BehaviorSubject it's one thing, but in the case of replay, we're going to get all of the different things. Let's watch down here for replay. There we go. You could see 1, 2, 3, 4 kind of got dumped out all at once.

RxJS Subjects in Action - Part 2
Now what's going on here? Well, I have in the core, services folder of the Angular-Architecture project, I have four subjects that are defined. So you'll first note that I'm importing the subjects up top. And then down in the class, I'm defining four different subjects. And then I'm exposing an observable, which we'll talk about in a moment. So notice I have a subject of ICustomer. Now I kind of made it very obvious that this is an interface with the naming there. If I peek at it, you'll see it's just a very simple interface with a name and a city. Now all these subjects are doing is just pushing a new item into an array of customers, and then the web page itself is just echoing out the length. As that length changes, we loop through each item we have received. So I track it, as you'll see in a moment, with some different properties of the component. Now going back, I want to point out something here. You'll note that all of these subjects are private, and then all of the observables are public, which is the default for TypeScript if you don't put public or private. You'll also note that each one has a dollar sign. Now the dollar sign is optional, but it's a nice naming convention to represent that we could have a stream of data, or some people would just say it's an observable that we can subscribe to. Now the reason that the subject is private and the observable is public is because you don't want to make the subject public. And the reason for that is while you can subscribe to a subject directly, from a component for example, you wouldn't want to expose the subject because then whoever is subscribing cannot only subscribe, but they can actually do anything that want to the subject. I don't want that. I would not want you changing the subject that I'm trying to own here in the subject service. So instead, what I'm going to do is from the subject expose an observable. And you'll note that I'm doing that for behavior, replay, and asyncSubject. Now if we jump on down, I call start once this initializes and I initialize the subject. Let's go on down to that. And this is really the core piece of the code. This is where we new up each subject, you'll see that down here, but notice I don't just give the subject again as a public member. I instead call subject asObservable, as you'll see in all four of these down here. That means that if you subscribe to it, it'll look just like a normal observable subscription, but I won't be opening myself up to letting you change the subject behavior. Now that's a good practice you can follow, and as we dive deeper into this component communication, and event buses and observable services and things, we're going to talk more about this. But for this demo, these are the main subjects that you saw that are ultimately showing in the web page. Now if we go back on up, what happens is I have a timer that fires right here, you'll see a setInterval, and that fires every 3 seconds. So every 3 seconds this code gets run, I push in a new customer, I clone it, and this is an array we have, customers array, and then the next tier is how we're actually pushing those customers out to any subscribers. So you can see that whether it's subject, behaviorSubject, replaySubject, or asyncSubject, you always call next and then you pass the appropriate data that would have been defined up here for that subject. You'll see that they have generics that are available. So moving on down, that's how we're actually returning the customer array to whoever subscribes. And then in this case, what I'm doing is in the component, I inject my subject service. I'm storing all the data that we would get here from each of the subjects. So every time we get a new value, I store that in here. And then as shown in the web page, I write out the actual length of that. So there is the different arrays I just showed you in this little ngFor. Now what's interesting here though is the subscription process. So you'll notice that I call start here, and that starts the subject service. Now that initializes the four different types of subjects that you already saw back in my subject.service. Now the first thing I do is I call runAction, and this is just a reusable function that takes a log message and then it takes the type of subject I'd like to run or subscribe to. And is there any delay before I subscribe to it? And this is how I'm simulating subscribing a little bit later. So the first one just logs the message you saw, but then the second one kicks off the subject. Now if you remember, each subject back in subject.service, it calls next every 3 seconds. Now we're subscribing before that 3-second period. We're taking 2 seconds. And that would mean we haven't missed any data. So the first time, we have one customer and two and three and we get all those because we've subscribed before the subject has actually starting sending data. Now behaviorSubject, on the other hand, it starts right away with one, two, three, four, but you'll see that we're subscribing after 8 seconds. And so we're only going to get the last value. Now if you do your math here, really tricky math, you have 3 seconds plus 3 seconds is 6, so obviously we're going to miss number 1. We're going to catch number 2 though, and you saw that's what showed, and then any values after the 8-second period once we subscribe. Now replaySubject, because it's set up to replay everything at this point, we're subscribing 13 seconds into this, but yet it gets everything. And as we talked about, that's because it's replaying all the data it had previously emitted. Now asyncSubject is a little bit different. We know you only get the last value after it completes. So in this case we're waiting 15 seconds to subscribe, but the last value hasn't been sent yet, which was 11. So we are able to get that value. Now the code that actually gets called here is just a little switch case statement. If this enum here, so I have ActionType for subject, behavior, replay, and async subject, if it's a subject I'm going to go ahead and subscribe. So this gets called about 2 seconds into the app. And then it just pushes the customers into this array that was at the top I showed. Likewise, behaviorSubject subscribes about 8 seconds in. And then this continues for replay and async. Now what ends up happening though is I delay through this little setTimeout, so I'm kind of simulating a delay here when we subscribe based on this delay that was passed in to this run function. So, the actual code of setting up the behavior and the replay and the async, I wouldn't be too concerned about that. What I do want you to get though is what this does, and how when we start it, because we subscribed to the subject before it started echoing or emitting data out, we were able to get that. Whereas behavior, we got the last value. Replay, we get everything that had happened previously. And then of course, async we get the last value. That's what's really important to get out of this. We're going to continue to talk about subjects, so regardless if you want to look at this demo or just hold off until the next one, what I do want to make sure you get is when you would use these different types of subjects. And so it really depends on the type of data you're looking for. For me, personally, I'm almost always using either subject or behaviorSubject. More often than not for me, I'm using behaviorSubject. But of course it would depend on the application and the needs of the application. So now that we've looked at subjects in action, let's start to dive in to some of the options for component communication now.

Creating an Event Bus Service
Up until this point in the module you've seen different types of subjects and how they can be used. Now what we're going to do is put a subject to good use and make something called an event bus. An event bus is going to allow us to send data between different components, and it's going to be a type of mediator or middleman. As component A wants to talk to another component out there that it may not even know about, it can send data through the event bus, and then the other component can get that data. So the event bus is going to be the communication mechanism between the components, as mentioned it follows the mediator pattern, and we're going to be using a subject, of course, to do this. So it would look like this then. First a component is going to subscribe to an event of the event bus, whatever that event may be called. Now in our example, we're going to have a customer selected event. Now another component is going to raise an event. Maybe when the customer selected and send details about that customer to the event bus. Now when it does that it doesn't know who's listening at all. In fact, it has no idea if anyone's listening at this point. It's just saying, hey event bus, this is what happened. Now assuming the component on the left has subscribed, it will then get the event data and be able to use that data to do something. So let's take a look at the code to make this possible. Going back in to the Angular-Architecture project, into core, services, I have another type of service called event- bus.service. The key to event- bus.service is the subject. And you'll see we have a subject right here, and you'll note that it's private though. Now this particular subject could send any type of data, which is why I have an any in the generic. But if you only had specific types of data, you could certainly lock that down with a class type or an interface or maybe it's just a number or something like that. But here's what we're going to do. When a particular component wants to get an event and subscribe to that event happening, it can say on such and such event, and you'll notice there is an event that can be passed in. The event that you'll see here is very, very simple. It's just an enum, and I only have one event. Now this could also be a string if you wanted. But oftentimes if I use this approach in my app, I try to avoid strings and I'll use an emum here. So, let's say that the component says on events.customerSelected, do something. Well when it gets the data back, it's going to have an action it's going to pass in, which is really a callback type of function. And then we're going to return to Subscription so I can unsubscribe as well. Now here's where it gets interesting though. We know we have a subject. So once they've said on, we're ultimately going to be subscribing ourselves, you'll notice down here, and then the subscription is going to take the action they passed in and call it. So we're actually subscribing in the event bus kind of like to our self, but you're going to pass me a phone number, and once new data comes in to me, I'll then call you on your phone. And that's kind of what we have going on here. Now if we look at the subject pipe, we're doing some other interesting stuff. In this example we only have one event, but we could have many events. Let's say we had 5 or 10 different types of events. Well if you say on customer selected for the event, you probably only want that event data. I doubt you want the customer deleted or the others if that's not what you asked for. So what I'm going to do is use some RxJS operator such as filter and map to filter down to just the event data that you want. So if you passed me an event type of events, customer selected, then we're going to take the filter here, we're going to check the event that actually fired in the subject, you'll see that in a moment down here. We're going to see if the name of the event matches the name that you passed me. So if you pass me customer selected, then obviously the event name needs to be customer selected. If those two match, we continue. That gets us to the map. Now I'm going to grab the event that fired value and I'm going to pass that back. In this case since we only have one it would be a customer. But as mentioned, you could use this with just about anything if you'd like. Now the reason again we're subscribing here is I could expose an observable of the subject as I showed in a previous demonstration in this module, but in this case, when you say on customer selected, you'll pass me the callback function, and I'm going to pass this back. Now that is one way to do it. There's actually several ways you could do this. We could just have you do all the work on the subscription. I could filter it down and then you would subscribe to it. That would be another option, then you'd give it the callback for the subscription. I'm basically saving you the trouble of having to worry about the subscribe portion of it. Instead, you just pass me what the subscribe would do and I'll automatically call it as long as the filter matches with the event name that you have. So this allows us to use the subject, but also some RxJS operators to make this all happen so that you only get the event data for the event that you're subscribing to. Now the component that's actually going to raise the data I going to call emit, and this will allow them to emit an event. Now I have a very simple emit event that takes the name of the event, and I made it an any because it could be a string or you could use the enum, either way. And then I'm allowing you to pass some type of value. Now the value is optional. A lot of times an event might fire to notify you that something happened, but it may not have any actual data for that event. So that's why the value is optional here. So what I'm going to do then is the subject is going to go ahead and call next and pass an event here. So every time you call emit, which I'll show you in just a moment here, then we can take that event data and the name of the event and we can emit it out. Now anyone subscribing to that event, the filter would allow them to get that event data. So, there's not a ton of code here, but yet this could handle any number of events and any amount of data associated with those events. So let me show you an example how we could use this on one side of the equation.

Using an Event Bus Service
Now that we've seen more information about the event bus, let's take a look at how we can actually use it. So if I go on to customers-list, this is a component that just shows a list of customers, and when you click on it I want to notify other components about which customer was selected. So you'll notice that I inject the event bus, first thing, and then what we're going to do here is when a customer is selected, and this is called as they click on a row in the list, we're going to call this.eventbus .emit. Now notice this is the emit event that I showed right here, and that EmitEvent takes the name of the event, in this case I chose to use the enum, and then the actual data, which is the data that was clicked on in this case, the customer. So this is how one side of the equation can communicate with the middle man, which is the event bus, send them an object, which has not only the event name, but also the data. Anywhere else in this app, I can now subscribe to this. So let's just come up to the search here and let's search for a .on. You'll notice in app.component, which is the root component, I have this subscription here. So I'm going to also inject the event bus and say all right, event bus, on this event, CustomerSelected, please call this function that's going to pass me the data, which I'm expected it to be a customer based on the event, and then I'm going to assign that customer up to the top. And in this case, what it does, let me go back to the app here, is it writes it out. So watch right up in this area here, and as I click on the list, it's going to send the event to the event bus. The app.component then subscribed to the event bus and was able to get that customer and we can see it's John Doe, Jane Doe, Michelle Thompson, you can see. Now we're able to communicate between some pretty deeply nested parts of the app and send any type of event and any type of data with that event as mentioned. So this provides a really powerful way to work with this. Now going back to the diagram I showed earlier, the customer list component would be the one on the right. It raises the CustomerSelected event through calling emit on the event bus. Now that sends the event name and the event data to the event bus. Now any subscribers then that have called on CustomerSelected, which would be the component on the left, they then get that event data and only that event data, and then it's up to them to do something with it. Now what's so great about this approach is we can communicate at any different level of the application. No matter how deeply nested a component is, it could talk all the way back up to the top or down deeper or whatever it may be, so it makes it very easy to work with. Now of course there's pros and cons to this approach too though. Now on the pros, it's very simple to use. You call emit anytime you want to send an event, or you call on anytime you want to subscribe to an event. It's very loosely coupled, very lightweight. Very little code, you could see. Now on the con side, though, who's triggering the event? In this example we didn't pass the sender of the event. Now we could have added that though. Imagine you're debugging this, someone else wrote it, and you magically get this event data through the on function call. Now if you want to tweak that data, where do you go? Well, you'd have to go search your code and find the emit source to fix that. So it's so loosely coupled that you normally don't even know where it came from. Now we could enhance that a little bit though. Now loosely coupled events though, in my opinion if you use them too much can make maintenance a bit of nightmare because now it's so loosely coupled that you literally have no idea who's sending data from where. And then of course I didn't show it, but you have to unsubscribe from the subscription that we have, that's very easy to do. I use on to subscribe to the event and get the data, but then in ngOnDestroy, I can take that subscription and call unsubscribe. So this is definitely one option that can be very flexible. If you have a scenario where you need to communicate between different levels of the app, but the different components don't know about each other and don't really want to know about each other. Dashboard's a good example where you have siblings that need to talk. You want to make that really easy. If you have that need to have a lot of different events and you want to just make it very easy to send event data around your app, then this might be an option for you. If you want to lock it down a little more though, I'm going to show another option with observable services, and we're going to cover that next.

Creating an Observable Service
Although an event bus is certainly a viable option for communication across multiple levels of an Angular app, there is another option that'll provide more control over where the data's emitted from, but also what's being emitted. Now we saw earlier that an event bus acts as the middle man, but the receiver of the event data doesn't really know who sent it unless you were to include extra information in the event. In this section we're going to talk about another option I like to call an observable service, and this is going to provide not only the ability to subscribe the data changes, but also to know where those data changes actually originated from. So this would be more of a publish/subscribe pattern, or what we would call the observer pattern. Now with this particular pattern, we're going to have a component that subscribes and the observable service is then going to be able to send data to that subscriber. And we could have multiple subscribers of course, it doesn't have to be just one component. Now as mentioned, this follows the observer pattern, and this provides a very simple way to keep multiple observers up to date, but every one of those will know exactly where the data came from. So if data modifications need to be made down the road, then we'll know exactly where to go. And that would be the observable service. Now this is going to use a subject and an observable, and so what we'll do is we'll expose that observable to anyone that wants to subscribe, in this case it might be a component. And then as that data changes, we'll emit that data by calling next on our subject. Then that data would flow down to any listeners. Now the difference between this and the event bus though is not only is the observable service sending the data, but it's also the source of the changes to the data. So now I know not only who I'm subscribing to, but also who's making those changes. Now this is a more tightly coupled solution, but in more complex scenarios, this provides more visibility into exactly what's going on. If you'd prefer a more loosely coupled approach, then you might want to stick with the event bus. Let's take a look at what the observable service would look like from a code standpoint. So coming into the core services folder of the Angular-Architecture app again, you'll see I have a data service. Now this data service is pretty basic, but it has a BehaviorSubject. Now I chose BehaviorSubject here because I wanted any subscribers to automatically get the last value that might have been sent out, and that way we can keep multiple subscribers up to date as changes are emitted, one of those components subscribes a little bit later, they'll still be able to get that last value that was sent to the earlier subscribers. So you'll notice the BehaviorSubject of customer array here, and we're going to return this customers property. Now I'm not going to expose that directly again. As we talked about, you normally don't want to expose the subject directly. Instead we're going to call asObservable, and that way whoever subscribes, they just subscribe like normal. Now what we're going to do then is if I come down a little further, you're going to see that when we add a customer, I'm going to call this customersSubject next. You'll see that this is exactly the same as what we've done in previous examples. So we raise that data. Now, the difference here is not only is the consumer, the observer, subscribing to the service, but it also can go directly to the service to see what exactly the data is that's being sent. Whereas with the event bus, some component or a service would send an event with the data to the event bus, but we don't really know on the other end, subscribing end, who ultimately sent that data, again, unless we provide a little more information. Whereas with this approach, not only do I know who I'm subscribing to, but I also know where to go to make data changes. Now that's really all there is to this particular aspect of it. So before we show the other side of the equation, let me go back to the app. Come into the Communication tab here and I'm going to add a customer. Now we have a subscriber right up top here. You'll notice this number 3 in the red circle. And as I push a new clone of the customer into the list, that's going to send a notification out to any listeners. Well in this app, the app component happens to be one of the listeners. So let's go ahead and do that. Notice that updates, and then of course 3 goes to 4, and as I keep cloning and pushing, it keeps notifying. Now as you've seen earlier in this sample, these components are pretty far apart. We have app component all the way up at the root. We have this customers list component buried fairly deep in the hierarchy. So this provides yet another way to communicate between components. So now that we've seen that, let's talk about how we can actually subscribe to the data and how that would work.

Using an Observable Service
To use an observable service is very straightforward. We simply need to subscribe to the data we'd like to work with. So let's take a look at that. So coming back into the sample, I showed how our app component at the top is subscribing. Let me come on back into the code, and I'm going to go to app.component, and you'll see first off that we're injecting the data service. Now in this particular example, I'm actually showing two different ways that app.component could get some data. We could use the event bus, or we could use this dataService. Now in this case, you'll see my customersChanged. Now if we go back that's the observable that I showed a little bit earlier, you'll see that right there. And so now we simply need to inject it and we can subscribe, and as we get data we can update the property, and then that property is read from to update the kind of red circle that you saw. Now what's different here though is with the event bus, if I were to right-click and peek at the on, that's not going to show me who actually raised the data. That's just the middle man code as we saw earlier. Whereas if I go into the data service and we jump back over to here, we can jump down to where next is called, as you'll see down here, and if we need to change the data, we know exactly what's happening. So the difference is the observable service not only notifies, but it's also the one changing the data. So you have one place to go for maintenance. Now is this better than the event bus? Well, it has its own pros and cons. It's very easy to subscribe to it, as you'll see, so that's definitely a pro. But let's talk about the overall pros and cons now. So when it comes to the pros, this is a very simple to use approach. You've probably subscribed to HttpClient or other observables in an Angular app. This is no different. The difference though again is the data source is known, which can simplify maintenance. It is more tightly coupled than the event bus, and so if you want that loosely coupled nature again, you might prefer the event bus, but at least I know who's changing and sending the data. It's also easy to share data between multiple layers of our application with this approach, as with the event bus. Now on the con side, it's definitely not as loosely coupled as the event bus, as we've already discussed, but it provides some maintenance benefits. There's also subject variations that you need to worry about. In this case I used BehaviorSubject, but if we didn't want any new subscribers to get that previous value, we might just use subject, or maybe we want them to get all previous values with ReplaySubject. It really just depends on what you're doing. And then of course, just like with the event bus, we do need to remember to unsubscribe, so we prevent any memory leaks. So that would be an example of an observable service. A very simple option, all you really have to know about is the subject or BehaviorSubject or another type of subject, and returning that observable that anything can then subscribe to. And that's it. From there it's pretty straightforward and easy to use.

Unsubscribing from Observables
How do you unsubscribe from observables in your application? Well, for most of us, we would add an ngOnDestroy, and then we would call unsubscribe on the subscription object that we'd capture from subscribing. And that's a pretty standard way to do this and there's nothing wrong with that approach. But there are some other options we're going to discuss here. One of those is a decorator called AutoUnsubscribe. And the other is an npm package you an import from my friend Ward Bell called subsink. Now we're going to discuss all three of these approaches, and that way you can choose which one works best for your particular application. Now most of us are used to doing the following. We subscribe to something, in this case we have an event bus on, and when the on is returned it returns the subscription. We capture that up in the property. And then in ngOnDestroy we make sure that we have a subscription, if we do, we call unsubscribe. Pretty standard approach, and that's what you'll find in most of the documentation and examples out there. Now there's nothing wrong with this approach at all, but if a given component has several subscriptions, this does mean writing a fair amount of code. You have to capture those in the properties and you have to, in ngOnDestroy, call unsubscribe from each of those subscriptions. So another technique that can be used is a decorator called AutoUnsubscribe. Now you'll notice right on top of the class, we have this AutoUnsubscribe, and this is an npm package you can grab and use in your application. And what this decorator does is it automatically iterates through the properties of your component, finds all subscription types, and then when ngOnDestroy is called it automatically calls unsubscribe. Now this does mean you still have to capture your subscriptions up in properties because it requires that, and you still do have to put the ngOnDestroy. Now it can be empty, but you need to put it. What it saves you though is the code to call unsubscribe. Now originally I started using this because I had a lot of subscription properties and I was talking with my friend, Ward Bell, about this particular approach. And while we liked it in general, he had an idea to make this even better, which ultimately became a package up on npm called subsink. Now subsink is actually a very simple way to handle all of this. So first off, you can import this package through a standard npm install. Once you have subsink available, you new it up and create this property I call subs that you'll see. Every time I want to subscribe to something, instead of having to individually capture the subscription I simply call subs.sink, and this will automatically add it into a collection of all the subscriptions. Now in ngOnDestroy, I simply say subs.unsubscribe, the code will then automatically iterate through all your subscriptions and call unsubscribe on those. So this saves quite a bit of code over the original one I showed where we have an ngOnDestroy, maybe multiple subscription properties. And then we have to unsubscribe manually. And it even saves code over the AutoUnsubscribe decorator that I showed earlier because I don't have to have multiple subscription properties. Now which one of these is best? There really is no best, just make sure you unsubscribe of course. But if you want to save some code, I now use subsink for pretty much everything I do when it comes to unsubscribing from observables that I might have. Now if you prefer, you could use the decorator, or maybe you just want to keep it the good old way where you have ngOnDestroy, you have your subscription properties, and you write the code to unsubscribe. Or maybe you go with an entirely different approach and you use something like a takeUntil operator. Regardless of which way you choose, there are many options out there, and those were a few of the key ones that I've run into and that I like to think about as I'm working with teams and observables.

Summary
In this module, we talked about different communication techniques that could be used to talk between components at different levels of your application. We started off by talking about the different types of RxJS subjects that are available, and I mentioned the subject, BehaviorSubject, ReplaySubject, and AsyncSubject. Now I personally use BehaviorSubject the most because it does provide new subscribers that last emitted value. That can be really convenient when you want to keep new subscribers up to date with what happened previously. Now from there we talked about how a subjects can be used in different ways, and we talked about a very loosely coupled approach I like to call the event bus service. This technique provides a middleman type of approach, or a mediator pattern, so that a component can send data, another component can receive it, and they don't have to know anything about each other. They just have to know about the middleman, which would be the event bus. So it's very loosely coupled, as mentioned. Now another option we talked about was the observable service. This provides a way for a component to still subscribe to changes in the service, but the service performs all of the work. So from a maintenance standpoint it's pretty easy to know where to go if you want to tweak the code in any way. And then finally we talked about different techniques that could be used to unsubscribe from observables. Whether you use the standard ngOnDestroy with subscription properties and then call unsubscribe, the AutoUnsubscribe decorator, the subsink option that I showed, or even other techniques. There's other operators, for example, such as takeUntil that you could even do. It really doesn't matter. Of course make sure that you unsubscribe, but I would recommend as a team that everybody gets on the same page as to which technique you're going to use. And that way your code's going to be consistent, and as team members maybe leave on vacation or switch departments or whatever it may be, it's going to be a lot easier to get that code maintained and to handle change requests.

State Management
Introduction
Earlier in the course, we walked through how we could use services in RxJS to manage state and pass it around in an application. And that provides a simple way when components need to talk to other components. However, as an application grows, you'll often find that you need to take a more serious look at how you're managing state in the application and the techniques and code that you're using. And so in this module, we're going to look at that exact topic and talk about a few options that are out there that can help with state management. So here's what we're going to cover. First off, we're going to address the need for state management. This may or may not be obvious to you. If you've only worked on a simple app then it probably isn't very obvious, whereas if you've worked on a more complex app, it's probably become very obvious. From there, we're going to explore some different state management options that are available. First, we'll just start off by discussing how services can be used. From there, we'll take a look at a more robust option called NgRx. We'll also look at an extension for NgRx called ngrx-data. And finally, we'll wrap up with something called Observable Store. Now there are several other options out there. I'm going to address those as we move along, but it's not possible to look at all of them in one module, so we're going to focus just on these four. From there, we're going to review these different options, talk about code complexity versus simplicity, which will give you something to think about as you're deciding on the state management technique for your application.

The Need for State Management
One question that I get a lot as I work with various companies is do I really need a state management solution for my Angular application? And the answer really is, it depends. There are many cases where an app is simple enough that you can get away with just what you'd normally use in Angular, a combination maybe of components and services. However, as the application gets more complex and as more developers are involved, state management can be a little bit more of a chore and it can oftentimes be difficult to know where changes are coming from. So let's look at an example of this. So let's assume that we've created a component tree like you see here in the application. And we're going to use some means to get data into these components. And then if we need to pass from parent to child, we can just use input and output properties. So for example, let's say that we have some type of an object that is going to feed us data. That data then flows in and comes on down to where it's needed. Okay, well, that's pretty straightforward. Not really any need for state management in this case because it's very, very simple. But as the application grows and more developers become involved, we find that we have multiple objects supplying data, and now data changes can be made in multiple places. And if the developers aren't really talking about what they're doing or communicating very well, what happens when the one on the bottom is updating customers, but the one at the top is also updating customers, and before we know it, customers are now being provided in multiple places. Now to further complicate the matter, we might have yet another developer that's also building some type of a means for getting state into our app, and now we have a little bit of a mess because if each of these objects is storing their own unique copies of very similar state, let's say, then now debugging is a chore, maintenance is a chore, and as new change requests come in, what you're going to find is it's confusing because you're going to work with a component and you're going to see that, oh, well this one is getting it from here, but this one gets customers from here, which one am I supposed to use? And that's really the challenge that comes up. So what we're going to do is talk about where state management makes sense and where maybe it doesn't, because as I've said many times throughout this course, I believe in the right tool for the right job. And I don't think state management is necessarily needed in every type of app out there. Some of the apps are simple enough that you can just get away with the basics, which would be services. In more complex apps though, we might have some specific goals we'd like to achieve. First off, we probably want a single source of truth so that we're not updating state in multiple places and really causing a debugging nightmare. We want things to be predictable. We also want immutable state. You need to go through one place if you need to change the state, but the state itself never changes. We always just create a new state. We'll talk about that as we move along quite a bit. We also want better debugging. We might, for instance, want to track state changes so that we can see kind of before and after effects and see what action actually caused that state to change. That would make it easier down the road to debug your applications. Now the different options we're going to be talking about throughout this module are going to satisfy these key goals and a few others in some cases. But before we jump into that, let's take a look at different state management options that are available.

State Management Options
Every application is going to have data that flows in and out of it, but the need for state management really depends on the needs of the application and what's being stored. There are some very robust solutions that are out there that are going to be a lot more code but provide a lot of power. Then there's some very simple options out there. And we've already looked at a few of those, and we'll review those coming up here. So let's look at some of the different state management options that are available for you to evaluate as you're going through your application and the overall architecture. So first, let's start by addressing some of the different state that can flow in and out of an application. Of course, the application itself may have some state it needs. It might have some URLs that are passed to it, some security information or other types of things that are needed. There might be some session state that's unique to the user. This could be user preferences, for example, or settings for that user. And then of course you have the actual data used in the application, our entity state. This would be the customers, the orders, the invoices, or whatever it may be that the application's actually working with and displaying and then collecting data as the end users are interacting with the application. Now regardless of the type of state you're working with, there's various options out there that can help us manage this state in the app. Now the most simple one would be to just use Angular services. We've talked about services quite a bit up to this point. We're going to review the use case for managing state with services. A more robust option to services would be NgRx. We'll be talking more about NgRx and the different features it offers as we move along throughout this module. Now a simplified version of NgRx is called ngrx-data. This is an extension that wraps NgRx functionality and makes it much easier to work with, with much less code. We're also going to look at something called Observable Store. This builds upon the observable services we talked about earlier, but adds state management into the mix, and it allows different subscribers throughout our app to be notified as our state changes. Now these are the main ones we're going to discuss, but there are some other options as well. Another option would be Akita, NGXS, or MobX. Now I'm not going to be able to go through every single one of these because each would deserve a little more time than we have for this one module, but these are some different options you'll want to look into as you're evaluating state management techniques and the overall architecture and data that's passed around in your application. So let's start off by talking about what if we were just to use Angular services for state management?

Angular Services
Angular services provide a great starting point for working with state in our application. After all, if you want to perform reusable calculations on the front end, validation, or maybe talk to the server through HttpClient, then of course we would use an Angular service to do that. The Angular documentation describes the service this way. "A service is typically a class with a narrow, well-defined purpose. It should do something specific and do it well. " We've talked about different ways services can be used for communication and other tasks throughout this course. Now when it comes to using services for state management, I think it's a great place to start. It's the simplest approach. You've got to be careful though, and we're going to talk about some of the complexities that can be introduced if you only go with just pure services in your application. For many simple apps though, I think services get the job done. And many of the companies that I've worked with, they've actually decided just to go with services whereas others have chosen some of the other techniques that we're going to be talking about. What's nice about services is we can inject them wherever they're needed, very simple to work with, and of course we can even provide notifications to subscribers by using subjects. And we talked about that earlier in the communication portion of this course. Now is it all roses though when it comes to services? Are they the de facto option? Well, if they're the right tool for your application, then maybe, but let's talk through some scenarios where services might fall down a bit and not meet the needs of state management. Now, as you're working with components that need data, services are great for this because they provide that one place to go, very good for maintenance, very good for change requests, reuse, all of those things, and they're very simple to use, as we've already seen. And if we have other places that need services, that works great as well. So we might have many services in an app that are being used by components for different tasks. Maybe one is for customers, one is for orders, one is for invoices, and so on and so forth. Now where things start to get a little more complex though is when multiple services are needed by a given component. So for example, this service is going to be injected into this component here, but then maybe that component right above it, it needs this other service, plus the service on the right of it, and now things tend to get a little more complex. Why? Well, not from the injection standpoint. That's easy. But what if we as developers didn't realize it and we stored our customers in two of these? For whatever reason, we simply didn't talk and didn't know that you built one service that gets customers, I built another. Mine updates customers, yours updates customers, and now before you know it we have a little bit of a mess on our hands. Now, of course this can all be mitigated and dealt with if we just communicate well, but oftentimes when you have different teams involved or different developers, or just a really complex app, it's not so cut and dry, of course. So how do we solve this with services? Well, the short answer is we can still keep services here, but we would need to have a centralized store for our state, and then each of these services can then talk to that store. Now if we can do this in such a way where we can guarantee that the orange service and the purple service and the blue service here are all using the store as the centralized storage location for our state, then we could probably get by with this solution in many types of apps. But how are we going to guarantee that number one, every developer is using the store, that we're not mutating the state somewhere else, maybe a fourth service, for example, is introduced and that person didn't realize we had this store, and therefore they're now updating state where they shouldn't be. So there's a lot of issues that can come up with this, but it certainly is an option. Now as an application grows and grows though, there might be a more formal approach we can take, and that's what we're going to look at with some of the other options for state management.

NgRx
One of the most popular state management options out there for Angular is NgRx. Now if you go to ngrx.io, you'll find this definition. NgRx Store provides reactive state management for Angular apps inspired by Redux. Unify the events in your application and derive state using RxJS. Now, I want to emphasize up front that NgRx is a very big topic. In fact, there are other courses on Pluralsight that you can check out if you're interested. The goal here is really just to explore the key building blocks of NgRx, explore some of its goals, and then I'll show a demonstration of how we can put it into action a little bit later. Now as the definition just implied, NgRx is really Redux, which is made popular through Facebook and React, combined with RxJS. Put those two together and we have NgRx. Now the main goal of NgRx is to provide that single source of truth for your state, and also a way to provide an immutable data setup so that we're not mutating or changing data in multiple places throughout the app. Now by following NgRx and the different building blocks I'm going to be talking about, we can provide greater consistency across a team of developers. We can also provide a very nice debugging experience because NgRx ties into a Redux tool that will let you watch your store and see changes to your state as it flows throughout your application. So if you haven't looked at the NgRx before, let's walk through how it works, some of the key building blocks, and the overall state flow by using different features of NgRx. So first off, let's say we have a component that ultimately needs to get data. Now, the de facto Angular way that we just talked about earlier would be to inject a service. And while that's certainly viable, that won't necessarily be the NgRx way. With NgRx, we're going to have the following building blocks available. First off, we're going to have a store, and the store is responsible for storing the state of our application. Now this could be any type of state that you want. It could be app state, session state, or entity state. It really just depends on what you need to store. Now in order to interact with the store and the state, we're going to send actions into it. Those actions will then be passed to something called reducers. Reducers are basically translators that'll take the action, act upon it, and then they're going to interact with the store state. And then of course we need to get data back to the component, and we can do that through selectors. So the flow would look like this. A component will send an action. The action goes to a reducer. The reducer is then going to modify the state in the store, and then we get that back through something called a selector. Now that would be a basic rundown of how things work. Now of course, we might need to talk to a server though to get data as well, and that changes things. So for example, if the component needs to get customers, it would send a GetCustomers action. That now is going to trigger an effect, which you would have to write the code for of course, which then integrates with the server and gets the data from the server. Now once the effect gets that back, that'll send the appropriate action that we now have the data. That goes through the reducer, which updates our store, and then the selector gets our data back to the component. And that's the general flow of how NgRx works and the overall set of features that it provides. Now what's interesting here is NgRx and the different features it provides satisfies the key goals that I mentioned earlier for state management. It also provides a very predictable pattern that everyone on a team can follow. Now as I like to say a lot, is it all roses? Not necessarily. It does satisfy those goals, but it does come with a little bit of cost, and that cost is complexity because it's going to add a lot of code into your application. And while having this very defined pattern is great for a team, if everyone on the team doesn't have a good understanding about actions and reducers and selectors and effects, then I think actually you could get in trouble that way. And I know of some teams that have gone down this road and then kind of turned around and came the other way and said no, it's a little more than we were banking for. I know other teams though that everybody had a very good fill about how this works, they bought into the pattern, you know, they liked it, and it's worked very, very well for them. So I think it really needs to be considered on a team-by-team basis, not only taking a look at the skill level of the developers, but how often are they communicating and talking about these different types of things. So now that we've talked about the key building blocks of NgRx, let's take a quick look at a sample that uses it.

NgRx in Action
Let's take a look at an application now that uses NgRx and goes through the concepts of actions and reducers and selectors and effects. So you can see the application here, it's a very simple, straightforward app, but a great way to start learning. And I'm going to be using this exact application for the other state management options I'm going to discuss, and that way you'll have a nice point of comparison. Now the app itself simply shows customers. You can sort and filter those. That's just done locally in the component, so no NgRx there. But as we go in to view the orders, that's going to load those orders using NgRx, and of course as we edit a customer, we can go in here and do that, and that's also going to be using NgRx. And so a little bit of CRUD type of operation going on there. So now that we've seen that, let's jump to the application code. Now first off I had to install some packages that you'll see here, and those are the effects, the entity, the store, and the store-devtools packages, and you'll find those in the package.json. Now once that was done, I went ahead and added a store folder, and you'll notice I have some actions, effects, reducers, and I do have some services as well that we're going to be talking about. So what's ultimately going to happen is when the customers need data, this customers component is responsible for working with that. So it's going to inject our store, and that store is going to have our entity state as you can see here. Now I'm also injecting the selectors, because as the store changes, I want to subscribe to that so that this component can get those changes and push them down into a child component, which in this case is the customers list that you'll see here. I'm also monitoring when are the customers loading. That way I can show a spinner very easily if I wanted to go that route. So the first thing I'm going to do is we're going to call getCustomers, and that's going to dispatch an action to the store. You'll notice I create a new CustomerAction.GetCustomers. So if we jump to that, this'll be our first action definition we'll look at, and you'll see it right here. So you can see in this case, GetCustomers is a very simple action, it implements an interface called action, actually. There's actually three of these. There's GetCustomers, which starts it; GetCustomersSuccess, which lets us know when the action occurred and we have the customers, notice the payload here is going to be a customer array; and then GetCustomersError, and this would be called, of course, if we have an error. And this is the action. Now, the action is going to be sent up to the reducer. So I have a customer reducer, and that's going to be used to actually handle this. So if we scroll on down a little bit to the reducer function you'll see here, it takes the state and the action to perform. So in this case, we sent a GetCustomers action. Well, that's going to come in and call the GetCustomers, and you'll see that right here. Now that is going to be responsible for returning the appropriate state. But in this case, there's a little more to the story because we need to get that state from a server, so we need an effect. And I'll get to that in just a moment. But, this is where the reducer is going to take the state, make a new object, and then it's going to set the loading property to true. So this is now going to interact with the store, and specifically with the state in the store. Now I mentioned that there's an effect though that's going to be responsible for actually getting the customer. So if we go into customer.effects and scroll on down, you'll notice I have this getCustomers. Now, this is going to monitor for that particular action, and when that action occurs it's going to call a service, which gets our customers. So if we jump to our getCustomers, this is now normal HttpClient, you'll see that injection right up top, then that's going to actually return the data. So let's go back to the reducer. So again, we send an action. In this case, that action's going to be intercepted by this effect. That's then going to return our customers, as you can see here. Once that happens, our GetCustomersSuccess action is going to be passed. And then if there was an error, our GetCustomersError would be passed. All of that boils down to the reducer though, updating the state in the store. Now what's going to happen from there is we also have selectors. And so in addition to what you see here, you'll notice that I also have a customer.selectors, and this is going to be responsible for, in essence, subscribing to the store. So notice I have a getAllCustomers, we call createSelector, and this is something from the NgRx store, and that's going to return that customer state, which is the customers in this case. And now if we go all the way back to the component, which is right up here, that's where we're going to grab that. So the process starts again by dispatching this action to the store, the effect gets called, it gets the data, that sends the action to the reducer which updates the store, and then the selector ultimately round-trips the data back to our UI here, our component. Now from there, this is an observable you'll see of a customer array. And then I pass that into an input property and I use the async pipe since we have an observable in this case. Now, you can see that there's quite a bit to this, and if I went through the orders you'd see a very, very similar story, but it's also very predictable. You always dispatch an action, reducers get called, effects maybe get called, the store gets updated, and then selectors return the data back. And so as long as everybody is dispatching from your components, everybody will have a very consistent way to work with this. Now, the final benefit I want to point out is when I go back, you'll notice a little tool up here. And this is a Redux tool, it's called Redux DevTools you can get for Chrome. And this'll allow me to actually replay my state. So notice as I push play here, you're going to see the UI change. There's the state just filled in. And I can actually rewind and see this state at different points in the application load process. And notice on the left, here's everything that happened. So as I walk through, you'll notice that changes and it provides a great debugging experience and there's all kinds of fun stuff you can do with this. You can also come in and actually see the payloads. Here's the actual customers I got back. And then we can then step through the different tasks that occurred here. So it provides a really nice level of visibility into your application as the state is actually changing. So I mentioned earlier, NgRx is a very big topic, not something I can cover in a very short time span, but I hope that at least gets you thinking about the building blocks. If you want more details on that, I'd recommend checking out the other NgRx courses that are up on Pluralsight.

ngrx-data
The next state management option we're going to take a look at is ngrx-data. Now this is still NgRx, as you'll see, but greatly simplified. So here's the official definition. Ngrx-data is an NgRx extension that offers a gentle introduction to NgRx Redux without the boilerplate. And it really does exactly that. Ngrx-data is just an extension, more of a wrapper around NgRx, but it greatly simplifies it. You don't end up writing all that boilerplate code for your actions and your reducers and your effects and your selectors. Ngrx-data wraps all that for you and really makes it where you can write one line of code per entity that you want to work with, and an entity would be of course something like your customer, your order, your invoice or whatever it may be. And then you'll see as I go through the demo, you'll write a service that acts as kind of a gateway, if you will, to that entity to get the data, and you don't even have to write your HttpClient type of code if you don't want to. Now of course, apps always have different needs, and we can customize NgRx data. So if you need to get deeper into a given reducer or a call to the server, then of course you can customize that as well. So here's a visual look at how NgRx data works as far as the state flowing through your application. So first off, a component is going to have an NgRx data service injected. So instead of dispatching to the store, as you saw with NgRx, instead it'll use this service to actually get the data that it needs. So the component will call over to the service, and this NgRx data service will wrap an entity, so for instance a customer. Now behind the scenes, the service will then communicate with the actions, reducers, effects, and selectors that we talked about earlier, and ultimately update the state store. Now once that's done we'll subscribe to an observable, and behind the scenes we still have selectors. And so the NgRx data service will provide a way that we can then get to that entity once it's available. So you can see it provides a really simple way to get started with NgRx because now you're not writing the code for your actions, reducers, effects, and selectors, and so a lot less code is actually needed. Now the other benefit to this that I'll show as I demo it here in a moment is that the Redux developer tools, they're also going to work with this because again, ngrx-data really is nothing more than NgRx under the covers.

ngrx-data in Action
Now that you've seen a little bit about ngrx-data, let's jump into a demonstration. So the application that you see here may look very familiar because it's the exact same application, just reworked to use ngrx-data. Now, you'll see that I can still come in, I can sort, I can filter my customers, all the same things, view orders, and we can edit as well. So we'll just put in some updated data. And there we go. Now, the difference though is instead of using everything that you saw with NgRx, this is now using a very simplified approach. So now that we've seen the application, let's take a look at the code. So the first thing I want to do is jump to the customers component, which I also did in the NgRx demo, and show you that it's a little bit different. Now, up top you'll notice I still have a customers property, and this is an observable of a customer array you'll see. But you'll note that I don't inject any store down here. Instead, I inject a CustomersService. So at this point it looks like standard Angular. Now we're going to use that customersService down here and we're going to call getAll. And I'll show you that in just a moment. But this isn't something I actually wrote. This is something that's part of ngrx-data. So let's jump to the service itself, and you'll notice it's very, very simple. We have a CustomersService and the magic here is that it extends this EntityCollectionServiceBase of type Customer, and that's my entity, if you will. Now from there, I call in to the base class, I pass the name of the entity and I'm passing in this serviceElementsFactory object, and this all documented in the ngrx-data documentation. But you can see that there's really no code. In fact, there's not even any code to call the server through HttpClient, for example. It will do that for you out of the box as long as you configure your entities in a certain way. And I'll show you that in just a moment here. So let's take a closer look at the entity aspect. And I'm going to go into the core folder. And first off, you'll notice I have some models. So I have a customer model, a very simple class, and then I have an order model that you'll see right here. Okay, so very basic, nothing really fancy there. That's kind of the first step though that you'll have to do. Now, from there let's go ahead and shrink these up and let's go into my store folder. Now in here you're going to see I have an entity- metadata file. And this metadata file's very simple. This is actually going to define our entities. Now in this case I have two entities, Customer and Order, you'll see. Very, very simple here. Now, if you need to pluralize the names in different ways, so for instance if you had goose, but it needs to be geese, plural, then this pluralNames which can be passed down here can be used to define that so that it pluralizes correctly. Now the beauty of this is remember earlier I said it's basically one line of code per entity. Well, here is the one line per entity that I mentioned, so we have Customer and Order. I then register those with my entityConfig into here, and then if I go into the app-store, this is actually where a little bit of the magic happens. And you'll notice my StoreModule, EffectsModule, NgrxDataModule, and notice my entityConfig. Now, these two here you're going to do with regular NgRx. So as mentioned, it is NgRx under the covers. But the registration of my two entities, that's being passed in through the entityConfig into this NgrxDataModule. Now I'm also tweaking the call to the server a little bit. By default, it will either use a plural name or a singular version, depending on if you're getting a single customer or multiple. And so I need to tweak it just a little bit. You'll see customers because I like to use the plural for everything whether it's all the customers or just a single customer. So what's nice is ngrx-data will let you override various aspects of your application as you need. So you're not locked into one thing. Again, it's still NgRx under the covers and you can still get to that functionality if you need to. Now it does add this bonus functionality though of being able to call the server for you, you don't even have to write your effects or your HttpClient calls if you don't want to, and that's pretty nice. So if I go back to orders, it looks very similar to the customer service. Notice we have an OrdersService, it extends the same EntityCollectionServiceBase, but then we give it the entity type. Now from here, everything's identical, and this will also make it possible for me to call and get orders without actually writing the HTTP code. So if I go into orders.component, you'll notice in this one it's a little bit different because I need to get the orders for a given customer. So I'm going to use the ActivatedRoute to grab a route parameter called id, and then the ordersService I just showed, in addition to get all, which would get everything, it has an API called getWithQuery, and now I can actually say, well let's pass in the customerId on the query string, for example. And this makes it very easy to customize as you're calling the server. Now if you don't want to do this and you want to step outside the bounds of that entirely, that's also possible, and you can go back to your normal effects if you'd like. Now in the end, what ends up happening, if we go back to the customer.component, is I call getAll in this one, that will then call the customers URL, get back the customers, and then that gives me back this observable of a customer array. And then, just like normal, I would go into my view, and in this case I have an async pipe, and I pass it into our customers-list. Now what's interesting here is you'll notice it was a very minimal amount of code, but yet if I go back, notice I can still use the Redux DevTools here. Now it's a little bit different. If I rewind this all the way back, you'll notice as we kind of start up top, in fact let me refresh this real quick, there we go. So this part here starts out very similar, but then notice this ngrx-data/query-all. We can jump right to that. And that's where I'm actually getting the customers. And then when they come back, success gets called and then we have the actual customer entities that'll be loaded here. That's a great feature to have, to be able to still use these Redux developer tools to step into the state and the flow of it throughout your application, but yet you don't have to write all that NgRx boilerplate code. So if you're going to be moving to NgRx on your architecture, this is definitely something you'll at least want to explore. I'm not going to say that it's appropriate for every application because it may be that your payloads you're passing in your actions, your effects, are just so custom that maybe this doesn't make sense. But by knowing about the different options at least you'll be able to explore that and see if it fits for your application.

Observable Store
As you're thinking through the different options for state management in your app, you may come to the conclusion that services alone may not do exactly what you want, and maybe NgRx is more than what you want. Well in this section we're going to talk about a middle ground type of approach, and it's one that I put together and that I have used in several different projects, and I call it Observable Store. Now, here's how I define it. Observable Store provides a simple way to manage state in a front-end application while achieving many of the key goals offered by more complex state management options. Now the reason this came about is in my job I have the opportunity to work with a lot of companies, whether it's training or architecture or some other things we do, and so I get to hear a lot of stories. I hear some great stories of success and I hear some not-so-great stories of this didn't work so well for us. Well, in a lot of those stories people start out with services and ran into some of the issues that we talked about earlier. And that's where one service was injected into a component, it made an update, then another service was also injected and it turns out it was also updating something, and so your state was being updated in multiple places. Now there's been other companies that jumped into NgRx and then decided it wasn't quite what they wanted, so they wanted a middle ground type of approach. And while there are other options out there now, I mentioned there's Akita, NGXS, or MobX as an example, this is one that satisfies the main goals I had and that many of these companies I've worked with had. So here's a few of those key goals. First off, I wanted to have a single source of truth. I want to have that single place where our data ultimately is stored. Next, I wanted the state to be read-only and immutable. Now from there, other components in the application might want to know when the state changes, so I might want to provide state change notifications, very similar to an observable service that we talked about earlier. I also wanted the ability to track state history. This gives us a before and after type of view and it makes it much easier to debug. Now, the next goal's really important. I wanted a very minimal amount of code. Some people are turned off by more complex solutions where you're writing just a ton of code in some cases. And in this case, it's just going to be services with a little bit more, very minimal though. Then this final goal was a little bit unique. Some of the clients I work with aren't all using Angular. So I wanted something that I could use anywhere with Angular or even React or View or just vanilla JavaScript maybe. And it satisfies that as well. So here's how it looks visually. A component is just going to call in to a regular Angular service. Now what's unique about this service though is it's going to extend Observable Store, and this is a class you can get, it's an npm package, and it's going to maintain the state and provide a very simple API for interacting with the state. If you want to get the state, you call getState. If you want to set the state, you call setState. And then in addition to storing the state, it also tracks it, so you'll see a begin and an after type of version of the state if you'd like to get to that for debugging purposes. So as the component calls in, the service will interact with the Observable Store. Now, everything else is just normal though. If you want to make a call to the server, then you just use HttpClient as normal. Now there's no actions, there's no reducers or effects. It's nothing to do with NgRx at all. It's a very simple way to have a single store that multiple services could read and write from in essence. And the store is immutable. You're always getting a fresh copy out of it when updates are made. Now that alone is very useful because now we have a single store that multiple services can interact with. But I also wanted components throughout an app that need to know about changes to the store to be able to subscribe to those changes. So it also supports that. Now, that gets us back to earlier in this course where we talked about component communication, and specifically what I called observable services. Now, observable services were a way to exchange data between components, but they didn't really do anything when it came to storing the data. So think of Observable Store as like an observable service, but with an API and a history tracker to actually track changes, update the state, get the state, and do those types of things. Let's jump into an example of using Observable Store.

Observable Store in Action
So here's the same application you've seen in several prior demos on state management. It shows customers and orders and allows for some edits. So I can drill down, as you've already seen. I can also edit, submit. I even added a delete on this one if you wanted to play with that. But that's all it does. Now if we jump to the code for this, it's very, very simple to get started. The first thing you'll need to do is install a package called observable-store. You'll see that here. Now once you've done that, you create a service that extends ObservableStore, and then you need to tell it what is the state I want to store in this. So if I peek at this, you'll see this a very simple interface that stores three things: customers, a customer, and orders. Now whenever your app needed a store, you would define it there, and then this service can now interact with that shape of data, if you will. Now, the component is then going to be calling this, and so we'll inject our service, and I'm going to call getAll. Now I purposely put the same exact function name that you saw earlier with ngrx-data, but in this case we're just calling a normal service. So if we go to this definition for getAll, you'll see the first thing I do is I call this.getState. Well getState comes from the ObservableStore base class that you saw. It's a protected member. Now that's going to get us any state if we have it. The first time this loads there won't be any, so we'll call fetchCustomers. FetchCustomers now goes and gets the customers from the server using HttpClient. And then once those customers are mapped back in to our operator, we're then going to set the state if we'd like to add those into the store. So in this case, that updates that customers property you saw. Now, setState also allows the type of action that was performed to be stored. Now this has nothing to do with an NgRx type of action, this is just a simple string value. If I come on down to the bottom, I made an enum, and each enum member simply has a string, you'll see. Now that's important because as it adds to the state here, it will log it, and that log now will carry this name for the action. Now as a heads-up for the logging, the way this works is because I extended a base class I have to call super. Well, in super, when I call that base class constructor I'm passing an option here, a setting called trackStateHistory and setting that to true. Now this is very useful in debugging mode, and I'll show you this in a moment, because every time something changes in the state I can check the before and the after type of picture. And that will show me what's going on in my store. Now if I went to the orders, it does the same thing. I have an ordersService. It also extends ObservableStore with the same shape of data. Now any time I call setState, that's going to update, in this case, one property in the store called orders. And that way we'll always know when our state is changing. Others can subscribe to this if we need to. Now, going back to the application, if I go in and go to Orders and maybe come back, I've already added a log statement to log out the state history. And here it is. First thing that happened is we had a get_customers, and then get_orders, then we got a single customer, and then we got all customers again. And what's happening here is it'll show you the begin and the end state of each of these. So the very first one, there's the beginState, it was completely null because there was none. But the endState ended up with four customers. Now moving on down to, for instance, get_orders. Well, in the begin, notice there was only a customers property here, whereas in the end there's an orders property. And so now I can go through and very easily see what's going on with my store state. So that's an example of the fundamentals of Observable Store. Now, is it appropriate for every app? Well just as I said with NgRx or ngrx-data or any of the other options, I don't think there's one size fits all. Right tool for the right job, you've heard me say many times throughout the course. I think this definitely fits a need. It's worked out well for us, in my company, and a few other companies I know are using it as well. But I think it's something you need to evaluate. Now you'll know about a more simple option and can compare it to some of the other options out there and then make a decision that you think is best for your team.

State Management Review
Throughout this module, we've taken a look at state management, the need for it, and several of the different options that are available. So we looked at services and the limitations that you can run into there, NgRx, ngrx-data, and Observable Store, and then I mentioned there's several other options out there that you'll see here as well. So let's do a quick comparison of the different state management options that we went through in this module. I'm going to compare these by going through some of the key goals that state management solutions have. Does it provide a store? Is the data immutable? Does it provide debugging support? What about tracking state history? Change notifications to other aspects of your application? And how simple is it to get started with? So if we break down one by one, if we go to provides store, then we know NgRx, ngrx-data, and Observable Store all provide a store. Core services don't. You could create your own, but you're not going to get that out of the box. For immutable data, NgRx, ngrx-data, Observable Store provide that. Core services do not. However, you could do it using something like Immutable.js or just a cloning technique that you might employ in your own code. Debugging. Well, NgRx and ngrx-data have a great story there. As shown, they can use the Redux DevTools. Now the other options, Observable Store and Services, don't have that, so that's something to consider as well. When it comes to tracking your state history, all three of the state management options support that. Services of course don't. However, you could build it custom, but that's where I start to question do you want to build it custom or go with something that already has that built in? Change notifications. All three support that. Services don't out of the box. However, we talked about how you could use subjects and create an observable service, so it would be possible with services. And then finally how simple is it to get started with? Well, I'm going to argue that NgRx is not as simple. You really do need to understand the pattern and the code that you're going to be introducing into your application. Now, ngrx-data because it wraps NgRx, in my opinion anyway, is pretty simple to get started with. And then I think Observable Store is very simple to get started with. Now services, they're the most simple thing we can do because they're built in to Angular, of course. So that's a quick look at some of the key goals that the state management options we discussed in this module support and will hopefully give you a frame of reference to compare. Now, how do you go about choosing one of these or one of the others that wasn't covered? To me it really comes down to each application. How simple or complex is the app, or is it just medium complexity? You know, where does it fit on this arrow here between simple and complex? Well, services could go anywhere. Of course, you could use them with simple. In fact, I would recommend starting there with simple applications that aren't complex or just don't have a lot of local state. Maybe your application only talks to the server for everything it does. Well in that case, you may not need to store a lot of state. You may not need the immutable nature of state management and the other things that I mentioned earlier. Now when it comes to more of a medium-size complexity app, then I think ngrx-data fits really well there because it'll give you that power of NgRx without introducing a lot of code into your application. And then Observable Store's very simple to get started with and technically you could probably use that with simple, but if it's really simple I'd say just go with services. Keep it as simple as possible. If you said, well Dan, we have multiple components that need to be notified as something happens, well, then maybe you go with ngrx-data or Observable Store because they both would support subscribing to changes to the state. Now, as your app is more medium to complex, if you understand Redux and the overall pattern provided by NgRx and are okay with introducing quite a bit of additional boilerplate code into your app, then this is a great solution. As mentioned, I know several teams out there that I've worked with personally that are using NgRx and really, really like it. Having seen both sides of the equation, the only thing I would question if I'm in your shoes and I'm deciding on these is does everyone on the team understand the pattern? Do they all understand how to work with actions, reducers, effects, and selectors? And is everybody okay with all the boilerplate code that would added? Now if the answer to that is yes, and everybody understands what's going on with it, then I think it's a great solution. If you have several team members that are just copying and pasting, and this is what I hear a lot is I don't know what's going on, I just copy and paste what other people did and tweak it, then I'd question if that's the right way to go. I think you need everyone on board because at some point somebody has to maintain these apps. And so I'd keep all that in mind. Now there's other alternatives out there as well. I mentioned a few of those. But I hope that at least gets you thinking about some of the different state management options that are available. At the very beginning of the course I mentioned that I always go by the rule, keep it simple. State management is very subjective, so pick what works best for you and your team as you make the choice.

Summary
Throughout this module, we've talked about different state management options that exist. We started out by talking about how services do offer a solution, but there's some challenges there that could come up as updates are happening in different parts of the app. So from there we talked about some official state management options and patterns, and one of those was NgRx. And because this provides a very established pattern based on Redux, it could be a very good way to go. It'll provide that consistency across the team. Now in full disclosure you saw that NgRx definitely adds a lot of boilerplate code though, so you've got to keep that in mind as you're making your decision. Now the other one we talked about was ngrx-data, which is NgRx under the covers. It's an extension to it, and it basically wraps all the complexity that you would normally have to deal with, so your actions and reducers and effects and your selectors, it takes care of that for you, plus it added the bonus of it'll actually call the server for you as well using a convention-based approach based on the name of your entities. Now from there we talked about Observable Store, and this provides a very simple option, but addresses many of the key goals that state management options out there have. So my recommendation is before you decide on any of these or any of the others that are out there, take some time to go through some samples, build a prototype, because before you dive in, why not spend a little time upfront? You've heard that saying measure twice, cut once. And I think that's extremely important when it comes to state management options out there.

Additional Considerations
Introduction
At the start of this course I mentioned how there's a lot of different topics that could be factored in as you're architecting any application out there, especially Angular applications. And while it's not possible to cover every aspect, there are a few additional considerations I want to bring up because they're a little more miscellaneous, and we're going to discuss these because some relate to performance or how we should have a team build our code, some relate to security and other topics I'm going to discuss along the way. So let's see what we'll cover. So I'm going to start off by talking about functions and how if we call those from templates, that can actually lead to not only performance problems, but the function getting called an awful lot, a lot more than you might actually think. And I'm going to demonstrate how in many cases we can convert functions to pipes. Now while on that topic I'm also going to discuss something called a memo decorator, which can be used for caching and further enhance how your pipes work. And I'll show an example of what this memo decorator is and how it can actually be applied to the transform function of a pipe and the benefits it can offer. From there we're going to talk about making calls to a server with HttpClient. Oftentimes in applications that are enterprise scale, it's not enough just to make a single call and we have all the data. Many times we have to call multiple APIs and sometimes we want to do that in parallel. Other times we want to wait for a given request to come back and then switch over to another request and then merge the data. So we're going to talk about how we can do those types of things with RxJS operators. Some of these you may have encountered before, but if not, these are operators I think you should definitely know about. From there we're going to talk about probably the biggest topic of all, which can certainly not be covered really even in one course, and that is security. So the goal of this section is going to be to discuss a few items that I definitely think you should plan for and build in to the overall architecture of your application. We'll talk about some different techniques that you can use and some things that are built into Angular that can help with that. And one of those that we'll wrap up with will be HTTP interceptors. So for example, if you need to pass tokens you might need to use an HTTP interceptor to keep your code very clean. So we'll talk about that and other security concerns that you might want to factor in as you're building not only your Angular wrap, but also the server piece if you're building RESTful or other types of APIs. So let's start off by talking about functions versus pipes and the differences between these two when it comes to performance.

Functions vs. Pipes
Angular makes it really easy to call a function from a template when you need to perform a calculation or some other type of activity. The problem there is oftentimes that function may be called way more than you thought it was. In fact, if you just add some simple console log statements into the function, you'll probably be amazed by how many times it's called. I know I was the first time I saw this. So we're going to talk about functions versus pipes and how in many scenarios we can actually get much better performance by using pipes. Now this obviously could influence the overall architecture and definitely would influence a team and the way in which they write their code as they're working with templates and the component functions. So function calls that are made from a template are actually invoked every time a change occurs. There's no caching at all that goes on. It's a fresh call. So as an example, if we were to have this type of scenario with a grid, we might calculate the total column dynamically if that wasn't actually given to us. So looking over to the right of the grid you can see an addTax function, and I'm passing in a product.price, and then we're going to pipe that out to a currency. Now the addTax call itself is very simple, and you've probably done this before, but if we go analyze it a little bit more, it's going to be called a lot more than you thought, especially if you have other filters, text boxes, drop-downs, and things like that, that are causing properties to change in your component. Now what we can do is actually replace many of these function calls from a template with pipes. And we can create what's called a pure pipe. This is where the same inputs passed in would always yield the same result. And we call that a pure pipe or you might have heard of pure functions. Now the difference here is that pipes and the transform function are only called when the inputs change. Other properties that might be in the component may be changing, but that's not going to change the inputs to the pipe, so it wouldn't be called with any other changes that occur within a component. Now this is actually a big deal because, as I mention with functions, you'll see they're called way more often than you might actually think. So this is what we're going to talk about. Instead of calling a function to calculate the total that you see here, what if we were just to pass the product price into a custom pipe. In this case I called that pipe addtax and then we can pipe the result of that out to a currency pipe if we wanted to. Now addtax is just a function, but because the main functionality is in the transform function of a pipe, other things that are changing in the component aren't going to cause that transform function to be called over and over and over every time a user types in a text box or selects from a drop-down or whatever it may be. So this is really what we're going to be after here is converting from function calls in our grid to a custom pipe.

Functions and Pipes in Action
Here's an example of calling the addTax function and passing in the product.price. That way as we iterate through our products we can dynamically calculate that in scenarios where it wasn't provided to us in the data. Now we take the output of that and then we pipe it to a standard currency pipe. So pretty basic there. Now doing this is very common. I see this all the time as I go into companies and work with different teams on their projects. But there's a little bit of a gotcha to this. Let's jump over to the component and look at the function itself. So you can see it's a very simple function. I take in the price, I have a tax rate, and then I do the multiplication and addition to get the final number. Note that I have this console.log call, addTax function called that's going to be written out, and then as we run this it's really just looping through some rows, writing them out, dynamically calculating the price, but I have some other properties in the component as well that are going to be changing, so let's see the impact of that. So I'm going to run off to the browser, and let's look at this application. So I have this pipes versus function. And you'll notice that I have a grid, calling a function from a template. Here's where we're actually calling addtax as the grid is loading and iterating through these products. And I'm going to go ahead and go off into the Inspect mode here and let's look at our console and see how many times that tax is being called. And you'll notice addTax 10 times. Okay, we would expect that. We have 10 rows. But notice that, due to some other things we're going to be discussing, and really some other things in this page, note that I also have addTax was called yet again down below here. Now what's even worse is let me clear the console, and I have a way to add in a product to this particular grid. And so we can type in a name. Now watch as I just type a single character here. And let's say we had a foo product, and there, it just got called 20 more times, and every single time I type including the price, we'll say 9.99, you'll notice this is just getting called over and over and over. Now, why? Well, because the date is changing, there's no way for Angular to know in this function what exactly it needs to worry about that is changing. And so it has to just recall it every time to make sure it has the latest data. And you can see that's kind of a big deal here, and it really can lead to a lot of bad performance in some scenarios or just really to some unnecessary calls. And it's one of those things that when you don't know about it, you don't really think about it. And that's why we're covering it here, because while the architecture may now include some other pipes you might think through, I think maybe even more important than that is a team understanding the impact of how calling functions from a view can impact the overall page itself. So going back into the component, that would be our addTax. Now what can we do to make this a little better. Well before I show you the code, let's go back and I'm going to clear the console. Actually refresh, we'll let the console load. And notice I have an addTax pipe and an addTax memo, and we're going to talk about these kind of in sequence. So that addTax pipe, that's this one. Now same exact calculations. If I scroll up a little bit you can do a quick comparison there. But it's pretty much identical. Now notice it was also called 10 times, but only 10 times. Whereas the addTax function, at a minimum, was called 20 times. Now that's because the nature of how pipes work. If the inputs to the pipe transform function don't change, then it doesn't need to be recalled. So that means if other properties in the component are changing around this, no big deal. Now watch this, let's clear it, and watch as a I type again a product, and you're going to see the only thing that's influenced by this is the function call, but not the pipe call. So let me just type something there. Now notice it's all that addTax, whereas if I refresh here, the log was addTax pipe. So the pipe isn't being affected at all, but yet if I type in some numbers and things you can see addTax is just called a tremendous amount of times. So let's go on back now and let's take a look at how that's working. So if I go back into the HTML, scroll down, the only thing I've changed here is we have the product.price being written out, but I'm piping it to an addtax pipe, and then taking that out, putting in doing the currency pipe. Now the addTax pipe is very, very simple. It's a normal pipe, and in that pipe I check if we have that price passed in. If we do, I call an internal function called getTotalPrice, and it actually does the calculation right there, you can see. In this example, you would think that the getTotalPrice and the transform in general would be called the same number of times as the actual function that we had back here, addTax. But you can see by the log that I write out right here, that's not actually the case. It was only called the number of times that the inputs changed. So in this case, if we come on back down, we did have the inputs changing for each item, so there's 10 of those, and therefore it was called 10 times. Now after that, as we type up here, the inputs to that particular data binding for each row for the total are not changing. Therefore, it doesn't have to do anything. And that's why, if I clear this and type again, you don't see the addtax pipe logging anymore. Because the inputs to these bindings didn't actually change.

Using a Memo Decorator
There's another trick we can add to our arsenal as we're converting functions to pipes or really just anytime you use pipes, and that's to add something called a Memo Decorator. Now the Memo Decorator is just an open source package that you can include, and it's going to enhance the caching of your pipe's transform function. So anytime a primitive value or values is passed in, a number, a string, a Boolean, something like that, it'll monitor that value and then see what the output was from the transform function. That output value's going to actually be cached. That way if you pass in 9.99 it's going to first say, okay, I've got to do the calculation. I haven't seen that yet. But the next time 9.99 might be passed in, then what it'll do is return the cached value from the previous run of the transform function. So as you can see here, it's very simple to include this. You are going to first install the Memo Decorator package from npm using a normal npm install. Then you can import it, and then you apply it right above the transform function as you can see here. As mentioned, this will automatically cache the result based on the inputs passed into this pipe transform function. So now we could change our code to something like this and we could pass product.price into the addtaxmemo pipe, which has that Memo Decorator above the transform function, and then we can leverage caching if we have a lot of similar data values. So let's jump in and take a look at this. You'll notice that I have a third option here, addtaxmemo pipe, and it was only called seven times. Well if you look at the data, you'll notice we have some duplication in the input. So, the final here, 269.99, you'll notice that's twice and that's because the data that's being passed in was actually the same price. Now likewise, 32.39 on the final, several of those. So really that has to be calculated definitely once. This is once, but these three can now be ignored. Now these are all unique down here, so it would have to calculate those. So what a Memo Decorator is doing is this is a caching decorator. So if I go to my addtaxmemo pipe, what I've done is I've imported into the project through an npm install, a package called Memo Decorator, and you'll see this memo. Now memo is being used to cache these simple or primitive inputs that are being passed into transform. If I had actual objects being passed in, this actually wouldn't work so well. But because I have primitives, and that could be numbers, strings, Booleans, things like that, what this will do is for every unique value passed in, it will actually check that and then the value being passed out gets cached. So that way if, down the road, I had 9.99, well first time it hasn't seen that, so it's going to have to calculate and it calls the function. Next time 9.99 is passed in, the Memo Decorator's going to say oh, I've already seen this and I already know the result, and it just echoes back the result, no need to call the function anymore. Obviously if you had a tremendous amount of data, you probably want to be careful with this, because that is caching in memory. But in scenarios like you're seeing here, it's actually very efficient to add. Now it's certainly optional, it's kind of one of those bonus things you can do, but by knowing about it, you can really speed up especially more complex calculations that you might need to perform. It's definitely an option that you might want to explore. Now going back to the browser one more time, let's come on in and let me type just a test product and 9.99. And again, you can see the function getting called a ton. Let's add a product here. Now let me clear the console and we'll add it. Now notice that the addTax function was now called 22 times. Addtaxmemo was called, and so was addtax pipe. Well, the reason for that? We just added a new value which equated to 10.79 after tax. That 9.99 had not been seen previously. You'll notice we don't have a 10.79 in our grid here at all. So the addtaxpipe had to be called because the input changed, and the addtaxmemo pipe had to be called, and then the Memo Decorator said, oh I haven't seen that value, so let me let the transform function run as normal, and then I will cache the output. Now let's go ahead and add in another one. We'll call this test2. We'll clear it and let's see what gets called now. Now notice as usual the function was called, the addTax pipe was called, that's correct, but notice the memo was not. And that's because it had already seen the input for 9.99, and so it just returned the cached output here. So while this is a very subtle thing you can do in your applications, it's definitely something you might think about in these scenarios where you have some dynamic calculations you need to do as you're iterating in an ngFor, as an example. Now obviously I'd prefer to do all the totaling in a service or even on a back-end server if I can, but that's just not always possible. Sometimes the data we get doesn't have exactly what we need and we need to do the total our self, whatever that calculation may be. So hopefully that gives you an idea of functions versus pipes in action and kind of some of the benefits you can get out of pipes and even an additional benefit you can get from adding a Memo Decorator.

HttpClient and RxJS Operators
As you're planning out the architecture for your Angular application, you may notice that multiple calls are made out to APIs. Now you may control these APIs yourself or they may be third-party APIs, but regardless, you might run into various scenarios where you want to make multiple calls simultaneously, or maybe when data comes back you have to use some data within that data such as an ID or a link to go fill in some additional details about that data. For example, you might have a person, when it comes back it has an ID, but it doesn't have an address. But maybe there's an address service you can pass the ID to to get that back. So RxJS has a few operators that I want to cover here because I think it's important to know about these. If you do, feel free to skip forward. But if not, we're going to quickly run through where these can be used and actually give a scenario with HttpClient. So the first is called a switchMap. This allows us to complete an inner observable and switch to another one. And I'll talk about that in a moment. MergeMap, this allows us to actually return some data and merge it back into the stream that goes back, in this case to the component for the demos I'll be running. And then forkJoin, if you've ever done a promise.all before or just have multiple calls that go out with HTTP, and then when they all are done you want to get that data simultaneously, then forkJoin can work well for that. So going back into the Angular-Architecture project, I've opened it up and I'm at the HttpClient and Operators demo. You'll notice I'm going out to a service to get some information on characters, planets, people and their home worlds, and some more information down here. Now if we needed to display characters and planets, we could go out and make two separate calls and actually wait for one to come back and then start the next. Or, if we want that data at the same time, we could use something like a forkJoin. Now we also have some characters or people here, and notice that their home world is being displayed. Well let me show you the data that comes back from these different calls. Let's go to the Network tab and I'll refresh this. And let's go to people. We'll come on down to just one of these. And if I scroll on down you'll notice homeworld is actually another URL here. So the homeworld itself doesn't have any data. Once that person loads, I need to go get additional data. That means, of course, another call to the server. So there's some techniques we can do with these types of scenarios that RxJS operators can be used for, and it really helps out in many cases. So running off to the code, I have a service. Let me go into my core services, and you'll see this httpClientRxJS.service. Now it does some pretty normal things. For example, getCharacters just returns an observable using standard HttpClient, as you can see right up here. And then I'm just tapping out a log message, mapping to the property that actually has the data I want for the characters, and then say when I'm done with this operation. Likewise, planets does the same thing. Http calls out, we get one observable, and we pipe that in. Moving on down, though, I have some other examples here. What if we wanted to call characters and planets, but know when both of them have come back and completed. Well that's where the forkJoin operator can be used. And if I scroll back to the top, you'll notice I'm importing forkJoin from rxjs itself. And if we come back on down to this, you'll notice I'm calling the getCharacters that return the observable above and the getPlanets that return the observable. Now what I'm doing with that is mapping the response, which is going to include both of these, the last value from both, into this map function. And you'll notice I'm returning a custom object. I grab the characters by getting to my response 0. That of course is the first one in the forkJoin. And then I get my planets with response 1, which of course is the second one in the forkJoin. So if you've worked again with promise.all, this is very similar, especially in the world of HTTP where you just get back one value per call, and this provides a nice way where I could call many things and then know when all of them are done at once and return that object. So now you can subscribe to this and just get this nice object here that would have the actual data. Now moving on down, let's look at an example of a switchMap. And I have two examples of this, but we're going to jump to this getCharacterAndHomeworld. Now in this example, I want to call out to the service and grab a specific individual here, a specific character. And then what I want to do, though, is not only return that character, but also go get their homeworld, which is a separate column. Now you'll see that right here. We're going to grab that homeworld and then we're going to update the character's homeworld. Now by doing that with this one call, it not only gets the character, but then makes a separate call to go get the homeworld data and then we can work with that. Now what's being done to make this possible is this alone returns an observable which gets piped. But I don't want to return the actual character or person, I want to return the tweaked or changed character or person. So what I'm going to do is switch to another observable. This is our first observable. And then the switchMap will switch to this observable here, and this is what we're going to return in that observable. So we're going to grab the homeworld from that character, map it into the homeworld property, then return the character. Well the end result of this, if we go back to the browser, is if I scroll on down and do Show Character and Homeworld, this will now call out and you'll notice that homeworld here now has all the homeworld data that we'd want. But that would be an example of using the RxJS switchMap to say, all right, I know I have an observable here, but I want to go ahead and finish that, or complete it, and then switch the map, switch to the observable that's right here. And then of course whatever's returned from the map, that's actually what the subscriber would get. Now if we jump over to the component here, you'll see where I call these. So here's getCharactersAndPlanets, and notice that I get the data, which has those two properties I mentioned, the characters and the planets property, and then I map it into this charactersAndPlanets. Now here is the get characterWithHomeworld. This one I treated as an observable. So if we come on back up, I said it's an observable of an object type, and we call the getCharacterAndHomeworld. So with the one call, it will have to make two separate calls, but that'll be done in a way that we just simply get that data back and we have not only the character, but also the homeworld. Now the final one is what if we want to get all the characters and also their home worlds? Because that gets a little bit trickier. So to go back to the browser here. If we inspect, let's go to Network and let's refresh again. So here's all the different people. But again, if we drill in their homeworld is just a URL, so what I'd like to do is iterate through all of these, and then grab their homeworld so that once that's passed back we can get all that data. Now yes, that does mean we're going to make some extra calls, we're going to get back the array. Then we're going to have to iterate through all 10 of these and go call the homeworlds, which is, of course, 10 calls to the server. Now you'll see those 10 calls being made here, and some of these you'll see are the same homeworld. You'll see one is used in multiple cases. We can use some caching there, potentially. But I'm going to show you how we could kind of do all this in one shot. So if we go back to the service, and if I scroll up just a little bit, you'll notice I have getCharactersAndHomeworlds. So the first thing we have to do is go get all the characters. That gets us back the array of 10 people that you just saw. I'm going to pipe that in, though, and then I'm going to switch from the people observable to a custom observable. So from is going to convert that array to an observable and pass each of those into this mergeMap. Now what I'm going to do is whatever is returned out of the map here, that's ultimately what I want to merge into the observable going back to the subscriber. So you can see we really have three types of observables here. This is our first, this is our second, and then our third is what ultimately we want to merge back in to the subscriber again. So walking through this, we'll first get the array, we'll convert that just normal JavaScript array into an observable using the from. That will then pass each one into this mergeMap. So in essence, it's like us writing a loop that would loop through each item in the array, but it's doing it with RxJS observables, of course. Now I'm going to go ahead, and from that person, get their homeworld URL. We'll pipe that result of the homeworld into the map function, and then we're going to take that homeworld and update the properties. So we're really replacing the URL that you saw earlier with the actual homeworld data. And then we return it. Now I could do this and leave it right there, and what would happen is every time one of these comes back, that observable will be pushed to the subscriber. In this case I wanted to get everything back as kind of one big batch though. And so I called toArray. So by doing this, we can get data for nested properties, in this case homeworld. And while there's other ways to do this, this provides one way that RxJS could be used for this type of scenario. So I wanted to go through these operators quickly here because it is an additional consideration as you're architecting the app. If you find that your API requires multiple calls, how can you make those multiple calls in an efficient way? Well, by using switchMap we can actually take an observable and return switch to another observable. MergeMap allows us to merge custom data into an observable. And then forkJoin allows us to make as many calls as we want and be notified when the last value from each of those calls is returned. Which in the case, again, of HTTP, you only get one value anyway. By using these operators and others in the appropriate way, we can then build out our services as efficiently as possible and make sure that we're doing parallel calls to APIs as needed versus serial calls as needed.

Key Security Considerations
Security is a key factor to take into consideration as you're architecting your Angular applications. Now we could have many classes on security because on the back end there's a lot of different technologies out there, and a lot of different techniques that could be used. What I'm going to do here, though, is provide a short synopsis of several key security considerations that I think you should take into account, especially on the front end. Now talking about the back-end technologies is simply outside of the scope of this course, so I don't want to minimize that at all, because that's where your true security obviously happens. So we're going to talk about four main things. First off cross-origin resource sharing, cross-site request forgery attacks, route guards, and then sensitive data in an application. Now let's start with CORS. Cross-origin resource sharing is very, very common in many applications because our app domain that serves up our Angular app may actually call other domains or even the same domain, but different ports. Of course, anytime we do that that's a cross-domain call and the browser shuts it off. So if we were calling acmecorp.com and that served up our app, then of course we can just call back to it, but if we want to call some other API, we're going to have to enable CORS on the server, otherwise that call is going to be blocked. Now how you turn on cross-origin resource sharing really depends on the technology that you're using on your server. Regardless of what you do, there are some things to think about there to really lock down the app as much as possible. So as mentioned, CORS allows a browser to call a different domain or port, and in order for CORS to work, we have to enable it on the server as it's needed. So this is not something we can do in our Angular app. Whatever server technology you're using, we're going to have to go there to do it. Now the important consideration I'd like to mention here is to limit the allowed domains, the allowed headers, and the allowed HTTP methods that can call into your API. Now this again would involve on your server side limiting what domains are actually allowed to call in or headers or methods. Now if it's a public API, you're going to probably allow star for your domains, anything. But you may limit your headers to just the key ones that are needed. And of course you may limit your HTTP methods to something like GET, PUT, POST, and DELETE as appropriate. So the big consideration here is that while CORS is kind of a necessary part of our lives these days, when you have APIs and other domains, make sure you limit that as much as possible. Now the next security consideration is cross-site request forgery, or CSRF, or you might even hear XSRF. This is the process of someone sending you, for example, an email and they try to trick you into going off to their site. Now the hope here is that you've already logged into a site such as yourbank.com and then a cookie was set. Now you get the email and click it, and this is a phishing type email. That directs you off to a bad site, which looks exactly like the bank site of course. The bad site then is going to send through your browser a request to the API of the good side, the bank. And because you would have already logged in to the site and maybe have an encrypted cookie set, we hope it's encrypted anyway, then your browser will basically send a malicious request and the bad site could then get your data. So the big thing here is if you are using any type of cookie authentication, and there are plenty of frameworks out there that use this, then you want to enable CSRF on the server so that if you are using this cookie authentication we can do some validation. Now the way it works is the server will send down a cookie with a special token in it. Angular will then read that and set it as a request header. Now only the same domain can set this request header. So now the bad site can't set the request header. And now when the request is made up to the server, if that request header wasn't there, it would be blocked and that request would not go through. Now in Angular, if you need to change the cookie that you look for, that the server sends, to get this token out of it, or if you need to change the header that's sent, you can actually do that. Now the docs on HttpClient have some details on this if you're interested. But definitely something I have had to tweak on occasion depending on the server setup that I have. And then as mentioned, the server's going to validate that header value, and that's how we can circumvent or stop this type of CSRF attack. Definitely something you'll want to take into account for your APIs on the server, it might involve a little Angular code potentially. As I mentioned, if you need to tweak it some, it'd be a very simple tweak, though, if you have to do that. Now the next security consideration is route guards. Now we know that route guards are a great way to direct a user to a login screen or some other page if they don't have the proper security credentials as dictated by the server. Or maybe they're not in the proper role or group. So we can use route guards for that exact purpose. Now the big thing here, though, especially if you come from a server-side background, is to keep in mind that there's no such thing as security in the browser. The server, of course, is the ultimate source of security for your data, your APIs, all of that type of stuff. So keep in mind that while route guards are very helpful for helping direct a user through your different views and routes on the client side, we're of course still going to have to add the proper security to the server side. Now the final one is I hope pretty obvious to everyone, but I'm going to mention it because I see it happen from time to time, and that is sensitive data. And this is something that there are some other things you might want to think about here when it comes to sensitive data. Anyone can access the browser developer tools, so they can get to your session storage, your local storage, your cookies, and variables, and all that type of stuff. So it goes without saying to not store sensitive data. Secrets that would be used to call an API? Any keys that are important and kind of secret keys, passwords obviously. Because we can get to all of that through the developer tools. Now where I see a problem come up sometimes is when you're calling a third-party API and you're calling that directly from Angular, but you need to pass a key and a secret in order to call it, well, some people will pass that secret down to Angular, store it, and then Angular will have that locally as it calls your API. And of course anybody that wants to get that secret could, and now they could call the API as well. So something to consider here is if an API requires a secret to be passed, you might actually consider setting up an API of your own, I call it a middleman service, that Angular would call, it's server side, and it would know how to load the secret. But by doing this you're never passing that secret down to Angular. So what then would happen is Angular will call your API, that API then forwards the request, includes the key in the secret to the third-party API. And that way we're not having to pass any secrets down to Angular. Now the final one relates to authentication and some authorization concepts. There are a lot of applications out there that use cookies, but if you have an API that supports JWTs, or J-W-T, JSON web tokens, that's a good thing. Because now we don't have to have a cookie container, first off. But also because the tokens can be set to expire and then we might have to get a refresh token. And then that way they can't be hijacked as easily as Angular is calling into these different APIs. So if you have that opportunity to set that up, that's not a bad thing. While there are certainly other concepts we could dive into for security since it's a huge topic, those are some of the key ones I'd mention just right up front that you should think about as you're evaluating your security. Some additional considerations that you definitely want to take into account as well would be your authentication on the server and how that's going to interact with Angular, any authorization such as roles or groups, and then of course are you going to use HTTPS? Now you definitely would want that between Angular and an API, but then you have the decision, what if that API calls other APIs? Do we have end-to-end HTTPS? Or is it just point-to-point? So these are different things that you would want to think through. Every company handles these things in different ways because many different technologies can be used. But I hope that gets you thinking.

HTTP Interceptors
One of the features of Angular that goes hand in hand with security and with others tasks is HTTP interceptors. So in this section we're going to take a quick look at interceptors and the role it can play with some of the other topics I talked about earlier. And we'll also discuss some other ways they can be used. So first off, an interceptor can implement an interface that you'll see here called HttpInterceptor. It's a service, you'll see the injectable on top, and by implementing that interface you'll add an intercept function. Now the intercept function can access the request. We could clone it and then we can change things. So in this case we're going to enable withCredentials for a CORS requests. That way if cookies are being used for authentication and we need to pass some of the information in the cookie, we can do that by setting withCredentials true. I'm also setting a header on the request called X-Requested-With, so that if I want to know on the server what type of request is being made, I can very easily identify that. Now once we clone that request we can then pass it into the next and that would cause the next interceptor in a line if we had multiple to be called. Now this can be very useful for some cross-domain requests where CORS is being used and you have some authentication information secured in a cookie, typically it'll be encrypted, and then you want to pass that along, or you just want to set some request headers. Now here's another example of using it in the case of J-W-Ts, JWTs, or JSON web tokens. If we had a service that's retrieved a token that could be used to authenticate into an API, then we could retrieve that here. Now in this example I'm kind of hard coding a token just so you can see an example of that, but you'll notice in the comment off to the right, we could obviously inject authService, or whatever your service is called, into this, and then call some type of a function such as getAuthToken. Once we have the authToken, we can pass that into the authorization header as you see here, and we do that again by cloning the request and then using the headers property to set that header. Now if you have a server-side API that looks for these JWT tokens, we can get to those. Now what this'll do is in the browser, it'll actually go in and set this, as you see here, and that would be a request header that now goes up and then it would be up to the server to validate that. Now to register your HTTP interceptors, you can go into a module such as Core module, which is where I always put mine because that's our singleton type of area, and we can provide for our HTTP interceptors. So you'll need to import HTTP_INTERCEPTORS from angular/common/http, as you can see here. You then put your class and then you put multi: true because you could have multiple interceptors. Now the order the interceptors are registered here is the order in which they're called, and that's where the next comes into play in the previous two examples that I showed. Now here's an example of setting the authorization header as HTTP requests are made. So you'll notice over here to the right, I have my tokens set, and this is the request header as you'll see up above, and now that would go up to the server and it would be up to that API to validate it again. This is what the auth.interceptor looks like. You'll see it's identical to what you saw earlier. You'll see that we're going to clone the request, set that Authorization header, and then of course we would normally dynamically retrieve this from some other service. Got to register it. We go into our core.module and you can see my registration right here as you saw earlier. The end result is now every request could send that authorization header automatically. And now you don't have to manually set the request header in each HTTP call. There are certainly a lot of other ways you could use interceptors. For example, I use them to show and hide a spinner as a request is being made to show some progress. And really, any other time you want to know about the request or get to the response, you could use an interceptor.

Summary
We covered a lot of ground in this module, and some additional considerations to factor in as you're architecting and ultimately building your Angular application. So we started off by talking about how although views can call functions, you need to be a little bit careful there. In many cases, pipes may be a better alternative. We also looked at some bonus features of this such as the Memo Decorator and how it can cache some of your data when primitive types are being passed in to the pipe transform function. From there we looked at different RxJS operators that can be used such as switchMap, mergeMap, forkJoin, and a few others, so that we can make the most efficient type of call to the server and then get that data back as quickly as possible. This is one of those areas where with a little practice you can really gain a lot of ground in your knowledge of RxJS and all of the powerful operators that it provides. We also looked at HTTP interceptors and looked at a few cases where they can be used. The cases I showed were more related to security, but you could use interceptors for many different scenarios. Almost every app probably has some type of a progress indicator. Earlier I mentioned that I use interceptors to show a little spinner as request starts, and then hide it when the response comes back. So there's many scenarios where you need to modify the request, such as the headers, or just know when a request is going out, or when you need to get access immediately to the response to grab something from it. Finally, we talked about security in a few sections in this module, and I can't overemphasize the importance of security, and I also can't overemphasize how JavaScript front-end type apps don't provide true security. That's pretty obvious if you've done this before, but if you're coming from more of server side or desktop or console type background, it's a very different world because the HTML, the JavaScript, and the memory is just directly accessible to us. So we can pretty much get to anything. And that, of course, leads to discussions during the architecture process of what is the server going to do? What technologies are we going to use? Are we using Windows Authentication? Are we going to be using just cookie authentication, JSON web tokens, whatever it may be, but that really needs to be discussed up front so that you know how to plan for your Angular services, making calls into your APIs on the back end. It goes without saying that security is a very, very important part of any application, whether it's a huge enterprise app or just a small admin app. Plan for it and make sure that you've thought through that overall process. So I hope that gives you some more food for thought and some additional considerations as you're evaluating and planning your Angular application architecture.

Course Summary
Course Summary
Thank you for watching the Angular Architecture and Best Practices course. I hope you enjoyed the course and that you got a lot of value out of it. Let's review some of the key concepts covered throughout the course to wrap things up. We started off by talking about the importance of planning your application architecture. This included discussing key topics to consider when doing initial planning, examining a simple planning template that can be used as the starting point for planning your architecture, and taking a look at the Angular Style Guide and the information it provides. From there we learned how to organize features in modules in an application, and this is one of those important areas to spend time planning, in my opinion anyway. By organizing features into modules, using core and shared modules, and even building custom libraries as appropriate, you can create an application that's flexible to change, easier to maintain, and more efficient, especially if you use lazy loading in your routing. The next topic covered in the course was structuring components. You learned about the container presentation pattern and how it can lead to less duplication of code and logic across components. Input and output properties, change detection strategies, as well as gotchas that you can run into with value versus reference types was also discussed. Finally, the importance of cloning and how it can be used to ensure you know when objects are changing in components was discussed as well. While input and output properties work well in container presentation, or general parent/child component scenarios, you may have a need to communicate between components located at different levels of your application. To handle this scenario, you learned about different component communication techniques that can be used, including event bus services and observable services. A discussion of RxJS subjects was provided, and you learned about the different types of subjects available and how they can be used for communication. Next, we discussed the need for state management and the different options that exist. Several of the key options available were discussed such as NgRx, and we see how these options can be used to work with state in applications. The module concluded by comparing the different options that were discussed and talking about when they're appropriate and maybe when they're not appropriate. State management can be very, very subjective. One of those things where you ask 10 developers about it and you may get 10 different responses, but understanding the options available can be critical when you're planning your application architecture. Finally, additional architecture considerations were discussed. This included covering pipes versus functions and a demonstration of the impact that function calls made from templates can have in an application and how they can be replaced with pipes was shown. Different RxJS operators were also discussed such as tap, map, forkJoin, mergeMap, and concatMap. And knowing how the different operators work can really help as an application makes multiple calls to services. Well that's a wrap on this course, and I really want to thank you for taking the time to watch it, I hope you learned a lot, and I certainly wish you the best in planning your application architecture and building your applications. I hope you'll check out my other courses on Pluralsight.

Course author
Author: Dan Wahlin	
Dan Wahlin
Dan Wahlin founded Wahlin Consulting, which provides consulting and training services on JavaScript, Angular, Node.js, C#, ASP.NET MVC, Web API, and Docker. He is a Google GDE, Microsoft MVP and...

Course info
Level
Intermediate
Rating
4.9 stars with 118 raters(118)
My rating
null stars

Duration
5h 21m
Released
15 Jan 2019
Share course
