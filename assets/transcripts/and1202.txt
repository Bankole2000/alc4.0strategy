Android Navigation Architecture Components: Getting Started
by Miguel Beltran

This course introduces the Navigation Architecture Component, a new component from the Jetpack library family, that facilitates navigation within the different screens of an Android application.

Navigation is a complex task that is usually overlooked by developers. In this course, Android Navigation Architecture Components: Getting Started, you will learn foundational knowledge and gain the ability to implement navigation within the different screens of an Android application. First, you will learn how to use the new navigation graph. Next, you will discover different ways to perform navigation screen to screen in your apps. Finally, you will explore how to perform deep linking, navigating into your app from the outside. When you're finished with this course, you will have the skills and knowledge of Android navigation needed to implement complex Android applications.

Course author
Author: Miguel Beltran	
Miguel Beltran
Miguel is a Freelance Android developer based in Berlin. He is passionate about mobile app development and machine learning, but most importantly, he is passionate about teaching and learning....

Course info
Level
Beginner
Rating
0 stars with 1 raters
My rating
null stars

Duration
1h 19m
Released
12 Feb 2019
Share course

Course Overview
Course Overview
Hi everyone. My name is Miquel Beltran, and welcome to my course, Android Navigation Architecture Components: Getting Started. I am a freelance Android developer. I've been building Android apps for seven years, and teaching is one of my passions. Navigation is a complex task that is usually overlooked by developers. In this course, we're going to learn how to implement navigation within the different screens of an Android app. Some of the major topics that we will cover include the new navigation graph editor, navigation screen to screen, advanced navigation patterns, and deep linking from notifications and web links. By the end of this course, you will know how to implement navigation in an effective way using the navigation architecture component. Before beginning this course, you should be familiar with Android development, have a basic knowledge of Kotlin, and have a working environment for making Android apps. I hope you will join me on this journey to learn navigation on Android with the Android Navigation Architecture Components: Getting Started course at Pluralsight.

Introduction to the Navigation Component
What You Need
Hello everyone. May name is Miquel Beltran, and I'm a freelance Android developer. Welcome to the module, Introduction to the Navigation Component, from the course, Android Navigation Architecture Components: Getting Started. In this module, you will be introduced to the concept of the Android architecture components, their purpose and functionality from each one of them including the Navigation component. I will discuss some of the options that Android developers had to implement navigation before the Navigation component came out. And, finally, we will take a look at the high-level features from the Navigation component and some of the general concepts that are necessary to understand this course. To be able to do this course, you will need some experience in Android development since this course will not cover the basics. However, you don't need either to be an expert or even have professional experience to complete this course. I will say that if you have done some online courses covering the basics on Android development in the past, you will be good. This course uses Kotlin rather than Java for all code examples, so having some familiarity with Kotlin is also advised. In this course, we won't be using any other third-party libraries besides what the Android framework and the first-party libraries that Google provides. So you don't need to have previous experience on libraries like Retrofit, RxJava, or Dagger. Regarding hardware and software, I recommend you use a suitable machine with at least 8 GB of RAM. You can use either Linux, Windows, or Mac OS. And, of course, you need to have the latest version of Android Studio installed.

The Android Architecture Components Family
In 2017, Google introduced a series of libraries called the Android architecture components. I'm going to give a brief introduction to them in this video. If you're already familiar with them, it is okay to just skip to the next video since knowing about the other architecture components is not a requirement to complete this course. These libraries are part of a larger collection called the Android Jetpack, a collection of software components that can help you build better Android apps. Other collections include the foundation components, the behavior components, and the UI components. The architecture components as the name suggests focus on the architecture of the app to help you design robust, testable, and maintainable apps. This includes the use cases like managing the lifecycle of your UI or handling data persistence. In our case, it also includes navigation. You as an Android developer can build successful applications without even using the named architecture components like many have done before of course. However, these new components provide a tested solution with first-party support from Google. Originally Google presented the following four architecture components: Lifecycle, LiveData, ViewModel, and Room. Let's take a look at them. Lifecycle helps you manage your app lifecycle with ease. This component is available to you even if you don't know it because now the AppCompatActivity class and the Fragment class from the support libraries incorporate the Lifecycle components built in. This component helps you manage the configuration changes, avoid memory leaks, and load data into your UI. LiveData provides a lifecycle-aware data observable. It allows you to modify changes to your views, for example, when the contents of the database change or when a background task finishes. Since it is lifecycle aware, you don't need to manage its subscriptions manually. ViewModel is also highly related to LiveData and Lifecycle. It stores all the UI-related logic and data. And it's capable of surviving configuration changes improving the user experience of your applications and helping you accomplish more with less code. Room facilitates the access to your application SQLite database. It provides direct object mapping to your database tables. You can use it to avoid boilerplate code and easily convert SQLite objects to Java objects. The architecture components continued to grow in the last year with new architecture components. Some of them are the Paging library, the WorkManager, DataBinding, and the Navigation component. The goal of the Paging library is to provide you an easy way to load data gradually into RecyclerView. For example, it helps you handle the loading of data when the user scrolls a list. It provides its own UI and data components, and it's highly coupled with the RecyclerView view list. The WorkManager makes it easier to specify and run a synchronous task and, as well, decide when these should run. WorkManager works on top of the existing JobScheduler, the Firebase JobDispatcher, or the old AlarmManager. Also DataBinding was released earlier in 2016. Today it's also part of the architecture components. It provides an object that represents views in the UI and allows you to bind UI components to data automatically simplifying your UI code. And it can be easily integrated into the ViewModel component. And, finally, the Navigation component. Released in 2018, this component simplifies the implementation of navigation in an Android app. It allows you to pass data safely and in an easy way between screens and provides tools to create deep links allowing users to navigate into your app from the outside. In this course, you will learn how to use this component. While I think it is interesting to know about the other components, they are not required to complete this course.

Navigation before the Navigation Component
How did developers do navigation before the Navigation component existed? In this video, I will do a brief introduction to the different options we had before the Navigation component was released. Traditionally, since the first version of Android, each time a developer wanted to send the user to another screen, they would start a new activity. This means that for each screen of our app, we would have an activity. And so to navigate to a new screen, we will call to the old startActivity method. The advantage of doing this is that the navigation back stack was completely managed by the operating system. So to say when the user wanted to go back to the previous screen, you either finish the current activity or let the back press close it. The operating system provides many flags for when you want to replace an existing activity or you want to clear up the whole activity back stack. The advantages of activities are clear. The system takes care of managing the stack for us. The API is very easy, just call to startActivity or to finish. And we even have some flags to control the stack, for example, to clear old existing activities in the app. However, the disadvantages are many. For example, it's hard for a developer to have a clear idea of the current application back stack. In other words, which activities are in the background. But the biggest problem is the huge overhead that causes having a different activity for each screen. One of those problems is how complex the AndroidManifest becomes. When we have thousands of different activities in our app, we need to have an entry for each activity on the AndroidManifest. And, finally, we will need some rich UI navigation patterns like, for example, bottom navigation bar or tabs. Activities always, more or less, take the whole screen. The biggest alternative to activities is fragments. Released with Android 4.0, they have been a hot topic of discussion for many developers. Some say that fragments are great, and we should use them all the time. And some say that you should avoid them. I personally think that we should use the right tool for the job, and fragments can help us in many ways. But what exactly is a fragment? Fragments are portions of the UI that you can combine and exchange inside an activity. You can have multiple fragments in the same screen. For example, in this screen, I have the HomeFragment inside the MainActivity, and then the FeedFragment inside the HomeFragment. This brings us to our second navigation pattern using fragments. Rather than having multiple activities, you can have a single activity for the whole app that will host multiple fragments. You can change one fragment for the next one to navigate to a different screen. Like in my example, the HomeFragment changes to the DetailFragment all within the MainActivity. Indeed, this is what the Navigation component is doing. We use fragments with the Navigation component. However, we don't manage them manually. Before the Navigation component was released, developers had to manage all these transactions by themselves. Using the fragment manager, developers added, removed, hid, and shown fragments on the screen manually. And they were in charge of managing the stack of fragments. This is where the Navigation component is going to help us. This is a simple example of using fragments. You have to use the FragmentManager provided by the activity. Call to beginTransaction, and then within this transaction, for example, you can add a new fragment to the fragment container. Then don't forget to commit the change to execute it. These can become a lot of work and can quickly become a source of bucks for larger apps. Besides, we don't have a natural way to manage the stack of fragments. We have to do all that by hand. For example, removing the previous fragment, hiding it, restoring it to navigation events, all of these have to be done manually. We have these two official alternatives, activities and fragments. With activities, we lack control over the navigation stack, and we miss some important navigation patterns. Another problem is that it does not scale for larger apps since we need to constantly create new activities with all that it implies. However, the API is extremely easy to use. Using the single activity pattern with multiple fragments, we have total control over the navigation stack, and we can implement rich user experience patterns. It is easy to extend and to modularize. However, fragments as they are are quite hard to manage. The API is very complex. That's where the Navigation component can help us. Just to compare how easy the navigation is with a Navigation component, this is the equivalent of the fragment navigation code we saw before, and it's just one single line of code. During this course, you will learn about the details of this and more comments and how to use them properly. Besides the solutions provides by Google, other developers created their own from scratch. And one of them is Conductor. Conductor is a library that provides an alternative to fragments and allows you to create view-based Android applications with a single activity. Conductor uses the concept of the router, the object in charge of this _____, and managing the stack of views, something like a navigator, and controllers who are a lightweight object that host the screen views, something like fragments. Conductor is open source and freely available. I've personally used Conductor for many years and even made a plugin for it adding ViewModel support from architecture components. However, as a third-party library, the level of support that you can get is lower than with other first-party solutions that can come from Google for example. This is something to keep in mind when deciding to incorporate a library to a project. Next, you will learn about how the Navigation component can help you.

How the Navigation Component Can Help You
Let's take a look at how the Navigation component is going to help us implement navigation. The state of the art when developing Android applications is to make what is called a single activity app. This means that we will only have a single MainActivity, and then we will have multiple screens using fragments that will appear and disappear on that MainActivity. This is, of course, something hard to achieve, and this is how the Navigation component can help us. Following the principle of single activity apps doesn't mean that you can only have a single activity. It means that we will only create a new activity when it is strictly necessary. Indeed, the Navigation component supports both having fragments and new activities as possible navigation destinations. So even if I refer to this architecture as single activity app, having more than one activity is still okay when you need to. The goal of the Navigation component is to simplify the implementation of navigation between destinations in your app. A destination is a place of your app that you can navigate to. It can be a screen containing a fragment or a screen in a new activity. And, as well, the Navigation component supports custom destination types like, for example, custom views. Destinations are grouped under a navigation graph. The navigation graph defines the different connections between the destinations called actions. And you can have more than one navigation graph in your app. And even you can have different navigation graphs inside the specific destinations. So you are not forced to have all your app inside a single navigation graph. These actions perform the transition from one destination to another and allow you to define how this transition happens, which animations to perform, and which data needs to be passed from one screen to the other one. Many other things are happening under the hood, and here is where the Navigation component helps most. The navigation stack is managed entirely by the Navigation component library, meaning that when you go from one destination to another, the previous destination remains in the stack allowing the user to navigate back. As well, if your application is destroyed by the system or a configuration change happens, the Navigation component takes care of storing and restoring the navigation state returning the user to the same screen that they were. Last but not least, the Navigation component helps you implement deep linking. Say a user received a notification about a new offer, when the user clicks on that notification, they will be redirected to the corresponding destination within the app. And as well, the expected back stack is also present. The same thing when a user clicks a URL that is supported by your app. The Navigation component can take care of parsing it and providing the right data to your screen. In this module, we took a look at the state of the art in terms of architecture component libraries on Android. We learned about the different ways to implement navigation before the Navigation component was released and had a quick overview on the Navigation component features. In the next modules, you will learn how to implement an app using the Navigation component from the setup to complex use cases like deep linking. Thanks a lot for watching. I hope you enjoyed this module. See you on the next video.

Creating a Navigation Graph
Introduction and Setup
Hello everyone. My name is Miquel Beltran. Welcome to the module, Creating a Navigation Graph, from the course, Android Navigation Architecture Components: Getting Started. In this module, you will learn how to add your first navigation graph from the Android architecture components to a project. And with it, you will create your first navigation interaction between two screens. Before we start coding, we will do the setup to make sure that you have everything you need to start using the Navigation component including the right version of Android Studio and the necessary libraries. We will create an empty project to work with it. Then we will add your first navigation graph to this project. Once we make sure that it works, we will add a couple of screens. And we will implement navigation across them with the first navigation actions. Finally, we will take a deeper look at the navigation graph edit tool and the options we can find there. In order to use the Navigation component from architecture components, we need to make sure that we are using the required versions for Android Studio and the support library. As well, because we will be using Kotlin for the examples, we need to make sure that your project is set up to use Kotlin. For this course, we will use Android Studio 3.2, the Navigation component 1.0 .0 -alpha06, and the support library 27.1 .1. To use the Navigation component tools, we need to use Android Studio 3.2. Version 3.2 was released in September 2018. So if you have a setup that is older than that, please be sure to update it. You can check the version of Android Studio using the about action. And you can check for updates using the Check for Updates action. The next step is to add the Navigation component from the Android architecture components. For this course, we will use version 1.0 .0 -alpha06. If you want to use an older version, please be aware that the API may have changed, and you will have to adapt our demo code to it. To add the libraries, open the app build.gradle file, and add them in the dependencies section. During this course, we will be creating a simple app that showcases the different navigation use cases. Because the topic of this course is navigation, we will create an app to rent boats online. Of course, this app will not contain any business logic, and the data is all mocked up. There are some coding best practices that will be ignored during this course. We will focus only on navigation.

Creating the Navigation Graph
Before creating our first graph, we need to enable the navigation editor feature on Android Studio. Then we will add our first navigation graph to the empty project that we just created. And then we will add the first screen. We will set up the navigation host and, finally, run the project to be sure that this setup works as expected by checking that the screen that we have created is displayed. Before we can start using the navigation editor, we need to enable it on Android Studio. Open Preferences, select Experimental category in the left pane, and check that Enable Navigation Editor is enabled. And then restart Android Studio if you have to change this. It's time to add a new navigation graph. Open the left Project navigation pane on Android Studio and select the res folder of the app module. Right-click over it, and select the option New, Android Resource File. We will give the file a name, nav_graph, and select the resource file to be Navigation. We can check that our navigation graph is now created under the new navigation folder as nav_graph.xml. The navigation editor is also open, and as we can see is empty. Let's add one empty screen here. On the top, you will find a button to add a new destination and select Create blank destination. This will create a new fragment using the standard new fragmenting blade from Android Studio. Let's name this fragment WelcomeFragment as it will be our loading screen. After, we will create a second one, RegistrationFragment, so the user will be able to navigate from the welcome screen to the registration screen. I will select both the Include fragment factory and Include interface callback options because we don't need them now. Source language, leave it as Kotlin. And the target as main. And then click Finish. Once Android Studio finishes, we will see our new welcomeFragment in the middle of the navigation graph. We can zoom using the plus icon, and we can see a preview of the fragment layout that shows Hello blank fragment. One interesting thing is that next to the ID, there is a home icon. This is because this screen is set as the home destination, which is the default destination for our navigation graph. On the navigation graph, there is a section on the left that shows all the screens that belong to our navigation graph. Also, there is a host section, which is empty now. That's because we didn't set the host activity for our navigation graph. Let's open our MainActivity now. In order to make our MainActivity the navigation host, we have to add a new navigation host fragment to it. To do so, open the MainActivity layout, and switch to TextView. Delete the default TextView that appears, and add here the navigation fragment code that I'm showing. Let's look at the different attributes of this fragment. The name attribute links to the NavHostFragment class. This class belongs to the Navigation component and implements an area in which your navigation will occur. The app:navGraph indicates which is the navigation graph that we want to host. And in our case, it's the one named nav_graph. And, finally, there is app:defaultNavHost. This indicates the library to intercept all backpress to handle navigation correctly. If we go back to the navigation editor, you will see how activity_main appears as the host section on top. Now it's time to run our app and see what happens. As we can see, under the action bar, we see the text Hello blank fragment, which belongs to the WelcomeFragment that we have created before. I have modified the WelcomeFragment and added the layout for this sample app that I will be using during this course. You can create your own layout, or you can just take a look at the provided code samples and feel free to copy mine. As well, I have removed the theme action bar because we will add our own toolbars later on. You can do that by modifying the default theme of the app. When I run the project again, I can see all the style changes that I have done. But, of course, here we only have one screen. Now we will create a second screen, and we will implement the navigation between these two screens.

Navigating to a Second Screen
Now that we have the navigation graph fully set up, it's time to add a second screen and implement a click action to navigate from the WelcomeFragment to the new screen that will be for the registration. I will show you how to add a second screen to the navigation graph. We will add a navigation action to navigate from one screen to the other one. Finally, I will run the project to verify that our navigation setup works as expected. To add the new screen, first, open the navigation editor of your project. Click on the button on the top named New destination, and add a new blank destination. Let's call this one RegistrationFragment. Remember that we don't need the Include fragment factory method or the Include interface callbacks. Now it's time to define the navigation between the first screen and the second screen. Click and drag from the point on the right of the welcomeFragment to the newly created registrationFragment. This adds a line that defines a navigation action between the first screen and the second screen. When we click on it, we can see a series of properties on the right of the screen. We will explore them in the next video. Now we need to add the code to perform the navigation action. In the welcomeFragment layout, I have created a button that when clicked will route the user to the registration screen. In my case, the button ID is button_registration. Now open the WelcomeFragment Kotlin file. We need to add the setOnClickListener to the registration button. Rather than implementing the click action by ourselves, we will use the createNavigateOnClickListener function from the Navigation component. The library provides us with methods that can configure automatically components to perform navigation. One of them is the createNavigateOnClickListener. This generates the click listener that performs navigation on click. As the ID, we have to pass the ID of the navigation action that we just created on the navigation editor. In my case, the ID is action_welcomeFragment_to_registrationFragment. In my project, I have added some nice registration form to the registrationFragment layout. Feel free to do the same, or you can copy the one provided in the course materials. Let's run and test our code. As we can see, now clicking on Register routes the user to the registrationFragment. By clicking back on the emulator, the user is redirected back to the welcomeFragment. Congratulations! You have implemented your first navigation action. Notice that the backpress clicks are correctly handled by the MainActivity. Since we made our NavHostFragment the default one, all backpress clicks are handled by it.

Exploring the Navigation Graph Designer
In this video, we are going to take a look at the different options available in the navigation editor. Let's take a look first at the navigation action attributes. Notice that we can always switch to the text version of the navigation graph, which can help us create some attributes better. One interesting thing to notice is how the generated IDs follow this pattern. First, there is the action keyword. Then there is the origin screen ID. Then the to keyword. And then the destination screen ID. We usually don't need to change these IDs or provide them by ourselves. They will be generated by the system, and the naming is quite convenient. In the Transitions section, we can define the transition animation that we want to run when running this action. The first one is Enter, which is a transition animation the destination will run when navigating to it. If we take a look at the default Enter animation, we can see how the alpha of the screen changes from 0 to 1 doing a fade animation. The second one is Exit. And this will play on the screen we are leaving. The default provided one by the library fades the screen from alpha 1 to alpha 0. Pop Enter is similar to Enter, but this transition animation runs when the user is navigating back. Pop Enter runs on the screen that now appears when navigating back, so the previous screen. For example, if we are on the registrationFragment, and we navigate back, Pop Enter transition runs on the welcomeFragment. The same thing with Pop Exit. This animation runs on the screen that the user is leaving. So this animation will run on the registrationFragment when we are navigating back to the welcomeFragment. This is how it looks like when we set all of them. We get the fade-in and fade-out animation. And then the same when going back. You can create your own custom transition animations in XML too, and then use them with the Navigation component library. The section named Argument displays which are the arguments that the destination screen requires. Later on, you will be doing a lesson on how to add arguments and pass them in a safe way. Pop Behavior is an interesting feature, which is a bit hard to understand. So I will start with an example. Imagine that once you log in, you navigate to the list of boats. But you want to exit the app when the user clicks Back. You can accomplish that with Pop Behavior. You define a screen that you want to navigate back in Pop To. In my case, I set the welcomeFragment as my Pop To destination. And then set Inclusive flag to true. When Inclusive is true, it will also pop the reference screen, and in my case, it will exit the app. I will configure the Pop Behavior as an example. I set the welcomeFragment as my Pop To destination, and then I set Inclusive to true. When I run this example, I can see how the app is closed when navigating back using backpress. And the last option is the Launch Options, Single Top. When you set the Single top option from the Launch Options as true, there will be at most one copy of a given destination on the top of the back stack. It works similarly to how FLAG_ACTIVITY_SINGLE_TOP works with activities. We looked at the different attributes for action. Now let's take a look at the buttons that we can find in the navigation editor. The Issues button opens and issues a screen that we show if we have any configuration issue with our navigation graph. Thankfully, now it's empty. Outer Range redistributes the different destination screens in a way that our graph is easy to understand. We can mess with our graph a little bit, then click Outer Range to see them correctly ordered. Zoom To Fit will set the zoom to a level that allows us to see the whole navigation graph, useful when we want to have a full overview. And when we select a destination, we see this button named Set Start Destination. When we click this, we will set the destination as the default one when starting our application. Currently, welcomeFragment is my start destination. With what you learned in this module, you should be able to use the Navigation component in a very simple way. You learned how to configure the project making sure that you are on the right version of Android Studio and also adding the Navigation component library to your project. You learned how to create a navigation graph using the built-in tools in the editor. We have created two screens, the welcomeFragment and the registrationFragment. And we have implemented the navigation between the two of them using the built-in NavigateOnClick method. We finally took a deeper look at the navigation editor too and the options available for us. Thanks a lot for watching. I hope you enjoyed this module.

Implementing Navigation Screen to Screen
Introduction to Navigation Screen to Screen
Hello everyone. My name is Miquel Beltran. Welcome to the module, Implementing Navigation Screen to Screen, from the course, Android Navigation Architecture Components: Getting Started. So far, you have learned how to create a navigation graph in your app and how to implement simple navigation between two screens. In this module, you will learn about the different navigation patterns that are supported by the Navigation component and that are common in Android, for example, the BottomNavigationView. The BottomNavigationView allows movement between the primary destinations in an app. It is a very common pattern on Android apps, and it is included in the material design specs. You will learn also to change the contents of the toolbar programmatically when the user navigates from one screen to the other. Navigation can also be implemented programmatically with the navigate command. And in this module, we will learn how to do that. We will explore the options we have to pass parameters in a safe way to our destination screens. For example, in this case, when we click on the boat item, we want to open the boat fragment, but we also need to pass the ID of the boat to the boat fragment. And, finally, we will take a look at the differences between the Kotlin and the Java APIs, and maybe you will find some motivation to start using Kotlin if you don't do it already. In summary, in this module, you will learn to use the BottomNavigationView together with the navigation graph. You will learn how to configure the toolbar so it changes depending on the destination. You will learn to pass arguments between the screens and how to do that in a safe way. And, finally, we will take a look at the differences between the Kotlin and the Java APIs.

Using BottomNavigationView and Toolbar: Part 1
The BottomNavigationView from Android implements the bottom navigation bar defined in the material design specs from Google. It allows the movement between the primary destinations in an app, and it's widely used in many Android applications. The material design specs recommend that it has between three and five destinations. It is important to note that in our example, we will have only two destinations. Another recommendation is to use the cross-fade transition between the two destinations using the BottomNavigationView, which can be easily implemented with the Navigation component. If you want to learn more about it, I recommend you check the material design guidelines from Google. The second component we will integrate is the toolbar, also known as the action bar or the app bar. Its goal is to display information and actions regarding the current screen. What we want to accomplish is to change the content of the toolbar depending on the screen that we are on. For example, when we are on the FeedFragment, we want to display Boat Feed. When we are on the OrdersFragment, we want to display Orders. The Navigation component provides methods to configure them. SetupWithNavController takes care of configuring the BottomNavigationView. Same for the toolbar. We have a setupWithNavController method. However, since we want to have navigation inside of another screen, we will have to create a different navigation graph to handle the navigation of the bottom navigation bar. We can accomplish that by having a child fragment inside one of our destinations. In our case, the homeFragment will contain a child fragment to handle that sub-navigation graph. Next, I will create a second navigation graph, and I will add it to the homeFragment in a child fragment. Then I will add both the toolbar and the BottomNavigationView and configure both components to work together. We are back at the navigation graph editor. Here I have created a new screen called homeFragment, which is currently empty. I will open it and add the necessary views in the layout. What I will add is a toolbar, a BottomNavigationView, and a fragment. First, I add the toolbar, and now I add the BottomNavigationView. To add the fragment, I switch to the text editor, and I add the fragment here directly. And now I put the fragment between the toolbar and the BottomNavigationView. Before we connect everything, we have to create a second navigation graph. You can do that in the same way we created our first navigation graph. I will call this second navigation graph nav_graph_home. We'll add two new screens to this navigation graph, one that I will call FeedFragment and the second one that I will call OrdersFragment. Then make sure that the FeedFragment is set as the default destination. We don't need to create any navigation actions yet. I will add some content now to the feedFragment and to the ordersFragment, but you can decide just to display a text view if you want. You can find my code in the course materials. Now we are back at the home feedFragment. Our goal now is to connect everything so the BottomNavigationView can be used to navigate between the feed and the ordersFragment. We need to make some changes to the newly created fragment in the center, so open the text editor. First, make it a NavHostFragment. And then set the nav_graph to the nav_graph_home. Also interesting, I don't want to handle backpresses, so I will set defaultNavHost as false because I want my main nav_graph host to handle those backpresses.

Using BottomNavigationView and Toolbar: Part 2
We will have to add a menu to the BottomNavigationView. I will create a new menu configuration file and call it menu_bottom_bar. Here I will add two items. I have to add the IDs of the two screens we are going to navigate to. Those IDs are feedFragment and ordersFragment, which correspond to the IDs of the fragments that we have created previously. You can also add icons if you want and feel free to add some text to it. Go back in to the homeFragment layout and add the menu to the BottomNavigationView. We are almost done now editing our XML files. It's time to jump into Kotlin code. We need to configure the BottomNavigationView with a setup method. We need to set here a navController. We will get that from the fragment that we have added to the HomeFragment. To do so, you have to access the childFragmentManager, and here call to findFragmentByID and pass the ID of the fragment, which is just fragment. And you need to cast this to a NavHostFragment. Now you can set this navHostFragment as the setupWithNavController. Now we can run the project and see how it works. Our navigation view responds to the navigation clicks. It's time to configure the toolbar now. Back to the HomeFragment. I will use the setupWithNavController again to show you how it works. Let's run this change on the emulator. As you can see, the toolbar is displaying a navigation arrow that, in fact, we don't want. We just want to display the label of the screen and nothing else. We can accomplish that with our custom NavigatedListener. You can create a custom NavigatedListener by calling to this method on the navController. One of the parameters is the destination object, which is the nav destination. We want to obtain the title for it and set it to the toolbar. Now let's run the example again. As you can see, the toolbar reacts to the destination changes as expected without showing the navigation arrow.

Navigation by Code
We have seen the different ways that we can accomplish navigation automatically. We can generate the OnClickListener methods that will navigate to a destination. We can also configure the BottomNavigationView automatically to perform navigation as defined. And, also, we can configure the toolbars to implement the app navigation action. In some cases, we want to redirect the user automatically without having to click a button. So we have a specific condition that will change the functionality of a button depending on the situation, for example, if a login is successful. A way to do navigation without using the standard controls is by calling the navigate method by hand. The Navigation component provides us with a navigate method that helps to perform navigation from one screen to the other. Let's look at one example of how to use this. We have a login screen that requires the user to input a username and a password. When the user clicks on Login, we verify those. And if they are correct, we navigate to the next screen, in this case, the HomeFragment. To help us with this task, we need another method, the findNavController. The purpose of this method is simple. It will look for a NavController within the activity or the fragment that we are in. The NavController manages the app navigation within the NavHost. Once you've got the instance of the NavController, you can call to the navigate method. This method requires an action ID or a destination ID to navigate to. For example, I can use action_welcomeFragment_to_homeFragment to perform the navigation action that navigates from the WelcomeFragment to the HomeFragment. Let's implement this case. I will add some very simple login logic to the WelcomeFragment. I will just check that the fields are not empty just for demo purposes. Never do this in a professional environment. When the condition is met and the user clicks the Login button, the app will navigate to the HomeFragment, of course, using the navigate method. Let's open the WelcomeFragment. Here I will replace the setOnClickListener logic by the logic that will do the login. I remove the original setOnClickListener. And I replace it with a setOnClickListener callback. Now I will read the email value and the password value, and I will check if they are not empty. Again, this is just for demo purposes. This is not a valid way to authenticate your users. Here we can perform the navigation manually by calling to findNavController and then calling to navigate with the action that will navigate to the homeFragment. As you can see, if we look into the method, this is a Kotlin extension function. If you are not using Kotlin, you will have to use NavHostFragment.findNavController method instead. Let's run this example. When I click the Login, it does nothing. But as soon as I write something on the email and the password, and I click Login again, then it navigates to the homeFragment.

Passing Parameters in a Safe Way
We have just learned about the navigate method on the previous lesson. The method supports multiple parameters, one of them being a bundle for passing arguments from one screen to the other. The way to use it is similar to how we used to pass parameters from one activity to the other. First, create a bundle. And then add the different arguments to it. Then call to the navigate method with the arguments. On your destination, you can read the arguments quite easily, just like you would read any kind of argument. You need to obtain the arguments property and then call to get the value. But you can already spot the issues here. What if a developer is passing an ID as a string, and another expects the ID to be an integer? In this case, the getInt call will fail and will return null. Or what happens if a developer decides to rename the ID by something else? How can we keep this safe? The Navigation component provides a tool for that. It is called the Safe Arguments Plugin. This gradle plugin will generate a couple of classes for each navigation action, and those generated classes provide methods that provide our read arguments in a safe way. This will generate two types of classes, one for the directions and one for the arguments. The directions class is used to generate actions from one screen to the other, for example, generating a method that will create an action with a required parameter. In this example, the HomeFragmentDirections is generated with a method actionHomeFragmentToBoatFragment with the ID as a parameter. So this is creating an action that will navigate the user from the HomeFragment to the BoatFragment passing the boatId. The arguments class will contain utility methods used to parse arguments inside a destination. So, for example, this one is providing the ID that we require. Now we will go into the code, and you will learn how to configure this plugin. We need to add the plugin to the build.gradle file. Also, you will learn how to use the newly generated method. We will pass the boatId from the BoatFragment using this plugin, and then we will use HomeFragmentDestination class to pass the arguments. And, of course, we will use the BoatFragmentArgs to read the arguments. To use this plugin, first, you will have to add this dependency to the build.gradle file of your project. Then call to apply plugin on your app build.gradle file. Now we need to define the arguments on our navigation graph. In our case, we want to add the ID to the action between the homeFragment and the boatFragment. Here I'm adding a new argument with a name ID and a type integer. We can check how this argument looks like on the XML. Once you compile, different classes will be generated, and we can directly use them. In our example, we have HomeFragmentDirections and the BoatFragmentArgs classes. Let's take a look at the HomeFragmentDirections. This class contains a static method that will generate an action, and this action is a NavDirections. This generated action also has the ID that we have specified as a parameter. The BoatFragmentArgs contains a method to parse the arguments from the bundle and then a getter to obtain the value. If the ID is missing, it will throw an exception, and that makes sure that the bundle that we are parsing contains this ID. So let's use them to read values. In the FeedFragment, when the user clicks on a boat, I want to open the BoatFragment by passing the ID to the boat as a safe argument. Now I will replace this unsafe call to use this safe arguments call. First, I need to create the action, and for that I use the HomeFragmentDirections class. This method requires an argument, and this argument is the boatId that we have to pass. Now we can call to the navigate method as we were doing before, but instead of passing the action ID, we now pass the action object that we have created. On the BoatFragment, I want to read this value now. I will replace the old call with a new one with a safe argument. The way to do this is very simple. I can read the ID by calling to BoatFragmentArgs and then passing the arguments as the parameter for the fromBundle method. This will parse the arguments, and now I can obtain the property ID. I will run this example, and I will show you with a debugger how the value is passed from one side to the other. Click on the boat item. This onBoatClick method is called, and the debugger stops. You can see how the ID is set in the action object. And now on the BoatFragment, we can see how the ID was correctly parsed from the arguments. I continue running the app. You can see how the BoatFragment is opened, and it's displaying the right boat.

Kotlin vs. Java Navigation Api
I want to talk a bit about the differences between the Kotlin and the Java APIs for this library. We have been using the Kotlin version as it provides a series of improvements over the Java API. But you may be asking, Can I use the Java API? What are the differences? Let's take a look in this video. We are using the Kotlin library version for this course. If you want to use the Java version, you can do that by removing the -ktx part of the library name. The library is, indeed, the same, but the -ktx version provides some goodies for you in the form of extension functions and default parameters. We have used one of them, for example, the findNavController method. It is, indeed, an extension function of the fragment class. The same functions are available in Java, and we can call to them directly. In this example, we can call directly using the NavHostFragment and passing the fragment as a parameter. Another example of it is the setupActionBarWithNavController. In this case, it is again an extension function over the AppCompatActivity. It helps you to configure the navigation actions on an action bar in case you have it. When you use Java, you have to call to the equivalent static method. Kotlin can help you write less code when you're using the navigation library. But the most interesting part of the Kotlin API is the addition of a domain specific language for creating navigation graphs programmatically. To start using this API, start with findNavController, and from there, you can access the createGraph method. This method is only available in the Kotlin version of the library. So if you are interested in creating a navigation graph programmatically, which is more an advanced use case that we haven't covered in this course, you should consider using the Kotlin version. We got to the end of this module. Let's take a look at the things that you have learned. The first thing you learned was how to use the BottomNavigationView and the toolbar together with the Navigation component. You learned how to use programmatically these two views, but as well how to handle special cases like navigation manually. You have learned as well how to perform navigation using the navigate method and how to pass parameters from one screen to the other in a safe way. And you learned how to configure the gradle plugin to generate that code. And, finally, we took a look at the differences between the Kotlin and the Java APIs. I hope you enjoyed this module. Thanks a lot for watching.

Using the Navigation Component for Deep Linking
What Is Deep Linking?
Hello everyone. My name is Miquel Beltran. Welcome to the module, Using the Navigation Component for Deep Linking, from the course, Android Navigation Architecture Components: Getting Started. So far, we have seen how navigation works between two screens, for example, when a user clicks on one button and the app navigates to the next destination. But there are other cases for navigation. For example, when a user receives a push notification, then we expect that when clicking on it, the app opens and displays the related content and not just the home screen. As well, a user may follow a link to your website. And if you have the app installed, you want to display the same related content and not just the home screen. We can solve this problem with deep linking. With it, you can create URLs that take users directly to the specific content in your app. With the Navigation component, we can define URLs that will link to other screens. And, as well, we can create deep links manually, useful for when the user clicks on notification. In this module, you will learn how to create deep links, how to start them from notifications, and how to configure your app to handle web links as deep links.

Deep Linking from Notifications
One case of navigation is when we need to send a user from an external action into a specific screen of our app. For example, when a user taps a notification, we want to open the app and show the specific content related to it. Another example is when the user does an action on a widget that should open the app. For example, we have a widget on the screen, the user clicks on the widget, and then it should open a specific screen of your app. However, we cannot just simply call to start activity and open our app from a notification. The Notification.Builder requires us to provide a PendingIntent instead. So what's a PendingIntent? A PendingIntent specifies an action to take in the future. It contains a description of an intent and a target action to perform with it. Thankfully, we don't need to create the PendingIntents by hand. We can use the NavDeepLinkBuilder from the Navigation component library. The NavDeepLinkBuilder is a class used to construct deep links to a particular destination in a NavGraph. To use it, we will have to provide the following values. First, specify the navigation graph that should be used for the created PendingIntent action. Secondly, specify the destination. Note that here we are not providing a specific navigation action, but, instead, we are providing the ID of the screen we want to open. We can also pass arguments to our destination, which will be useful if we want to open a specific content of the app. Finally, we call to PendingIntent to create it. Now I will open Android Studio, and I will show you how it works. I will create a notification that opens when the app starts just for testing. And tapping on it will redirect the user to a specific screen passing the ID of the item we want to display. For this, we will have to use the NavDeepLinkBuilder. With it, we will create a PendingIntent. We will also specify our destination. And then we will pass a specific value for the boat ID. I have opened the MainActivity of the project. In here I have created a method called sendFakeNotification. The method sendFakeNotification has the following content inside. First, I get the instance of the NotificationManager. Secondly, I have to create a channel if I am supporting devices with version 0 or later. Then I am creating the notification here. I'm using the Notification.Builder to create a simple notification that is just showing some content title, and also I'm using a small icon. As you can see, this notification doesn't have any action yet. Then I have to set the channel ID to the notification. And, finally, I call to the notificationManager.notify. Let's start by creating the PendingIntent. I go here, for example, before the notification, and then I will create my new pendingIntent. It's going to be equal to the NavDeepLinkBuilder, which is here. The first thing I have to pass is the context. Then I need to set the graph, so I will call to setGraph with the value navigation, and then I have to select our navigation graph, nav_graph. Secondly, I need to pass also the destination, and the destination in this case will be the boatFragment. Then I need to pass the arguments. We will do this later, so I set here arguments, and I create args, and we will see how we do this. And then I will call to createPendingIntent. So now we have the PendingIntent here. Now I have to set the PendingIntent to the notification. So I can go to the notification here, and I can call to setContentIntent, and then here I pass the pendingIntent. Now we just need to create the arguments for the notification. Let's see how we can do that. I will create a variable called args, and I will use the BoatFragmentArgs class that has been generated using the safe arguments generator. I will call to the builder, and here in the builder, I have to pass the ID of the boat that we want to open. So I will just hardcode the number 3 for the id: 3. Then I can call to build, and here I need to convert it into a bundle so we can pass it to the arguments. This args now is a bundle, and we can call to setArguments with this arguments. It's time to run our example. As we can see, the notification appears when we start the app. When we click on it, the app opens directly into the BoatFragment that we have created. And it is, in fact, opening the boat we wanted, the one with the ID number 3. When I click back, rather than exiting the app, it redirects me to the starting destination as expected.

Deep Linking from Web Links
So far, we have seen how we can send our user into the app from the outside using a PendingIntent. Now we will see how we can do the same using a deep link with our URL. When we talk about deep linking in Android, we refer to URLs that point to specific destinations in our app. For example, we can make https:// www.example .com / to redirect to the HomeFragment of our app. When the user follows that link from an email or from an instant messaging app, and the app is installed, the app will be opened. If the app is not installed, then the website will be opened. We can also have URLs that are a bit more complex and contain parameters. For example, we can make example.com /boat/1 to point to the BoatFragment and show the content for the boat with ID 1. If the app is not installed, then the website will be opened. We can also define a custom scheme, useful when we want only the app to be opened. So, for example, we may want that rentaboat://boat/1 to open the same screen. Both cases can be easily solved with a Navigation component. We will see how now. To do so, we need to add a deep link to our destination. Before we jump into the code, let's define our requirements. We want that example.com /boat/1 to open the BoatFragment for the boat with ID 1. Also, we want that rentaboat://boat/1 to open exactly the same. Deep links accept parameters. In our case, we want to obtain the part of the path that corresponds to the ID of the boat. For that, we will have to specify a deep link with the ID parameter in the path. We can use placeholders for that. So now the URL will be this one, example.com /boat/(id) between brackets. When the deep link is parsed, the library will provide us with an argument of the type of string and the name of ID with the value that was there. I will recommend that instead of using the same argument name that we have been defining as a safe argument, we choose a different name because if not, you may encounter parsing problems. In my case, I have id already defined as a safe argument for the type int. So I will use id_dl to specify that the ID is provided by a deep link. Then my URL will look like example.com /boat/(id_dl). I will do the same for the custom scheme and define my custom scheme deep link URL as rentaboat://boat/(id_dl). Alright, we have specified the two deep link URLs and the destination that we need to open. Let's jump into the code and implement this. First, we will specify the two deep links on the boatFragment destination. We have to do that on the navigation graph, and we have to add the specific code to the AndroidManifest. Then we have to load the parsed parameters. And also I will show you how to test things using ADB. I will show you first a way to open URL intents from command line so you can easily test this process. You will need to have ADB in your path. If you don't have this command, please look on line for a guide to add ADB to your path. This is a very useful tool for Android developers. With ADB, we can run the following command. This will run a view intent to the provided URL. Now without any changes in our app, if you run the command, it will just open a browser to example.com. We will use this again later to verify our implementation. It's time to open Android Studio. Open the navigation editor here. So we can go to the nav_graph. And we have to select the boatFragment. And now we have to click on add a deep link to add a new one. Here we have to put the URL that we have defined before. So in our case, it will be the following URL for HTTP URLs. And also we need to add the rentaboat scheme. The second step is to add the following lines to your AndroidManifest. Here inside the MainActivity, we need to add the nav-graph. This specifies which are the deep links that we want to register to this activity. The next step is to modify the boatFragment so we can parse the arguments that we are sending to it. The first thing, we need to get the intent arguments. So for this, I call to arguments here. This is a new level property, so I need to check it. And then I will call to getString to obtain the string that we are passing as a parameter. The string has an ID of id_dl. And, finally, I need to convert it to an integer. If this ID does not exist, then I want to use the ID from the safe arguments. And to do so, I will do the following. I will use BoatFragmentArgs also, as well, and I will call fromBundle, and here I will pass the arguments. And then I will get the ID. Let's run our app and see how it works. Now let's go back to the terminal, and let's run the same ADB command that we saw before. And as you can see, it opens the BoatFragment with a boat with ID 1. Now let's close the app. And let's try this again the same, but now with the rentaboat scheme, the other scheme that we have defined. And it's exactly the same. And in this case, it's not asking us if we want to open the browser or now. A small summary before I finish this module. We can use the Navigation component library to handle navigation from outside into the app, for example, from a notification, a widget, or a web link. We can create pending intents that will open a specific destination to a navigation graph with ease including passing arguments in a safe way. We can also define URLs that will link into specific destinations, and we have custom parameters that will be parsed automatically, everything being really easy to do. Thanks a lot for watching. I hope you enjoyed this course.

Course author
Author: Miguel Beltran	
Miguel Beltran
Miguel is a Freelance Android developer based in Berlin. He is passionate about mobile app development and machine learning, but most importantly, he is passionate about teaching and learning....

Course info
Level
Beginner
Rating
0 stars with 1 raters
My rating
null stars

Duration
1h 19m
Released
12 Feb 2019
Share course