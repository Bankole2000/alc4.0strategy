Android Apps with Kotlin: ViewModel and Lifecycle
by Jim Wilson

Learn the skills necessary to effectively maintain activity state and simplify coordination with the activity lifecycle using the Android Architecture Componets' ViewModel, Lifecycle, and other related types.

Effectively managing Android activity state and coordinating the lifecycle of components within an activity are essential to providing a high-quality and consistent user experience; however, doing so can sometimes be a challenge. In this course, Android Apps with Kotlin: ViewModel and Lifecycle, you’ll learn how to use the Android Architecture Components’ ViewModel, Lifecycle, and other related types to deliver just such an experience. First, you'll see how to use ViewModel to simplify managing activity-related data and maintain consistent access to that data even when the system recreates the activity in response to device orientation changes. After that, you'll explore how to use ViewModel in cooperation with onSaveInstanceState to assure a more consistent user experience when moving between apps. Next, you'll discover how to leverage Lifecycle events to simplify coordination between life cycle dependent components and the activity that uses them. Finally, you’ll delve into Lifecycle states to create more flexible, easier-to-use life cycle dependent components. By the end of this course, you'll have the necessary skills and knowledge to create Android apps of your own that provide a high-quality and consistent user experience with the Android Architecture Components’ ViewModel, Lifecycle, and other related types.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Advanced
Rating
4.8 stars with 10 raters(10)
My rating
null stars

Duration
2h 24m
Released
21 Dec 2018
Share course

Course Overview
Course Overview
Hi everyone. My name is Jim Wilson. Welcome to my course, Android Apps with Kotlin: ViewModel and Lifecycle. I'm a managing partner of JWHH, LLC., and I've had the good fortune to have been a professional software developer now for over 30 years, and I've been creating apps for Android since the earliest days of the platform. In this course, you'll learn the skills necessary to work effectively with the Android architecture components ViewModel, lifecycle, and other related types. And you'll do all of this while levering the power and efficient coding experience provided by the Kotlin programming language. Some of the major topics we cover include managing activity state with ViewModel, maintaining activity state during system-initiated shutdowns, persisting complex activity state, subscribing to lifecycle events, determining lifecycle state. By the end of this course, you'll have the skills necessary to create Android apps that provide a high-quality, consistent user experience using the Android architecture components, ViewModel, lifecycle, and other related types. To get the most out of this course, you should already have a solid understanding of the fundamentals, developing Android apps using Kotlin, the purpose and behavior of Android activity lifecycle-related callback methods, the basics of working with RecyclerView. You can learn more about these topics in my courses, Android Apps with Kotlin: Build Your First App, and Android Apps with Kotlin: RecyclerView and Navigation Drawer. I hope you'll join me as we'll learn the skills necessary to provide a high-quality and consistent user experience using the Android architecture components, ViewModel, lifecycle, and other related types with the course, Android Apps with Kotlin: ViewModel and Lifecycle, at Pluralsight.

Managing Activity State with ViewModel
Introduction
Welcome to the Pluralsight course, Android Apps with Kotlin: ViewModel and Lifecycle. This is our first module, Managing Activity State with ViewModel. My name is Jim Wilson. Throughout this course, we're looking at types that come from the Android architecture components library and are tied to managing state and other lifecycle-related issues within our activities. So in this, our first module, Managing Activity State with ViewModel, we'll see how we can use ViewModel and related types to simplify the task of maintaining consistent user experience when device configuration changes occur. In the next module, Maintaining Activity State during System-initiated Shutdowns, we'll take a look at some of the scenarios where the task of providing consistent user experience requires more handling than the ViewModel class can provide by itself. So we'll see how to deal with those issues in that module. After that, we'll see how to deal with persisting state that involves complex types like objects and object relationships. Then in our next module, Subscribing to Lifecycle Events, we'll see why certain types of components, such as location services and messaging systems, need to cooperate with the lifecycle of our activities and see how we can use lifecycle events to simplify the task of doing so. And then in our final module, Determining Lifecycle State, we'll see how we can use lifecycle state information to further simplify the task of associating components with the lifecycle of our activities. So now in this module, our focus is on maintaining the state of our activities when the activity is destroyed and re-created in response to a device configuration change. And this happens more than you may think. Anytime a user rotates a device from a portrait orientation to a landscape orientation, our activities are destroyed and re-created, and that creates challenges for us as app developers. So we'll start out in this module by looking at the details of that challenge. After that, we'll see the role of the ViewModel class and other related types in helping us to overcome that challenge. We'll then see how we can identify state-related bugs in our activities. We'll then see how we can add ViewModel into our application and provide the necessary build dependencies. Then we'll see how we can access and manage the state of our activities using ViewModel. And we'll finish up by looking at some more complex state scenarios that we can manage with ViewModel.

Activities - More Than Just a Pretty Face
As we build our applications, the application user experience is provided by our activities. Now from a user perspective, activities are just simply screens within an application. But as developers, we know there's much more going on to simply presenting some views to a user because an activity is a component that actually has its own lifecycle. So as we're coding up our activities, it's important that our code cooperates with that lifecycle. Now just as a reminder, this course assumes that you already understand the lifecycle of activities and the callback methods that are associated with that lifecycle. If you're not familiar with the details of the activity lifecycle, or if you just need a refresher, I'd encourage you to go back to the first course in this series, Android Apps with Kotlin: Build Your First App. And in that course, we talk in great detail about this activity lifecycle. Now a key part of the activity lifecycle is the activity's life and death, but there can be some complex issues around this idea of life and death of an activity. Because obviously at the beginning, an activity gets created, and at its initial creation, the state of that activity is app defined. In other words, any state within the activity is however we've coded it to start up. But then as a user interacts with the activity, the activity kind of matures and grows. So any state we store within the activity reflects the actions that the user has performed. Now once that activity gets destroyed, any state stored within the activity instance is lost. Now there are some scenarios where an activity is destroyed not because a user is done with the activity, but because certain system events occurred that required that the activity be destroyed. And when those situations occur, when the user performs an operation that takes them back to the activity, the activity gets re-created. But when the activity gets re-created, we don't want the activity to have its default initial state. What we want is for that activity to restore its previous state so that from the user perspective, the activity never went away. We want to give the user the impression that the activity was always there waiting for them. Now there's a number of situations that can lead to an activity being destroyed and re-created. But one of the most commonly occurring ones is whenever a device experiences a configuration change. And configuration changes can occur for a number of reasons. One of the most common scenarios is when the user rotates a device from portrait to landscape. So if my application has an activity that's being displayed, and the device is rotated from portrait to landscape, when the user rotates that device from a portrait to a landscape orientation, my activity is completely destroyed. So any instance stored directly in the activity would be lost. And then once that activity is destroyed, a brand-new instance to the activity is re-created and displayed in the landscape orientation. So what we'd like to have is an easy way to keep that state around between the destruction and re-creation of the activity. And we'll see how we can do that in our next clip.

Managing Activity State with ViewModel
Now as we've mentioned, since activities can be destroyed and re-created, we need some way to maintain the activity's state across that destruction and re-creation process. And one way to maintain that state is to write the state out to a persistent store, and then read it back in. Now there are some scenarios that require that we do that. In the case of configuration changes, that's really expensive. So in these cycles, like configuration changes where the activity is very quickly destroyed and then re-created, we'd like a more lightweight solution than dealing with persistent stores, and that's where the ViewModel class comes in. The ViewModel class allows us to store activity state in process, but the state is stored separately from the activity itself, and that allows that state to be maintained even though the activity instance itself is destroyed and then re-created. And the way we use the ViewModel class is we create our own class that extends the ViewModel, and then we customize the class by adding whatever properties and methods are required to manage our activity's state. Now since our ViewModel is stored separately from the activity, we need something that manages the ViewModel for the activity, and that's where the ViewModelProvider class comes in. It handles the details of managing our ViewModel instances. So what happens is when our activity is initially created, it'll go out to its ViewModelProvider, and it will ask for a ViewModel. But since the activity is brand new, the ViewModelProvider will take care of creating the ViewModel instance. But then at some point in the future, if that activity is destroyed and then re-created, in that case when the activity asks for the ViewModel, the ViewModelProvider will actually hand back the existing instance that was created earlier. Now each activity will have its own ViewModelProvider, so the activity needs a way to find the ViewModelProvider that's associated with that activity, and that's what we use the ViewModelProviders class for. It manages the association between activities and their corresponding ViewModelProvider instances. Now it sounds like there's a lot going on there, but using ViewModel is actually pretty straightforward. Let's see what it looks like graphically. So now when an activity's first created, it will need the ViewModel instance that it will use to store its state. So to make that available, the activity can use the ViewModelProviders class. So what it'll do is make a call against ViewModelProviders asking for the ViewModelProvider that corresponds to the current activity. And then once that has the ViewModelProvider, it simply asks for the ViewModel instance. Because this was the first request for the ViewModel, the ViewModelProvider creates that instance, and passes back that reference to the activity. And then from there, the activity can interact with the ViewModel directly. So as a user interacts with the activity, it's storing and managing its state within the ViewModel. But then when the user rotates the device, we know what happens. The activity is destroyed, but that ViewModel instance still remains. So when the activity is re-created, the activity can now go back out to ViewModelProviders, get the ViewModelProvider that corresponds to the activity, and this time when it asks for the ViewModel, rather than creating a brand-new ViewModel instance, it passes back the existing ViewModel instance that it was using previously. So then with that ViewModel instance, it can now restore the previous state and allow the user to pick up right where they left off. So to help us understand all this better, in our next clip, let's take a look at the application we'll be using throughout this module and see how we might be able to use the ViewModel class to improve the behavior of that application.

There's a Bug in Our App
So we're looking here now at our app running inside the emulator. And if you've been following along in the other courses in this series, this app should look pretty familiar because it's the same app we've been using throughout the series. We call this our NoteKeeper app, and the purpose of this app is to allow us to keep notes for Pluralsight courses. So when the app first launches, we show a list of notes that have already been created here within our RecyclerView. As we look at each of the notes, we can see the course that note is associated with, as well as the title of the note. If I tap on one of the notes, then it takes me here to this Edit Note activity, which allows me to modify the note. So I can change the course it's associated with, change its title, as well as change the note text itself. So now if I head down here to the Back button, we click Back, that takes us back to our list of notes. Going to, of course, choose another note, and I can modify that note. Head back to the Back button, and I'm back at my list. Now this app also has a navigation drawer. So if I head up there to the icon at the top left and I select that, you can see there are other display options. So if I head down here to Courses and I select that, we now see a list of available courses. Let me head back up to the icon at the top left again. I'll choose that. Now in addition to the Notes and the Courses options, we also have another option, and that's an option I've added for this course, which is a Recently Viewed Notes option. If I head down to there and I choose that, this list shows the notes I've recently visited. So you see what we're doing here is we're using RecyclerView to display content using CardViews to allow the user to see the full list of notes, the list of courses, as well as the list of recently visited notes. So it's kind of a nice, little set of features. But we've gotten some bug reports that the app behaves strangely when the user rotates from portrait to landscape orientation. So let's see if we can check that out. We'll open up our navigation drawer. Let's go down here and select Courses. So we're currently displaying a list of courses, and let's see what happens now when we rotate the device from portrait to landscape. So let me head over here to the control bar for the emulator, and let's choose the option to rotate the device to the left. So I'll click on that. And you notice when I do that, the activity switched from showing the list of courses to showing the list of notes. So the app actually changed state. So that might be surprising to the user because they thought they were looking at a list of courses, but now they're looking at the list of notes. But the problem's even a little bit worse than that. Let me head over to the icon in the top left, I'll click on that, and you'll notice that the navigation drawer indicates that we're currently displaying the list of courses even though we're currently displaying the list of notes. So of course, the question is what's going on there? So let's head over to Android Studio and see if we can identify what's going on. So we're here in Android Studio, and we're looking at the ItemsActivity class, and this is the activity responsible for displaying that content within a RecyclerView. Well let's scroll down toward the onCreate method, and let's see if we can identify why it showed the list of notes when the user rotated the device even though they had selected the displayed list of courses. So we're down here in our ItemsActivity's onCreate method. Now recall, when we rotate the device from portrait to landscape, that causes our activity to be destroyed and re-created, which means that our onCreate method has to get called. And if we look here in our onCreate method, notice we have a call to this function, displayNotes. So what that means is any time the activity gets created, we always display the notes no matter what option the user had selected. So what we need to do is add the code to this activity to maintain the user's current selection when the activity's destroyed so when it's re-created, we can display the appropriate content for the user's selection. And in our next clip, we'll see how to do that.

Adding a ViewModel and Build Dependencies
Here we are back in Android Studio, and what we want to do now is improve the state management of our ItemsActivity class. As you recall, as we saw in the previous clip, whenever the device orientation changes, the activity always reverts to displaying the list of notes rather than displaying the appropriate content for the user's selection within the navigation drawer. Now we're looking here at our ItemsActivity class's onCreate method, and we know the problem is the way our activity's being created. Because here in onCreate, we always call the displayNotes function. What we really want to do in the case where our activity's being re-created for a configuration change, rather than displaying the notes all the time, we want to display whatever list is appropriate for the user's most recent navigation drawer selection. So to see how to do that, let's head down to the method where we handle the user's navigation drawer selection. So here we are now in the ItemsActivity class's onNavigationItemSelected method, and this is the method that handles selections within a navigation drawer. And you can see we have a when statement here that checks the ID of the selection and then based on that selection, we either display the list of notes, display the list of courses, or display the recently viewed notes. So in order to display the appropriate list when our activity is re-created, what we'll need to do is store the ID of the user's most recent navigation drawer selection. And we can't store it here in the activity because the activity gets destroyed and re-created, so this is a perfect opportunity to take advantage of the ViewModel class. So now in order to use the classes related to the ViewModel, we'll need to modify our application's build. gradle file. So what we'll do is we'll switch over to the app module's build. gradle file. So we're here in our app's build. gradle file, and we're in its dependencies section. And in order to add the appropriate dependency, we use the implementation keyword. Now the specific library we add depends on whether you're using AndroidX or not. At the time I'm recording this, AndroidX is in the early stages of adoption. Android Studio and most projects are still using the pre-AndroidX libraries, so that's the library I'll add to our project. So that takes care of adding the lifecycle extensions using the pre-AndroidX libraries. If you've already migrated your projects over to using AndroidX, I have the appropriate dependency for AndroidX currently displayed on the screen. So which of these libraries you use depends entirely on whether you're using AndroidX yet or not. Pre-AndroidX, use this dependency I have here in the build. gradle file. If you're using AndroidX, then instead use the library I have displayed onscreen. So now in order to sync our project with these changes, let's head over here where it says Sync Now, and I'll go ahead and sync the project. So we have the required dependencies in our project, so now we're ready to start creating our ViewModel class. So to do that, I'll head over to the package name in my Project window, I'll right-click on the package name, head up here to New, head over to Kotlin File/Class, and I'll choose Kotlin File/Class. Now when it comes to naming our ViewModel class, there's no hard and fast rules for how we name them, but a common pattern we use is the activity's class name followed by the word, ViewModel. So that's what we'll do here. Our activity's named ItemsActivity, so we'll name our class ItemsActivityViewModel. So we've got our class name there. Now for the kind, rather than in File, we want a Class. So I'll expand the Kind drop-down, I'll choose Class, and then we'll go ahead and click OK. So that takes care of creating our class. And remember that this is a ViewModel class so we'll want it to extend the class, ViewModel. To add the import for the ViewModel class, I'll hit Alt+Enter. So now our ItemsActivityViewModel class fulfills the requirement to be a ViewModel class. So now it's up to us to simply add this state information we want to store inside of our ViewModel class. Now in our case, we want to store the user's most recent navigation drawer display selection. So let's add a mutable property to our class named navDrawerDisplaySelection. Now, of course, when our activity is initially created, there won't have been any previous display selection for the user to have made, so we'll want to go ahead and give our property here a default value. Now currently when our activity's initially created, we always display the notes. So why don't we go ahead and make the default value for our navDrawerDisplaySelection's property the ID of the note selection. So that's our R. id. nav_notes ID value. So now with that, we have our ViewModel class, has a property to store the user's display selection, and that property has an initial value. Of course, the question is now how do we interact with our ViewModel from within our activity? We'll see how to do that in our next clip.

Accessing Our ViewModel with a Lazy Property
Here we are back in Android Studio, and what we want to do now is add the code to our activity to access our ViewModel class. Now we're currently looking at our ItemsActivityViewModel class, and we've already done the work to allow our ViewModel class to store the user's display selection that they make from the navigation drawer. But now, of course, the user ViewModel will need an access to ViewModel class from our ItemsActivity. So let's head over to our ItemsActivity class. So I'll head up here, and click on that tab. So now we're here in our ItemsActivity class, and we're looking at our onCreate method. And here at onCreate is where we'll want to get access to our ViewModel. So let me declare a local variable here named vm. So now in order to access our ViewModel, we'll need to start out with the ViewModelProviders class. And ViewModelProviders is a class we can use directly. We don't need to create an instance of it. And remember that what we want to do with the ViewModelProviders class is find the ViewModelProvider for this activity. The way we do that is by using the of method. And we want the ViewModelProvider of the current activity, so we'll pass in our this reference. So now with that, the of function will give us a reference to the ViewModelProvider for this activity. We can then use that ViewModelProvider to get a reference to our ViewModel class. The way we do that is by using the ViewModelProvider class's indexer operator. In other words, square brackets. We access it much like it's an array. And then within the square brackets, we provide the type information for our ViewModel class. So our ViewModel class is ItemsActivityViewModel, we'll want the type information, so we'll say ::class, and we need to pass that type information in a way that's compatible with Java, so we include. java. So with that code in place, our vm variable will now have a reference to an instance of ItemsActivityViewModel, and all the work of managing that ViewModel are taken care of for us. When our activity is initially created, a new ItemsActivityViewModel instance will be created. But if our activity's being re-created because of a configuration change, we'll receive back a reference to our existing ItemsActivityViewModel instance. Now commonly, we're going to want to access our ViewModel frequently throughout our activity, and we wouldn't want to have to write all this code to access it every time we need a reference to it. It would be a lot better if we can make our ViewModel reference a property within our activity. So let's do that. So I'll highlight the code here that accesses our ViewModel instance. With that code highlighted, I'm going to right-click on it, let's choose Refactor, we'll choose Extract, and then we'll want to extract a property. So we'll head over to Property, and we'll select that. Android Studio's asking if we want the property within the class or the file level. We'll want the class level, so we'll go ahead and select that. And for the name of our property, let's just make it viewModel. We'll hit Enter. So that gives us our ViewModel property. There's only one problem. If we tried to run this code right now, it would actually crash. And the issue is that we can't use the ViewModelProvider before the activity's onCreate method is called. Because remember that by initializing a property in this way, the properties initialize when the activity instance is created, which is before the onCreate method is called. We want to delay access in the ViewModel itself until after onCreate's called. We can do that by making this a Kotlin lazy property. Now if you're not familiar with lazy properties or you haven't worked with lazy properties when developing Android applications, I encourage you to check out the course, Android Apps with Kotlin: RecyclerView and Navigation Drawer where we talk about how we can use Kotlin lazy properties to have properties that work well with the activity creation requirements of Android. All right, so to make this a lazy property, we're going to remove that equal sign and replace it with by lazy, and then we'll wrap the value for the property in curly braces. Now we have our curly braces there, and then I'll go and add some line breaks just to make it a little bit easier to read. So now with that, our viewModel property is an assign once property, but it's a lazy property. And what that means is that we won't run the code to set the property's value until the first time we use the property. And since we don't use the property until we're down here in the onCreate method, we won't try to actually access the ViewModel instance until our activity's onCreate method has been called. So that takes care of the work to access our ViewModel. So now in our next clip, let's see how we can use our ViewModel to maintain state within our activity.

Restoring the Activity State
Here we are back in Android Studio, and what we want to do now is use our ViewModel class to assure that the users most recent display selection is restored any time our activity is re-created in response to a configuration change. Now in order to display the appropriate list when the activity is re-created, we're going to need to do whatever work is performed whenever the user actually makes a selection from the navigation drawer. So let's head down to the code where we handle the user's navigation drawer selection. So we're down here at our onNavigationItemSelected function, and the when clause within this function is what controls what work is performed in response to the user's selection. Now the first three selections, nav_notes, nav_courses, and nav_recent_notes, all modify the displayed list. The other two selections are tied to operations. So the only ones we need to handle in terms of tracking the state of our activity are the ones that are related to displaying the lists. So what we can do is create a function that has the logic to handle the three conditions related to list display. So let's scroll down a bit, and we'll start creating that function. So now I've scrolled down to just below our onNavigationItemSelected function. I'm going to create a new function, and we'll name it handleDisplaySelection. So we'll have our function accept one parameter, we'll name it itemId, and its type will be Int. Here within our function, we'll go ahead and add a when statement to handle the values of itemId. And here within the when, we'll add the code to display the appropriate list based on the itemId. So now our handleDisplaySelection has the code to display the notes, the courses, or the recently viewed notes depending on the value passed in to the function. So let's scroll back up to our onNavigationItemSelected function. So here in our onNavigationItemSelected function, rather than duplicate all the work of displaying the appropriate list, let's change it to go ahead and use our handleDisplaySelection function. So the first thing we'll do is take the three separate condition tests for nav_notes, nav_courses, and nav_recent_notes, and let's change it to one condition test that checks for any of those values. So now with that change in place, our initial condition here checks to see if the value of item. itemId is nav_notes or nav_courses or nav_recent_notes. And if it's any one of those values, what we'll do is call our handleDisplaySelection function, and we'll pass in item. itemId. So that'll take care of displaying the correct list for us, but remember we also want to keep track of which selection the user's made, and we'll do that by using our ViewModel. And we'll set our ViewModel's, navDrawerDisplaySelection property, and we want to set it to the value of item. itemId. So now with that, any time the user makes one of the display selections, we display the appropriate list, and we store that selection in our ViewModel. So now, let's go ahead and head back up to our onCreate function. So now here in our onCreate function, I've got a couple lines of code here that we don't really want anymore. We don't really need to take that ViewModel property and assign it to a local variable, so we can rid of that. And then here where we called displayNotes, rather than calling displayNotes, let's call our handleDisplaySelection function, and then we'll pass in our ViewModel's navDrawerDisplaySelection property. So now with that, any time our activity is re-created in response to a configuration change, we'll now display the correct list based on the user's most recent selection from the navigation drawer. So in our next clip, let's try it out.

That Bug's Fixed, but We Just Found Another One
Here we are with our app up and running, and what we want to do now is verify that the ViewModel allows our activity to maintain its state even when the activity is re-created in response to configuration changes. Now you recall the problem we were initially having is any time a configuration change caused our activity to be destroyed and re-created, our activity would always revert back to displaying the note list. Let's see if the ViewModel has taken care of that problem. Now we're currently looking at our list of notes. So let's open the navigation drawer. Let me head down here to Courses. I'll select that. Now we're currently showing our list of courses, so that's a good thing. So let's head over to the control options for our emulator. Then I'll go ahead and rotate the emulator to the left. And notice this time when we rotate the emulator, we're still displaying the list of courses. So now I'll head over to the option to rotate it back, I'll select that, and it's still showing our list of courses. So by storing our display selection within the ViewModel allows our activity to continue displaying the correct list even when the activity's destroyed and re-created in response to a configuration change. So that, of course, is going to provide the user with a much better experience. You know, I wonder if there's any other parts of our activity that is incorrectly managing its view state. Maybe there's some things we're currently storing in the activity that we should move over into the ViewModel. Let me head over to the icon in the top left of our activity. I'll expand the navigation drawer. Let's return back to our list of notes. Now remember I mentioned that this activity, in addition to showing the list of notes and the list of courses, also has an option to display the most recent notes you've visited. So let's see how that behaves. So I'm going to go ahead and select a note here. I'll head down to my Back button. We'll return back to our item's activity. Let me go ahead and select another note. Return back to our item's activity. We'll head up to the icon to open the navigation drawer. We'll click on that. And let's head down to our Recently Viewed Notes option, and we'll select that. So we can see there that when we do that, we can see the most recent two notes that we've selected. So let's see what happens to this list when we rotate the device. So I'll head over to the option, it let's me rotate the emulator. We'll go ahead and select that option. And you notice that when I do that, my recently viewed notes list becomes blank. So that tells me the information for the recently viewed notes is state that I'm storing directly in my activity that I should probably move over into my ViewModel. So in our next clip, let's start looking at what we need to do to do that.

Managing More Complex State with ViewModel
Here we are back in Android Studio, and what we want to do now is address the bug that we have in our application where we lose the list of recently viewed notes whenever a device configuration change occurs. Now a good place to start is to probably look at how we're storing that information. So we're currently looking at our ItemsActivity, and there are two properties here related to recently viewed notes. The first one, maxRecentlyViewedNotes, simply identifies how many notes we want to keep in the recently viewed list. But then our other property, recentlyViewedNotes, that's an ArrayList where we actually store references to the notes that have been recently viewed. And based on what we've learned in this module, that's probably going to be a problem. Because if we store those notes directly here in the activity, well, whenever a configuration change occurs and our activity is destroyed and re-created, we're going to lose those values. So we're probably going to want to go ahead and move these properties into our ViewModel. But before we do that, let's take a look at how we manage this recently viewed notes list. So let me just scroll down here a little bit. So now we've scrolled down to this function, onNoteSelected, and this is a function that gets called each time the user selects a note from our RecyclerView. This function receives a reference to the note that was selected, and you can see it calls another function, addToRecentlyViewedNotes. And addToRecentlyViewedNotes is responsible for managing our list of recently viewed notes. And so basically, whenever a note's selected, this function looks to see if it's already in the list of recently viewed notes. If it's not already in a list, it adds that note to the beginning of the list, and then trims off any notes that are in the list beyond the max that we want to keep. If the note is already in the recently viewed list, then in that case, it simply moves that note up to the top of the list and moves the others down. So this function is tied specifically to managing that list of notes. So it probably makes sense that if we're going to move the recently viewed note's properties into our ViewModel, we should go ahead and move this function into the ViewModel as well so that the data and the code that manages it can both be in the ViewModel. That provides two benefits. That simplifies maintenance because the code and related data are both together in our ViewModel. It also avoids bloating up our activity by placing a bunch of code in the activity that's not directly related to the activity itself. So to make this change, the first thing we'll do is we'll scroll back up to the top of our ItemsActivity class. So we're here at the top of our ItemsActivity class. Let me highlight the two properties related to our recently viewed notes. I'll hit Ctrl+X to cut those out. Let's switch over to our ItemsActivityViewModel class. I'll paste those properties in here. We'll switch back to our ItemsActivity class. We'll scroll down to our addToRecentlyViewedNotes function. I'll highlight this function, Ctrl+X to cut it, switch back over to our ItemsActivityViewModel class, and we'll go ahead and paste it in. So now the properties related to recently viewed notes, as well as the related method, are both here in our ViewModel. So we'll head back over to our ItemsActivity, and we'll update the activity to use the properties and method from the ViewModel. So we're over here in ItemsActivity. Remember our function, onNoteSelected, needs to call the addToRecentlyViewedNotes function, but of course, that function's now in our ViewModel, so we'll update that to call viewModel. addToRecentlyViewedNotes. So now with the note selected, the ViewModel gets informed of the note selection so then that selection itself is taken care of. And then there's one other place we need to update our ItemsActivity. So let's scroll up a bit. Now we're up here towards the top of our ItemsActivity at the property for the RecyclerView adapter for our recently viewed notes. And you see there the recently viewed notes are in red because, again, that property is no longer in the activity. That property is now over in our ViewModel, so we'll update that to say viewModel. recentlyViewedNotes. So now with these changes, our list of recently viewed notes are stored in the ViewModel, and all the code that manages that list are also in the ViewModel. So in our next clip, let's go ahead and run this and verify that everything works as we expect.

Verifying App Behavior
Here we are now with our app up and running, and what we'll want to do now is verify that moving the list of recently viewed notes into our ViewModel allows that list to behave properly even when the activity is destroyed and re-created in response to configuration changes. So let's start out. Let's go ahead and select the note. We'll head down to our Back button. Return back to our item's activity. Let's go ahead and select another note. We'll return back. Go ahead and select one more, and we'll return back. So now we'll head up to the icon to open up our navigation drawer. We'll select that. Head down here where it says Recently Viewed Notes. We'll select that. That, of course, displays the three notes we just selected. So now we'll head over to the button that lets us rotate the emulator. We'll go ahead and rotate the emulator. You notice this time when the emulator rotates, we still have our list. Now just to verify, let's head over to the Rotate button once again, we'll rotate it back, and our recently viewed notes list is still intact. So with that, by using our ViewModel class, we're able to provide a more consistent experience for the user when the activity is destroyed and re-created in response to configuration changes. In addition to that, we can simplify the code within our activity because we can move not only the data related to state of the activity class, but also the code that manages that state.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that configuration changes impact our activities, because when a device configuration change occurs, our activity is destroyed and re-created. So what that means is that any state that's stored in the activity is lost. But that can create a lot of confusion for the user. So our app is responsible to be sure that the activity provides a consistent user experience even when the activity instance is destroyed and re-created by the system. So to help with that, we have the ViewModel class. The ViewModel class allows us to store activity state in process, but store it separately from the activity itself. Now the way we use the ViewModel class is we create a custom class that extends ViewModel, and we add the properties and methods that we need in order to manage our activity's state. Now when working with ViewModel, we'll access our ViewModel through a ViewModelProvider, and ViewModelProvider manages ViewModel instances. So when we request a ViewModel from ViewModelProvider, it will look to see if an instance of that ViewModel already exists. If it doesn't exist, ViewModelProvider will take care of creating that new instance for us. If it does already exist, ViewModelProvider will simply return back a reference to that existing instance. The way we get to the ViewModelProvider is through the ViewModelProviders class. ViewModelProviders is responsible for managing the association between our activities and the corresponding ViewModelProvider. Leveraging ViewModel provides a number of benefits. As we've seen, the key thing it does, it separates our activity's state from the activity itself, and that allowed us to retain state across configuration changes, but it does even more than that, because once we move the state out of the activity and into the ViewModel, we can also take the code that manages that state out of the activity and into the ViewModel. So by leveraging the ViewModel class and the associated pattern, it actually reduces the amount of code that has to be placed directly within our activity. All right, so that's it for this module. In our next module, we'll take a look at some scenarios where the ViewModel class, although still useful, can't do the entire job by itself. So we'll see what we need to do in order to provide the user with a consistent experience in those scenarios.

Maintaining Activity State during System-initiated Shutdowns
Introduction
Welcome to our next module, Maintaining Activity State during System-initiated Shutdowns. This is part of the Pluralsight course, Android Apps with Kotlin: ViewModel and Lifecycle, and my name is Jim Wilson. Now, a better name for this module might have been something like, wow, why does my activity work most the time, but every once in a while, when the user leaves and comes back, things don't seem to work right. But I thought that title was too long, so I went with the one we have. But what the issue really comes down to is activity state is something we've got to manage carefully if we're going to provide our users with a consistent experience, and that's what we focus on in this module. So we're going to start out with a look at the need for durable activity state. In other words, the state of our activity needs to live longer than the activity itself, and although the ViewModel class that we talked about earlier in this course helps, it doesn't cover every situation. So what we'll do then is go on and see how we identify when we need to incorporate durable state into our activities. Then we'll finish up. We'll look at the features that Android provides that allow us to durably persist our activity state values.

Activity Destruction Effects on State
As we've talked about, a natural part of an activity's lifecycle is that activity being destroyed. And the user's expectations about the state of that activity when they return to it will vary depending on how the activity is destroyed. In some situations when the user returns back to the activity, they're going to expect the state to be maintained. In other words, they expect the activity to behave as if the user never left. But in other situations, there is no expectation of the state being maintained. And in these situations, from the user perspective, they were all done with that activity when they left it, so there's no reason to restore the state the next time they visit the activity. Now in our previous module, we looked at the situation of an activity being destroyed and then re-created due to a configuration change. And in that situation, the user did have an expectation of the state being maintained. Because in this situation, that activity was actually providing the user's foreground experience. From the user perspective, all they did was do something very simple, maybe rotate the device from one orientation to another. So from the user perspective, they never left that activity. The fact that Android destroys and re-creates that activity in that situation is a detail of the behavior of the system. For the user, we want to create the impression the activity was never destroyed, that it just kept running. But this situation of an activity being destroyed and re-created while it's providing the user with a foreground experience is kind of the exception. In most cases when an activity gets destroyed, it's because the user has either left that activity or is in the process of leaving that activity. And in most of these situations, the user doesn't really have an expectation of the state being maintained because, again, from the user perspective, they're done with that activity, for example, when a user leaves an activity by tapping the Back button. In that case, the user's exiting the activity so there isn't really an expectation of the activity maintaining state. Another situation is when a user explicitly kills an activity. For example, when they bring up the list of activities and they swipe one of them off the screen. That has an explicit kill, so the user has an expectation that the next time they go to that activity, it'll be starting fresh. And another situation where there's no expectation of state being maintained is when the activity calls finish on itself. In this case, the application is determining that this activity is done, so there's no need to maintain the state. But there is a situation that does arise when an activity is destroyed after the user leaves it, but that state needs to be maintained for when they return. And that's a case where when a user leaves an activity to go to a different activity either within the same application or a different application. In this situation, when the user returns, the user will expect the state to be maintained. In other words, the user expects the activity to act like it was always there waiting for them. So let's look at these scenarios where we need to maintain the state. Now in our previous module, we were looking at this issue of the configuration change. And in that scenario, we relied on our ViewModel class to maintain the state of the activity. Now remember that the instance of the ViewModel class is maintained in memory. And this works well for configuration changes because in this scenario, the activity is very quickly destroyed and re-created. But in situations where the system is reclaiming resources after a user has left an activity, we need a more durable solution than ViewModel can provide because the system is responsible to maintain that state no matter how long the user remains away from the activity. And to get a better understanding of this, in our next clip, we'll walk through some scenarios where this comes up.

Durable Activity State
As we mentioned, there are scenarios that come up where when a user leaves an activity, the system may clean up that activity for resource purposes while the user still has an expectation of that activity still being there for them to return to. Well let's walk through a few scenarios and see what that looks like visually. Let's say I go to my device's launcher screen and I tap on one of the icons. That then initiates a flow using what's known as a task in Android. And a task is simply a mechanism that Android uses to keep track of the flow from one activity to another. So now as a result of tapping on that icon, that launcher screen will an intent. The system will then make sure that the process for the application that corresponds to the activity that's tied to that intent is running. It'll then launch the activity and as part of that task, store the information about that activity. So the user then performs an action on that activity, but then sends another intent. Well that'll then launch the appropriate activity, and again, the system will keep track of the information for that activity. Now if at this point the system comes under resource pressure, the system may decide to clean up the activity that the user left. Now the activity is gone, but the information about that activity is not gone. So that way, when the user hits the Back button to leave the current activity, the system can then use the information that it has to relaunch that activity, so the user returns back to a consistent experience. Now this idea of cleaning up due to system pressure can impact much more than just an individual activity. Say, for example, that the user interacts with this initial activity that, again, sends the intent to launch our other activity. Again, the information for that activity is stored. And then as a result of the interaction with this activity, another intent is sent, and that intent results in another application being started. It'll launch an activity inside of that application, which again, this will, of course, store the information for. But now at this point, the user is interacting with an activity that's in a completely different process. If this system comes up under resource pressure, it needs to start cleaning things up. So it may start out by cleaning up one of the activities in our application. It may clean up the other activity in our application. And once all the activities are gone, it may even clean up the process. So any state information about those activities can't be within a process. But remember, the system still knows about those activities. So what that allows us to do is when the user hits the Back button to return to the previous activity they were visiting, the system can then use the information that it has on those activities to make sure the process is running, and then take the information about the activity to launch that activity. And if we've stored our state correctly, as the user returns back to that activity experience, they will have the impression that they never left, and this can continue as they wind back to the other activities inside of our application. And this scenario comes up whether the activities move from one to another as part of your application flow or the user simply leaves the activity in your application by doing something as simple as switching from your application's activity to the phone app's activity when a new phone call comes in. When that phone call completes, if the user then wants to return back to your application's activity, they'll, again, expect that activity to appear as if it's always been there waiting for them even if the system had to clean it up, and then recreate it. So the question is how do we store state in a way that can survive this process of being destroyed and re-created? In other words, how do we store our state in a way that's durable? Well to allow us to do that, the activity class has a method, onSaveInstanceState, and that's a method that we can override to save our activity's state in a durable way. OnSaveInstanceState receives a reference to a bundle, and we can write our state information into that bundle. And what the system will take care of doing for us, it will take that bundle and persist it in a durable fashion. So it's storing away that allows our activity to be fully destroyed, and even the process that our activity lives in to be fully destroyed, and the information will still remain. So that way, when our activity is re-created, our activity's onCreate method will receive a reference to a bundle that has the state values that we saved into a bundle in the onSaveInstanceState method. So we can use that bundle that we receive in onCreate to then restore the state. Now remember that the activity class's onCreate method can be called because the activity's being re-created or because it's the activity's initial creation. When the activity's being re-created, we receive a reference to the bundle. But on an activity's initial creation, that bundle will be null. So any time we want to interact with the bundle within our onCreate method, we want to check to make sure that bundle is not null. So to get a better understanding of all this, in our next clip, let's see if we need to add some durable state to our application's activity.

Identifying the Need for Durable State
Here we are with our app up and running, and what we want to do now is see if we need to any durable state to our application's activity. Now just a quick reminder, here are some of the features in our application. We can select a note from the note list here. We'll then head down to the Back button, return to our previous activity. Let's go and select one more note. We'll head back. Let's head up to the icon in the top left of our activity. Let's go ahead and open up the navigation drawer. Let's go down here to Recently Viewed Notes. We'll select that. We can see the two notes we just visited. Let's head back up to the icon. We'll open our navigation drawer. Let's go ahead and select Courses, and that shows our list of courses. So as we're walking through the features of our application, it seems like they all behave fine. But as we were talking about this issue of durable activity state, we mentioned the problem could come up when we move from one activity to another within our application or if we move to another application's activity. Well let's try that. Let's try switching to another application's activity. So we'll head down to our Minimize button. I'll go ahead and minimize our activity. Let's go up here, and open up mail. So it opens up mail. Let's go over here and show the list of available activities. There's our activity, so let's go ahead and return back to it. Things look fine, and our courses are still showing. So let's head back up to the icon for our navigation drawer. We'll open that, and we'll return back to our list of notes. So now as we walk through it, everything seems like it's fine. But the challenge in verifying that your app behaves correctly when the system cleans up your activity due to system resources is you never know when the system is going to clean up your activity due to system resources. So that can make it a very hard thing to test. Fortunately, Android gives us an option that allows us to force the cleanup of activities whenever we leave them, and that will allow us to test how our activities behave in that situation. So in order to do that, I'm going to head up to my status bar. We'll go ahead and pull that down. We'll go up here to the icon for our settings. I'll tap on that. Let's scroll down. Then down here towards the bottom, we'll select System. And one of the features that's available on the System screen is Developer options. But if you're looking at the screen as it's displayed right now, we don't see Developer options, and that's because it's an option that's hidden by default. In order to get to Developer options, we first have to enable them. So the way we do that, we'll go up here where it says About emulated device. We'll go ahead and select that. Then down here towards the bottom, we have Build number. And what I'm going to do is start clicking on Build number. You notice that it's telling me I'm almost there, and it says, you're now a developer. What happens is in order to enable Developer options, you have to tap on Build number seven times. If you tap on it seven times, that turns on Developer options. So now to get to Developer options, let's go down here and just click Back. And you'll notice we now have Developer options available. And this works on both an emulator and on physical devices. So let's head up to Developer options, and I'll select that. And when you get to Developer options, you'll find that there's a lot of options here, and the one we're looking for is all the way down near the bottom of the list. So I'm going to scroll down. And down here near the bottom of the list, we see this section labeled Apps. And one of the options we have here is Don't keep activities, and the description says, Destroy every activity as soon as the user leaves it. And what we want to do is go ahead and turn that On. And what that'll cause to have happen is every time we move from one activity to another, the activity we leave will be destroyed. So therefore, when we return back to that activity, the activity will need to be re-created, and that allows us to verify that our activity behaves correctly in this scenario where the system destroys it to reclaim resources, and then later re-creates it when the user returns to it. So let's head down to the square button here at the bottom of the screen. I'll tap on that. I'll go up to our application. Select that. So now our application is, again, visible, and things look like they're okay, but let's try something out now. Let's head up to the icon for our navigation drawer. I'll select that. Let's go ahead and choose Courses. So now our activity is displaying the list of courses, and as you may recall from our previous module, the user's current selection for what to display in this activity is something that we store inside of our ViewModel. But remember that our ViewModel will not be persisted if the activity is fully destroyed and has to be re-created. So let's see what happens when we switch away from our application. So we'll head down to the circle there, which is our Minimize button. I'll select that. Let's go ahead and open up Gmail. We'll head over to the square button to display the list of activities. Now we see our NoteKeeper app there in the background, and as we see it there, it's showing the list of courses. But the way the activity appears here when it's showing the list of activities is simply an image of the way the activity appeared when the user left it. Because you notice if I go up here to our application and I select our activity, notice that it's, again, showing the list of notes. So that shows us that storing the user's display selection in the ViewModel was not adequate for maintaining the state when the activity is fully destroyed and re-created. We need to incorporate saving durable state in our activity, and we'll see how to do that in our next clip.

Persisting State of a Simple Value
Here we are in Android Studio, and what we want to do now is begin the work of adding durable state to our activity. Now the activity we're looking at now is our ItemsActivity, and that's the activity that's responsible for showing the various lists that we want to display. And as we saw in the previous clip, even though we store the user's display selection in the ViewModel, that's not enough to create durable state. We need to store it in a way that our activity can retrieve the value when the activity's re-created. As we mentioned, we have the opportunity to do that by overriding our activity class's onSaveInstanceState method. So let's scroll down here in our class a little bit, and we'll go ahead and add that method. So now I've scrolled down in our class to just below our onCreate method. And I want to override onSaveInstanceState, so I'll press Ctrl+O. I'll scroll down this list. Then once I do that, I'll select onSaveInstanceState. You want to make sure you select the one that takes just one parameter, which is a Bundle. And that's the one I have selected, so I'll go ahead and hit Enter. That adds the code for onSaveInstanceState. And when you override onSaveInstanceState, you want to make sure that you don't delete the call to the base class implementation. The activity itself, along with the views within the activity, need to store information in that state as well, so be sure to call the base class implementation. Now you'll notice here that the Bundle that's passed into onSaveInstanceState is nullable. So before we interact with that bundle, we want to check to make sure it's not null. So once we verify that our bundle, which is our outState parameter, is not null, then we're free to interact with the bundle. And the Bundle class just has a series of put methods. We want to save the ID of the user's navigation drawer display selection, which is an integer. So we're going to just simply call outState. putInt. Each item we put into the bundle needs to be identified by a string name. For now, let's just put an empty string in there. And then as a second parameter, we provide the value that we want to store. And in this case what we want to store is our ViewModel's navDrawerDisplaySelection property. So then that takes care of writing the property, but we still need to give it a name. And the way we do that is by normally creating a string property that contains the name we want to use to identify the value. Now since the value we're storing here is contained within our ViewModel, let's go and add that name property to our ViewModel class. So we'll switch over to ItemsActivityViewModel. And here in our ItemsActivityViewModel class, let's create an assign once property, and we'll call it navDrawerDisplaySelectionName. And the name we use to identify this value in the bundle, we'll want to be sure that it won't collide with any other values stored in the bundle, because a number of different components can store information into the bundle. So what we normally use for the name is the fully qualified class name followed by the name of the value itself. So as we see here, the name we'll use is our fully qualified class name, com. jwhh. notekeeper. ItemsActivityViewModel followed by the actual value we're storing, which is navDrawerDisplaySelection. Now the name we're using here is not some magic value. The name doesn't have any special meaning. We're just following the convention that we use to avoid collision with any other values that might be stored in the bundle. All right, so now we have a name for the value we're storing. Let's head back over to our ItemsActivity. And then here, where we write out the value with an onSave instance state, we'll replace the empty string we have there with the name of our property. And with that, now whenever our activity's being destroyed and has the potential to be re-created, when the system calls onSaveInstanceState, it will now store our display selection inside the state bundle. So now in our next clip, we'll add the code to read that value back, and then verify that everything works.

Restoring State of a Simple Value
Here we are back in Android Studio, and what we want to do now is add the code to restore the state to our activity when the system re-creates it. Now in our previous clip, we overrode the onSaveInstanceState method, and we wrote out our state information to the Bundle that was passed in to onSaveInstanceState. Here in our onCreate method, we also receive a Bundle. As we mentioned, when the activity's initially created, that bundle is null because there's no state to restore. But if our activity has been destroyed and re-created, then the onCreate method receives a bundle that contains the values that we saved in onSaveInstanceState. So the first thing we'll want to do here in onCreate is check to see if savedInstanceState is nonnull. And if it is nonnull, we can retrieve the values that are stored in there. And just as we use put methods to put values into the bundle, we use get methods to get the values out. Now these methods will return back the value that's stored. So the value that was stored in the bundle, we want to put into our ViewModel's navDrawerDisplaySelection property. Then we'll call savedInstanceState. getInt, passing in the name of the value we want, which is our viewModel. navDrawerDisplaySelectionName. So now with that, in scenarios where the system destroys our activity knowing it has the potential be re-created, system will call onSaveInstanceState allowing us to save the values we want to be part of our durable state. And then when our activity is re-created, we read those values back out, and that should allow our activity to behave as if it was never destroyed in the first place. So let's go ahead and run our app and see how things look. So here we are now with our app up and running, and let's see what happens if we change the selection in our navigation drawer. So we'll open up the navigation drawer. We'll head down to our Courses. I'll select that. Then let's go ahead and minimize our application, so I'll head down to the circle here at the bottom. Select that. We'll open up Gmail. We'll bring up the list of activities, and we'll go up here and select our activity. You notice that this time our activity maintained the proper display list. So even though our activity was destroyed and re-created, because we used durable state, we could give the user the experience of returning back to the same list that they were viewing. So we're off to a great start in assuring that the user has a consistent experience even in scenarios where the activity is destroyed and re-created.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that activities are often destroyed and re-created, so that means that any state destroyed directly within the activity instance will be lost. So we need to manage our state in a way that outlives our activity instances. Now the ViewModel class helps because it handles that scenario of the activity being destroyed and re-created in response to a configuration change. But it doesn't handle the other scenarios where an activity gets destroyed and then re-created. To handle those scenarios, we need to implement durable persistence. In other words, we want to allow the system to store the state info for us so it can be maintained longer than the activity instance itself. And that's where the activity class's onSaveInstanceState method comes in. It passes us in a bundle, and we can write our state information into that bundle, and the system will take care of persisting that bundle for us. So that way when the system re-creates our activity and our onCreate method gets called, we're passed in a bundle that contains that saved state. So we can then restore our activity's state using the information in that bundle. Now remember, though, the activity only receives saved state if it's being re-created. On the initial creation, the bundle is null. So by checking whether that bundle is null or not allows us to determine whether it's an activity instance's initial creation or this is a re-creation. All right. That wraps up this module. In our next module, let's see what's involved in durably persisting more complex activity state.

Persisting Complex Activity State
Introduction
Welcome to our next module, Persisting Complex Activity State. This is part of the Pluralsight course, Android Apps with Kotlin: ViewModel and Lifecycle. My name is Jim Wilson. In this module, we're going to continue our look at durably persisting activity state where we're going to take a look at the additional challenges that come up when persisting complex state like objects or what are known as object graphs where you have a series of objects that reference other objects. So we'll start out. We'll look at how our application is doing in terms of managing its activity state and seeing if we have any gaps in terms of durably persisting our activity state. We'll then take a look at the relationship between the data model we use within our application and the state that we have to keep track of within our activities. We'll then see how we can effectively persist and then restore the state of an object graph. And we'll finish up with a look at how we effectively use the capabilities of the ViewModel class, along with durable activity state, to provide an effective state management solution for our activities.

We're Still Losing Some of Our Activity State
Here we are with our app up and running just as it was at the end of our previous module. And what we want to do now is determine if there's any other activity state that we'll need to durably persist. Now in our previous module, we added the code to durably persist the user's display selection. What that allowed us to do is minimize our application, switch to another app like Gmail, bring up the list of activities, and then, again, select our activity. And because we had durably persisted the user display selection that's in our activity's ViewModel, the activity maintains the proper display list. So even though the activity was destroyed and then re-created, because we used durable state, we could give the user the experience returning back to the same list that they were viewing previously. But remember the work we did earlier in the course when we were moving our activity state values into the ViewModel. The user's display selection wasn't the only thing we put into the ViewModel. We also put the list of recently viewed notes into the ViewModel as well. You know we should probably check to make sure that that's working correctly. So let's head up to the icon to open our navigation drawer. We'll open the drawer. We'll head down here to Notes, and we'll select that. So I'll go here and select a note. That opens up the activity to display the note. I'll head down to the Back button. We'll head back. Let's go ahead and select one more note. We'll head back. So that means that we should now have at least two notes in our recently viewed list. Let's see if that's the case. So let me head over here to the edge of the screen, and I'll drag out the navigation drawer. I'll head up to Recently Viewed Notes, and let's go ahead and select that. And you notice that our list of recently viewed notes is empty. That's happening because we're not storing the list in durable state. Remember that earlier in the course, we configured our emulator to destroy an activity any time we leave it. So each time we display the activity that shows the individual note, our item's activity is being destroyed. So when we return back to our item's activity, it has to be re-created. But when it's re-created, our list of recently viewed notes is an empty list. So in our next clip, let's see how to properly persist and restore complex state like that of our recently viewed notes list.

Activity State and Data Model Cooperation
To understand how to durably persist our activity's state, we also need to understand our application's data model because the two of them work together. Now if you've watched other courses in the Android Apps with Kotlin series, you know that we're using a class called DataManager to manage the data for our application. Now the DataManager is implemented using an in-memory data model, but that's just for simplicity. The way it's implemented allows us to interact with it as if it's backed by a persistent data store. So we rely on the DataManager to look up our notes and the courses that we interact with in the application. Now in the work we did in a previous module, we took our activity's state, and we created a ViewModel to store that state. As part of our ViewModel, we store the users most recent drawer display selection, and that value's stored simply as an integer. And then our ViewModel also stores the list of recently viewed notes, and that's an array list. But now each entry in the array list holds a reference to a particular note, and each note holds a reference to a course. So the first entry references the most recent note. Second entry references the second-most recent note, which also references a course. Again, our third entry references a note. But because we're dealing with references, each note doesn't necessarily point to its own course. Sometimes multiple notes will point to the same course because one course can have multiple notes associated with it. And this idea of referencing the notes just kind of carries on. So our list of recently viewed notes isn't just a list of simple values. It's actually an object model. So now our ViewModel manages the state when our activity is up and running. And as we saw in the previous module, by using ViewModel, we can maintain our state when our activity is destroyed and re-created due to configuration changes. But in other situations where our activity is destroyed and it's going to be re-created, we need to durably store the state, and that's where onSaveInstanceState comes in. Now we've already done the work to take our navDrawerDisplaySelection and store that using onSaveInstanceState. So now we need to do the same sort of thing with the list of recently viewed notes. But we can't simply store the array list because that array list contains references that, by themselves, aren't actually useful if the activity is destroyed and re-created because those notes won't be referenceable by the same addresses when the activity gets re-created. So what we really need to do is not just store the simple array list. We need some way to reproduce this full object graph. Now there are techniques that would allow us to persist this full object graph into the bundle provided by onSaveInstanceState, but that's not really the sort of thing we want to do. There's no real reason to persist the full object model. It's time-consuming and can take up a fair amount of storage, and there's a limit to how much data can be stored in the bundle that provided the onSaveInstanceState. But the reality is we don't need to store the full object model. Remember that all the information for the notes and the courses comes from the DataManager. So rather than store the full note and course object information, all we really need to store is the information that we'll need to rebuild the object graph by looking up the appropriate information from the DataManager. So what we can do is walk through the recently viewed notes and put together the information that we'll need to find those notes again later. And all we really need to do that is an array of the note ID values, and then those note ID values can then be persisted into the onSaveInstanceState bundle. And then when our activity's re-created, we'll get those ID values back. We could then use those ID values to look up the notes in our DataManager and fully rebuild the object graph of our recently viewed notes. So in our next clip, let's head back over to Android Studio, and let's see how we implement this.

Moving the Details to the ViewModel
Here we are back in Android Studio, and what we'll want to do now is begin the process of durably saving and restoring the state of our list of recently viewed notes. Now we're currently looking at our ItemsActivity, and on screen we have the two methods within the activity that are related to saving and restoring state. We have our onSaveInstanceState method, and that's the method that's called when it's time to save our state. And we currently have the code in there to persist the user's display selection from within the ViewModel. Then we head up to the onCreate method. When our activity is re-created, we receive back the state we saved. So inside of onCreate, we have the code that restores the value of the user's most recent display selection. So it's in these same two places we're going to need to save and restore the information related to the list of recently viewed notes. But if we think about it, the state that we're actually saving and restoring is being managed within our ViewModel. So the code to handle the details of saving and restoring the state should probably be within the ViewModel class, not here in our ItemsActivity. So let's go ahead and make that change. So down here in our onSaveInstanceState method, I'm going to remove the line that writes the value out for our navDrawerDisplaySelection. What I'll do is call a method we'll create on the ViewModel class called saveState, passing in the outState bundle. Now, of course, that method doesn't yet exist, but I can get Android Studio to create it for me. I'll hit Alt+Enter. I'll choose Create member function. So that places that function inside of our ItemsActivityViewModel class. I'll accept a parameter name of outState, and I'll accept a parameter type of Bundle. Then I'll go ahead and paste in the line to save the user's display selection. Now since we took that code from the activity class, it's accessing the members of ViewModel with a viewModel reference. Well now that this code is inside of the ViewModel class, we won't need those references, so I'll go ahead and remove those. So now all the details of durably saving the state within our ViewModel class are encapsulated here within the ViewModel class. So let's head back over to our activity class and do the same sort of thing to restore the state. So we're back here in the onCreate method of our ItemsActivity class. And the line here where we get the value back from the state, I'm going to go ahead and cut that out. And then we'll call a method we'll create on the ViewModel class called restoreState, passing in the saveInstanceState. So now to create that method, I'll hit Alt+Enter, I'll choose Create member function, accept the parameter name and type, then I'll paste in a line that restores the state. And just as with saving the state, we don't need the viewModel reference anymore. So now I have the code to save and restore our ViewModel state here in our ItemsActivityViewModel class, and that'll create much cleaner code for us. Because if we head back over to the ItemsActivity class and we check out our ItemsActivity class's onSaveInstanceState function, this function's now nice and clean. It calls its base class implementation, and then it delegates the work of saving the state of our ViewModel to the ViewModel itself. And the same sort of thing in our onCreate function. The details of restoring the state, rather than cluttering up the onCreate function, are, again, delegated to our ViewModel class. So now with that all in place, we're ready to start handling the details of saving and restoring the state related to the list of recently viewed notes. And we'll handle those details in our next clip.

Persisting State of an Object Graph
Here we are in Android Studio, and what we want to do now is complete the process of saving and restoring the state of our list of recently viewed notes. Now remember that our list of recently viewed notes is an object graph. So rather than store the entire object graph, we're simply going to store the list of IDs we need to rebuild that object graph using our data store, and all the code to save and restore the state will be here in our ItemsActivityViewModel class. Now remember that when we're storing and restoring state, we need to name the values that we're storing. So here in our ViewModel class, we'll declare a property to name these values, and we'll name it recentlyViewedNoteIdsName, and the value of the name will be the fully qualified class name followed by recentlyViewedNoteIds. So now with that, we have a name we can use to save and restore the value that we're sure won't collide with any other values that are in the bundle. So now that we have the name for our value, let's head down to our saveState function. So now we're down here in our saveState function, and since we're storing the IDs for the notes, we'll need to first get those IDs. So let's declare a local variable named noteIds. Our DataManager class has a utility function that makes it easy for us to get the IDs of a list of notes. So let's go ahead and call that function. So we're calling the DataManager class's noteIdsAsIntArray function, and as its name implies, if you give it a list of notes, it'll give you back an int array containing the IDs of those notes. So we'll pass in our recentlyViewedNotes property. So now our noteIds variable will hold a reference to an integer array that has the IDs of each note in our recently viewed notes list. So we can go ahead and write that int array out to the outState. So we'll call outState. putIntArray, we'll pass in the property that names the value, and then we'll pass in our noteIds int array. So that takes care of saving the IDs of those notes, and now we just need to add the code to restore them. So we have our restoreState function here, and inside the restoreState function, let's declare a variable called noteIds that'll hold the IDs as we read them back. Then we'll use our savedInstanceState parameter, and we'll call its getIntArray function. And then we'll pass in the name of our value. So now when our activity's restored and restoreState gets called, we'll now have the IDs of all the notes that were in our recently viewed notes list. So now we want to go ahead and get those notes. So let's declare a local variable called noteList, and we'll call a DataManager function called loadNotes. So now as its name implies, loadNotes is a function that loads notes from our data manager, but there's some interesting details about that function. So let's head over to our DataManager class, and we'll take a look at that function. So here we are in the DataManager class, and we have our loadNotes function. Notice that loadNotes accepts a parameter named noteIds of type Int, but that parameter is marked with a keyword, vararg, and that means that this is a function that accepts a variable number of arguments. So now the way the function works that if you call it passing in no IDs at all, it returns back the entire list of notes. But if you specify one or more ID values, it'll create a list containing just the notes that correspond to those ID values, and then pass that back. And that's the feature that we want to use. So let's see how we do that from with inside of our ViewModel. So we'll head back over to our ItemsActivityViewModel class. So we're back here in ItemsActivityViewModel, and as you recall, we got back the IDs that we want to load and stored them in this variable, noteIds. So let's try passing in noteIds to our loadNotes function. And you'll notice that Android Studio is underlining that in red, and the reason is that loadNotes is a function that accepts a variable number of arguments and expects each of those arguments to be comma separated. Well the problem is that all the arguments that we want to pass are all inside of one variable, noteIds, and that variable is an array. So what we need is a way to convert this array into a format that is acceptable to a vararg parameter, and the way we do that is by putting an asterisk in front of the array. And that asterisk is what's known as a spread operator, and what it does is expand the array. So it makes that array compatible with a variable length argument list. So by calling loadNotes in this way, our local variable, noteList, will now have the list of notes that correspond to those Ids. So once we have that list, we can use our recentlyViewedNotes property. And we can use its addAll function to add the notes that are contained in noteList. So now with that, our recentlyViewedNotes property will contain the same list of notes that it contained prior to the activity being destroyed. So now we're just about done doing the work to add durable state to our ItemsActivityViewModel, but there's just a little bit more we need to do. And we'll see what that is in our next clip.

Effectively Using ViewModel and Durable State Together
Here we are back in Android Studio, and what we'll want to do now is finish the process of enabling our ViewModel to durably persist its state. So now we're looking now at the saveState and restoreState functions of our ItemsActivityViewModel class. And our saveState function is a relatively inexpensive function to run. It simply persists an integer value to keep track of the user's most recent display selection. It then looks at the recently viewed list of notes that it has in memory, extracts to our ID values from that in memory object graph, and then persists those values as well. So that's something that's really inexpensive to do. But now if we look at our restoreState function, that starts out pretty inexpensive as well. First thing we do is read back the user's display selection from the savedInstanceState bundle. But then to get back that list of recently viewed notes, we have to do a few things. First, we get back the integer array from the savedInstanceState bundle, which is an inexpensive operation. But then we have to go out to the data manager, access the persistence store, look up all those notes, and then rebuild the object graph that represents those notes, and our corresponding courses, and then we add that to our recentlyViewedNotes property. So being able to do that is really useful in terms of persisting our state when the ViewModel has to be re-created, but we certainly don't want to do that any more often than we need to. So to not call restoreState any more often than we actually need to, we need to add just a little bit more code. So to figure out what we need to do, let's head over to our ItemsActivity class. So now we're here in our ItemsActivity class, and we're looking at our onCreate function. And within the onCreate function, we have this statement here that checks to see if the savedInstanceState is not equal to null. And if it's not equal to null, we call our ViewModel's restoreState function. Remember that savedInstanceState is nonnull any time an activity is being re-created. And remember there are two general scenarios where an activity gets destroyed and then re-created. One scenario is the activity had been destroyed because the system wanted to reclaim its resources and is now being re-created because the user's returning back to that activity. And in that scenario, the ViewModel would have been destroyed as well, so we, of course, need to restore its state. But remember the other scenario where an activity is destroyed and then re-created is when a configuration change occurs. And remember that when an activity is destroyed and re-created due to a configuration change, the ViewModel is not destroyed. So in that scenario, there's no reason to call restoreState again because the ViewModel's still around. So we need to add just a little bit of code to make sure we only call restoreState on ViewModel if the ViewModel was destroyed along with the activity. So to deal with that, let's head back to over to our ItemsActivityViewModel class. So now up here near the top of our ItemsActivityViewModel class, we're going to add a property named isNewlyCreated, and I'm going to give it an initial value of true. So now any time a brand-new instance of ItemsActivityViewModel is created, the isNewlyCreated property will have the value of true. So now let's head back over to our ItemsActivity class and see what we can do with this property. So we're back over here in the onCreate method of our ItemsActivity class. And down here where we checked the condition for savedInstanceState being not equal to null, we're also going to check to see if our ViewModel is newly created. So now we only call the restoreState function on our ViewModel if the ViewModel was both newly created and savedInstanceState is not equal to null. So, of course, when do we set isNewlyCreated to false? We're going to do that right after our call to the restoreState function. Now notice that we're setting isNewlyCreated to false outside the if statement. So let's see how all this works. So the very first time our activity is created, both the activity and the ViewModel will be newly created. So viewModel. isNewlyCreated will be true, but our savedInstanceState test will be false because there is no savedInstanceState when an activity is initially created. But now even though we didn't call restoreState, we can go ahead and set isNewlyCreated to false because this is now the ViewModel that's representing our activity's state. So anything we do within the activity, it will happen inside this ViewModel. So then let's say the user interacts with the activity for a while, and then rotates the device from portrait to landscape. Well in that scenario, that would destroy the activity, but our ViewModel would stick around. So when the activity is re-created, we would have a savedInstanceState so it would be nonnull, but our ViewModel's isNewlyCreated would be false. So there's no reason to call restoreState because we still have the state. But then let's say the user navigates away from the activity, and the system reclaims the resources for this activity. So in that scenario, both the activity and the ViewModel is destroyed. So when the user then returns back to the activity, the activity is re-created passing in a savedInstanceState, so that's nonnull, and a new instance of the ViewModel has to be created, so isNewlyCreated is now true. So in this scenario, we then go ahead and call restoreState to restore any of the state that we've saved. So now we have durable state for our ViewModel, but we only go through the process of restoring that state when we need to. So in our next clip, let's go ahead and run our code, and let's see how it all looks.

Verifying State Management Behavior
Here we are now with our code up and running, and what we want to do now is verify that our ViewModel's state is being properly managed. First thing we'll need to do is select some notes so we can start adding some notes to our recently viewed notes list. So I'll select a note. Head down to the Back button. Return back to our item's activity. Select another note. Return back to our item's activity. Let's go ahead and open up our navigation drawer. We'll head up to Recently Viewed Notes, and I'll select that. So just as we should, I've got two notes in our recently viewed notes list. So now let's verify how our state's being handled. So let's head back to Android Studio. So we're here in Android Studio, and we're looking at the restoreState function of our ItemsActivityViewModel class. So I'm just going to go ahead and add a breakpoint to the first line of this function. So now any time restoreState gets called, Android Studio will break at this line. So let's head back to our emulator, and we'll see how everything behaves. So now back here at our emulator, we still have our list of recently viewed notes displayed, and let's see how things behave during a configuration change. Remember that during a configuration change, even though activity's destroyed and then re-created, the ViewModel is not destroyed. So in that case, we don't expect restoreState to be called. So we'll go ahead and rotate the emulator. And when we rotate the emulator, we still have our list of recently viewed notes displayed so that's good. Let's head back over to the control bar for the emulator, we'll go ahead and rotate the emulator back, and we still have our list. So now let's see how everything behaves when both the activity and ViewModel are destroyed. And remember that we've set our emulator so that any time we leave an activity, the system will reclaim that activity and fully destroy it. So let me go ahead and minimize our application. Let me go up here and select Gmail. So now our activity should be fully destroyed, as well as the ViewModel. So let's bring up the list of available applications. Let's go up here and select our application. And you'll notice that in the background, Android Studio hit our breakpoint. Let's go ahead and switch back to Android Studio. So that shows us in the case where both the activity and the ViewModel were destroyed, when the activity is re-created, we're restoring the state of our ViewModel as well, and that's exactly what we want to have happen. So let me go ahead and release this, and we'll return back to our emulator. And back here in our emulator, we again show our list of recently viewed notes. So everything's working exactly as we want it to. We leverage ViewModel to maintain our state across configuration changes, and then we durably persist the state of our ViewModel to handle the scenarios where the activity is fully destroyed, along with its ViewModel, and then re-created.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that when it comes to saving our activity's complex state, we want to avoid writing that state directly into the bundle that's passed to onSaveInstanceState. Writing complex state like that can be time-consuming, and there are size limits on the amount of data that can be written into that bundle. So instead what we want to do is cooperate with our application's data store. So rather than write all that complex state directly, instead, we'll save the information that will allow us to reconstruct that state using our app's data store. Now it's also important to remember that when we're creating our activity state management solution, we want to use a two-part approach. We want to leverage ViewModel because ViewModel allows us to easily separate our activity's state from the activity class itself, and the ViewModel maintains that state when the activity's destroyed and re-created due to configuration changes. But remember that ViewModel doesn't cover every scenario, so we'll also want to be sure to include durably persisting our activity's state because that assures that our activity's state is maintained even in scenarios where the activity is destroyed and re-created due to the system reclaiming resources. All right. That wraps up this module. In our next module, we'll take a look at the important role that lifecycle events play when we're working with components that need to cooperate with the lifecycle of our activities.

Subscribing to Lifecycle Events
Introduction
Welcome to our next module, Subscribing to Lifecycle Events. This is part of the Pluralsight course, Android Apps with Kotlin: ViewModel and Lifecycle. My name is Jim Wilson. Now, of course, the lifecycle of an activity is critical to the activity itself. But it can also have significant effects on components that need to work with that activity, and that's the issue we're going to begin working at in this module. We'll start out. We'll look at what's involved in cooperating with an activity's lifecycle. We'll then take a look at a new feature we're going to add to our app in this module and the next module that we call our get-together feature. From there, we'll take a look at some of the lifecycle-related types that are provided by the Android architecture components. We'll then take a look at lifecycle events. And then we'll finish up by seeing how we can cooperate with those events by creating something known as a lifecycle observer.

Cooperating with Activity Lifecycle
As we've talked about, activities have a lifecycle, and our code needs to cooperate with that lifecycle as we build our applications. But most applications don't stand alone. They need to leverage other components in order to provide the features and capabilities that are necessary. And some of those components also need to cooperate with our activity's lifecycle. And this is because in some cases, components need to start, or connect, to a local service. For example, location providers will need to do this sort of thing. Other components need to connect to some remote back end. It might do some kind of remote messaging system or other system that connects up to some cloud-based service. And with these services each having a distinctive start phase, they also need to be stopped. Because if we don't stop them, many services will start to leak resources. So it's important that the component knows when we need it, and it knows when we're done with it. Now the way we generally address this need is by working directly with the activity lifecycle methods. Now just as a reminder, this course assumes that you have a solid understanding of the activity lifecycle and the associated methods. If you need a refresher on those things, I, again, encourage you to check out the course, Android Apps with Kotlin: Build Your First App. Now just as a quick reminder, here are some of the most common lifecycle methods that we use. We have the onCreate method. That's called when the activity is first created. So for components that need to be active during the entire lifetime of the activity, we can go ahead and start, or connect, to those components here in onCreate. Then we have the onStart method. That's called when our activity becomes visible. And this is one of the most common places where we start, or connect, to components. Because oftentimes a component may be expensive to have running, so we don't want it running unless our activity is actually visible. Then we have the onResume method, and that's called when our activity becomes a foreground activity. In other words, it's the activity with focus. And that's where we connect to components or services that we just want to have access to while our activity is in the foreground. And then from there, we consider our activity to be up and running. So as our activity is running, we would interact with any components that we've started or connected to. But again, to not leak resources, we need to make sure we clean things up. So for any component we've started, or connected to, in onResume, we'll generally clean that up in the onPause method because onPause indicates that we're no longer in the foreground. For components that we've started, or connected to, in the onStart method, we'll clean up those guys in the onStop method. OnStop tells us that we're no longer visible. And then finally, for anything we've started, or connected to, in onCreate, we clean those up in the onDestroy method, which tells us that our activity is being destroyed. So now with all this in mind, in our next clip, let's take a look at a feature we want to add to our application that'll require us to use components that need to cooperate with our activity's lifecycle.

Our App's Get-together Feature
In this module, and the next module, we'll be adding a new feature to our application that will help us understand how to work with components that need to cooperate with our activity's lifecycle. And the feature we add will be tied to the note activity of our application. Remember that this is the activity that allows the user to create, view, and modify a note regarding a particular course. And we have a new menu option on the activity, and this ties to our application's get-together feature. And the get-together feature allows us to invite people to get together to talk about a particular note that we've created for our course. Now we're assuming that there's a back-end service that has a predefined list of people that I like to invite, so what we'll need to do is have the ability to get our current location, and then send information about our location and a note to that back-end service. So what that means is we're going to need some kind of location component, in other words, a component that will tell us our current location, and we'll also need some kind of messaging component that will allow us to send messages to that back-end service so we can send the information about our location and the note to that service. So that we can focus our attention on the details of dealing with our activity's lifecycle, rather than using real location and messaging components, I've created a couple of components that simulate those behaviors, but allow us to focus on lifecycle issues without dealing with all the details of location and messaging. So one of the components we'll be using in our application is what I call the PseudoLocationManager, and the PseudoLocationManager simulates location updates. Now we need to start the location service when our activity is started, and we want to stop it when our activity is stopped. And what we need to do is provide the location manager a callback method, and that callback method will receive regular location updates. The other component we'll be using is what we call the PseudoMessagingManager, and this simulates messaging behavior. So it simulates the fact that we're going to connect to some back-end messaging service. So we need to connect to the service when our activity's onStart method is called, and we'll want to disconnect from it when the activity's onStop is called. And then using our messaging service, we can then send location and note information to the back end. So now to get us started, in our next clip, we'll head over to Android Studio, and we'll start tying in the PseudoLocationManager into our activity's lifecycle.

Managing Location with Activity Functions
Here we are in Android Studio, and what we want to do now is begin the process of tying in our PseudoLocationManager into our note activity. Now I currently have onscreen here our PseudoLocationManager class. And again, this class simulates the activity of a real location manager except in this case, rather than using a real location service, our PseudoLocationManager has a predefined set of latitude and longitude pairs, and it simply sends update using the values in that set. So now if we look at our PseudoLocationManager's primary constructor, it's first parameter is a context, so that'll be our note activity's this reference. And then its second parameter is a callback, and that callback will be a lambda expression that receives latitude and longitude values. Now in order to use our PseudoLocationManager, we have to start it. So we do that by calling its start function, and then when we're done with it, we want to stop it, and we do that by calling its stop function. So it's usually just pretty straightforward. So let's head over to our NoteActivity class and start hooking this up. So now we're here at our NoteActivity class, and the first thing we'll want to do is declare a property that will hold a reference to our PseudoLocationManager. So let's call that property, locManager. We'll create a new instance of our PseudoLocationManager. The first parameter's a context, so we'll pass in our this reference. So now our second parameter is a lambda expression that will receive the location callbacks. Now in Kotlin, when you want to pass in a lambda expression as a parameter, if that lambda expression is the last parameter, rather than putting the lambda expression within the parenthesis, we can actually do it after the parenthesis, which is a little bit more readable. So let's go ahead and do that here. Now remember that our lambda expression will receive two parameters, which are our latitude and longitude values. So that starts out our lambda expression receiving those two parameter values. And what we'll do inside of here is simply write out a message to logcat. So that takes care of creating an instance of our PseudoLocationManager and providing the callback lambda expression. But now in order to start receiving the actual updates from the location manager, we'll need to start it. So let's scroll down here in our class a little bit. So now I've scrolled down to just below our onCreate method, and we'll want to start our location manager when our activity's onStart method is called, so we'll need to override onStart. So I'll hit Ctrl+O. We'll scroll down a bit. Once we've scrolled down, we'll locate onStart. We'll go ahead and select that. We'll hit Enter. So that gives us our onStart function, and we'll want to go ahead and add our code to this function. Now in the case of onCreate, onStart, and onResume, we generally add our code after the call to the base class method. So here after the call to the base class's onStart, we'll go ahead and call locManager. start. So with that, we now have the code in place to start receiving location callbacks from our PseudoLocationManager. So let me go ahead and start our app running, and let's see how things behave. So now our app's up and running. And in the background, I have Android Studio with the Logcat window open so that way we can see any logcat messages generated by our app or its components. So let me go ahead and select one of our notes. That opens up our note activity. If we look in the background, we can see where our location manager started, and we can see that we're getting callback messages. And those callback messages are giving us location information from our PseudoLocationManager. So it looks like we're starting up our location manager just fine. Now let me head down to our Back button, and I'll return back to our previous activity. Now as you can see, we've left our note activity, but there's one interesting thing happening in the background. Notice that we're still getting location messages. So that means that we didn't properly shut down our PseudoLocationManager, and that's a really important thing to keep in mind. In this case, we're getting location updates that we don't really need, which isn't that big a deal, but this is just the sort of thing that can lead to your application crashing unexpectedly because these are location updates coming back to an activity that doesn't actually exist anymore, and that can be a problem. So in our next clip, let's go and add the code to properly stop our location manager.

Fixing the Location Resource Leak
Here we are back in Android Studio, and what we'll want to do now is add the code to properly stop our PseudoLocationManager. Now we're currently looking at our NoteActivity class, and stopping our PseudoLocationManager is a pretty straightforward job. What we need to do is override our NoteActivity class's onStart method. So to do that, I'll press Ctrl+O. We'll scroll down. We'll find the onStop method. We'll select that. We'll hit Enter. So now we have our onStop function, and I want to add the code to stop our location manager. Now, in general, when we add code to methods like onPause, onStop, and onDestroy, we generally do that before the call to the base class method just to be sure that all of our cleanup is done before any cleanup done by the base class itself. So we'll go ahead and add a blank line before the call to the base class, and then we'll call locManager. stop. So now, our location manager should stop whenever the user leaves the note activity. So let's go ahead and run our code and verify that that's the case. So now we, again, have our app up and running, and we have Android Studio open in the background with the Logcat window open. So let's go ahead and select a note. And when we do that, we can see our location manager's started, and we can see that we have our location updates coming in as well. So let me head down to the Back button. Let's head back to the previous activity. And you notice now when we do that, we see a message telling us that our location manager is stopped, and just as we expect, we no longer receive location callbacks. So now we're properly starting and stopping our PseudoLocationManager. So the things there are working well. But let's head back to the code for our note activity, and take a look at something. So now we're back here in Android Studio, and we're looking at our NoteActivity class. Now I've collapsed the code for the onCreate method of NoteActivity, and I've done that just so we can see all the code related to our PseudoLocationManager at one time here onscreen. So now when we use our PseudoLocationManager, we, of course, have to declare the PseudoLocationManager, and we have to provide the callback to receive those location updates. Now at this point, that callback's pretty simple, but it doesn't really do anything yet. So we'll need to start adding more code and likely additional properties related to managing that location information. In addition, we add the override activity's onStart method so we could start a location manager in the same way we had to override onStop, and that's just for the location manager. Remember we're also going to have a messaging component, so we'll have to add code to the onStart and onStop methods for that component as well and add more code to our note activity related to interacting with the messaging component. And remember as we talked about earlier in the course, we want to avoid bloating up our activity classes with a lot of code that's not directly related to presenting the user interface. So what we'd like to do is clean this up a little bit. We'd like to be able to take all this code related to working with the PseudoLocationManager and the lifecycle interactions and move those outside the note activity. And, of course, we'll want to do the same thing with other lifecycle-related components like the messaging manager that we'll add a bit later. So in our next clip, let's see how we can do that.

Improving Lifecycle Handling with Events
Now as we've seen, components often need to cooperate with our activity's lifecycle. But we'd like to avoid bloating up our activity class with a lot of extra code related to these components. So what we'd like to be able to do is separate the work of interacting with these components from the activity itself. But because these components are dependent on the activity lifecycle, we need some way to be notified when each of the lifecycle events occur. Well fortunately, the Android architecture components give us some help with this. They give us some types that allow us to abstract away lifecycle handling from the activity itself. What we have now is an interface called LifecycleOwner, and this is an interface that's implemented by types that have a lifecycle. One of the most common types that we work with that implements this interface is the activity classes. So we can think of an activity as a lifecycle owner. From that lifecycle owner, we can get its lifecycle. Lifecycle's a class that represents a particular object's lifecycle. And then in order to get information about the lifecycle, we have the interface, LifecycleObserver. And we can implement this interface to indicate that we'd like to be notified of lifecycle events from a particular lifecycle. So what these types allow us to do is to abstract our thinking a little bit. Historically, in order to cooperate with an activity's lifecycle, we thought very much in terms of the specific methods within that activity. So we had to override those methods and add any code we needed to those methods. Well now with these types, we don't have to think about those methods. We can think much more about the activity. And since the activity implements the LifecycleOwner interface, it will expose a property called lifecycle. Through that property, we can get a reference to a lifecycle object, and that lifecycle object will fire events. So if we want to do work when onCreate's called, we can handle the lifecycle's ON_CREATE event. Same sort of thing with ON_START and ON_RESUME. Now remember when we overrode these methods within the activity, we would generally call the base class implementation before we added our code. Well these events work the same way. For example, the ON_CREATE event fires after the activity's onCreate function actually finishes doing its work. Same sort of thing with ON_START and ON_RESUME. Now for the other events, like ON_PAUSE, ON_STOP, and ON_DESTROY, remember that we would normally do most of our work before calling the base class method. Well these events fire the same way. So the ON_PAUSE event fires before the activity's onPause code actually runs. Again, same thing with ON_STOP and ON_DESTROY. So to use these events, we need to create an observer, and there are a few steps to doing that. The first thing we need to do is mark our class as an observer of lifecycle events. We do that by implementing the interface, LifecycleObserver. The thing that's kind of interesting about that interface is it doesn't have any methods, has no methods at all. Simply indicates that we're interested in receiving events related to the lifecycle. The way we actually handle those events is by adding functions to our class and marking those functions as event handling functions. We do that by using the OnLifecycleEvent annotation, and that annotation accepts a constant to indicate which event you want to handle. So we'll use constants from the Lifecycle. Event class. So, for example, if you have a function that wants to handle the ON_START event, we'll mark that function with the OnLifecycleEvent annotation passing in Lifecycle. Event. ON_START. Now that takes care of implementing our observer. But in order to receive the events, we have to register as an observer. And the way we do that is by getting a reference to the lifecycle we're interested in and calling its addObserver function passing in a reference to our observer type. So now to get a better handle on all this, in our next clip, we'll start converting our application to use a lifecycle observer rather than overriding the activity's lifecycle functions.

Creating a Lifecycle Observer
Here we are back in Android Studio, and what we want to do now is create a new class that, by cooperating with the lifecycle events of our known activity, can handle the details of working with our PseudoLocationManager. So in order to create that new class, we'll head over to our package name over here in the Project window, and I'll right-click. I'll choose New. I'll head over to Kotlin File/Class. Then I'll choose that. Now this new class is going to handle all the details of implementing the get-together feature that we're going to be using in our note activity. So let's call the class, NoteGetTogetherHelper. Now we want this to a class not a file. So we'll head down to the Kind field, we'll go down here and choose Class, and then we'll go ahead and create the class. So now we have our NoteGetTogetherHelper class. Now as you may recall, when we created our PseudoLocationManager instance, we needed a context. So let's go ahead and declare a context property here in the primary constructor of our NoteGetTogetherHelper. We'll go ahead and add an import for the context by hitting Alt+Enter. So now remember that we want this class to act as a lifecycle observer, so we'll need to implement our LifecycleObserver interface. We'll need to add that import as well, so we'll hit Alt+Enter. So now before we carry on, let's just do a couple things here. I'm going to go ahead and add some blank lines to the body of my class, and then I'm also going to go ahead and collapse the list of imports at the top of the file. And by doing that, we get the imports out of the way, and it doesn't keep moving our code down every time we import another class. All right, so with that stuff done, we can start doing the work inside of our NoteGetTogetherHelper class. And one of the first things we'll want to do, since we're going to be writing out to logcat, let's go ahead and declare a tag property and set its value to our class's simpleName. Now we'll also want to add properties for the current latitude and current longitude. Because remember that our PseudoLocationManager is going to keep calling back into a callback function of ours giving us the most recent values for our latitude and longitude. So we'll want to be able to save those, so let's go ahead and declare those two properties. All right, so now that we have those properties in place, I want to go ahead and start declaring a property for our PseudoLocationManager. So we'll declare a locManager property. We'll create a new instance of our PseudoLocationManager passing in the context. We'll create our lambda expression and have it receive two parameters, lat and lon. And then here inside of our lambda expression, let's go ahead and assign the lat and lon parameters to our currentLat and currentLon properties. So that'll allow us to store the most recent values directly here in the instance of our NoteGetTogetherHelper class. So now one last thing we'll want to do inside of our lambda is go ahead and write out the lat and lon information to logcat. So now, each time the location manager calls back into our lambda expression, we'll store the latitude and longitude, and write the information out to our logcat. So now in our next clip, let's start tying our NoteGetTogetherHelper class into our activity's lifecycle events.

Observing Lifecycle Events
Here we are back in Android Studio, and what we want to do now is start tying in our NoteGetTogetherHelper class to the lifecycle events of our note activity. So now the first bit of work we'll need to do is to start our PseudoLocationManager when our activity's onStart method is called. So to do that, let's declare a function named startHandler. And then here inside of our startHandler function, we want to go ahead and call the PseudoLocationManager's start method. So that takes care of providing the code to start the PseudoLocationManager, but the question is how do we get this startHandler function to get called? And that's where annotations come in. The name of this method doesn't matter at all. In order to cooperate with the lifecycle events, it has to be marked with the proper annotation, and the annotation we want to use is @OnLifecycleEvent. And then the annotation needs a constant to identify which event we want to handle. We want to handle the ON_START event, so we're going to pass in Lifecycle. Event. ON_START. So now, startHandler is marked as being able the event, ON_START. So that'll give us a chance to start our location manager. Now, of course, we want to do this same sort of thing to stop the location manager. So we'll add another function, and we'll call this one, stopHandler. Here inside of stopHandler, we want to call our location manager's stop function. And we, again, want to associate this function with a lifecycle event, but in this case, we'll handle the ON_STOP event. So now with that, we have functions in place that can handle these lifecycle events. The thing we need to do though is to somehow associate them with a particular lifecycle. So what we'll do, let's head up here to our class's primary constructor, and let's add another property. We'll call that property, lifecycle of type Lifecycle. So that'll give us a reference to a lifecycle. So now what we need to do is add the current instance of our NoteGetTogetherHelper as an observer of that lifecycle. And one of the easiest ways we can do that is with an initializer. So we'll say init. And then within the body of our initializer, we'll use our lifecycle property, and then we'll call its addObserver function passing in this. So now with that code in place, whenever we create an instance of our NoteGetTogetherHelper class, we'll take their lifecycle reference that we receive, and we'll automatically add ourselves as an observer of that lifecycle. All right, so now in our next clip, let's go ahead and make the changes in our NoteActivity class to take advantage of our NoteGetTogetherHelper.

Connecting the Observer to the Lifecycle
Here we are back in Android Studio, and what we want to do now is modify our NoteActivity class to take advantage of our NoteGetTogetherHelper. Now remember that our NoteGetTogetherHelper class now takes care of all the work related to our PseudoLocationManager. So here in our NoteActivity class where we declare our locManager property and assign it to an instance of the PseudoLocationManager, well we can just get rid of all that code. So let me go ahead and remove all that. And then what we'll do instead is declare a new property that we'll call noteGetTogetherHelper. We'll assign it to a new instance of our NoteGetTogetherHelper class. Remember the first parameter to noteGetTogetherHelper is a context, so I'll pass in our activity's this reference. And remember the second parameter is a reference to a lifecycle. Well remember that activities are lifecycle owners, so they have a property named lifecycle. So we'll pass in our NoteActivity class's lifecycle property. So that passes in a reference to the instance of the Lifecycle class that represents the current activity's lifecycle. Now because noteGetTogetherHelper takes care of subscribing to the lifecycle events, the code here in NoteActivity that we have inside of onStart and onStop is no longer necessary. So let me head down there, and I'll highlight both of those functions. Once I do that, I'll just go ahead and delete them. And believe it or not, we're all set. And the only thing a class has to do now to take advantage of our NoteGetTogetherHelper class is declare an instance of the class passing in its lifecycle property. Because if we go over and take a look at our NoteGetTogetherHelper class, here in our NoteGetTogetherHelper class, our initializer takes care of calling the lifecycle's addObserver function and adding the current noteGetTogetherHelper instance as an observer, which then allows that instance to receive lifecycle events. And because our startHandler function and stopHandler functions are both marked with the @OnLifecycleEvent annotation, they're both automatically called any time the appropriate event fires. Okay, with all that in mind, let's go ahead and run our code, and let's verify that everything works as we expect. Here we are now with our app up and running. We, again, have Android Studio in the background with the Logcat window visible. So I'm going to go ahead and select a note. Notice when I do that, we see the message that our location manager has started, and we can see that we're getting the location callbacks. Let me head down to the Back button. We'll go ahead and head back to the previous activity. And notice that when we do that, we see the message, Location manager stopped. So that shows us that our NoteGetTogetherHelper class is working correctly. It's actually receiving the lifecycle events related to our NoteActivity class. And because it receives those events, it's able to do the appropriate lifecycle management on our PseudoLocationManager. And a really cool thing about all that is the only thing our NoteActivity class had to do to use our GetTogetherHelper class was simply declare an instance of it. The NoteGetTogetherHelper class took care of all the details including subscribing to and handling the lifecycle events. So the new feature that we're adding to our application is off to a fantastic start.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that the activity lifecycle sometimes effects the components that the activity uses. And in those cases, those components need to cooperate with the activity lifecycle. The thing is trying to do that cooperation work directly in the activity's lifecycle methods can cause the activity's code to get quite bloated. So we'd like to be able to separate that code out from the activity, and that's where the lifecycle-related types come in. They allow us to separate lifecycle-related work from the activity itself. As part of the lifecycle-related types, we have the LifecycleOwner interface, and that's an interface that's implemented by types that have a lifecycle. One of the most common lifecycle owners we work with are activities. And then LifecycleOwner allows us to abstract out the lifecycle from the activity itself, and that's where the Lifecycle class comes in. It's a class that represents an object's lifecycle. And that lifecycle can fire lifecycle-related events. And these lifecycle-related events correspond to our activity's lifecycle-related callback functions. So it allows us to respond to those events without having to put the code directly into our activity class. So now in order to receive those events, we need to create a lifecycle observer. To do that, we first have to implement the interface, LifecycleObserver. And that indicates that we support receiving lifecycle events. The thing is the LifecycleObserver interface doesn't actually have any methods on it. So in order to receive the lifecycle events, we have to somehow indicate which functions correspond to each event. We do that by marking those functions with the annotation, @OnLifecycleEvent. And @OnLifecycleEvent accepts a parameter to indicate which event a particular function corresponds to. And we indicate those events by using the Lifecycle. Event. ON_xxxx constants, which will then cause those functions to run when the corresponding event fires. All right. That wraps up this module. In our next module, we'll see how we can work even more effectively with our activity lifecycle using something known as lifecycle state.

Determining Lifecycle State
Introduction
Welcome to our next module, Determining Lifecycle State. This is part of the Pluralsight course, Android Apps with Kotlin: ViewModel and Lifecycle. My name is Jim Wilson. In this module, we'll continue our discussion of activity lifecycle and see how we can create components to better cooperate with that lifecycle. So we'll start out with a closer look at lifecycle and understand how lifecycle events are only part of the story. We'll then see some of the challenges that come up with dealing with our lifecycle, especially when it comes to asynchronous operations. We'll then take a look at lifecycle state and understand it important role in working with our activity lifecycle. And then we'll finish up. We'll look at the relationship between lifecycle state and lifecycle events.

Events Are Only Part of the Story
As we saw in our previous module, lifecycle events are a valuable tool because these events indicate transitions in the lifecycle of our activities. And these events are a great way to trigger work that's dependent on the stage of life of the activity. But it's important that we understand that a lifecycle is more than simply transitions. An activity, or any other lifecycle owner, is always in some stage of life, and there are some cases where the transitions aren't quite enough information. There are times where we need to be able to actually ask a lifecycle what stage of a life it's currently in. And this is especially important in the case of asynchronous work. Because we may kick off some long running background task that depends on the activity being in a particular stage of life. But then while that background task is running, the stage of life of the activity may change, and we need to handle that scenario appropriately. The key point to understand here is that the lifecycle transitions, although very, very important, don't give us the complete picture. Because we think about what a lifecycle of an activity is like. The activity instance gets initialized, and then the activity is created. We become aware of that creation because the ON_CREATE event fires. And the same way if we're overriding the methods inside the activity, we become aware of that transition by overriding the onCreate method. But then once that event completes, the activity is still created, but we don't really get any access to the lifecycle of the activity until the next transition occurs. So as the activity becomes visible, the ON_START event fires. And inside of ON_START is a place where we'll often connect to, or start up, components that our activity needs. Well if the startup work for our component is asynchronous, odds are that work will complete after we finish processing the ON_START event. So we just have to make the assumption if we initiated that work in ON_START, the activity is still at least in the started state when that background work completed. Then as the activity becomes the foreground activity, then our ON_RESUME event fires telling us that our activity is transitioning into the foreground. And then when that work completes, our activity is now in the foreground, and it will run for some period of time in the foreground. And during all this time, there are no lifecycle transitions going on so there are no lifecycle events firing. And we don't get any more events until the activity moves out of the foreground, and that's when our ON_PAUSE event fires telling us that we're leaving the foreground. When our handling of that event completes and then the activity is no longer visible, then the ON_STOP event occurs telling us that we're transitioning from being visible to not visible. Now in many cases, once that activity is no longer visible, it will still exist. It's just not visible. So again, the activity is spending a fair amount of time at some point in its lifecycle with no transitions going on, so of course, there are no events firing. We won't see any more events until the activity is about to be destroyed, and then our ON_DESTROY event fires. So the key thing I want us to see here is that these events are really important and really helpful for identifying transitions, but they don't give us the complete story about the activity's lifecycle. So to help us to get a better picture of the issues that come up focusing just on the transitions, in our next clip, we'll start tying in the messaging feature into our application.

Adding the Messaging Manager
Here we are in Android Studio, and what we'll want to do now is begin the work of connecting in our messaging manager to our app. Now just as a reminder, in our previous module, we started adding a new feature to our app called the get-together feature, and that allowed us to invite people to get together with us at our current location to talk about a note regarding the course. Now that feature was added to our note activity, so we're currently looking at our NoteActivity class. And to help us with that, we created a new class called NoteGetTogetherHelper. And one of the key things we did with this class is we passed in a reference to our activity's lifecycle. And by having that lifecycle reference, the NoteGetTogetherHelper class can cooperate with our note activity's lifecycle without us having to add any lifecycle methods to the NoteActivity class itself. So let's take a look at our NoteGetTogetherHelper class. So now, looking here at our NoteGetTogetherHelper class, we have our initializer. And in our initializer, we automatically add ourselves as an observer to the past lifecycle. So that allows us to observe the lifecycle events. So we added two functions, startHandler and stopHandler, with the appropriate annotations so that startHandler is called when our NoteActivity class's ON_START event fires and stopHandler is called when our NoteActivity class's ON_STOP event fires. Now currently inside those functions, we start and stop our location manager. Now I did add one additional line of code to each of these functions since our previous module. In both functions, I call Log. d to simply write out to logcat when the functions are called. So now what we need to do is start connecting in our messaging manager into our NoteGetTogetherHelper class. And before we do that, let's take a look at our class, PseudoMessagingManager. So this is our PseudoMessagingManager class, and the purpose of this class is to simulate a cloud-based messaging system that allows us to send information that will then notify other users of the invitation to get together to talk about our note. So now our PseudoMessagingManager has one function, which is the connect function. Its only parameter is a reference to a lambda expression, and that lambda expression will be called back when a connection occurs. So we initiate a connection by calling our PseudoMessagingManager's connect function, we pass it in a lambda expression, and then our lambda expression will be called back with a reference to a PseudoMessagingConnection. Now because connecting to a cloud-based service can often take a few seconds, the way our connect function is implemented is that lambda expression gets called back after about 5 seconds. So it simulates the connection occurring asynchronously. But now once the connection occurs, we'll get that reference to a PseudoMessagingConnection. So let's scroll down and take a look at that class. And here we have our PseudoMessagingConnection class, and it has just two functions. It has a send function where we can pass it in a string, and it simulates sending it to the messaging system by simply writing out the message to logcat. Then we have a disconnect function, and this is a function that we call to disconnect from the messaging service. Again, all our implementation here does is write out to logcat. All right, so let's head over to NoteGetTogetherHelper, and let's start adding the code to use our PseudoMessagingManager. So now over here in NoteGetTogetherHelper, in order to use the PseudoMessagingManager, we'll need a property. Let's create a property, msgManager. Then we'll create an instance of PseudoMessagingManager passing in the context. So that gives us our PseudoMessagingManager, but remember that we're going to need a connection to actually interact with a messaging manager, and we'll get that connection as part of the connection process. So we'll declare another property, msgConnection, but this will be a mutable property. Now since we won't get the connection until later, we actually want to allow this property to be nullable, and we, in fact, want to give it an initial value of null. Now the main thing we'll want to do with our messaging connection is send messages to the messaging system, and we'll want to send information about a particular note. So let's add a function to our NoteGetTogetherHelper named sendMessage. SendMessage will accept a note in for a reference so we'll add a parameter named note of type, NoteInfo. And then here inside the body of the function, let's go ahead and add a variable named getTogetherMessage. And the message will be a simple string containing the values that we want to send each separated by a vertical bar. So the first thing we want to send is the current latitude and current longitude, so we'll use the currentLat and currentLon properties that we added in the previous module. Then we'll add the note title and course title passed in by our note parameter. So with that, our getTogetherMessage variable will be a string containing our current latitude, current longitude, the note title, and the title of the course that corresponds to the note. So we'll want to send that using our message connection, but remember our message connection may be null so we use?., and then we'll simply call its send function passing in getTogetherMessage. So now with that, we have properties for our messaging manager, our messaging connection, and we have a function that allows us to send information to the messaging system about a particular note. So in our next clip, we'll add the code to initiate the connection to our messaging manager and then disconnect from it.

Lifecycle-driven Asynchronous Operations
Here we are back in Android Studio, and what we want to do now is add the code to connect and disconnect our messaging system. So now we're looking at our NoteGetTogetherHelper class and onscreen here, we have the startHandler function. Remember that this function is automatically called when the ON_START event fires for our NoteActivity class. And inside this function we already did the work of starting our location manager. So now to work with our messaging system, what we'll need to do is call our messaging manager's connect function. Remember that our connect function expects a lambda expression that can receive a reference to our messaging connection. So the connection parameter of our lambda expression will be a reference to our PseudoMessagingConnection. So let's go and assign that connection to our msgConnection property. And here in our lambda expression, let's go and write out some text to logcat that indicates that our connection callback has occurred. So now when our connection is established, it'll write that information out to logcat, and we'll have a reference to the connection in our msgConnection property. So now let's scroll down a bit so we can see our stopHandler code. So now here at our stopHandler function, we want to disconnect our connection. So we'll use our msgConnection property. And remember that our connection may be null, so we the?. to call our disconnect function. So that takes care of disconnecting from the messaging system here in our stopHandler. Let me just scroll up a bit so we can see all the code related to our messaging system. So now here in our NoteGetTogetherHelper class, in our startHandler, we establish our connection to the connection system, and our stopHandler, we disconnect from the messaging system, and we have this function up here, sendMessage that allows us to send messages over the messaging system. What we need to do now is add the code to NoteActivity to take care of sending a message when the user selects the get_together option. So now we're over here in the NoteActivity class, and we're in the onOptionsItemSelected function. Remember that this function gets called whenever the user selects one of the option items within an activity. And down here, we have the code block for when the user selects the get_together option. So all we need to do here is call our noteGetTogetherHelper's sendMessage function and pass in the note that's currently being displayed, which we can access from our DataManager. So now it would seem that our get-together feature is complete. Our noteGetTogetherHelper takes care of connecting and disconnecting from the messaging system automatically by subscribing to the lifecycle events, and we send a message to that system whenever the user selects the get_together option. So in our next clip, let's go ahead and run this code, and let's see if things behave as we expect.

We're Leaking Connections
Here we are with our app up and running, and we'll want to do now is verify that the messaging behavior of our get_together feature behaves as expected. Now as you can see, we have Android Studio open in the background, and we have our Logcat window visible. So we should be able to see all the related Logcat messages. So the first thing I'll do is go ahead and select a note. That opens up our note activity, and you can see in the background that we're initiating our connection. Then a short time later, we see another message that shows us that the connection is established and our connection callback was called. So that means we should now have a valid connection to the messaging system. So I can head up here to our get-together feature. I'll select that. And you can see we now get the message showing that we called the send function of our messaging connection simulating sending a message to our back end. You can see our message includes our current location, which is the latitude and longitude, along with information about the note. So that all appears to be working well. So let's see how things behave when we leave the activity. So I'll head down to the Back button. Once we get down here to the Back button, we'll go ahead and head back to the previous activity. And when we do that, we can see that our stopHandler got called, and we disconnected from the messaging system. So in our first little walkthrough here, it seems like everything's working just as we'd like it to. But let's try something else. First, let me clear the Logcat window. Now that our logcat cleared, let's see what happens if the user selects a note, which will take them into the note activity, but then decides that they didn't want to be in the note activity and quickly heads back here to our current activity. So I'm going to quickly select a note, head back, and when I do that, we see something interesting in logcat. Notice that we initiated the connection, just as we did last time, but now when we look at the messages towards the bottom, notice that our stopHandler was called, but then after that, the connection to the messaging system was established, and our connection callback was called. So what that tells us is that the connection to our messaging system was actually established after our note activity had already stopped. So that means that we just leaked a connection to the messaging system. In other words, we now hold a connection to the messaging system that will not be disconnected until our application process is actually destroyed. And over the life of an application, that can be pretty serious because the user keeps doing this sort of thing even if they only do it once in a while. Over time, we're going to leak more and more connections, which can ultimately create problems in our application. So in our next clip, let's see what we can do to avoid this kind of problem.

Lifecycle State
Now as we've talked about, lifecycle is about much more than transitions because an activity is always at some point in its lifecycle. So to help us identify that, lifecycle provides a concept of state, and the state indicates the current point in the lifecycle. Now the thing is, is that state and events work together. Basically, whenever the events fire, what we're actually doing is transitioning from one lifecycle state to another. The key is we can access the state at any time because the Lifecycle class has a currentState property. So we can check for a very specific state, or we can check to see if we've reached at least some state. So let's see how all this works together. So now when an activity is initially constructed, it's in the INITIALIZED state. But very quickly after that, the activity's going to fire its ON_CREATE event, and that indicates that we've transitioned from the INITIALIZED state to the CREATED state. So that tells us that our activity is now created. Remember that when an activity becomes visible, that fires the ON_START event, and that indicates the transition from CREATED to STARTED. So if our current state is STARTED, we know our activity is visible. Then when our activity transitions into the foreground, that's when our ON_RESUME event fires, and the state transitions from STARTED to RESUMED. So then as long as our activity's in the foreground, the current state is going to be RESUMED. So we can reliably use the current state to identify if our activity's currently in the foreground. But then once the user moves to a different activity, our activity would no longer be in the foreground. So at that point, our ON_PAUSE event would fire, and that tells us that we've transitioned from the RESUMED state to the STARTED state. When our activity is no longer visible, then our ON_STOP event fires, and that tells us that we've transitioned from the STARTED state to the CREATED state. But now as long as your activity's in the background, but still exists, if we were to check the current state, the state would be CREATED telling us that the activity has not been destroyed. Now if the activity was to move back into the foreground, we would transition back through the STARTED and RESUMED states. Then if our activity moved again into the background, we would transition through the STARTED, and then the CREATED states. And then finally, when the activity gets cleaned up, the ON_DESTROY event would fire, and our state would transition to DESTROYED. But now let's focus in on the actual state values. Because as we said, at any point we can check the current state. And sometimes we do want to check for a specific state. For example, if we want to know if we're in the foreground, we can check for that current state of RESUMED. But commonly, we just want to know if we made it to a certain point in the lifecycle. In other words, have we made it at least to some point? So to do that, we can use the isAtLeast function. So if we call isAtLeast, and we pass in STARTED, if the current state is either STARTED or RESUMED, then the isAtLeast function would return true. So that tells us that our activity's lifecycle has progressed at least to the point of being started. And the same way we can ask isAtLeast created, and in that case, if the current state is CREATED, STARTED, or RESUMED, isAtLeast would return true, and then we could do an isAtLeast INITIALIZED, which will return true if the current state is INITIALIZED, CREATED, STARTED, or RESUMED. In other words, is it anything other than DESTROYED? So in our next clip, let's take a look and see how we can use theses state values to fix the bug that we currently have in our application.

Verifying State in Asynchronous Operations
Here we are back in Android Studio, and what we'll want to do now is take advantage of a lifecycle state to correct a problem we were having in our application where we were leaking connections to our messaging system. Now we currently have our NoteGetTogetherHelper class onscreen. And remember that the code that initiates the connection to the messaging system happens here in the function, startHandler. And remember that this function is run when our note activity's lifecycle fires the ON_START event. Now the first thing we should probably do is try to understand how we ended up with a connection leak in the first place. Well remember here in our startHandler, we call the messaging manager's connect function. Remember that function initiates an asynchronous connection process. In other words, the connect function returns right away, but it starts running some work in the background that simulates the process of reaching out to a cloud server doing whatever work is necessary to initiate that connection. Then when that work is all done, it then calls our lambda expression. The lambda expression receives a reference to the connection, which we then assign to our msgConnection property. And then later when the user leaves the activity, our stopHandler function runs. And inside this function, we have the code to make sure that our message connection's nonnull. And if it's nonnull, then it disconnects. And that's the behavior we want to have happen. But we ran into trouble when the user launched the note activity and then quickly left. Well the reason that was happening is that up here in our startHandler when we launched that process of connecting to the messaging manager. Remember that's an asynchronous process. So if the user quickly left the activity, the code for our stopHandler would then run. When we get down here to disconnect the connection, we haven't received a connection yet. So our message connection is null, so there's no disconnect to do at this point. Then, of course, the user experience takes them back to our main activity. But then at some point later after the user has already left the note activity, the code for the lambda expression that we pass to the connect function now runs. So at this point, we then receive the connection. Problem is, is that the activity has already been destroyed. So there'll never be any code that runs to actually do the disconnect. So in order to fix this problem, we need to check the current state of the lifecycle at the time we receive the connection. So what we'll do is just before we assign the connection to our msgConnection property, let's add an if statement that checks the lifecycle's current state. Now as we check the current state, question is what do we want to compare it to? Well since we launched the code to do the connect doing the ON_START process, our first thought might want to be, do we check to see if the current state is STARTED? But the thing is it doesn't need to be STARTED. If it's either STARTED or RESUMED, either one of those is fine. So why don't we use the isAtLeast function, and we'll pass in the value, Lifecycle. State. STARTED. So as long as the lifecycle current state is at least STARTED, we want to go ahead and assign that connection to our msgConnection property. But then what if it's not at least STARTED? Well if it's not at least STARTED, then we don't want to keep the connection. All we want to do is immediately disconnect the connection we received. So now with this code in place, as long as our lifecycle's current state is STARTED or RESUMED, we'll keep the connection just as we did previously, but in any other case, we'll go ahead and disconnect the connection. And now before we finish up here, let's just do one last thing. Up here where we write to logcat, let's go ahead and write out the current state of the lifecycle. So now with that in place, we can see in logcat, what the current state of the lifecycle is at the time that our callback gets called. So in our next clip, let's go ahead and run our code, and let's see what happens.

The Leak Is Fixed
Here we are now with our app up and running, and what we'll want to do now is verify that we're managing the connection to our messaging system appropriately for the lifecycle of our note activity. So now the first thing we'll do is we'll go ahead and select a note. When we do that, we can see that our location manager's started, and we've initiated the connection to the messaging system. And then a short time after that, we get the callback that tells us that the connection is established. You can see our callback shows that the lifecycle state of the note activity is currently RESUMED, and that, of course, it's correct because it's the foreground activity. So now if everything's working correctly, I should be able to head up here to the option for our get-together feature. I'll go ahead and select that. And you can see we then display the appropriate information for sending that message to our messaging server. So it looks like the feature itself is still working well. So let's head down to our Back button. We'll return to the previous activity. And when we do that, we can see that our connection to the messaging system disconnected just as it should. So now we want to see if things behave appropriately when the user enters our note activity and then quickly leaves it. So the first thing I'll do is go ahead and clear our logcat so we can see a little bit better. So now that logcat's cleared out, I'll go ahead and select a note, then I'll quickly return. And now if we look here at logcat, we can see that we initiated the connection, just as we did previously, but then look further down here. Notice that our stopHandler ran before we received the connection. But then as the connection was established, our callback took a look at the lifecycle state, and the lifecycle state was DESTROYED. So since it wasn't at least STARTED, we didn't want to keep the connection, so instead, we went ahead and disconnected it. So by simply checking the state, we were able to avoid that connection leak that we had previously. So that shows us by taking advantage of a lifecycle, using the lifecycle states that we talked about in this module along with the events that we've talked about in a previous module, we're able to create classes that work reliably and effectively with the lifecycle of our activities without having to load up our activities with a bunch of extra code.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that lifecycle state is an important part of cooperating with our activity's lifecycle because it allows us to determine at what point in the lifecycle the activity is currently at. Now we can access the lifecycle state at any time by simply using the currentState property of our Lifecycle reference. And although we can check the current state for a specific value, in many cases what we want to do is determine if we're at, or beyond, a specific point in the lifecycle, and we do that by using the isAtLeast function. But remember, when working with our lifecycle, it's not an either/or between state and events because the two are tied closely together. Because remember that events are fired as part of a state transition, and they make it easy for us to initiate work based on a state transition. So as we're doing a lifecycle-related work, we want to be sure to use the best of both, lifecycle events and lifecycle state. All right. That wraps up this module, and it wraps up this course. But I encourage you to keep building your skills. Because this course is part of a large series on Android and Kotlin. Now the best way to find us is simply go to Pluralsight's search feature and just start typing in Android Apps with Kotlin, and you'll find there's a lot of great courses in this series that are really useful in helping you develop your skills at building Android apps with Kotlin. Thanks for joining me in this course, and I hope we'll keep running into each other as you continue to build your skills in creating Android apps with Kotlin.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Advanced
Rating
4.8 stars with 10 raters(10)
My rating
null stars

Duration
2h 24m
Released
21 Dec 2018
Share course

