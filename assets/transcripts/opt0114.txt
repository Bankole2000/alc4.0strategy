Introduction to Git
by Geoffrey Grosenbach

Learn the ins and outs of Git quickly.

Git was built for the modern developer's workflow. Easy branching, full capability even when offline, and fast operation make other source code management systems feel underpowered compared with git! This course will teach you how to install and use Git. You'll learn how to create a repository, use branches, and work with remote repositories.

Course author
Author: Geoffrey Grosenbach	
Geoffrey Grosenbach
Geoffrey is VP of Open Source at Pluralsight. He founded PeepCode and has created numerous courses on Ruby, JavaScript and Shell. He commits code at <a...

Course info
Level
Beginner
Rating
3.4 stars with 705 raters(705)
My rating
null stars

Duration
1h 0m
Released
25 Oct 2007
Share course

Introduction to Git: Part 1
Introduction
It's PeepCode talking about the Git source code control system. Git was developed about two years ago by Linus Torvalds for managing the Linux kernel. It's been getting a lot of press recently. Current maintainer is Junio Hamano, who is the technical editor for this screencast, so thanks to Junio. Why would you want to use Git? Well, first it can be used online or offline. Most of this screencast was put together while I was on an airplane over the ocean and I was able to do everything that I needed to branching, merging, reverting, committing, all those kinds of things are just natural with Git because you don't have to be connected to a central server. You can do most of what you need to even if you are offline, not even connected to any network at all. It's also distributed. Once you do get connected back to a network, you can push and pull your changes to any other repository that has Git installed. You can push it back to a centralized server. Some people think that this is a bad idea. Well, you could use Git just the way that you use Subversion or any other centralized system, it's just that Git can also work in a distributed fashion and you don't have to be connected to a centralized server in order to be able to do what you want to do. Another reason you may want to use Git is branching. Yes, in other source code control systems, you can do branching but it involves several steps and it's a little bit awkward. With Git, it's super easy, takes less than a second to create a branch, to switch between branches, and it all happens right within your current working directory. In many other source code control systems that I've used, I've rarely done branching just because it's a little bit awkward. But in Git, I make branches all the time. If I want to try out a new feature, if I want to try out a new plug-in, upgrade, library that I'm using, I can try that all out, I can test that in a separate branch and then when I'm done, I can merge that back into my master branch and keep going. One more reason out of many that you may want to use Git is that it's very clean. You only have a single. git directory in the root of your project. Other systems like Subversion may have a. svn directory in every subdirectory of your project. If you need to move things around or rename things or delete a directory, it can get kind of messy. But in Git, you don't have any of those kinds of problems. You can easily rename things, move them around, delete a directory and refresh it, any of those kinds of things are very easy to do in Git and makes it very clean and simple to use.

Install
What's up? You're watching this screencast. I assume you probably want to learn about Git and don't have it. If you already do, you can skip ahead to the next section. If you have Mac ports or if you are on Debian or have other package management systems, often, it will be called git-core, and you can just install that package and it will give you at least a version of Git an all the manpages and other kinds of documentation that you need. Even if you do intend to build Git from source later on, which we'll do in a minute, you may still benefit from installing the package because then, you'll get the other dependencies and other kinds of things that you need in order to make Git work smoothly. However, as I mentioned it may be an older version or it may miss certain components that you may need. For me, I was using Git together with the git-svn command to work with some older Subversion repositories, and the package that I originally installed didn't have Git SVN. So if you're going to do something like that, you may need to install from source eventually. If not, just install the package and that will get you up and going with the bare basics of what you need for working with Git. Whether or not you did that, it's a good idea to install from source. That will get you the blazingly newest version of Git. You can go to the main Git website, download the tar ball. Untar that and change into the directory. Two files in there, the standard readme and an install file will tell you the basics of installation, but it's pretty simple. I like to use a prefix to keep all my software in the user local directory, so make, with prefix of user local and all, we'll build all of, at least the code parts of Git. Personally, I had a hard time with all the dependencies of building the manpages, but there are other ways to get that. At any rate, sudo with the same make and install will actually copy that over to system, and you'll be ready to go with Git. If everything worked properly, you should be able to see that Git is in your path, and you should be able to issue little commands for example. Look at the version of Git and see what version you have installed. You could also look at the manpages, and this might be a good time to mention that Git is actually a bunch of individual scripts, most of which are written in Perl. And when you are going to look up some documentation, you want to use the full version of the command with a dash in it. If I look right here at my user local bin directory, I can see I have git-diff and git-pull and git-push and all these kinds of things. Once we actually use Git, we'll leave out that initial dash and we'll just say git push or git pull, but on disk and in the manpages, it's going to have all those dashes, so keep that in mind. If you want to use Git immediately, you could get Git. You could go to the Git website and actually get the source itself from the main Git repository. This line right here will give you what you need for that, just space that in, git clone and then the URL. It will give you a local copy checked out and you can use that. You can build from source straight out of the master branch here if you want to. There are also branches for the manpages in the HTML documentation. We'll learn later on how to switch between branches, and you might want to use this as an example.

Configure
So to begin with, it's a good idea to introduce ourselves to Git. We're going to set our name and email address so that it can be stored in commit messages. Where you do that is git config --global, and then user. name and enter in your name. Probably in quotes if it's two words. Also can do the same thing, but user. email, and that will then be our email address that will be saved when we do a commit back to a repository. I can look at those a couple of ways. I can just say git config list and there it is, or git works just out of text files, and the main global one is just in my home directory called. gitconfig, and you can see right there, I've got my name and my email address. Now this file won't actually be stored in any repository. If I have a desktop and a laptop computer, you may want to copy this file or set these same settings on each so that you have the same information on both. There are a few other configuration details. I'm just going to set two of those right here. One is an alias. So you may not even know what checkout means in the context of Git right now, but I'm going to set this up right now and I'm going to use that throughout. This means that if I wanted to do a checkout, I can just do get co foo and I can use that as a shortcut for actually executing that command. So do whatever makes sense to you. Another good one, especially if you're going to work with Ruby code or even C or other code that is not white space-sensitive, you can set apply white space to nowarn, and Git will then basically ignore differences in whitespace that otherwise may be odd. I personally like to set up a few aliases in my shell, and you may see me use these throughout this screencast, just because they're so ingrained in my brain, very fast to type, just a couple of letters and I'll put my C shell and bash aliases file on the downloads so you can use those if you want to locally on your machine. Do whatever is easy for you to remember and makes sense and helps you work smoothly.

Basic Commands
So let's get started with an actual project. I have a project here that is in process. We can see right here, it has a couple of different files. I'm trying to write a time travel library. I also have some specifications and a log as well. So to begin with, this is just a blank directory not set up for any source code control system, and I can just say git init, sitting right in that directory. And magically, that will create a. git directory, and I'm ready to work with this directory with this project with Git, it's that easy. Now if I want to look inside that. git directory, most of the contents I don't need to really worry about, but you got some hooks that can be executed after different events, and we have the actual database of objects that Git maintains, and there's some configuration files which we'll look at later. One thing that's good to start out with though is ignoring the files that we don't want to have tracked. For example, I have this log file right here, maybe this is dynamically generated by my application and I could ignore this with a file called. gitignore at the root of my project. Then I can type some patterns in here, for example *. log. Any file in any subdirectory ending in. log will be ignored or a path like db/schema. rb or db/schema. sql, any kind of patterns like this will be then applied when I'm adding and tracking content. These kinds of files will be ignored. Now you can actually have a. gitignore file in any directory, any subdirectory that you want, but I like to just keep one at the root of the directory, it's a lot simpler and keeps that all consolidated into one place. You can see some other comments and examples in the. git info exclude file. For example, you can use a # mark at the beginning of a line to ignore that, to comment that out or just to write a comment, and then you can use different kinds of shell escapes or shell patterns to identify which kinds of files should be ignored. Now it's good to know the difference between these two files. The. gitignore stays with the project. So it's going to be checked in. Anyone who clones it will get the. gitignore. the git info exclude is your personal copy. It's not going to be checked in, and you're going to use that if there are some exceptional files that you only want to be excluded from the repository. But let's add some files. Git add. That will take the working directory and all subdirectories, add every single file, every single bit of content to the next check in. Now anything that was listed in the. git exclude will not be included, but everything else will be. This is great for a first time check in just to get everything and in fact, if we look at git status, we can see that here are a bunch of files that have been queued up. Those are in the index and those will be committed the next time that we commit, which in fact is right now. Let's commit. We can use the -m argument, similar to Subversion, just gives a little message for this commit and there it is. Now we have some files that have been actually committed to our local repository right here. And we can even look at what has been added, what's being tracked with a nice command here, Git ls-files. And these are the files that are currently stored in the Git repository. However though, you may see one there, the third line down, lib/. DS_store. That is a Mac OSX-specific file, binary file, and I don't want to be tracking that every time I check things in and out. So I want to make sure I add that to my ignore file. We don't want that in the repository, and I'm also going to do a git rm to remove that file. Now I can look at my status and I see we've had some activity. What might be confusing though is we have here change but not updated the. gitignore. Please git add that file. Well, didn't we already do that? In fact, this illustrates a big part of how Git works. Other source code control system work with files, so we might have these three in the white circle that are tracked, and the rest are not tracked. But Git works with content, so even though things are stored in files, it basically looks at maybe this class Dog and then it sees that we've currently added a line here for attr_accessor of tail, and when we say add, it takes a snapshot of that, adds that to the index and then that's what actually gets committed. So Git is all about content. We can kind of fake this other behavior of kind of a file-based thing by just saying Git commit -a, and that's going to just say any changes that are in this whole project right now, add those and do a commit. And then right here I can write a little message for myself describing what I did in this commit. You can see down there the. gitignore and the. DS_store. Files are both part of that commit. So we have files, we have content and let's do one more change and commit to show one more aspect of how you can commit. So I'm just going to pull up my text editor right here and pull the file and make a little bit of a change to a file. I'm going to say spec file, so I'll add a little spec here. Should travel from one year to another. And then I'm going to go back just on the command line and I'm going to manually add that file. If I look at the status, I can see that, that file has changed but not updated, so I can just say git add and the name of the file, do this specifically. And in fact, the status has changed, it's queued up to be committed. Now as an exercise for the reader, try editing that file again. You'll see that the status changes because we're talking about content, not files. At any rate, I like to do git commit with a different option here, -v. That actually includes a diff of all the content in your commit message, at least right there for you to see while you're writing your commit message. That's nice because then you can think about what you actually did, and you can see it listed out there. And if you had code completion that uses the contents of the current file, that comes in handy too. Now that you know how to add things to the index and commit in several different ways, let's look at the log and see our handiwork. Git log will just give us a brief message about what happened, what we did, a little bit of the commit message and also the SHA1 hash right there that identifies each individual commit. Usually, you're not going to reference those specifically but there it is for you to know about. Git log also takes a few other arguments, --stat is helpful to have a little ASCII graph there, pluses for each line that's changed. It has been added and a minus for each line, which has been subtracted from a file so you can see the depth or the extent of a commit and how much was actually changed and the different files. Finally, git log -p is useful to see the actual diff of what was changed, what was added or subtracted from a file, the actual content right there. And by default, it is going to be paged so you can scroll through that with the spacebar or whatever your pager is.

Branches
At the beginning of this screencast, I mentioned that branching is one of the most powerful things that Git can do and it's very easy, so let's look at branching. First though, I want to use a little tool to help us visualize this, included with the general installation of Git called gitk. I'm going to send it the all flag and for me, this always launches kind of in the background. So I have to switch to find that application, but here it is, it shows us a little bit about the different branches, the different commits. We can see over there who did the commit, when they committed. You can scroll down below and see the actual contents. Even color code it right here. And if we have more files, you can scroll through those files and then see all kinds of details about that. So this is useful. It also is going to show us a little bit of a diagram on the upper left, once we start out with some different branches. However, if you are using this and if you happen to launch this on Mac OSX, you might see that it looks horrible. Well, if you edit a. gitk file in your home directory, you'll see a few options here. I highly recommend switch to Monaco and at least 12-point font, otherwise, I think it uses Helvetica or something, and it's a variably spaced font and it looks horrible. So switch to Monaco, it's going to look a lot better and it's going to be a lot easier to see what's going on. So I'm going to leave that running in the background and use the ampersand so that it will just detach itself from running in the background, and we will, from time to time, update this. There's a little file update menu item, and it will show us what we're doing with our branching. First, why would I even want to branch? Well, sometimes, you want to work on a new feature and you want to keep the main master branch pristine so it continues to build or that the website can be deployed while you're working on this experimental feature. That's a great reason to split off a branch. And with Git, it makes that very easy. Now this whole time, we've actually been working with a branch, and that is called the master branch. In Subversion, that would maybe be similar to the trunk, although the terminology or the functionality is a little bit different. You can see that in color. To show you what the current branch is and the local and remote ones, we'll talk about that later. But to begin with, we just want to create a new branch. And so what I want to do is I want to make a branch called human, and I'm going to work on a feature here where I see if humans can travel through time with my Ruby library. Typing git branch again shows me that I did indeed create a human branch. And looking at gitk, I can see that the human and master branches are basically equal. There's nothing different, there's the same code in each because the human branch started out as just a copy of the master branch. It's now separate and I can do different things to it, but it started out as a straight copy of the master branch. Now even though I created this branch with git branch human, I'm still on the master branch so I need to do git checkout human to actually switch to that branch. Now if we just type git branch, we can see a star next to human, and I'm using the human branch. That's what my working directory is going to work with. In order to see what's happening, I'm going to create this new file right here. So this is going to be the human class and it's going to inherit from time_travel and maybe I'll add some extra code in there. For now, I'm just going to have that class definition and that's all I'm going to do. As you are familiar with, we need to actually add that file. I'm going to use my little alias here, gst, just to do git status that I set up in the shell. And I'm going to actually commit that with the -v option to see the contents of what I'm committing and make a little message. So that's been committed. Part of the beauty of Git is the ease with which you can switch between branches. You saw that we just added that human file and so that is part of the human branch. And if I go back to my text editor, I can actually see that human. rb file is in the lib folder. But if I check out the master branch, in other words, I switch back, it's gone. Why? Well, that human file was part of the human branch but it wasn't part of the master branch, so when I switch back and forth between branches, Git actually updates the current working directory that I'm in with all the changes, all the files, all the content that's part of that branch. If I update gitk, you can see a little bit of what's happening here. The human branch is actually gone a little bit past the master branch, they're not equal anymore, and it's actually added on to the code that is in the master branch. If I did a little bit more of an edit right here, just to add a little bit of an initializer, and then if I add and commit this, which could also be done with just git commit -a but here we go, explicitly adding that file and writing a little bit of a commit message, then I can go back and I see that again, the human class, the human branch, now has two commits that are different from the master branch, and so it's diverged a little bit. If I wanted to see this even more, I could check back to the master branch, so git checkout master, and I'm using that little alias that I set up for myself, git co, back on the master branch, human file is gone. I'm going to add a little bit more of a spec here to the time_travel spec, and this is on the master branch. So maybe I'm continuing to work on the master branch and I know that eventually, I'll merge these two together and all this content will come together. I'll go ahead and commit that, use the -a flag to just automatically get any changes in this project. Going back to gitk, we can update and see that something is actually split off here now. So the human branch went off to, it looks like, a real branch there, branch of a tree. The master continued on and now we have two separate pieces of code, two separate code bases right here. And eventually, we're going to want to merge these back together at some point. Even though I'm not ready yet to merge the human branch back into the master branch, I do want to make sure that human stays in sync with the master branch, and any changes in the master branch get reflected in the human branch as well. For that, we have rebase. First I'm going to check out the human branch using co, that nice alias that I set up for myself. Then I'm going to run this rebase command. The command is git rebase, and we name the master branch because master is what we want to use as the base for this merge for this rebase. You can see a little bit already what happened. First, rewind head to replay your work on top of it. So it extracted out all the changes that I did in this human branch, brought me up to date with the master branch and then replayed my human changes on top of that. We can even see that right here in gitk by doing a refresh, and now it's almost the same as it was previous to where human is kind of in line with the master branch, started out similarly, but just added a little bit to it. It hasn't actually diverged at all, it's just continuing on that base, the master code base. Let's assume that a lot of other changes have been made and I'm finally, finally ready to actually merge human back into the master branch. Now I've made some changes offscreen here and you can see, even been made by a different user, the PeepCode laptop user. That'll come in later. But with this visualization here in gitk, we can see that master is indeed branched off. It's different from the human branch, and they have changes that aren't a complete copy of the other one, so this is a time where I'm finally ready to merge these back together. First, I'm going to want to just switch back to that master branch, so git checkout master and I can see that I'm on that. I may also want to see what changes I'm about to merge back in, and a handy way to do that is git diff and then list the two branches that I'm interested in. So git diff master human. I'm going to list master first because I really want to see the human changes that have been added to master. And there it is, nice little diff. I can even pipe that to my text editor to get a little bit of color coding. It should work in Emacs or VI, or whatever text editor you use as well. This way, I can look, I can see what kind of changes are going to happen, find out what has actually been done, what I'm about to merge. And then I can actually execute the merge. For that, quite simple, git merge human. I'm in the master branch, so that's what's going to be merged into. Human is the branch that I'm pulling that change from. And now, we get this nice little graph, see what's happening, see that that content has been merged back into my master branch. Again, gitk is quite informative here. I can see that the master branch had one change set. The human branch had four change sets, and then they were joined back together into the same branch again. I've used exactly this workflow in a web app that I'm working on right now, trying to upgrade to Rails 2. 0, so I forked off a branch. I'm reconciling all the conflicts. And once I get that all together, I will merge back into the master branch. In the meantime, I'm doing some updates in the master and I also occasionally rebase to make sure that those features get into the Rails 2. 0 upgrade branch as well. So there's a real world example, but what if we wanted to revert? Well, Git gives us an opportunity to do that as well. Git reset --hard and then ORIG_HEAD. A little bit cryptic but what this does is just pulls back those changes and goes back to before the merge. And if we refresh right here, you can see that, that looks basically like the thing that we saw previous to the merge, master has forked off there, the human has a couple of change sets and they haven't merged yet. So reset, very useful for reverting some kind of a merge. Another thing that can happen during a merge is a conflict, the merge doesn't work, and it is up to you, the human, to resolve it. Here's another project where I had conflicts during a merge, and this is what it looks like. First, you'll see some content all over the screen showing you that a conflict happened in different files. One of those files happened to be the gitignore file and you can see here some markings for which parts of the file were part of the different versions. And I can just go ahead and edit that. I can use Emacs right here for the moment, and I can just delete the different lines and resolve that in order to make that work. And I may have to actually delete duplicate lines or whatever. In this case, it was just that there were some lines in different places, and I can just delete the merge messages, save that, add that again manually, and the next time I commit, that will be committed with the merge fixed.

Introduction to Git: Part 2
More Branches
Now that you know the basics of branching and merging, I'm going to show you a few advanced topics that are very useful. It's good to know that git can do this, and throughout here, you may see me use my aliases GB just to see what branch I'm in. What I can do here is I'm going to add some code and some different files, so time going to see if vegetables can travel through time, and I'll add this vegetable class, and I'll go ahead and actually add this to the index. So I'm going to actually queue this up for the next commit. Git, add, name of the file. We can see that in the status. I also may go in here and make some other changes, but these changes are not actually going to be queued up. I'm just going to make this change but not add it yet. The whole purpose of this is going to be to show that you can create branches on the fly, and it will carry your changes, both queued and unqueued, will carry those with you. So what I've done here is I've said, "Hey, I started out thinking that I was going to develop this in the master branch, but really I want a vegetable branch to continue this new feature, and while we're at it, I'm going to show you a different way to create a branch. Previously, we did just git branch, and name of the branch, but you can also do git check out dash B the name of the branch. That will not only create the branch, but it will also switch to it. So a little bit of a shortcut. You can see now that I'm on the vegetable branch. In addition, I also get those changes, which were queued up or even unqueued the new file and the modified speck. Those come with me, and I can now commit those to this new vegetable branch if I want to. So that's a nice part of the work flow. If you get halfway through some changes and decide you want a branch, you can do it. Another nice feature is get stash. What get stash does is it just saves away these changes, so that you can go do other work and then come back to the changes later. So right now I'm just going say git stash, and I'm going to say I started this vegetable branch. These changes now have been unqueued but saved away. It's somewhat, maybe, like a clipboard. What I can do now is I can go back, and let's say a have a crucial bug in the master branch, couldn't wait one minute. Well, now I can go back to the master branch, I can fix that bug. This code wasn't even written. Now that's in there. I can add that. I can commit, committing now to the master branch, and once I've committed this code then, now I can go back to my vegetable branch, continue where I left off by reapplying that stash. Let's do that then. I've committed back to the master branch, fixed the crucial bug, I'm going to check out the vegetable branch again, and first I'm just doing to look at the stash to see what's there, get stash list, and because I gave myself a little bit of a description, I can see that I started the vegetable branch. Now I'm finally ready to apply it, git stash apply, now I'm back it the point where I was. Nothing has actually been committed. I'm just queued up, ready to commit, ready to add, ready to keep working from wherever I was previously. Another thing you'll want to do often is delete branches. I'm going to go back here to git K, and we can see, that I have a whole bunch of branches, kind of messy, none of these are really needed right now, and some of them have already been merged, and I can get to the point where I can just delete these and go on with my development. So first, let's delete the human branch. That happened a few check ins ago, and I know that I don't need that anymore. It's been merged back in. Let's delete it. Git branch dash D, and the name of the branch, deleted branch human, there is it, it's gone. Deleting is just a little thing just to clean up. You can see that we still have that history, and we can see what happened, but that branch isn't going be in the list, and it kind of cleans up the whole work flow, the whole environment right here. Next, I may want to delete an unmerged branch, and unfortunately, you can't just do dash D. Git will warn you about that, which is actually a good thing. If it's not part of the current branch that you're sitting in, you what to use D and that will just force delete that to get rid of it, clean up your work flow, clean up your repository. Finally, we may want to clean out the stash. Once we've applied it and used it, we can get rid of what is there on the stash. Keep our repository clean. The way to do that is a little bit different, since the stash is its own animal. Git stash clear, that just clears out the entire stash, and we don't have to worry about that anymore.

Repositories
So far we've done what we've done just on the local repository, and that's one of the strengths of git. You can do quite a bit without ever having to leave your own machine, but, of course, sometimes you do want to leave your own machine. You want to keep a repository on the Internet, so that it will be always accessible or you want to pull some content from another repository. Maybe from another computer or someone else that you're working with on the project, and that's where different repositories come in, and that's what we're going to look at right now. The easiest, most secure way to use a git repository is with SSH, so that's the way I'm going to do this right here. I'm going to start by just copying this repository for the time travel project, copy that up to a server. I've set up an alias right here of the deployuser@repos. peepcode. com, and I have a path I'm just going to store in the time travel directory on that remote machine. SCP is just a tool to copy things over SSH to another computer, and so now I've copied that all up, and now I'm sitting on what I've shown here is the origin machine. So this is where all that was copied to. First I'm going to make a directory for this repository. I've just chosen to call it it var slash git, and I've used pseudo because that's at the root of this drive, and I'm going to move this whole directory to that location, so it will be at var/git/time travel. Next I'm going to change into that directory just to make it a little easier. The problem here is the directory still belongs to the deploy user. The way I've set this up is that there will be a git user which has a restricted set of capabilities, and that is the only user that will actually deal with this. So to make that work, I've changed this directory recursively to belong to the git user in the git group, and you can see that right there, git, git, time travel. That is pretty much all I need to do. I'm pretty much ready to go. The last thing is just to show you that I did, indeed, change that git user to have the user local bin git shell as his shell. This restricts that user to only doing git-related things on this server, a little bit of a security measure, and, of course, I do have git installed on this origin server where all that content is so that the user can commit and do whatever they need to. In order to now get a copy of that repository in my local host, this may be a little bit familiar, I'm going to clone that, and I'm going to clone it with the git user that we saw, point out the URL, and then I have var/git/time travel as the location of the repository. In order to understand a little bit of what's going on now, let's change into that directory and look at the hidden directory git slash config file. This contains a lot of the information about branches and other servers, other repositories that we're going to work with, and you can see right there we have the URL of the repository that we pulled this from, and we have our master branch which says remote equals origin. What this means is our master branch is tracking the master branch on the origin server, and practically, that means that we can send content out to it and we can pull content back, and if other people have updated the master branch on the origin server, we'll get those changes, as well. So later, we will do a little bit more complicated tracking with different branches, but for now, this is a great way to start, and we can see a little bit of this with git branch dash A. For our intents and purposes, origin slash masters is the only one that we're concerned about, and that's automatically linked to our own master branch. To see this in action, I'm going to make some changes here, and I'm going to commit that. So I'm just going to add and attr accessor to the human class, and I'm going to queue that up and see that it's been changed but not updated. Do my commit dash A to add all of the changes which includes just these two little lines. So now I've committed that, but that's just a local commit. That's not actually on any server other than mine, but with git push, I have now synchronized that back to the origin server, and because this is tracking the master branch and the origin server, I can just say git push. I don't have to tell it what server. I don't have to tell it what branch. It just automatically knows and sends that along. I also get the flip side of that, which is pull. Let's say somebody else has made a change, committed that, pushed it up to the origin server, well, I can do git pull, and without any other arguments, this particular branch in this repository knows that it should get new objects and merge from the master branch on the origin server. So those are the basics of push and pull, but let's look at the components so you understand this a little bit better. Fetch is a slightly more atomic element of pull. What fetch does is it just says, "Give me all the objects from a repository. " For example the origin, "And store those in my local database "so that I'm synchronized and I have "a synchronized copy of the objects "on that other repository. " Merge is a local thing where it says, "Given my database, and the objects "in a particular branch, put these together "and make an updated branch that has "the relevant combined total of all of these things. " You saw a merge earlier on our local repository. We merged two branches. We didn't even need another server in order to do that. Well, the fact is, pull is actually both of these together. Pull does a fetch, which says, "Give me all the objects "from all branches from the origin repository, "and pull those down to my local database, "and then do a merge locally on the branch "that I'm currently sitting in. " Now, right with this project that we're talking about, we only set up the master branch, but in fact, it's going to pull all branches, objects from all these different branches, and they're just going to be stored in our local database, our local git database. Nothing has actually been done with them yet except for the master branch. When we do a pull, it not only fetches those objects, but it also merges locally with the master branch that we're sitting in. At least if we're sitting in the master branch, then a pull will merge all those objects. The important thing here is just to understand that we have objects, we have merging, and we'll work with some of these independently later on. What I'm going to do next is pull from a completely different repository, and we'll see how to set that up and set up a tracking branch with that, but first let's just get a gauge of where we're at. I'm going to start up git K, and we can see that I have my master branch, and it also knows about the remotes origin master branch. We'll talk about the different remote branches in a little bit, but we can see that's what's happening and those are just equal right now. They're just listed side-by-side, the master and the origin master branch. So before we actually add another remote repository, let's look at the one we have. I'm going to use git remote show, and I'm going to just list the origin repository. That's the one that we cloned from, and that's the one that's set up already. So we can see just a little bit of information about that. The URL, the remote branch that is tracking the master branch, but what I want to do now is pull from another repository, so the laptop. I just have my laptop, and I just have this same git repository on that, the time travel repository, and I want to pull some content from it. First I'm going to add that repository as a remote source, so git remote add, laptop. I just chose the name of laptop that I can use to reference this, and then I list the URL and the path to that repository. So this is similar to what I did when I said git clone, but I'm just setting up a little alias for this, and I can then say remote show about that laptop, and I can see that that's set up, and it even knows a little bit about the branches on that remote source, so it actually connected and got a little bit of information about that. Next I'm going to do a fetch. So I'll explicitly ask for the laptop, and you can see here it just pulls down all the objects from the laptop repository and stores those locally. No merging actually happened, but we can see in my database now, it knows about a dog branch and a master branch on the laptop repository, and again, in git config, I can see that that has been added as a source, just remote laptop right there. I could've just typed that straight into git config but I chose to use the command line tools to do it. Next, I'll create a local branch with the same name as the branch as I want to fetch from the remote repository. I'm going to use that shortcut of git checkout dash B to create and switch to the branch, and so now I have a dog branch, but it's just a copy of my master branch right now. Nothing special about it. I could do this. I could say git pull laptop repository dog branch, and that would pull the objects and merge into the new dog branch that I just made, but, if you remember, I already did a fetch. So I already have all those objects in my database. I don't really need to go out to the laptop repository again to get those. I could just do a merge on what I already have in my local git database. So I'm going to do git merge laptop/dog, and that's the syntax to refer just to my local database copy of the laptop repository, and the dog branch. Very quick, and you can see that right there, now I have a dog file added to this repository, added to this branch, that I can now work with. It is possible to pull from branches that don't have the same name and merge those with other branches locally, but usually, it's easiest just to use the same names. If you know you're going pull from a dog branch on another repository, just create a local dog branch, and that's the easiest way to go. Then you can use a lot of these defaults, and you don't have to do some complicated paths to match up the exact branches. At any rate, I'm going to do a little bit of an edit right here, and I'm going to push back to that repository. So I added a line. I did git add to actually queue that up in the index. I'm going to do a commit here. Use dash A on there, although you didn't really need it. At any rate, now I've done a commit. It's in my local git repository, but I want to push this back to the laptop repository as well. So I'm going to explicitly name the laptop repository and the dog branch that I'm pushing out to. It's going to use the commit in the current branch that I'm sitting in in my working directory, which happens to also be named the dog branch. That's how I do the reverse. That's how I push it back. So git push laptop dog takes my commits. Send those out to the laptop repository. It's that easy. One last thing you may notice some other names here. Refs heads dogs, refs remotes, laptop dog, and again at the bottom, refs heads dogs. That's just kind of an internal representation that git uses. You can use those full paths if you're going to reference something, but I find it easiest just to use a branch that has the name as the same name as the branch that I'm pushing or pulling to, makes it a lot simpler.

Tracking
So there's one more basic concept that you should know about git, and that is a tracking branch. You may remember that when we cloned the origin, we could just push and pull from the master branch, and that went straight back to the origin, and we didn't need any extra arguments. We just said push or pull. Well, that is basically a tracking branch, and we can set up other branches to work that way, as well. Right now, I still have just my dog and my master branch, so I'm going to start by explicitly pushing that dog branch out to the origin server. The origin doesn't have a dog branch yet, and we can see that with git branch dash A to see all of them. So the origin doesn't have a dog branch, but I'm just going to push this anyway, and it will create that branch on the server. So git push origin dog. I'm sitting in the dog branch. It's going to push that out, and it's going to call that dog on the origin repository, and if I look now, I can see that the origin does, in fact, now have a dog branch down the bottom there, origin/dog. Okay, so we're all set up with that, but we still need to manually mention that. We can see from git K that those branches are actually equal to each other. Up at the very top there, we have dog and laptop dog and origin dog. They're all at the same point, same code in each of those, but they're not automatically hooked up to be able to push and pull from one another. In order to do that, there are a couple ways. First I'm going to show you just the manual way so you can understand what's going on, and then we'll do this again with a more automated command line way that sets it up automatically for us. So first what I want to do is edit the git config file. We've looked at this a little bit already. It's just a text file. It has some different settings, and we can set this up to track a branch. In this case, it's going to be the dog branch. So I'm going to edit that just in my text editor dot git config, and I'm going to take the settings from the master branch, because I know that's already doing what I want to. I'm just going to copy that and paste it down below. And I'm just going to change two lines. First we're talking about the dog branch. So I'm going to change that. We're still talking about the origin server, and we're talking down here about the dog branch, and you see refs heads dogs. Again, dog, again, talking about the merge. Now, a lot of different options that can happen here, but let's just start simply and this is all we need. This is going to set us up so that now our local copy of the dog branch is a tracking branch. I set up most of my branches this way, just because it's nice to be able to push and pull back to a central server, and then access that same branch from another laptop or a desktop or something like that. So in order to show this in action, I'm actually going to edit a little bit here in the dog branch and after adding this and committing it, I can actually just push and pull without any extra arguments. And this context sensitive. If I am sitting in the dog branch, so if I've checked out dog, then it's automatically just going to push back to the origin dog branch any time I just say git push, and there it is. And for confirmation, we can see a little line in there that says rest remotes origin dog that will let us know that, yes, in fact, this did push back to the origin repository. Next we want to pull. Let's say somebody else has been working on this repository and maybe they were also tracking and they pushed back up to the origin repository. Well, when I do a pull, then I'm going to get all those changes. One thing to remember is that a pull will get all the objects for all branches, but it only merges the current branch that you're sitting in if you set it up to do tracking. So this will, you can see there, we've got a couple other branches that it pulled down, but it only merged the one that I'm in right now. At any rate, now we are set up, push, pull. We're tracking the dog branch with the origin server and that's a nice way to work because you can just be very concise. You can push and pull, and it's going to do the right thing based on the current branch that you're sitting in. But there is an even easier way. You can create a branch and start that out as a tracking branch. You can see here we have the fish branch on the origin, so I can just say git branch. Give it the track argument right there, and then fish is the name of the local branch that I want. Origin fish is the remote one that I'm talking about, and now I have a fish branch. It's automatically set up to track and I can switch to that and I can start working on that and same thing, push and pull is going to go back to the origin. You can see at the bottom of git config, there's a new section, which looks pretty much like the manually edited dog section that we added, but it's just the fish branch, and that was automatically set up by the track argument to git branch. I've talked to a few people who've said, "Well, I don't want to use git because I don't like "the distributed nature of it. "I want a centralized thing where everyone "on the team can just push and pull "to a centralized server. " Well, as you've seen here, you can do that with git. You can use it that way. Set up a server, set up a bunch of tracking branches, have everyone pull and push to those branches, and you can use it the same way that you would subversion or some other kind of centralized thing, but you still get all the benefits of offline and distributed access, as well.

Subversion
There are many other tools available with git. You can have a web interface. You can blame files and find out who edited different lines. You can do many different things. You can archive, but one of the most useful ones for me in the transition to using git was git SVN, which allows you to work with a subversion repository but use git on the client on your own. So if you were working on a team and everyone else is on subversion, you can still use git locally and get all the benefits of branching and different kinds of things that you want to do, but push that out eventually have everything back on a centralized subversion server. So the command here is called git SVN, and you start out by doing git SVN clone and then list the name of a subversion repository. Here is an http-based one, a project that I have, and I'm just going to do a local clone. For a big repository with a whole bunch of commits, whole bunch of revisions, this can take quite a long time. I first tried to import the entire peepcode repository which only had a couple hundred commits, and I think it took an hour or something like that on my machine. I've since switched over, so I'm just using git exclusively on that, but this may take a little bit of a little while. At any rate, when it's done, you will have a copy of your subversion repository locally, and you can just work with it as a git repository. There are also some flags, if you want to automatically hook up tags and branches to subversion but I often just do the simplest way right here, and it's just a git project that happens to have a couple of folders, and once I'm inside of that, then I can do the normal git things that I would do. Just do your regular git commit and add files and make a branch and merge and anything you want to do, but when you're done, and you're ready to send stuff back to subversion, use this command, git svn dcommit, and that will take all of your individual git commits, package those up as subversion commits, and send them back to the main subversion server. So it's very clean. It works nicely. People on subversion won't even know that you're using git because you just work into the normal work flow and it commits quite cleanly. The only problem that I ran into was that you need to make sure that you have all the PERL bindings and subversion installed on your machine in order for that to all hook up because git needs its own code, and it needs all of the subversion code, as well. So while you're installing, make sure you have all that. Subversion installed from source with the PERL bindings and git itself. The last thing you may want to do is actually get a new copy of any changes that other team members have made, and you do that with git SVN rebase, and that will just pull down all the updates from the subversion repository and replay your local commits over those and then you can just keep going about your business and use git together with a subversion repository. Okay, here's one last thing that I mentioned at the beginning. If you go back to the main git repository, we started out by just cloning the source code of git itself, you can use git branch dash A, and you can see that there are a number of other branches in there. Now it's kind of a creative use of branches, in that some of those branches are actually documentation, manned pages, other kinds of things in there that you might want to work with. So go in there, check out the HTML documentation or whatever, great source, a lot of good documentation for looking up a specific command or how to use something, and you can find that all in the main git repository that you cloned already. So there are the basics of git. I found it to be a very useful source code control system, and I've switched most of my repositories and deployments over to use it. Hopefully, it's been useful to you, and you'll use these concepts of merging, branching, cloning, pushing, and pulling to work with your own projects and be more productive and do useful things with your source code.

Course author
Author: Geoffrey Grosenbach	
Geoffrey Grosenbach
Geoffrey is VP of Open Source at Pluralsight. He founded PeepCode and has created numerous courses on Ruby, JavaScript and Shell. He commits code at <a...

Course info
Level
Beginner
Rating
3.4 stars with 705 raters(705)
My rating
null stars

Duration
1h 0m
Released
25 Oct 2007
Share course
