Android Apps with Kotlin: Tools and Testing
by Jim Wilson

Learn the skills necessary to assure quality software through testing by learning to effectively use the single most important tool for Android developers, Android Studio.

With any craftsman, knowing how to use your tools is a critical part of doing a job well. Android Studio is the single most important tool for Kotlin Android developers and it includes a wide variety of features that empower developers to work effectively and assure software quality through testing. In this course, Android Apps with Kotlin: Tools and Testing, you'll learn the skills necessary to work efficiently as a Kotlin Android app developer and assure quality software through testing. First, you'll start by exploring Android Studio productivity tools such as refactoring, automatic code generation, and converting Java code to Kotlin. Next, you'll see how to identify and resolve application problems using the debugger. From there, you'll learn how to incorporate more expansive feature support into your applications using Android Support Libraries, Android KTX, and the Gradle build system. Finally, you'll explore how to assure software quality and reliability through the combination of local unit tests, Android instrumented tests, and automated UI tests. By the end of this course, you'll have the necessary skills and knowledge to efficiently utilize Android Studio to create your own high-quality Kotlin Android applications.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Beginner
Rating
0 stars with 8 raters
My rating
null stars

Duration
3h 42m
Released
30 Aug 2018
Share course

Course Overview
Course Overview
Hi everyone. My name is Jim Wilson. Welcome to my course Android Apps with Kotlin: Tools and Testing. I'm Managing Partner at JWHH, LLC, and I've had the good fortune to have been a professional software developer now for over 30 years. I've been creating apps for Android since the earliest days of the platform, and I've seen many exciting changes in that time, but none more so than the addition of Kotlin as an Android development language. Kotlin's a game changer. It tremendously simplifies the task of creating Android apps and includes a number of features that reduce the likelihood of our apps encountering problems at runtime. But even with all the great features that Kotlin provides, we, as developers, are the ones who are ultimately responsible for assuring that we deliver high-quality apps, and that's the focus of this course. So the major topics we cover include Android Studio productivity features for Kotlin developers, debugging and resolving errors in our Kotlin apps, incorporating Kotlin libraries into our app build process, implementing local JVM unit tests with Kotlin, and performing automated user interface testing with Kotlin. By the end of this course, you'll have the necessary skills and knowledge to efficiently utilize Android Studio to create your own high-quality Android apps using Kotlin. To get the most out of this course, you should already have a basic understanding of how to create Android apps with Kotlin. This course is part of a series and builds on the content covered in my course Android Apps with Kotlin: Build Your First App. I hope you'll join me as we learn to develop high-quality Android apps using Kotlin with the course Android Apps with Kotlin: Tools and Testing, at Pluralsight.

Working with the Core Tools and Features
Introduction
Welcome to the Pluralsight course, Android Apps with Kotlin: Tools and Testing. In this module, we'll look at how we work with the core tools and features of Android development. Now, throughout this course, we'll get a variety of tools related to developing our Android applications. We'll start out by looking at those core tools and features related to creating our applications. We'll then look at how we can debug our applications and resolve unhandled errors. We'll then dig into the Android build process and review some of the key libraries, including KTX and the Android support libraries. From there, we'll get into testing. We'll first look at how we can run local unit tests on our application, and then we'll see how to automate user interface tests. So now in this module, we're focused on the core tools and features that we use when we're developing our applications. But in order to look at those tools, the first thing we need to understand is the demo project we'll be using throughout this course. From there, we'll look at an overview of the features and capabilities provided by Android Studio. We'll then look at some of the features of Android Studio that really help improve developer productivity. From there, we'll see how we can convert Java code into Kotlin. And then we'll finish up. We'll look at an Android Studio feature known as Instant Run.

Overview of the Demo App
Throughout this course, we're doing all of our demos using an application that's intended to keep notes for Pluralsight courses. We initially created this app in the first course in this series, Android Apps with Kotlin: Build Your First App. So if you want to see the details of how we built that application, I encourage you to check out that course. But just to give you an overview of the application, the application has one activity that allows the user to interact with a note. Now for a particular note, you can associate it with a course, give the note a title, and, of course, give the note a body. The application has another activity that shows the list of notes that have already been created. The data model for this application is stored in memory. So when the user first starts the app, they see the list of notes. The user taps on a note. We then launch the other activity, showing the details of that note. The user can view those details or modify them. Also on the activity showing the list of notes, we have a floating action button. If the user taps that floating action button, we again show the activity for an individual note, and that allows the user to create a brand-new note. And of course, when the user leaves that activity, the new note is added to our in-memory data model and appears in a list along with the other notes. So all of our demos throughout this course will be using this application. So now in our next clip, let's look at some of the key features that are included when we install Android Studio.

The Important Role of Android Studio
When we're building our Android applications, we're, of course, going to be using Android Studio. Android Studio really is the primary environment we use for development applications because Android Studio handles the full development cycle. So pretty much everything we're going to need to do when we're working on our Android apps, we're going to do from Android Studio. Now Android Studio is actually built on the IntelliJ Platform. And the reason I point that out is because IntelliJ and Android Studio have really consistent developer experiences. So if you're trying to find out how to do something and you do a search for how to do it in Android Studio and you can't find the answer for Android Studio, if you find the answer for how to do it using IntelliJ, in almost all cases you can go ahead and use that answer to do what you want to do within Android Studio. Now, Android Studio takes care of installing pretty much everything we need to build our applications. Now, we know that Android is a Java-based environment. By using Android Studio, Android Studio takes care of installing what we need from a Java standpoint. Now, throughout this series, we're doing our work in Kotlin where Android Studio takes care of installing what we need from a Kotlin standpoint. And of course, since it's Android Studio, it's going to take care of managing things like our Android SDK and other tools we need in order to do our Android development. Now, of course, a key part of our development is running our code, and the cool thing about the emulator is it allows us to run and debug our code directly on our desktop. So it makes it very easy to verify that things run as we expect without having to connect to an external device. But Android Studio also supports physical devices. And when we're building real apps, it's important that we periodically run our code on real devices. Now, in order to run code on a real device, you may need to install USB drivers. Now, if you're working with a Mac, you don't need to do that. You can simply plug the device in, and in most cases, Android Studio can just run your code directly on that device. But if you're working on Windows, you probably will need to install a USB driver, and the specific driver you need will depend on that physical device. So if you check out that URL that I currently have on screen, it will give you the information you need as to what drivers to install depending on which device you're using. Now, an important part of developing any application is testing, and Android Studio provides what we need to do our application testing. And one of the cool things is Android Studio allows us to do unit testing, and for a logic-based tests, we can do those directly on our desktop. So for the parts of our code that are purely logic and don't have a user interface, we can turn around those tests very quickly because they'll run directly in the JVM on our desktop. And the reason that's possible is because Android Studio includes JUnit. So now in addition to our logic-based tests, Android Studio also allows us to do automated UI testing, and these are interactive tests that we can run on an emulator or a device. And these tests can do things like click buttons, enter text, select items from drop-downs. And this is possible because Android Studio also includes Espresso. So just by installing Android Studio, we have access to all these capabilities. Now we'll talk about testing in more detail a little bit later in this course. But now in our next clip, let's take a look at some of the productivity features that Android Studio provides to accelerate our Android development.

Android Studio Project Window and Productivity
Here we are back in Android Studio, and what we want to do now is look at a few of the productivity features that Android Studio makes available. Let's start out here with our Project window. Now, our Project window shows us the files that are part of our project. And as we talked about in the first course in this series, we generally use the Project window's Android view. And what that does is that arranges the files and the folders in a way that allows us to work effectively during the application development process. And the Android view is the one we use far and away the most often. But there are times you might want to use other views. For example, you may want to see the files and folders as they actually exist in the file system. So the way we can do that is go over here to this drop-down where we currently have Android selected. We're going to expand the drop-down. Let's use Project. So now that switches us to the Project view. And you can see here we're now seeing folders that we didn't have before because this is showing us the content of our project as it appears in the file system. So we can see like the folders that Gradle itself needs or the folders that Android Studio needs. So if we want to see the content as it is in the file system, we can use this Project view. But as we mentioned, we generally want the Android view. So let's go back to the drop-down, and we'll choose Android. So now, again, we're able to interact with the files in a way that's effective as we're developing our applications. Now currently, our Project window is showing a lot of content, so let's go ahead and collapse all of this just to get it out of the way. So go up here to this option, we'll choose that, and that now collapses all the content in the Project window, and that gets rid of some of our clutter. Now in a large project, the number of files and folders can actually become quite large, so locating any particular file can sometimes be difficult. So to help with that, we have this option that allows us to locate the source file that we're currently viewing. So I'm currently viewing my MainActivity. kt file. So if I go here and click this option, that locates that file for me here in the Project window. So that gives us a sense of the sort of things we can do within our Project window. But what about improving productivity in our coding? So let's take a look at some of those features in our next clip.

Android Studio Developer Productivity
Here we are back in Android Studio, and what we want to do now is look at some of the features that are available to improve the productivity of our coding. Now, one of the things we know is that Kotlin, from a language standpoint, does a great deal for us to improve the efficiency of our coding, but there are sometimes things we need to do that are better handled by Android Studio itself rather than the language. So let's head over to our Source window, and then I'll just go ahead and right-click on some of the content here in our Source window. And notice that one of the options we have here is Refactor, and Refactor makes it easy to refactor our code, so simple things like renaming. Renaming variables, properties, or methods can be handled by the tool. So it'll take care of doing the renaming and changing all the references to that name throughout our code. Change Signature allows us to change a signature of a function, so we can do things like change its return value or its parameters. We can move code, copy code. And then there's Safe Delete. If we use Safe Delete, Android Studio will check to see if anywhere else in our code relies on the item we're about to delete, and if so, it'll show us where that item is used. So now let's look at this option, Extract. And Extract allows us to extract pieces of code. So we can extract a piece of code and associate it with a variable or a property, even make something like a variable a parameter, and we can even take blocks of code and turn them into a function. So let's take a look at what it's like to use the Extract feature. So let me return back to my code. So here in our code we're looking at MainActivity, and MainActivity is the activity that shows the content for a particular note. And we're here in it's onOptionsItemSelected method, and that's the method that's called when the user selects one of the option items. And here's the code for when the user selects Next. And when the user selects Next, they want to move to the next note. So now, as long as there are more notes, we go ahead and allow them to move to the next note. But if they're already at the last note, we simply use a Snackbar to display the message that there are no more notes. So now notice here when we create the Snackbar we're using the literal text No more notes. Let's say we want to take that literal text and make it a variable instead. Let's go and highlight No more notes. I'll right click on it, I'll choose Refactor, then Extract, and then I'll choose Variable. And when we click Variable, you'll notice that Android Studio has given a default name of s, and by default, it makes it an assign once variable. You see we have options here to make it immutable variable, as well as explicitly identify its type. Now we don't want to do either one of those things, but we do want to change its name. So I can simply type the new name I'd like it to have, so I'll type message. So once I have that, I'll hit Enter. And so now Android Studio took care of extracting that literal string into a variable. And we can do that with any blocks of code that we want to pull out from their direct usage into different usage, like variables or properties. Now, one of the powerful Extract features is to extract a function. But now, if we look here where we show the Snackbar, that's a fairly long bit of code to simply display a message, and there are other places where we use Snackbar. Look here towards the bottom of the screen where this other function, displayNote, and that's the function responsible for actually displaying the content of a note. And we have some code here at the beginning that just checks the note position that's trying to be displayed, and it makes sure that it's a valid position. And if it's not a valid position, then it uses a Snackbar to indicate to the user that that note can't be found. So the code we're using to display a Snackbar might be better placed inside of a function that's just easier to type. So let's go up here to the code where we show the Snackbar for no more notes, and we'll highlight the line for the Snackbar. Now once we have that highlighted, let's right-click on it. We'll choose Refactor, we'll choose Extract, then we'll head over to Function, and we'll choose Function. So now that brings me to this dialog to allow me to extract the function. And notice one of the things that it did. It noticed that the code we're trying to extract uses a variable that's not part of the code we're trying to extract. So it's inferred that we want that variable to now be a parameter. And that's exactly what we want. We want to be able to pass in the message that we want to display. So let's name the function showMessage. Now I've indicated that I want to create a function named showMessage that accepts a parameter. We can actually see the signature of that method down here in the Signature Preview. All that looks good, so I'll go ahead and hit OK. And you'll notice that when I hit OK, this message now pops up. And what Android Studio is telling me is that it found code that I'm using that matches the code I just extracted to that function, and it wants to know if I want to replace that code with a call to the function that I just created. And I do, so I'll go ahead and select Yes. And now once I do that, you can see the code I actually extracted calls our new function, showMessage, passing in the variable, but also, if we head down to the displayNote function where I was displaying the Snackbar there, it also calls our new function, showMessage, passing in the literal text that was being used in the Snackbar in this code. So now scroll down a little bit. And when we scroll down, we can see the function it created. It's our showMessage function, accepts a parameter for the message, and then it has the code to display the Snackbar. So as you can see, Android Studio includes a lot of features to simplify the housekeeping of our code. So anytime you have to do any kind of mundane housekeeping like renaming code, moving code around, extracting bits of code, I'd encourage you to dig around Android Studio because chances are it has features that will simplify the task that you need to do. Okay, so now in our next clip, let's see what kind of features Android Studio provides to simplify bringing Java code into our Kotlin code.

Converting Java to Kotlin
Here we are back in Android Studio. What we want to do now is look at an important aspect of improving our efficiency as developers, and that's code reuse. In general, if there's already code available that does what we want to do, we're probably better to use that code than write code from scratch. And Android Studio provides a few features that can help us out. Now, the first one is access to samples. Android Studio allows us to access a very rich library of samples. If I go up here to the File menu, then I choose New, then you want to go over to Import Sample, then I'll go ahead and select that. And what this does is give us access to a huge library of Android samples that are available in GitHub. And there are samples that show us how to do a wide variety of things when we're working in Android. Now, if you look at the list of samples we currently have on screen, you'll notice that some of them have the word Kotlin in parentheses after them, and that tells us that those are samples that are written using Kotlin. So you can see there's a sample for Downloadable Fonts, one for Emojis, another one for Notification Channels, and some others as well. But that, of course, means that the ones that don't have parentheses after them are not in Kotlin. Those are going to be in Java. And this is an important thing for us to keep in mind, right? Kotlin is a fantastic language, and it's generally much more efficient to program in Kotlin than it is in Java. But Java's been around for a long time, so there's going to be lots and lots of code out there that's written in Java that might be useful to us as we're developing our Kotlin applications. And it turns out that Android Studio makes it very easy for us to take advantage of Java code even when we're working in Kotlin. To see what I mean, let's head back to our source code. So here we are back in Android Studio, and we're looking at the source code for the activity that shows a list of notes. One of the things I thought might be neat to do is take some code from a Java application and see how it compares to code we already have in our Kotlin application. So here on screen I have the code that handles when the user taps the floating action button. And this code actually takes care of creating an Intent to show another activity, which is an activity named MainActivity, and then called startActivity to start that activity. So let's head over to a Java application that does the same sort of thing. So here we are now over in the Java application, and this is an application that comes from the Android Associate Developer Certification Path, and that's a path that's available for people who want to get certified as Android developers. And the application here is very similar to the application that we're currently building, but, of course, the key difference is this one's built in Java. You'll notice that one of the things we have on screen here is code to handle when the user taps on the floating action button, and when they do, we launch another activity, the same sort of thing we're doing in our application. But notice how much more verbose the code is in Java. Here in Java we have to create an instance of an anonymous class that implements a particular interface, we then have to explicitly override a method, then finally within that method we have the code we want to run, which is a code that creates a new Intent and starts an activity. So functionally, this is exactly what we're doing in our app. Now, of course, there will be a few significant differences, most notably, the activity class names. In the Java code, MainActivity is a class we're currently in, and the activity we want to start is implemented by a class named NoteActivity. And those will be different class names than we're using on the Kotlin side, but functionally it's the same. So let's see what happens if we take this code over to our Kotlin application. So first, I'll go ahead and highlight the code. Once it's highlighted, I'll right-click, I'll choose Copy, and now that I have that in a clipboard, let's head over to the Kotlin application. So I now have Java code in the clipboard. I'm go ahead and paste it into my Kotlin class. So I'll right-click. I'll choose Paste. And you'll notice that when I did that Android Studio looks at the code and says hey, that's Java code. Do you want me to go ahead and convert that to Kotlin for you? And I'll say yes, I do. Let me go ahead and hit Enter. It tells me that it needs to import a class, so I'll say OK. And you can see that once the code's pasted in here, Android Studio converted it to Kotlin, which means we got rid of all that extra Java code that we needed to do this same operation. Now, to make this a little bit easier to read, let me add some line breaks. So I'll add a line break after the opening bracket, and I'll also add one just before the closing bracket. And so now, as we look at this code, you can see that the code that was copied from Java and pasted in here is very similar to code that was written explicitly as Kotlin. Now one key difference is the code that we wrote explicitly in Kotlin does the operation of starting the activity in two steps. It creates the Intent as one step and then starts the activity as a separate step. The code we pasted in just does all that in a single line. That, of course, is a very minor difference, and it's only doing it in one line because the Java code we copied did it in one line. Now another difference is the Kotlin code that was explicitly entered actually specifies that the view parameter is received. But that view parameter is never used, so we actually could've left it off when we typed that Kotlin code. But when we pasted the code in, Android Studio knew we weren't using that parameter, so it didn't bother specifying it. But you can see that even here Android Studio is showing us that there is a View parameter available if we did want to use it. Now, the things that are highlighted in red are highlighted in red only because of differences in the way things are named in the Java version of the application and then this Kotlin version of the application. So for example, the this reference is being specified within a class named MainActivity, and we don't need that over here in our Kotlin class because we can simply say this, and Kotlin will realize we're referring to the this for the current activity, which is our NoteListActivity. So let's take that out. And then another key difference is the Java program wanted to launch an activity named NoteActivity, but the one we want to actually launch is the one named MainActivity. So let's go ahead and change NoteActivity to MainActivity. And now once we do that, the code we pasted in from Java looks basically just like the code we manually typed in Kotlin. So Android Studio took care of doing all that code conversion for us. The only thing we had to do was change the class names to match the class names we're using within our Kotlin application. So this is a really powerful feature. It opens up the huge world of Java code that's available to us and allows us to leverage it in our Kotlin applications. Okay, so now in our next clip, let's look at a feature of Android Studio known as Instant Run.

Android Studio Instant Run
Here we are now with our app up and running in the emulator. Now I launched the app using Android Studio's Run button. What I want to do now is look at a feature of Android Studio known as Instant Run. So let's head back over to Android Studio. Now, if we look here in Android Studio, we know there are a couple ways we can start an application. We have our Run button, and we also have our Debug button, and both of these launch the app. But one of the challenges we have, particularly when we're trying to resolve a problem, is that we tend to make small changes to our code, test them out, see how that goes, make some more changes, see how that goes, and so on. And we tend to go through this cycle many, many times. And of course, when we make those changes, we could test them out by simply clicking the Run button. And if we do that, Android Studio will stop our app, fully redeploy the app, and then restart it. Now, one issue is that full redeployment and restarting the app takes a fair amount of time, particularly in large applications. The other issue is that a full restart of the app will cause any app's state to be lost. Now, to help us with that, Android Studio has what's called Instant Run. Now, it's also known as Apply Changes, and that's this lightning bolt button here. So whether someone says Apply Changes or Instant Run, they're talking about the same thing. It's a feature of Android Studio that does just enough deployment based on the changes that we've made. In many cases, it'll just leave the app running, apply the change, restart the activity, and then bring that activity right back. So let's see Instant Run in action. So let's head back over to the emulator. So here on the emulator, let's go ahead and pick the first item on the list. Here in the note text, let's go and add an XXX. Then we'll go up to the title; we'll add a YYY. Then we'll head down to our back button, collapse the keyboard, and return back to the previous activity. Now, once we return back to the previous activity, that'll save the changes that we've made to the note. Now what that means is that we've changed the state of the application. But now remember that our app doesn't currently have a persistent storage, so all of our app's state is stored in memory. So maintaining the current state of our app is dependent on the app continuing to run. So with that in mind, let's head back to Android Studio, and then here in Android Studio, let's make a really simple change to our app. What we're looking at now is the layout for our MainActivity. And let's do something creative, like change the text color for our note title. So now I already have the Note title selected, so over here in the Attributes window I'm going to go to the textColor attribute. I'll select the... next to it. In the Resource dialog that pops up, I'll expand the Project node, and then for the color, I'll select colorAccent. And then we'll say OK. So now that we've made that change, if we went over here to our Run button and we click that, it would fully relaunch our app, which means all of our app's state would be lost. So what we'll do instead is use the Instant Run feature. So again, that's our lightning bolt button. So let me head over there. I'll select Instant Run and then switch over to the emulator. Now, in just a couple of seconds, Android Studio applied those changes to our app. So to see those changes in place, let's go ahead and select that first item, and notice that our text color's changed. It's now that fuchsia color that we actually selected when we made the change to our layout. But notice also the updates that we made to the data before the change are still in place. So that shows us that by using Instant Run, Android Studio did just enough deployment to get our changes out there and running. So the key point to remember is that you want to be sure to take advantage of Instant Run. It'll allow you to work much more effectively and helps to keep you moving as you make small changes to your code and test them out.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that Android Studio is the central tool we use for Android development. It gives us pretty much everything we need. So the installation of most of the tools we use during the Android development process are taken care of for us by Android Studio. And remember that Android Studio includes testing tools, so it gives us the tools we need to run traditional unit tests, as well as automated user interface tests. And Android Studio has a really rich set of productivity tools. For example, many of the things we need to do when it comes to refactoring our code are handled for us by Android Studio. Now, a key part of working effectively is access to good sample code, and Google provides for us a large library of samples, and we can access, download, and open those samples all from directly within Android Studio. Now, a key part of working effectively as a developer is taking advantage of code that already exists. Now, when Kotlin code's available, that's what we'll want to use, but because Java's been around a lot longer, there's a much larger set of Java code out there than there is of Kotlin code. And Android Studio allows us to easily convert Java code into Kotlin code. We can simply paste Java code into a Kotlin class, and Android Studio will do the conversion work for us. And then we have Instant Run, and Instant Run accelerates the process of deploying code changes. Because rather than doing a full deployment, it deploys just enough. It employs only what's required to apply the changes that we've made. And as part of this deployment process, it can even help us avoid long startup times for our application because in many cases Instant Run will even allow our app to keep running. All right, so now in our next module, let's take a look at the features that are available for debugging your applications and for resolving errors.

Debugging Your App and Resolving Errors
Introduction
Welcome to our next module, Debugging Your App and Resolving Errors. This is part of the Pluralsight course Android Apps with Kotlin: Tools and Testing. My name is Jim Wilson. In this module, we'll look at some of the tools that are available to help us to resolve errors and other issues that might occur within our program. We'll start out, we'll look at breakpoints that allow us to pause execution of our program at a particular statement, along with some of the options we have for stepping through individual statements within our program. We'll see how to set breakpoints that only occur when a particular condition is met. We'll see how to view the values contained within variables and properties. We'll see how we can deal with unhandled exceptions and how to resolve the cause of those exceptions. And then we'll finish up. We'll look at the Android logging system known as logcat.

Breakpoints and Code Stepping
Here we are in Android Studio. What we want to do now is look at some of the debugging features provided to us by Android Studio. Now, as we've talked about before, when we launch an application, we have two general choices for how we do that. One is the Run button. The Run button takes care of installing our application onto an emulator or device, then starts it running, but then we also have the option to debug the application. So when we click the Debug button, that takes care of installing our application, starting it running, but it also gives the option to kind of walk through the code line by line if we want to. Now, as you recall from earlier in this course, we talked about the Instant Run feature, which provides the ability to more quickly relaunch our application when we make changes. Even though the feature's known as Instant Run, it works whether we run the application or if we're debugging the application. In both cases, you can still use Instant Run to deploy and execute changes in your code. Now one of the most common things we do with the debugger is use breakpoints because breakpoints allow us to stop the execution of our code at specific statements in our application. Now we're currently looking at the code for our application's MainActivity. Now remember, this is the activity that displays information for an individual note. So let's say here with the new onCreate method we want to add a breakpoint, and let's add a breakpoint here where we actually associate an adapter with a spinner that's used to select a course. So now the easiest way to add the breakpoint is go over to this gray area to the left of the code. If we head over there with our mouse and we click, we've now added a breakpoint. So when the execution of our program reaches this statement, the debugger will automatically halt execution at this line of code. So now to start our application initially, we'll head over to our Debug button. Then we'll go here and click our Debug button. So now our app's up and running, and we're looking to list of notes on the NoteListActivity. So let's go ahead and select one of the notes, and when we select that, we can see that our application has stopped at a breakpoint back in Android Studio. So let's switch back to Android Studio. So back here now in Android Studio we're at our breakpoint. The blue highlight on the line where we set the spinner's adapter shows us that that's a current line being executed, so our application is halted at this line of code. So now from this point, we have a few options on how we proceed. One of things we commonly do is use a feature known as Step Over, and that allows us to step line by line in our application code. If I select Step Over, the current line advances to the next line in my source code. I select Step Over again, goes to that next line, Step Over again, goes to our next line, and I'll Step Over one more time. Now this point, the execution is stopped at a call to a function that I wrote, the function displayNote. Now, if I click Step Over, the debugger will run that entire function and then advance me to the next line in our onCreate method. Now sometimes that's what we want to have happen, but other times we want to be able to go into that function. And when we want to go into the function, we have this Step Into option. So if I go over here to Step Into, and then I click on that, that takes me into my displayNote function. So here inside of displayNote I can step line by line if I want to. So let's go back here to Step Over. I'll click that. So I can click it again. Now I can continue doing that, but if I know I'm done inside this function and I simply want to return back to where this function was called, we've got the Step Out option. So if I click Step Out, I return back here to where displayNote was initially called. Now I can continue stepping from here if I want to, or I can just go ahead and let the code continue running normally. To do that, head over to this button. So we'll go ahead and click that button, return back to the emulator. So now at this point, the code for our application will run normally until we hit another breakpoint. So let's return back to NoteListActivity, let's head up to that first note again, and we'll go ahead and select it. See we hit our breakpoint, so let's return to Android Studio. So we're back in Android Studio, and our code is stopped at the breakpoint. And so from here I can use Step Over and Step Into as we talked about before, but sometimes when I'm looking at my code I know I want to run until I reach a particular statement. Now I could add another breakpoint, but there's also another choice, which is Run to Cursor. So let's say we have our if statement here where we actually check the notePosition, and I know I want to run until I reach that statement. What I can do is go up here and click on it, which positions the cursor there, and then we have this option down below here, Run to Cursor. So now if I go and choose that option, my code will run until the execution statement reaches the line where I've placed the cursor. And that's a great choice when I know there's a bunch of code I want to get past before I start walking through things piece by piece in a debugger. Alright, so now in our next clip, let's take a look at something known as conditional breakpoints.

Conditional Breakpoints
Here we are back in Android Studio, and what we want to do now is look at something known as conditional breakpoints. Now, as you recall, in the previous clip we added a breakpoint. Here we associate an adaptor with our spinner. Now because we created that as a regular breakpoint, whenever our code reaches that statement, execution will always stop. Conditional breakpoints allow us to set a breakpoint that only stops code execution when a specific condition is met. Now before we do that, let's remove the breakpoint that we already have here. To do that, we can go over to the red dot, and we'll click on it. That removes that breakpoint. And then for our conditional breakpoint, let's look down here where you have this if statement. That's an if statement that checks to see whether the note's position equals some constant POSITION_NOT_SET. Now one thing I want to point out. We're setting our conditional breakpoint on an if statement. That is not a requirement of a conditional breakpoint. Conditional breakpoints can be set on any statement you want. In this case, we happen to be using an if statement, but conditional breakpoints can be used with any kind of statement. So now in order to make that a conditional breakpoint, we're first going to make it a regular breakpoint. So I'll go down here into the gray area next to that statement. I'll click. That adds the breakpoint. So now to make it a conditional breakpoint, I can simply right-click on it. That opens up this dialog, and this dialog allows me to associate a condition with the breakpoint. And I can write regular old Kotlin code when I do that. I can use any variables, any properties, any constants. Any code that would be valid for me to write at this point in the application is valid for me to write in this Condition. So let's go now to Condition that says only stop at this breakpoint when notePosition is equal to POSITION_NOT_SET. So now we have a conditional breakpoint. Our code will only stop here when the notePosition has a value of POSITION_NOT_SET. So we'll go ahead and say Done. We'll head back up to our Debug button. So now to launch this, I'll click the Debug button. So here we are now with our app up and running, and I'm going to go ahead and select a note. But before I do that, just a quick reminder on the way the application code works. So when we select an existing note, the property notePosition does not have a value of POSITION_NOT_SET, but when I create a brand-new note, the value of the note's position is -1, which is the value of the constant POSITION_NOT_SET. So when I create a brand-new note, no position will contain the value POSITION_NOT_SET. So my breakpoint should only stop execution of the code when I create a brand-new note, so let's try that out. So first I'll select an existing note, and you see it went over to my MainActivity completely normally without ever stopping at our breakpoint. So let's head down to our Back button. Let's go ahead and go back. Takes us back to our NoteListActivity. Now let's head over to our floating action button to create a new note. We'll select that, and you see when we did that we hit our breakpoint. So let's head back to our code. So now here we are back in our code, and in our code we're now stopped at the breakpoint because creating a brand-new note passes a notePosition value of POSITION_NOT_SET. But now what if we wanted to actually evaluate the contents of particular variables and properties within our code? How will we do that? Well, that's what we'll see in our next clip.

Variable and Property Viewing
Here we are back in Android Studio, and what we want to do now is look at how we can see the contents of variables and properties during the debugging process. So we're here in our MainActivity class, and we have our onCreate method. Now our onCreate method calls this other method, displayNote, that handles the details of displaying the contents of a note when the user selects an existing note. So let's scroll down to that method. So here we are in our displayNote function. Now as we mentioned, this handles the details displaying the contents of a selected note. So let's go and add a breakpoint here where we get a reference to the note from the DataManager. So I'll head over to the gray area, and I'll click. So that gives me my breakpoint. So let's go ahead now and launch our app in the debugger. Here we are now with our app up and running. So let's go ahead and select a note, and we'll select this first note. When we do that, we hit our breakpoint, so let's switch back to Android Studio. So back here in Android Studio we can see we're stopped at our breakpoint, so let's see what information about the variables and properties are available to us while we're stopped at this breakpoint. Well, notice at the line where we're stopped we're about to set a local variable named note. That variable doesn't exist yet. But we're also using a property named notePosition, and you'll notice that just to the right of the line we can see that property, notePosition, and its current value, which is 0. So we can see that Android Studio is showing us information about variables or properties within a particular line. Notice we also have the Variables window down here, and the Variables window shows us information about properties and variables relative to the code we're currently in. Now the only thing in the Variables window at this point is our this reference, the reference to the current class. Let's go ahead and step. So if we step, we've now run the line of code that assigns a note to our local variable named note. So if we look at the Variables window down here, we can see that the note variable now appears in the Variables window. Now note is a reference to the NoteInfo class, so the information being shown to us is the string representation of that class. So it's basically calling the toString method on the NoteInfo class. But now what if I want to see the individual properties within that note? Well, you notice that next to the note variable inside the Variables window we have that greater than sign. Let's head down there, then we'll go ahead and click on that, and you notice that that actually expands the note. So that allows us to see the individual properties within that note. So we can see not only the reference itself, but, of course, the contents of that reference. If we want to go ahead and collapse it, we just click on it again. So let's head back to our Step Over button, and then we'll step a couple times. So we'll step, we'll step again, and now we're about to set the coursePosition variable. So let's go ahead and step, and notice now when the coursePosition variable gets set, coursePosition is also added to our Variables window. So the Variables window does a pretty good job of automatically determining what to show us. But sometimes you want to see things that aren't already in the Variables window. So let's say, for example, we want to see the value of our notePosition property, and we have a line of code here that uses notePosition. So let's head up there, and when I get up to notePosition I'm going to go ahead and up let my cursor hover over top of notePosition. And notice that Android Studio automatically showed me the value of notePosition. So I can hover over most variables or properties, and Android studio will automatically show them to me. But now what if I want notePosition to appear in the Variables window even though it wasn't automatically added? Well, I can do that by first right-clicking. You notice that down here we have Add to Watches. And if I select that, notePosition now appears inside the Variables window. But we can actually see more than simple variables or properties. We can actually evaluate expressions. For example, we have our DataManager notes collection. What if I wanted to see what notes are inside that collection? Well what I can do is highlight DataManager. notes, and then once I have it highlighted I'm going to go ahead and right-click on it, and you see we have this option, Evaluate Expression. We'll go ahead and select Evaluate Expression, and when I do that, you see the highlighted expression shows up here in the Expression box. And what this allows me to do is evaluate code within the context of the current breakpoint. So I can use things like variables and properties and have them evaluated in the current application context at this breakpoint. So what I'm going to do is go ahead and choose Evaluate. And you notice that when I did that it evaluated the value of DataManager. notes, so it's showing me all the notes that are currently in that collection. So I'll go ahead and close this. So as we can see, Android Studio does a really good job of allowing me to see the contents of the variables and properties within my application. So now in our next clip, let's see how to resolve unhandled exceptions in our application code.

Determining the Cause of an Unhandled Exception
Here we are back in Android Studio, and what we want to do now is see how we can use Android Studio to resolve unhandled exceptions. So let's imagine the scenario that you've been assigned the task of going through the know NoteKeeper application and looking for opportunities to make the code a little bit tighter or a bit more readable. So when you go into our MainActivity class, you take a look at the onCreate function, and you look at the code here where we decide whether we're displaying an existing note or we need to create a new note. And you notice that the work of displaying an existing note occurs within a function, but the work of creating a new note we're doing right here within the onCreate function itself. And you decide that it might be a little bit cleaner if we took the work of creating a new note and put that into a separate function just like we do when we're displaying an existing note. So to do that, the first thing we'll do is highlight the code within the else part of the if. Once that code's highlighted, we'll right-click, we'll go up to Refactor, we'll then choose Extract, and then we'll choose Function. That brings up the Extract Function dialog. We'll give the function a name of createNewNote. Our createNewNote function doesn't require any parameters, so go ahead and create the function. And so now within our onCreate method we display a note within a function, and we create a new note within a function. And our createNewNote function now contains the code to create that new note. But now looking at the code here, we see that inside of createNewNote we assign a value to our notePosition property, and onCreate, we also assign a value to the notePosition property. And remember, part of our task here is trying to clean up and tighten up this code. So we make the decision to say well, there's no reason to set notePosition in two places, so let's remove the line within createNewNote that assigns a value to the notePosition. So now we have some nice, tight code for creating a new note. So now let's go ahead and launch our app inside the debugger and verify that everything works as we expect. Here we are now with our app up and running. Let's first make sure that selecting an existing note still works correctly. So I'll select a note. The note displays correctly. Let's head down to our Back button. We'll click the Back button to return back to our NoteListActivity. So that all worked fine. Now let's try creating a new note. So we'll go over to our floating action button. We'll select that. Let's go and give our note a title and some text. So we've given our note a title and some text. So let's go ahead and collapse the keyboard, and then we'll return back to our NoteListActivity. And that, my friends, is an unhandled exception. So we need to figure out what's caused that exception. So let's head back to Android Studio. Now here within Android Studio we have the Debug tab selected. But as you can see, because we're not actually stopped in the debugger, there's no regular debugging information to be displayed. But we have this other tab here labeled Console. If I go ahead and select that tab, this tab is showing me information about my application's crash. And you can see here we have an exception, which is an ArrayIndexOutOfBoundsException. So we have the name of the exception, as well as some information about the exception itself. And then underneath that exception is information about the call stack. At the top of the stack is the most recent thing we've called. Just below that was the method called before that, and that continues backwards all the way up to the very start of the application. Now each line in the call stack shows me the class and the method that was called along with the source code that contains that code. But notice that two of these entries actually show the source code file names in blue, and these are referencing our source code files. And both of these are MainActivity. Now for our source code files, we can actually use those like hyperlinks. So let me take my mouse over to the call for saveNote, which is our MainActivity, line 114, and when I get here I can click on it. And that exception happened as I was getting a reference to a note from the DataManager. And this is inside of our saveNote function, so this is where we're doing the work of getting the contents from the screen to then save any changes made by the user into our DataManager. So that shows us where the exception actually occurred within our code. In our next clip, let's see how we can actually resolve this issue and get it fixed.

Resolving the Cause of an Unhandled Exception
Here we are back in Android Studio, and what we want to do now is figure out how to resolve the unhandled exception that we encountered in the previous clip. Now in the previous clip, we determined that we were running into the problem as we were trying to get back this note from the DataManager as we want to save any changes the user's made to that note. So let's go and add a breakpoint here where we get the note back. Now let's go ahead and launch our code in the debugger. So our app's up and running. We know the problem happens when we create a new note, so we'll click the floating action button to create a new note. We'll give the note a title and some text. So now that we've provided content for the note, let's go ahead and collapse the keyboard, and then we'll click the Back button to return back to our NoteListActivity. But before we reach the NoteListActivity, our MainActivity will do the work to save any changes to the note. And when we do that, we hit the breakpoint in our MainActivity, so let's head back to Android Studio, and then here in Android Studio we can see inside of our saveNote function that when we're attempting to get back the note from the DataManager, we see the value of notePosition is -1. So that's not going to be a valid index. So the problem, of course, is when we create a new note, we never set the proper value for the notePosition, and we know we just made some changes to that code. So let's head up to the top of our MainActivity class. So here at the top of our MainActivity class we have our onCreate function. Remember that the onCreate function calls a function that we just created called createNewNote, and then here inside of createNewNote we actually go ahead and add a new note to the DataManager. But as you recall, we took away the line that actually sets the notePosition. Well, obviously that was a line that we needed because remember that the way the onCreate method works, it goes out to retrieve the notePosition from the Intent that was used to launch this activity. Well, if we're creating a new note, the Intent doesn't contain a notePosition, so our notePosition property receives the value of the constant POSITION_NOT_SET. The POSITION_NOT_SET constant has a value of -1. So when we're creating a new note, we've never done the work to properly set the notePosition property to the position of the note that we just created. So down here in our createNewNote function, we want to go and assign the notePosition, and we want to assign it the position of the note we just created, which is the lastIndex of the DataManager's notes collection. So now that we're setting the notePosition, our app should again work correctly. So let's go ahead and launch it in the debugger. Our app's up and running, so let's go ahead and click the floating action button to create a new note. We'll give the note a title and some text. We'll collapse the keyboard. We'll return back to our NoteListActivity. When we try to do that, we hit our breakpoint, so let's go ahead and switch back to Android Studio. And you notice now, back here in Android studio, as we're about to get the note back, we can see the value of notePosition is now 8. So our notePosition now has a valid value. So if I head over here and I go ahead and release the application, return back to the emulator, and then back here in the emulator let's scroll down to the end of the list, and we can see the list now contains that note that we just created. So we're able to successfully identify the cause of our unhandled exception and get it fixed. So now in our next clip, let's see how to capture logging information from our app.

Logcat
As we're trying to track down specific behaviors in our applications, sometimes the most effective way to do that is to write out logging information. Well, in Android, that's where the logcat system comes in. Logcat is the logging system of Android. It records and manages logging information. To use the logcat system, we have the Log class, and it provides methods for writing information out to logcat. And then Android Studio is able to display the log information from logcat. And not simply display it, but also gives the ability to search and filter those logs. When we write information out to logcat, Logcat takes care of capturing some information for us. It automatically captures the date and time that information was written to logcat, and it also captures process information, things like the app package that's loaded into a process, as well as the process ID. But then it's up to us to manually provide the specific information we want to capture. So we provide the message we want to write to that log entry. Each entry has a tag associated with it. A tag is simply a string value that identifies the source within your application of that log entry. That could be any string you want, but most commonly, we use the class name where that log entry was written from. And then each entry has a priority, and the priority indicates the relative severity of that specific log entry. So when we write the log entry, it's up to us to indicate the priority of that entry. And each entry has a specific priority, and to indicate that priority, the Log class has separate methods for each of those priorities. And indicating the priority does a couple things. One thing it does is label that entry within logcat, so each entry will be labeled with a specific character to identify the priority of that entry. But priorities are also important when it comes to viewing the entries because we can filter the entries based on their priority. Now when we indicate the priority we want to filter on, that doesn't show only that priority. Selecting the priority we want to filter on will show all entries at that priority or higher. So let's take a look at the available priorities. Now the most severe priority is priority Assert, and entries that have a priority Assert are labeled with the letter A. Now we don't use priority Assert very often. Assert is used only when something is a catastrophic issue, something you never expect to happen. To give us a sense of how severe the Assert priority is, the Log class method we use to write assert priority entries is Log. wtf. Now according to the documentation, wtf stands for what a terrible failure. Now the next priority below Assert is priority Error. Each entry with priority Error is labeled with the letter E. Now this is the priority we most commonly use when our application experiences an error, and we write these entries out with Log. e. We then have priority Warning, which is labeled with a W, and this is where we want to capture warning information, things that may not be an actual error, but something we want to note that's going on inside of our application. We write these out with Log. w. We then have priority Info. These entries are labeled with an I, and this is how we capture just general information we want to log within our application. These are written out with Log. i. Then we have priority Debug. These are labeled with a D, and as the name indicates, this is debug information we want to track that's going on inside of our application. These are written out with Log. d. And then our lowest priority is Verbose. These are labeled with a V, and these are messages you write out just to capture detail behavior going on inside of your application. These are written out with Log. v. In general, you never want to ship a production application that includes log entries of priority Verbose or priority Debug. So now looking at these various priorities, when it comes to writing information out to the log system, as we head down the table, we're logging information out at increasingly severe priorities. So Verbose is the least severe priority. Assert is the most severe priority. But now when it comes to filtering information that we're viewing from the logs, as we head up the table, these selections each become more inclusive. So if I'm viewing the logs from Android Studio and I set the filter priority to Assert, the only entries I would see are those entries with priority Assert. If I then selected the filter priority of Error, the entries I would see would include both Error priority entries, as well as Assert priority entries. If I selected priority Info, I would see all entries at a priority of Info, Warning, Error, or Assert. And of course, if I want to see all the entries that are being logged, I would select priority Verbose. All right, so you get a better sense of how all this works. In our next clip, we'll start adding some logging information to our app.

Using Logcat
Here we are back in Android Studio. What we want to do now is add some logging information to our app. Now, the class we're currently looking at is our MainActivity class, and, again, this is the class that displays the information for an individual note. Now remember, a key part of adding our logging information is the tag, and the tag identifies the source within our application where a particular log entry is coming from. And for the tag, we most commonly use the class name. So let's go ahead and declare a private read-only property here named tag, and for its value, we'll give it the name of our class, MainActivity. So that give us our tag property, and we'll use that for all the log entries that we write from within this class. Now you can log any information you'd like to. One of things that I like to do when I'm developing an application is add log entries with a priority of Debug for all the lifecycle methods. So you can see here we have our onCreate method, so at the end of that method, let's use the log class's D method to write a Debug priority entry. We'll specify the tag, and then for the log message, let's just use the method name, onCreate. So now each time the onCreate method runs, I have a Debug priority log entry containing the name of the method onCreate. Now this class also has an onPause lifecycle method, and I want to go and write out of log entry whenever that method is called as well. Now to get down to that method, I could simply scroll down and look through the source code until I find it, and in a small class like this, that might work just fine. But as a class gets more complex, finding the individual methods within the class can become difficult. So to help us with that, Android Studio includes this Structure tab. So let's head over to the Structure tab, let's go and select it, and you can see it shows the contents of this file. The file contains the MainActivity class, and we can see all the properties and functions within the class. So I want to go down to the onPause function. I'll go ahead and select that. And of course, when I do that, over my source code window I'm now at the onPause function. So I want to write another Debug priority entry, so I'll say Log. d, and then I'll write out the tag and the message onPause. So now both of my lifecycle methods write out Debug priority entries. But now something else that might be helpful to capture within this class is information about the position of the note being displayed. Now we do all that work in our displayNote function. So to get there, we can see displayNote over in our Structure window. I'll go ahead and select displayNote, and that takes me to displayNote over my source code window. So now to give us some more room, let me go ahead and collapse the Structure window. You can see here in displayNote where we use the notePosition to get back to selected note, so just before that is probably a really good place to write out the value of our notePosition. Now when I write this out, I'm going to give this a slightly higher priority. Rather than making this a Eebug priority message, let's go ahead and make this an Info priority message. So I'll use Log. i. We'll write out the tag. For the message, let's write out the literal text, Displaying note for position. And then what I want to see is the actual value of the notePosition property. Now to help us out with that, Kotlin supports something known as string templates, and string templates allow us to put things like variables and properties within a string, and Kotlin takes care of doing the work of extracting the value. So the way I use a string template is I place a dollar sign followed by the value that I want, which in this case is notePosition. So what that causes to have happen is when this log entry is written we'll get that literal text displaying note for position, but then Kotlin will actually get the value of the notePosition property and write that out. Now the thing I want to really reinforce, string templates are not specific to logging. String templates are a fundamental feature of strings within Kotlin. So anytime you want to substitute a value within a string, you can use string templates. Now there's one more log entry that's probably worth writing. Notice in the code just above where we are we have this check for an error situation. So if we get a notePosition beyond the last index of our notes collection, that's an error. Well, we should probably go ahead and log that out as well. I'm going to log it with an Error priority, so we'll use the log class's E method. We'll give it the tag. Then for the message, let's say Invalid note position, and then we want the value of our notePosition, so we'll again use a string template to get the value of our notePosition property. So now that tells us that we've encountered an invalid notePosition, but it would actually be nice to know what the maximum valid position is. So let's go ahead and add some more literal text that says comma max valid position, and the max valid position is found by going to our DataManager object, it's notes collection, and then that lastIndex property. So let's use a string template, so we'll say $DataManager. notes. lastIndex. Now that is a valid string template, but it won't give us back what we expect. The way I have this currently written, the string template would simply return the string value of the DataManager object. In other words, it would call toString on DataManager, but then the. notes. lastIndex would simply be the literal text that's written out. If I want that entire block of code to actually be part of the string template, I need to enclose it in curly braces, so let's go ahead and do that. So now that string template will resolve the entire value of DataManager. notes. lastIndex. So in the unlikely event that we receive a note position beyond the end of the notes collection, we would actually write out the position we were trying to access along with the maximum valid position that we can use. All right, so that takes care of writing out all of our log information. In our next clip, let's see what it looks like when we view it within Android Studio.

Viewing, Searching, and Filtering Logcat Entries
Here we are back in Android Studio, and what we want to do now is take a look at the logcat output produced by our application. So now the way we see the logcat output is by using the Logcat window of Android Studio. So you can see we have the Logcat tab down here near the bottom, so let's go and expand that. And when I do, you can see there's already a bunch of messages written out there. So anytime I'm about to run my app, one of the first things I do is just go up here and clear out the Logcat window. So to do that, just move my cursor up in the Logcat window, I'll right-click, and I'll choose Clear logcat. And I try to do that each time before I run the app just to make sure I don't have any old messages hanging around. So now we're ready to go ahead and launch our app. And it doesn't matter how we launch it. We can launch it in a debugger, or we can just launch it normally. Cool thing about logcat is the output is produced no matter how the application is run. So I'll go ahead and just start up my app. So you can see here our app is up and running. If you look in the background where we have Android Studio, you can see we've already started generating some output messages. So now from here within the app, let's go ahead and choose a note. And when I do that, you can see more messages are generated in the background. Let's head down to our Back button. We'll go back to our NoteListActivity. Now let's go up here and choose another note. So I'll choose that note, and then we'll go and click the Back button again. All right, so we should have some good logcat output, so let's head back to Android Studio and see what it looks like. So now here within our Logcat window, we can see the logcat entries produced by our app. Now before we look at the details of those entries, let's take a look at a few of the options here that control what appears in the Logcat window. Now the first thing we'll take a look at is this drop-down all the way on the left here. Let me go and expand that. And this drop-down controls which device or emulator we're capturing output from. Now I currently only have a single emulator running, so as a result, there's only one selection in this drop-down. But if I had multiple emulators running or I had an emulator and a physical device connected, they would all appear in this drop-down, and I will only capture output from the one I have selected. So now this next drop-down shows the list of apps on the selected device. So if I expand this, I can see the apps that are currently running on the emulator, and our NoteKeeper app is the one that's currently selected. So let's go ahead and collapse this. And the selected app is important because of the filter drop-down that we have all the way here on the right. Notice that the filter that's currently set is the one that says show only the selected application. So as long as we have that option set, the only output we see will be the one from the application we have selected in this drop-down. We'll talk more about filters in just a moment. But now before we get into all that, remember the key part of the way log entries are written is based on their priority, and we control which priorities are displayed with this drop-down. So if I go and expand that and say I switch it from Verbose down to Info and I select that, notice that I'm not seeing any debug messages. I'm only seeing those messages that have a priority of Info or higher, which would include, of course, my info messages, but also any warning messages that are being generated from within the application as well. If I head back up to this drop-down, expand it, and then choose Verbose, you can see that I still have the info and warning messages, but I also have debug messages as well. Now, in addition to those filters, we can also use simple string filters. So if I head up to this field here, I go and click in it, any text I type here will be used to do simple string filtering. So let's type the text a-c-t-i-v. So now by typing that, this text, a-c-t-i-v, is being used into a filter based on the contents of the entire entry. So the entries that are tagged with MainActivity appear because MainActivity includes the characters a-c-t-i-v. But notice also there's some output being generated by the OpenGLRenderer, and those entries have messages that include the characters a-c-t-i-v. So in this case, we're doing just a very simple string filtering across the entire entry. Although we may sometimes want to do that, we generally want to make filters that are a little bit more specific than that. We generally want to filter based on specific fields in the entries. So let me go and clear the string filter out. I can do that by just clicking on the X here. And now let's go ahead and define a filter based on the tag. So the way we do that is by going to our filters drop-down over here on the right. We'll expand that. I'm going to head down here where it says Edit Filter Configuration and choose that. And this brings up a dialog that lets me specify filters based on individual fields. So if I want to filter only those entries that are tagged with MainActivity, here where it says Log Tag, I'll enter the text MainActivity. Then I'll go ahead and name the filter. I can name it anything I want, but I'll just go ahead and call it MainActivity. So now when I select that filter, we only have the entries that are tagged with MainActivity. And while we're here, let's take a look at all the information that appears inside of each entry. So let's look at our first entry here. So notice that we have the date and timestamp of when the entry was created. We have the information about the app that generated the entry. Then after that we have the character I. That I indicates that this is an Info priority entry. Then we have the slash followed by MainActivity. MainActivity, of course, is our tag. And then after the colon we have the actual message. That was the message that we wrote out into this entry. Now notice here that our message says Displaying note for position, and we have the value 0. So that shows us that Kotlin properly provided the value of our notePosition property when building the string. And because our entries are composed of all these individual fields, it's really easy for us to create very specific filters. So let's head back over to our filter drop-down. We'll expand that. We'll again go down to where it says Edit Filter Configuration. We'll choose that. And then notice here within this dialog, in addition to being able to filter on the Tag field, we could also filter on the Message field, the Package field, and as part of the filter, we can even specify what log level we want included in that filter. So as we can see, these filters can be very specific, and the filtering can be tied to individual log fields. So let's go ahead and cancel out of here. So let's again expand our filter drop-down, and let's switch back to Show only selected application. And so once we do that, we have a whole bunch of entries again appearing in our Logcat window. Now everything we've talked about so far has given us the ability to control what appears in the window. Sometimes we don't want to change what appears in the window, we just want to search through the contents of the window, and we can do that by using the find feature. So the way we find is just by going ahead and clicking somewhere inside the Logcat window, and then do Ctrl+F, and that allows us to do a simple search throughout the displayed content. So if I want to search for like the word position. So notice that when I do that, we can see here in our find bar that there were two matches found, so then I can use these arrows to move through those matches. So if I want to try and move to the next match, I'll choose the down arrow, and when I do that, it says position not found because it's already positioned at the last match. So I can go ahead and find the previous match by going to the up arrow, and that moves me back to the previous match. I can go ahead and clear out the find by clicking on this X here. And to close the find bar, I can head over to the X all the way on the right and choose that. So as you can see, logcat gives us everything we need to capture logging information from our app. Then using Android Studio, we can filter, search, and analyze the information produced by our application.

Summary
To wrap up, here's some of the key things we want to remember from this module. Remember that the Android Studio debugger allows us to control code execution. We're able to set breakpoints that will cause the execution of our application to pause when we reach the statement that contains the breakpoint. Now normally a breakpoint pauses the execution of our program whenever that breakpoint is encountered, but we also have the option of associating conditions with the breakpoints. In that case, the breakpoint will only pause our application when the specified condition is met. So once our application pauses at a particular breakpoint, we have a number of options for then stepping through our code. And in addition to being able to step through the code, we can also view data values within our application. So we can view the values stored in individual variables or properties within our app, and we can also do on-the-fly statement evaluation that actually allows us to determine the value of a particular statement at the current execution point in the program. We then took a look at how to deal with unhandled exceptions, and we saw that Android Studio allows us to see the crash information associated with an unhandled exception. And we can see that information in Android Studio's debug window after we select the Console tab. And the Console tab includes important information about the exception itself, as well as the call stack that led to the exception. And within that call stack, anywhere our source code appears, the call stack will include a link that allows us to jump directly to that point in our code. And then we finished up with logcat. Remember that logcat is the logging system for Android. We add information to the logcat system using the Log class. Remember, the Log class includes a variety of methods that allow us to write that information at a specified priority. And then the information we write to logcat can be viewed from the Android Studio Logcat window, and that allows us to view, filter, and search the logcat information. All right, that wraps up this module. In our next module, we'll take a look at the Android Studio build system and some of the key libraries we use when working with our applications.

Understanding Android Build Process, KTX, and Support Libraries
Introduction
Welcome to our next module, Understanding Android Build Process, KTX, and Support Libraries. This is part of the Pluralsight course Android Apps with Kotlin: Tools and Testing. My name is Jim Wilson. In this module, we'll look at how to manage the build process of our applications. So we'll start out with an overview of the Android build process and the important role of a tool called Gradle. We'll then look at how we modify Gradle parameters. We'll see how to specify dependencies for our application in Gradle. We'll then look at the important role of something called the Android Support Library, and then we'll look at two new libraries called AndroidX and Android KTX.

Android Build Process and Gradle
When it comes to building our Android applications, if we had to manually manage all the details involved in building the application, it would actually be somewhat challenging because there's a number of different tools that come together to actually complete the full build process. So to help us with that, Android Studio leverages something called Gradle, which simplifies our build process. Now Gradle is actually a general purpose build system, and there's an Android plugin that plugs into Gradle to actually give us some Android-oriented features. So if we think about what goes on when we build our Android applications, now we know we have our source files and our resource files, and as your applicants get more complex there'll be a few other file types you might build into that as well. And as you have those files, we ultimately want to produce what's called an Android Package file, or what we commonly called an APK file. Now obviously we can't get from those source and resource files directly to that APK file. Something has to happen in between there. Now, of course, we know that there are compilers, but there's also dependencies. Some of those dependencies are Android specific. Some of them might come from third parties. Some of them might even be other things that we're creating ourselves that go into making this application. So as all that stuff passes through the compilers, we ultimately produce some intermediate files. So now we've got to get from those intermediate files out to the APK, so there's actually an APK Packager tool. And of course, the intermediate files go into the APK Packager, but there's more to it. There's still things that need to be known, like what's the version information for our application? What's the minimum version of the SDK that we want to support? What target SDK have we actually tested this against? So all that stuff has to be managed so that we can ultimately create an APK file that is a deployable version of our application. So to help us with all that, that's were Gradle comes in. Gradle actually automates all this for us so that we can kind of focus on just building our application. And keeping track of all that information in terms of dependencies and so forth is actually centralized with Gradle. There are a few different files associated with Gradle, but the one we normally deal with are the ones called build. gradle, so they give us a place to kind of put the configuration information of our build right inside just a few files. Now Gradle is extremely powerful, and it's very flexible. In fact, it actually has its own domain-specific language. So in effect, it actually has its own kind of programming language. And so as you work with Android more and more, it's worth trying to understand Gradle as you use it because it gives you a lot of flexibility, allows you to create different build variations of your program relatively easily, so it's really worth understanding. But it turns out that the common things that we deal with in Gradle are actually pretty easily managed because our Android Studio projects will actually generate some starter build. gradle files for us. And most of the things that we commonly need to do can really just be simple edits to those Gradle files. Now the Gradle files are always going to give you the most complete access to the capability of Gradle, but Android Studio helps out that many of the changes that we commonly want to make can also be made through the Android Studio UI. So if we go to the File menu and choose Project Structure, we could actually set a lot of things from inside of there. Now they'll ultimately end up in the Gradle file, but it gives us a UI for doing it. To get a better sense of how all this comes together, let's take a look at some of the Gradle values in our next clip.

Modifying Gradle Parameters
Here we are back in Android Studio, and what we want to do now is look at how we can view and modify our app's Gradle parameters. To get started, we'll head over here our Project window. Remember that the Project window supports a few different views. We want to be sure we have our Android view selected. With the Android view selected, notice that one of the sections in the Project window is labeled Gradle Scripts. So let's go ahead and expand that. And when we do that, we see the list of files that affect Gradle. Now, the ones that are most interesting to us are the ones named build. gradle. And as you can see, our project contains two build. gradle files. The first one is the project-level file, the other one is the module-level file. Now in Android Studio terms, a project represents the top-level grouping of our work, so projects are divided into modules. In our case, our project has one module, which is our app module, and the app module contains everything specific to creating our application. Now it's worth noting that in some scenarios a project may have multiple modules, and in those scenarios, it's common to have the other modules be what are called library modules. Library modules are helpful when you have code that you'd like to be able to easily reuse across different apps. Now here in our project, again we have the two build. gradle files. The first one is the project-related file, and that's where the settings related to the overall project appear. Now in general, we don't need to work with the project-related file. What we'll tend to do is do much more of our work in the module's build. gradle file because, again, that's the settings that are particular to our module, again, in our case, the settings that are particular to our app. So let's head down to that file. Then I'll double-click to open it up. And when we open it up, we can see the Gradle settings for our application. And here within the file we have a section labeled android, and the android section contains the general settings for building this module. For example, within this section we have compileSdkVersion, and that indicates what version of the Android SDK we're using, which in our case is Android SDK 27, and as we know, that corresponds to Android 8. 1. Then within the android section, we have this section called defaultConfig. Now the reason we have this defaultConfig section is because Gradle supports having multiple configurations for the same module, and that's great when you may want to have different behaviors targeting different platforms. But for this simple case, we have just this one, default onfig. Now within defaultConfig we can provide information like the applicationId, which is what our application is going to be known as in the Play Store. We have the minSdkVersion, which indicates the minimum version of Android our app supports. Then we have the targetSdkVersion. The targetSdkVersion indicates what kind of behavior our app is expecting. So if at some point in the future Android were to change the behavior of certain APIs, Android would know that our app expects those APIs to behave as they did under API 27. So that targetSdkVersion allows Android to provide our app with a consistent execution environment. Now next we have the versionCode and versionName. The versionName is the version as it's displayed in things like the Play Store and on the device's settings. The versionCode is the integer version, which is just an incrementing value to identify when we're moving from one version to the next. Now these two separate ways of identifying a version should look pretty familiar because it's the way Android versioning works. Remember that each Android platform has a version name, things like 8. 1, 8. 0, 7. 0, and so forth, but then there's also the integer versions like 27, 26, and 25. Now with the versionCode and versionName, we're applying this same idea to our app. The versionCode provides an integer version, which will have increasing values to indicate that we're moving from one version to the next, and then the versionName is just a friendly name we use to display our versions. Now one thing to keep in mind is that if you make any changes to the Gradle file, you'll need to sync Gradle. And when you make those changes, in general, Android Studio will display a bar across the top indicating that you need to sync now. And what it means to sync is that Gradle needs to check, make sure all your settings make sense, and then assure that everything we need to perform the build with those settings is available. But now we don't have to wait for Android Studio to ask us if we want to sync. We can force a sync by clicking on the Gradle Sync button up here at the top. And when we do the sync, it will again confirm that our Gradle settings are valid and make sure that we have everything we need to do our build. Now in addition to being able to control the Gradle settings inside the build. gradle file, we can also control them through the Android Studio UI. So let's go up here to our File menu, we'll select file, then we'll head down to Project Structure, and we'll go ahead and select that. And when we do that, it opens up our Project Structure dialog. Now there are a number of different sections down the left-hand side of this dialog, and the one we want is the one that's associated with our module, which is again our app module. And then we have these various tabs across the top, and we currently have the Properties tab selected. And here within the Properties tab, we can see that one of the values is the Compile Sdk Version. And this is the same thing we saw inside the Gradle file. In fact, any changes we make here in the Android Studio UI will automatically change the corresponding value within the build. gradle file. So let's look at another tab. Let's head over here to our Flavors tab. We'll go ahead and select that. So now notice when we select the Flavors tab we see that name, defaultConfig, just like we saw inside of our Gradle file. And then we have a variety of values. So we see our Min Sdk Version, Application Id, and Target Sdk Version. All of these are the same sort of things we saw when we were working in the Gradle file itself. In fact, we even have our Version Code and our Version Name. So as you can see, the Android Studio UI is simply an alternate way to interact with the values contained in the build. gradle files. We can interact with those values here using the UI, or we can edit them directly within the build. gradle file itself. In both cases, we're doing the same thing. We're modifying the build settings of our app. All right, so now in our next clip, let's look at the idea of dependencies.

Understanding Dependecies
As we've mentioned, most applications rarely stand alone. Instead, those applications have dependencies, and so in our build process we have to specify those dependencies. Those dependencies might be an external binary file or they might be a library you're building as part of the same project. But whatever the case, when we're building our application, we need to list our dependencies in Gradle. Now we do that in our build. gradle file in the dependencies block. So in that dependencies block, we need to list any of our direct dependencies, but one thing that's nice about Gradle is that if any of those dependencies also have dependencies, Gradle will take care of going ahead and including those as well. When it comes to dealing with dependencies, there's two basic things we need to understand. The first is dependency types. Dependencies fall into three types. There's module dependencies, which is simply a dependency on another module from your project. There are jar dependencies, which are dependencies on a Java JAR file. And then finally, there are library dependencies, which is dependencies that actually pull things from a repository. A repository is simply a collection of binaries we can access. We can have some repositories on our local machine. So we can have the Android Support repository and the Google repositories, and these contain binaries that we commonly need to build our Android applications. So we don't have to do anything special to get Gradle to look on our local machine for these repositories. Beyond those repositories, they actually have to be specified. Now when we generate a brand-new Android Studio project, the build. gradle files that are generated for us include a reference to the jcenter repository, which is just a massive Java repository. But you can also add other repositories if you need to by modifying the Gradle file to look for those repositories as well. Now in addition to understanding dependency types, we also need to understand how we associate dependencies. Now for most dependencies, want to associate them with all of our build variants. So to do that, we use the implementation directive. With the implementation directive, we identify a particular dependency, and that dependency is applied to all of our build variants, in other words, all the different kind of builds that we do. But now something we'll talk about a bit later in this course is testing, and we can build testing specific variants. There are two kinds of tests that we commonly perform. One is JVM tests, in other words, tests that rely on just the Java Runtime Environment. Now these are tests we use to validate our app's logic, and these are tests that don't need the whole Android environment. So any dependencies we want to specify particular to JVM tests, instead of using the implementation directive, we use the testImplementation directive. Now the other kind of tests we commonly perform are what are called instrumentation tests, and these are tests that rely on the Android environment. To specify a dependency for these kind of tests, we use the androidTestimplementation directive. Now as I mentioned, we'll talk about these testing scenarios much more later in this course. The key thing we need to understand for right now is that when we specify a dependency we need to indicate whether that dependency applies to all of our build variants or is it specific to a particular test build? Now to get a better sense of all this, in our next clip, we'll look at how we specify dependencies in our Android Studio project.

Specifying Gradle Dependencies
Here we are back in Android Studio, and what we want to do now is take a look at the dependency information for our application. Now I currently have our app module's build. gradle file open and have scrolled down to the bottom of the file. You can see here the last section in the file is the dependencies section. Notice that most the entries inside of the dependencies section start with the keyword implementation. So those lines are specifying dependencies that affect all of our build variants, our regular application build, as well as our JVM tests, and our automated user interface tests. That we have a line here that starts with the keyword testImplementation, so that's a dependency specific to our JVM tests. And then we have a couple lines here that start with androidTestImplementation, and those are entries specific to our automated user interface tests. Notice that the first entry under dependencies starts out with the implementation keyword followed by fileTree, and fileTree has two values specified inside of it, a dir value of libs and an include value of *. jar. So what this does for us is it allows us to add JAR files as dependencies by simply copying those files into the libs folder underneath our project folder. Now notice that a number of these dependencies have fairly long names. These are all library dependencies. These guys will be pulled down from our repository, and most of these come from the Support Library, which we'll talk more about shortly. So let's take a look at this entry. Notice that the name of this dependency is com. android. support:appcompat-v7:27. 1. 0 Now that can be kind of an intimidating name, but if we look at the individual parts, they're actually fairly easy to understand. Now the parts of the name are separated by colons. So you notice before the first colon we have com. android. support. And that's what's referred to as the namespace group, so that's just a way to group libraries together. Then appcompat-v7, that's the actual library name itself. And then the last section, 27. 1. 0, is the release version of that library. Now although these library names can look kind of complex, we don't have to get too worried about that because in general we can find the full name of the library we need just by looking at the documentation for it. And also remember we're never required to manually type these entries into the build. gradle file unless we want to. We always have the option of adding dependencies by using the Android Studio user interface. So let's take a look at that. Let's go up here to our File menu. I'll expand that. We'll go down to Project Structure. I'll choose that. So now in our Project Structure we have our app module selected. If we look across the tabs at the top, the rightmost tab is labeled Dependencies. I'll go ahead and select the Dependencies tab. And once I select that tab, you can see the dependencies listed. And these are the same values we saw in the build. gradle file. Now if we want to add another dependency using the user interface here, we can head over to that plus sign, I'll click on the plus sign, and then you'll notice here it allows me to specify what kind of dependency I want to add. Now if we start down at the bottom, the Module dependency will allow me to add a dependency from another module inside the same project. So if I selected that, a list of the module names would show up, and I would choose which one I want. Then we have Jar dependency here. That allows me to add a dependency to a JAR file. If I select that, Android Studio will allow me to browse my local system and select the JAR file I want to add a dependency to. And then finally, we have our Library dependency. Let's go ahead and select that. And when I select that, that gives me a list of libraries that I can then select from to add as a dependency to my application. Now I can select the name of the library from this scrolling window down here towards the bottom of the dialog, or if I prefer, I can start typing part of the name of the library, and Android Studio will start filtering the list based on the value I type in here. So let's go ahead and close this dialog, and we'll close our Project Structure dialog, and that takes us back to our module's build. gradle file. So now that we've seen the list of dependencies that our application already has, in our next clip, let's make a change to our application that requires us to add an additional library dependency.

Specifying kotlin-reflect Dependency
Here we are back in Android Studio. What we're going to do now is make a small change to our application that requires us to add an additional dependency. Now we're currently looking at our application's MainActivity class. As you recall from earlier in the course when we were talking about logcat, we added a property here named tag that identified the source of any logcat information we wrote from this class. Now the way we've declared our tag property, we've set its value to the literal string MainActivity. That, of course, means that if we change the name of this class, we'll also have to remember to change the value of that tag property. Also, this tag property is something we want to include as part of any class that writes out logcat information, so it would be nice that rather than setting this to a literal string, we could set it to a value that automatically set it to the class's current name. And we can actually do that by using the reflection features of Kotlin. Reflection allows us at runtime to learn information about types and their capabilities. So to do that, let's get rid of this literal string, MainActivity. We'll then use a this reference to refer to our current class. To get information about that class, we'll use ::class, and then the thing we want to know about this class is its simple name, in other words, the non-packaged qualified name. So to get to that, we use the property simpleName. So now with that, the tag property will automatically be set to the name of the current class. And that helps us out in two ways. One, if we change the name of our MainActivity class, the value of our tag will automatically update. Also, we can now take the line that declares this property, paste it into any class, and it will automatically have the name of that class. So that's just a really good way to set the tag property we're using for our logcat information. But now to use the reflection information, we'll need to add another dependency to our application's build process. So let's head over to our app module's build. gradle file. So now we're looking at our app module's build. gradle file, and we want to specify a dependency on the Reflection Library. Now we want that dependency to be part of all of our build variants, so we'll use the implementation keyword, and then we want to specify the naming information for that library. Now most of the libraries related to Kotlin are part of the namespace group org. jetbrains. kotlin. We already have a dependency for our library that's part of that namespace group. So what I'll do is I'll copy the information from that line above and just paste it right here. Then what I'll do is change the part of the library name where it says kotlin-stdlib-jdk7 to instead be kotlin-reflect. So now I've specified a dependency to a library that's part of the namespace group org. jetbrains. kotlin, then it's the library kotlin-reflect, and then remember we said that after the last colon is actually the release version. But that release version is written kind of funny. Instead of actually having a version number there, it's $kotlin_version. And what's happening here is that the way that the project is generated, rather than hard coding the Kotlin version number, it instead uses a variable to specify the Kotlin version number. That way any time we want to move from one Kotlin version to another, we can simply change the value of that variable. And the value of that variable is actually specified in our project's build. gradle file. So if I switch over to the project's build. gradle file, you can see here where we specify this ext. kotlin_version, and it's currently set to the value 1. 2. 41. So anywhere in our build. gradle files where we refer to $kotlin_version, Gradle will substitute that value of 1. 2. 41. And again, that just makes it easy for us to evolve from one Kotlin version to another as part of our build. So let's head back to our module's build. gradle file. So now we've made a change to our Gradle file, so we want to go ahead and sync it. So I head over here where it says Sync Now, I'll choose sync now, and now our project is all synced based on our current Gradle values. So with that done, I could simply build this and run it. And now with the value of our tag property, we take advantage of reflection rather than using that hard-coded string that we had before. So now we've got that in place. In our next clip, let's talk about something known as the Android Support Library. The Android Support Library is the source of many of the dependencies that our application will rely on.

Android Support Library
The Android Support Library is a really important part of Android development. Basically, it supplements the Android SDK, and one of the key things it does is provide backward compatibility. Because one of the issues we often have with Android is that as a new version of Android is released, it introduces new features, but there's still a large user base using older devices that may not have that feature. So to help that, initially the Android Support Library was focused on this idea of adding backward compatibility. Basically, it made some of the newer platform features available to older versions of the Android platform. And it does this by providing alternate classes. So these classes have different names to indicate that they're Support Library classes rather than Android SDK classes. And as Support Library classes, they make features available that may not otherwise be available on a particular platform version. And although that was the initial focus of the Android Support Library, over time its capabilities grew, and then other classes such as convenience and helper classes were added. And these were features that were not part of any version of the platform. And so what this did was make features and capabilities available without being tied to a particular Android version. And one of the places where this really comes up is with the user interface features, and we'll talk about some of those featrues later in this series. We'll talk about things like the RecyclerView, which allows us to create very rich appearing lists, or the CardView class, which allows us to create an appearance of a three-dimensional card within our app. But then as time went on, it went even beyond that. So now the Android Support Library includes many features related to debugging and testing our app, as well as other utilities. So the capability to do automated testing is part of the Android Support Library. There are features in the Android Support Library that allow us to do enhanced code checks within our app. And then there are other special case utilities that are helpful in certain deployment scenarios. Now as I mentioned, the Android Support Library was initially very focused. It was focused on this idea of backward compatibility. So the Android Support Library itself was actually quite small, and there was just a single library known as the Android Support Library. But then as time went on and more features were added to the library, the library got bigger and continued to get bigger until this idea of a single support library file was just too unmanageable. So to help that, they then reorganized the Android Support Library, and they started to break it up into individual libraries, and those individual libraries were part of the overall umbrella of the Android Support Library. And then to make them easier to work with, they then organized them into groupings, and much of that grouping was based on platform support. And the name of the library historically indicated the minimum version of the platform that that library could be used with. So if we look at some examples, there was the V4 support libraries. And that didn't mean that this was the fourth version of the Android support libraries. What it meant was that it's the version of support libraries that will work with any Android device running API level 4 and up. Now API level 4 is Android 1. 6. And then there were the V7 support libraries. Again, this wasn't the seventh version of the support libraries. These were the support libraries that worked with API level 7 and up. API level 7 is Android 2. 1. Or we have the V13 support libraries, and those are the libraries that work with API level 13 and up, and API level 13 is Android 3. But now, of course, API level 4, API level 7, API level 13, these are all really old versions of Android, and they're not versions of the Android platform you're likely to encounter. So more recently, this versioning idea has changed. At the time of recording this video, none of these support libraries support any Android version below API level 14. So that means that the minimum supported version for the V4 support libraries is API level 14. The minimum supported version for the V7 support libraries is API level 14. Same thing for the V13 libraries. So obviously this whole version support idea is getting a bit complicated. So let's take a look at a Support Library entry we might find in our build. gradle file. So if we look at the first part of the library name, that's the com. android. support. Well, that's the namespace group, and com. android. support is the Support Library's main namespace group. In other words, that's the way library is grouped together. Then we have the appcompat. So that indicates that it's an app compatibility library. So in other words, it adds compatibility for features to older versions of the Android platform. And the library name includes that -v7, so that says that the minimum supported platform is API level 7, except we know that's actually not the case. Even though it's -v7, the minimum supported platform is still API level 14. But then here at the end we have another version number, and that's actually the Support Library's release version. So that's the version of the Support Library that this library is part of. So as I mentioned, the way the Support Library is currently organized it's becoming very hard to work with and very hard to manage, so we need to start looking towards a better way to work with the capabilities of Support Library, but organized in a way that's easier to work with, and so that's what we'll take a look at in our next clip.

AndroidX and Android KTX
As we mentioned earlier, the Android Support Library is a really important part of our application development. It includes a lot of types that are just really helpful in enabling us to build richer, more powerful applications. But the Android Support Library has been around a long time. It was initially released back in 2011. And as we talked about, as it's evolved over time, its organization has become very difficult to manage. It can be hard to work with and difficult to understand how things are actually arranged within the library. The other issue with the Android Support Library is it uses relatively tightly coupled versioning. The major parts of the Support Library are released in consistent versions. What that ultimately means is we have to put very tightly coupled versioning across parts of the library that may not be that closely related, and as a result, feature releases can get held up. So to help with that issue, at the time of recording this video, Android is in the process of moving from the Android Support Library to something known as AndroidX. And key part of AndroidX is that it's a refactor of the Android Support Library, so many of the same types that are already in the Android Support Library are simply being moved over to AndroidX. And as a part of moving over to AndroidX, they're actually being reorganized and refactored to make it much simpler to manage the contents of the library. In addition, the versioning with the library is being broken apart. As opposed to synchronizing version releases across the whole library, each part of the library is independently versioned, which allows each part of the library to be released on its own version schedule, which speeds up the release of new features. Now at the time of recording this, AndroidX is in early beta, but it shouldn't be long until it's available as a full-blown production library. So just to take a quick look at how the library is refactored to AndroidX, first, looking at an implementation entry under the Support Library, remember that we had our namespace group, and much of the Support Library was in the namespace group com. android. support. Well, if we want the app compatibility classes, we had appcompat, but, of course, remember that it actually had that minimum API level as part of the name, but that minimum API level was not actually meaningful anymore. And then, of course, we had the release version of the library. And again, huge versions of the support library were versioned together, which often held up feature releases. So now moving to AndroidX, if we wanted a type that was in the appcompat-v7 library, now under AndroidX it would be in the namespace group androidx. appcompat. So you can see the namespace groupings are now different, the library itself is simply called appcompat, the concept of the minimum API level is no longer part of the name at all, and then versioning is restarted down at version 1. So now looking at the types within our code, well if we were to look at most Android applications, one of the most commonly used app compatibility classes is AppCompatActivity. It's the class that enables us to create activities that work consistently across Android versions. Under the Support Library, in order to use the class AppCompatActivity, we would import android. support. v7. app. AppCompatActivity in a very long name with lots of parts to it. Refactoring over to AndroidX, the same import now becomes import androidx. app. AppCompatActivity. And again, AndroidX greatly simplifies accessing and interacting with the organization of the types. Now AndroidX is not simply a refactor. There's also the addition of new types. And a key part of AndroidX that's being added is something called Android KTX. Now as I mentioned, it's part of AndroidX, but this is a Kotlin-specific library, and it's a Kotlin library designed to simplify our Android development. And what it does is it leverages language features in Kotlin that makes it much easier to work with classes that come from the Support Library, as well as classes that are part of the standard Android SDK. And in many cases, this library can substantially reduce the amount of code that we have to write. In many cases, code that would've been 10 lines or more working with the libraries directly, Android KTX can reduce to just two or three lines. Now at the time that I'm recording this video, Android KTX is still in alpha, but I don't think it'll be long till it's released in beta and then finally in production. So this is a library that you want to watch for. Now Android KTX will be broken up into various libraries, but the core library is actually androidx. core:core-ktx and then followed by whatever its current version number is. So keep a watch out for this because it'll really be a helpful part in developing applications using Kotlin.

Summary
Throughout this module, we've been looking at Gradle, and Gradle simplifies the process of building our applications because there's a number of things that have to be managed during the Android build process. And Gradle insulates us from those details and allows us to focus much more on the general idea of what we need when we're doing our builds. Now Gradle is a very powerful build system, and it's extremely flexible, so there are a number of settings available to affect our builds. Those settings are stored within files named build. gradle. Now we can edit the build. gradle file directly if we want to do it that way, or many of the settings that we commonly interact with can actually be edited using the Android Studio user interface. One of the most common things we have to affect within our build. gradle files are dependencies, and that's because our applications rarely stand alone. We're going to rely on other code to do our builds, and they can come from any number of places. So there are a number of dependency types that we can access from inside of our Gradle files. We can access other modules within the same project, we can leverage existing JAR files, and we have libraries that allow us to pull down dependencies from a repository. Now when we associate those dependencies, we can associate them with specific build types. So we can associate a dependency with all of our builds, or we can associate a dependency with a particular type of test. We can associate with our JVM tests, or we can associate it with our automated user interface tests. Now dependencies can come from many different places, but one of the most common places we pull our dependencies from is the Android Support Library. And the Android Support Library includes libraries that do a wide variety of things. Much of the features of the Android Support Library are focused on improving compatibility across API levels, but it also provides many features beyond that. But now because the Android Support Library has been around so long and has evolved so much, its organization has become a bit complex, so at the time of this recording there's an evolution going on, and we're evolving from Android Support Library to something known as AndroidX. And one of the main things that AndroidX does is it refactors the Android Support Library to make its organization a bit more clear and makes it a bit easier to work with. But AndroidX is not just a simple refactor. There's also new features being added as well. Now one of the key additions to AndroidX is something called Android KTX, and that's a Kotlin-specific library focused on further simplifying the development of our Android applications. And in many cases, Android KTX can greatly reduce the amount of code that we have to write, so you want to really keep your eyes out and watch the evolution of both AndroidX and Android KTX. All right, so that wraps up this module. In our next module, we'll take a look at JVM tests and learn how to use those to automate the testing of our application logic.

Implementing Local Unit Tests
Introduction
Welcome to our next module, Implementing Local Unit Tests. This is part of the Pluralsight course Android Apps with Kotlin: Tools and Testing. My name is Jim Wilson. In this module, we'll start to look at how we can use testing to assure that we deliver quality applications. So we'll start out, we'll look at some of the basic concepts of app testing, we'll then take a look at some of the features that Android Studio provides to allow us to efficiently run our unit tests, we'll see how to create unit tests, we'll take a look at one of the important classes we use in unit testing called the Assert class, and then we'll finish up with a look at how we can assure that our tests run consistently.

Testing Basics
Software testing has been around as long as we've had software development, but for a long time software testing was really kind of an ad hoc process. You'd write some code, you'd run the program, you'd do a few manual tests, things look okay, yeah, I tested my software. But now that's no longer the case. Testing is now a core task of our application development, and it needs to be a core task because it's essential to delivering quality software. Software is just too sophisticated now to rely on a few manual tests to be sure things are okay. Now as we go through the rest of this course and the rest of this series, we're going to focus on a type of testing known as functional testing. And functional testing focuses on the idea of does my application meet the business requirements or specifications? And that's distinctly separate from what we call nonfunctional testing. And nonfunctional testing is testing things that are not part of those core requirements, and that might be things like security testing or performance testing, that sort of thing. So when we look at functional testing, what we're really focused on is verifying that things behave as we expect. But now a key part of that is that being sure that not only do they behave as we expect when we first write them, but making sure that any changes we make don't break things, what we call breaking changes. And that's the idea is that when I originally wrote the code, it was fine, but then I made some changes elsewhere in the application, and that had unexpected side effects that broke other things. So that's going to really be our focus in this idea of functional testing. Now we're going to look at two specific aspects of functional testing. First, in this module, we're going to look at what we call unit testing. And unit testing, as its name implies, is that we want to test the individual units of code. And generally speaking, each unit that we test is going to be relatively simple, so each test unit is really going to focus on a specific feature or behavior. Oftentimes it's just one particular thing a method might do. By doing things that way, we're able to actually verify the fundamental aspects of our application. So as we work with unit testing, we will generally have many unit tests. Because each individual test focuses on a very narrowly defined set of functionality, we're going to need lots of tests to verify all our functionality. Now another kind of testing we'll talk about in the next module focuses on this idea of integration testing. And integration testing is testing how the pieces come together. Basically, we move away from individual features up to application-level behaviors. And often this kind of testing involves testing of the user interface. And again, that's what we'll talk about in the next module. In this module, we'll focus on this idea of unit testing. Now one of the key aspects of using unit testing effectively is that we want to be able to run our tests often. So pretty much after we do any of our code changes, we're going to want to go ahead and run our unit tests, and certainly, before we check our source code into any kind of source code control, we want to go ahead and run our unit tests because we want to always be making sure that things are working as expected. And generally, we want to run all the unit tests. Now as we're going through in the process of making an individual change to our code, we may run one or a few unit tests just to kind of verify that as we go, but no application change we make is complete until all the tests pass. Remember that we're not just trying to test the functionality that we're implementing. We also want to make sure that any changes we make don't break other aspects of our code. So that means then is that if we're going to have a lot of unit tests and we want to run all of them a lot, ideally, we need to be able to run our unit tests quickly so we're not spending a lot of time unnecessarily waiting for these tests to run. So now as we think of this idea of testing our Android applications, this introduces some challenges for us. Remember that our Android applications, in order to fully test them, we actually need the Android environment, or we need all those aspects of Android that we're using to fully test our application. And in order to do that, we're going to have to run those tests on an emulator or on a physical device. But that can make actually running all of our tests all the time kind of challenging. What we really need is a way to efficiently run our unit tests. We want to limit how often we need the full environment so we can do some kind of lighter testing along the way, and we'll talk about how to do that in our next clip.

Efficiently Running Unit Tests
To determine how to most efficiently run our unit tests, we first we have to look at how our applications are constructed. If we look at our Android applications, it really turns out that they're composed of two distinct parts. There's first the logic-based behavior. Those are things that aren't really tied to the Android platform itself. This is the actual logic or calculations that we use, maybe how we deal with data that comes back from the user, or interacting with data storage systems. And then the other part is the part that is tied to our Android-based behavior. Again, this will be our user interface or other distinct features of the Android platform itself. Well, with these two distinct behaviors, we can actually separate our tests out. So we can have one set of tests for our logic-based behavior and then have a separate set of tests for the Android-based behavior. And by doing this, we can efficiently run unit tests that test our logic-based behavior. And the reason we can do that is because these tests can actually run inside of a Java virtual machine. So we can actually leverage the JVM that's on our desktops and run those tests directly on the desktop machine that we use to do our development. And Android Studio lets us do that. Android Studio makes it easy for us to do JVM testing within our Android development environment because our Android Studio prompt text will contain a separate source set for our unit tests. So now those tests are run using something known as JUnit. JUnit is a very powerful and widely used unit testing platform. And by using Junit, we can actually both run and debug our tests. So we can take our test code and just run it, or if we have a problem, we can debug it and step through it line by line if we need to. And by using Junit, we can run a single test, we can run a group of tests, and we can easily run all the tests that we've created to validate our behavior. And then when we run those tests, we can easily display the results of those tests inside of Android Studio, and the display format makes it very easy to see which tests succeed and which tests fail because success or failure is indicated by the color of the test results. Now when we create our tests, each test is created as a separate method. So all the code to run the test is contained in a method, and then we mark that method with the @Test annotation. And then from there, JUnit handles all the details. We get to focus just on the code required to run the test. All the detail of running the test, managing tests, and displaying the test results are handled by JUnit. Now with each test being a separate method, we're going to want to group those tests together, and we group them by simply using classes. Now these classes exist primarily for organizational purposes. There's no real magic to which tests you put into which class. What we generally do is take a group of related tests and put them in the same class because it makes it easy for us to manage those tests as a group and easily run those related tests together. Alright, so now in our next clip, we'll head over to our source code, and we'll add a unit test.

Adding a Unit Test
Here we are in Android Studio, and what we want to do now is add a unit test to our application. Now for the process of adding the test to our application, we're going to use a very simple form of a testing technique known as test-driven development. And in test-driven development, we actually use tests to drive the way we implement our functionality. So we're currently looking at our DataManager class, and I want to go and add a new function to this class. I want to add a function that makes it easy to add a new note to the DataManager's notes collection and get back the index of that note. So what we'll do is we'll add a function. We'll name the function addNote. Then addNote will take three parameters, a course, a noteTitle, and noteText. So that gives us our three parameters. Now this function is going to return back an index, so we'll give it a return type event. Then we'll go ahead and add our body. Now when we're developing using test-driven development, what we actually do is start out by implementing our code in a way that will fail our test, and then we'll ultimately build up our test for what we want to verify and then come back and add the code to our function that'll actually meet the requirements of that test. So what we want to do here initially is return back a value that will fail the test, so we'll return back an index of -1. So that now gives us a very simple implementation of the function that doesn't really do anything, but it does return back a value. So what we want to do now is go ahead and add a test to our project that will allow us to build the test that will verify the expected behavior so we can come back around later and then add that behavior to the function itself. So to add our test, I'll go over here to our Navigate menu. I'll choose Navigate. And you notice down here in the menu we have an option that says Test. Let me head down there. So now to add a test, I can go ahead and select Test from our menu here. Notice also instead, as a shortcut, I could've simply use Ctrl+Shift+T. So let's go ahead and select Test. And notice here that it says to choose a test for DataManager, but we don't yet have any tests for DataManager. So we'll go ahead and select Create New Test. So notice that brings up this dialog, and it asks me what class name do you want to use for your test class? We'll accept its default of DataManagerTest. It gives me the option of what package I want to add that test class to. We'll go ahead and accept the default. And then notice that it gives an option of what members of the DataManager class we want to add a test for, and we want to add it for the function we've just created, addNote. So I'll go and check that box. So now with the addNote checked, I'll go ahead and hit OK. It asks me which source set I want to add it to, and you notice we have a couple of options here. The top one is the one labeled androidTest, and that's the source set for our automated Android tests. But what we want to do in this case is actually create a simple JVM-based unit test, so we'll add it to the second option here, the one simply labeled test. So I'll hit OK. So you'll notice now that Android Studio created for us a class named DataManagerTest. And if we look over to our Project window, notice that down at the last source set, the one labeled with test in parentheses, the DataManagerTest is part of that source set. So that's a source set we're using for our unit tests. Notice that our DataManagerTest class has just one function inside of it, it's the addNote function, and that's the function we're going to use to implement our test code. And we'll see how to do that in our next clip.

Implementing and Running a Unit Test
Here we are back in Android Studio, and we're currently looking at our DataManagerTest class. And we're now ready to add the code to test out the new function called addNote that we added to our DataManager class. Now remember that we're following a style of development known as test-driven development, and in test-driven development we kind of write our tests first and then implement our code to fulfill the requirements of the test. So now our DataManager class's addNote function takes three parameters, a course, a noteTitle, and a noteText. So let's go and add assign once variables to our addNote test for each of those parameters. So we'll start out with one called course. And then to get the course, we use the DataManager's courses collection, and then we use the collection's get method to get a particular course. And I know that one of the courses has an ID of android_async, so we'll get the course with that ID. So that gives us a variable with the course that we'll use to add the new note. Let's add two more variables, noteTitle and noteText. So that gives us variables for each of the parameters we want to pass to create our new note. So now the next thing we want to do is go ahead and call our DataManager class's addNote function. Remember that addNote will return back an integer value, which will be the index of the newly created note. So let's declare a variable here called index, then we'll go ahead and call DataManager. addNote, and then we'll go ahead and pass in the variables for each of the parameters. So now you notice when we add those parameters to the addNote function call, the course is underlined in red. So let's go and hover over top of that, and let's see what the error is. And you notice that it says Type mismatch, that the addNote function is expecting a type of CourseInfo, but what we're passing is a CourseInfo with a question mark. What that's saying is is that that local variable CourseInfo could potentially be null, but our addNote function doesn't allow null values. So now to address that, we could do a couple things. One is we could go ahead and do our addNote function and allow it to accept nulls, but that's not what we want to do. We don't want to allow people to add new notes with a null course value. So what we need to do is somehow get this local variable to not allow nulls. So now there's a couple different things we could do. One simple thing we could do is to give it a default value if it was null where we could simply add a check to make sure it's not null. But now in this case, we're running a test, and we don't really want to test whether the get method of courses returns back a null or not. We want to go ahead and rely on the fact that it's not going to return back a null. So what we can do is at the end of the line where we call get on the courses, I'm going to add a double exclamation mark. Now by adding those double exclamations at the end of the line, we've actually incorporated a null check into our code. What they do is they will check to see if the get function returns back a null or a non-null value. If the value is non-null, it'll go ahead and assign the value to our course variable. In the event that it is null, it'll actually throw a NullReferenceException. Now this is not the sort of thing you want to commonly put into your production code, but in cases like this where we're writing a simple test, using it is fine because it allows us to get back that value and not have to deal with the details of the unlikely possibility of it being null. So now that we have a valid call to addNote, we want to do the next step in our test. The next step in our test will be to get back the note at that index. So I'll declare another local variable named note, and I'll go ahead and retrieve back the note at that index. And so now that gives me the basic functionality of my test. I want to add a note with my addNote function, and I want to try and get that note back. So let's go and try and run the test. Now you notice here in the gray bar off to the side by our DataManagerTest class there's a green arrow next to the addNote function, and there's a green arrow next to the DataManagerTest class. If I click the arrow next to the addNote function, that'll allow me to run my addNote test function. But now if I click the one next to the class name, that would run all the tests within the class. But now, of course, at this point, we only have one test in our class anyway. So let me head up to the green arrow next to addNote. I'll click on it. You notice that gives me the option of running the test, debugging the test, or running the test with code coverage. Let's go ahead and just simply run the test. And you notice that when I ran that test no emulator popped up, and that's because the test is running directly on my desktop. It's running within the JVM on my desktop. And as we mentioned, that'll allow me to run these tests and run lots of test very quickly because I don't have all the overhead of launching an emulator or installing the application on an emulator and running everything over there. It's all running directly here on my desktop. But notice also that once a test completed this window popped up at the bottom. If we look at the left side of the window, we can actually see our test. So we have one entry there that shows the class name, so that allows me to see the grouping of all the tests in our DataManagerTest class. Then we have our addNote function. And you can see that they're marked with that red circle, and that indicates that it's a test that failed. And over here in the window to the right, we can see why it failed. It failed because we had an ArrayIndexOutOfBoundsException. Because remember that our addNote function returns back -1, and that's always going to fail when we try to access the collection with an index of -1. But even though the test failed, we're off to a good start because we have our test code in place. And what we really want to test is to see if the note that's at the specified index actually contains the values that we added to the DataManager class's addNote function. So to do that, we're going to need an easy way to test to see if certain values match. We'll see how to do that in our next clip.

Assert Class
When we write our tests, we need some way to judge whether the expected behavior has occurred correctly, and that's where the Assert class comes in. The Assert class gives us the ability to indicate what our expected results are, and it does that by providing methods that'll allow us to indicate our expectations. What these methods will do is they will check to see if that expectation is met. But in the case that that expectation is not met, then the Assert method will fail, which will in turn fail the test. Now there are a number of different methods on the Assert class. Here's just a sampling of some of what's there. One of the methods is assertSame. Now the assertSame method allows us to pass in two references, and assertSame will only pass if both those references point to the exact same object. Then we have assertEquals, and that allows us to pass in two object references, and that only passes if both those objects are equal. In other words, does the equals method on that class return true? And then we have assertNull, and that allows us to pass in a reference, and the assertNull method will only pass if the reference is null. And there are many other methods besides these three. These are just some examples. And most methods also have negative versions, so there's things like assertNotSame, assertNotEquals, assertNotNull. So now in our next clip, let's head back over to our code. Let's add in some assertions to validate our expected behavior.

Using Assert Class in a Unit Test
Here we are back in Android Studio, and we're currently looking at the code in our DataManagerTest class. We're looking specifically at the function to test our DataManager class's addNote function. So now we already have some behavioral code inside this test. We already call the addNote function to add a note, that function returns back an index, and so we use that index to try to get back the note that we believe was just added. So now how do we test to see if our addNote function works correctly? Well, the way we do that is by checking to see that the note we get back has the values in it that we expect. So we want to make sure that the note that comes back has the course, the noteTitle, and noteText values that we passed into addNote. So now to do that, we're going to use functions from the Assert class. Now before we do that, let me just scroll up in my code a little bit, and you'll notice here at the top of the class file we've got some imports. And one of the imports is for org. junit. Assert, and then it's followed by. star. And by using that. star, we can actually call the functions within the Assert class without having to qualify them by the Assert class name. And by doing that, it makes our test code a bit easier to write and read because we can simply use the Assert functions themselves and not have our code all cluttered up with a lot of assert. before each of the function names. So let me scroll back down to the body of our addNote test. So now we're back here in our addNote test function, and we want to start testing the values in the note. And what we're going to do is use the assertEquals function. And assertEquals takes two parameters. The first one is the expected value, so let's first check to see if we get the expected course. So we'll pass in our local course variable, and then for the second parameter we'll pass in note. course. And that'll check to see if the course for the specified note corresponds to the course that we added with the addNote function. And now let's do the same thing for noteTitle and noteText. So with those three lines added, we now have the code in place to make sure that the note that comes back has all the values that we added to the DataManager class's addNote function. So we're simply verifying that the note that comes back has the expected course, title, and text. But if we go ahead and run this test right now, we know we're never going to reach the asserts because we're still going to hit that ArrayIndexOutOfBoundsException. So if we're following the style of test-driven development, we want to evolve the DataManager class's addNote implementation in a way that we won't get any exceptions now, but we should still fail the asserts. So let's head over to our DataManager class, and let's see how we do that. Here we are now in our DataManager class. We're looking at our addNote function. Now the way our addNote function is currently implemented, it returns back -1, which means that every time we run the test we're going to get that ArrayIndexOutOfBoundsException, and what that means is that we never get a chance to verify that our asserts are checking for the right things. So what we want to do now is change our addNote function so it'll return back a valid note index, but it simply won't be the index of the note we just added. So to do that, we'll change our -1 to a 0. So now, no matter what note we add, the addNote function is always going to return the index of the first note, the note with index 0. So let's head back to our DataManagerTest class and see why that matters. So now we're back here in our DataManagerTest class, and we're ready to rerun our test. And it may seem strange that we're always returning back the index 0, but the thing we want to keep in mind is that when we're building our tests we want to be sure that we have solid tests, so we want to make sure that they properly fail when invalid values come back. So by making our addNote function always return back an index value of 0, we're always going to get back a reference to the first note in the notes collection, and that's a note that's not going to have the proper course, title, and text. So by having the addNote function return 0, we're verifying that our test will fail correctly when an improper index is returned. So now to rerun the test, there's a couple different ways we can do it. You notice down here at the bottom of the screen there's a couple of options. We could rerun all the tests that we ran last time, we also have an option here that'll let us rerun just the failed tests, or up here in the source code window we can run the tests just as we did before, and that's we'll go ahead and do. So we've got the arrow here just to the left of the function name. I'll go and click on that. I'll go and choose Run. And now when I run the test, it fails again, but this time it fails with an AssertionError, and it tells me specifically what happened. It's always expecting one particular Android course, but instead it found a different one. So that now verifies that my test properly fails when an invalid index is returned. So now I know I've got a good solid test to work with. And once I know I've got a good test to work with, I'm now ready to properly implement the DataManager class's addNote function, and we'll do that in our next clip.

Verifying Implementation Behavior
Here we are back in Android Studio, and now that we have a solid test in place to verify the behavior of our DataManager class's addNote function, we're ready to go ahead and implement that function. So now remember the purpose of this function is to create a brand-new note that has all the specified values and return back the index of that note. So the first thing we'll need to do inside of here is construct the new note. So we'll start out by declaring a local variable. Then we'll construct a new instance of our NoteInfo class, passing in all of the specified values. That takes care of constructing our note, so let's go ahead and add it to our DataManager's notes collection. And then once we've done that, we're going to return back the index of that note. And we know it's going to be the last note in the notes collection, so our addNote function can simply return back notes. lastIndex. So now with that, our addNote function should be all set. But in order for us to be sure it's all set, we need to run its test. So let's head back over to our DataManagerTest class. So now here in our DataManagerTest class, let's go ahead and run our addNote test. So I'll click on the arrow to the left of our test function, I'll choose Run, and you'll notice now that our test shows up in green, meaning that our test passed. And so that tells us that based on our test, the DataManager class's addNote function behaves correctly. And you can see that's why we wrote the test first. By writing the test first, test-driven development allows us to specify the expected behavior in the test, and then once we know what the expected behavior is, we can then go in and implement the function to correctly perform that behavior. So we're really using the tests as a specification for the expected behavior, and that allows us to write good, solid code that we can modify and evolve over time without concern for introducing unexpected errors because we always have the tests to verify we haven't introduced some breaking behavior when we make a modification. But now before we move on, we'll look at one quick thing here in our test. Notice that the first thing we test for is assertEquals on the course. Now remember that the course is an instance of the CourseInfo class that we created, and what assertEquals is doing is it's calling the Equals function on the CourseInfo class to verify that these two courses are indeed equal. But if you think back to the first course in this series, when we created the CourseInfo class, we never actually wrote an equals function, but we did something that makes the equals function available. So let's head over to the source code for our CourseInfo class and see what that is. So we're looking now at our CourseInfo class, and as we mentioned, the CourseInfo class doesn't explicitly define an equals function. But notice that it is marked as data, and this really shows the value of using the data modifier on classes that are part of a data model. Remember we said that the data modifier calls those certain functions to be automatically generated, and one of those functions is the equals function. So by marking CourseInfo as a data class, the Kotlin compiler generated an equals function that checks the values of the properties specified in our primary constructor. So the generated equals function does exactly what we want it to do. When we have two references to instances of CourseInfo, it checks to make sure that both courseIds are equal and that both titles are equal. So by marking this as a data class, it generated the exact equals function that we want. And this really shows us the kind of code savings that using data classes does for us in many parts of our code, but especially when using our own data models as part of our testing. Alright, so now in our next clip, let's see how we can be sure that our tests behave consistently each time we run them.

Assuring Test Consistency
In order for tests to be valuable, tests have to be reliable. And for tests to be reliable, they have to be consistent. And what that means is that each time we run a test, the same data should produce the same results, whether you run that test by itself or as part of a larger group of tests. So that means that each test needs to stand alone. It can't depend on the actions of another test for this particular test to succeed. In the same way, each test must be protected from side effects of other tests. So now for that to be the case, each test must start with a consistent state. So what we need is a way to set things up before each test or tear things down when a test completes. And JUnit allows us to do that. JUnit allows us to have test preprocessing. So this allows us to create methods that will run before each test within a class. And the way we do that is we add a method to the class, and we mark it with the @Before annotation. In the same way, we can have test post-processing. That allows us to have tearDown methods or methods that run after each test in a class. The way we do that is we code up the tearDown method, and we mark it with the @After annotation. Now each class can have as many setUp methods that you like and as many tearDown methods as you like. And if you create multiple setUp methods, all of those methods will run before each test, but the order of those methods is not guaranteed, so that means that each setUp method must stand on its own. One setUp method can't depend on another setUp method. In the same way, each tearDown method must stand alone. One tearDown method cannot depend on another tearDown method. Alright, so to get a better sense of how all this works, in our next clip, let's see how we can use a setUp method to assure that our tests run consistently.

Inconsistent Test Behavior
Here we are back in Android Studio, and what we want to do now is take a look at the importance of assuring test consistency. Now we're currently looking at our DataManager object, and I've added a new function to the DataManager object named findNote. And this is a very simple function that allows us to pass in a course, a noteTitle, and a noteText, and the function will loop through the notes collection to find the note that has those values. Notice that the for loop allows me to iterate through the notes collection, and it takes care of assigning the current note to our note variable each pass through the loop. Then inside the loop we just have some simple equality checks. And notice that we're using the double equal sign, and this is a key difference between Kotlin and Java. In Java, a double equal sign only returns true if both references point to the exact same object. In Kotlin that's not the case. In Kotlin, a double equal sign is compiled into a call to the object's Equals method. So this code here where it says course == note. course, that's actually being compiled into a call to course. equals passing in note. course. So again, this is leveraging the Equals method that's generated for us by making our CourseInfo class a data class. So now, of course, we want to be sure that this method works correctly, so it needs a test. So let's head over to our DataManagerTest class, and you notice here in the DataManagerTest class I have a test method named findSimilarNotes. And the purpose of this test method is to be sure that our findNote method works correctly in a particular edge case. And what this test does is confirm that if we create two notes that are very similar, that findNotes still returns the correct note. Because you notice that here at the top of the test we have this series of variables. We have a course variable and a noteTitle variable, and then we have two separate variables for the noteText, noteText1 and noteText2. So the first thing the test does is add two notes. Both notes have the same course and noteTitle. The only difference is the noteText. So when we add those notes, we capture the index of the note that we added, so then we call our findNote method to try to find the first note. We get a reference to that note, and we want to verify that the index that we got back is the correct index for the first note that we added. And then we do the same thing for the second note. So we're just verifying that if we create two notes that have the same course and the same title, but different text values, that we find the correct note. So let's go ahead and run this test. So I'm going to head over here to the green arrow to the left of findSimilarNotes. I'll click on that. I'll choose Run. And we can see here that once a test completes, we can see that it completed successfully. So our test shows that findNote is working correctly. But now let's run this test again. But instead of running it by itself, let's go and run it with all the tests within our DataManagerTest class. Now one way we could do that is to scroll back to the top of our DataManagerTest class, and click on the arrow next to the class name. Or we have another option. Notice at the top of Android Studio we have this box that says DataManagerTest. findSimilarNotes. That box is displaying our current run configuration. Let me head up there. Then I'll go and expand it. You'll notice that there's a few values here. One value is app. If we have the app run configuration selected, when we run our project, it will run our application normally. But then down below app we have some other recent configurations that have been used. So you can see there's a configuration to run just the test addNote, there's another configuration to run just the test findSimilarNotes, and then we have one labeled DataManagerTest. So if we head down and select that one, when we select DataManagerTest, running our project will run all the tests within that class. So I'll head up here to my Run button, I'll choose that, and notice now when I ran all the tests inside the DataManagerTest class, findSimilarNotes now fails even though it ran successfully when I ran it by itself. So in our next clip, let's take a look at why that's the case and how we can fix it.

Maintaining Consistency Across Tests
Here we are back in Android Studio, and what we want to do now is see how we can assure that our tests run consistently. Now remember that in the last clip when we ran all the tests in our DataManagerTest class, our findSimilarNotes test failed, but when we ran that test by itself, it succeeded, so there appears to be some side effect going on when we run all the tests within this one class. Now notice here in our results for our test, we can see that we had a fail on NotEquals, and we can see that it was in our DataManagerTest class line 34. So let's go and click on that link, and then it shows that we failed when we checked to see if the first note we got back was the same index as the note we had just created. So we can see things a little better, let me to go ahead collapse this window down here at the bottom. So now we can see our entire findSimilarNotes test, and, of course, the question is why is it when we run this test as part of the other tests in this class that we don't get back the index of the same note that we just added? Let's take a look at the values for the very first note that we're adding inside of this test. We can see we're using the course, which has the ID android_async, the title we're using is This is a test note, and then the noteText is This is the body of my test note. Let's scroll up and look at the other tests inside of this class. So now we can see our other test, which is our addNote test. Remember the addNote test verifies that our addNote function works correctly. In order to do that, this test adds a note. And take a look at the values that we're using in this test. Again, we're using the course with the ID android_async, we're using the title, This is a test note, and our noteText is This is the body of my test note. So what we're doing is we're using the same values in our addNote test that we used in our findSimilarNotes test. So when we run the findSimilarNotes test after the addNote test, the find is finding the note that was added in the addNote test, not the note that was added in our findSimilarNotes test. And that's happening because we use the same values in both tests. Now you may be thinking well, duh, don't use the same values in both tests, and that is certainly a reasonable idea when you have a small number of tests as we have here. But in practice, when you're building an application, you will have hundreds if not thousands of tests, and it's going to be really difficult to assure that no two tests use the same values. So a better solution is just make sure that every test starts out with a consistent environment no matter how it's run, and we can do that by adding a setUp method to our test class. So let's scroll up towards the top of our DataManagerTest class. So we're here at the top of our DataManagerTest class, and what I'm going to do is go ahead and right-click. When I right-click, I'm going to head down to where it says Generate. Then I'll go ahead and select Generate. And the Generate dialog gives me a few options. One of those options is to add a setUp function. So let's head up to that option, and then I'll go ahead and select it. And when I do that, it adds this function name setUp that's marked with the @Before annotation. And so what that'll do is that before each test in this class is run, JUnit will run the setUp method first and then run that test. And then before it runs the second test in the class, it'll again run our setUp method and then run the second test in the class and so forth. So let's go ahead and remove this TODO. And so what we want to do in here is to assure that we always start each test with our notes collection in the same state. So the first thing we'll do is we'll clear out the DataManager's notes collection. So that'll take care of clearing out all the notes that are in my DataManager's notes collection. Then what I'll do after I clear it out is go ahead and add in some sample notes to use before we actually run the test itself. Now my DataManager class has a method that does that called initializeNotes. So now with that, before each test in this class is run, we'll completely empty out the DataManager's notes collection and initialize it with a starting set of notes. So let's try running our test again. So let's head up here to my run configuration, we'll go and expand the run configuration, we'll go down here and choose findSimilarNotes, and then we'll head up here and choose Run. So now notice when we run findSimilarNotes by itself it still succeeds. So now let's go up here and expand our run configurations again. This time I'll choose DataManagerTest, and let's go and run all the tests inside of DataManagerTest. And as you can see now, even when we run all the tests inside the class, findSimilarNotes succeeds. So by using the setUp method, we're able to assure that all of our tests always run with a consistent startup environment.

Summary
To wrap up, here are some of the key things you want to remember. Remember that in modern application development testing needs to be a core task because we need to have testing to assure that we deliver high quality software. The way we generally do that is through unit testing. And in unit testing, we break our units into relatively simple tests, and each of those tests focus on a specific feature or behavior. And throughout our development cycle, we'll be running those tests very frequently so we can catch any breaking changes very early in the development process. Now a key part of our testing is the local JVM testing, and this is the testing that focuses on the logic-based behavior of our applications. And Android Studio allows us to run those tests directly on our desktop, making it easy for us to run them frequently and run them quickly. And Android Studio is a key part of managing our tests because we can run them, or we can debug them and walk through them line by line if we need to to identify the source of a problem. And Android Studio will display the results of our tests indicating success or failure based on the color of those results. Each of our tests are created as a separate method. We can group those test methods within classes. And the way we identify a method as a test method is by marking it with the @Test annotation. And within our test we're going to make frequent use of the Assert class because the Assert class allows us to indicate the expected results within that test, and the Assert class will take care of failing the test in the event that those expectations aren't met. And remember tests are only useful if those tests are reliable, so we need to be sure that our tests are always run in a consistent environment, whether those tests are run alone or as part of a larger group. So to assure that consistency, we can add pre and post-processing to our tests, and we do that by adding methods to our test class and marking those methods with either the @Before or @After annotation. And by doing that, these methods will run for each test in the class, allowing us to assure that the test always runs in a consistent environment. Alright, so now in our next module, we'll take a look at how we can perform automated user interface testing.

Understanding Automated UI Tests
Introduction
Welcome to our next module, Understanding Automated User Interface Tests. This is part of the Pluralsight course Android Apps with Kotlin: Tools and Testing. My name is Jim Wilson. Incorporating testing that occurs within the Android environment is critical to assuring app quality. As part of assuring that app quality, we need to also incorporate testing that includes interacting with the user interface. However, manually testing the user interface can be time prohibitive, so for this sort of testing to be effective, we need a way to automate it, and that's where instrumented testing comes in. So in this module, we'll start out with an overview of instrumented testing, we'll then see how to implement instrumented tests, we'll see how to set up automated user interface tests, and then we'll finish up with a look at some basic user interface test interactions.

Instrumented Testing Overview
Now, as we talked about in the previous module, our Android applications can be broken up into two general categories of behavior. The first category is our logic-based behavior. These are things like our calculations or interacting with data and those sorts of things. And then, of course, we have our Android-based behavior, and those are the features of our application that rely on the Android platform itself. Now as we saw, when it came to testing our logic-based behavior, we could run those tests really efficiently by running them directly inside the JVM on our development desktop machine. But now what about testing our Android-based behavior? Well to do that, we're going to use something known as instrumented tests. Instrumented tests allow us to test the Android-based features of our application. Now because instrumented tests rely on the Android platform itself, we're going to need access to the full Android environment when we run these tests, so these are tests that we'll need to run either on an emulator or on a physical device. Now there are two general categories of instrumented tests. The first kind is what we call instrumented unit tests and these are just regular old unit tests that just happen to rely on the Android platform itself, so we're going to write these kind of tests very much like we wrote our other logic-based tests. We just have to run them inside the Android environment because the behavior we're testing relies on that environment. But there's another kind of instrumented test that we can write that's a very powerful kind of instrumented test, and that's an automated user interface test. And this is effectively an integration test because it allows us to verify that our application behaves correctly in response to user input and user interaction. Now, these kind of tests have to be run within a special environment, so as we mentioned, we're going to need either an emulator or a physical device, and on that device we're going to have to have our application code because, of course, that's what we're testing. Just like a regular application, that code will run inside of a process, but now rather than an application being run directly, we're going to run it with the assistance of a test package, and that test package is going to have the things we need to perform the tests. So it will include JUnit that allows us to actually run our unit test code, it'll contain information about test instrumentation that allows us to gain information about our test environment itself, and then it will include our test cases, in other words, the test code that we write to perform the tests. So now this test package will need to interact with our application somehow, and we do that using something known as the AndroidJUnitRunner. So now in our next clip, let's see what's involved in implementing these instrumented tests.

Implementing Instrumented Tests
Now when it comes to implementing these instrumented tests, much of what we do will be very much like what we did in the previous module with our regular unit tests. We're still going to leverage JUnit. So we're going to group our tests within classes, and our test functions are going to use the same annotations. So our test function itself will still use the @Test annotation, and we can still use @Before and @After for tests preprocessing and post-processing. We're still going to rely on the assert class. So we're going to rely on the functions in our Assert class to indicate our expected test results, and if those expectations are not met, the Assert class will take care of failing our test. And we're going to manage our test using Android Studio. So we can run and debug those tests just as we did in a previous module, and we'll be able to see the results of those tests displayed directly within Android Studio. But now there are some differences. Now our instrumented tests are organized separate from the JVM tests. Remember that our JVM tests were in the test source set. Well, these tests will be in the androidTest source set. Now, as we already mentioned, these tests require a test runner, so we're responsible to indicate the type that's used as the test runner. So each of our test classes have to be marked with the @RunWith annotation, and then we're going to pass to that annotation the information on the AndroidJUnit4::class, and that indicates that that's the type that will be used as the test runner for these tests. And since these are tests that require the Android environment, we're always going to be running these tests on either an emulator or a physical device. So let's take a look at what a test setup looks like when creating an instrumented test. We're, of course, going to have a test class. We'll need functions for our tests. Each test function is marked with the @Test annotation just as it was in our regular unit tests, so we'll put our test code inside that function. But now here's one of the key differences. We need to mark our test class with the @RunWith annotation, passing in AndroidJUnit4::class. And if we need to have any pre or post-processing functions, we can incorporate them right in a class, again, just as we did before. So in this case, we have a function named testSetUp that will be run before each of the tests inside this class. So now in our next clip, we'll go ahead and add an instrumented test to our application's project.

Setting up the Test
Here we are back in Android Studio, and what we want to do now is add an automated user interface test to our application. And let's say that the test we want to add will be to verify that our application properly handles the creation of a new note. So now I'm currently looking at the MainActivity class. Remember, the MainActivity class is the activity that displays a note and allows a user to create a brand-new note. So now, to add this test, we're going to follow a process very similar to the one we used in the previous module. We're going to go up here to the Navigate menu option. I'll select that. I'll scroll down here to where it says Test, and then I'll go ahead and select Test. Now, I do want to create a new test, so I'll select that. And that brings up the same dialog we saw before. So now you'll notice that the suggested class name is MainActivityTest, and that's, of course, because we were viewing the MainActivity class when we created this test. But now when it comes to user interface tests, I generally name my classes based on the overall test that I want to perform. So in this case, I want to test out creating a new note, so I'm going to change the class name to CreateNewNoteTest. And that's all I'm going to do on this dialog. I'm not going to select any of the methods because we're not testing a specific method, right? This is more of an integration test. We want to actually test out a behavior. So I'll go ahead and create our test class. Now remember that automated user interface tests are actually instrumented tests, so instead of using the test source set, we're going to use the androidTest source set. So I'll go ahead select that and then go ahead and create my class. So now that gives us our test class. You see we start out with a fairly bare file here, so we're going to have to add in the things that we need to set up our test. So let's go ahead and give our class a body. Then here inside of the class body we'll create our test function. I'll simply name the function createNewNote. So that gives us our function. Now because this is a test function, we're going to need to mark it with our @Test annotation. We'll go ahead and import that class. So now that annotates our function as a test function. But remember that this is an instrumented test because remember that automated user interface tests are just a type of instrumented test. Now remember that our instrumented tests have to have a test runner. We need to mark our class with the @RunWith annotation. We'll go ahead and import that, and then we have to tell the RunWith annotation what type to use as the runner, and we're going to use AndroidJUnit4. We'll go ahead and import that. And what we need to specify here is not an instance, but the class information, so we'll just follow this with ::class. And with that, we now have our test class and a test function in place. But of course, that's just a beginning because if this is an automated user interface test, we need some way to interact with the views contained within an activity, and we'll see how to do that in our next clip.

Creating UI Test Interactions and View Matching
Now as we mentioned, one of the really powerful capabilities of instrumented tests is they allow us to perform automated user interface tests. But now to do that, we're going to have to have the ability to specify interactions with the views within our application. So now, in order to interact with our views, the first thing we need is some way to specify the view of interest. In other words, we have to be able to say I want to interact with this specific view. And then once we identify the view we want to interact with, we need a way to specify the action we want to perform on that view. So of course, the question is how do we do that? Well that's where the Espresso API comes in. The Espresso API is a UI testing framework, and it provides us the features we need to create these automated user interface tests. So now a key part of performing these tests is the Espresso class's onView method. And the onView method accepts a matcher, and we use matchers to specify the criteria we want to match on. These matchers allow us to indicate what view we want to match on. And what onView returns back is a reference to a ViewInteraction. And the ViewInteraction is really powerful because first of all, an instance of ViewInteraction is associated with a specific view. It's associated with the view that matched the matcher. And then once we have the ViewInteraction reference, we can perform actions on that view. So let's look first and how we specify the view of interest. In order to do that, we're going to rely on something known as Hamcrest matchers. Now, Hamcrest matchers provide a declarative model for performing matching operations. The thing is, Hamcrest matchers are not specific to Android. They're actually a general-purpose Java-based matching framework, and we can actually leverage Hamcrest matchers in our Android user interface testing. Now if you want to know more about Hamcrest matchers, check out the URL hamcrest. org. But now as we mentioned, Hamcrest matchers are not specific to Android, and although they're a great base for doing our testing, we need a little bit more than that to do our UI testing. So that's what the ViewMatchers class comes in. It provides matchers specifically for matching Android views. But what's cool about this is that they actually return back a Hamcrest matcher, which means that when we're building our tests we can leverage the Android-specific behaviors of the ViewMatchers class and combine them with the general matching behaviors of the Hamcrest matchers. So let's first look at some of the most commonly used ViewMatchers methods. Now, one of the most common ones we use is withId, which allows us to match a view based on its ID value. But we can also match on other criteria. For example, we have withText, which allows us to match a view based on the value contained in its text property. Then there's isDisplayed, which will match a view if it's currently on screen. Or there's isChecked, which matches a view if it's currently checked, so it's great for working with things like switches and checkboxes. Now in addition to the ViewMatchers class, we still commonly leverage some of the regular Hamcrest matchers as well. For example, we have equalTo, which does a match based on a type's equals method, or there's instanceOf, which performs a match based on a referenced object's type. But there are also matchers that accept other matchers. For example, there's the allOf matcher, and that accepts multiple matchers. And the allOf matcher is true only if all the past matchers are true. And then we have the anyOf matcher. It also accepts multiple matchers. In the case of anyOf, if any one of the past matchers is true, then the anyOf matcher is true. So let's next take a look at how we can interact with our views, and we'll see how to do that in our next clip.

Performing View Actions and Starting Activities
Now, once we've identified the view we're interested in, we're ready to interact with that view. Remember that when we match a view we get back a reference to a ViewInteraction. The ViewInteraction class has a perform method. What that allows us to do is perform one or more specified actions. Now the way we identify the action is by passing in that action as a parameter to the perform method. So the way we specify these actions is with the ViewActions class. The ViewActions class has a series of methods that allow us to identify the action we're interested in, and so that will return back a reference to the specified action so that the ViewInteraction class's perform method can perform that action. Now, the ViewActions class has a number of methods. Here's some of the most common ones we use. There's the click method, which allows us to click on a view, or in effect, tap on a view. There's a typeText method, which allows us to enter text into a view. There's a replaceText method, which allows us to replace a view's current text with some new text. And another one we commonly use is closeSoftKeyboard, and as its name implies, it allows us to close the soft keyboard if it's currently open. So now we've seen how we can identify the view that we're interested in, and we've seen how it can interact with that view, but, of course, we can't do any of those things until the activity containing those views is started. Well, to make it easy for us to do that, we have the ActivityTestRule, and the ActivityTestRule automates the lifetime of a test activity. It will take care of starting that activity before each test. It will take care of terminating that activity after each test. And the lifetime of that activity will include the @Before and @After methods. So basically, the identified activity will be started. Qny message marked with @Before will be run. Then our test method will be run. Then the @After methods will be run. Then only after all that will the activity be destroyed. So this allows us to simply identify the activity we want to test, and the test system takes care of all the issues related to that activity's lifetime. All right, so now in our next clip, let's add the code to our test to launch an activity and interact with the views contained within it.

Implementing the Automated UI Test
Here we are back in Android Studio, and we're ready to start implementing our CreateNewNoteTest. Remember, this is an automated user interface test, so it's going to actually mimic the interactions that occur with our app's user interface to actually create a new note. So in order to write the test, we need to know the specific user interface actions that have to be performed. So let's go ahead and launch our app and see what those are. But now, before we actually do that, there's one thing we need to keep in mind. If you've recently been running tests, the current build configuration will probably not be the one you want to actually launch the app, so we want to make sure that we have our app build configuration selected. So we'll go up here to where we have build configurations. I'll expand that. I'll go down here and select app, and now I'm ready to actually run the app. Had I not done that, when I clicked the Run button, I would have simply run the last test that I had performed. All right, so now that we have our app build configuration selected, we can go ahead and start our app. So here we have our app up and running in the emulator, and remember what we're testing is creating a new note. Well, the first step in creating a new note is going down here to our floating action button. We'll go ahead and click on that. That takes us to our MainActivity screen. So now, to create a new note, we'll go ahead and give the note a title. Once we have our title, we'll go ahead and add some text to the note. And so now that our note has a title and text, we now have the basic behavior of creating a note. We launch the NoteListActivity, click the floating action button, and then gives a note a title and some text. So let's head back to Android Studio and start implementing this test. So we're back here in Android Studio, and we're ready to start implementing our test. Now one thing I want to point out before we start actually writing the code for this test, you'll see here in our source code window that I've added some new imports, and these are the imports that we commonly use when creating automated user interface tests. Notice the first one is the Espresso import. That allows me the access to methods in the Espresso class without specifying the class name. Notice I've got two imports for matchers, one for the ViewMatchers class and then one for the Hamcrest Matchers class. Again, in both cases, I can simply use the method names. I don't have to class qualify them. I've got an import to access the actions in the ViewActions class. Again, I can do that with just the method names. And then finally, I have the imports for the ActivityTestRule and the Rule annotation. So that should give us most the imports that we need. So I'll go ahead and collapse our list of imports. The first thing we'll need to do in this test is make sure that our NoteListActivity is up and running. Remember that there's a rule that allows us to do that, and that's the ActivityTestRule. So the way we use the ActivityTestRule is by declaring a property of that type. Now we can name the property anything we want, but I generally name it based on the activity name, so I'm going to create a property called noteListActivity. I'll set it to an instance of ActivityTestRule. And ActivityTestRule takes as a parameter the class information for the activity, so it'll be NoteListActivity::class. Now, the ActivityTestRule does expect class information, but it expects it in a Java format, so we're simply going to add. java after class. So now that creates an instance of ActivityTestRule, but in order to tell the test system that that rule exists, we need to mark this property with the @Rule annotation. Now if we've done everything correctly, we should be able to run our CreateNewNoteTest. Now, the only thing that would happen is the testing system will simply create and then destroy our noteListActivity, but least this would verify that everything's set up as we'd like it to be. So I'll go up here to the arrow to the left of createNewNote, and then I'll go ahead and choose Run. Notice that's prompting me for where I want to run it because remember that these kind of tests require an Android environment. So I'll go ahead and run it on the selected emulator, and notice that my test fails. Now in some ways that's kind of discouraging because I'm like I'm just getting started. Why is my test failing already? But if we look here at the provided information, we can see why. It says that the @Rule noteListActivity must be public. So that sounds like the solution to the problem, except there's one issue. In Kotlin, properties are automatically public, so the reality is is that noteListActivity is already public. The problem we're having has to do with the way Kotlin represents types versus the way that Java represents types. In Java, when you declare a field, it's just that; it's actually a field. In Kotlin, when we declare a property, it's actually a method. So it looks like a property to us. To the java environment, it actually looks like a get method, so it looks kind of like getNoteListActivity. So the easiest way to resolve this issue is to tell Kotlin to represent this property as if it's a Java field, and the way we do that is by marking it with the @JvmField annotation. So now, by adding this annotation, our noteListActivity property will be exposed as if it's declared as a field in Java, and that's what we actually want. So let's go ahead and run our test again. So I'll go up here to the green arrow, I'll choose Run, I'll run it on the selected emulator, and now, as you can see, the test passes. So that means we're set up and ready to start doing the actual work to perform this test, and we'll see how to do that in our next clip.

Implementing Basic Test Interactions
Here we are back in Android Studio, and we're ready to start adding code to our CreateNewNoteTest. Remember what we're doing here is testing out the behavior of our application when a new note is created. Now, if we're going to create a new note, there's a couple things we need. We'll need a string value for the noteTitle. We'll need another one for the noteText. So let's go and declare those first. So that gives us the values that we'll use to create the note, so now we're ready to start performing the actual actions to do the note creation. Now remember that from a user perspective the way they do this is they first go to the NoteListActivity, and then they click on the floating action button to launch our MainActivity. Well, the way our test is set up, the testing system will take care of launching our NoteListActivity for us because we've specified this ActivityTestRule. So by the time our createNewNote function starts running, we know that noteListActivity is already displayed. So the first action that we have to perform is clicking on the floating action button. But before we can perform that click action, we first have to identify that view somehow. Remember, we do that by using the Espresso class's onView method. Now remember that we imported the Espresso class, as well as many of the other test classes in such a way and we can use their method names directly, and that allows us to write very clean, easy-to-read tests. So we're simply saying onView, and then we want to match on that view somehow, and the matcher we'll use is withId. And the ID we want is the ID of the floating action button, so that's R. id. fab. And that ID value is simply the ID value we used when we created the layout resource for this activity. So now with that code in place, we now have a reference to a ViewInteraction for that floating action button. So to perform an action, we call the perform method, and the action we want to perform is a click, so we'll call the click method. So with that line of code in place, the test will locate the floating action button and click on it, and we'll then wait for our application to do whatever it does. In our case, it'll go ahead and launch our MainActivity. So the next bit of code we write in this test will be interacting with our MainActivity because the way these tests work is the code here interacts with whatever the current activity is. So we launch the test with noteListActivity, but then the action in the test calls MainActivity to be displayed, so we'll then be interacting with MainActivity. So then once MainActivity is displayed, we want to start adding information to the note. So the first thing we want to do is type in the noteTitle. So we'll again use the onView method. We'll use withId and pass in the ID of the noteTitle. We want to perform an action, and the action we want to perform is to type in some text. And the text that we want to type in is the value of our noteTitle variable. So that'll take care of typing in textNoteTitle into our note's title field. So now we'll do the same thing for the noteText. So with that, our test will take care of launching our noteListActivity, it'll then click on the floating action button, and then when the MainActivity is displayed, it'll enter in values for the note's title and the note's text. So to see what that's like, let me go and put a breakpoint here at the end of the function. We'll head up to our green arrow. I'll select that. I'll choose Debug. Run it on the selected emulator. So when I did that, we saw our noteListActivity appear. The test clicked on the floating action button, which displayed our MainActivity, and then we can see values typed in for the note title and then note text. So it looks like our automated user interface test is off to a really great start.

Summary
To wrap up, here's some of the key things you want to remember from this module. Remember that the kind of tests we've been looking at throughout this module are what are known as instrumented tests. Now, instrumented tests are a kind of test that has to be run on an Android emulator or device, and as a result, has access to the full Android environment. Now there are two broad categories of instrumented tests. There are what's known as instrumented unit tests, and those are unit tests that rely on the Android environment, but don't have to interact with the user interface. The other kind is automated user interface tests, tests that can interact with our app's user interface. Now, just like our local JVM tests, instrumented test rely on JUnit, so our test methods have to be marked with the @Test annotation. We have access to pre and post-processing methods when we need them, but one key difference is, in this case, we need to mark our test class with the @RunWith annotation when we pass in the class information for AndroidJUnit4. And that's because these kind of tests need a test runner, and AndroidJUnit4 serves as our test's test runner. But one of the things we commonly do with this sort of testing is automated user interface tests. Now, these are a form of instrumented tests, but we leverage features and capabilities that allow us to automate the interaction with our app's user interface. Now, because these are user interface-based tests, we're going to need an activity, so these sort of tests generally use the ActivityTestRule. And ActivityTestRule automates the lifecycle of an activity, takes care of starting it before a test and terminating it after a test. Now once our activity's up and running, we're ready to interact with the views, and to do that, we use the Espresso class's onView method. And the onView method allows us to locate a view within the activity, and then it returns back a reference to a ViewInteraction. Now the way we locate a view is by using matchers. We have the Hamcrest matchers, which are general-purpose matchers, and then we also have to ViewMatchers class, which are matchers that simplify the process of locating views. So now once we locate the view, we want to perform actions on that view. So remember that the onView method returns back a ViewInteraction reference, so we can use the ViewInteraction. perform method. That allows us to perform an action against a view, and we specify the action by using the methods on the ViewActions class. Alright, so that wraps up this module. So in our next module, we're going to build on the work we did in this module by incorporating more involved user interface interactions and then seeing how the verifier tests behavior.

Creating More Complete Automated UI Tests
Introduction
Welcome to the module Creating More Complete Automated User Interface Tests. This is part of the Pluralsight course Android Apps with Kotlin: Tools and Testing. My name is Jim Wilson. In this module, we're going to continue building our automated user interface testing knowledge so we can build richer, more sophisticated user interface tests. So we'll start out, we'll look at how we write tests that interact with AdapterViews, we'll see how to interact with our device's Back button, we'll see how to verify our test behavior, that's both logic verification, as well as user interface verification, and then we'll finish up with a brief look at the Espresso Test Recorder.

Testing AdapterViews and Back Button
In our previous module, as we were creating the test to create a new note, you may have noticed that our test didn't include the process of selecting a course. And the reason for that is that selecting a course requires an interaction with a type of AdapterView. And when it comes to testing, AdapterViews require some special handling. Now we talked about AdapterViews in the first course in this series, but as a reminder, we load data into AdapterViews using Adapter classes. And some common examples of AdapterViews are things like ListViews and spinners. And in the case of our course selection, we're using a spinner. The thing that's special about AdapterViews is they display multiple items. And although they display multiple items, only a subset of those items may be loaded at any point in time. So when we create tasks that interact with AdapterViews, we need to be able to make selections based on the target data that we're interested in. So let's say we have a ListView. Now ListView is going to be populated with data, and the data set is much larger that can actually be loaded into the ListView. So the way we populate that ListView is using an adapter, and that adapter will load some subset of the data. Well, if during testing we want to interact with a data item that's outside of that loaded area, somehow the adapter is going to have to move from the currently loaded data set and load up the data set that's appropriate for the data item that we want to interact with. And then once that happens, we're able to interact with the corresponding data item. But to do that requires some special handling. And so that's where the Espresso. onData method comes in. So now the onData method accepts a matcher, but when we specify the matcher in this case, we're going to do it based on the target data. And since we're targeting data, rather than using ViewMatchers, we're going to tend to use the Hamcrest general-purpose matchers. Well now once we match on the interested data item, we'll get back a reference to a data interaction, and that data interaction will give us the ability to interact with a match, or if we need to, we can even further narrow the match. So now once we have our match, we're going to want to interact with it, and that's what the DataInteraction class's perform method comes in. The perform method accepts a reference to a ViewAction, and then it will perform that action based on the top-level view that corresponds to the matching data item, which then allows us to interact with the items displayed within things like ListViews and spinners. Now oftentimes when performing a test we may want to press the Back button, and that's where the espresso class's pushback method comes in. It performs the action of pressing the Back button. So it allows the test behaviors within our activity in response to the user pressing the Back button. There is one thing about this method that's a little different than the other methods we looked at. The pushback method doesn't require a reference to a view. We can simply call it directly. All right, so now in our next clip, we'll return to the test that we started creating in the previous module. We'll add support for selecting courses from a spinner, as well as pressing the Back button.

Implementing Spinner and Back Button Interactions
Here we are with our app up and running, and what we want to do now is continue working on the CreateNewNoteTest that we began working on the previous module. Now the app as is it's running in the emulator is running normally, so I can interact with it as a user. So what we'll do is we'll walk through the app interactively, compare those operations to what we already have in the test, and see what we need to add to the test to complete the testing process. So you can see there within our test class we have our ActivityTestRule to launch the noteListActivity, and that's the activity that's currently being displayed within the emulator. Then down here within the test, the first thing we do is click on the floating action button. So I'll do that interactively in the emulator. That then displays my MainActivity. So now if we look back at our test, the only other operations we have in the test are the operations to type in text for the note title and the note text. So to complete this testing process, we need to add test code to make a selection inside of our course spinner. So let's see what that looks like interactively. So I'll take my mouse up to the course spinner. To interact with the course spinner, the first thing I have to do is click on it. Once that comes up, I can make a selection. So I'll go down here and I make a selection of Android Async Programming and Services. So that makes the selection inside the spinner. Now the way I would save the content when I'm done is I would go down to the Back button, and I would press that. So there are the operations we have to add to our test. We need to add the code to make a selection from the spinner. Then we also need to add the code to press the back button. So let's head over to Android Studio, and we'll add that code. So we're back here in Android Studio, and we're looking at our CreateNewNoteTest function. So the first bit of code we'll want to add is the code to make a selection from the spinner. But before we do that, let's go and add a variable to represent the content that we want to select. Remember our spinner contains courses, so what we'll do is we'll add a variable named course and initialize it to one of the courses inside the DataManager. So our course variable now holds a reference to a course, and that will be the course we want to select from the spinner. Now remember that since the spinner is an AdapterView, rather than using onView to make the selection, we'll use onData. Now when we make a selection in AdapterView, we commonly use two conditions, so we have to combine those conditions, and both conditions have to be true. So to combine these conditions, we use the allOf matcher. The first condition is the data type of the content that we want to select, and the data type we want to select is the course info type, so we'll use the instanceOf matcher, and we want this to be an instance of our CourseInfo class. But notice that we have to provide the type information in a Java compatible way. So now once we indicate that the type of item we're selecting is a CourseInfo, we then need to provide the value that we want to match on. And what we want to do is select the course that's equal to our course variable, so we'll use the equalTo matcher. So onData will return back a data interaction that corresponds to the specified selection. So now we want to go ahead and click on that selection, so we'll use the perform method passing in the click action. So now that's all the code it takes to make the actual selection. And if we were interacting with something like a ListView, that's all we would have to do. But spinners are kind of a special case. If you recall, when we were walking through the app interactively, before I could actually make the selection on the spinner, I first had to tap on the spinner itself, and that same thing is true in our tests. So before we can actually make the selection within the spinner, we first have to click on the spinner. So just before I call onData here, I'm going to use onView to perform a click action on our spinner. So what happens here now is that first a test taps on the spinner itself. That presents the selections, and then the onData will actually select the course that we're interested in. In this idea of having to do the onView before doing the onData is something that's specific to spinners. Most other kinds of AdapterViews don't require that. We only have to do this when we're interacting with a spinner. All right, so that takes care of our spinner, so now we want to do is go ahead and add the press of the Back button, so we'll do that at the end of the test. So in our last line there we'll call the pressBack method. And you'll notice when we call pressBack it's underlined in red. So let me go ahead and hover over that, and you notice it's telling me that there's ambiguity. And the issue is, is that both the Espresso class and the ViewActions class have a pressBack method. So I have two ways of dealing with this. One is I could qualify the call to the method, so I can do something like Espresso. pressback, or I could add an import that disambiguates this call, and that's what I'll do. So I'll expand my imports, and then here at the end of the imports I'll add an explicit import for the Espresso. pressBack. So that explicitly identifies that I want to use the Espresso class's pressBack method. So if I go ahead and collapse the imports, you can see that the pressBack call is now no longer underlined. All right, so with that, our test is in pretty good shape. We now have the interactive features inside the test to create that new note. All right, so now in our next clip, let's see what features are available to validate our test results.

Verifying Behavior
Throughout this module and the previous module, we've been talking a lot about how we can interact with the user interface from within our test code. And it's a ton of fun to write that kind of code, write this testing code that can actually drive the user interface for us. But it's important that we don't lose sight of the reason for doing testing. The reason we do testing is to confirm that things behave as we expect them to. Now when doing automated user interface testing, obviously part of what we're testing is our UI behavior. We want to make sure the UI behaves as we expect it to. But UI testing is not just about UI behavior because UI interaction triggers logic, so we also want to verify that the logic behind UI behaves correctly as well. So now when it comes to verifying the UI behavior, in other words, is a view there that you expect to be there or not there that you expect to be there, or does a view contain data that you expect to be in there, we need a way to check those sort of things. And that's where the ViewInteraction class's check method comes in. It confirms some aspect of a view. So what we can do is use the Espresso class's onView method to select a view just like we do when we want to perform an action against it, but instead of performing an action, we use the check method to confirm some aspect of that matching view. Now the way we confirm the aspects of a view is by using the ViewAssertions class, and it provides methods to assert that some condition is true. If that condition's not true, it will fail the test. Now the most common ViewAssertions method that we use is the matches method, and it confirms that if view matches some passed matcher. So we'll commonly use the matchers from our ViewMatchers class. So it allows us to verify some state or some aspect of a view. And if the corresponding view doesn't exist, the matches method will automatically fail the test. Now there are some occasions, although not super common, where you don't want a specific view to exist. If you want to test that a specific view doesn't exist, you can use the ViewAssertion class's doesNotExist method, and it will only pass the specified view doesn't exist. Now something that's important to remember, even though we're doing user interface testing, most of our tests are still going to verify aspects of our application logic. So even in our automated user interface testing, the Assert class and its methods are still important because even in automated user interface testing we're going to use the Assert methods to confirm that the logic behind the UI behaves as we expect. So now in our next clip, we'll head back into Android Studio, and we'll add the code to our test to confirm that our application behaves as we expect it to.

Verifying App Logic During UI Interaction
Here we are back in the Android Studio, and what we want to do now is add the code to our CreateNewNoteTest to verify that the creation of the new note behaves correctly. Now in the case of this test, even though it's a user interface test, we really want to validate it based on data. In other words, we want to make sure that we actually created the note that we think we did. So what that means is that we're ultimately going to use just a regular Assert class. We don't need to use view asserts in this particular test. Because how we know if the user interaction correctly created the note? We need to see if that note is now in the DataManager. So the first thing we'll do is declare a variable named newNote. And the note that was created should be the last note in our notes collection, so we'll access the DataManager's notes collection, and we'll call its last function. And then what we want to do is make sure the note that we just got back contains the course, note title, and note text that correspond to the variables that we use to create the note. So we'll first do an assertEquals on the course, so that'll verify that the note we got back contains the course that we use to create the note. So we'll then do the same thing on the noteTitle and the noteText. So as you can see, in this case, because the definition of a correct test is based on data, we can use the same Assert process to validate the values that we used earlier in the course when performing local JVM tests. We're simply using the Assert class's assertEquals to make sure our DataManager contains the note that we expect. So let's go ahead and run this test and see what it looks like. So I'll go up to my green arrow next to createNewNote. I'll choose Run. I'll select the emulator. Now notice that the tests fail, so either my operation is not working correctly or my test isn't working correctly. But if we take a look at the test code, it seems like it's okay. We have the code to make a selection for the course spinner, we have the code that types in the title and some text, and then we press the Back button. Now we know that our MainActivity does the save when the user leaves the activity, so pressing the Back button should do that. But if we look at the specific error message, notice that it says it expected a course named Android Async Programming and Services, but it got back a null. So that tells us that apparently we didn't save the note correctly. So let's run our application interactively and just see what the note creation process looks like. So here we have our NoteListActivity up and running. So I'll click on the floating action button. I'll go out to my spinner. I'll click on the spinner. I'll make a selection. Click on that. So we'll go up to our Note title. We'll enter the note title. Then I'll go down my Note text, enter some note text. Then I head down to my Back button. And when I press the Back button, notice what happens interactively. I'll click on that. Notice that the first press of the Back button simply closed the soft keyboard. I need to press it a second time to actually exit the activity. So I'll press it the second time, and then once I do that, I've left my MainActivity, and that's what triggers the save. And that's the problem inside of our test. We have the code there that enters text into both the note title and the note text, but then when we press the Back button inside our test, all we've done is close the soft keyboard. So let's head back to our test code and see if we can fix that. So now we're back here in our test code, and what we want to do is make sure the soft keyboard is closed so that when we press the Back button we actually go ahead and leave the activity and perform the save. Now there's two ways we could do this. One way to do it would be to add a second call to pressBack, and that would actually directly simulate what we did interactively. But since we know what we want to do is actually close the soft keyboard before we leave the MainActivity, a better choice is to simply perform a closeSoftKeyboard action. So what we can do here, is in the onView call where we perform typeText, we can add a second action to the perform method. So after we type the text we'll add a comma, and then we'll use the closeSoftKeyboard action. You notice now that closeSoftKeyboard is underlined in red. And again, this is a situation where it's an ambiguous method. We need to specifically import the closeSoftKeyboard method that we want. So let me scroll to my imports. Then I'll go ahead and add the import for closeSoftKeyboard within the ViewActions class. So by adding that import, I get rid of the ambiguity. So I'll go and collapse my list of imports, and now you can see that the call to closeSoftKeyboard is no longer underlined in red. And this demonstrates a couple things. First of all, it shows us that when we call the perform method we can actually perform multiple actions if we want to because this one call to perform performs both the action of typing the text and closing the soft keyboard. It also shows us that we don't always want to write our test code exactly the way we perform things interactively. Although interactively we press the Back button twice, once to the close soft keyboard and then once to exit the activity, in this case, it was a better choice to use the closeSoftKeyboard method. That way we're much more explicit about what we're doing. We want to get the keyboard out of the way before we exit the activity. All right, so let's go ahead and run our test again, and let's see what things look like. So I'll go up to my green arrow, I'll choose Run, and I'll launch it within the emulator. And as you can see, our test now passes. So our CreateNewNoteTest works correctly. It interactively creates a brand-new note, and we're able to verify that it behaves as we expect. So now in our next clip, let's create another test, and in that test we'll include assertions to validate the state of the views displayed within an activity.

Creating a Test to Validate UI State
Here we are again with our app up and running. Let's look at another situation that we might want to add a test for. And in this test, we want to verify that certain parts of our user interface behave as we expect. So looking at our app, let's go ahead and select the first note in our ListView. So I'll click on that. Now, of course, when I make that selection, that displays that note inside of our MainActivity. And then notice we have this menu option up here that looks like an arrow. If I head up to that menu option and I tap on it, notice that it moves to the next note. If I tap on it again, it moves to the next note again. So one thing we might want to verify in our application is that this nexting process works correctly. So what that means is we'll have to write a test to select the first note in our ListView. Then when the MainActivity is displayed, we want to verify that the correct course, title, and text are displayed for that note. As long as they are, then we want it to click on our menu option, which should then move to the next note. So again, we'll want to verify that the correct course, title, and text are displayed for that next note. And we going to repeat that all the way through to the end of the list of notes. And then we'll test one more condition. When we reach the end of the list of notes, we'll verify that the menu item here is no longer enabled; otherwise, we'll verify that the user's not able to tap on it. So let's head back to Android Studio, and we'll start working on that test. So now we're back here in Android Studio, and I've added another test class to our Android test source set, and that's our NextThroughNotesTest class. Now I've done all the work to initially set this up. Notice that the class is marked with our RunWith annotation, and I have a Rule to launch our noteListActivity. I've also taken care of adding all the imports that we need. So these are all the same imports that we used in our CreateNewNoteTest, plus I've added an import for the ViewAssertions class because that's the class we use to verify the state of our views. So let me go ahead and collapse the Project window so we have some more room to work. And then with that out of the way, we can start building our test. Remember the first thing we did when we were doing this interactively is we had to select a note from our ListView. Remember that a ListView is a type of AdapterView, so we're going to use the onData function to make the selection. To make that selection, we'll use the allOf matcher just like we did in the CreateNewNoteTest. The selection is going to be an instance of NoteInfo, so we'll incorporate the instanceOf matcher. So that's the type of the item we'll be selecting, and the one that we want to select is whatever the first note in our DataManager's notes collection is. So we'll use the equalTo matcher, and then we'll pass in the first entry in the DataManager's notes collection. So that specifies what note we want to match on. So now we want to select it, so we'll perform the click action. And that's all we have to do to make the selection inside the ListView. And notice that's a little different than what we did with the spinner. In the spinner, we first had to click on the spinner itself, and then we could use the onData to make the selection. But in the case of the ListView, we can simply use the onData directly. So now once we make the selection, it'll display our MainActivity containing the first note. And we're going to want to walk through all the different notes inside our DataManager's notes collection, so let's go ahead and add a for a loop that increments through the indexes of our DataManager's notes collection. So we'll start out with for index in, and we want to count from 0 to the last index of our notes collection. And then here inside the for loop, let's go ahead and get a reference to the note at that index. So now once we have a reference to that note, we could then add the code to verify that our MainActivity is displaying the correct data for that note, and we'll add that code in our next clip.

Verifying Views Contain the Expected Content
Here we are back in the Android Studio, and what we want to do now is continue working on our NextThroughNotesTest. So we've already got the code in place to select the first note within our noteListActivity, and we have a for loop here that will then walk through each of the notes. And what we want to do in each pass of this loop is verify the proper values are being displayed within the views in our MainActivity. So let's first add the code to verify that the proper title is being displayed. So to do that we'll use our onView method, and we'll specify that we want the view with the ID of textNoteTitle. So now that'll select that view. But now in our earlier tests, once we selected a view, we would generally using the perform method to perform some action. But in this case, we don't want to perform an action. We want to verify that the view matches some matcher. So what we're going to do instead is use the check method. And then to the check method, we're going to pass in the matches method. Now what we want to verify is that the text property of this view contains the appropriate value for this note's title, so we'll use the withText method, and we'll pass in note. title. So what that code does is goes out and finds our view that has the ID textNoteTitle, and it makes sure that the displayed text corresponds to the current note's title. So we're just making sure that view is displaying the correct value. If it's not displaying the correct value, it'll fail our test. So now let's do the same thing, but this time we'll do it with the view that has the ID textNoteText, and we'll use the note's text property. So now we've got the code to make sure our views are showing the correct values for the note's title and the note text. Now let's go and add the code to verify that the correct course is being displayed. We'll do that just above where we verify the note's title. So we'll start out with the onView method, and we want the view that has the ID spinnerCourses. We'll call the check method, passing in the matches method just as we did with the noteTitle and noteText views. But because this is a spinner, we can't use the withText method. Spinners have a special method for verifying the displayed text. So rather than using withText, we're going to use withSpinnerText. And we want to verify that the displayed text corresponds to the title of this note's course, so we'll say note. course. title. And you notice that when we do that the dot after course is underlined in red, and that's because course can potentially be null. So to deal with that, rather than using a simple dot, we'll use?.. And remember the?. operator checks to see if course is null, and if it is null, it simply returns null. So now with that, we've got all the code we need to verify that we're displaying the correct course, title, and text for each note. So the next thing we need to do is start interacting with the next menu item, and we'll see how to do that in our next clip.

Interacting with and Verifying Menu Items
Here we are back in Android Studio, and what we want to do now is add the code to our NextThroughNotesTest to start selecting the next menu item. But now before we actually add the code specifically to select the next menu item, I'm going to add a condition here. I only want to select the next menu item as long as I'm not on the last note. So what I'll do is I'll add an if statement that verifies that our index variable is not equal to the notes collection's last index. Now within that if, I want to go ahead and perform the operation of selecting our next menu item. And from a testing standpoint, menu items are just views, so what we'll do is we'll start out with the onView method, and then I'll use the withId method, passing in the ID of that menu item, which is action_next. And then to make the selection, I'll call the perform method, passing in the click action. So now with that code in place, we can go ahead and perform the click on the next menu option. But now since this is a test that verifies UI behavior, more than just clicking on the menu option, we probably want to make sure that the option itself is clickable, so we want to make sure that this menu option is enabled. So what we'll do is inside the onView method, rather than simply calling the withId matcher, let's place that inside of an allOf matcher. And then inside the allOf matcher, in addition to using the withId matcher, we'll also use the isEnabled matcher. So with that there, we'll only perform the click on the menu option if we can find the menu option with that ID and that option is currently enabled. So that would help us detect if that menu option was disabled for some reason. So our test is just about done. Let's go and add one more check. Let's add the code after our for loop that checks to see if the menu option is now disabled. So after our for loop, we'll use the onView method, passing in the withId for action_next, and then we want to verify that it's not currently enabled. So what we'll do is we'll call the check method, passing in the matches method. Now if we wanted to verify that it's currently enabled, we would pass in the isEnabled method, so let's do that. But now remember we want to verify that it's not enabled, so we can wrap isEnabled in a not. So now we have a complete test. We'll select the first note in the ListView on our noteListActivity, walk through that list of notes verifying that the correct values are displayed, and then check the state of our next menu item after all those values are displayed. So in our next clip, let's run it, and let's see how it looks.

Running and Modifying Our UI Test
Here we are back in Android Studio. We're just about ready to verify that our NextThroughNotesTest works as we expect. But now before we do that, let's just take a look at our testing code here and make sure we have everything set up correctly. So our class is called NextThroughNotesTest, and although the name of the class doesn't matter, we do have to be sure that it has the proper annotations. So you'll notice that our class has the @RunWith annotation, and we pass in AndroidJUnit4, and that indicates that we want to use the test runner, AndroidJUnit4, so that looks good. The next thing we have to make sure we do is provide the rule to launch our starting activity. So we have our ActivityTestRule here, which indicates we want to launch noteListActivity. In order for the testing system to find that, that property has to be marked with our @Rule annotation and our @JvmField annotation. So our rule looks good. And then we have our test function nextThroughNotes. Now that contains all of our test code. But there's one thing that's missing. If we trid to run this test right now, we would actually get an error from the testing system telling us they can't find any tests to run. Because remember that in order for the testing system to run a test function, we have to annotate that function. It has to have the @Test annotation, and currently this function is not marked with that annotation. So let's go ahead and add @Test to our nextThroughNotes function. So now with that, we should be good to go. So let's go ahead and run our test and see what it looks like. So I'll click on the green arrow, I'll choose Run, I'll select the emulator, and switch over to it. See our app start, we're nexting through our notes, and then you notice the test in the background fails. So let's head back to Android Studio and see what's going on. So now we're back here in Android Studio, and we can see our error message. It says AssertionFailedWithCauseError: 'not is enabled' doesn't match the selected view. Then down below that we can see our stack trace, and we can see our nextThroughNotesTest code in there. So let's go ahead and click on that, and let's see what the error is. So I'll go ahead and select it. And notice that the failure occurred when we did to matches call on not isEnabled. So that tells us is that when we reach the end of the list, our next menu item was still enabled. It hadn't been disabled. So let's go and run the app normally, and let's see what's going on. So now with our app running normally, I'm going to go ahead and select one of the notes in the list. I'm going to head up to the next menu item. I'll click on Next. That advanced to the next note. I'll click on Next again. That advanced to the next note. But because it's our last note, notice that the appearance of the menu item changed. So let's see what happens when I click on it now. So I'll click on it. You notice that a message shows up at the bottom saying No more notes. So it turns out our test is incorrect. Our test was written to expect that menu item to become disabled when we reach the last note. That's not actually true. The application behavior is that that menu item remains enabled; it just performs a different operation. So the fact that our test is checking for it to not be enabled is the wrong test. What I actually want to do is verify that it's still enabled when we reach the end of the list. So let's switch back to Android Studio, and we'll fix that. So back here in Android Studio where we have the line to check to see if the menu item is no longer enabled, we want to remove that call, the not that wraps isEnabled. And so now our test verifies that the menu item is still enabled even when we reach the end of the list. So let's go ahead and run it again. So I'll click on the green arrow next to our function, I'll choose Run, and then I'll select the emulator. We see the test start, its nexting through the menu items, and then the test completes. And if we look in the background, we can see that all of our tests passed. So with that, we now have a test that properly verifies that our application behaves correctly when the user nexts through a list of notes using our Next menu item. In our next clip, let's take a look at something known as the Espresso Test Recorder.

Using the Espresso Test Recorder
Here we are back in Android Studio. Before we wrap up, there's one more feature of Android Studio I'd like to mention, and that's the Espresso Test Recorder. So to check that out, let's go up here to the Run menu inside of Android Studio. So I'll select that. You see that one of the options we have down here is Record Espresso Test. So I'll head down there. I'll go ahead and select that. We'll go ahead and run it on the selected emulator. And then once I make that selection, Android Studio takes care of launching my application, and it brings up this recorder screen. This allows me to interact with the application, and the recorder will record what I do. So I go up here to the floating action button, and I click on that. Notice that in addition to opening up my MainActivity, the recorder kept track of the fact that I performed a tap operation on the button with the ID fab. Let me head up to my spinner up here. I'll select that. Notice that the recorder now knows that I tapped on the spinner. If I go down here and make a selection, the recorder tracks that as well. So you can see what the recorder's doing is it's keeping track of all the interactions that I perform. Then once I've recorded all the operations that I want to capture, I can head over here to the recorder dialog's OK button. I'll go ahead and select that. It asks me for the name of the class that I want to put the code into. I'll just accept the default. And then from there, Android Studio generates the test code that corresponds to the operations that are recorded. Now one of things that you'll notice is that the generated code tends to be a bit more complex than the sort of code we'd write on our own. So for that reason, I don't really see the Espresso Test Recorder as a primary way to create tests, but it is a really powerful tool. If there's something you want to do and you don't know how to write to test code yourself, the Espresso Test Recorder is a great way to get a starting point to understand how to do that operation within your tests.

Summary
To wrap up, here's some of the key things you want to remember from this module. Remember that we first looked at the Espresso class's onData method, and that allowed us to interact with AdapterViews. And the way it works is it allows us to locate the contents within an AdapterView based on some data criteria. What the onData method returns back to us is a reference to a data interaction. And we can use that data interaction for a few different things, but one of the things we commonly do is use its perform method, and that allows us to interact with the top-level view that corresponds to the data match. Now we never want to lose sight of the purpose of testing. We do testing to verify the behavior performs as we expect. And there are two general kinds of behavior we need to verify. There is UI behavior, in other words, is a UI in the state, or does it contain the content we expect? So we can use the ViewInteraction's check method, or the DataInteraction's check method, and that accepts ViewAssertions that allow us to verify that the UI is in the state that we expect it to be. Remember that oftentimes, even when doing automated UI testing, we still really want to verify logic behavior. So in that case, the Assert class that we learned about in the module on local JVM testing remains just as important in our automated user interface tests as it was in our logic-based local JVM tests. All right, that wraps up this module, and it wraps up this course. Now as a reminder, this course is part of an overall series on developing Android apps with Kotlin. There's some other courses I'd really encourage you to check out. Now, if you haven't already done so, I would encourage you to check out my course Android Apps with Kotlin: Build Your First App. That really provides the foundation and fundamentals you'll need to start building Android apps using Kotlin. Another course I would encourage you to check out is Sriyank Siddhartha's Android Apps with Kotlin: Resources, Styles and Themes, and then my course, Android Apps with Kotlin: RecyclerView and NavigationDrawer. There's a lot of great stuff to learn about both Android and Kotlin, so I really encourage you to check out these courses, as well as other related courses from Pluralsight on these same topics. Thanks for taking the time to watch this course, and again, my name is Jim Wilson.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Beginner
Rating
0 stars with 8 raters
My rating
null stars

Duration
3h 42m
Released
30 Aug 2018
Share course