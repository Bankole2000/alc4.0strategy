Firebase on Android: User Email Authentication and Verification
by Mitch Tabian

Firebase is an emerging technology that targets mobile development. This course features the Firebase Authentication tool where you'll learn to integrate the cloud-based user management system.

The Firebase Authentication tool is arguably the most useful of the Firebase tools because you find a use for it in almost every application you build. In this course, Firebase on Android: User Email Authentication and Verification, you'll learn foundational knowledge that will give you the ability to seamlessly integrate a cloud-based user management system into your Android applications. First, you will learn how to register new users, send verification emails and sign-in existing users. Next, you'll learn how to restrict app-access to only users who have been authenticated. Finally, you'll learn how to manage user account properties like display name, profile image, and email address. When you're finished this course, you will have the skills and knowledge of Firebase Authentication needed to build a user management system for your Android applications.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
4.9 stars with 37 raters(37)
My rating
null stars

Duration
1h 13m
Released
11 Oct 2017
Share course

Course Overview
Course Overview
Hello everyone, my name is Mitch Tabian, and welcome to my course, Firebase on Android: User Email Authentication and Verification. I'm a self-employed Android developer and I'm here to teach you about an incredible new technology called Firebase. Firebase focuses on making life simple for developers. How do they make your life simple? They have a number of cloud-based, server-less, developer tools that are almost all free to get started with. In this course we're going to get some hands-on experience with my favorite developer tool, user email authentication. Some of the major topics that we'll cover include, new user registration. The app will contain a registration screen where users can enter their email and a password. The email and password will be saved on the Firebase servers. Verifying emails. Users will have to verify their email before they can sign into the app. After they register, a link will be sent to their email, once they click it, they'll be verified. Signing with email and password. Users will be able to enter their credentials on the login screen. If they've registered and verified their email they'll be able to sign in. Restricting app access to only authenticated users. Users that don't have a registered, verified email won't be able to authenticate. And if you can't authenticate then you won't be able to gain access to the application. By the end of the course you'll be able to seamlessly integrate Firebase email authentication into your existing Android projects, or you can start new projects without having to worry about constructing a cumbersome user-management system. There's no server needed and no database needed. Before beginning the course you should be familiar with Android Studio, but I'm going to guide you through everything, so if you're fairly new you should be okay. I hope you'll join me no this journey to learn about Firebase with the User Email Authentication and Verification course at Pluralsight.

Getting Started
Introduction
My name is Mitch Tabian, and welcome to my course Firebase on Android: User Email Authentication and Verification. In this course, you'll learn how to build an Android application that can register users, verify users, sign in emails, and manage user account properties. If you have any production development experience, you know typically this is not an easy task. There are many steps involved. You have to purchase a domain, build a website to manage users, implement an authentication system, such as OAuth1. 0, OAuth2. 0, or some other token-based system, and on top of that, you still need to worry about security and scalability. How will you ensure requests to your server are secure? How will your server handle 1, 000 users? What about 100, 000 users? Simply put, that is a ton of work. Wouldn't it be nice if there was some kind of tool that did it all, and didn't take a ton of time? I am incredibly excited to be making the first Android Firebase course for Pluralsight. And on top of that, I get to use my favorite Firebase tool, authentication. Firebase is s cloud-based framework with various developer tools for Android, IOS, and web development. If you've never heard of it, you're not alone. Firebase is a fairly new technology and was only just purchased by Google in 2014. After using Firebase for my production apps, I've come to really appreciate it. It's truly and amazing technology, and it's constantly improving the quality of life for developers. Imagine a one-stop shop for all things related to Android, IOS, and web development. To name a few other features, there's user management tools, a database, hosting, crash reporting, push notifications, automated cloud functions, the list goes on and on. In this course, we'll be focusing on the authentication tool, and more specifically email registration, login, verification, and all things related to managing user accounts. Here are some of the advantages of using Firebase for your authentication system, instead of a more traditional method. There's no domain needed, no server needed, no cumbersome OAuth requests, no worries about security, no problems with scalability, and way less time so you can start building your application, not worrying about user management. At this point, you're probably wondering two things. Okay Mitch, that sounds great, but how much does this service cost? And, number two, what makes it so secure? Well let's start with number one. Firebase is actually completely free to get started. Developers can create projects and use almost every cloud tool they have. You won't be charged until you reach a certain data threshold, or bandwidth threshold, and even then, the pricing's very reasonable. You can take a look at their pricing at Firebase. google. com/pricing. That brings me to number two. Earlier I mentioned that Firebase was purchased by Google in 2014, that means Firebase is built on Google's infrastructure, and if that doesn't give you enough peace of mind regarding security, here's some of the details on what happens behind the scenes. Firebase uses 2048-bit keys for the SSL certificates, they sign authentication tokens with SHA256 HMAC signatures, and they use BCrypt for password storage. Additionally, they have a unique way of defining security rules for their NoSQL database nodes, but in this course, we're not going to talk about the database. In the next section, we're going to talk about prerequisites and what you need to get started with this course.

Prerequisites
In this section we're going to talk about all the prerequisites related to the course. To benefit from this course I recommend a small amount of Android experience and absolutely 0 experience with Firebase. Basically, I expect people taking this course to know their way around Android Studio and know how to use the emulator. But I'm going to guide you through everything, so it's not a big deal if you're fairly new. I'm going to be coding in Android version 26, otherwise known as Android O, Firebase version 11. 0. 4, and Android Studio version 2. 3. You'll also need to install the Firebase SDK and Google Play Services SDK in Android Studio, but I'm going to guide you through that later. To test the application I'm going to be using a Samsung Galaxy J5. I'll be using a Google Chrome extension known Vysor to mirror the screen of my device on the computer. If you're using an emulator, you'll need to make sure Google Play services is updated to the latest version on the image. In the next section we're going to talk about the story behind the application that we're going to be building in this course. That way you have some real context as to why we're using Firebase for the authentication system.

The Story Behind the App
For the duration of the course we'll approach app development from the perspective of an imaginary company, Tabian Consulting Inc. Here's a scenario for Tabian Consulting. Tabian Consulting is currently a 10-person company that is looking to expand the personnel to 100 employees in just 12 months. For those of you with no experience in the corporate world, that's a sizable increase. A CEO recognizes there is too much manual work being done with respect to their current infrastructure around employee scheduling and communication. The current employees are a tightly-knit group who send out schedules via email and communicate through text and phones calls. With 100 employees there needs to be a more efficient system. The CEO has decided to invest in the development of a mobile application that will manage employee scheduling and provide a means of communication. The CEO has the following criteria in mind, it must be secure and only allow employees to access, it must be scalable as the company's growing, and she wants to minimize development cost, in other words, development time. The first point here specifies the application must only allow employees to register with an email address @Tabian. ca. So, someone named Mitch would have the company email mitch@Tabian. ca. The CEO is unsure about Firebase, as it's a relatively new technology, but you, as the developer, ensure her that it meets every criteria perfectly, and is owned by a very reputable company, Google. In the next section we're going to do a complete application demo and showcase all the features for the Tabian Consulting app.

App Demo
In this section, we're going to do a complete application demo. We'll demo the entire authentication process, including registration, login, and email verification. Let's start by viewing the Firebase console. I want to show you there's currently no users registered. If you're not familiar with Firebase, which I'm assuming most of you aren't, this screen is where all your application's users will be listed. Later we'll be going over this in detail, but for now, just notice there's nothing here. Now let's try to login using the email mitch. tabian. ca. Notice the Toast message saying Authentication Failed. The authentication failed because there are no users currently registered for this application, as we saw in the Firebase console. Now let's press the Register text view on the login screen. Here's the register screen. Let's enter mitch@tabian. com and choose a password of password. Now click REGISTER. Notice the application won't let you register with an email that is not of the domain tabian. ca. Let's change the email to mitch@tabian. ca, and click Register. Cool, we've been registered. Now let's check the Firebase console again. Notice an email has been entered. Now let's try to login again. That's the email verification blocking our login. Users won't be able to login until they verify their email address. I'll check my email inbox and verify. Here it is. Simply click the link and now my email's verified. Now let's attempt to login again. Cool, we've successfully authenticated. Here's the application. It doesn't do much, it's mainly just to help you conceptualize a real-live situation, and what it might look like. Everything on the screen does nothing, except the menu icon in the top-right. Here we can view another screen where we can change the email address, or click another option and sign out, let's sign out. Other features we'll be covering are sending a password reset link and resending a verification email. Users will be able to execute those actions by clicking on the text views below the SIGN IN button here. That's all for the application demo. In the next module we're going to get started building our Tabian Consulting application.

Integrating Firebase Authentication with Android
Software Requirements
In this module we're going to get started integrating Firebase authentication into our Android project. As I mentioned in module 1 we are going to be working with Android Studio version 2. 3 and Android version 26, which was officially released August 21, 2017. Android version 26 is otherwise known as Android Oreo, or Android O. To use Firebase with Android Studio we're also required to install the Firebase SDK and Google Play Services SDK. We need to take a look at the SDK Manager in Android Studio to make sure you meet all the requirements. And since we're going to be looking a the SDK Manager, we might as well create our new project. I'm going to name it TabianConsulting. The packaging isn't important, but if you copy mine it will make it easier to compare your code with mine later. I'm just going to name my package com. Pluralsight. courses, and then hit Next, and hit Next. I'm just going to grab Empty Activity, and we want to rename our launcher activity to LoginActivity, and that's it. And finally, let Android Studio build our project. Now let's navigate to the SDK Manager and see what we're dealing with. You should be familiar with Android Studio if you're taking this course, but, if you're not, I can show you how to get to the SDK Manager. You just click on Tools in the top of the menu, and go to Android, then SDK Manager. Now, let's take a look and see what Android version you have. It's important that you use Android O, because that's the exact same version I'm using. If it isn't, simply check the checkbox, and hit Apply, and Android Studio will install Android version O. Next, take a look at the SDK Tools. Here we need to make sure that Google Repository is installed under Support Repository. And Google Play services is also installed. If they aren't, simply click the checkbox and hit Apply. That's all we need to do to start using Firebase. Also note that if you're going to be using the emulator to test your application, ensure that it's updated. You can check that by viewing the status here. If it says it needs an update, click the checkbox and hit Apply. In the next section we're going to head over to the Firebase. google. com and get started connecting our application to the Firebase servers.

Creating a New Firebase Project
In this section we're going to take our first look at the Firebase cloud console and create a new Firebase project. As I mentioned before, Firebase is a cloud-based framework, so all we need to do is essentially point the Firebase project to our Android project and vice versa. After that they'll be connected forever unless you break the connection. To get stared with Firebase just head on over to Firebase. google. com. Once you're there, ensure that you've signed into a Google account. Firebase automatically syncs to your Google account so you can manage your projects from anywhere in the world. This course focuses on Firebase authentication, so I'm not going to go over any of the other Firebase tools, but if you want to learn more about them, check out these links below. In the top-right of the browser window there's button labeled GO TO CONSOLE. Click it and you'll be redirected to your personalized Firebase console. On this page, all of your Firebase projects will be listed below. If this is your first interaction with Firebase there will only be one button and it will say, Add project. Let's click it. Let's follow the instructions and give our project a name. I'm going to call it the same thing as the Android Studio project. This is not a requirement, it's just my preference. And my region is Canada, but you can enter your own region here. Click CREATE PROJECT and let Firebase build your project. This is what's called the project dashboard. It's a custom view where you can access all of your Firebase tools for your application; they're shown in the column on the left. Currently we don't have any of these features enabled, but in the next part we're going to take a look at the Authentication tab and integrating our Firebase project with our Android project.

Syncing Android Project with Firebase
In this section we're going to connect our Android project with our cloud-based Firebase project. Currently we have two standalone projects, one is the Android Studio project and one is a Firebase project. At this moment it time they are completely independent. The Firebase project exists on Google servers and the Android project exists on your computer. They might have the same name, depending on how you named them, but they have no idea one another exists. This module is all about connecting the two, and after we give our Android application access to our Firebase project we can integrate the authentication tool. Let's head back to the Firebase console. Before we start I just want to point out that you can verify you're looking at the correct project by viewing the pull-down menu in the top-left of the browser window. The project you have selected will display its name in this location. It's always a good idea to verify you've selected the correct project before making any changes. I don't think I need to tell you that making changes to the wrong project is definitely not a good idea. Now to add your Android app to the Firebase project, just select the icon that says Add Firebase to your Android app, right in the middle of the screen. As you can see from the top of the pop-up window, there's three easy steps we need to complete. In the first step we have three fields available to us, one says Android package name, another says App nickname, and the third one says Debug signing certificate SHA-1. The App nickname is 100% up to you and I'm just going to be leaving that blank. The SHA-1 certificate isn't needed to use email authentication, and as you can see below it's only required for dynamic links, invites, Google Sign-in, or phone number authentication. So we're going to be leaving that one blank too. We can get the application package from our Android Studio project. You can get it from any of the Java files in the main package directory, in our case, we only have LoginActivy. java, so that's what we're going to be getting it from. Let's open up LoginActiviy. java and copy the package from the top of the file. Now go back to Firebase and paste in that package name. Now press continue. Next is adding the google-services. json file to your application. The google-services. json file will allow Firebase to identify your application. It's very important not to copy mine from the source code files, you need to go get your own just as I'm doing in this video, if you take mine it's not going to work. Okay, now let's download the file and add it to a project. After downloading, navigate to the Project pane in Android Studio, expand the directory, and drag the google-services file into the app folder. (Working) That's it. Let's go back to Firebase and see what's next. This is now the final step. Add this first dependency to the Project-level build. gradle file and add the second dependency to your App-level build. gradle file. The two build. gradle files can be found in the same directory in Android Studio. One's labels Project and the other one's labeled App. (Working) Once you've added the dependencies, click the Sync button, wait for Gradle to finish, and head back to Firebase. Click FINISH, and we're done. The Firebase project and the Android project are now connected. In the next video we're going to take a look at enabling email authentication.

Enabling Email Authentication in Firebase
In this section we're going to enable the Firebase authentication tool in our Firebase project. Usually I would recommend checking out the documentation, but this is a very straightforward process. All we need to do is first click the Authentication option from the menu on the left-hand side of the browser, and now you should see three tab options, one that says USERS, one that says SIGN-IN METHOD, and one that says TEMPLATES. Your application's users will be displayed in the USERS tab. Obviously right now we have none, since there is nothing to display here. The TEMPLATES tab contains templates for sending verification emails, password reset emails, address change emails, and SMS verification messages. Later in this course we're going to take a look at the verification emails and password reset emails. If the TEMPLATES tab still doesn't make sense to you, these are essentially just templates for emails sent out to users. They get sent from the Firebase servers. For example, in our application, when users register a new email, they need to verify it. This email address verification template is what they're going to see coming into their inbox. Here's the Subject and the Message they'll receive. And finally, we have this SIGN-IN METHOD tab. This where we can enable our preferred authentication method, or we can enable multiple authentication methods. To enable one all we need to do is click the option we're interested in. Note that all the methods are a little different. Facebook, for example, requires you to register your app as a developer on their portal, and then there's a number of configuration steps you need to follow. In the future I plan on making a course for Facebook authentication, and there might already be one at the time you're watching this course. Now that we've enabled email authentication, let's take a quick look at the USERS tab again. View's changed. From here, you can actually add users manually to your application's database; however, I don't recommend this as it cuts through the application's regular sign-in flow, but let's add one, take a look, and then remove it when we're done. I'm going to add mitch@tabian. ca, and give it a password of password. Now we see a new user added to the list. We can see the Identifier, which is essentially the login credential, the provider is showing as email, because that's how we registered, the date created, and Signed In will show when the user signed in last. As you can see, he was never actually signed in. And, a unique user ID that Firebase automatically generates. This is how you will to use to identify users in your database, when you finally do get to use the Firebase database, which once again, we're not going to be covering in this course. You probably have noticed that the password is nowhere to be seen. It's not actually accessible for the developer and can only be changed via a password reset link. You can manually send a password reset link by clicking here. The only other options are Disable or Delete account. Disable does exactly as it sounds and disables the user from being able to authenticate and login. Delete also does exactly as it sounds, and will remove the user from the database. now that we have enabled email authentication and explored the console a bit, let's delete the user and move onto the next section, where we can actually start writing some code.

Implementing User Registration
Introduction
In this one, we're going to cover everything to do with the registration and sign-in process for your app. For the duration of the module I'll be referring to the source code files in the directory module_3\start\TabianConsulting. I encourage you to use my source code as I've included resources for drawables, colors, strings, and styles. If you don't use my source code you will probably have a hard time following along. Note that if you use my source code you need to change the package name to match the Firebase project's package name and also add the google-services. json file from your Firebase console. Do not use my google-services. json file, it will not work, it won't allow Firebase to properly identify your application. In this module we're going to talk about the required authentication dependencies, the registration screen, and all methods involved it the registration process. By the end of the module you'll be able to register a new user from your Android application, whose information will be stored on the Firebase servers. We're then going to test a sign in with the credentials you registered a user with. Before we look at the code I want to talk a little bit more about the Firebase documentation. Firebase has really great documentation. I can only think of a few cases when I found it difficult to follow, or maybe when it could have used a little more information. But overall, it gets a thumbs up from me. Getting to the documentation is simple, here's three different ways you could get there. Number one, search Google for Firebase documentation. Number two, go to firebase. google. com, and then just select Docs. Or you can just go straight to firebase. google. com/docs. Either way, once you're at the docs we can click on the Get started for Android text right here. Here's where you can find anything related to Firebase and Android. I just wanted to make sure I pointed out the documentation, because, out there in the real-world jungle of software development I won't be able to help, you'll need to be resourceful and help yourself. The documentation is always the best place to start. Now let's move onto the next section and add the required dependencies.

Adding the Required Dependencies
In the last video we left off in the Firebase documentation at firebase. google. com/docs. In this section, we're going to add all the dependencies required to use Firebase authentication in Android. Okay, so here we are back at the docs. We're interested in authentication, so let's select the Authentication option from the menu on the left-hand side of the browser. Now select Get Started. Here's a step-by-step outline containing everything you need to know for using Firebase authentication. As you can see we've already completed step 1 and step 2, the next step says, Add Firebase Authentication to your app. Well let's do it. Copy the dependency and open Android Studio. Go to the build. gradle app file, and add the dependency. Before you press sync we are going to need to change the version to 11. 0. 4. At the time of this recording, that is the most recent stable version. If you want to see more information about the versions, check the change log and go to firebase. google. com/support/releases. Okay, now press Sync and wait for Gradle to finish. Okay, let's head back to the documentation and see what's next. The next step is telling us we need to enable a sign-in method from the Firebase console. But, if you recall, we've already done that in the previous module. So, the following steps outline how to use objects involved in authentication. And below that, we have Sign up new users, which just outlines the method involved in signing up new users. And we have Sign in existing users, which is the same, but for signing in users. And then access information. If you ever get stuck, or can't remember something regarding the authentication process, a quick glance at the documentation is often all you need. Alright, so now let's head back to Android Studio and take a look at the code.

Registering a New User
In this module we're going to write all the code required to register a new user. Let's quickly go over the general process of user registration. A user will navigate to the register screen by clicking on the REGISTER text view widget on the login screen. Once they're at the register screen, the user will need to enter their email address and two passwords. I'm requiring that they use two passwords since then we'll actually be sure they entered the same one. We don't want them to make a mistake and accidentally enter and incorrect password if there's only one field. Once the fields are filled, they press the REGISTER button and a request will get sent to our Firebase server. That's it, pretty simple. Now let's open up Android Studio and open up the file name RegisterActivity. java. It's in the main package directory. We're going to start by taking a look at the on click listener on the register button, it's named mRegister. It can be found in the onCreate method of RegisterActivity. java. After clicking the Register button we have a few checks to make sure before submitting a request. Number one is that the fields are not blank. We don't want a blank email or a blank password being sent to the Firebase server. Number two, is that the domain is valid. Remember that one of the criteria was that the employees must have a domain Tabian. ca, or in your case, whatever domain your email's registered to. Number three, that the passwords match. Let's start by checking number one. I've create a method called isEmpty and it will return true is a blank string is passed to it. It's pretty straightforward, it just takes one string as an input and it will return true if that particular string is blank. And if for some reason, there's a blank value we just want to let the user know. For that we can use an else statement below our if logic and print a Toast message. Once we've verified the fields are not null we make sure that user trying to register is an employee of Tabian Consulting. We're going to verify that by checking for a company email To do that I've created a method called isValidDomain. Let's take a look at it. IsValidDomain will take an email and make sure it contains the substring @tabian. ca. It will take a string input and return true if the domain is valid. Note that you will need to change the domain restriction to whatever your email domain is. For example, if you have a Gmail account you need to change the variable DOMAIN_NAME to gmail. com. The variable DOMAIN_NAME is a global and declared above the onCreate method. Here it is up here. Just like when we checked the fields for blank values we want to print a Toast message if the domain is not valid. We can just write please register with company domain if the domain was not valid. Now we need to do one final check, making sure the passwords match. To do this we're going to use the doStringsMatch method, which I've included below onCreate. It's right here. The method simply take two strings as input, s1 and s2, then returns true if they match, it's pretty simple stuff. So, if doStringsMatch, mPassword, mConfirmPassword then we can proceed, else, let's print another Toast message letting them know that the passwords do no match. Those are all the checks we need to do, now we can write the method for registering a new email. We'll call it registerNewEmail and place it down below onCreate. The method will take two parameters, the email and the password. When the method is called we want to show the progress bar. That will ensure the user knows something is happening in the background and they need to be patient. Now let's get our FirebaseAuth instance and call the method createUserWithEmailAndPassword. Now add an addOnCompleteListener and go new capital O-N, and we can see the interface OnCompleteListener, select the interface, and let Android Studio build it for you. This is how most Firebase tasks are implemented. As the course progresses you'll become very familiar with this process. Generally you start with a method call, add an addOnCompleteListener, and then implement the OnCompleteListener interface. This is good time to write to the log so that we know the task was actually successful. So we can write task. isSuccessful, it will print out true if the task was successful, then we can write an if statement saying if task is successful then we can also write to the log again and print out the new user's user ID. In that case, we need to sign out and redirect the user to the login screen. You may be wondering, why do we need to sign out the user? By default, when you register a new user it will automatically sign them in, but later we're going to implement email verification so we want to sign them out and wait for them to verify their email before logging in. If the task wasn't successful, something went wrong, and we need to let user know. Don't forget to hide the progress bar once the task is complete. And one more thing here, on our OnCompleteListener interface we just need to make sure that we add a semicolon. That's it, that's all there is to registering a new user. Make sure to call the method in the mRegister on click listener, and let's test the app, and try to register a new user. Before we run it, I just want to show the Firebase console just to confirm that there is in fact no users currently registered. So there's our visual on that, now let's go back to Android Studio, and we'll click the Play button up here, select our device, and run the app. Alright, so here's the login screen, now we're just going to click the REGISTER text view. Now I'm going to type mitch@tabian. ca, and the first password of password, and the second password of password, and now hit REGISTER. Okay, so notice nothing happens, we didn't' get a Toast or anything, which is what we expect, we have no Toast message currently printing out if the task was successful. But, if we take a look at the log, we can see here that onComplete is true, so the task was definitely in fact successful. Let's check the Firebase console and see if there are any changes in the Authentication section. Cool, as you can see, we have a new user appearing in our console. If you don't have a new user in your console go back and make sure you followed all the steps outlined in this section. Remember, if you're using my source code you need to change the package to your package and the google-services. json file to the one Firebase gave you when you created your project. Do not use mine. So, keep in mind we haven't implemented email verification yet, we're going to be covering that in module 4, but for now let's move onto the next section and attempt to sign in our new user.

Sign-in Newly Registered User
In this section we're going to be signing in and authenticating the new user we registered in the previous section. To start, let's go over the general flow of the login process. Our user will enter their email in the Email field and their password in the Password field. Then, all they need to do is click SIGN IN and the authentication process will begin. It's pretty straightforward stuff. Let's open the file, LoginActivity. java in Android Studio. To being the authentication process we need to instantiate an object responsible for retrieving something called the authentication state. There's only two possible values for the authentication state, a user can either be authenticated or not authenticated. The object used to retrieve the authentication state is called an AuthStateListener. As its name implies, the AuthStateListener listens for changes to the, in the authentication state. In case that's not clear, essentially what it means to be logged in or authenticated is denoted by the status of the authentication state, and the only way to retrieve that status is by using an AuthStateListener. If you're still confused, just continue watching and I promise it will make complete sense in just a few minutes. I'm going to create a new method called setupFirebaseAuth, it's going to take no parameters and it's going to be responsible for instantiating our AuthStateListener object. I like to put all the Firebase stuff below this kind of Firebase setup header, just to help things stay organized. Inside the setupFirebaseAuth we simply go Auth State Listener = new FirebaseAuth. AuthStateListener, and implement the interface. Inside the interface we create a new FirebaseUser object and check to see if it's null. If the user object is null it means there is no user currently authenticated. If the user object is not null then we have a user that is authenticated. And we can print out to the log for both situations. To use the AuthStateListener object Firebase also requires us to do two more things. Number one, remove the AuthStateListener from the FirebaseAuth instance in the onStop method. Number two, we need to add the AuthStateListener to the FirebaseAuth instance in the onStart method. So let's press Ctrl+O on Windows, or Ctrl+Cmd on Mac, and we can insert our onStop and onStart methods. In onStop we want to remove the AuthStateListener, but we also need to make sure that we check to see if the AuthStateListener object is not null in the onStop method. Because if it's null and we try to remove it, the app will crash. (Working) After that, in the onStart method we just need to add our AuthStateListener. That's everything we need to use the AuthStateListener object. We just need to call setupFirebaseAuth in onCreate, and the listener will be actively listening for changes to the authentication state. We can then use a status of the authentication state to give access or deny access to the application. Now let's take a look at the on Click Listener for the signIn button and work on submitting a sign in request. You can find the signIn button in the onCreate method. The first thing we need to do after the user clicks the signIn button is check for blank values in the Email and Password fields. Once that's done we want to show the dialog and initiate the authentication request. The methods related to signing in a user look similar to the methods related to registering a new user, once again, we just use our FirebaseAuth object, but this time we want to call the method, signInWithEmailAndPassword. And pass the email and the password. Just like with the registration process we want to add an addOnCompleteListener and use the interface OnCompleteListener to listen for when the task is complete; however, we won't be actually taking any action in the OnCompleteListener for this task, all I want to do is wait for completion and then hide the progress bar. I don't actually care if it was successful or not; why do you think that is? Remember our AuthStateListener object? It's always listening, so it doesn't actually matter if I check for task completion after the sign in, the AuthStateListener will catch any change in the authentication state and then let me know. Alright, let's run the app and watch the log. Okay, so I'm just going to enter mitch@tabian. ca, and the password of password, and now hit log in. Cool, and right away you can see that the authentication state has changed and actually printed out the user's ID right here in the log. Now we have a way of knowing if the user is authenticated or not, but how will we use this to give or deny access to the application? In the next module we're going to learn how to send verification emails and make sure users have verified their email before they can log in.

Verifying a Registered User by Email
Introduction
In this module we'll be covering everything related to the process of verifying a newly-registered email. I'll be referring to the source code files in the directory module_4\start\TabianConsulting. When registering a new user it's important to verify their identity. For example, in this application only users with an email address from the domain tabian. ca are able to register. But, what's stopping from someone with registering with say, mitch@tabian. ca and then logging in immediately? Do you see what I mean? There's currently nothing confirming the person who registered with mitch@tabian. ca is the same as the person who has access to the email mitch@tabian. ca. In this situation, implementing something like email verification would solve this problem. Here's how it'll work. Upon registration an email will get sent from the Firebase server to the email address provided by the user. To flag the user's account as verified they'll have to click a link the email they receive. Once the link it clicked, the account will be verified, and they'll be able to log in. If they don't click the link they will not be able to login. In this module, we'll be building a method for sending verification emails to newly-registered users, and we're also going to add a check when users attempt to login. The check will contain some simple logic that confirms users have verified their email address. In the next section we'll get started building that method for sending the verification emails.

Building Method for Sending Email Verification
In this section we're going to build a method for sending a verification email to a newly-registered user. Before we begin, I want to mention something important. It's best if you uninstall the current application from the device you're testing on before we proceed. The reason being, you will be authenticated due to signing in in the previous module. To properly demonstrate this module I need you to be in an unauthenticated state, and as we currently have no way to sign out, it's easiest just to uninstall the application. You can uninstall by holding down your finger on the icon until it starts wiggling, and then dragging it to the Uninstall icon on the top of the screen. Once that's done, we can begin. Let's open up Android Studio and navigate to RegisterActivity. java. Scroll down below the onCreate method and let's create a new method named sendVerificationEmail. This method is going to be responsible for sending a verification email once a new user is registered. The method's pretty straightforward. First we have the Firebase user object by going FirebaseUser user = FirebaseAuth. getInstance. getCurrentUser. Now we simply call the method sendEmailVerification onto the FirebaseUser object. Like we always do with Firebase tasks, add an addOnCompleteListener, then implement the OnCompleteListener interface, and write some simple logic that will print a Toast message, depending on if the task was successful or not. We can just write something like Send Verification Email and Couldn't Send Verification Email. That's pretty much it. Do you see anything that we might to add to our method? If you guessed, make sure the user object is not null, you're right. We always need to make sure that user object is not null before calling any methods on it. If it's null, it will definitely crash the app. So let's just add a small if statement right here, and copy our logic, and put it inside the if statement. Alright, we're ready to use our new method. Head up to our createUserWithEmailAndPassword method and inside the if task. isSuccessful statement, let's call sendVerificationEmail. So once a new user's created a verification email will get sent and they will get signed out and redirected to the login screen. Perfect. Now all we need to do is go to the login screen and implement implement a check that's going to make sure they're, that user is verified before they can actually log in. In the next section we'll add some simple logic to login activity to ensure the email is verified before allowing a user to log in.

Restricting Login Until Email Verified
In this section we'll be adding a small amount of logic to the login screen so users who have not verified their email address will not be able to login. After that we'll talk about how users can manually send a verification email if for some reason they didn't receive it upon registration. Open up Android Studio and navigate to LoginActivity. java. As a refresher let's quickly go over the login flow. User enters their credentials and clicks the signIn button, a Firebase task is initiated by the signInWithEmailAndPassword method, if the task is successful the authentication state will change to a status of authenticated. Inside the OnCompleteListener interface there's nothing happening whether the user is authenticated or fails to authenticate. The state change is handled by the AuthStateListener object down in the setupFirebaseAuth method. So, after review, pretty easy to see that that's where we're going to need to check the email to see if it's verified. Inside the if statement it checks if the user is null, let's add a second check for the email, it's very simple. We just use if user. isEmailVerified, it will return true if the email is verified and false if the email is not verified. The only way to change the verification state from not verified to verified is if the user clicks the link set to their email upon registration. Now we've set our new if statement we can navigate to the sensitive areas of the application, because we know the user contains an email address from the company domain, and their email has been verified. We'll also need to add an else statement here. Inside the else statement we need to sign out the user. If we don't sign them out the user will remain authenticated from the sign in. To test the app we need to remove the current registered user and register a brand new user so a verification email will get sent. I want to mention again that, you'll need to change your DOMAIN_NAME variable inside registerActivity. java if you're using my source code, because obviously none of you are going to have a domain tabian. ca. You're likely going to have a Gmail or some other email. Alright, let's head to the Firebase console and remove that user that was registered before. So we just click on the user on this little ellipses icon on the right, and select delete user, and this will permanently delete the user from the Firebase server with no record of it ever being there. Alright, now we have no user there, let's run the app, and register a new user, and test the email verification. Okay, so here's the login screen, let's go to Register a new user, and I'm just going to enter the same thing, mitch@tabian. ca, and password, and password, and click REGISTER. Cool, so it says an email verification was sent, now let's head to the Firebase console and check that a user was added. Okay, there's our new user. Now I just want to try and log in to make sure that it's not going to actually let me and not authenticate. So we'll type mitch@tabian. ca, and password is password, and click SIGN IN, and there we go, we get a Toast message telling us that we need to check our inbox for a verification email. So far, so good. So, now let's check my email and see if that verification email is there. Okay, great. So, now I just need to click this link and it should verify my email. Cool. Now let's head back to Android Studio, and we'll open the log, and we're going to try and log in again. There we go, now it's actually authenticating me. So that's all great. We've successfully restricted application access to users who have registered with a company email and who have verified their email address. But what is user doesn't receive their verification email? As I'm sure you're well aware, software is far from perfect, even if it is from Google. So what can we do about that? There needs to be some way a user can manually resend a verification email if for some reason they don't receive one. That's what we're going to take a look at in the next section.

Resenting a Verification Email
Resending a verification email is a relatively straightforward process. Personally, I like to add a link to the login screen that users can click, enter their credentials, and then resend an email to their inbox. Firebase currently has no other way to resend a verification email, and there's no way developers can do it from the console. For that reason it's absolutely mandatory to have a way users can do it from the application. Software isn't perfect and sometimes the email doesn't send when users register. Before we begin, let's talk about a problem we're going to run into when resending the verification email. In Android Studio, open up the file RegisterActivity. java. If you've been watching carefully you probably remember when we sent the verification email upon registration, we used the method sendEmailVerification on the FirebaseUser object. Do you see the problem? There's no way for us to use that method because the FirebaseUser object is null unless the user is authenticated, and the user can't authenticate because they haven't received an email. It's a never-ending loop. So, what can we do? Take a look at ResendVerificationDialog. java. it's a simple class that extends dialog fragment. When the user clicks the Resend Verification Email text view on the login screen, the dialog will pop up and ask for their credentials. Inside the On Click Listener interface for the confirmDialog TextView, we're going to build a new method. The method will temporarily authenticate the user using their credentials and then send a verification email. After the email's sent, they'll be signed out, and they won't be given access to the app. Let's scroll down and build a method. We'll call it authenticateAndResendEmail. It'll take two parameters, their email, and their password. We're going to use their email and their password to create an object you haven't seen yet, an AuthCredential object. (Working) Now we'll do FirebaseAuth. getInstance. signInWithCredential, and pass the credential. As always, we'll need to add an addOnCompleteListener, and implement the OnCompleteListener interface. Now check if the task was successful and send an email if it was. After sending the email we need to make sure we sign out and dismiss the dialog. (Working) But what happens if the user enters incorrect credentials? For this particular situation we'll also need to implement on OnFailureListener. If the sign in fails, we'll let the user know, and a Toast message will say Invalid Credentials, and tell them to reset their password and try again. Users rarely get their email incorrect so it's usually a password issue. You can dismiss the dialog if you like, or leave it up and let the user try again. I'm going to dismiss the dialog. Inside the On Click Listener interface for the confirmDialog we'll call the method after checking for null values, and now we're ready to test the app. Okay, so here's the login screen, now we just click on the text view that says Resend Verification Email, and now we're prompted for our credentials, I'll just enter mitch@tabian. ca, and my password is password, and I'll hit CONFIRM, and we see a Toast message telling us that a verification email has been sent. So, now let's head into my email and see if I received a link. Great, there's the link. Let's click it and verify. Cool, just like before. So now if users don't receive a verification email when they register, they still have a way to manually send it. In the next module we'll go over how to use the authentication state to allow or deny access to the application.

Using the Authentication State to Maintain Security
Introduction
In this module we're going to be covering how to use the authentication state to maintain security and allow or deny users access to your application. I'll be referring to the source code files in the directory Module_5\start\TabianConsulting. Once again, I want to remind you that if you're using my source code, which I expect most likely you are, make sure to add your google-services. json file to the project and change the package to match your package. To start off, I have a question for you. Why do we bother doing all the work related to authentication? Generally it takes a lot of time and what do we really get out of it? Does that sound like a strange question? Let me explain. Wouldn't it be easier if we had system where anyone could log in and use the application? That way you wouldn't have to spend a bunch of time verifying identities and constantly checking if users are authenticated. the answer is, of course it would, but then how would we protect sensitive information? One of the main underlying reasons for implementing an authentication system is security. In this section we're going to go over how to manipulate the authentication state and give or deny users access to our application.

Getting Access to the App
In this section we're going to talk about the authentication state and how we can use it to manipulate the user experience. We'll talk about the AuthStateListener object and how it can retrieve the authentication state so we can use it. So far, all we've done when a user successfully logs is show the authentication state changing in the log. Let's head over to LoginActivity. java and take a look at our code. Inside the setupFirebaseAuth method we're going to use an intent and navigate to sign in activity if both the checks are confirmed. If you don't remember what checks I'm referring to, number one is checking their credentials, or in other words, if the FirebaseUser object is not null, and number two is making sure their email is verified. Remember, when a user is successfully authenticated, the AuthStateListener will catch the state change and proceed to check if the user is null with this if statement. Next we check to see if their email's verified. If both those checks return true, we can use an intent and start activity to navigate to signedInActivity. So, let's go Intent intent = new Intent, and LoginActivity. this, comma, SignedInActivity. class, then startActivity and pass the intent. Make sure to call finish after startActivity. It's very important as we don't want the user to be able to navigate back to the login screen after they've authenticated. If we don't use finish, LoginActivity will not be removed from the activity stack, and the user will be able to navigate back to the login screen by pressing the back button. Obviously that makes no sense and would yield a poor user experience. Alright, let's try it out. Just like we did in the previous module, let's first uninstall the application since we currently have no way to sign out a user. Okay, now let's run it again. So, I'm going to log in with my user, which is mitch@tabian. ca, and my password of password. Okay, cool, so I've now been navigated to signedInActivity and successfully authenticated with mitch@tabian. ca. This is an example of what you would see if you were trying to hide sensitive information from some users. As I talked about in the demo of this application in the first module, none of these buttons do anything or the text views do anything, this is just a dummy application to mimic what an actual application might look like. I've also added a Sign out feature to the menu in the top-right here. So we can click it and sign out a user. Now let's take a quick look at the log and check out what was printed. So we see here, the authentication state changed to authenticated, and the user ID was printed out here, then I clicked Sign out, and we have a sign out message also printed to the log. So now that we've gone through the process of getting access to the application after a user has been authenticated, do you see any potential issues? Can we count on users being authenticated 100% of the time? What if a user somehow gets into the application without logging in? In addition to restricting access before login it's good practice to check the authentication state in every activity. If you're using fragments for you application, the same rules apply.

Checking the Authentication State on Resume
In this section we're going to add a second layer of security by checking the authentication state in every activity. Let's take a look at SignedInActivity. java. And scroll down to the method checkAuthenticationState, it's below onCreate. Let's go over it. Remember we can check the authentication state by getting the FirebaseUser object and then checking if it's null. If it's null we know our user is not authenticated. And in that case, we should navigate them back to the login screen. Notice the flags I'm setting on the intent. I'm using Intent. FLAG_ACTIVITY_NEW_TASK, and Intent. FLAG_ACTIVITY_CLEAR_TASK. In this particular situation it's not necessary to do this because we only have a single activity the user can navigate to. Simply calling finish would do the trick here; however, 99. 9% of application will have more than a single activity. So we need to make sure we clear the entire activity stack before navigating to the login screen. Otherwise the user will be able to press the back button and gain access to the application. Using these flags will clear the activity stack. So that's actually all we need to verify the authentication state, but when should we call this method? As you probably guessed from the title of this section, the best place to put it in onResume. Let's take a look at the activity lifecycle so the reasoning is clear. As you can see, first onCreate is called, then onStart, then onResume. We could call the method in onCreate or onStart and it would work fine most of the time, but what if the user navigates to another activity and then back? In that scenario onStart wouldn't be called unless the previous activity was removed from the activity stack and then added back. In short, there are a few situations when onResume will be called and onStart or onCreate will not. If we check the authentication state in onResume we maximize the number of situations we can verify the user's authentication state. I encourage you to implement this process in all your activities and fragments. The process being, create a method for checking authentication state and then call the method in onResume. This will help ensure users are authenticated and thus adding a second layer of security. In the next module we'll take a look at managing some basic user account properties, such as display name, otherwise known as a username, and profile URL, otherwise known as a profile photo.

Managing User Account Properties
Introduction
In this module we're going to talk about some of the methods Firebase provides for managing user account properties. I'll be referring to the source code files in the directory Module_6\start\TabianConsulting. Most mobile applications offer some kind of user account personalization. Take Instagram for example, you can customize your display name, description, profile picture, website, the list literally goes on and on. Firebase offers some minor account personalization methods that developers can take advantage of to make things easier and save time. Here's how it works. The FirebaseUser object that we've been looking at throughout the course has getter and setter methods for getting and setting the user's personalized properties. The methods we're going to be looking at are getDisplayName, setDisplayName, getPhotoUrl, and setPhotoUri. Before you get excited, no, that's not a typo. The setter method for the photo is setPhotoUri, despite what the getter method being getPhotoUrl. We'll talk about that later. As their names imply, their methods are responsible for getting and setting the display name and profile URL of a particular user. You can think of them as a username and a profile image. At this point you might be thinking, saving a display name and a profile URL is great, but what if the user wants to change their email they registered with? And on the same vein, what about changing or resetting a password. It turns out changing a registered email is more involved than simply calling a method like, set email, and changing a password is no different. As an additional layer of security, Firebase requires re-authentication when changing a user's email or password. They require users to enter and submit their authentication credentials within a short timeframe before a change can be made. The timeframe is roughly 5 min, but I'm not 100% certain of that number. I've tested it up to 5 min, so I know for sure within 5 min you can make a change. In this module we'll take a look at changing a user's account properties, re-authenticating, altering a registered email, and resetting a password.

Getting/Setting the Display Name and Profile URL
In this section we're going to take a look at the methods involved in setting and getting a user's display name and profile URL. More specifically, the methods we'll be looking at are getDisplayName, setDisplayName, getProfileUrl, and setProfileUri. In your applications this will be great for saving a username and something like a profile image for a user. The nicest thing about using these methods is we don't have to worry about setting up a database or building a system for managing information. We simply get the FirebaseUser object and instantly we have access to these methods. One thing to note is no one will be able to alter these properties, except the authenticated user. They aren't visible from the Firebase console, so even developers can't change them, they're hidden, kind of behind-the-scenes, so to speak, much like the password, which can't be seen or altered from the console. Let's take a look at SignedInActivity. java. (Working) We'll start by creating a new method called getUserDetails. Inside getUserDetails we'll do exactly as its name implies and get the user account details. To start, we need to get the Firebase user object. So, FirebaseUser user = FirebaseAuth. getInstance. getCurrentUser. Then if the user does not equal null we know they are authenticated. then we'll create some string objects that will represent each property we're interested in. We'll create five strings total, one for the user ID, one for the name, one for the email, and one for the photo URL. I know I said we're only going to be looking the display name and the photo URL, but I want to show you the other properties we can view. So, we can go String uid = blank, String name = blank, String email = blank, and String photoUrl = blank. Now let's get the objects by calling methods on the user object. We can use getUid to get the username ID, getDisplayName to get the display name, getEmail to get the email, and getPhotoUrl to get the Photo URL. Alright, so first, user. getUid, then user. getDisplayName, user. getEmail, and user. getPhotoUrl. The area you're seeing is due to an incorrect type cast of the photo URL object. If we use the method getPhotoUrl it actually returns a Uri object. Hovering over the red underline will tell you just that. We need to change the photo URL object to a URI object instead of a string, which is no problem. I personally think this is a typo in the getter method since the object return is actually a URI, but the method is called getPhotoUrl. I haven't brought this to the attention of the Firebase staff, but I've been wondering about it for a while now. Now let's print all the user account properties to the log. We'll create a string that holds all the properties and then print it out using Log. d. So, String properties = uid + uid, then new line, and now I'm just going to copy that line and repeat it three times. So we go name, name, email, email, photoUrl, and photoUrl. Okay, now we can go Log. d and type properties, use a new line, and + properties. Now we just need to call this method in onCreate. So we'll open the log and run it. Okay, so, let's check the log here and notice here's our user account properties section here. And the thing I want you to notice is that the name and the photoUrl are null. They're null because we haven't set them yet. This user was created, and their name was never set, and their photo was never set. So, now we're going to move on and set those properties. So, we have a way to display the user account properties, now we need to work on a way to set them, and then display them. So we create a new method here and call it setUserDetails. This method is going to be responsible for altering the display name and the photo URL. The email can't be updated in the same fashion as we talked about before, this requires re-authentication. The user ID cannot be changed ever. It's a permanent unique ID that identifies a user. So once again we'll start off by getting the FirebaseUser object, but this time we're going to instantiate something new. (Working) A UserProfileChangeRequest object, we'll call it profileUpdates. And go new, UserProfileChangeRequest. Builder, and get rid of those two brackets. We're going to use a builder here since we'll be chaining a few methods on the UserProfileChangeRequest object. Now we can set a display name with setDisplayName, and set a photo URL with setPhotoUri. I'm just going to use a random Android image from the internet here, but you can use any URL you like. Just go to Google images and search anything you want, or, if you have something stored on imager, or any other photo hosting website, you can just use any, any URL. Oh, it looks like we've got some right here. So, this is because it requires a Uri object, but we currently have a URL. So we can just use Uri. parse and convert the string to a URI. Now we call. build and our UserProfileChangeRequest object is complete. Now we need to use a FirebaseUser object and use the method called updateProfile to pass the profile updates. As always, we'll add an addOnCompleteListener and implement the OnCompleteListener interface. At this point you should be very familiar with this interface as we've implemented it many times throughout the course. Now we'll check for task completion, and it printed a log that the user profile was updated, and finally call the getUserDetails method to print out our new details. Okay, scroll up to onCreate and comment out getUserDetails, and then we're going to add a call to setUserDetails. Alright, let's open the log and test the app. Great, so right away we're authenticated because we were already logged in, and we can see now our account properties have changed. We can see the name is Mitch Tabian, and also the image here is the image that we set with that URL. So everything seems to be working exactly as we expected. So now I just want to show you that those properties are permanently saved, they're not just saved kind of in the session, or they were set and then displayed right away, so everything was fine. I'm going to go back up to onCreate here and we're going to comment out setUserDetails and uncomment getUserDetails. I just want to show you that those properties are in fact saved on the Firebase servers, and now they can be called at any time. And they're not going to be changed unless the user changes them with setDisplayName or setPhotoUri. Cool, so, our account properties are still there, nothing has changed, and everything is working exactly as we expect. So now we know how to get and set the display name and photo URL, in the next section we'll work on editing a registered email address, re-authenticating and resetting a password.

Editing User Email and Password
In this module we're going to go over the process of re-authenticating and then editing a user's email. We'll also cover sending a password reset link. As I said earlier in the introduction of this module, editing an email address is not a straightforward process. But, it's not a straightforward process for a good reason. Firebase wants to protect authenticity, so they require you to re-authenticate users before editing an email that they registered with. In Android Studio let's take a look at SettingsActivity. java. This is the class that's responsible for editing a user's email. Navigating to it is simple. I've added a second menu option next to Sign out. Okay, let's head back to the code. There is a lot of code here so, I'm going to walk through it very slowly. On the highest level we have basically two possible scenarios. Number one is the user clicks the ResetPasswordLink and a password reset link will get sent to their registered email address. Number two is click the Save button and it'll attempt to change the user's email. First we'll look at sending a password reset link since it's a much shorter process. Scroll down to the method sendResetPasswordLink. There's a simple method we can use on the FirebaseAuth object called, sendPasswordResetEmail. Once the method's called it will execute a Firebase task, and the Firebase servers will send a password reset link to the user's email. We just need to pass the email in question, add an addOnCompleteListener, and implement the OnCompleteListener interface. Once the task is complete we can give the users feedback and let them know if was successful or if it failed. It's pretty simple stuff, let's test it. Okay, so let's go to Account Settings, and we're already authenticated to let's just click on the password reset link here. Okay, so it says, a password reset link was sent, now I'm going to check my email, and let's click the link and try to reset the password. I'm just going to change it to password1. Okay, so now let's try to log in with the new password. (Typing) And there you go, I'm authenticated. Also note that there was a password reset link that I put on the login screen. That one's a little different though because the user isn't already authenticated, they'll actually just need to enter their email, and then press confirm, and the app will send a reset link to their email, just like we just showed. Alright, now let's take a look at changing the user's registered email address. So we'll start up in the OnClickListener interface on the save button. After the button is clicked we have three checks to perform before attempting to change the email. Number one is, we need to check for null values in the email and password fields. Number two is we need to check to see if the email in the EditText field is different than the one stored in the FirebaseUser object. Number three is we need to confirm the user is attempting to change their email to one that contains a valid domain. If all these conditions are met we can call the method editUserEmail, which will initiate the update to the email. Let's take a closer look to that method. Alright, so first we'll show the progress bar so the user knows something is happening in the background, next we need to create an AuthCredential object. The AuthCredential object is exactly as it sounds, it's just a credential, so it takes their email and their password. Then once we have the AuthCredential object we can call the method reauthenticate on the FirebaseUser object. We can pass the AuthCredential, and like always, add an addOnCompleteListener, and implement the OnCompleteListener interface. We'll also need to implement an addOnFailure here because we need to hide the dialog if something goes wrong. So, in the OnFailureListener interface we'll print a Toast saying, unable to update email. If the task was successful, the user's credentials were correct, and they've been re-authenticated. Now there's a small timeframe of about 5 min that we can edit the email in. I'm not sure of the exact time, but I've tested it for up to 5 min. Now I've added a second check here to check if the domain is valid, I know we checked it in the OnClickListener for the save button, but in case you wanted to check it in this method instead of in the save button, I've added some additional logic for that here. So, once again, you just use the isValidDomain method and if the domain is not valid we just print a Toast message letting the user know that they need to register, or they need to change it to an email with a company domain. Now we need to check if someone else uses this email. If someone already uses it, obviously the user can't be allowed to claim it. To search for a matching email we use the method fetchProvidersForEmail on the FirebaseAuth instance. We pass the email, add an AddOnCompleteListener, and implement the OnCompleteListener interface. We'll also implement an addOnFailureListener, because once again, we need to hide the dialog if something goes wrong. In the OnFailureListener interface we'll print a Toast saying, unable to update email. This method's a little different than what we usually do in the OnCompleteListener interface; to check for a result we use task. getResult. getProviders. size. If it returns a size of 1, that means the email is in use by someone else. In that case we'll print a Toast message saying, that email is already in use, and now we'll write an else statement where we can finally update the email. To update the email we get the FirebaseUser object, call the method updateEmail, and pass them your email. Once again, add an AddOnCompleteListener, and implement the OnCompleteListener interface, and check for a successful task. We'll also add an AddOnFailureListener here because once again we need to hide the dialog if something goes wrong. So if the task was successful we need to send a new verification email and sign out the user. Once they verify their new email they can login again. Alright, it's time to test it. Okay, so, first of all I want to check and make sure the isValidDomain method is doing what it's supposed to be doing. So, I'm going to try changing it a. com domain, and there we go, we get Invalid Domain, perfect. Now let's change the email to mitch_1@tabian. ca, so the domain is valid this time. Great. So it said it updated the email, now let's go to the Firebase console and check to see if the email was changed. Cool, so it's showing mitch_1@tabian. ca. Perfect. Firebase actually does something pretty cool, when someone changes a registered email, the old email gets sent a notification saying that their email was changed. And they have the option to revert back to what the previous email was. That probably sounded a little confusing so, let's just check on my inbox. So here's the email, it's saying, a change was made to your account, the email was changed, and I can click this link and revert it back to what it was before. Just another layer of security here. And so now my email has been changed back to mitch@tabian. ca, let's check the Firebase console, and there you go. So, yet another layer of security here. And it also gives me a messages saying, you are probably going to want to reset your password. Alright, well, that was a lot of code for a really simple request. Most things don't take that long with Firebase, but this is an exception since we're changing an authenticated email. There's a high security risk involved. So we've covered everything from editing personalized account properties to more secure details like an email or a password. We're getting pretty close to the end of the course, we just have one section left, and in that section we're going to tie everything together and kind of summarize it all to give you a good overview of everything we've covered.

Tying It All Together
Final Summary
Congratulations for reaching the end of the course. In this final module we're going to briefly summarize everything we've covered and solidify this new knowledge. In Module 1 we talked about the advantages of using Firebase as opposed to a more traditional authentication system like OAuth. With Firebase there's no need to set up a server, no need to set up a database for managing users, no need to worry about generating encryption tokens, it's literally ready to go in matter of minutes as opposed to days, or even weeks to build a server and manage your applications users. Firebase is highly scalable. You can start with one user and with absolutely 0 work scale up to thousands or even hundreds of thousands of users. There's no worries about security, Firebase is a Google product and is built on Google's infrastructure. They use the newest and best encryption methods available. In Module 2 we went over how to integrate an Android Studio project with a Firebase project. In other words, we connected our applications to Firebase servers and enabled the use of Firebase authentication. We covered the SDK requirements for using Firebase, how to create a new Firebase project at firebase. google. com, how to sync your Android projects with a firebase project. This entailed referencing your package name, downloading a Google-services JSON file so Firebase could properly identify your application, and adding the required dependencies. Module 3 was broken down into 3 sections. Number one was adding the required dependencies for Firebase authentication. Number two was registering a new user. And number three was signing in a newly-registered user. Module 4 was broken down into 3 sections. Number one was building a method for sending verification emails, number two was restricting logins until the registered email is verified, and number three was how to resend a verification email. Remember Firebase has no way to do this from the console so it's absolutely mandatory that you build some kind of a method in your application so users can do it manually. Module 5 is broken down into 2 sections. Number one was getting access to the app, number two was checking the authentication state, and remember we talked about the best place to put it, and that was in the onResume method. Module 6 was broken down into 2 sections. Number one was getting and setting the display name and the profile URL, and number two was editing a user's email and password. Remember, editing a user's email and password required additional steps, you had to reauthenticate, because that information is more sensitive than just a display name and a profile picture. I think you'll all agree that we've come a long way since starting this course, and in such a short amount of time. And the incredible thing about it is we've only just scratched the surface of the features Firebase offers. Even in the context of authentication alone, we've looked at one out of the seven methods they offer. There's still phone number authentication, Google account authentication, Facebook authentication, Twitter authentication, GitHub authentication, and anonymous authentication, each with their own slight differences. If you could take only one thing away from this course, I hope it's a new appreciation for Firebase. It's truly an amazing platform and I'm proud to be presenting it to you. Keep your eyes open for my next Firebase course, there will definitely be another.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
4.9 stars with 37 raters(37)
My rating
null stars

Duration
1h 13m
Released
11 Oct 2017
Share course

