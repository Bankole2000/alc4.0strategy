Android UI Tests: Espresso Fundamentals
by Nora Valletta

Espresso is the official UI testing framework for Android. This course will teach you how to use and combine Espresso matchers, actions, and assertions to produce powerful UI tests for your Android apps.

Nothing offers peace of mind like having automated tests to validate that your application is working as intended. In this course, Android UI Tests: Espresso Fundamentals, you'll learn the fundamentals of writing Android UI tests using Android's official UI testing framework called Espresso. First, you'll explore a variety of common Espresso matchers and actions. Next, you'll discover all about assertions. Finally, you'll learn other tools that will come in handy as you journey into the heart of Android UI testing. By the end of this course, you'll have the skills you need to write clean and concise Android UI tests without having to worry about manual synchronization between test actions and UI elements.

Course author
Author: Nora Valletta	
Nora Valletta
With a love of computers that stemmed from playing video games as a little girl, Nora began studying at Southern Utah University in the year 2010. Her career in Android development began in 2013...

Course info
Level
Beginner
Rating
3.9 stars with 17 raters(17)
My rating
null stars

Duration
1h 18m
Released
15 Sep 2017
Share course

Course Overview
Course Overview
Hi everyone. My name is Nora, and welcome to my course, Android UI Tests: Espresso Fundamentals. I am an Android developer here at Pluralsight where I've had the opportunity to test and develop features for the Pluralsight Android app. Espresso is Android's official UI testing framework, which means that by the end of this course, you'll know everything you need to get started writing clean and concise UI tests for your android apps. In this course, we're going to cover the key components that make up the Espresso framework. I'll demonstrate how we can mix and match a variety of Espresso matchers, actions, and assertions to come up with simple, but powerful, UI tests. We'll also take a look at some of Espresso's other useful tools that allow us to easily interact with WebViews, verify our application's intents, and test asynchronous operations. By the end of this course, you'll be more than capable of writing tests that cover most Android UI scenarios that you'll come across, and if you're still not sure, then you'll definitely know what you need to search for on Google. This will be an epic journey into learning Espresso, and so I hope you'll join me in the Android UI Tests: Espresso Fundamentals course here at Pluralsight.

Introduction
Introduction
Welcome to Android UI Tests: Espresso Fundamentals. My name is Nora, and I'll be your guide on learning the basics of writing UI tests using the Espresso framework. There are a few reasons why Espresso is the de facto standard for writing UI tests in Android. For one, it offers us the ability to target Views and perform mock user interactions with just a few short method calls. This not only shortens our tests, but makes them much easier to read. In addition, the Espresso workflow is very easy to understand, so getting started with Espresso is painless and fun. Last but not least, Espresso is highly customizable. If you have a complex view hierarchy and need a custom matcher, it's very easy to add your own.

Our Espresso Workflow
Before we write any code, let's discuss our Espresso workflow. Our workflow will be very simple. First, we'll match a component with our UI under test. Once we've matched it, we can act, or rather use an action to perform a mock user interaction with the matched component. Finally, we can assert to verify the intended behavior. We'll combine our assertion with a matcher, as I'll show you in just a moment. Let's go ahead and apply this workflow. First, we'll match a view and perform some kind of action, then we'll match another view and assert that it matches some criteria. For example, let's say that we have an app with a button and a TextView. When we click the button, we want our TextView to set its text to The button was clicked! Here's how we would accomplish this. We'll find the button by its ID and click it. Next, we'll find the TextView by its ID and check that it has the desired text. This works like any other assertion. If the assertion fails, the test fails. If it passes, then we're good to go.

Espresso Dependencies Explained
Now that we've gone over the basics of Espresso, let's get our dependencies in order. First things first, we'll use testCompile for our local test dependencies and androidTestCompile for our Android test dependencies. TestCompile dependencies are only compiled when building plain old Java tests and androidTestCompile dependencies are only compiled when building instrumented, or Android, tests. We'll also be using a lot of JUnit 4 test annotations, and we'll be using the APIs provided by Android's testing support library, so make sure you include both in you build. gradle file. You'll also want to include espresso-core as an androidTestCompile dependency. These next dependencies sort of depend on what you're testing. If you want to use RecyclerView actions, drawer actions, or accessibility checks, you should include espresso-contrib. Include espresso-web if you need WebView support in your tests, and espresso-idling-resources for synchronizing background tasks. If you'll be validating or stubbing intents, you'll want to include espresso-intents.

Running Tests in Android Studio
Okay, so we've gotten our dependencies out of the way, let's learn about running our tests in Android Studio. The app/src/test directory is where your local unit tests should go. Local unit tests are simple, plain old Java tests that run on the JVM and require no Android-specific components. This means they can be run quickly, as they don't require the use of an Android device or emulator. In this course, we won't be writing any local unit tests. Instrumented unit tests, or rather, tests that require access to Android framework-specific components belong in our app/src/androidTest directory. This is where our UI tests go. The process of running these tests include building your app, installing it on an emulator, or real device, and installing the test APK alongside it. Because they must be run on an emulator, these tests can take a lot longer to run than your local tests. There are a couple of different ways we can run our tests in Android Studio. If you head over to your project in Android Studio, you'll see the androidTest and test packages located just inside you app/src folder. If you right-click on one, you'll be given the option to run all tests within the selected package. Instrumentation tests can take a long time to run, especially if you have a lot of them. If you only want to run tests within a single class, you can right-click on the class name and click Run from there. If you'd like, you could also run a single test by right-clicking on it as well. Keep in mind that even if you only run a few of your UI tests, Gradle will still have to go through the process of making sure the most up-to-date app and test APKs are installed on the device, which can take a lot of time with larger code bases. Here's one common pitfall you should look out for. Make sure your device is unlocked and awake while your instrumented tests run, otherwise, your tests might fail with a NoActivityResumed exception because onResume was never called. It's super easy to forget this and frustrating when it happens. We've learned a little bit about Espresso and setting up our test suite in Android Studio, so now we can start drilling down into the specifics on what Espresso has to offer. Join me in taking a closer look at some of Espresso's most commonly used tools as we write tests for our Coffee Companion Android app.

Using Matchers to Target Specific Components
Using Matchers to Target Specific Components
In this module, we'll learn about the various matchers that Espresso offers us to help target specific components under test. There are a variety of matchers to use, but we'll focus mostly on ViewMatchers, which are one of the most commonly used matcher types. There are other matchers at our disposal as well. Android AdapterViews that are backed by cursors are pretty common, so CursorMatchers help us match specific data rows in a cursor, and can be used with Espresso's onData utility. LayoutMatchers help us match and detect typical layout issues. Specifically, it helps us match TextView elements that have ellipses or multi-line text. RootMatchers help match root objects. You can use a RootMatcher, for example, to match roots that are dialogs or roots that are able to receive touch events. PreferenceMatchers help us match Android preferences and allow you to find specific preference view components based on their key, summary text, title, or whether or not the preference is enabled. Finally, we have the BoundedMatcher. The BoundedMatcher is used for creating your own custom matcher for a given type, and a specific subtype for the actual matching.

ViewMatchers
Before we dive into the code, I wanted to introduce to you some of the most common ways that ViewMatchers are used. ViewMatchers allow us to match views in a variety of ways, such as by their ID, value, class, such as TextView or ProgressBar, parent, sibling, or child. These alone are more than enough for most use cases. ViewMatchers can also match a view based on whether or not it's enabled, focusable, displayed, checked, or selected. If, for example, we want a progress bar to appear when we tap on a button, we could use the isDisplayed ViewMatcher to find out. Remember, we use matchers to target specific components under test. With that in mind, if you're wondering how a ViewMatcher can possibly tell us if, for example, a certain view is focusable, we can use matchers combined with an assertion like so.

Demo: Using and Combining Matchers
Now for the fun part, our Coffee Companion app needs some UI tests to help confirm that everything's working as expected. So let's go ahead and write some. In this demo, we're going to write tests to ensure that a TextView is displaying the right text, a FloatingActionButton is displayed, and that an ImageView has the correct content description. Here we are in Android Studio, and I've got my emulator running Coffee Companion. The UI is very simple. We have a collapsing toolbar layout with an ImageView and a TextView, followed by a RecyclerView of beverage items, each with their own TextView and ImageView. Here on the right, we have a FloatingActionButton. Let's say we want to write a test to ensure that our FloatingActionButton is currently displayed. Fortunately for us, our FloatingActionButton has an ID we can use to find it by. Since our FloatingActionButton is on our BeverageListActivity, we'll go over to the BeverageListActivityTest class and start writing our test. I've gone ahead and stubbed out all of our test methods, but for now let's focus on testMapFloatingActionButton_shouldBeDisplayed. Let's go ahead and find our view, onView withId R. id. fab. Now that we've targeted our FloatingActionButton, we'll check that our view is displayed. If we go ahead and run our test, it should pass. Okay, let's move on to the next test. Let's again refer to our BeverageListActivity layout. As you can see, we have a collapsing toolbar layout that contains an ImageView. For UI elements that require an explicit label to indicate their purpose to the user, it's a good idea to include a content description. Notice that our toolbar image has a content description already set. However, there are situations where you might want to set the content description programmatically as well, and for those situations, having a test that verifies that the correct content description has been set can be very useful. So let's go ahead and write a test to verify that our toolbar image has the appropriate content description set. Let's look at testToolbarImageView_shouldHaveContentDescription. And again, we will find the view by its ID, but instead, this time we'll use the withContentDescription ViewMatcher in conjunction with an assertion to verify that our toolbar ImageView has the right content description set. Once we've run our test to make sure it passes, we can move on. Next, let's go back to the emulator and take another look at our UI. Notice how our toolbar has the title Coffee Companion. Here's the thing, we didn't actually put that there, and if we take another look at our layout, we won't be able to find this TextView at all. So how do we test views that are added dynamically, or might not have an ID for us to find it by? One thing that you might find useful is Android Studio's Inspect Layout tool. While our app is running, let's trying clicking the Inspect Layout button and see what happens. As you can see, we now have a snapshot of our view hierarchy. Using this tool, we can see which child views belong to which parent, and if we click on one, we can also see the properties currently set for that view. Now let's go ahead and take a look at the Toolbar. We see here that our toolbar has a couple of children, one of them being an AppCompatTextView with the value of Coffee Companion. If we scroll down its list of properties, we'll actually see that it doesn't seem to have an ID for us to utilize. Well, there's still a way we can target this view for testing. Let's go over to our BeverageListActivityTest and I'll show you. Since we know that our toolbar title is an AppCompatTextView, can we use a ViewMatcher to find it by class? As you may have already noticed by the ominous test name, the test we're about to write will fail. Let's find this toolbar title by class and ignore that for now. OnView isAssignableFrom AppCompatTextView. class. Now that we've found our match, we assert that this view has a text value of R. string. app_name. Now, let's run the test and see what happens. That's a bummer. Our test failed. If we take a look at the stack trace, we'll see that an AmbiguousViewMatcherException was thrown. This happened because there's more than one view that matches our criteria in our view hierarchy. So Espresso has no idea which view we want it to run our assertion against. Things just got a little trickier. Luckily for us, ViewMatchers can be combined to help us target views that are unique when taking into account a variety of criteria. Remember, our title is currently the only AppCompatTextView with a toolbar as its parent. If we're confident that this will always be the case, we can go ahead and use allOf to match views that not only are of type AppCompatTextView, but that also have a parent of type toolbar. Doing this in our case will narrow our ViewMatcher results down to just one, and Espresso can then proceed to run our assertion. Running the test with this modification, we can see that our toolbar title text is indeed set to R. string. app_name. Sometimes, Espresso doesn't quite have the matcher you're looking for. If this is ever the case, you can create a custom matcher. Let me show you how. Refer to our BeverageListActivity, behind the scenes, we have a beverage object, which has a name, description, and drawableResourceName. Basically, when the application starts up, the beverages are parsed from a JSON file, and the results are what populate our RecyclerView. As you can see, each of these beverage items has a title that corresponds to the value returned from beverage. getName. At this time, there are limited resources out of the box for testing Espresso RecyclerView items. So why don't we go ahead and write our own matcher to make sure that our beverage's RecyclerView has been populated correctly? It's time to head back to our tests. This is what the beverage at index 0 in our RecyclerView looks like. Let's carry on as though we already have a matcher for what we want to do. Okay, so I've already gone ahead and instantiated the beverage whose data belongs in spot 0 of the RecyclerView. Now that we have that, similar to previous tests, let's use an Espresso ViewMatcher to find our RecyclerView. OnView with ID R. id. beverages_recycler. Next, we want to check that the beverage at a given position is populated correctly. Let's call it hasBeverageDataForPosition, and it will need the index of the ItemView and the beverage whose data we're checking against. Great. Now all we have to do is write hasBeverageDataForPosition. What I'll do now is write a static function that returns a Matcher of type View. So again, two arguments here, the position of the item we're testing against, and the beverage whose data belongs in that item's views. If you remember earlier, I mentioned something called a BoundedMatcher. Here's where we'll get to use one. We're matching a view of type RecyclerView, so that will be the type and subtype of our BoundedMatcher. Next, we need to override matchesSafely. MatchesSafely should return true if the given view matches our criteria and false otherwise. MatchesSafely takes the subtype, or in our case, a RecyclerView, which we'll use to find our beverage item. We'll do this by finding the viewHolder for the given adapter position. If the viewHolder is null, we know it can't possibly have our beverage's data, so we return false. Otherwise, we'll check the following, if the ItemView has a child with the text beverage. getName, matchesSafely will return true. Otherwise, matchesSafely returns false and our assertion fails. Before we run the test with our custom matcher, we should make sure we override describeTo. In describeTo, we append the description with our own description of what our matcher is looking for. This is helpful for when an assertion fails due to our custom matcher. In fact, let's change up the item index so that our test fails. I want to show you where you can see the text we've appended in describeTo. When the test fails, if you click on the test name and look over to the right, you should see the message we've appended using describeTo. And if we fix our test, changing the index back to 0, we can see that the RecyclerView item at position 0 does in fact have the correct data. And that's all there is to it.

Mimicking User Activity with Actions
Mimicking User Activity with Actions
Now it's time to learn about Espresso actions, in particular, ViewActions. Espresso's actions are what allow us to interact with the UI during a test, just like the user normally would. Espresso offers plenty of actions we can perform during our UI tests, and I won't be able to cover them all here, but just for example, we can type text into a view, scroll within any descendent of ScrollView, send key events to a view, perform any available EditorAction on a view, force an AdapterView to load specific data into the view hierarchy, swipe across a view, click on a view, close the soft keyboard if it's open, invoke the onClick of a link within a TextView, and finally, we can replace the text within a view. Some actions will be used much more often than others, and Espresso's ViewActions class has you covered for most of your action needs. ViewActions contains a variety of static helper methods for Espresso's most commonly used actions. Some examples of this are click, openLinkWithText, swipeRight, swipeLeft, typeText, and pressBack. It should be noted that each of these could change the state of your UI. We'll be discussing why that's important next.

Actions and UI State
Our tests can be as simple as using an action to enter text into a view, and then using an assertion to find out whether or not the UI has changed in response. However, sometimes our UI can be a bit more complex and our tests might reflect that. Here's an example. Let's say we have an activity filled with lots of content that scrolls vertically. At the very bottom, there's a button with the ID of submit_button, and right above it is an EditText with an ID of input_edittext. As you can see, we can just barely see the top of our EditText right now, and our button is not currently visible to the user. Now if we didn't scroll to the bottom, and if we tried using Espresso to enter text into the EditText and then click on the button, our test could fail because at least 90% of the view's area must be displayed when we attempt to interact with it. If you think about it, this kind of makes sense. How can the user interact with a component that isn't even on the screen? Anyway, if we want to remedy this, we perform scrollTo and check to make sure that the button is displayed before we proceed. This way, we know that the button is now on screen and ready to interact with the user. Now let's go ahead and type something into that EditText. We can first check that the EditText is completely displayed just to be sure, and then we can perform the view action typeText to enter the text I love cats! Just as a side note, if you don't actually love cats, rest assured that this assertion will still pass. Now that we've entered our desired input, let's go ahead and use the click action to click on our Submit button. Usually, when we click on a button we expect something to happen. So let's pretend that the Submit button was actually supposed to launch a new activity. We'd use Espresso-Intents to check if the activity was actually started, but we'll talk more about Espresso-Intents later in the course. Anyways, once we've verified that our activity has started, we're good to move on. Notice how we used a combination of actions to get to our end result. We started at the default position in our activity at the very top. Next, we scrolled to a button, which was located at the very bottom of our activity. We then made sure that our EditText was visible and performed the typeText action. Finally, we clicked the Submit button. If we were to try interacting with the button or the EditText while they were still off screen, our test might have failed because those views were simply not visible to the user at the time, so a user would never have been able to interact with them. This is just something to consider when using actions to manipulate the UI during our tests.

Demo: Using Espresso Actions
It's that time again. We have more UI tests to write for our Coffee Companion app. This next demo will feature several common actions. We previously mentioned using Espresso's scrollTo method to scroll within a descendent of ScrollView, but the RecyclerViews are a little bit different. We'll scroll to the bottom of the RecyclerView, select the item at the bottom, and press the Back button as a user might do when they want to return to the previous activity. Since it can actually help to see what we're testing, let's go ahead and bring our Android Emulator to the forefront. When we launch the app, we're initially taken to the BeverageListActivity. Let's use some Espresso actions to test the following behavior. Let's find the item at index 6 in our RecyclerView and tap on it. When we do this, the BeverageDetailActivity should have been launched, and if we click back, we should be back to where we were, scrolled to the very bottom of our RecyclerView. Let's write testBeverageClick_shouldOpenBeverageListActivity. This test is going to be much more complex than it needs to be, but I want to demonstrate how the state of your UI is changing as we perform these actions. So to start, let's find item 6 on our RecyclerView, and assert that it is not currently displayed. We can find it by its text Café mocha. This test will pass on some devices and fail on others. If you're running tests with a variety of device screen sizes, some views may or may not always be displayed. The emulator I'm using right now is a Nexus 5x, and our item 6 is not currently displayed unless we scroll. So what we want to do next is find our RecyclerView using, you guessed it, onView withId R. id. beverages_recycler. To scroll our RecyclerView, let's use RecyclerViewActions. scrollToPosition 7. You might wonder, why do RecyclerViews get their very own set of actions? That's because RecyclerViews are not AdapterViews, so you can't just use Espresso. ondata as you normally would. Next, we'll perform a special action that was created specifically for RecyclerViews, RecyclerViewActions. actionOnItemAtPosition 6, and then we'll pass in a click action. At this point in time, we should expect that our BeverageDetailActivity has been launched, and this is how we would assert that. If any of this looks unfamiliar, that's okay. We'll talk more about Espresso-Intents later in the course. Now that we're on the BeverageDetailActivity, let's press back. To make sure that we're still scrolled to the bottom of our RecyclerView, let's add one last assertion to check that the Café mocha beverage item is displayed. If we run this test, we can see that it passes. Great. Feel free to write tests that manipulate the UI in different ways and verify against what you expect might occur. In the real world, however, if I wanted to test whether or not a BeverageDetailActivity is launched when I tap on a beverage item, my test would simply look like this.

Common Pitfalls
Let's discuss a few common pitfalls when using Espresso actions to interact with your UI. If you remember earlier, I mentioned that you should make sure at least 90% of your view is visible before attempting to interact with it, or your test could fail. This is something you should definitely keep in mind when running tests on a variety of devices with different screen sizes. Don't be caught off guard if some of your tests fail on a smaller device because you forgot to scroll or swipe to bring the view on screen before interacting with it. Here's another very common pitfall that you should be aware of, make sure that all view manipulation code is performed on the main thread. The main thread refers to the thread created by the Android system for your app. It's in charge of dispatching events to the appropriate UI widgets, so you often hear main thread referred to as the UI thread. If you ever hear either of these, know that they're the same thing. Because it's important that your app doesn't block the main thread, many apps will do background work and a worker thread, or an ongoing service. If you ever find yourself in a position where you need to update the UI from any thread other than the main thread, you can use activity. runOnUiThread, View. post, and View. postDelayed. I cannot stress how important it is to be aware of this. As your application grows and you're doing more and more wonderful things on a worker thread, all it could take is one stray UI operation, such as hiding a dialog or showing a progress bar, and your app could crash at runtime. This is why having good test coverage is important. Your tests alone could help prevent this sort of thing from happening.

Summary
In summary, we learned how to avoid common pitfalls, such as making sure at least 90% of the view is visible before performing an action on it, or making sure to perform any kind of UI operation on the main thread. We learned how to click on a view. This sounds incredibly simple, and it is, but clicking on a view and checking to see that the UI has the intended behavior is probably the most common thing you'll ever do in your UI test, and this is an introductory course after all. Given that you should now also be familiar with basic Espresso matchers, you should be able to click on almost any given view in your hierarchy, which is incredibly useful to know how to do. We also learned how to scroll within a ScrollView using Espresso's scrollTo action, and how to scroll within a RecyclerView using RecyclerView actions. I made sure to include RecyclerView actions as part of the tutorial since RecyclerViews are such a common way to display a list of content. Finally, we learned how to press the back button. This one's unique because on some devices the back button is actually a hardware button, which can make things a little bit trickier. There are other types of actions which involve interacting with the UI in unique ways as well, such as closing the soft keyboard or pressing the menu key. If you're ever interested in delving further into Espresso actions, feel free to check out the official Android documentation when you get the chance.

Declaring Expectations with Assertions
Declaring Expectations with Assertions
In this module, we'll be looking at some utility classes that provide us with common assertions to use in our tests. Before we do that, I wanted to start by talking about assertions in general. If you're already familiar with assertions within the context of software testing, please feel free to skip ahead. Part of why we write tests is to ensure that our product meets the expectations of the end user. These tests are made up of assertions, and some requirements under test require multiple assertions. Let's say we have a view that is only supposed to be displayed when the user is online and logged in. So we write a test that asserts that the view is displayed when we're online and logged in, and then we ship our product. Now that our product is live, a few bugs crop up. The view is still visible, for example, even when the user is online, but not logged in. Also, the view is still visible when the user is offline, but had already been authenticated. To protect against this, and to adhere to our requirement that the view be only visible when the user is online and logged in, we need these four assertions. We check that the view is displayed when the user is online and logged in, but we also make sure that the view is not displayed when the user is online but not logged in, when they're offline and logged in, and when they're online and not logged in. Make note of the connection here. We had several different situations to cover. The view can either be visible or invisible, which means only two possible outcomes for each scenario. Our total number of scenarios comes from the fact that the user must be online and also logged in. So again, 2 possible outcomes for our view, raised to the power of 2 different constraints, each of which are either true or false. This gives us a total of four assertions. If we added another constraint, for example, the view may be only visible when the user is online, subscribed to our service, and logged in, that's 3 possibilities, so we'll need 2 to the 3 assertions for a total of 8. The idea here is that if we want to maximize coverage, we're going to want to cover all possible situations so long as they're not already covered transitively by other tests. In a nutshell, it's important to come up with relevant and well thought out assertions. It all starts with our acceptance criteria, which is the required behavior of our application. Once we have that, we can come up with our assertions for the criteria. And that's it. With that in mind, we can write our own tests and, hopefully by the end of it, we'll have comprehensive test coverage. At that point, releasing our code to production won't be so scary.

Espresso Assertions
As with matchers and actions, Espresso also provides a collection of nifty assertions for us to use in our UI tests. In Espresso, a ViewAssertion is simply an interface with a single public method called Check that accepts a view to perform assertions against and a NoMatchingViewException to throw if the view parameter can't be found. In our tests, you'll notice that we've been using ViewAssertions all along. Naturally, the ViewAssertion is part of the Espresso framework, and its whole purpose is to be used in conjunction with matchers and actions to build and verify UI state or behavior. You can guess this one from the name, but according to its official Android documentation, it's responsible for performing assertions on a view element. The cool thing about ViewAssertions is that we're able to write our own if we wanted to, just like how we're able to write custom matchers and actions because they're part of the Espresso test framework's public API. For most cases, however, you'll probably just want to stick with the ready-made ViewAssertions offered by Espresso. If you really do want to write your own custom ViewAssertion, you'll have to adhere to the following rules. Your ViewAssertion implementation should always through a JUnit AssertionError if the assertion does not hold, run on the UI thread, which also means making sure not to perform any blocking operations, not attempt to mutate the view parameter that is passed into the ViewAssertion check interface method. This would lead to your assertion having side effects that could alter the future assertions made within the scope of the same test. Finally, your custom ViewAssertion implementation should not attempt to downcast the view prior to checking that it's an instance of that type. Doing so could cause non-AssertionError exceptions and non-noMatching view exceptions being thrown, which are totally unexpected. If you find that the view is not an instance of the type you're trying to downcast to, it's recommended that you simply throw an AssertionError. As I mentioned, custom ViewAssertions can get pretty advanced. It's actually recommended by the Android documentation on a ViewAssertion that you consider using existing ViewAssertions offered by Espresso's ViewAssertion utility before you consider writing your own. Let's talk about some of those existing assertions. There are three different classes that contain assertions, which cover most common test scenarios. ViewAssertions, which contains a couple of common ViewAssertions like does not exist or matchers, LayoutAssertions, which contains common ViewAssertions for checking layout constraints, such as whether or not the view hierarchy contains ellipsized or truncated text, and PositionAssertions, which contains a variety of position-related ViewAssertion, such as the alignment of the view under test. While there are definitely fewer ViewAssertions than there are matchers or actions, I won't be able to demonstrate all of them. However, they are very easy to get the hang of, and once I show you how to use one, you'll be fine experimenting on your own.

Demo: Using Espresso Assertions
Here's my favorite demo, and probably the most important part of writing our UI tests, using assertions to verify our intended behavior. We're going to take a look at several Espresso assertions and how they can help us ensure well-designed layouts and functionality. We'll write tests to assert that views are positioned above or below each other, a view has the correct text, a view is properly displayed, a view doesn't ellipsize or truncate the text that it contains, and finally, we'll assert that two views don't overlap one another. This may seem like a lot, but assertions are fairly quick and easy, and in no time, you'll be able to use these ViewAssertions in your very own UI tests. Up until this point, we've only really been writing tests for our BeverageListActivity. Let's go ahead and write some tests for our BeverageDetailActivity. In case you've forgotten what it looks like, here it is. It's simply a beverage title, image, and description all stacked on top of each other. If you want to add your test file manually, you can, or Android Studio is smart enough to suggest the test class for you. If you place your cursor on your activity class declaration, you'll see this nifty light bulb appear. Let's click on that light bulb and select the Create Test option. Here is where we'll practice using assertions. In our BeverageListActivityTest, we had an intents test rule. For our BeverageDetailActivityTest, we'll use an activity test rule. Our BeverageDetailActivity expects to passed a beverage object in its intents extras upon launch, so let's add a mock beverage to use during these next tests. We'll start by creating our mock beverage, which we'll keep as a private static final field in our BeverageDetailActivityTest. Next, we'll go ahead and declare an ActivityTestRule of type BeverageDetailActivity since, of course, that's what we're testing. While we're creating this test rule, we want to override the getActivityIntent method so that we can intercept the intent and add our beverage as an extra before the intent is used by our activity. We'll get the target context using InstrumentationRegistry. getInstrumentation. getTargetContext, and go ahead and add our extra beverage. Okay, now that our ActivityTestRule is in place, let's write a test to assert that the title is positioned above the image view. For this test, we'll use an isAbove assertion. Let's go ahead and write @Test, public void testTitle_shouldBePositionedAboveBeverageImageView, onView withId R. id. text_title. We'll check it's above the view withId R. id. image_beverage. Let's run the test and make sure it passes before moving on. Now let's use a different assertion to make sure that the beverage description field is being populated with the correct text. For this test, we'll use the common matches assertion, @Test public void testDescription_shouldBeSetToCorrectBeverageDescriptionText, onView withId R. id. text_description. Check that it matches something with the text beverage. getDescription. Awesome, let's try another matches assertion for our next test, checking that the beverage ImageView is displayed. @Test public void testImage_shouldBeDisplayed, onView withId R. id. image_beverage. Let's check that it matches isDisplayed. Easy. Now we'll use the no ellipsize test assertion to ensure that the View hierarchy doesn't contain ellipsized or cut off text views. @Test public void testDescription_shouldNotContainEllipsizedText, onView withId R. id. text_description. check noEllipsizedText. Finally, we can use the noOverlaps assertion to make sure that our BeverageDetailActivity layout does not contain any text view or image view decedents who overlap one another. @Test, public void testBeverageDetailActivity_shouldNotHaveAnyOverlaps, onView withId R. id. activity_beverage. check noOverlaps. So that's it. There are more assertions at your disposal of course, so feel free to check out the Espresso documentation if you want to know more. Once we've run our tests and made sure they all pass, we can move on.

Verifying Intents
Verifying Intents
Intents are an important part of the Android ecosystem, so you might be glad to hear that Espresso has given us a means to verify the correctness of our application's intents. In Android, an intent describes some operation to be performed. Intents are a means for us to start an activity, broadcast an intent to any listening broadcast receivers, or start and communicate with a background service. However the intent is used, it's always important to make sure that your intent leads to the desired outcome. We won't go too in depth here, but I wanted to give you guys a few examples of how intents can be used. Intents are unique in that they allow us to perform late runtime binding between code and different applications, as well as our own. There are a variety of use cases for an intent. Here are a few examples. Suppose your application lets users look up phone numbers for nearby doctor's offices. When they tap on a phone number, you want your application to send an intent that will dial the listed phone number. The logistics of the app that receives this intent might not be under your control, but you can still test that the intent was in fact sent. Let's also say that your app allows users to take photos and associate them with specific doctors in the office. Your app will want to send an intent that launches the camera app for picture taking, or maybe opens the user's photos and allow them to select pictures to upload. Maybe as a bonus feature, you give the users an option to add a specific office to their contacts with the tap of a button. To do this, you might use an intent to communicate with the Android contact's provider to insert or update the office as one of the user's contacts. If any of these intents fail to be sent, or if the intent is not sent with the correct action or data, your users will miss out on a really cool feature.

IntentsTestRule
The Android testing support library provides us with a set of rules to be used with our UI tests, and so far, we've only really used ActivityTestRule and IntentsTestRule. Let's talk a little bit more about why we'd use one versus the other. First of all, you might be wondering what is a rule? Rules are not specific to Espresso, nor are they specific to Android. They're actually part of a JUnit framework, which is for writing unit tests in Java in general. According to the JUnit documentation, rules allow very flexible addition or redefinition of the behavior of each test method in a test class, or in simpler terms, rules give us a way to manipulate the conditions in which each individual test is run. To understand why something like an ActivityTestRule or an IntentsTestRule is nice to have, let's consider the following scenario. Each of our instrumented tests will need the activity to be launched before we carry out any actions on our UI or attempt to perform any assertions. Instead of having to write this code ourselves and perform the initial setup in the start of each of our tests, ActivityTestRule has us covered. It launches the activity under test before each method annotated with @Test, and before each method annotated with @Before. It also offers us a way to get the reference to the activity, or a way to intercept the intent, which would have launched our activity under test, as we saw in the previous module's demo. In addition to all this, now let's pretend we have to use the Espresso-Intents library to perform some intent verification. Espresso-Intents requires some set up and tear down before and after each test, and if we just switch to using an IntentsTestRule, it would cover this for us so we wouldn't have to worry about it ourselves. IntentsTestRule extends ActivityTestRule, so it actually provides all the functionality that ActivityTestRule would have provided for us, and it can be used in the same way as an ActivityTestRule. If you aren't using Espresso-Intents, however, you should simply stick with using ActivityTestRule since there's no need to perform any Espresso-Intents related setup or teardown.

Demo: Verifying Intents With Espresso
Our Coffee Companion app has a couple of cool new features that involve intents. This demo will show you how to verify that the intents are in fact being sent, and that they're being sent with the correct data attached. These intents are pretty important to delivering value to our customers, as these features simply wouldn't be possible without them. As such, let's go ahead and write tests to verify the following. An activity is started when a button was clicked, a special message is shared provided by our intent for use by messenger applications, and finally, we'll make sure that when the user taps on a button, Google Maps is launched to show us the location of a selected coffee shop. Let's fire up Android Studio and an emulator running Coffee Companion. For this demo, we'll actually be writing some tests for the coffee shop activity, which displays a list of coffee shops near the device's current location. You'll actually notice that I've renamed it to Coffee Shop list activity, so that's what we'll call it from here on out. If you're not seeing any results for your list of nearby coffee shops, make sure you have High accuracy location enabled. In API level 23, you can find this option by going into your device settings, selecting Location under the Personal section, tapping on the Mode item at the top, then selecting High accuracy option. Once you've done this, you should be able to see your coffee shop list activity populate with a list of nearby coffee shops provided by the Yelp API. Oh, and make sure you've added you own Yelp API consumer key and token information, which I've kept sort of shoved aside in a class called ApiConstants. In order to sign up for your own Yelp API credentials, head over to yelp. com/developers and follow the instructions there. You'll have to create an account first, but it is a free API and it offers a lot of cool data. Now that we've gotten those bases covered, let's actually head over to the BeverageListActivityTest. It's currently using IntentsTestRule because I've already written a test that checks to make sure our BeverageDetailActivity is launched whenever we tap on a beverage item. Let's go ahead and write a quick and easy test to make sure that our coffee shop list activity is launched when we tap on the map icon. We'll write a test called @Test public void testMapFabClick_shouldOpenCoffeeShopListActivity, onView withId R. id. map_fab. perform click, intended hasComponent CoffeeShopListActivity. class. getName. Now let's talk about our assertion a little bit. Intended asserts that the given matcher matches one and only one intent sent by the application under test. That means if our map_fab somehow fired off two intents to start the coffee shop activity, our assertion would fail. The hasComponent method will only match intents targeted to the class whose name we specify here as an argument. Now that we've gone over what's actually happening, let's run out test and watch what happens. It seems to be taking a while to run. If you look at the emulator, a dialog is blocking our way. This will cause our test to hang until it's dismissed. We can dismiss it manually and the test will finish, but that's definitely not a sustainable option. Your first instinct might be to say, well, we could just use Espresso to press the back button and dismiss it ourselves during the test. That might work, but it's also not optimal. What we will do is we'll simply stub out our intent. Start by adding a method annotated with @Before. We'll first instantiate a new intent, then an ActivityResult. We'll use intending and hasComponent, but this time we're going to add respondWith at the very end and pass in our desired result. What this means is that once an intent has been fired off to launch the CoffeeShopListActivity class, we can go ahead and assume that it's a success because it has satisfied the requirements we have of our intent. The coffee shop activity intent doesn't require any extras, but if it did, we could add it to this intent before passing it to activity result. Go ahead and re-run the test and make sure it passes before we move on. Let's move on to the CoffeeShopListActivity. The CoffeeShopListActivity will only display a list of nearby coffee shops if the user has granted the app location permissions. If you're using an emulator, you may also need to update the device's location coordinates, as there may not be a registered location until you do. Do this by clicking on the three dots, which will bring up the extended controls. On the Location tab, simply enter your desired latitude and longitude and click Send. Now that we see our list of coffee shops, notice this Share button in the upper right-hand corner of the screen. When we click on it, an intent will be fired off that opens a dialog that will prompt us to choose a messaging app in which to share our message. Let's write a test to verify that the intent is being sent when we click on the Share button, and that the intent is being sent with the correct message. If you haven't already, you'll want to add a CoffeeShopListActivityTest. For intent verification, we'll be using an IntentsTestRule, and our test rule will be a little more complicated than in the BeverageListActivityTest. We're going to want to override getActivity intent so that we can provide our coffee shop list activity with a fake model, which will have a collection of fake coffee shops to display. We're doing this in order to side step the network request that occurs when reaching the coffee shop activity. And while this isn't quite the best way to do it, you should know that your tests should never actually rely on any network requests. Testing fundamentals and more in-depth dos and don'ts are covered in other Pluralsight courses, and I'd highly recommend you look into that if you're serious about testing. Anyway, once we've provided our activity with fake data, we should be ready to write our test, @Test public void testShareButton_sendsCorrectShareIntent. Let's go ahead and build our message so that we can verify that the message is correct when we send our intent. OnView withId R. id. action_share. performclick. Alright, so our intent should have the type text/plain, have the action, actionSend, and it should have an extra with our desired message. Once we've made sure our test passes, let's take another look at the Coffee Companion app. There are other things we could test here, but our next intent to verify is actually located on the next screen. When we tap on a coffee shop, the app will now take us to a coffee shop detail activity. Here we have the option to send an intent to view this particular coffee shop in Google Maps. Let's write a test to verify that this intent is actually getting sent, and with the right data. We'll again define our own fake coffee shop, then add our intentsTestRule. We're going to have to override getActivityIntent one more time so we can provide our CoffeeShopDetail activity with a fake coffee shop. Once we've gotten that taken care of, let's write our test. @Test public void testMapButton_SendsMapViewLocationIntent. We can flesh out our desiredUri, onView withId R. id. button_map. perform click. Awesome. So our intention is that our intent has the action ACTION_VIEW, and its data matches our desired URI. If you want, you can pull up your emulator and watch the test as it runs. Sometimes it can be helpful to see what's going on first hand. So that's it. Once we're sure our tests all pass and our intents are firing off correctly, we can move on.

Testing WebViews
Testing WebViews
I haven't come across many WebViews in my own career as an Android developer, but I do know that they're relatively popular and that they have a fascinating history. If you're already familiar with WebViews, you can probably skip to the next clip as I'll be giving a very basic overview next. WebViews are pretty self-explanatory. They display web pages, plain and simple. Some newer Android phones use Chrome as their default internet browser, but this is not always the case. Because the user's browser may vary, the user experience for things like viewing a simple web page to authenticate with another service may differ drastically. You can use a WebView if you want to allow you users to open and browse a website without the user ever leaving your app, which might make for a more seamless experience. They're actually quite commonly used for authentication, such as when asking users to log into their Google or Facebook account before proceeding. This is all very nice, but WebViews weren't always quite the easiest or the safest option for security reasons. To understand why, let's talk about the history of WebViews. In the past, WebViews used code based on Apple's WebKit, which is used by the Safari browser. From Android 4. 4 onwards, WebView is based on Chromium, which is Google's open-source base of Chrome. Prior to Lollipop, however, WebViews were tightly intermingled with the operating system and updates to the WebView component had to pushed down by the device manufacturer. This meant that users who didn't get timely firmware updates were potentially being left open to a variety of nasty exploits when browsing the internet from a WebView. Nowadays, however, WebViews are now completely separate from the Android OS, which makes it updatable via Google Play just like any other app. When you use a WebView, you don't get any browser-like widgets out of the box, and JavaScript is disabled by default. In addition, web page errors are ignored. This makes it a little more challenging when you actually want a full-blown web browser experience in your application. The good news is, there are options if you want to customize the user's experience using a WebView, such as showing a progress bar in the activity title bar to mimic the browser app. Some other interesting things you can do with a WebView are set its minimum font size, or set whether or not to display an on-screen zoom control when using built-in zoom mechanisms. Given all of the ways you can use a WebView to provide the user with the most optimal experience, you'll be glad to know that Espresso does offer us a way to work with and test them.

Espresso Web
If you use a WebView in your application, you'll probably want to know about the different testing utilities that Espresso Web has to provide. Similar to how we used onView to target a particular view, we can use onWebView to target a WebView. We can find a WebView by a child element if needed. Our interactions with the WebView under test will be composed of something called View Atoms, which can be seen as a ViewAction. An atom is a self-contained unit which performs an action in your UI. They differ from ViewActions in that they have to work with JavaScript and they're pretty verbose. Atoms must be properly orchestrated, which is mostly handled for us by Espresso-Web wrappers. Espresso-Web also gives us some web-specific assertions, such as whether or not the page rendered by the WebView contains specific elements. If you plan on performing more assertions within the given test, or interacting with the WebView any further, you'll probably want to call reset. This is necessary because some of your previous interactions might have caused a navigation change or some change that invalidates the element reference and window reference pointers, meaning that you might not be able to find or interact with your WebView in the same way moving forward, and that can be frustrating. In your Android app, you can enable JavaScript by calling webView. getSettings. setJavascriptEnabled. Regardless of whether or not JavaScript is enabled or disabled for your actual WebView, Espresso-Web needs JavaScript enabled in order to control the WebView. If you remember, our activityTestRule has a few different methods we can override to give us a handle of the activity under test. With that in mind, to ensure that our WebView under test has JavaScript enabled, we can override afterActivityLaunched in our ActivityTestRule and call onWebView. forceJavascriptEnabled.

Demo: Testing WebViews with Espresso Web
In this demo, we'll showcase a couple of ways we can test an Android WebView using Espresso-Web. Since Coffee Companion's WebView isn't all that complicated, there's really not much we can test. If the IDs or classes on the web page change and we're relying on them in our tests, the tests will fail, which isn't really a long-term solution. If you're feeling up to it, however, we can still explore some ways Espresso Web allows us to do the following, target a WebView under test, interact with certain WebView elements, like entering text into an input field or clicking on a link, and finally, verify the contents of a WebView to make sure that the user is seeing what we expect them to see after displaying the page. As always, let's take a look at the app we're testing. When you click on a coffee shop, we should see a details screen pop up that displays the coffee shop's title and primary phone number. There are also two buttons. We've already seen the Maps button, which will launch Google Maps and show users where the coffee shop is located. This time, let's take a look at the Website button. Clicking on it should open up the coffee shop's Yelp page provided for us by the Yelp API. Here is where we have a sort of gray area in testing. Espresso-Web offers us a variety of tools to help identify web page elements so that we may interact with them. If we, or our company, owned and curated this web page ourselves, it might seem a little less daunting for us to hardcode certain values into our test, such as the values of element IDs or classes. As it stands, we certainly aren't in charge of the URL provided to us by Yelp. If we were to write a test that, say, scrolled down and clicked on a button in our WebView, this test would break if the button was one day removed or if other key elements on the page were changed. So you might wonder then, why does Espresso-Web give us the option to interact with WebViews in this way? Well, WebViews can actually get a lot more complex than you might initially think. Let's pretend our WebView takes the user to a special web form that we ourselves own and curate. If we wanted to, we could actually provide our WebView with a custom web interface, which could actually expose certain methods within our Android app to the web page itself. Isn't that cool? Cool maybe, but a little scary for security reasons. Enabling JavaScript on a WebView can also open your users up to cross-site scripting. There are ways you can limit your user's WebView navigation to certain domains, but while all of this is super interesting, it's well beyond the scope of this course. Anyway, given that scenario, it then makes more sense if you wanted to interact with your WebView using Espresso. For example, if your app displays a dialog or exits the activity after a user has signed into your website, you'll want to mimic the user signing into the website through your WebView, then verify that your app has displayed the dialog when it should. With this in mind, Espresso Web makes a lot more sense, and it's kind of cool to see just how we can interact with WebViews. Heading over to our CoffeeShopDetailActivityTest, let's take a look at how we might write tests for our WebView. First, take a look at our IntentsTestRule. In previous slides, I mentioned that we have to force JavaScript to be enabled on our WebView in order to interact with it in our tests. To do this, override afterActivityLaunched, and call onWebView withId R. id. webview. forceJavascriptEnabled. The reason I'm passing the matcher with ID to onWebView is because onWebView, when it does not have any parameters being passed to it, it defaults to trying to find a WebView by whether or not JavaScript is enabled. If your app's WebView does not already have JavaScript enabled, Espresso won't be able to find your WebView, resulting in a noMatchingViewException. Now that we've gotten that taken care of, let's begin writing a test. Again, note that we're really only exploring the tools that Espresso-Web provides, and we're not actually going to be testing anything about our WebView. We could test that our WebView was displayed after clicking the button, but that doesn't require any Espresso-Web-specific tools, and you already know how to accomplish that on your own. Let's go ahead and type out @Test public void testClickWebsiteButton_OpensWebViewCoffeeShopUrl, onView withId R. id. button_website. perform click. That should open up our WebView. In order to target your WebView, you should be able to use onWebView now that your WebView has had its JavaScript enabled. You can also pass in a matcher as we did before, if you want to be more granular, such as if you have multiple WebViews in your activity. Anyways, let's pretend we're going to check to make sure that our WebView displays the proper text. If we know the IDs of the elements in the page, and if we were reasonably sure that those IDs wouldn't change in the near future, we could find a header by its ID, and then check to make sure that it displays the right text, like so. This test could theoretically let us know that the correct coffee shop is displayed to the user. If we wanted to instead check whether or not a button press correctly utilized our app's custom web interface to display an Android toast, we could find the button on the web page and perform a webClick. A webClick differs from the clicks we've been using before, as it actually simulates the JavaScript click event on our targeted element. Later in the test, we could check to make sure that our toast has been displayed correctly. If you want to clear the value of whatever element you've selected, such as a text input field, you can pass clearElement to the perform method. Remember that acting upon an element using Atoms is basically the same thing as when we were manipulating our Android views using actions. If we happen to perform an action on our WebView that alters the state of what's being shown in our WebView, we can always use reset. An example of when this might be useful is when you have multiple assertions and are relying on a clean slate every time. That's basically all we can cover for WebViews for now. If you're thinking of writing tests for your own WebView, consider how the page displayed in your WebView might change over time, and how much you do or don't want to rely on referencing the elements within.

Testing Asynchronous Operations with Espresso Idling Resources
Testing Asynchronous Operations with Espresso Idling Resources
Most Android applications perform some kind of asynchronous background work. Because of this, we may sometimes have to wait for specific background tasks to be completed before the view is ready to be interacted with. This is where Espresso Idling Resources comes in. By default, Espresso waits for any UI-related events in the current message queue to be handled, and for default async tasks to be completed before it moves on to the next test operation. However, when our app delegates work to a background thread, we need to be able to let Espresso know when we should wait or proceed during the UI test. Some examples of the kind of work we'd like to perform on a background thread are downloading files, such as music or videos, sending or receiving data to or from a web service, such as when you need to sync changes the user made within your app with the web, or performing any kind of heavy computation that you might want to delegate to a background thread, although this scenario should be somewhat rare as you'll typically have a web service to help with any heavy lifting that you wouldn't want to perform on a mobile device. To illustrate why Espresso idling resources will come in handy for these operations, let's consider the following scenario. We have an activity that, at the click of a button, starts a service which requests content from an API, then displays that content in a RecyclerView once a response is received. The timeline of our Espresso test might look like this. An Espresso action is performed to click on the button, which spawns a background thread to handle the network request. This network request will take a few seconds. However, Espresso notices the UI event message queue is empty and can proceed with the next test operation. So, before our background work is complete, Espresso attempts the next action, which is to click on the designated RecyclerView item. Our RecyclerView is still empty at this point, so our test will fail with a NoMatchingViewFoundException. If our background operation is sometimes extremely fast, it might be able to beat Espresso before it performs the next test operation, but this will only lead to flaky tests and very frustrated debugging sessions. In case you're thinking, shouldn't we just mock the responses or results of our background tasks? You're correct. We should definitely do that, and it's made easier for those of you who are using dependency injection frameworks, such as Dagger 2. However, whether we mock those operations or not, we are still spawning a background thread, and even if our background thread completes its work super fast, Espresso might proceed to the next item in the main message queue just a little faster, which can still result in some flaky tests. So if you ever perform work on a background thread and manipulate the UI in a callback, and if you ever want to test your UI's response to the resolution of this background work, you might find an Espresso idling resource very useful.

Espresso Idling Resources
Espresso's ability to synchronize various test operations is part of what makes it such an incredibly powerful tool. I'm excited to show you how you can implement an idling resource, which will allow Espresso to halt mid test while your app's background operation completes. If you're wondering what an idling resource is, it's pretty much as its name suggests. An idling resource represents some kind of resource which can cause asynchronous background work to happen during the execution of our test. If we register our idling resource with Espresso, we'll be able to communicate when it's appropriate to halt or proceed a given test. In more technical terms, Espresso's idling resource is actually an interface that we can implement ourselves, or we can actually use an already existing implementation. Basically, we will have to register an idling resource with Espresso in the test setup, then make sure our idling resource is implemented in such a way that it properly notifies Espresso of changes in state, such as when it becomes idle or if it's still busy. To do this, we implement isIdleNow, which should return true if the resource is currently idle. A resource callback is registered by an idling resource to notify Espresso of a transition to its idle state. When the resource transitions from busy to idle, onTransitionToIdle is called. There are two very common approaches to implementing an idling resource. The first is to use a counting idling resource to increment a counter when a job starts, then decrement the same counter when the job finishes. Once the counter hits 0, Espresso will know that the background task is now idle and can proceed with performing test operations. This is a very simple approach and doesn't require a lot of heavy lifting on our part, which is awesome. The second approach is to query the state of the background task and update our idling resource accordingly. Once the background task reports that it's complete, the idling resource can then notify Espresso and allow us to resume our test. This approach requires that you implement the idling resource interface yourself, and you'll also want to make sure that the state of your background task is easy to get a hold of, so you can update your idling resource when necessary. One thing that both of these approaches actually have in common is that they can make it really tempting to mix test code with your real-world application code. In the upcoming demo for the sake of simplicity, and since we aren't using a dependency injection framework like Dagger 2, we'll actually be mixing our test code and our app code. If we were to separate our application's concerns without the use of a dependency injection, our idling resources demo would be needlessly long, and I was trying to keep it as vanilla Android as possible. However, one thing you should always keep in mind is that in practice, you should never place test logic within your application logic, and you should definitely look into using dependency injection. Mixing test code in with your app code actually violates the principle of single responsibility. For those of you who aren't familiar with this, the single responsibility principle states that every module or class should have responsibility over a single part of the functionality provided by the software. Following this principle can reduce the possibility of unintended side effects in other parts of your application, and most importantly, keeping your code as modular and precise as possible can drastically improve its testability. If we were to, say, have our live non-mock, non-fake background task communicate with our idling resource to let it know when it's busy or idle, we'd be introducing test-specific responsibilities to our application responsibilities, which can result in messy, side-effect laden code.

Demo: Espresso Idling Resources
Utilizing an idling resource is one of the more advanced parts of Espresso, but it'll be much easier to illustrate how they're used if we can dive into some code. When we think about background work and updating the UI once it's complete, there's one area of the Coffee Companion app that sticks out, Our CoffeeShopListActivity grabs a list of nearby coffee shops from the Yelp API, then populates a RecyclerView with the resulting data. So in this demo, let's see how we can utilize an idling resource to notify Espresso when our network request has successfully completed, and our lists of coffee shops is ready to be interacted with. Let's take a look at the coffee shop list activity. When the user first reaches this activity, they're asked for the location permission so that we can find them a list of nearby coffee shops. If they hit Allow, we send the request to the Yelp API to find them some nearby coffee shops, then we display those coffee shops in the coffee shop's RecyclerView. We don't have to worry about asking them for their permission again for future searches, although they're free to revoke the permission at any time in their device settings. If the user hits Deny, however, we can't perform the network request, and we can't display any nearby coffee shops. In a previous demo, we side-stepped the entire network request and permission request dialog by overriding getActivityIntent in our CoffeeShopListActivityTest rule. While this is one way we can avoid the permission dialog, the process of requesting a permission then acting upon its result is crucial to the user experience. That is why we're going to go ahead and comment this chunk of code out. While it's great for demonstrating how we can intercept activity intents and provide fake data, it's sidestepping important logic in our app that still needs to be tested. However, there's something special about this dialog. It belongs to the Android OS, not our app. This means Espresso can't interact with it the way we want it to. In a situation like this, you'd usually use a tool called UI Automator to handle the job, which is capable of interacting with Android system components just like an actual user. But there's another problem. The permission dialog pops up before Espresso knows that the activity has been launched. This means that afterActivityLaunched will never be called, our method annotated with @Before will never be called, we'll never even get to see our test run either. So what do we do about the situation? Well the easiest thing to do, I guess, would be to side step the permission's dialog entirely the way we have been by providing our activity with mock data and ignoring the fact that our permission result handler logic is more or less untested. You'll be happy to know, however, that Espresso 3. 0 has just announced a Grant Permission Rule, which will actually allow us to skip permission dialogs altogether and simulate the acts of a user granting permission at runtime. Unfortunately for us, Espresso 3. 0 was announced just before the recording of this demo. Since the rest of our demos are using Espresso 2. 2. 2, we'll go ahead and stick with that and bypass the permission dialog for now. To do that, we can grant the location permission using adb, and make sure we establish a location for the emulator to use. Note that going forward, you'll definitely want to just use Espresso 3. 0's new Grant Permission Rule, especially since it allows us to not only proceed with the execution of our test code, but we can actually use it to very easily test our logic corresponding with whether or not the user grants permission. Now that we should no longer have to worry about that pesky permission dialog, let's implement an idling resource. As mentioned earlier in this module, we'll actually be muddying up our app code with some very test-specific logic. Normally we'd be able to separate these concerns with the help of a dependency injection framework, but again, since this way's shorter, and primarily since our goal here is just to see how idling resources work, we're going to go ahead and turn a blind eye to the fact that we're doing this the dirty way. Let's add a coffee shop's idling resource and implement IdlingResource. We'll go ahead and keep a reference to our resource callback, and a Boolean to keep track of whether this resource is idle or not. Now we implement our idling resource methods. GetName isn't really used beyond logging, so the most important methods here are isIdleNow and registerIdleTransitionCallback. IsIdleNow can just return isIdle, and we'll just set our resource callback and registerIdleTransitionCallback. Thinking ahead, our presenter will want a way to let the idling resource know that it's now idle. So let's add a public method for that. Once the coffee shop search is complete, the idling resource is then idle and we can notify its resource callback. To let our resource callback know that we've just become idle, we'll call its onTransitionToIdle method, and that's it. That was pretty easy to implement wasn't it? Now let's go ahead and hop over to our CoffeeShopList activity presenter. We'll give him a CoffeeShopsIdlingResource so that he can easily notify our resource when the search is complete. In the callback's onResponse and onFailure, we'll notify our idling resource. If we want, we can lazily instantiate our idling resource. Add a get getCoffeeShopsIdlingResource method, which will instantiate the idling resource if it's null. That way, if we only call getCoffeeShopsIdlingResource from our tests, we're at least sure that the idling resource won't be newed up in actual production code. We should also make sure that we let the coffee shop idling resource know if we've already performed the search. Sometimes we have a very fast internet connection, and our search might execute and return before we've even instantiated our idling resource. Once we're finished implementing notifyIdlingResource, we'll also want to expose the idling resource in our activity as well. This method will simply defer to the presenters getCoffeeShopsIdlingResource, and it's a way for our test to easily grab the idling resource from an activity for easy registration. Now that all that is settled, let's get back to our CoffeeShopListActivityTest. Let's add a method annotated with @Before, and get our coffeeShopsIdlingResource from the activity provided by our test rule. Next, all we have to do is register that idling resource, and Espresso will know to keep watch over whether or not the resource is idle before it proceeds with our test execution. However, let's not forget to add a method annotated with that after and unregister our idling resource if necessary. Now we can move on to the actual test. Writing the actual test will be dead simple. We're now safe to write a test that taps on a specific coffee shop item without having to worry about permissions dialogs or background work that we may have to wait on. We can write the test simply assuming that Espresso will know when it can perform the click event on our RecyclerView item. Running the test should confirm this for us. Well, that's all for idling resources, and it's also the end of the course. I hope that you'll take your new knowledge of Espresso and write plenty of clean, concise tests for your real-world applications. It's been a pleasure learning with you. Thanks for watching.

Course author
Author: Nora Valletta	
Nora Valletta
With a love of computers that stemmed from playing video games as a little girl, Nora began studying at Southern Utah University in the year 2010. Her career in Android development began in 2013...

Course info
Level
Beginner
Rating
3.9 stars with 17 raters(17)
My rating
null stars

Duration
1h 18m
Released
15 Sep 2017
Share course
