Managing Android App Data with SQLite
by Jim Wilson

Persistent data storage is at the heart of most modern applications. In this course, you will learn how to use SQLite, the most widely used persistent data storage solution for Android.

SQLite is the persistent storage solution of choice for the overwhelming majority of Android applications. In this course, Managing Android App Data with SQLite, you'll learn how to create Android applications that effectively leverage the persistent storage capabilities of SQLite. First, you'll explore how to create and access a SQLite database in a way that conforms to the standards and best practices of Android app development. Next, you'll dig into the rich query capabilities of SQLite including row selection criteria and row ordering. Then, you'll discover how to use adapters to connect SQLite data to views like RecyclerView, Spinner, and ListView. Additionally, you'll walk through how to perform lifecycle aware queries using LoaderManager and CursorLoader. Finally, you'll learn how to update, delete, and insert data within a SQLite database, including how to maintain a responsive user experience. By the end of this course, you'll have the skills and knowledge to create Android applications of your own that persistently manage data within a SQLite database.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Intermediate
Rating
4.8 stars with 34 raters(34)
My rating
null stars

Duration
4h 28m
Released
11 Aug 2017
Share course

Understanding SQLite and SQLite Database Creation
Introduction
Welcome to the Pluralsight course, Managing Android App Data with SQLite. This is our first module, Understanding SQLite and SQLite Database Creation. My name is Jim Wilson. The work we'll do in this course will result in another big leap forward for our app. Now currently all our app's data is stored in memory, which means that any changes made to that data are lost when the app is restarted. In this course, we're going to get rid of that issue by transitioning our app to maintain data persistently through the use of the SQLite database API. So we'll start out with just a quick overview of SQLite. We'll then design out the database we need for our application. We'll then see how to express that database design using a convention known as a database contract class. We'll then look into the capabilities of SQLite for describing the capabilities of table columns. We'll look into the considerations for creating the tables within our database so they work effectively with the Android framework. We'll see how to create and access our database. Then we'll finish up by verifying that our database is created just as we expect it to be.

SQLite Key Concepts
SQLite is a relational database. And as relational database, it provides our application with structured data storage. What this means is our application data is safely maintained even when execution replication is stopped and restarted. Now SQLite as implemented is very lightweight. Part of the reason for that is it runs in process. In other words, the SQLite library actually runs as part of our application unlike many other relational databases that actually require a server. So since SQLite runs in process, there's no server to install or configure. Also, SQLite is optimized for common usage scenarios. SQLite isn't trying to be some super-duper, ultra-powerful relational database. Its implementation focuses on common usage scenarios and doing them well. SQLite is portable, and it's portable in a couple of ways. One way it's portable is the databases themselves are portable. A SQLite database is simply a file. You can move that file from device to device or computer to computer, and if you have the file, you have the whole database. In addition, SQLite is portable because it's supported by a number of different operating systems. What this means is you can have something like a Linux server or Windows Server create the SQLite database. Because the database is just a file, an Android device can download that file. Then that location can interact with that database. Similarly, an Android application can create the database, upload it to a Windows Server or a Linux server, and then that server can then open up that database and interact with the data. So as a relational database that's both lightweight and portable, SQLite is a great storage solution for mobile device applications. As with most relational databases, SQLite supports structured query language, or as it's most commonly known SQL, or S-Q-L. Now S-Q-L is a domain-specific language. It's a language designed for interacting with data. And it's very English-like in nature. So SQL commands are English looking commands that operate on our databases and our data. And SQL's a very powerful language, but it does have some challenges. One thing is that parsing SQL commands can be resource intensive because these English-like commands have to be translated into the individual operations and the components of those operations. In addition, there is the potential for SQL-based attacks. In scenarios where an application takes in user data and incorporates that into the SQL statement, there is the potential for hostile actors to introduce data that can cause the SQL to perform malicious actions. Now there are certainly ways to guard against this, but the potential does exist. To help overcome some of the challenges with SQL, SQLite also supports operation-specific methods. And in general, these methods are preferable to the SQL commands. Being operation specific, they eliminate the need for some of the complex command parsing. In addition, they help protect against some of the SQL-based attacks. But in practice, your application's going to use a combination of SQL commands and methods. Most of the data tests that we need to do can be done with methods, things like putting in data, deleting data, getting data, modifying data. Tasks that are involved in managing the database itself like creating tables you're more likely to do with SQL itself. So the question of course is, Well, how do you know which to use? And what it comes down to is that if there is an operation-specific method available, use that. Only use SQL when we don't have a method that does the thing we want to do. And we'll be seeing examples of both of these cases throughout this course. So now in our next clip, let's look at a few of the basic relational concepts and start designing our database for our application.

Designing Your App Tables
So let's first look at a few key concepts related to relational structure. The first one we want to look at is table. The table is the place we normally store our data within a database. So a table is really considered a set of related entities. Now tables are composed of columns and rows. And in general a database will have at least one table, but it might have more. So as we mentioned, a table can have columns. And columns are considered attributes of an entity. We sometimes refer to them as fields. And generally a table will have at least one column in it, but it often has more as well. Now tables are also composed of rows. As we mentioned, a table is a set of related entities. Well then a row is an instance of one of those entities. We sometimes refer to rows as records. Now a table can have 0 or more rows. Now generally there will be multiple rows in a table, but it's not uncommon for a particular table to start out with 0 rows initially until we start adding data to it. So to get a better set of these concepts, let's start designing our application database. So the first thing we'll do is we'll design a table, and that will be the table for our courses. And we'll call the table course_info. We'll give that table a column to hold the course title, and we'll call it course_title. And that might hold something like Android Programming with Intents. But let's go ahead and give this table another column, and we'll call that column course_id. It might hold a value something like android_intents. Now in this case, a value like android_intents is not something we want to necessarily show the user. It's just a value we use to identify a course within this table. So now currently we have one table--course_info. It has two columns--course_id and course_title. And that table has one row in it. Let's go ahead and add another row. So this row will have a course_id of android_async. And the course's title is Android Async Programming and Services. Let's go ahead and add another row for the Java Language course. And we'll add another row for the Java Core Platform course. So now we have one table. It still only has two columns--course_id and course_title. But it currently has four rows in it. So let's go ahead and add another table to our database, and we'll use that to store our note information. So we'll call it note_info. Let's give it a column, note_title, that holds the title of our note. Another column, note_text, that holds the text for our note or also the notes associated with a course. But rather than actually store the course information directly within a note, what we'll do is in our note, we'll store the course_id that goes with this note. What that does is that creates a relationship between our note_info table and our course_info table. And that's a very powerful concept in relational databases that having the information in one table be related to information in another table. So now currently our note_info table has three columns--note_title, note_text, and course_id. It currently has one row in it. Let's go ahead and add another row to it titled Anonymous classes. We can see the note text. And this note is related to our Java Language course. So, again, we're just storing the course_id for the course that this note is associated with. We'll go ahead and put one more row in here for the title Delegating intents. We can see the note_text. And this course is also android_intents. So you notice now we have this one note in note_info that's related to the row for the course Android Programming with Intents. Remember we also have another note that's related to that same course. And this is another key concept in relational databases that a given row in one table, in this case the course_info table, can be related to multiple rows in another table, which is our note_info table. So now we have two tables in our database--note_info and course_info. Our note_info table has three columns--note_title, note_text, and course_id. And it also has three rows in it. Our course_info table has the two columns--course_id and course_title. And it has the four rows within it. That's our basic database structure. In our next clip, let's start seeing how we can map this structure into our application using what's known as a database contract class.

Database Contract Class
As we're creating our application, it's helpful to have all the information about the database in a central place. And that's the role of the database contract class, to hold information about our database. In general what we're looking at is the organization and structure of the database, what we commonly refer to as the database schema. The database contract class is mostly composed of constants describing the database. Now this is normally a non-creatable class because we don't actually ask it to do anything except just hold information about our database. Our database contract class would generally have a number of nested classes. It will have a nested class for each table within a database. And as you might expect, this class is responsible to describe the table. So it's going to have a constant for the table name. It will have constants for each of the column names. And it may contain key SQL statements. And one of the SQL statements we'll commonly find in this class is the SQL to handle table creation because there is no explicit method for table creation, so we have to use SQL to do it. So we'll use this SQL CREATE TABLE statement. And what we need to do in this statement is, of course, give the table a name but also describe the columns within the table. So to see what it's like to work with the contract class, in our next clip, let's add a database contract class to our application.

Implementing the Contract Class
Here we are in Android Studio, and we'll continue our work with the same project we've been working on throughout the course series. Now as we mentioned up to this point, our application has stored all its information in-memory, and throughout this course, we're going to transition to using SQLite to store that information. To get us started, the first thing we'll do is add a database contract class to our project. So we'll get rid of the package name, right-click, choose New, and then Java Class. We'll name the class NoteKeeperDatabaseContract. As a contract class, there's no reason for anyone to inherit from it, so we'll mark it as Final and say OK. And also since it's a contract class, there's no reason for anyone to create an instance of it either. So let's go ahead and give it a private constructor. Now within this class, we want to go ahead and have nested classes for each of the tables. So for our first table, course_info, let's go ahead and create the class for that. Now the convention is when creating these classes to describe a table, we give it a name appropriate for the table followed by the word Entry. Then within this class, we're going to go ahead and provide the constants we need for the table. So what we'll do is we'll go ahead and give it a constant for the table name. We also want to give it constants for the columns. So we'll create a constant for the column course_id, and we'll call the constant COLUMN_COURSE_ID. Then we'll do the same thing for our course_title column. So now with constants for the table name and columns, I want to go ahead and provide a constant for the SQL to create the table. So now before we do that, let's just go ahead and show the full command here in a comment so we can see it. So we'll start with a SQL command CREATE TABLE. Then we give it the table name. And then we give it the list of columns comma separated within parentheses. So that's a command that will create our table named course_info that has two columns--course_id and course_title. Now you'll notice that the words CREATE and TABLE are in all caps. That's not required. But it is a convention that's commonly followed, to put SQL keywords in all caps just so they stand out. So what we want to do now is have our constant create that command using the other constants in our class. So what we'll do is we'll start out by declaring a constant SQL_CREATE_TABLE. So well start out with the literal text CREATE TABLE. We'll follow that with our TABLE_NAME constant, and then the literal opening parenthesis. Then we'll put our course_id column followed by a comma, then our course_title column followed by the parenthesis. And so with that, now we have our class in place with the constants for our course_info table with the table name, the columns, and the SQL CREATE TABLE statement. So let's go ahead now and do the same thing for our note_info table. So let me scroll down here a little bit. So we'll declare our class NoteInfoEntry. We'll give it the constant for our TABLE_NAME. Let's go ahead and provide the constants for our three columns. And now let's go ahead and add the constant for the SQL statement to create our table. So with that done, we now have the classes in place for our course_info table and our note_info table. Now one thing I'll point out if you've worked with other relational databases, as you look at this CREATE TABLE statement, you might be wondering why there's no type information next to the columns. Now in SQLite, columns do not have to have an explicit type. That doesn't mean that associating a type with a column isn't helpful. So in our next clip, we'll take a look at the issue of columns and typing.

Describing Table Columns
Let's take a closer look at this idea of describing the columns of a table. Now we know a column can have a name. But it can also have a storage class. A column can also have constraints. Now let's look first at storage class. Now a storage class is optional. But a storage class associates typing with a column. But SQLite does not have rigid typing. In fact, any column no matter what the storage class is can store any value. But what storage class does do is it influences storage affinity. In other words, the preferred form to use when storing data in that column. Now when we declare a column, we can choose from five available storage classes. And to get a better sense of what it's like to work with these storage classes, let's see how each of them stores values of particular forms. So the first storage class we'll look at is BLOB. Now BLOB storage class stores data however it comes in. If you have a column, and you don't give it an explicit storage class, blob is the storage class that's associated with it. But you can also give a column the explicit storage class of BLOB. But now as I mentioned, columns with the BLOB storage class store the data however it comes in. So if I pass in a text value of "123, " that text value of "123" is stored in that column. If I pass in an integer value of 123, it's stored as the integer 123. If I pass in a real value of 123. 0, it stores that real value 123. 0. But if I give a column a storage class of TEXT, it will prefer to store its data in a text form. So as a result, if I pass in the text "123, " it of course will be that text "123. " But also if I pass in the integer 123, it'll also store it as text "123. " Then if I pass in that real number 123. 0, it'll store it as the text "123. 0. " But now if I have a storage class of INTEGER, it will prefer to store things as an integer, so the string "123" is stored as the integer 123. The integer 123 of course is stored as the integer 123. And 123. 0 is stored as 123. Now the REAL storage class will prefer to store things as real numbers, so the text "123" is stored as a real number 123. 0. The integer 123 is stored as a real number 123. 0. And, of course, our 123. 0 is also stored as 123. 0. Now our last storage class here is NUMERIC. The text "123" is stored as an integer 123. The integer 123 is also stored as the integer 123. And our 123. 0 is, again, stored as the integer 123 because it could safely convert it from a real number 123. 0 to 123 without losing any information from the original value. But notice, though, if I passed in 123. 1, it would numerically store it as 123. 1 because it couldn't safely be converted to an integer value. But to make clear, no matter what storage affinity we give a column, that column can still store a value of any type. So if I pass in a text value "abc" to columns with each of these storage classes, of course, the BLOB will keep the text "abc. " And the TEXT column would keep the text "abc. " But so will the INTEGER, REAL, and NUMERIC columns. So it's important to understand that we choose our storage classes based on the kind of data we expect to be putting into those columns. But the storage classes do not prevent data of any given type from being stored in that column. Now we've just taken a general look at this idea of storage classes. If you want to dig into this topic more deeply, just check out the URL I currently have onscreen. Now columns can also have constraints. Constraints restrict allowable content for a column. You associate constraints with a column as you need them, and when you associate a constraint with a column, the database will take care of automatically enforcing that constraint whenever values are put into that column. Now one of the most common constraints we use is NOT NULL. And NOT NULL makes sure that a column has an actual value. In other words, that column can't be left null. If a column is marked as NOT NULL, and you try to put a row into a table and you don't give that column a value, the database will raise an error. Another constraint we commonly use is UNIQUE. And the UNIQUE constraint makes sure that no two rows have the same value for the specified column. So any time you insert a new row into a table, or if you try to change the value of a column, the database will make sure that no other row in that table has the same value for that column. If you try to insert a new row that duplicates that column value or change an existing row that duplicates that column value, again, the database will raise an error. So now to get a better sense of what it's like working with storage classes and constraints, in our next clip, we'll go back into our CREATE TABLE statements and associate storage classes and constraints with our table columns.

Adding Column Descriptions to the Contract Class
Here we are back in the Android Studio. We're looking at our database contract class. What we want to do now is add the appropriate storage classes and constraints to the columns in each of our tables. So let's start out with our course_info table. So we've got two columns there, one for the course ID and one for the title. Remember, the course ID is a text value that identifies the course. And, of course, the title is text. So for this table, both columns will have a storage class of TEXT. So now what about constraints? We want to make sure that every course has an ID, and we want every course to have a title. So we'll give both columns a NOT NULL constraint. And now the COURSE_ID, we want to make sure that every course has a unique ID. So let's go ahead and give that COURSE_ID column a unique constraint. So that takes care of our course_info table. Let's look at our note_info table. So the title should have a TEXT storage class. The text should have a TEXT storage class. And since that COURSE_ID refers to the course ID in our course_info Table, that should also be a TEXT. So now what about our constraints? Well we wanted every note to have a title, so we'll give that a NOT NULL constraint. And, of course, we want every note to be associated with a course, so we'll give that a NOT NULL constraint. So that takes care of the title and the course_id columns. Notice that I didn't put a NOT NULL on the text column. It may be completely reasonable for someone to create a note that doesn't have any body text. They just want to give it a title and associate it with a course, maybe they're creating it for later, that sort of thing. Also, I didn't make any of these columns unique. You could certainly have more than one note refer to the same course, and if someone wants to have multiple notes with the same title, particularly if they refer to different courses, that's certainly okay. And that illustrates a key point. When you're creating these tables and you're applying constraints, don't overdo it. Just apply constraints to provide clear value. So in our next clip, let's look at the issue of the table having a primary key.

Primary Key and Framework Friendly Tables
Now let's look at one more kind of constraint, and that's the primary key constraint. Now the purpose of the primary key is to provide unambiguous row identity. In other words, uniquely identify each individual row within a table. Now a table can have no more than one primary key. Now tactically when you're creating a table, you can make any column part of a primary key. But there are some special considerations when working with SQLite and Android. First, let's look at SQLite. Internally, SQLite uses a data structure to manage access to the rows in a table. And each of those rows is identified with a unique integer. And SQLite takes care of assigning that an integer value for each row. And the purpose of that integer value is to allow SQLite to quickly and efficiently access each row in the table. Well created appropriately, the Android framework can leverage that efficiency. What we want to do is have each of our tables have a column whose storage class is INTEGER and has the constraint PRIMARY KEY. By creating a column that's an INTEGER PRIMARY KEY, that column is automatically associated with that integer row tag that SQLite uses internally to manage its storage. Then if we name that column with a constant _ID that's part of the BaseColumn interface, the Android framework can then leverage that efficiency when interacting with your table. So what we'll want to do is add that _id column to each of our tables. So for our note_info table, we'll add the _id column. We'll mark it as an INTEGER PRIMARY KEY, which will call SQLite to associate that column with those integer values it uses to manage its internal storage. Do the same thing for course_info. Create the _id column, and make it an INTEGER PRIMARY KEY. So in the next clip, let's make the appropriate changes to our table created in SQL to add this column.

Making Your Database Framework Friendly
Here we are back in the Android Studio, and we want to go ahead and add the appropriate primary key to each of our tables. Remember, we want to name that key using a constant from the BaseColumns interface. So we'll need to implement that interface. So we'll start with our CourseInfoEntry class. We'll have it implement the interface. So let's go ahead and take a quick look at this BaseColumns interface. I'll go ahead and right-click on this guy, choose Go To, and Declaration. And you'll notice here it's actually a very simple interface. It just has some constants to find in it. Now what we're interested in is this constant _id because, remember, that's what we're going to use to name our column. So let's head back to our Contract class. So we're here in our SQL CREATE statement. And we want to go ahead and add that _id column. So let's go in here and add a new line. We'll use the _id constant from the BaseColumns interface. And then we'll go ahead and concatenate the literal text, INTEGER PRIMARY KEY. And with that, our course_info table has that _id column as an INTEGER PRIMARY KEY. So now we're going to do the same thing for our NoteInfoEntry class. So let's have it implement the BaseColumns interface. Then we'll go down here to our CREATE TABLE statement and add that _id column as an INTEGER PRIMARY KEY. And with that, both our tables now have the primary keys in place to work effectively with the Android framework. So now in our next clip, we'll look at how we can use our DatabaseContract class to create the actual database.

Database Creation and Access
Now that we have our database and tables all designed out, we're ready for our application to start accessing and using our database. But database access has implications. The first issue is database creation. The first time our applications run, that database won't exist yet. So we need to check to see whether the database exists. And if it doesn't exist, then we need to go out there and create the database. The other issue is database versioning. As your application is improved, and as you enhance it and change it over time, the specific structure of the database that your application needs may change. So your application database has to actually have a concept of being versioned. So the database itself will have a version, and then your application has to indicate what version of the database is expects. And if the database version is currently behind the version of the database the application expects, then the database needs to be updated. Now we could, of course, code up our applications explicitly to deal with all these issues. But thankfully, we don't have to. There's a standard class we use to resolve these issues. And this is where the SQLiteOpenHelper class comes in. Now it provides methods that allow us to access the database. But whenever we use those methods to attempt to access the database, the SQLiteOpenHelper class manages the issues of database creation and database versioning. Now the specific needs of creating and versioning a database are going to vary from application to application. So our application will need to extend the SQLiteOpenHelper class to meet our application's needs. So generally what we'll do is provide a current version of the database our application currently expects. We'll provide the database file name we're going to use, and then we need to override the appropriate methods. The first method we'll override is the onCreate method. And this method gets called in the scenario where the SQLiteOpenHelper looks for the database and it isn't there. And what we'll do in this method is execute the SQL to create our database tables. And in addition to creating the tables, we'll often also want to add some initial data to those tables. For example, we might want to add a list of courses that a user can choose from in our application. The other method we'll override is the onUpgrade method. And this method gets called in that scenario where the SQLiteOpenHelper checks the version of the database, and it's behind the version of the database the application currently expects. So what we'll do in this method is execute whatever SQL is necessary to upgrade our tables. Oftentimes within this onUpgrade method, we'll also want to preserve the existing data. So we may need to add code now that actually reads data out of the tables, upgrades those tables, and writes it back into the tables. Now once we have our SQLiteOpenHelper created, we're ready to start using it throughout the rest of our application. And what we'll normally do is create an instance of our class in the activity's onCreate method and then assign that reference to a member field of the activity. What that does is it allows our open helper class to be around for the life of the activity. What we'll do then is that when our activity's onDestroy method gets called indicating that the activity's being destroyed, then we'll close up our open helper. But as you recall, the main thing our application uses our open helper class for is to access the database. And there're a couple of methods we'll use there. One is the getReadableDatabase method. We use that method when we want to get access to the database to read data out of it. There's also a getWritableDatabase method that we call when we want to access the database to make changes to the database. And both of these methods, getReadableDatabase and getWritableDatabase, trigger the creation and version checks as needed. So calling either of these methods will do the work to create the database if it isn't already there and upgrade it if it needs upgrading. Both methods return back a SQLiteDatabase reference. The SQLiteDatabase class provides the database interaction methods that we need to actually do work with our database. So there are operation-specific methods like we talked about earlier for things like inserting data into a table or deleting data from a table. But also it has methods to allow us to execute SQL when we need to. And in that case, we use the execSQL method. In our next clip, let's implement our application's open helper class.

Implementing the Database Open Helper
Here we are back in the Android Studio, and as you recall, we've already created our database contract class, which provides the information describing our course_info table including a SQL statement to create that table. And then the same thing for our note_info table. We have that SQL statement to create the table. So what we want to do now is create our database open helper class by using information from our contract class to handle the details of creating the database and the tables within it. So to create the class, we'll go over here to our package name. We'll right-click, choose New, and we'll choose Java Class. So let's name this class NoteKeeperOpenHelper. And since we know we want it to extend SQLiteOpenHelper, let's just go ahead and put that here in the Superclass. So we need to import the package that SQLiteOpenHelper comes from, so we'll do Alt+Enter just like we do when we're working in our source code. So let's go ahead and click OK. So now you can see it created our class. It has extends SQLiteOpenHelper. And it included the import for the package containing SQLiteOpenHelper. Let's go ahead and collapse the project window over here. So let's start implementing our class. Let's click on the lightbulb. Let's choose Implement methods. It shows onCreate and onUpgrade, and we want both of those, so we'll click OK. Now we also need a constructor. Click on the lightbulb. We'll choose Create constructor matching super. And we'll just go ahead and accept that first one there and say OK. Now as you can see, our constructor now accepts four parameters. But we can actually provide much of that information right here from inside the class. So let's look at the first one there, factory. Factory is a mechanism we use to customize behavior of our database interaction. And we don't really need to do that. So let's go up to our call to super, and let's change factory to null. And we'll go ahead and remove it from our constructor's parameter list. So let's look now at name and version. Name is going to be the file name that contains our database, and version is the version number of our database. So we can actually make both of these constants within the class. So let's go up to our class here. Let's first add a string constant that we'll name DATABASE_NAME. And now, again, we want to provide the file name that will contain our database. By convention, we end that file name in. db, so let's pick our name NoteKeeper. db. And then we need our integer constant to hold our database version, and we'll set that to 1. So now we have a constant DATABASE_VERSION that indicates that this is the first version of our database. And we have the constant DATABASE_NAME, which contains the name of the file that'll have our database. Let's pass both of these into our super constructor. So with that, we don't need to accept named versions as parameters of our constructor. So let's remove those. So now that we've created instances of our NoteKeeperOpenHelper, the only thing we have to pass in is the context. We take care of providing all the other information to our super constructor. So now before we carry on, let me just go ahead and collapse the imports up here at the top. So with those imports out of the way, let's go ahead and implement our onCreate method. Now you notice that onCreate receives a reference to a SQLiteDatabase. As we talked about, the SQLiteDatabase class allows us to interact with the database. So that'll actually allow us to execute the SQL statements that create our tables. So let's go down here into the onCreate method. We'll call it db. execSQL. And let's first create our course_info table. So let's use NotekeeperDatabaseContract. CourseInfoEntry, and we want to pass in the SQL create statement. So we'll pass in the constant SQL_CREATE_TABLE. So that'll run the SQL statement that creates our course_info table. So let's go ahead and now and do the same thing for our note_info table. So we'll call db. execSQL passing in NoteKeeperDatabaseContract. NoteInfoEntry. SQL_CREATE_TABLE. So with that there now, we've got everything we need to create the course_info table and the note_info table. Now at this point, though, when the tables are created, they'd be completely empty. And for some applications, that's okay. But for many applications, we need to provide some initial data. So, for example, in our case, we want to make sure the user has a list of courses to choose from. So we should probably add some rows to our course_info table. And then also for testing out our app, we probably want some sample notes in our note_info table. So to help us out with that, I've already created a class that takes care of the details of adding rows to our course_info table and our note_info table. So let's go ahead and add that class to our project. So let's head over to the before directory for module 1 of this course, and into your before directory, you'll see a class named DatabaseDataWorker. java. Let's go ahead and right-click on that guy and copy it. Let's head back over to Android Studio, expand our project window. Then to fully expand the project tree, let's just go over here and locate our current source file. Let's head down here to the package name. Let's right-click, choose Paste, and you see when I do that, Android Studio prompts me if I want to change the class name or change the directory it's going into or anything like that. I'll go ahead and accept everything it's suggesting and say OK. So now it's added this class DatabaseDataWorker to our project. Now let me scroll down here just a little bit. So you notice here this class has a constructor that accepts a reference to a SQLite database. Now it has two key methods. One method is insertCourses and handles the details of adding four rows to our course_info table so we'll have a list of four courses to choose from. The other method, insertSampleNotes, handles the details of adding rows to our note_info table so we'll have some sample notes to work with. So let's head back to our NoteKeeperOpenHelper class. So what we want to do now is use this DatabaseDataWorker class to add that data to the tables. So the first thing we'll do is create an instance of our DatabaseDataWorker and assign it to a local variable. And we'll pass in the database reference that was passed into onCreate. And from there we just call the methods. So, first, we'll call worker. insertCourses. And then we'll call worker. insertSampleNotes. And so now our onCreate method does all the work to create the tables, which were initially empty, and then using our DatabaseDataWorker class to actually add some rows to each of those tables. So let's just scroll down here a little bit. So we also have our onUpgrade method. Now, remember, the purpose of this method is to transition the database from an older version up to whatever version an app might currently need. Now at this point, we're on the first version of the database so there's no upgrade work to do. But now later in the course series, we will add some code for onUpgrade to deal with some additional needs we have inside of our database. But for now, we'll just leave it empty. So with that, our NoteKeeperOpenHelper class is all set to go. So in our next clip, we'll go ahead and use this class to create the database.

Creating the Database
Here we are back in Android Studio. What we want to do now is add the code to our MainActivity to utilize our NoteKeeperOpenHelper. Now remember that when we use these open helpers, we generally want them to stick around for the life of the activity. So the first thing we'll do is add a member field to hold a reference to it. So there we have it, our field mDbOpenHelper. So, next, what we want to do is create an instance of it. And so we'll go ahead and create that in the activity's onCreate method. So we'll go down here. Let's go ahead and add a line and create an instance of our NoteKeeperOpenHelper and assign it to our member field. So now, remember, our constructor requires a context, so let's just pass in our 'this' reference. So there we've got our instance created. And the thing to keep in mind is that creating an instance of the open helper is actually fairly cheap. The thing that's expensive is actually interacting with the database. So that's why it's okay for us to go ahead and create the instance here in onCreate, but we wouldn't want to actually try to access the database itself. We'll talk more about that issue later in the course. So we've created our open helper when the activity was created. So then we want to close our helper when the activity is being destroyed. So what we'll do is scroll down here a little bit, and let's override the activity's onDestroy method. So we'll go up here to my Code option, choose Override Methods. I'll select onDestroy and then say OK. And then the first thing we'll do with our onDestroy method is call close on mDbOpenHelper. So now we've got the code in place for our open helper to live for the life of the activity and be closed down when the activity is being destroyed. If this is the only code we put into our MainActivity, we would never get our database created because the database doesn't get created until we try to connect up to it. So let me scroll down here again. So here we are now in our displayNotes method. And this is the point in the activity where we'd want to go ahead and connect up to the database, get the rows out of our note_info table, and display them to the user. So we'll go ahead and do mDbOpenHelper and call getReadableDatabase. GetReadableDatabase returns back a SQLiteDatabase reference, so let's assign it to a local variable. So now calling getReadableDatabase will do the work to check to see if the database exists and create it if it doesn't. And this work of interacting with the database can be potentially very long running. So the way we're currently calling getReadableDatabase here as part of our main application flow can actually create a very sluggish user experience. A little bit later in the course, we'll see a better time in our app to connect up to the database. But for now, let's go ahead and do it here just so it can verify that our open helper works as we expect it to. So what we can do is go ahead and run the application and just see if our database gets created or now. So what I'm going to do is go ahead and put a breakpoint here on this line, and I'm going to go over to our open helper class and put a breakpoint on the first line of our onCreate. So we'll go ahead and start it in the debugger. So you can see here now our application is about to attempt to connect to the database. So let me go ahead and let it continue running. So you can see what happened when I let it continue running, it went into our onCreate method. So let me scroll down here a little bit. Let's step through it a line at a time. So we'll go ahead and run the SQL to create our course_info table. That worked. And the SQL to create our note_info table, that worked. Step here. We'll add some rows to the course_info. We'll add some rows to our note_info. I'll let it continue running. So we can see now that our application did the work to connect up to the database, and it went out and created it. But the challenge we have is that we don't really know what the database looks like right now. Remember that our application is still interacting with data from in-memory. It's not interacting with a database yet. So how can we check to see if the database was created the way we expect it to? And that's what we'll take a look at in the next clip.

Verifying Database Structure and Content
Here we are back in the Android Studio, and what we want to do now is confirm that the database we created was created as we expect. So now in order to do that, we need to open up the database, look at its structure and contents, and confirm that what we expect to be there is indeed there. Now there are a few options for doing this. But I find the easiest way to do it is to transfer that database over to My Desktop then use SQLite running on My Desktop to look at it. So in order to transfer, I'll go over to Android Studio and choose this tab at the bottom terminal. So let's click on that. What this does is open up a shell or command prompt. In other words, it allows me to execute commands directly here on My Desktop. The command I'm going to use is adb. Now adb is a command that allows me to interact with whatever device or emulator is connected to My Desktop. And it's my preference for transferring these database files because I find it to be the most reliable way to do it. There are other utilities for transferring the files, but they often run into issues if you're dealing with a device that's locked or even the most recent versions of the Android operating system running on an emulator. So I'm going to show you the whole command, and then I'll explain the parts of it. So we have the adb command followed by the option exec-out. Put an open quote, now put run-as, a space, then my application's package name. Follow it up by cat, space, databases/, and our database file name. So I'm going to put a close quote, and I'll put greater than, space, and repeat our database file name. So let's take a look at the parts of this command. Now as I mentioned, adb is a utility that lets me interact with the connected device or emulator. The exec-out option indicates that I want to transfer any content from the device or emulator over to My Desktop in binary form. In other words, keep it exactly as it appears on the device when you put it on My Desktop. That's important when transferring database files. If we don't use that option, the database file may get corrupt when you try to transfer it to your desktop. So now the contents inside the quotes, that part actually runs directly on our emulator. So we're actually using the adb commands on our desktop to issue a command to the connected emulator. So now the run-as followed by our package name. Again, notice that's the package name exactly as it appears in our project window. And what we're saying is that I want to perform this operation as if I'm this application. And the operation I want to perform is a cat. A cat is just a Linux command that says, Show me the contents. And I'm saying I want the database file NoteKeeper. db in this application's databases folder. And that's the folder that Android uses to create databases. So basically what we're doing here is using this command to scroll by the contents of our database. But then the greater than and NoteKeeper. db says, Well take those contents and write them to My Desktop into a file called NoteKeeper. db. So we can use this command to transfer any application's database with one caveat: The application has to be compiled in debug mode. Obviously, we don't want to allow anyone just to start running on our devices or emulators as if that's an application. So Android confirms that we've got a debug version of the application installed on the device or emulator. As long as we do, it allows us to run a command like this. So what this command does is gives us a way to reliably transfer the database of any application we're working on over to our desktop so we can interact with it. So let me go ahead and hit Enter. And you notice you don't see much information there, but this is a case of no news is good news because as long as we don't see an error, that means we now have the contents of our application database inside a file called NoteKeeper. db on our desktop. So now I'm going to use SQLite running on My Desktop. So you will need to download and install SQLite, and I've got the URL on the screen that you can download that from. And the SQLite command I want to use is sqlite3. And I'm going to follow it by my database file name. And when I hit Enter, my database is now opened up inside of SQLite. Now using SQLite directly, I'm using a command prompt interface, which isn't super pretty, but it allows me to do the basic operations I need to. There are also GUI-based tools out there if you prefer a graphical user interface. But for just performing a simple check of the database, I find SQLite itself works just fine. So now there're a few commands here I want to show you. The first one I'm going to show you is one called. tables. And this will show me the list of tables inside of this database. And you can see that there's one table called android_metadata, and that's one that Android itself needs. But you notice there're our two tables--course_info and note_info. So now let's look at the structure of each of those tables. So I'm going to use the command. schema, and let's put course_info. So this says, Show me the schema or structure of the course_info table. And you see there that it shows it to me as a CREATE TABLE command. So basically it's saying it's a CREATE TABLE command for a table called course_info and then it lists our columns. So we've got our _id column, which is an INTEGER PRIMARY KEY, our course_id column, which is a TEXT with the constraints UNIQUE and NOT NULL, then our course_title column, which is a TEXT with the constraint NOT NULL. And that's exactly what we want to see. So let's do a. schema for note_info. Let's see what that looks like. Again, of course, it's a CREATE TABLE command for our table note_info. We have our _id column, again an INTEGER PRIMARY KEY, our note_title column, which is TEXT with the constraint NOT NULL, our note_text column, which is TEXT and no constraints, and course_id column, which is TEXT and a NOT NULL constraint. That shows us now that our database has the tables we expect, and they each have the structure we expect. Let's make sure now that the data we put inside this table is as we expect. Now you notice that both tables and schema started with a dot. That indicated that they were a SQLite command. In other words, telling SQLite to do something. If you want to see that list of those commands, you can simply type in. help. But SQLite also lets us run SQL commands. And so what we'll do is use a very simple SQL command, which is the select command, that shows us the contents of each of these tables. So I'm going to type select. And notice that the select does not have a dot in front of it because it's not a SQLite command, it's a SQL statement. I'm going to follow that with an asterisk. And the asterisk simply says, Show me all the columns from whatever table I indicate. So I'm going to say from course_info. So what this command says is, Show me all the columns of all the rows in the table named course_info. And when we're using this SQLite interactive command prompt, we have to enter SQL statements with a semicolon. And that semicolon indicates that I'm at the end of the SQL statement. So I hit Enter. And if you look there now, you can see there are four rows in that table. Let's look at just the first one. It has an _id column value of 1. It has a course_id value of android_intents. And the course_title is Android Programming with Intents. And you can see we have all four of those rows there. So now let's look inside of our note_info table. So we'll do a select * from note_info. Now as I mentioned, you want to make sure that all of your SQL statements end in a semicolon. Let me show you what happens if I don't put a semicolon on the end. So I'm just going to go ahead and hit Enter. And you see where it shows that... greater than. And what SQLite is saying there is that I guess there's more to come. So just tell me what the rest of the SQL is. So if you forget to put a semicolon at the end, when you get this... greater than, you can then put the semicolon in at that point, hit Enter, and then you actually run that SQL statement. So we can see here now that our note_info table has eight rows in it. If we look through the first one, it's got an _id of 1. It's got a note title of Dynamic intent resolution. We can see our note text there. And it's associated with the course android_intents. So now when we're all done working with SQLite, we can put in a. quit, hit Enter, and that exits SQLite. So now we've seen by transferring the file over to our desktop and looking at it with SQLite, we confirmed that we've created the table correctly, it has the right structure and the right data inside of it. So that means now that we're ready to start transferring our application code to use the database rather than working with the in-memory data model.

Summary
To wrap up, here's some of the key things we want to remember from this module. Remember that SQLite is a relational database that's lightweight and portable, which makes it a perfect storage solution for our Android applications. Now as we store data within the SQLite data, there're a few key concepts we want to understand. Remember that we actually store the data within tables. And any given table is considered to be a set of related entities. And tables are composed of columns and rows. A column is an attribute of that entity, and we often just call that a field. And then a row is an instance of that entity, and we'll often refer to that as a record. Then we have the database contract class, and that allows us to describe the structure of our database within our application. Now within the contract class, there's a nested class for each of the tables. And it will provide a series of constants. We'll have constants for the table name, constants for the columns, and we'll also have constants for key SQL statements such as the CREATE TABLE statement. Now as we're designing our tables, we have to express the columns within those tables. Remember that each column has a name. And optionally a column can also have a storage class. Now remember that a storage class is not strict typing of that column. Remember that any column can store data of any type. So storage class simply expresses the preferred form to store the data for that column. Columns can also have constraints, which restrict the allowable content for that column. Remember that we want to design our tables in a way that works well with the Android framework, which means that our tables should have an integer primary key, and the name of the column associated with that key should come from the constant _id from the interface BaseColumn. And then we had SQLiteOpenHelper, and that provided methods for accessing the database, but as part of that, it managed database creation and versioning of the database. Now in order to use the SQLiteOpenHelper, we have to extend it to meet our application's needs. And as part of that, we provide things like the database file name and the application's currently expected version of the database. We implement the code to actually create the database. And we implement the code to transition the database from an older version up to our currently expected version. That wraps up this module. In our next module, we'll look at the features and capabilities that SQLite provides for accessing the data within our database.

Reading Data from SQLite
Introduction
Welcome to the Reading Data from SQLite module of the Pluralsight course, Managing Android App Data with SQLite. My name is Jim Wilson. With our application database created, we can start the process of transitioning our app from using transient in-memory data to instead use data that is persistently stored in our SQLite database. In this module, we'll take the first step to making that transition by learning how to read data from our database. We'll start out by taking a look at our initial plan for transitioning the app to use data read from our SQLite database. We'll then see how we issue queries to our database. We'll see how we move through results of our query using something known as a cursor. We'll see how to access the values in our result. And then we'll finish up by seeing how we can control the order that results are returned.

Your App Plan
As a reminder, let's take a quick look at the application we've been building throughout this course series. As you recall, our application has a list of notes in it. Remember that each note is associated with a course. So we have the option to look at the list of courses that have notes. And of course if we select a note, we can see and interact with the details of that note. Now ultimately throughout this course, we're going to transition each of these activities to work directly with the SQLite database that we created earlier. But initially, we'll start a transition using a SQLite database by integrating the SQLite database into our application's existing data model. And as you'll recall, our existing data model has a class that represents a course, and each course has an ID and a title. We have a class that represents a note. Each note has a title, a text, and each note is associated with a course. Now the way our activities get access to the courses and the notes is through our DataManager class. Remember, our DataManager class is a member field that holds a list of courses, and our DataManager class has a member field that holds a list of notes. Now currently as our application is written, each of those lists is loaded with transient in-memory data. So what we're going to do in this module is take our SQLite database that we've created, and remember that it has a table for the courses, and it has a table for the notes. And what we will do then is read the data from the course table into the DataManager's course list, and we'll read the data from the notes tables into the DataManager's notes list. And with that process, our DataManager will now be using the notes and the courses from our SQLite database. So in our next clip, let's see what's involved in accessing data inside of a SQLite database.

Accessing Data
One of the most common things we can do with a database is access data that's already in the database. Now this process of accessing the data is broken out into distinct phases. Now the first thing we need to do is request a connection to the database. We then want to issue a query to identify what we want from the database. And then we need to move through the results of that query. So now when it comes to requesting a database connection, this builds on what we talked about earlier in the course. The connection's provided by that SQLiteOpenHelper class. And what we'll want to do in our applications is use implementation of the SQLiteOpenHelper class that we've created. Now if we're just reading data from the database, we'll call the getReadableDatabase method, and that'll give us back a reference to the SQLiteDatabase. Now once we have that SQLiteDatabase reference, we identify what we want from the database using the query method. Now this is equivalent to issuing a SQL select statement. And SQLite does allow us to issue a regular SQL select. As we talked about earlier, in any scenario where SQLite provides an operation-specific method, we want to use that method rather than explicit SQL. So when we want data from the database, we're going to prefer the query method. The query method accepts a number of parameters that'll allow us to specify the query details, but we don't have to specify all the parameters. Any parameters that we don't want to specify, we can simply pass null for. But there are two fundamental parameters to the query method. The first thing is the table name. We want to identify what table we want to pull the rows from. And then the other thing we want to specify is which of the columns from each of those rows we want returned back. To help us understand what it's like to work with the query method, in our next clip, we'll query for the courses and the notes from our database.

Querying CourseInfo Table
Here we are in Android Studio, and we're looking at our DataManager class. Remember, this is the class that provides data to the rest of the application. Now it has two lists inside of it--one for courses and one for notes. Now remember that DataManager is a singleton, meaning that there's one instance shared throughout the whole application. Any time we want to get a reference to that instance, we call this method here getInstance. And the way getInstance is currently implemented, the first time it's called, it automatically loads up the list of courses and the list of notes from transient data in-memory. We don't want to do that anymore, so let's go ahead and comment those two lines out. And what we'll do instead is add a method that allows us to explicitly load those lists from the database. So let's add a static method here called loadFromDatabase. This method, of course, will need to get a connection to the database. And the way we get a connection to the database is with that NoteKeeperOpenHelper class we wrote earlier. So let's go ahead and accept a reference to that. And we'll call the parameter dbHelper. Let's go ahead and give the method a body. So now the first thing we'll need is a connection to the database. So we'll use our dbHelper reference. And since we're reading data, we'll call getReadableDatabase and assign that result to a local variable called db. So that local variable db is of type SQLiteDatabase. And, remember, that allows us to interact with the database. What we want to do is do a query from the database. So let's call db. query. And we want to query from our course_info table. So we'll pass in our NoteKeeperDatabaseContract. CourseInfoEntry. TABLE_NAME. So we have our table name there. As I'm looking at the fully qualified name of the constants within our CourseInfoEntry class, it's actually getting pretty long. And we're actually going to have to use constants from inside of that class quite a bit. And having to type the contract class name before it each time is going to actually be cumbersome to type and honestly make our code harder to read. So let's see if we can help that out a little bit. So let's go over here click on CourseInfoEntry. Now let's click on the lightbulb. Notice our second option there says Add import for, then it's our NoteKeeperDatabaseContract. CourseInfoEntry. Let's go ahead and choose that. And you'll notice there now that we're able to pass the TABLE_NAME constant by simply saying CourseInfoEntry. TABLE_NAME. So let's scroll up a little bit in our source code and see what happened. And you see here what it's done is it added an import for NoteKeeperDatabaseContract. CourseInfoEntry allowing us to use the CourseInfoEntry directly, not having to qualify the inside of our contract class name. So let's go ahead and collapse the imports and scroll back down. So we're back here to our call to the query method. We've already got our table name in there. So now we need to specify the columns. Now the columns are specified as a String array. So I'm going to create a new instance of the String array right here in the query call. And inside that array, I'll provide the name of the columns that I want to receive back on my result. The first column that I want is COURSE_ID. The next column I want is COURSE_TITLE. So now in our call to our query method, we've indicated that we want to get the rows back from our course_info table, and we want that result to have the columns for COURSE_ID and COURSE_TITLE. Now this call to the query method still accepts five more parameters, but we don't need to specify any of those. So I'm just going to provide five nulls here. So we now have all the parameters passed to our query method. But you know as I'm looking at the call to the query, creating a new instance of the String array for the columns right there in the call is a little bit hard to read. So I'm going to go down here to the String array, and I'm going to right-click. I'm going to choose Refactor, choose Extract, and then choose Variable. So now Android Studio is offering me two options of what I want to assign to a variable. It's asking me, Do you want to assign that String array to a variable. Or if you see below, it says db. query, it's asking, Or do you want to assign the result of the call to db. query to a variable? And I want to assign the String array, so let's just go ahead and choose that. And it's saying, What do you want to call that variable? I'm going to go ahead and call it courseColumns. I'll hit Tab. Now the array of columns we want is in a local variable. Let's go ahead and add a new line before that first column name to neaten things up a little bit. So now with our columns and the variable, we're calling our query method passing in the table we want, the columns, and then nulling the rest of the parameters. So we're off to a pretty good start. In our next clip, we'll add the code to create the database for our notes, and we'll hook the call into our loadFromDatabase method into our MainActivity.

Querying NoteInfo Table and Connecting Queries to MainActivity
Here we are back in the Android Studio looking at our DataManager class's loadFromDatabase method. Now earlier we added the code to query the database for the courses. What we want to do now is add the code to query the database for the notes. So we've already got our SQLiteDatabase variable called db. So we'll call it db. query. So now we want to specify what table we want to query from, so we'll use our NoteKeeperDatabaseContract class, and that has a NoteInfoEntry class inside of it with a constant TABLE_NAME. So that we don't have to keep qualifying our NoteInfoEntry class within the NoteKeeperDatabaseContract class, let's go down to import for that. So I'll click on that. I'm going to choose my lightbulb, choose Add Import. So that way we can just specify it now as NoteInfoEntry. TABLE_NAME. So now we need to specify the columns. So we'll create a new instance of a String array. So the first column we want is NOTE_TITLE. Let's go ahead and add the constants for the COLUMN_NOTE_TEXT and COLUMN_COURSE_ID. That specifies the three columns that we want. Let's go ahead and add nulls for the remaining parameters. Let's go ahead and extract that list of columns to a local variable like we did for the courses. So I'm just going to click on it. And this time I'll just use the hotkey Ctrl+Alt+V. It asks what do I want to extract to a variable? And I want that list of columns that's currently selected, so I'll hit Enter. We'll name the variable noteColumns. I'll go ahead and hit Tab. And now we have all the parameters passed to our query method. So we're off to a good start with our loadFromDatabase method. So let's go ahead and head over to our MainActivity class so we can add a call to loadFromDatabase. So we're here in our MainActivity class's initializeDisplayContent method, and this is the method where we do all the initial work to display the content in the MainActivity. So for now, let's go ahead and call our DataManager's loadFromDatabase here. So I'll simply say DataManager. loadFromDatabase. And remember that our MainActivity class has an open helper field called mDbOpenHelper. So I'll go ahead and just pass that into our call to loadFromDatabase. And with that, our loadFromDatabase method will use that open helper to get the connection to the database to each of the queries. So now before we leave MainActivity, let's just do one quick bit of housekeeping. Notice here at the bottom of the screen, we have a displayNotes method. And as you remember earlier in the course, we added that call to getReadableDatabase just to test out our open helper. We don't need that anymore. So let's go ahead and delete that line. So our MainActivity is set to go. Let's head back to our DataManager and look at one quick thing. So here we are back in our loadFromDatabase method within our DataManager class. Now as you recall, we extracted the String array out containing the column names to a local variable. Android Studio asks us if we want to actually take that array and make it a variable or assign the result of the query method to a variable. Well all that that means is that the query method must return something. So let's head over to our query call for the courses. We'll right-click, choose Refactor, choose Extract, and then choose Variable. So we can see there that the type returned by query is a cursor. So let's go ahead and name this variable courseCursor. We'll hit Tab. Let's do the same thing for the call to query for our notes. So we'll head down there. This time we use the keyword shortcut Ctrl+Alt+V. And we'll call this one noteCursor. And then we'll hit Tab. So now we have the results of the call to query for the courses and something called a courseCursor, and we have the results for the call to query for the notes in something called the noteCursor. And, of course, both of those variables are of type Cursor. So the big question is, What's a Cursor? And that's what we'll look at in the next clip.

Move Through Results
As we saw in our application code, when we called the query method, the query method returns back a reference to a cursor. Now a cursor provides us access to the results of the query. So when we issue a query, it operates on a table. That table has rows, so the results of the query also have rows. And a given query result may have 0 rows in it, it might have 1 row, or it might have multiple rows. So what a cursor allows us to do is walk through that result row by row. In order to provide us with this row-by-row access, a cursor has to maintain a current position in the result. When the query first returns, the cursor is actually positioned before the first row in the result. So when that result is first returned, you can't actually access any of the values in the result. What we have to do is explicitly position the cursor to a particular row. Now there are a few different ways to do that, but one of the most common ways we do that is by using the cursor's moveToNext method. And what that allows us to do is move sequentially to the next row in the result. In other words, it allows us to walk through the rows in the result in the order that they're returned. The moveToNext method returns back a True or False value. So as long as we're able to move to the next row successfully, it'll return True. But then eventually you actually walk past the end of the result. And then in that case, it returns False. So as long as moveToNext returns True, you know you're able to access the data of the current row. So let's see what this all looks like. So say we have our table note_info in our database, and we want to actually issue a query against it. So we would use the query method, and we'd provide the information we need for the query. So we'd specify the table, and then we'll specify the columns. So in this case, we're asking for the column's course_id and note_title. And then, of course, we provide the rest of those parameters. So what the query method does is operate on that table and produce a result that corresponds to the query. So in this case, we're seeing all the rows from our note_info table but only the columns we asked for, course_id and note_title. So when the query method first returns, our cursor's positioned before the first row. So as we said, that means we can't actually access any of the data in the result at this point. So what we can do is call moveToNext. That would position us to that first row. We could access the data on that row, and then we could call moveToNext, and that will position us on the next row, and we could access that data. Call moveToNext, and we could access the data on that row. Now each of these times we've called moveToNext, moveToNext will be returning true. But if we called it again, we'd move past the end of the results. And moveToNext would then return False telling us that we'd processed all of the data. In addition to being able to use moveToNext to move sequentially forward through the result, there's also a moveToPrevious. What moveToPrevious allows us to do is have the cursor move from whatever row it's currently positioned on to whatever row precedes it in the result. MoveToPrevious also returns back a True or False value. And it will return True until you try to move past the beginning of the result. So if we look at our diagram, remember that when a query first returns, our cursor is positioned before the first row. So we call moveToNext. We move it to the first row. MoveToNext to get to the second row. MoveToNext to get to the third row. Then if our application wanted to start moving backwards, and we called moveToPrevious, we'd move from the third row to the second row. Call moveToPrevious again, we'd go from the second to the first. And then if we called moveToPrevious again, we'd go before the first row. So in this case, moveToPrevious will return False. Cursors aren't limited to sequential movement. You can also do direct access. So there's a moveToFirst method, which allows us to jump directly to the first row in the result no matter where we're currently positioned. We've got a moveToLast, which allows us to jump directly to the last row in the result. And there's also a moveToPosition, and that allows us to position to any row in the result by simply passing the index of that row. It's important to remember that's a zero-based index, which means the first row is index 0, the second row is index 1, and so forth. So in our next clip, let's continue our discussion of moving through the results with a look at how we access the values in a row.

Accessing Result Column Values
As we use our cursor to move through the rows in a result, we're going to want to access the values from that result. And so the cursor allows us to get the column values of whatever row the cursor is currently positioned on. So the cursor class has a series of typed get methods. So there's like a getString or getInt. And when we access the value for column, we don't pass in a column name. We have to pass in the index of that column in the result. So let's see what this all looks like. So here's the same diagram we were looking at in the last clip where we issued our query. We got back our result with two columns. It's got to resolve the column course_id and the column note_title. Now we want to get the values of those columns. We can't do it by the name course_id or note_title. We have to do it by the column's position. So if we want the value for course_id, we actually ask for the column with the index value 0. If we want to get the value for the column note_title, we ask for the value in column position 1. Now notice that those column positions don't correspond to the column positions in the table. They correspond to the column positions in our query. So since course_id is the first column we specified in query, that's column position 0. And note_title is our second column in our column query, so that's column position 1. So if we want to walk through all this data, remember that when our query first returns, our cursor's position is before the first row. So we could call moveToNext to get to the first row. And then we might say getString column 0, and that will give us the course_id from the first row. If I call getString column 1, that would then give me the note_title from the first row. From there, I could simply call moveToNext. As for getString in column 0, I get the course_id, getString on column position 1, I get the note_title. From there, I can call moveToNext again, get the course_id, get the note_title. And then when I'm done and I call moveToNext, moveToNext will return back to False telling me I've processed all those rows. When we're using the cursor get methods to access the values of the columns, we want to avoid hard-coding column positions because if we pass in literal 0s and literal 1s and literal 2s and so forth for the column positions, our code could become very fragile because changes to the query might change the index of a particular column. What we'd rather do is have the cursor tell us what position a particular column is at. The cursor class has a method getColumnIndex that does just that. We can pass in the name of the column we're interested in and getColumnIndex will return back that column's position in the cursor. By using getColumnIndex to get the column's current position, we're sure to always get the correct index for that column. One more thing we want to keep in mind--when we're done with our cursor, we want to be sure to call its close method on it because cursors consume system resources. They consume memory and so forth. And if you don't close it, the cursor may leak those resources. So it's a simple thing to do, but you just want to be sure that you do it. Whenever you're done with a cursor, be sure to call close on it. So in our next clip, we'll start using cursors inside of our program to read back our list of notes and our list of courses.

Loading Courses
Here we are back in the Android Studio looking at our DataManager class. Remember, the DataManager's a singleton and there's only one instance shared for the whole application. And it contains two lists, one for the courses and one for the notes. We're in the process of adding the code to load those lists from the database. And we start that work in a method called loadFromDatabase. Let's scroll down so we can see the whole method. So here at loadFromDatabase, it's a static method. And we have the code in place to query for the courses and for the notes. What I'll do now is use the results of that query to load up the lists. So let's start with the courses. So you can see her we have our call to query for the course_info table. We specify that we want the column's course_id and course_title, and query returns back a cursor, which we've called courseCursor. So we'll use that courseCursor to actually get the values of the columns within the course_info table. So let's do that work in a separate method. So let's call a method we'll create called loadCoursesFromDatabase and pass in the courseCursor. We'll go ahead and click on our lightbulb, say Create. We'll accept a void return type, so hit Tab. We want the parameter to be a cursor, so hit Tab. Let's just go in and change the parameter name to cursor. We'll hit Tab again. So, remember, when we want to get the column values out of a cursor, we get those column values based on the column position. And we don't want to hard code those positions. We want to instead ask the cursor for the positions. So we'll first need to ask for the position of the course_id column. So let's declare our local variable of type int. We'll call it courseIdPos. And then we'll call the cursor's getColumnIndex method. And what we need to pass in now is the name of the column we want. So that'd be our CourseInfoEntry. COLUMN_COURSE_ID. So when the call to getColumnIndex returns, that variable courseIdPos will have the index of the course_id column. So now we'll do the same thing for the course_title. So we'll have a local variable courseTitlePos. So, again, we'll call the cursor's getColumnIndex method for COLUMN_COURSE_TITLE. So now those two variables have the positions of the course_id and course_title columns. So, remember, now we want to load these courses into the lists contained in our DataManager singleton. So in order to access that list, the first thing we need to do is get a reference to the singleton. So the method getInstance returns us back a reference to the instance, and we store it in our local variable there dm. So now we want to clear out any courses that might already have been loaded. So we'll say dm. mCourses. clear. And all we're doing here is just making sure we start out with a fresh clean list each time we load it up. So now remember when a cursor's returned, it's positioned before the first row. So if we want to walk those rows in order, we use the cursor's moveToNext method. But, remember, we have to actually call moveToNext before we try to access any of the values. So we'll say cursor. moveToNext. So now remember that moveToNext returns True if it was able to move to the next row. Once we move past the end of the last row, it'll return False. So we can actually wrap this call to moveToNext in a while loop. Now it's here in the body that the while loop will actually do the work to access the values. So our cursor is positioned initially at the first row, so we can get the values for the course_id columns and the course_title columns. Let's start with the course_id column. So let's declare a local string variable. We'll call it courseId. And then we'll call the cursor's getString method and pass in our courseIdPos. So I return back the value for the course_id column and store it in courseId. We'll do the same thing for the course_title. So now with those two values, we can create a new instance of CourseInfo passing in our courseId and our courseTitle. Now the CourseInfo constructor takes a third parameter that we don't need, so we'll just pass null for that. So now we have a new instance of CourseInfo containing the ID and title from the current row. So let's go ahead and add that to our Courses list. So the first pass through the loop will create a new CourseInfo instance with the values from the first row. We'll loop around, do the same for the second row. Then we'll continue on until we've processed all the rows in our course_info table. Now, of course, once we've processed all the rows, we'll exit the while loop. Now, remember, we want to close the cursor when we're done. Let's go down here after the while loop, and we'll simply call cursor. close. So now we have all the code in place to load up the courses from the database. In our next clip, we'll add the code to loop the notes from the database and then test out that everything worked.

Loading Notes and Testing Your App
Here we are back in the Android Studio. We're looking at our DataManager class. We're continuing our work loading our courses and our notes from the database. And we've already got the courses loaded, so we're ready to start loading the notes. So you can see that I've got my call to query method for the note_info table, and I've got my list of columns in that variable noteColumns. Now you can see that we've got that noteColumns variable declared. Let's go ahead and neaten that up a little bit so we can read it more easily. So that's a little better. So we can see we've got three columns there. So as we process the results in our noteCursor, we want to get values for those three columns. So let's go ahead and create a method called loadNotesFromDatabase. We'll pass in our noteCursor. So for the Create method, we'll click on the lightbulb, say Create method. We'll keep the void return type. We'll keep the Cursor parameter type. Let's just go ahead and call the parameter cursor. So now as we work through the return notes, you see that the work we do here is very much like the work we did for the courses. In fact, you'll see that's a very common pattern when working through database results. The first thing we do is get the positions of the columns, so let's get our three column positions. And when working through the results of a database query, once we have those column positions, we do any application-specific setup work. So in our case, that's going to be getting a reference to our DataManager singleton and then clearing out the Notes list. And then once we have that setup work done, we're going to start working through our results. Now before I start adding that code, let me just scroll down here a little bit so we can see everything a little more clearly. So that's a little better. So what we want to do now is, again, use the while loop to move through the results row by row by calling the cursor's moveToNext method. Go ahead and add a body to our while loop. And then what we want to do is get the values for each of the columns. So we'll get the values for our title, our text, and our course ID. So once we have the values for the columns and the current row, we need to do whatever our application-specific work is. Now in our case, we want to go ahead and create an instance of our NoteInfo class and add it to the list. But remember that the notes are associated with a course. So before we can actually create the NoteInfo instance, we want to get the course that corresponds with this particular note. So let's create a local variable of type CourseInfo and name it noteCourse. And then we'll ask the DataManager to give us the course that corresponds to the courseId that was returned for the current row. And then once we have that course, we can create a new instance of a NoteInfo. We'll assign it to a local variable called Note. We'll pass in our noteCourse, our noteTitle, and our noteText. And then we'll add that note to our Notes list. So with that code in place, our while loop will loop through once for each row in the result. We'll get the values for each note. We'll find a corresponding course. We'll create a new instance of our NoteInfo, and then we'll add that new note to our Notes list. The last thing we need to do here is go ahead and close the cursor when we're done. So now we've added all the code to our application to load the courses and the notes from our database. So to see this work, we can actually step through it in a debugger. Now the loading of the courses and the loading of the notes works largely the same way, so what we'll do is we'll step through our loadNotesFromDatabase in the debugger to see how things work. So let's go ahead and put a breakpoint here on our first line. And then let's go ahead and run it in a debugger. So here we are with our application running in the debugger. We're in our loadNotesFromDatabase method. You can see we're about to get the positions of each of the columns and the cursor. So we'll step once. You see there that the position for the noteTitle column is position 0. Let's step again. You see the noteText column is at position 1. Step again. The courseId is at position 2. So that tells us the index of the values of each column in our cursor. So we'll go ahead and get our singleton instance. We'll clear out our Notes list. Then we'll go into our while loop. So we'll step once. The cursor's now positioned at the first row in the result. So I step once. So your note title is Dynamic intent resolution. Step again. Let's scroll our variable windows down a bit so we can see better. We can see our noteText is Wow, intents allow components to be resolved at runtime. Let's step again. Let's go ahead and enlarge our debug window so we can see more of the variables at one time. So we'll step again. We get a reference to our course. We create a note, then we add it to the list. Loop back around to the top of our while loop, and then repeat that process for the next row. Now we'll continue until we've processed all the notes that are in our note_info table. So let's go ahead and release this guy and see what our application looks like inside the emulator. So now here we are inside the emulator. We can see our application running. Let's go up here and switch over to the Courses view. We can now see our list of courses. Let's switch back to our Notes. And, again, we have our list of notes. So all that's working correctly. Now one thing you'll notice though is that the order of the notes is kind of scattered. We've got the Android Programming with Intents note. Then we've got our Java Fundamentals: The Java Language note. Then we've got another Android Programming with Intents. Then we've got our Java Fundamentals: The Core Platform. You know, it would be nice if we could order these notes in a way that is meaningful to the user, possibly something like sort them alphabetically by the course they're associated with. So in our next clip, let's see how we can do that.

Ordering Results
When we get back a result from the query method, by default, the ordering of the rows in that result is considered to be undefined. In other words, the database can give it back to us in any order it wants to. Now often times that's find, but there are many scenarios when we want to be sure that our rows come back in a specific order. So when we issue a query, we can specify we want the rows ordered based on the values of specific columns in that result. The way we specify our ordering is by passing a string value to the query method. And in its simplest form, we can simply pass in a column name. So if we pass in the column name for the ordering, then the resulting rows will be ordered based on the values in that column. But we're not limited to ordering our results based on the values in one column. We can actually order the results based on the values in multiple columns. So we still pass in a string value, and we simply list the columns we want to order it by separated by commas. So if we pass in multiple columns, the first column is considered the primary source. In other words, the entire result is first sorted by the values in that column. And then the second column is ordered within the values of the first column. And if you add a third column, that's ordered within the values in the second column, and so forth. The values of the columns that we specify for ordering are sorted in ascending order by default, but we're not limited to ascending order. We can specify that values are sorted in descending order if that's what we want. The way we do that is by following the column name with space DESC. That indicates that that column's values should be sorted in descending order. Now keep in mind when you use the DESC indicator, it only applies to the column that it's next to. If you have multiple columns specified, the other columns will continue to be sorted in ascending order unless you put the DESC next to those as well. So in our next clip, let's add some ordering to the rows that come back for our notes and our courses.

Ordering Courses and Notes
Here we are with the application running in the emulator. And as you recall, we've changed the application so that rather than having the notes and courses taken from transient in-memory data, we now load them from the database. But currently there's no ordering involved in the data. So if we look at the list of notes here, you can see the first note is for the course Android Programming with Intents. The second one's for the Java Language course. The third one's for the Android Programming with Intents. Fourth one's for the Java Core Platform course. If I go to the list of courses, you can see that that's not ordered either. We've got the Java Language course, then Android Programming Intents, the Java Platform course, then Android Async Programming and Services. So what we'd like to do is load the data from the database so that we can display it in a reasonable order. Let's head back to our code and see how we can do that. So here we are in our DataManager loadFromDatabase method. Remember that this is the method responsible for issuing the query out to our database and then loading up the list of courses and the list of notes. Now as you recall, our code that actually processes the results from the database just walks through the data in the order that it was returned. So if we could query the data in a way that's returned back in a specific order, that same order would be reflected when we display the information. So let's start out with our courses. So you can see we've got our query statement here for the course_info table. And let's go ahead and request this back in order by course title. Now the way we specify the ordering is with a string parameter, and it's actually the last parameter in this version of the query method. So we'll go to this very last parameter. And let's change that to courseInfoEntry. COLUMN_COURSE_TITLE. And by passing the column name for the value of that parameter, when we query the course_info table, the rows will be returned back in order by the course title. So let's go ahead and run it and see what our application looks like. So here we are in the emulator. You'll notice that the list of notes doesn't look any different. And that's because we haven't done any changes to the source of the notes. Let's go look at our list of courses now. And you'll notice now that the courses are displayed alphabetically by title. Android Async Programming and Services, Android Programming with Intents, Java Platform course, and the Java Language course. So that easily we're able to sort the list of courses by their title. Let's head back to our code. So here we are back in our source code. So now what if we wanted to display the courses in reverse order by title. In other words, sort them in descending order. Well, remember, we can do that by appending a space DESC after the column name. So now with that there, that indicates we want the values sorted in descending order. So let's go ahead and run our program again. So we're here in the emulator. Let's choose our list of courses. And notice now the courses are sorted in reverse order. We've got the Java Language course, Java Platform course, the Android Intents course, and the Android Async Programming and Services course. So let's head back to our source code and try sorting the notes now as well. So here we are back in our source code. And let's now look at ordering the query from the note_info table. And let's say in this case, we don't want to order by just one column. We want to order by two. We want our primary sort to be on the course that the note applies to. And then within that we want to sort the notes by their title. Now remember that even when dealing with multiple columns, we specify the ordering in a string. So what we need to do is concatenate some values together. Let's declare a local variable called noteOrderBy of type String. So the first thing we'll do is specify our primary sort column, which is the course ID. We'll then concatenate a comma on the end of that. And then we'll concatenate on the name of the second column we want to sort by, which will be our note title. And then what we need to do is take that noteOrderBy variable and pass it to the ordering parameter of our query statement. So we'll change that last null to noteOrderBy. So now that indicates when we query for the notes, we want the total list of notes sorted by the course that they apply to. And then within each course, we want to sort the titles. So let's go ahead and run this and see what it looks like. So here's our application running in the emulator. So if you look now at the way the notes are ordered, the first two notes both apply to the course Android Async Programming and Services. The first note has the title Long running operations. The second one is Service default threads. So that sorted correctly. We then look at the second two. They both apply to Android Programming with Intents. And then the titles of those are sorted alphabetically. The first one is Delegating intents. The second one is Dynamic intent resolution. Let's scroll down. We then have our two notes that apply to the Java Platform course, and the titles again are alphabetical, Compiler Options and then Serialization. And then, finally, we have our Java Language course notes, and those titles are alphabetical as well. So our application's off to a great start. We're now loading up our courses and our notes from the database. And in both cases, we're able to specify meaningful order of the information.

Summary
Here are some of the key things we want to remember from this module. Remember that it's the SQLiteDatabase's query method that enables us to request data from the database. Now that query method has a number of parameters in it. But there are really two fundamental parameters. Remember that we want to specify the table name that we want the data from, and we want to specify which columns we want returned from the query. Remember that we use a cursor to access the query results. And our cursor interaction with that result occurs row by row. So cursor positioning is an important concept. And we're responsible to explicitly manage the cursor positioning. And when that result is first returned, it's actually positioned before the first row. So no data values are accessible until we move the cursor to a row. The way we access the column values in the result is to use the Cursor. get methods. Remember, those are typed method so like getString and getInt and so forth. And when we access a column, we don't do it by name. We do it by the column's position. But we want to avoid hardcoding column positions. Instead, we want to use the cursor class's getColumnIndex method to translate a column name into its corresponding position. And when we're done with our cursor, we want to be sure to close it by using the cursor's close method so we don't leak system resources. And, finally, remember that when you issue a query, results are returned in no specific order. So if a particular order is important to you, you want to be sure to specify it. Now in the simplest form, we could simply pass in a column name. If we pass in a column name, the results will be ordered by the values in that column. We can order by multiple columns by simply separating the column names with a comma. And by default, each column's values are sorted ascendingly. But if you want them in descending order, you can simply follow the column name with a space DESC. So that wraps up this module. In our next module, we'll see how we can add selection criteria to our query method calls so that we can filter the rows returned in the result set.

Filtering SQL Queries
Introduction
Welcome to the Filtering SQLite Queries module of the Pluralsight course, Managing Android App Data with SQLite. My name is Jim Wilson. In this module, we continue our discussion of database queries. What we want to understand now is how to specify selection criteria so that only a subset of rows in the table are returned. So we'll start out with a high-level look at our application plan for this module. We'll see how to specify our row selection criteria. We'll then see how to pass a row selection criteria to the query method. And we'll finish up with a look at how to take advantage of row identity when activities need to communicate with one another.

Your App Plan
In this module, we'll be continuing our work of moving our app to use the database. Our focus in this module will be on note selection. So let's look at how our app works right now. So we know we have our DataManager, and one of the things in our DataManager is a list of notes. Earlier we created a database. Within that database, we have our note_info table, which contains our notes. So we now load the list in the DataManager from that database table. When we launch our NoteListActivity, it reads the notes from the list inside the DataManager and displays them within our RecyclerView. When a user selects one of those notes, we start our NoteActivity. And currently our NoteActivity then reads that note from the DataManager note list and then displays it. But what we want to do in this module is start decoupling our note activity from the list inside the DataManager. What we want to do now is we want to select some note within our NoteListActivity. We start up our NoteActivity. We want our NoteActivity to actually read that specific note from our note_info table and display that. Now in order to provide this feature, we have to understand how to get back a subset of rows from a table rather than getting back all the rows. So in our next clip, we'll see how we can do that.

Row Selection
Up until now whenever we query rows from a table, we've been getting back all the rows from that table. But oftentimes that's not what we want to do. Often we just want a subset of rows from a table. Now one way to do that would be to get all the rows back and write application code to only keep those rows we're interested in. But we don't want to do things that way. What we want to do instead is let the database do the work of filtering down the result to only those rows that we want. We can do that passing in a selection criteria to our query method calls. Now query conditions are pretty simple. they have three basic parts. They have a column name, something like course_id. They have an operator, something like an equal sign. Then they have a value. So in this case, we have the string android_intents. So our condition is course_id = the string android_intents. Now SQL has a pretty rich set of operators we can use on our selection criteria. Here are some of the most common. The first one is equality, And in SQLite a single equals or a double equals means the same thing, they're both equality. Then we have the inequality operators. You can do that with an exclamation point equals (! =) or a less than/greater than. They both mean the same thing, which is simply inequality. Then we have greater than, less than, greater than or equal to, less than or equal to, and another operator we'll look at more closely in a moment called LIKE. Now these are just the most common operators. As I mentioned, SQLite has a pretty rich set. So if you want to see the full set of operators, just check out the URL I have onscreen. The LIKE operator is a really powerful operator. It allows us to do string pattern matching. The best way to understand the LIKE operator is just to see some examples. So we might have something like this--note_title LIKE, then the string dynamic%. What this will do is return all the rows with a column note_title. It has a value that starts with the string dynamic. Technically what it says is I want to match against the string dynamic followed by 0 or more characters. That's what the percent sign means, 0 or more characters. So if we look at another example, note_title LIKE %intent%. And what this says is I want those rows in the column note_title containing the string intent preceded by 0 or more characters and followed by 0 or more characters. In other words, I want all those rows where the column note_title has a value that contains the string intent, and it doesn't matter where the string intent occurs in the value of the column note_title. Now we can also combine conditions. So we have things like the AND operator that allows us to combine two conditions. And the result of the AND is true only if both of those conditions are true. So if we have a condition course_id = the string android_intents, another condition note_title LIKE the string dynamic%, and we add them together, the only rows that'll be returned are those rows that have a course_id value equal to android_intents, as well as have a note_title value that starts with the string dynamic. In addition to the AND operator, we have an OR operator that combines two conditions. In this case, when we OR conditions together, the result is true when one condition is true or both of the conditions are true. If we take our same conditions, course_id = the string android-intents, note_title LIKE the string dynamic%, and we OR them together, in this case we'll get back those rows that have a course_id value that's equal to android_intents no matter what the note_title value is. Along with that, we'll get back those rows that have a note_title value that starts with dynamic no matter what the course_id column value is. And that result will include those rows that match both of the conditions. So now in our next clip, let's see how we can pass the selection criteria to our query method.

Row Selection Parameters
When we use selection criteria with the query method, we actually pass it in in two parts. Now the first part is selection clause. This identifies our column and our operator. But we don't provide an actual value here. Instead we use a question mark as a position holder for the value we want to compare against. And we pass in the values separately in a string array. And the way it works is that the first member of the array matches the first question mark in a selection clause, the second member of the array matches the second question mark, and so on. So let's see what this looks like. So we have a method here queryCourse. And the purpose of this method is return back a cursor that contains those rows from the course_info table that have a courseId value that matches the parameter that's been passed in. So, first, we're going to use our selection clause. So we'll declare our string variable. We'll set our clause to be course_id =?. So our clause says we want to compare against the course_id column and check that it's equal to some value. We pass in the value. We identify that value by declaring a string array and passing in that parameter courseId. So what happens now when we call the query method and we pass in selection and selectionArgs are parameters, query method will use the selection clause course_id =, and when it finds the question mark, it'll substitute the value in that courseId variable. Let's look at another example. We have a method here queryNote, and the purpose of this method is we return back a cursor that contains those rows from our note_info table. We have a courseId that matches our first parameter, and it has a title that begins with the value in our second parameter. So, again, we'll declare a variable for our selection clause. Now this is going to be a two-part comparison. So we put in our course_id =. We put the question mark and AND to connect them. And then we do note_title LIKE and another question mark. So we'll declare our selectionArgs variable as a string array. The first member of the array will be courseId, and the second member will be titleStart concatenated with a percent sign. So what will happen now when we call the query method, we pass in selection and selectionArgs, the selection criteria will be course_id = the value in that courseId variable. And then we'll AND that with the note_title LIKE, and we'll use the value of whatever's in titleStart with a percent sign. So the question that comes to mind is, Why are we doing it this way? Why don't we just build a single string clause where we concatenate column names and operators along with the values into that one string? And there're a few benefits to it, but there're really kind of two key ones. And far and away the most important benefit is that by passing the values separately from the clause protects against SQL attacks. So there's a certain type of SQL attack known as a SQL injection attack. And by passing the values separate from the actual clause protects against SQL injection attacks. Another important reason to pass the values separate from the actual clause is that in some cases, it helps with query performance. What happens is that as our tables and our queries get more complex, SQLite often has to do a great deal of work to even determine how to find the data you're looking for. By passing the selection clause separate from any specific values, that helps in many cases for SQLite when it sees the same clause repeated to reuse much of that work it did previously. So let's start putting selection criteria to work in our application. So in our next clip, we'll add the code that will allow us to select a specific note from the database into our NoteActivity.

Note Selection By Course and Title
Here we are in Android Studio, and we're looking at our NoteActivity's onCreate method. If we look here towards the bottom of the onCreate method, we see a call to a method called displayNote. DisplayNote is the method that's responsible for handling the details of displaying the values of a note within the activity. You see when we call displayNote, we pass in three parameters. And they're all member fields. The first one is a reference to a Spinner. The other two are references to EditTexts. So let's take a look at displayNote. So I'll go ahead and click on it. I'm going to go ahead and jump to its declaration by pressing Ctrl+B. Here we are in displayNote. We see we've received those three parameters, the one for the Spinner, the two for the EditTexts. And if we look here inside of displayNote, we see we get the values for the current note using a member field names mNote. And mNote is a reference to a note that's contained in our DataManager's note list. And what we want to do is change displayNote so that rather than using our note that comes from the DataManager's note list, we want to use a cursor that's positioned at a note that was returned back from our SQLite database. Now that, of course, means we're going to have query the database for a particular note. Now before we do that, let's think about how displayNote is currently implemented. So displayNote receives a reference to the Spinner and the EditTexts as parameters, but the values for those parameters were passed from member fields. So we could actually just use those member fields directly as opposed to receiving those parameters. And this is the sort of thing that happens a lot as an application evolves over time. Initially when we wrote displayNote, we needed to receive references to those views as parameters. But then later as time went on, we changed NoteActivity to hold references of views in member fields, but we never changed displayNote to use those member fields. So before we do the work to query the note from the database, let's go ahead and refactor displayNote to not need those parameters anymore. So let's go up here to displayNote. We'll right-click. We'll choose Refactor. Let's go over here to Change Signature. We'll choose that. You can see here in the Change Signature dialog, it lets me do things like change the method name, change its return type, and then modify its parameter list. In our case, we want to remove the parameters. You notice there's a little minus sign here that we can use to do that. And then what'll happen is that as we change the signature displayNote, Android Studio will take care of changing all the calls to displayNote as well. So let's get rid of the minus sign, click it once to get rid of the first parameter, get rid of the second, get rid of the third. Go ahead and say Refactor. So you can see now that the parameters are gone. Of course, once we did that, the code that uses the parameters is showing up in red. So what we need to do now is change those lines to use the member fields. And with that now displayNote displays the note values using the member fields directly. So now we need to go ahead and make the call to load a note from the database. But rather than doing it here in displayNote, let's go back up to onCreate and initiate the query from there. So here we are back in the onCreate method. You can see our call to displayNote there. And note that it no longer passes any parameters. So as we change the signature of displayNote, the calls to it were changed as well. So what we want to do now is rather than call displayNote, let's go ahead and change this to a call to a method we'll create called loadNoteData. Now, of course, loadNoteData doesn't exist yet. So we'll go to our lightbulb, say Create. We'll accept a void return type. And so now we're set to go. Now if we're going to query the database, we need of course to get a connection to the database, which requires our open helper class. So now remember that our open helper class should be created when our activity's first created and then closed when our activity's destroyed. So let's head back up to the onCreate method. So we're up here near the beginning of our onCreate method. We'll go ahead and create an instance of our open helper. And initially we'll assign it to a local variable. So let's go ahead and promote that local variable up to be a field. So do Ctrl+Alt+F. We'll accept the suggested name. And so now our open helper is stored in a field in our class. Now we need to override the onDestroy method, so we'll do a Ctrl+O. Let's use onDestroy. I'll hit Enter. And then it's the first line of onDestroy. We'll go ahead and close our open helper. So our open helper's all set. Let's go ahead and scroll back down to our method loadNoteData. So we're down here in loadNoteData. So let's go ahead and use our open helper to get a readable database, and we'll assign it to a local variable of type SQLiteDatabase. So now that we have our reference to SQLiteDatabase, we can do the query. But now before we do that query, we've got to specify our query criteria. So now initially here, let's assume that we always want to find the exact same note. Let's assume we want to go ahead and find the note that has the course ID, android_intents. So I'll assign it to a local variable. And in addition to having that course ID, we want to find the note that has a title that starts with the word dynamic. So we'll assign it to a local variable as well. So what we'll want to do then is go ahead and build a selection criteria that uses these two values. So let's start out by declaring a selection clause, so we'll declare a local variable here of type String. I'm going to name it selection. And when we build our selection clause, we'll of course need our column names. So the first column we want to use is the info_table's course_id column. So we'll use our database contract class, the NoteInfoEntry. Then we want the constant for the course_id column. So that gives us a constant for our course_id column. But let's go ahead and add an import for a NoteInfoEntry class so we don't have to keep qualifying it in the contract class. So we'll select that. We'll head over to our lightbulb, click on the lightbulb, and we'll choose Add import. So we have our column name there. Let's go ahead and concatenate onto the end of that a string that has the equals operator. Remember, we're going to use a question mark as a value placeholder. And let's go ahead and put an AND after that. So that takes care of the course_id column value. So now we need to add the part for the note_title. So we'll concatenate onto the end of here the end of the note_title column. And then we'll concatenate on a LIKE and a question mark. So that takes care of our selection clause. Now we just need our selection values. So we'll go ahead and declare a string array, and we'll name it selectionArgs. And since our selection clause has two question marks, we need to provide it with two values. The first value will be the courseId variable. The second value will be our titleStart variable. Then we'll go ahead and concatenate a percent sign on the end of titleStart so that the LIKE operator will find all the note_titles that start with the word dynamic. And so now with that, we have our selection criteria specified with our selection clause and our selection values. So in our next clip, let's use that selection criteria to query the database and display the corresponding note.

Display Note Selection
Here we are back in the Android Studio working on our NoteActivity class's loadNoteData method. Remember, in this method, we're going to query the Note_info table for a particular note. And we've already got the code in here to get a connection to our database. We've already provided our selection criteria. So now we're almost ready to do the actual query. So let's go ahead and declare our local variable called noteColumns of type String array. So now we'll list the individual columns. So it asks for the COURSE_ID, the NOTE_TITLE, and the NOTE_TEXT. So now we're ready to issue the actual query. Now, remember, our query returns back a cursor. So we'll declare a local variable noteCursor of type Cursor. Then we use our database connection and call the query method. We'll pass in the table name and a list of columns. So now we're ready to specify our selection criteria. So, first, we'll pass in our selection clause. We'll pass in our selection values. And we'll pass null for the remaining parameters. So now when the query method returns, we'll have the row from the note_info table that matches our selection criteria. Let's go and promote this cursor up to a member field. So I'll click on it. I'll do a Ctrl+Alt+F. And we'll go ahead and accept the default name. So now, remember, in order to access the column values in that cursor, we'll need the position of each of the columns. So we'll start with a local variable here, courseIdPos of type int. We use the cursor's getColumnIndex method to get the column position. Let's go ahead and promote that variable up to a field, do a Ctrl+Alt+F, accept the default name. So now let's get the positions of the NOTE_TITLE and the NOTE_TEXT. So now we have all the column positions. So we're almost ready to do the work to display the note. But, remember, when a cursor is returned, it's positioned before the first row in the result. So even if we expect a result to only have one row, we still have to explicitly move to that row. So let's go ahead and call the cursor's moveToNext method. So that'll position us to the first row in the result. So let's go ahead and call our displayNote method now. So now we've done all the work to query the database for a row that matches our criteria. We've gotten the column positions for the results, and we've even moved to the first row in the result. So we'll do the actual work of displaying that note in the displayNote method. So let's go ahead and jump to that method. So I'll click on it. I'll do a Ctrl+B. So here we are in displayNote. So now before we can display the values, we need to get the actual values from the cursor. So what we'll do here is, first of all, we'll get the value for the courseId. So we'll declare a local variable of type String named courseId. And then we'll call the cursor's getString method passing in the position of the courseId. So that gives us the value of the courseId. Let's do the same thing for noteTitle and noteText So with that, we have all the column values from our cursor. For noteTitle and noteText, we're actually ready to go ahead and display those values. So if we look here at the bottom of the displayNote method, we have those two calls to setText. Let's change them from using mNote to using our noteTitle and noteText local variables. So that takes care of displaying our noteTitle and our noteText. Now the courseId is actually a little different because remember that our course is actually displayed using a spinner. And for the time being, that spinner is still populated from the list in the DataManager. We'll change that a little bit later. But for now, we need to go ahead and cooperate with those lists. So what we'll want to do is go ahead and use the DataManager and ask it for the course that corresponds to our course ID. So notice we have a line here where we actually get the list of courses from the DataManager. Let's go ahead and add a blank line after that. We'll declare a local variable of type CourseInfo named course. And then we'll ask the DataManager for the course that corresponds to the courseId we read from the database. So now once we have that course back, we can simply ask the courses list for the index of that course. So instead of passing in mNote. getCourse, we'll simply pass in our course local variable. So with that, courseIndex will have the position in the spinner of the course that corresponds with the courseId we read from our database. So when we call mSpinnerCourses. setSelection, it'll select the appropriate course. So our code's all set now. So let's go ahead and run this and see what it looks like. Here we are with the program running in the emulator. So now when I click on one of these notes, it'll go ahead and try to display the note activity, which will cause our new code to run. Now I put breakpoints into our loadNoteData method and our displayNote method. So when we click on one of these, let's see what happens. As you can see, I hit one of the breakpoints. So let's switch back to Android Studio. So you can see we're about to call the query method. So let's go ahead and step. So we can see here that our call to query succeeded. Let me go up here to mNoteCursor and right-click on it. And what I'm going to do is choose from the menu here Evaluate Expression. And what Evaluate Expression lets me do is interactively view the state of values inside my program. So I've got a reference to my cursor there, so what I'm going to do is call its getCount method. And getCount will tell me how many rows are in that cursor. So I'll go ahead and hit Enter. And we can see the result is 1, which means that our cursor returned back one row, which implies that our filter actually worked. Let's go ahead and close this guy. So let's go ahead and release this and see what happens now. So here we are in displayNote, and you can see I've already assigned the three local variables from the column values in the cursor. If we look down here at our Variables window, we can see each of those got populated. The courseId is android_intents, the noteTitle is Dynamic intent resolution, so it starts with dynamic. We can see our noteText. So let's go and let this guy finish. We'll switch back to the emulator. And you can see here in the emulator that we're actually displaying the note correctly. So we've successfully added the code to query our database for a particular note and display it in our note activity. But at this point, we're actually hardcoding the selection criteria we've applied to the query method. What we really want to do is when the user chooses a particular note in our NoteListActivity, we want to query the database for the note that corresponds to that user's selection. In our next clip, we'll see how we can do that.

Passing Row Information Between Activities
Now as we've talked about, activities often share information. In fact, that's one of the main purposes of intent extras. When one activity sends an intent to start another activity, it passes in the information it wants to send to that activity in the intent extras. So what's the most effective way to use intent extras when our application is reading its data from tables inside of a SQLite database? Well that's where the unique row identifiers come in. Remember when we created each of our tables, each table had a special column whose name was based on the BaseColumns interface _ID constant. Now remember that we said that that column worked very closely with the way SQLite internally stores data. And it provided a very efficient way to find a particular row inside of a table. In addition to being a very efficient way to find a row in a table, remember that the value of the _ID column is unique for every row in a table. So basically it gives a particular row a definitive identity. So in the case where one activity wants to ask another activity to show the information that corresponds to a particular row in a table, all we have to do is pass the value of the _ID column, then that activity has a definitive way to look up that row from a table. So, of course, the question is, How do we take advantage of this row identifier in our app's note selection feature. In order to see how to do that, let's first take a closer look at how it currently works. Now remember that the way our app is currently implemented, we use this class NoteInfo. The NoteInfo has fields for the note title, the note text, and the associated course. We have our DataManager class. Our DataManager class consists of a list, and that list is instances of our NoteInfo class. And we load that list from our database. So now once we have all those notes in our list, we have our NoteListActivity. Remember that our NoteListActivity relies on an adapter. It's that adapter that takes the notes in the list and then feeds them into the RecyclerView on our NoteListActivity, which then displays the notes. Well when a user makes a selection of one of the notes in our RecyclerView, remember that there's an associated view holder. That view holder has a click handler. So when a user makes a selection, the click handler sends an intent. And currently that intent contains the position of that note. So when our note activity is started, it uses that position to find the note in the list and then displays that note. Well now looking at that note from the data, we need to make a few small changes. We'll start with our NoteInfo class. Well we can add just one field to NoteInfo, and that field would hold the ID. So now we're reading our notes from the table, we can now read and store each note's ID. So now once we have that ID, we can take our NoteListActivity, the adapter will still load it up, but now when a user makes a selection, and the view holder's click event handler handles that selection, when it fires the intent, rather than having the position in it, it will actually have the note's ID value. So with that, our note activity can then take that ID value, look up that specific note from our note_info table, and then display the value. So that allows our note activity to be decoupled from our DataManager's note list. And in our next clip, we'll start implementing this behavior.

Pass Selected Note ID
Here we are in Android Studio, and what we want to do now is change our application so that when a user selects a note from the NoteListActivity, we pass the ID of that note to the NoteActivity so the NoteActivity can then look the note up in the database. Now, of course, in order to do that, we need to include the value of the ID column with our notes. So I've made a few small changes to our DataManager class that will allow us to do that. So in our DataManager class here, we're looking at the loadFromDatabase method. Remember, the purpose of the loadFromDatabase method is to read our courses from our course_info table, put that into a list in the DataManager, then read our notes from the note_info table, put that into a list in the DataManager. You'll see before we actually show the query against the note_info table, we've got our list of columns there. And I've modified that list to now include the _ID column along with the NOTE_TITLE, NOTE_TEXT, and COURSE_ID. So by doing that, when our query method returns, the cursor that's returned will include the ID column. So you'll notice what we'll do now is when that cursor's returned, we'll pass it into a method called loadNotesFromDatabase. Let's scroll down to that method. So we're here in the loadNotesFromDatabase method. Since our cursor includes the _ID column, we want to make sure we get the position of that column. So you can see we do that there. And then once we have the position of the column, if we go down to our while loop, notice that along with getting the values for the noteTitle, noteText, and courseId, we now get the value for the ID column. And once we have that ID value, we want to go ahead and store it with the note. So you notice here when we create our NoteInfo instance, it'll now pass the ID value to its constructor. And what I did there was I simply added an ID field to the NoteInfo class and a constructor that allows us to pass it in. So what happens now is we go through this while loop as we store the information for each note in an instance of our NoteInfo class, we just include the ID value with it. So what that means is that each instance of our NoteInfo class now contains the ID value of the corresponding note in our note_info table in the database. Let's head over to our NoteRecyclerAdapter class to see how we can use the ID value when the user makes a selection. So here in our NoteRecyclerAdapter class, remember that there's a nested class that's a ViewHolder. Remember that ViewHolder holds the information corresponding to the views that are currently displayed in a RecyclerView. And within that ViewHolder, we have a click listener. And as you can see there, when a user taps on a particular view, the click listener method runs. And inside there, we created an intent, and then we put an extra in that intent. And currently that extra is a NOTE_POSITION that will then get passed to our NoteActivity. What we want to do now is change that to the ID. So the first thing we'll do here is change this field mCurrentPosition to be mId. So what I'll do is just go ahead and put my cursor on it, do a Shift+F6. That'll allow me to rename it. Let's rename it mId. We'll hit Enter. And so with that now, that mId field will be passed with the extra that's part of our intent. But, of course, simply changing the name of the field doesn't change the value that's in it. But now if we look towards the top of the screen, we see a method onBindViewHolder. And onBindViewHolder is part of our recycler adapter, and it's responsible to set the values within the view holder. So if we look at it, we see we receive a position of the note that's currently being displayed. We use that position value to get a reference to the corresponding note. We then set the course title and the note title. What we want to do now is where we actually have our holder. mId, instead of assigning that a position, we want to assign it the result of note. getId. So now our mId field will have the ID of the note that's currently being displayed. So when a user selects it, our setOnClickListener will now pass that ID as part of the intent that it's sending to our NoteActivity. So in our next clip, let's see how we can change our NoteActivity to use that ID to read the note back from the database.

Display Note By ID
Here we are back in Android Studio. We're looking at our NoteActivity class. Now we've already done the work in NoteRecyclerAdapter to pass the ID that corresponds to the note to the user selected from our NoteListActivity. So what we want to do now is have our NoteActivity use that ID value to look up the note from the database and display it. So we're looking at our NoteActivity's OnCreate method, and our onCreate method calls this method readDisplayStateValues. And as you may recall, readDisplayStateValues handles the details of extracting the value from the intent and doing any associated initialization. So let's take a look at that guy. So here we are in readDisplayStateValues. You can see the first thing it does is get the intent. And then it gets the extras it was passed with the intent. Now currently the value of that extra has been placed in a field called mNotePosition. But we know that that's no longer a position. It's actually an ID. So the first thing we'll do is change that field name to mNoteId. Let's go and change the names of our constants as well. Let's change the constant NOTE_POSITION to be NOTE_ID and POSITION_NOT_SET to ID_NOT_SET. So now we have everything named appropriately, and we have the value of the past ID in our field mNoteId. And you'll notice just below where we get the extra, we have a test to see if it's a new note. And all that code will continue to work just fine because when we create a new note, we won't be passing an ID. But let's look at the last line of readDisplayStateValues. Now this line gets the current note from the list. But since we're now reading the note from our database, we don't need that any longer. So let's go ahead and comment that guy out. So we're all set here in readDisplayStateValues. Let's head up to the code where we actually get the note from the database. So here we are in the method loadNoteData. Now as you recall, loadNoteData handles all the details of looking at a note that matches our specified selection criteria. Now currently our selection criteria consists of hardcoded values for the note's course ID and the start of the note's title. To locate a note using the ID value, all we need to do is change the selection criteria. So let's first look at our selection clause. So we'll change our selection clause to no longer use the COURSE_ID and NOTE_TITLE but instead just use the _ID column. And our selectionArgs will contain the ID value, which is in our field mNoteId. So you see there that mNoteId is underlined in red. And the issue is that mNoteId is an integer and selectionArgs is a string array. So we use Integer. toString to change the value of mNoteId to a string. And that's all the changes we need to make to NoteActivity. The NoteActivity will now display whatever note corresponds to the ID value that's passed to it. But now before we test everything out, there's a little bit of housekeeping that we should address. Let's head over to the menu resource for a NoteActivity. Here we are in the menu resource for a NoteActivity. And you remember that our menu has a Next option which allowed the user to move to the next note in the list. As we currently have our NoteActivity implemented, we don't actually support that feature. So why don't we just go ahead and set its visibility to False. So I've got Next selected. So now if I go to the visible property, notice that it's actually a dash. And when I click on it, it's switched to a check, and my Next menu option is still visible. And that may seem confusing. The issue is that that visible property defaults to True. So when I click on it, I give it an explicit value of True. So basically it remains visible. So if I want to actually make it not visible, I've got to click on that property again. So now the visible property is explicitly set to False, and the menu option won't be visible. So let's go and run our program and see if everything works as we expect. So here we are with our program running in emulator. Now we've already verified that the code to read a note from the database and display within NoteActivity works fine. What we want to verify now is that when we select a note in the NoteListActivity that the correct note is displayed in our NoteActivity. So we're looking here at our first note, which is associated with the course Android Async Programming and Services, and it has the title Long running operations. So let's go ahead and select that guy. And we can see our NoteActivity displays the correct note. It's part of Android Async Programming and Services, and it has the title Long running operations. So let's go ahead and go back to our NoteListActivity. So let's go ahead and select a third note in the list. So that's associated with the course Android Programming with Intents, and its title is Delegating intents. We select that one, and we see that it's the correct course and the correct title. So now our NoteActivity is able to correctly display whatever note corresponds to the note the user selected in the NoteListActivity. So that's another big step forward in converting our application to use data that's contained in a database.

Summary
To wrap up, here're some of the key things you need to remember from this module. Remember that in most cases, our selection is composed of three parts. We have the name of the column we want to use in our selection condition, an operator that indicates the comparison we want to use, and then the value we want to compare against. Remember, though, these selections can be combined. So we have the AND operator. So in the case of the AND operator, both of the selection conditions need to be true for the AND condition to be true. We have the OR operator, which is true when one or both of the conditions are true. Remember that SQLite supports most of the condition operators you would expect. So we have things for equality and inequality, we have things like greater than, less than, greater than or equal to, less than or equal to. Remember, we also have the LIKE operator, which allows us to do partial string matching. Remember that when we pass a selection to our query method, we do it in two parts. We have the selection clause, which generally has the column name and the operator but no values. For the values, we use the question marks as placeholders. We pass the actual values in a separate string array, and the values in the string array match the question marks in order. So the first value in the string array matches the first question mark. The second value in the string array matches the second question mark, and so forth. And remember to utilize each row's unique identifier. Remember, that's the column whose name is based on the _ID column in the BaseColumns interface. That column provides the most efficient way to find a row, but also it provides each row with a definitive identity. Remember, the value of that column is unique for each row in a given table. So it's a great way for one activity to indicate to another activity which row to use. That wraps up this module. In our next module, we'll see how we can use adapters to simplify the process of populating things like spinners and RecyclerViews with data from our database.

Connecting SQLite Data to Views with Adapters
Introduction
Welcome to the Using Adapter to Populate Views with SQLite Data module of the Pluralsight course, Managing Android App Data with SQLite. My name is Jim Wilson. Populating views like spinners, ListViews, and RecyclerViews all rely on our adapter classes. In this module, we'll see how to use adapter classes to populate these types of views with cursor-based data return from a database. We'll start out with an initial look at our application plan for this module. We'll then take a look at the CursorAdapter class and its role in populating things like ListViews and spinners. We'll then see how the SimpleCursorAdapter class simplifies the most common scenarios of populating things like ListViews and spinners. We'll then get into our application code and use a SimpleCursorAdapter to populate the course selection spinner on our NoteActivity. We'll then see what's involved with using a cursor with the RecyclerView. Adapter. We'll wrap up by changing our application to populate the MainActivity RecyclerView with notes queried directly from the database.

Your Plan for Populating Course Spinner
We're in the process of converting our application to fully utilize the SQLite database that we created earlier. Now in the last module, we'd gone a long way towards our NoteActivity being able to display the data directly from the database. So as we read a note from our note_info table, we were able to directly display the text for that note. We were able to directly display the title for that note. But remember when it came to displaying the course associated with it, we ran into a bit of an issue. Now we were able to read the course ID for the note directly from the note_info table, but we still had to cooperate with the DataManager and its Courses list. Remember, the reason we had to do that is because our list of courses is displayed in a spinner. And a spinner has to be populated with a list of choices. Now we populate that spinner with an adapter. And currently we're using an arrayAdapter. It's that arrayAdapter that takes care of reading the data stored in the list of our DataManager and translating that into the display needs of the spinner. But if we think about it, that list of courses in our DataManager is really just an intermediary. We're actually populating that from the course_info table in our database. And we do that using a cursor. What we want to do now is get rid of that intermediary. So we want to use a different kind of adapter. There's an adapter called a CursorAdapter. And it's able to read data off of the cursor and then translate it into the display needs of views like the spinner. So in our next clip, we'll start looking at CursorAdapters and see how we can use them.

CursorAdapter and SimpleCursorAdapter
The CursorAdapter provides us with the ability to take data from a cursor and populate views like a spinner or a ListView. Now the CursorAdapter takes care of managing the cursor interaction and provides methods that will allow us to create the views that we need, as well as bind the data from the cursor into those views. Now, of course, one of the key things we need to do with a CursorAdapter is associate a cursor with it. So we can do that with a CursorAdapter constructor, or we can use a method called changeCursor. And changeCursor is a method we tend to use a lot because, of course, it allows us to associate a new cursor with the CursorAdapter, but it also does some housekeeping for us. So, for example, if we call changeCursor passing in a new cursor and there is already a cursor associated with the CursorAdapter, the changeCursor method will take care of closing that previous cursor for us. And, in fact, we can use the changeCursor method even when we're done with the CursorAdapter. If we call changeCursor passing in null, it'll take care of closing that existing cursor associated with the CursorAdapter even though we're not passing a new cursor in. So let's take a closer look at what's involved in populating our spinner. So we have a table from our database, and we want to populate the spinner. But remember the spinner has two appearances. It has one appearance when it's showing the currently selected item. It has another appearance when it's showing the user a list of options they can choose from. So the CursorAdapter's going to bring these guys together. So, of course, we have the cursor that's going to read the data from the source table. But then we also have the display issues, so we're going to need a layout resource to identify the appearance of items in the spinner when we're showing the currently selected item. But we also need a layout resource to identify the appearance of the items that show up in the selection list. Also since we're pulling our data from a table in our cursor, we have the issue of the columns that are coming in. So we'll also have to identify which columns from the cursor we want to use to populate the display values in the spinner. Now one of the really cool things about the CursorAdapter is that it's extremely flexible. But part of it being very flexible is that it leaves some work for us to do because we're responsible to handle the display details. So we're responsible to create any view instances that we need, and we're responsible to populate these views with the data from the cursor. Now the good news is in most scenarios, we don't have to get into all those details because of another class SimpleCursorAdapter. Now it extends CursorAdapter, and it leverages that same cursor management that's provided by CursorAdapter, but it provides default display handling. And this default handling works for most common scenarios. So basically all we have to do is provide basic display information, things like which display resources we want to use, and then a mapping of the columns from our cursor into specific view IDs. And then SimpleCursorAdapter will take care of the details. So using a SimpleCursorAdapter, we can change our NoteActivity to populate the spinner showing a list of courses directly from our database. And that's what we'll do in our next clip.

Populating a Spinner with a SimpleCursorAdapter
Here we are back in Android Studio. We're looking at our NoteActivity classes onCreate method. What we want to do now is change the way we populate the spinner that shows the available courses. Now currently it's populated from the DataManager course list using an arrayAdapter. We now want to populate this spinner directly from the CourseInfo database table using a SimpleCursorAdapter. So if you look here at the code we're currently using to populate the spinner, the first thing we do is get the list from our DataManager. We then create an arrayAdapter, associate the resource we want to use for the drop-down view, and then associate that arrayAdapter with the spinner. Switching over to use our SimpleCursorAdapter won't look that much different. But one thing we won't need is a list of courses form the DataManager. So let's go ahead and get rid of that line. So now the next thing we'll do is change our adapterCourses variable from being an arrayAdapter to a SimpleCursorAdapter. So now we also want to make sure that we change the constructor from an arrayAdapter constructor to a SimpleCursorAdapter constructor. So now if we look at the constructor arguments, the first one 'this' is being passed for the context. We still need that in our SimpleCursorAdapter. The second one, android. R. layout. simple_spinner_item, that's a layout resource we want to use for the currently selected item. We still want that constructor argument as well. But now the courses, that was the list of courses from the DataManager. And we don't use that anymore, but we would need a cursor. But we haven't gotten our cursor yet. So let's go ahead and pass null for that one. Now we need to provide the names of the columns and the cursor I'm going to pull data from. And we do that with a String array. So let's go ahead and create a new String array. So in our case, the only thing we need to display is the course title. So we'll pass in the name of that column using our NoteKeeperDatabaseContract class. So now that we have the name of the columns, the next thing we need to provide is the IDs of the views we want to set. So now in our case, we're using one of the built-in layout resources, which is SimpleSpinnerItem. And in the case of built-in resources, they tend to follow a standard naming, so if there's a text view in it, its ID is normally android. R. id. text1. If there were two text views, one would be named text1. The other would be text2. So we'll go ahead and pass in a new integer array that contains android. R. id. text1. So what this is saying is I want to set the view whose ID is android. R. id. text1 with the values that come from the column whose name is NoteKeeperDatabaseContract. CourseInfoEntry. COLUMN_COURSE_TITLE. Now if you weren't sure what the ID of the view was coming from this resource, what we could do is get rid of the resource, let's go ahead and right-click on it, choose Go To, and then Declaration. Now currently we're looking at the design view for that resource. Let's switch to the text view. I'm going to go ahead and scroll down here. So we can see here that this resource contains a single text view, and the ID comes from the Android framework, and it's text1. So if we switch back to our NoteActivity class, it shows that our ID value of android. R. id. text1 is the correct value. Now one more thing we want to note, you notice that our SimpleCursorAdapter constructor has a line through it. And that tells us that we're using a deprecated constructor. What we want to do for this one is provide one more parameter to the constructor, which is the flag's value. Now there're no specific flags we want to set, so we'll go ahead and pass in a 0 for that last parameter. And that way, we're now using a currently supported constructor. So now what this is saying is that we're creating a SimpleCursorAdapter. The currently selected item will display using one of the Android layout resources named simple_spinner_item. We're taking the values from our cursor's course_title column. I'm going to take those values and display them in the view whose ID is android. R. id. text1. Now, remember, when we're using a spinner, we also need to provide a layout resource for the way items appear in the selection list. So you see we use that same method we were using with the arrayAdapter, and we're using that same layout resource, simple_spinner_dropdown_item. And then we associate the adapter with the spinner the same way we do with the arrayAdapter. We simply call mSpinnerCourses. setAdapter and pass in our adapter. So that takes care of setting up our SimpleCursorAdapter. Now a couple of things we want to go ahead and do here. The first thing we'll do is go up to our NoteKeeperDatabaseContract. CourseInfoEntry class. Let's go ahead and click on that. Then let's click on our lightbulb. And we'll go ahead and add the import so that way we don't have to qualify that by NoteKeeperDatabaseContract anymore. Now let's go up to our adapterCourses variable, and let's do a Ctrl+Alt+F to promote that to a field. And we'll accept the default name. So now our SimpleCursorAdapter is a field within our NoteActivity class. So with our SimpleCursorAdapter all set to go, we'll now need to associate data with it, and we'll see how to do that in our next clip.

Connecting a Cursor to the SimpleCursorAdapter
Here we are back in Android Studio, and as you recall, we just set up a SimpleCursorAdapter to populate our course selection spinner with a list of courses contained in the cursor. What we have to do now is actually go out and get that cursor and load it up with the courses from our database. So let's do that with a method we'll create called loadCourseData. So now we're calling our loadCourseData directly from our onCreate method, which means we're going to be loading data from the database as part of our MainActivity flow. As I've mentioned before, we generally don't want to load up database data as part of the MainActivity flow. There's a particular way we want to handle it. Now we haven't got into those details yet, but we'll see how to do that a little bit later in this course. For now, we'll just go ahead and load them up directly here from onCreate. So let's go ahead and create our loadCourseData method. So I'll click on the lightbulb, choose Create method. We'll accept the return type. So now if we're going to be getting data out of the database, the first thing we need is the connection to the database, so we'll call getReadableDatabase on our mDbOpenHelper. So now the next thing we need if we're going to do a query is a list of columns. So let's go ahead and create a String array called courseColumns. So, of course, one of the main columns we'll need is actually the course titles because that's what we display. But remember how we actually save notes. When we create a note, we actually save not the course title but the course ID, so we'll need that as well. Now that might seem like all we need, but we also need one more column. We also need our _id column. Remember now that the _id column uniquely identifies each row in a table, and the CursorAdapter actually rely on that column to work correctly with the data coming back in a cursor from our database table. So now we're ready to query the database. So the first thing we'll need is a cursor, so let's declare a local variable of type Cursor named cursor. Let's go ahead and call our query method now passing in the table name and our columns. So now we want all the rows back from the table. So we'll just pass null for our two selection criteria arguments. Pass null for the next two arguments. Now our last parameter here affects the order that the data's returned back from the database. And, remember, by default the database can give you back the rows in any order it wants to. Now from a usability standpoint, it'd probably make sense to show the user the list of courses in alphabetical order by title. So let's go ahead and pass the course title as our ordering column. So now with that, the data returned back into our cursor will be all the rows from our course_info table in order by course title. So all we need to do now is go ahead and associate that cursor with our adapter. So remember that the mAdapterCourses field holds a reference to our SimpleCursorAdapter. So we'll call changeCursor on that field. And then we'll pass in our cursor. And now with that, our spinner will be populated with all the rows from our course_info table in order by course title. So let's go ahead and run this guy and see what it looks like. Here we are with the program running inside the emulator. Let's go ahead and click the button to create a new note. Let's go up to our spinner, and let's go ahead and expand that. And you can see now that our spinner contains our list of courses. And notice that they're in alphabetical order. Very first is Android Async Programming, the Android Programming with Intents, the Java Fundamentals: The Core Platform, then Java Fundamentals: The Java Language. So now we're able to populate our spinner with the contents of our course_info table, and we're doing it in alphabetical order by title. So loading up our spinner is working correctly. Let's go back to our main screen. So we're here back in our main screen. And let's choose one of our notes. So the first note here says Android Async Programming and Services. Let's click on that guy. You notice now that when we select a note, the course that's displayed is incorrect. Instead of showing the Android Async Programming course, it's showing a Java Fundamentals: The Java Language course. And that's because our logic to select current course is not correct. Remember that we're now loading the spinner from the database, but our logic to select the current course for a note relies on the course list that's inside the DataManager. So we need to change our logic so that we select the course for a note using the cursor that populated the spinner, not the course list that's in the DataManager. So in our next clip, let's see how to do that.

Selecting an Item in a SimpleCursorAdapter Populated Spinner
Here we are back in the Android Studio, and we're looking at our NoteActivity class's displayNote method. Remember, this is the method responsible for displaying the values for the currently selected note. What we want to do now is fix the code that's used to select the correct course in our spinner. The way we select something in a spinner is with its index. If we look at the code we have here now, it relies heavily on the DataManager where we actually get the list of courses from the DataManager. We then ask the DataManager which course and its list corresponds to the course ID we just wrote for the note. We then get the index of that course, and that's the index we use to set the spinner. What we want to do now is set the spinner's index based on the cursor that's being used to populate the spinner. So the first thing we'll do is get rid of these two lines here that interact with the DataManager because we don't need those anymore. So now with those gone, we want to go ahead and get the index that corresponds to the course in our cursor. And let's do that with a method we'll create called getIndexOfCourseId. And when we call this method, we want to pass in the ID of the course that was read for this note from the database. So we'll pass courseId as the parameter. Now let's go ahead and create the method, so we'll click on the lightbulb, say Create. We'll accept the return type as an int. We'll accept the parameter type and the parameter name. Now remember that our spinner is now being populated with a cursor. So what we want to do now is figure out which row in that cursor is the right row for the course that's associated with the current note. So the first thing we want to do is get a reference to the cursor that's being used to populate the spinner. So let's go ahead and declare a local variable here of type Cursor named cursor. Remember that cursor was then associated with an adapter, and that's what's populating the spinner. So we'll simply ask that adapter for its cursor. So our field mAdapterCourses is the adapter that's populating the spinner with the courses from our database table. Once we have a reference to that cursor, we can then use the cursor to figure out which row is the correct row for the current course. So, remember, we read the note from the database, we got the course ID of the course that the note is associated with. So what we need to do is figure out which column in this cursor is the column holding the course ID. So what we'll do is have a local variable here of type int. We'll call courseIdPos, and then we'll call the cursor's getColumnIndex method passing in the course ID column name. So now what that'll do is courseIdPos will be the index of the column that holds the value of the course ID. So that's the column index. Remember, our goal is ultimately to get the row index of the course that corresponds to the course in the note. So let's declare a local variable here of type int called courseRowIndex, and we'll set it to 0. And now what we want to do is walk through the cursor row by row trying to find the course we're looking for. So let's go ahead and declare a local variable here of type Boolean, and we'll name it more. And then what we want to do is start processing the rows one at a time starting at the beginning. And because this cursor was already used to populate the spinner, we don't know where the cursor is currently positioned. So we'll call cursor. moveToFirst to assure that it's at the first row. So when moveToFirst returns, we know our cursor is positioned at the first row. So what we want to do now is do a while loop, and the while loop will run as long as more is true. So the first thing we want to do in this while loop is get the course ID value for the current row. So let's create a local variable here of type String. We'll call it cursorCourseId. And then we use the cursor's getString method to get the value of the course ID column. So what that will do the first pass through our loop is give us the course ID value of the first row in the cursor. So we want to find out if that's the course ID we're looking for. So let's put an if statement in place to see if the cursorCourseId value is equal to our courseId parameter. So if our if statement is true, that means we found the row we're looking for. So let's go ahead and call break and break out of our loop. But if it's not true, we need to keep walking through our cursor. So let's go ahead and increase the courseRowIndex value. So we'll increase the row index by 1, and then we'll say more = cursor. moveToNext. So what this does for us is initialize a courseRowIndex 0. We check to see if the first row is a course we're looking for. If it's not, we increase the courseRowIndex by 1. We move to the next row, repeat our loop, and see if it's the course we're looking for. And we keep that up until we find the course that we're looking for. Once we find the course we're looking for, we can go ahead and just return back that courseRowIndex. So what this does now is give us the index value of the row in the course cursor that corresponds to the course for the current note. So that value gets returned back to displayNote. So let's scroll up here just a little bit. So we're back here in displayNote. So we get back that index of that row, and then we use that index to set the selection in our spinner. So that way our spinner will correctly show the course that corresponds to the current note. We're doing all this work with just the database. So let's go ahead and run this guy and see what it looks like. So here we are with our code running in the emulator. Let's go ahead and select one of the notes. I'll select a note whose course is Android Programming with Intents. Now I've put a breakpoint inside of our getIndexOfCourseId method so we can see how everything works. So I'll select the note. You can see that the code has stopped back in Android Studio, so let's switch to Android Studio. So here we are in Android Studio. And if you look at our Variables window here, you see that the course ID that was passed in is android_intents. So that's the course ID that corresponds to our note. Notice that our rowIndexValue is 0, meaning that were on the very first row in the cursor. Let's go ahead and step. So we'll step once, and then we'll go ahead and step again. And that gives us the course ID that's in the cursor. So that's android_async. So that's not the one we're looking for. So we'll go ahead and step. We'll step again. So that increases our row index from 0 to 1. We call moveToNext to get the next row on the cursor. We loop back around, go back into our loop. We now get the course ID for that second row in the cursor. We'll step. So that's android_intents. So now when we do our if statement, it matches. It breaks us out of the loop, and then we'll go ahead and return back that row index. And then we'll use that row index to select the course in the spinner. So let's go ahead and release this and see what it looks like in the emulator. So here we are back in the emulator, and you can see Android Programming with Intents is selected. So it selected the correct course for the current note. So you can see now our NoteActivity is working directly with the database now to not only get the note but even to select the correct course in the spinner. So our application is continuing to evolve to use the database more and more directly relying on that DataManager less and less. So in our next clip, let's see what's involved in changing our RecyclerView to start working directly with the database.

Using a Cursor with RecyclerView Adapter
Let's take an overall look now at the way our application handles display notes. We still have our DataManager and that notes list that it contains. And that notes list, of course, is populated from our database. And when we look at our MainActivity, which contains a RecyclerView, it relies on an adapter class that we've created. And that adapter class reads data from the list, passes it to the RecyclerView, which then displays the notes from the list. Now remember that within a RecyclerView, we have that ViewHolder class. And a ViewHolder class holds references to the views required to display an individual note. So references to things like our text views, which display our course title or our note title. Now a ViewHolder is also responsible to handle interactions. So if a user selects one of the items inside of our RecyclerView, it's the ViewHolder that has the click event handler that will then send an intent passing in the ID of the selected note to our NoteActivity. Now our NoteActivity is able to use that ID value to read the note from the database, and it displays that note directly from the database. And not only does it display the note itself directly from the database, but with the changes we just made, it also populates the spinner showing a list of courses we can select directly from the data. So our NoteActivity is converted now to interact directly with the database. But now what about our MainActivity? How do we make it so that the RecyclerView on our MainActivity showing notes can do that without needing the DataManager or that list of notes? How do we change it so that we can actually take the notes directly from our database and display them in the RecyclerView? It turns out, we still use the RecyclerView. Adapter class. So that adapter class we've already written that displays the data from the list in the DataManager is the same class that we're going to use to display the notes directly from the database. Unlike the spinner where we had one kind of adapter for displaying information in a list or an array and a different kind of adapter for displaying from a cursor, when we're working with RecyclerView, we're going to continue to use our RecyclerView. Adapter class. So, of course, the question becomes, Well, how do we do that? Well let's look at the job of the RecyclerView. Adapter class. So now one issue is, of course, the data source. Our data source is going to change. We're now going to use a cursor as our data source rather than a list. So we want to be able to associate the cursor with our adapter so we'll allow a cursor to be passed in as a constructor to the adapter. But remember when we used the SimpleCursorAdapter to populate our spinner, we could associate a cursor when we constructed it, or we could use the changeCursor method to change the cursor associated with our adapter. Why don't we do that same thing here with the RecyclerView? So we'll have a method that allows changing the cursor that's associated with our RecyclerView. Adapter. Another key task of the RecyclerView. Adapter is view management. Remember that we use our ViewHolder class. We create instances of the ViewHolder class, and then the RecyclerView manages those as a pool. And as the user scrolls through the RecyclerView, the individual ViewHolder instances are recycled. And the role of each ViewHolder instance is pretty straightforward. It holds references to the contained views. As I mentioned, references are things like the text views used to display the course title or the note title. And it handles the view interaction with a click event handler, so when the user selects a note, we go ahead and show our NoteActivity. Well whether our data is coming from a list or coming from a cursor, these jobs don't change. Each note will still have the same appearance to the user within a RecyclerView, and when a user selects the individual note within a RecyclerView, the application will still do the same thing--show the NoteActivity. So there're no changes at all that we need to make in our adapter with regard to view management. But now we will need to deal with the way the data is displayed within those views because now remember that when the RecyclerView is interacting with our adapter, it will indicate to us position of the data it wants displayed. So our cursor will have to move to a specific position. When we get to that position, we'll of course have to get the values for the columns in the cursor. And then we'll use those values to set the display values within our ViewHolder. So our process of converting our RecyclerView. Adapter to work with the cursor is really going to be focused on the idea of managing the cursor and then the way we actually display the data from the cursor. So in our next clip, we'll start the process of changing our application's RecyclerView. Adapter to display the note data directly from the database.

RecyclerView Adapter Cursor Management
Here we are in Android Studio, and we're looking at our NoteRecyclerAdapter class. And what we'll want to do now is change our adapter so that it displays note information returned directly from our database rather than using the list of notes from our DataManager. So let's start here looking at our field declarations. You'll notice that we have a field for the context, the field that holds the list of notes, and a field for the layout inflator. Now we want to keep our context and our layout inflator, but we don't need the notes anymore. So let's go ahead and get rid of this line. And let's go ahead and replace it with a field that's a cursor. We'll just call it mCursor. So that gives us our mCursor field. So we're going to go ahead and need to set this field. So let's take a look here at our constructor. Now currently our constructor's second argument is that list of notes. So let's change that to be a cursor. So our constructor accepts a cursor. So now we want to go ahead and assign that cursor to a field. So we have the line there where we used to assign the notes list to a field. We'll assign the cursor right there. So now we have our cursor. But, of course, to get the values from our cursor, we need the positions of the columns we're interested in. So let's go ahead and add a line here to the end of our constructor, and we'll call a method we'll create, and we'll call it populateColumnPositions. Now, of course, that method doesn't exist yet. So let's just do an Alt+Enter, say Create method. We'll accept the return type, and now we're set to go. Now remember when we were working with the SimpleCursorAdapter, it allowed us to initialize the adapter even before we had the cursor. In other words, we could actually set it up even though the cursor started out as null. So we want to go ahead and follow that same pattern. So the first thing we'll check here in our populateColumnPositions method is whether the cursor's null. And if the cursor is null, we'll just go ahead and return. But now if the cursor's not null, we'll use that cursor to actually index the columns we're interested in. Now we'll add the details for that a little bit later. For now, we'll just go ahead and add a comment as a placeholder. Before we get into the details of accessing the columns in our cursor, let's go ahead and finish the work related to setting up the cursor in our adapter. Now, remember, we worked with the SimpleCursorAdapter. In addition to being able to pass in a cursor in a constructor, there was also that changeCursor method that allowed us to change over to a new cursor, and it also took care of closing any existing cursor that was associated with the adapter. So why don't we do that same sort of thing in our RecyclerView. Adapter. So let's go here after our populateColumnPositions method. Let's go ahead and add in a new method. And let's call it changeCursor. And we'll accept the cursor as a parameter. So what do we want to do in this method? Well the first thing we want to do is check and see if we have an existing cursor. And if we do have an existing cursor, we want to go ahead and close it. Once we close that cursor, we'll go ahead and assign the cursor we received to our cursor field. Now this new cursor that's coming in may not have the columns in the same order that our old cursor did. So we're going to go ahead and call our method populateColumnPositions. And then once we've called populateColumnPositions, we want to notify our RecyclerView that the data has changed. So we'll call our base class method notifyDataSetChanged. And with that, we now have the ability to set or change the cursor in our recycler adapter. So the next thing we want to look at is how we actually display the data coming back from the cursor. We'll see how to do that in our next clip.

Displaying Cursor Data with a RecyclerView Adapter
Here we are back in Android Studio, and we're continuing our work on our NoteRecyclerAdapter class. Now we've already modified the class to accept and manage a cursor. Now we want to start adding the code to display the actual node values from the cursor. Now remember that the cursor we receive is coming directly from our note_info table. I want to use the values we have available to that table to populate the views in our adapter. Now when we display a note in our RecyclerView, one of the things we display is the course information. Now up until now, we've been displaying the course title. But we know our notify table doesn't have a course title. It only has a course ID. So let's go ahead and use that for now. We'll see a little bit later in the course how we can actually show the title. But for now the ID will be good enough. So let's declare a local variable here of type int. And we'll call it coursePos. So we'll use our mCursor field's getColumnIndex method. And then we'll pass in our course ID as column name using the NoteInfoEntry class from the NoteKeeperDatabaseContract class. So we've got the fully qualified name of the constant for our column name there. I've got my cursor in the NoteInfoEntry class. So I'm going to do an Alt+Enter. Let's go ahead and add an import for our NoteInfoEntry class. Let's go ahead and promote our coursePos variable up to a field as well. So we're all set there. So let's do the same thing to get the position of the note title column. And we'll put that to a field we'll call mNoteTitlePos. So that takes care of the columns that we actually display, the course information, and the note title. Remember, there's one more column we need. Remember that when a user selects a note in a RecyclerView, we pass the ID to our NoteActivity to actually display the details for that note. So we'll also need to get the position of the _ID column as well. So with that, now we have the indexes of all the columns that we need. Now we're ready to start displaying the actual data. So let's scroll down to our onBindViewHolder method. So here's our onBindViewHolder method. Remember, the purpose of this method is to display the data at a specific position. So we receive that position as a parameter. So the first thing we want to do is move our cursor to the correct row. So we'll use the cursor's moveToPosition method and pass in the position. So with that, our cursor will be at whatever position's being requested. So now what we want to do is get the actual values. So we'll need to get the value for the course, the title, and the ID. So now with that, we've got the value for our course, the note title, and the ID of the row at the current position, and we retrieved all those values using the column indexes that we got earlier. So now the line where we actually position our notes list, we don't need that anymore. So let's get rid of that line. So what we want to do then is take the values from our cursor and associate them with the appropriate fields in our ViewHolder class. So our ViewHolder class has a field mTextCourse, which is a reference to a text view. So we'll take our course value from the cursor and pass that into setText. We'll then take our noteTitle value and pass that into the setText method for the ViewHolder class's mTextTitle field. And then, finally, we'll take our ID value and assign it to the ViewHolder class's mId field. So that takes care of taking the values from our cursor and associating them with our ViewHolder class, which means we'll actually display the content from the cursor to the user. So we have one last method to address, which is the getItemCount method. And that informs our RecyclerView how many rows there are. So what we can do here is that rather than return mNotes. size, we'll take our cursor and call its getCount method. So getCount will return the number of rows in that cursor. But remember that our cursor might be null. So what we need to do is check to see if the cursor is null. And if it is null, we'll return 0. Otherwise, we'll return getCount. So with that now, our adapter's all set. So in our next clip, let's do the work we need to do to pass in an appropriate cursor to our adapter.

Connecting a Cursor to a RecyclerView Adapter
Here we are back in Android Studio. And we're looking at our MainActivity class. What we want to do now is update MainActivity to take advantage of the changes we made to our NoteRecyclerAdapter and have the MainActivity's RecyclerView display the list of notes directly from the database. To get us started, we're looking at the MainActivity class's initializeDisplayContent method. One of the things this method does is construct the instance of our NoteRecyclerAdapter. If we look at the code we have here now, we get the list of notes back from the DataManager and then pass that into our NoteRecyclerAdapter. Well we know that our NoteRecyclerAdapter wants a cursor now, not that list of notes. So the first thing we'll do is get rid of the line that gets back the list of notes. So now for the second parameter to our NoteRecyclerAdapter constructor, we want to pass the cursor. But we don't have the cursor yet. So let's just go ahead and pass null. So now that we have our NoteRecyclerAdapter properly constructed, let's go ahead and scroll up to the onResume method. So we're here at the onResume method. And, remember, the onResume method gets called each time we return to an activity. And when we're populating our RecyclerView with an arrayAdapter, you can see we used to call the notifyDataSetChanged method to let the arrayAdapter know that the data in the list may have changed and it needs to go ahead and update the RecyclerView. Well in our case, we don't want to do that. We want to just go ahead and instead each time we come in here, get the latest set of data out of the database. So let's go ahead and get rid of this call to notifyDataSetChanged. So what we'll do instead is go ahead and get the latest set of notes from the database. So let's do that in a method we'll create called loadNotes. We'll go ahead and create it by just doing Alt+Enter, then Enter. We'll accept a return type. So what we want to do now is query the note_info table in the database to get back the list of notes. And in order to do that, we need our database connection. So let's call getReadableDatabase on our open helper, and we'll assign that back to a SQLiteDatabase variable. So now we can use that db variable to query our database. Now remember that we've already queried the database for the list of notes. We did that in our DataManager class. And the way we're going to do it now is largely going to be the same. So let's head over to our DataManager class and just copy that code. So we're in our DataManager class's loadFromDatabase method. Remember, this has the code to both query the data from the course_info table and the note_info table. Let me go ahead and just highlight the lines that are related to querying the note_info table. So we'll go ahead and copy those. Let's head back over to our MainActivity. So we're back here in our MainActivity's loadNotes method. We'll go ahead and paste in the lines we just copied. And you can see when I go to paste it in, it tells me that it needs to add some imports, and that's okay, so I'll just click Enter. So you can see there now we actually have the array with the list of columns that we want back. And notice that our columns are being fully qualified in the NoteKeeperDatabaseContract class. So let's go in and adjust our imports so we don't have to fully qualify that. So we'll go down here to NoteInfoEntry. I'll click on that. I'll do Alt+Enter. We'll go ahead and say Add the import. And so now all those references are simply NoteInfoEntry instead of being qualified inside the NoteKeeperDatabaseContract class. So when we look over the list of columns, we've got our NOTE_TITLE, our NOTE_TEXT, the COURSE_ID, and then _ID. Whenever we interact with the database, we generally don't want to bring back any more data than we need. Now we know we need the NOTE_TITLE, the COURSE_ID, and the _ID columns, but we don't need the NOTE_TEXT column. So let's go ahead and remove that column from the array. So now we've got our array of columns. We've got our noteOrderBy information, which we're going to order first by the COURSE_ID and then by the NOTE_TITLE. We want to go ahead and keep doing that. And then we're going to go ahead and do the query and get back our cursor. So what we want to do now is take this cursor and associate it with our NoteRecyclerAdapter. And we can use our mNoteRecyclerAdapter's changeCursor method. And with that, now the cursor's associated with our NoteRecyclerAdapter. Remember that this method here, loadNotes, is called from onResume. So each time we return back to MainActivity, We'll re-query the database and get the latest information from inside the note_info table. So let's go ahead and run our program now and see how everything looks. So here we are with the application running in the emulator. And we can see that we have our notes listed here. Now remember that for the time being, we've changed our code so that when we display the notes here in the RecyclerView, we're showing the course ID rather than the course title. A little bit later in this course, we'll go ahead and make the changes we need to go ahead and show the course title as well. I'm going to go ahead and choose this first note here. And notice its course ID is android_async. And the note title is Long running operations. And you can see when I choose that, in our NoteActivity, we have the correct course displayed, Android Async Programming and Services. We've got our correct title there. Let's go ahead and go back to our MainActivity. We returned back to our MainActivity, and it repopulated our RecyclerView correctly. Let's go down here and choose a different note. So I'll choose the one that's part of the course java_core. The note title is Compiler options. I'll select that. So you can see now that's associated with the correct course, Java Fundamentals: The Core Platform. And we have the correct note title. And so now with that, our app is working directly with the database for all of our note display. The changes we just made to MainActivity and the recycler adapter handle displaying the list of notes directly from the database. The changes we made earlier to NoteActivity display individual notes directly from the database including populating a list of courses in the course selection spinner.

Summary
Here are some of the key things to remember from this module. Remember that we had the CursorAdapter, and that gave us the ability to populate things like spinners and ListViews with data from a cursor. And the CursorAdapter is extremely flexible. It took care of managing the cursor interaction, and then it provided methods that allow us to create views and bind data to those views. But remember that one of the reasons a CursorAdapter class is so flexible is because we're responsible to implement our data display details. So to help us out with some of the common scenarios of binding cursor data to things like spinners and ListViews, we have the SimpleCursorAdapter. Now it extends the CursorAdapter class but provides default display handling. When we use the SimpleCursorAdapter, we can simply provide the display resources we want to use, and then we provide the information that maps the columns from the cursor into the IDs of the views within those resources. And then SimpleCursorAdapter takes care of the details of displaying the data from the cursor within those resources. And then we finished up with a look at RecyclerViews and cursors. And the key thing we learned there is that when we're binding data to a RecyclerView, whether that data comes from a cursor or some other data source, the process is largely the same. We still extend the RecyclerView. Adapter class. The issue of managing our views with a ViewHolder is largely the same no matter what the data source is. But, of course, the difference is when we're working with a cursor, we have to provide cursor management, we have to handle the data display of taking data from the cursor and binding it to the views. But fundamentally when it comes to working with RecyclerViews and cursors, what we're doing is combining what we learned about RecyclerViews earlier in this course series and combining it with what we learned about cursors in this course. That wraps up this module. In our next module, we'll dig into the issue of database queries and activity lifecycles. And we'll learn how to use something called loaders to issue queries that work appropriately with the activity lifecycle.

Performing Lifecycle Aware Data Loading with Loaders
Introduction
Welcome to the module, Performing Lifecycle Aware Data Loading with Loaders. This is the Pluralsight course, Managing Android App Data with SQLite. My name is Jim Wilson. In this module, we'll look at the appropriate way to query our SQLite database so we load and access the data in a way that correctly works with the lifecycle of an activity. So we'll start out with a look at how database queries can negatively affect activity user interface performance. We'll then look at the LoaderManager and its role in overcoming those negative effects. We'll see how to load SQLite data using a class known as a CursorLoader. We'll see how to deal with the challenges that come up when an activity needs to load data that comes from multiple queries. And we'll finish up with a discussion of the differences in behavior between initializing and restarting a loader.

Queries and Activity UI
Throughout this course, we've been modifying our application to query data from our SQLite database. Now each of those queries was executed by a code that was called directly from activity methods such as onCreate or onResume. And that means that those queries are being executed as part of the MainActivity flow. And each time we did that, I'd tell you that we should avoid performing queries as part of an activity's main flow. And the issue is that as the amount of data in the database increases with the nature of the request for data getting more complex, queries can become quite time consuming. And so running these time-consuming queries as part of our MainActivity flow can actually create inconsistent user interface performance. The user interface can momentarily freeze or become very jerky. And in extreme cases where a query runs for several seconds, you might even get an Application Not Responding error, which might result in a user terminating your application. So let's take a look at what's going on that creates that problem. Now we know that our application runs inside of our process. And inside of our process, work is actually done on a thread. So when our activity starts up, it's actually running on the main thread. That's where it runs throughout the life of the application. And it's responsible for all the user interface work. It's responsible to write or draw all our content to the user interface. And it's responsible to take all the user input. Well let's see running a query affects that. So let's say we start with our activity, and things are running on the main thread just fine. And then we issue a query. And by doing that on the main thread, that main thread is now busy issuing the query and is not available for any of the user interface work. So no user interface work can go on at all while that query's running. It has to wait until the query finishes, and the main thread again becomes available. And this can create a very undesirable user experience. So what we want to do now is the main thread runs, and it becomes time to do some database work, what we want to do is hand that query off to another thread. And then that query runs separate from the main thread leaving the main thread available to do whatever user interface work is necessary. And then once we have our results of the query, we can pass that back to the main thread, and the main thread can then use that data to write the information to the user interface or do whatever work needs to be done. Now, of course, we could manually do all this work. But fortunately we don't have to. Android provides a lifecycle aware data loading model. And it relies on something called loaders. So loaders allow us to run queries on a background thread, and they know how to cooperate with our activity lifecycle. Now we don't do a lot of direct work with the loader. Instead we rely on something called a LoaderManager. Now a LoaderManager knows how to coordinate a loader and our activity. So in our next clip, let's take a closer look at the LoaderManager.

LoaderManager
As we mentioned, LoaderManager coordinates loaders with the corresponding activity. So each activity has a single LoaderManager. And it manages all the loaders for that activity. So that implies that one activity can have one or more loaders. Now LoaderManager initiates the loader execution, and it initiates our loader-related cleanup. And it provides us with notifications of what's going on with the loader. So the way we access an activity's LoaderManager is by simply calling the activity's getLoaderManager method. When we're using loaders to load our data, we don't load the data directly. Instead, we ask the LoaderManager to start the process for us. So what we need to do is actually initialize the process of data loading. We do that with a method called initLoader. And when we call initLoader, we need to pass it an ID for that loader. And all that is is an integer value that uniquely identifies that particular loader within this activity. And then we also need to pass in a reference to an interface called LoaderCallbacks. Now this interface LoaderCallbacks is used to notify us of key steps in loader processing. And LoaderCallbacks divides processing into three steps. There's a request for the actual load. There's a notification that tells us that the data is ready. And it tells us when it's time to clean up. And each of those steps are represented by a method on the interface. So the interface's onCreateLoader method is how the LoaderManager requests a loader. So when that method's called, it's our responsibility to go ahead and create and return a loader. Then there's the onLoadFinished method, and that's how the LoaderManager tells us that our data is ready. So when that method's called, we'll actually receive a reference to a cursor. And then we can use that cursor just as we have been. And, finally, there's the onLoaderReset method. And that's how the LoaderManager tells us that it's time to clean up. So when that method's called, we're responsible to go ahead and close up our cursor. So in our next clip, let's start the work of converting our NoteActivity to use a LoaderManager to load the data from our database.

Working with LoaderManager and Callbacks
Here we are in Android Studio. And we're looking at our NoteActivity class. What we want to do now is start converting this class to use the LoaderManager to initiate the process for loading data from our database. We'll start by changing the way we load our note data. Now here at the bottom of our onCreate method. You can see here where we call our loadNoteData method. Now because this method directly loads data from our database, it has the potential of interfering with user experience during the data load. So let's go ahead and start switching this over to use our LoaderManager. So the first thing we'll do is get rid of this call to loadNoteData, and what we'll do instead is use the LoaderManager to start the process. So we'll need to call getLoaderManager to get a reference to our LoaderManager. So now we want to initialize the process of loading our note data, so we'll call initLoader. So now when we call initLoader, we need to pass in an integer value to identify the loader. We'll just use the integer value 0. Now we could, of course, use this literal value 0, but it's a lot better idea to use a constant. So let's do Ctrl+Alt+C to turn this into a constant. It says what we want to do now is load our notes. Let's name this constant LOADER_NOTES. We'll go ahead and hit Enter. So now that constant LOADER_NOTES has a value 0. But more important than its specific value, it's the constant identifying the loader we're going to use to load up our notes. So now we don't need to use the second parameter to initLoader, so we'll just pass a null for that. And the last parameter is a reference to the class we want to receive the LoaderCallbacks. It says we want them to come directly to our NoteActivity class. We'll just pass the 'this' reference. So you can see that our 'this' reference has a red underline. And that's because our NoteActivity class doesn't yet implement the LoaderCallbacks interface. So let's scroll up top so we can implement that. So we're here at the top of our NoteActivity class. We want to implement our LoaderCallbacks interface. Now the LoaderCallbacks interface is within the LoaderManager class, so we'll put implements LoaderManager. LoaderCallbacks. The LoaderCallbacks interface accepts a type argument. So we'll provide a type argument of cursor because we're loading data into a cursor. So now our NoteActivity class implements the interface LoaderManager. LoaderCallbacks, and LoaderCallbacks is typed on cursor. So now we want to go ahead and implement this interface, so let's do an Alt+Enter. We'll say Implement methods. And we want all the method, so we'll just hit OK. So let's scroll down here so we can see all three methods. So you can see our first method there, onCreateLoader. This is a method that's called to actually create the loader. And we see onLoadFinished. That's the method that's called when our data is ready. And then onLoadReset is called when it's time to clean things up. So what we want to do is start by implementing onCreateLoader. So in our next clip, let's see what's involved in creating a CursorLoader.

CursorLoader
As we've mentioned, the purpose of the loader is to run queries in a background thread and do so in a way that cooperates with the activity lifecycle. Now the interworks of a loader can be fairly involved, but using a loader generally speaking is pretty straightforward. So in our code, we're going to use a special kind of loader called a CursorLoader, which is a loader designed specifically for loading cursor-based data. So now the CursorLoader makes working with SQLiteDatabase queries pretty easy. It also works well with a special kind of component called a content provider. Now we'll look at content providers a little bit later in this series. But for our current scenario, we're querying a SQLiteDatabase directly. So to do that, all we have to do with a CursorLoader is override its loadInBackground method, and then inside that method, we'll issue our database query, and then we just return back the cursor. And in doing that, we'll be able to query the database in a way that works with the LoaderManager to cooperate with the activity lifecycle. So in our next clip, we'll go ahead and add the code to our NoteActivity to query the database using a CursorLoader.

Loading Notes
Here we are back in Android Studio. And we're looking at our NoteActivity class's onCreateLoader method. Remember that this is the method call by the LoaderManager to request a loader that knows how to load our data. And we want to load up our note data. Now we're going to load up our note data using a special kind of load called a CursorLoader. So let's go ahead and add a local variable here of type CursorLoader. We'll call it Loader and initialize it to null. Let's go ahead and change the return statement to return back loader. So now remember that an activity can have multiple loaders. And each loader has an ID. So the first thing we want to do here after we've declared our loader variable is check to see if the ID value that's being passed to this parameter onCreateLoader has the value we're looking for, which is loader_notes. So let's add an if statement to check that. So if it is our ID value, we'll go ahead and create an instance of a CursorLoader that knows how to load up our notes. Now there're a few steps involved in doing that. So why don't we go ahead and move that into a method. So what we'll do is assign the loader variable results of a method we'll create called createLoaderNotes. We'll do an Alt+Enter to go ahead and create it. We'll accept the return value. So, again, what we want to do in this method is return a CursorLoader instance that knows how to load up our note data. So let's go ahead and say return new CursorLoader. The CursorLoader constructor accepts a context, so we'll go ahead and pass it this. So now remember that the way we construct a CursorLoader that knows how to load our data is by overriding its method loadInBackground. So what we want to do is make this an anonymous class and then override that method. So we'll go ahead and put our brackets in place. We'll go ahead and add a new line. Even though this is an anonymous class, I have override methods here just like I can in any other class. So I'll just do a Ctrl+O, and I will choose the loadInBackground method, and I'll hit Enter. And that goes ahead and stubs it out. Let's go ahead and get rid of the code that's in here. So now the way that we create the cursor here is just like we did earlier. So we have all code in our loadNoteData method. So let's head up to our loadNoteData method. So here we are in loadNoteData, and if we think about it, loadNoteData is kind of doing two broad tasks. The bottom portion of loadNoteData does all the work that has to be done once we have a cursor back. It's the beginning part of the method that actually deals with getting that cursor. So let's go ahead and highlight those lines. We'll go ahead and copy those guys. Let's head back down to our createLoaderNotes method. So here we are back in createLoaderNotes. Let's go ahead and paste that code in. So now the way we have the code currently written is that when we issue the query, we're assigning it directly to our member field mNoteCursor. Instead of doing that, let's change the return from db. query to be our message return value. And it turns out that's all we have to do. The process of actually issuing the query is exactly as it was before. The only difference is rather than using return cursor directly, we're making it the return value of our loadInBackground method. So now by creating this CursorLoader that contains the code we need to query our data in its loadInBackground method, the loader match will take care of all the details of running that code on the background thread for us. So what we need to do now is deal with the results of that query. And that's what we'll see how to do in our next clip. Here we are back in Android Studio, and we're looking

Handling the Note Cursor
Here we are back in Android Studio, and we're looking at our NoteActivity class. And what we want to do now is continue the work that we started in the last clip of accessing our note data from the database using the LoaderManager. So now in our previous clip, we took care of issuing the actual query using a CursorLoader. What we want to do now is start dealing with the results, and we'll do that in this method here onLoadFinished. Now you can see that onLoadFinished has two parameters. The first parameter is a reference to a loader, and that's the loader we created in our last clip. So in our case, that loader's a reference to a CursorLoader. The second parameter is the actual cursor that we returned. So basically this method is giving us access to the things we created earlier. Now, again, a reminder, one activity can have multiple loaders, so the first thing we want to do is check and see that this is actually the loader we expect, the one we expect for our notes. So what we can do is use our reference to loader there that's passed in and call its getId method and check and see if that matches our constant LOADER_NOTES. So now if this is our loader, I'm going to go ahead and do the work to display the note returned in that cursor. So let's go ahead and call a method we'll create called loadFinishNotes, and we'll pass in the cursor. So let's go ahead and create the method. So we'll say Alt+Enter, Enter, we'll accept our return type, the parameter type, and the parameter name. So now this is the same work we were doing earlier in our loadNoteData method. Remember that the first thing we want to do is go ahead and take this cursor and assign it to the member field mNoteCursor. So we've got that cursor in our member field mNoteCursor. So let's head up to our loadNoteData method, and we'll just copy the rest of the code from there. So here we are in loadNoteData, and you can see that once we have the cursor, what we did was simply get all of our column positions, position the cursor on a row, and then call displayNote. And that's the same thing we want to do now. So just go ahead and highlight these lines. We'll go ahead and copy them. Let's scroll back down to our loadFinishNotes method. So here we are in loadFinishedNotes. Let's go ahead and paste that code in. So now we have all the code that will use our cursor. Again, it gets some column positions, moves to a row in the cursor, and then calls displayNote. And that's all we have to do to display the note within the NoteActivity. But there is one more bit of housekeeping. Remember that we always want to close a cursor when we're done with it. And that's what this onLoaderReset method comes in. That method is called when it's time for us to clean up the cursor. So now remember whenever we work with these methods that are called by the LoaderManager, we want to make sure that it's for the loader we expect. So you can see that onLoaderReset will use a reference to a loader. So, again, we want to use its getId method to see if it's the loader that corresponds to LOADER_NOTES. So now if it is ours, we want to go ahead and close it. Let's go ahead and add some brackets. We'll add a new line. We always want to be thinking in terms of defensive coding, so let's just put an if check in to make sure that our mNoteCursor is not null. And as long as it's not null, we'll go ahead and close it. And with that, we're all set. We've added all the code necessary to get our queries to work with the LoaderManager. So let's go ahead and run this guy and see how everything goes. Here we are with our app running in the emulator. I've added some breakpoints to NoteActivity so we can actually see what goes on with the LoaderManager controlling our queries. So let's go ahead and select a note. We can see our code stopping in Android Studio, so let's switch to Android Studio. So you can see here in Android Studio now that we're in our NoteActivity's onCreate method, and we're about to call initLoader on the LoaderManager. So I'll go ahead and release this. And you see as soon as I release it, we now go into our onCreateLoader method. Now, remember, this is not the point that it actually issues the query. This is the point where it actually creates our CursorLoader that knows how to issue the query. So if I step here, I've created the CursorLoader instance, but there is no query yet. So I'm going to go ahead and release this now. And you can see that we're now in the CursorLoader's loadInBackground method. But that method's actually running on a background thread that was created by the LoaderManager. So now if I go ahead and release this, we're now in our loadFinishNotes method. That tells us that our query actually finished, and we're actually getting a cursor passed in here. So if I go ahead and step and that cursor's passed in as our data parameter, that gets assigned to our mNoteCursor member field, so we go ahead and release this. The application continues running. So let's switch back to the emulator. And we can see here now that a selected node is being displayed in our NoteActivity. So all of our code to actually query the database and process the results using the LoaderManager work correctly. So let's go ahead and return back to our MainActivity. You see when I did that, our code stops inside of Android Studio again. So let's switch back to Android Studio. And you can see here we're in the onLoaderReset method. So that's telling us that it's actually time to clean our cursor up. So we'll go ahead and step. It checks to see if mNoteCursor is not equal to null. It's not. So we go ahead and close it. And then we can go ahead and release it. And our application's off and running in the MainActivity now. And so you can see that easily we were able to add the code to do our queries in a way that work effectively with the LoaderManager. It's very much like we've already learned. We're just adding the CursorLoader and some callbacks from LoaderManager to do things in a way that work effectively with the activity lifecycle. So now in our next clip, we'll add the code to populate the spinner that shows a list of courses using the LoaderManager.

Loading and Handling Courses
Here we are back in Android Studio. We're looking at our new in activity class's loadCourseData method. And this is the method that's responsible for querying the database for a list of courses and then associating that with our spinner using our cursor adapter. So now currently we call this method directly. But since we're querying the database, I'm going to replace this method with code that uses our LoaderManager. So let's head up to our onCreate method. So here we are in our onCreate method, and you can see where we call loadCourseData. So we're going to replace that call to loadCourseData to our LoaderManager's initLoader method. So, remember, when we call initLoader, we pass in an integer value to identify the loader. So when we call the loader to load the notes, that was the integer value 0. So in this case, we'll go ahead and use the integer value 1. But now of course we don't want to use the literal value 1, so we'll go ahead and convert it into a constant. So we'll do a Ctrl+Alt+C. And let's go ahead and give it the name LOADER_COURSES. We'll accept that value. So now we'll go ahead and pass in the other parameters, and they're the same parameters we used when we called it for loading the notes. So we'll pass in a null, and well pass in a 'this' reference. So now remember that the 'this' reference indicates that we want the LoaderManager to notify the NoteActivity class of the loader events. So that means that when we're loading up our courses, we're going to call the same LoaderCallbacks method we called earlier when we were loading up our notes. We just have to add the code that we need to load up the courses. So let's head down to our onCreateLoader method. Here we are in onCreateLoader. Now remember that one of the parameters passed to onCreateLoader is the ID value of the loader that needs to be created. So the first thing we want to do here is add a check to see if the ID is LOADER_COURSES. So what we'll do is go ahead and add an else-if and then check the ID for LOADER_COURSES. And if it is our ID value, we're going to create an instance of a CursorLoader and assign it to that local variable there loader. So we'll do the work of creating the CursorLoader in a method we'll create called createLoaderCourses. We'll do an Alt+Enter to create it. Go ahead and create it. We'll accept the return type. Now remember that what we do in this method is create an instance of a new CursorLoader, and we'll return that back. So we'll say return new CursorLoader. The CursorLoader needs a context, so we'll pass in 'this. ' And remember that we're going to implement it as an anonymous class. So we'll put our brackets here. I'll go ahead and hit Enter. Let's do a Ctrl+O. We want to implement loadInBackground, so I'll select that. Hit Enter. And remember that what we do here is whatever work is required to create our cursor. And that's going to be the same work we did in our loadCourseData method. Now I've already copied that into the clipboard, so let me just go ahead and paste it in. So you can see that all we do there is get our connection to our database, identify the columns we want, and then issue the query. And that query returns back a cursor. So what we'll do is we'll take the result of the query method and simply return that back from our loadInBackground method. And, again, that's all we have to do. The LoaderManager and the CursorLoader class will take care of all the details of running that query on a background thread. So that issues the query. Now, of course, we want to get the results back. So let's scroll down to onLoadFinished. Here we are in onLoadFinished. Remember, we received two parameters, a reference to a loader and then our cursor. So the first thing we're going to do is check and see if this call to onLoadFinished is for our loader. So what we'll do is we'll add an else-if here that checks the loader ID value against LOADER_COURSES. Now if it is our loader, all we want to do is take the cursor that's passed in to allLoadFinished and associate with our cursor adapter. So we'll just go ahead and do that right here inside of onLoadFinished. So I'll put some brackets, create a new line, and we'll take our adapter reference, mAdapterCourses, and call its changeCursor method passing in the cursor. So I'll associate the cursor with our cursor adapter. And that's all we need to do to populate the spinner with the list of courses returned from the query. But there is one last thing we want to do. Let's scroll down to our onLoaderReset method. Remember that when onLoaderReset is called, we're responsible to close the cursor. So the first thing we'll do is add an else-if here to check to see if this is the loader for our courses. And if it is our loader, the way we close the cursor is by simply calling the adapter's changeCursor method with a null value. So with that now, we have all the code in place to populate our course selection spinner using the LoaderManager. So in our next clip, we'll go ahead and test it all out.

Challenges of Multiple Loaders
So here we are with our application running in the emulator. We've just added the code to populate our spinner using a LoaderManager. So let's select one of the notes. And that worked okay. We see we've got a course selected in our spinner. If I click on the spinner, we can see it's populated. So it's populated correctly. So the code we've added to populate the spinner with the LoaderManager has worked correctly. So let's head back to our MainActivity. So what I'm going to do now is I'm just going to go here and select a few different notes and keep returning back to MainActivity. So I'll select another note. And you notice that it crashed that time. It didn't crash the first time. And it might not even have crashed that time. But eventually our program was going to crash when it was trying to display a NoteActivity. So let's head back to Android Studio and understand why. Here we are in Android Studio. We're looking at our NoteActivity class's displayNote method. Remember that this is the method that we call once we've populated the cursor that contains our note. If you look here, we first get the values from the NoteCursor, and then one of the things we do is select the appropriate course in the spinner. Well that spinner is populated with a cursor as well. And as you recall, the reason we actually use the LoaderManager to populate these cursors is because it runs the actual queries on background threads. And, in fact, it's actually running both of those queries at the same time. So the query to access the notes and the query to access the courses are running at the same time. And we don't know which of those queries is going to finish first. If the courses query finished first and gets the spinner populated, then when the notes query finishes and calls displayNote, everything will be fine. But if the notes query finishes before the courses query finishes and we call displayNote, when we attempt to select a course in the course spinner, we'll actually crash the program because the courses haven't been populated yet. So we need to make a couple of small changes to our program to make sure that we don't call displayNote until both the course spinner is populated and we have the note back. So let's scroll down to our onCreateLoader method. So here in our onCreateLoader method is where the query process begins for both the notes and the courses. So what we can do is use flags for both of those cases to indicate when the queries have finished. So in the case of the courses, onCreateLoader calls the createLoaderCourses method, so let's go ahead and add a Boolean variable to createLoaderCourses, and we'll initialize it to false. Let's go ahead and promote this guy to a field. So what we'll do now is we'll use this field to tell us whether the query for the courses is finished yet or not. We initialize it here to false when we start the process of querying for the courses. And we want to set it to true when that query is finished. So let's head down to our onLoadFinished method. So here we are in our onLoadFinished method. Remember, this is the method that's called when our query is finished. And you can see our if block here that handles when the courses query finished. We associate the cursor with our adapter. So the next thing we'll do is just go ahead and take our field mCoursesQueryFinished and set it to true. So now our mCoursesQueryFinished field is false when we start the query to get our courses. And then it's true when it's finished. I'm going to do that same thing for notes. So let's head up to our createLoaderNotes method. So here we are in our createLoaderNotes method. So what we'll do now is add a field mNotesQueryFinished, and we'll initialize it to false. So we set that field to false before we start our query to get the notes. I'm going to go ahead and set it to true when that query is done. So we'll head down to our loadFinishedNote method. So here in loadFinishedNote, we'll go ahead and set our mNoteQueryFinished to true. So now those two fields, mCoursesQueryFinished and mNotesQueryFinished, will both be true only if both of those queries have finished. So what we'll do is rather than have our loadFinishedNotes method call displayNote, let's have it call a new method we'll create, and we'll call it displayNoteWhenQueriesFinished. We'll go ahead and create that method, so we'll do Alt+Enter, Enter. We'll accept the return type. And what we want to do now is check those two fields in an if statement. So now if both the notes query has finished and the courses query is finished, then it's okay to go ahead and call displayNote. So let's scroll up here just a little bit. So if we look here at our loadFinishedNotes method, the last thing it does is set its finished flag to true and then call that new method we created, displayNoteWhenQueriesFinished. Now as long as the courses query's already finished, then displayNoteWhenQueriesFinished will go ahead and display the note. But if the courses query hasn't finished yet, then we wouldn't display the note yet. So with that being the case, we actually need to call this displayNoteWhenQueriesFinished method from two places, the call we have now in the notes query finishes, but we also need to call it when the courses query finishes. So let's scroll up to that code. Let's look at our onLoadFinished method, and let's look at the if block for when our courses query finishes. So we set our finish flag to true. And then right after that, we want to go ahead and call our new method, displayNoteWhenQueriesFinished. So now we call that method displayNoteWhenQueriesFinished in two places, once when the courses query finishes and then once when the notes query finishes. But that method will only display the note whenever both of the queries have finished. So whichever one finishes last will call the note to be displayed. And that assures that we never try to display the note until we have everything we need, both the note and the courses. So let's go ahead and run this again and see if everything works okay. So here we are with our code running in the emulator. Let's go ahead and select a note. That note displays fine. Let's go back to MainActivity. Let's go ahead and select another note. That note displays fine. Let's go back to MainActivity. We'll select one more, and that note displays fine as well. And our notes will keep displaying fine because now we only display a note when we have both the note itself, as well as our course spinner loaded. So now in our next clip, let's look at something called resetting a loader.

Initalizing vs. Restarting a Loader
Here we are back in Android Studio. We're currently looking at our MainActivity class. And in this clip, we're going to look at how to handle the scenario where we need to repeat a query when using the LoaderManager. So you see here in our MainActivity, we have our loadNotes method. And that's the method that we've been using to actually query for the notes that we display in our RecyclerView. And we call our loadNotes method from inside of our onResume method. And we call it from there because we want to go ahead and repeat the query each time we return back to the MainActivity. So that way, as we add code to actually save changes to notes and create notes, we make sure we're always showing the latest notes information inside a RecyclerView. Now I've already done most of the work to convert our MainActivity over to use in the LoaderManager to loadNotes. Let's scroll down towards the bottom of the class and have a look. So we're down here in the onCreateLoader method. You can see that I have an if block for the constants that I've set up, LOADER_NOTES. Then inside that if block, I create a CursorLoader. And within that CursorLoader, I override the method loadInBackground to do the query we need to do to get all the notes out of the database. We'll scroll down here a little bit more. So you can see we have our onLoadFinished method so when the notes query finishes, we take the cursor that's passed into onLoadFinished and call changeCursor on our recycler adapter. And then on onLoaderReset, we call changeCursor with a null to close the cursor. So let's scroll back up to onResume. So here we are in onResume. And we want to replace that call to loadNotes to the call that will use the LoaderManager to start our query. So we'll call getLoaderManager. So now we've been using the initLoader method. So let's go ahead and call that here. Remember, the constant that identifies this loader is LOADER_NOTES. Then we'll pass null and this. So with that, our MainActivity will now use the LoaderManager to run the query that we use to populate our recycler adapter. Let's go ahead and put a breakpoint in here. I'll go ahead and start the application. So now as soon as we run the program, we hit our breakpoint to initialize the LoaderManager to load our notes. Now in addition to this breakpoint, I also added some breakpoints to all the LoaderManager callbacks. So let's go ahead and let this guy run. So as soon as we let it run, we see we get down into our onCreateLoader. So that creates the CursorLoader that will then run the query to get our data back. I'll let it run again. And when that query finished, it called our onLoadFinished method. And now I'll take the cursor that resulted from the query and of course associate that with our recycler adapter. So let's go ahead and let this guy run now. Let's go ahead and switch over to our emulator. So here we are in the emulator, and our recycler adapter has populated our RecyclerView. So we're good to go there. So let's go ahead and select the note. So I'll select this first note here. That of course displays the note in our NoteActivity. Now let's go ahead and return back to our MainActivity. So you can see as soon as we return back to the MainActivity, we can see that our code has hit a breakpoint inside of Android Studio. So let's switch back to Android Studio. So you can see our breakpoint is at onResume. This is where we call our LoaderManager and initLoader method. Again, the reason we do this in onResume is because we want to re-query the database to make sure we have the latest notes information. So let me go ahead and let this guy run. And you notice when I let it run, it never hit the code to actually do the query. It simply called onLoadFinished again. What that means is that we're going to go ahead and associate this cursor in the RecyclerView without getting any fresh data because the purpose of initLoader is just to make sure that a loader gets initialized. Once the loader's initialized, repeated calls to initLoader simply triggers a callback to onLoadFinished again. It doesn't repeat the query. If we want to repeat the query, we have to use a method called restartLoader. So let's go ahead and stop our program, and we'll scroll back up to the onResume method. So here we are in onResume, and what we want to do is change the method call to initLoader to restartLoader. So now by using restartLoader rather than initLoader, it assures that we'll re-query the database each time our onResume method gets called. So let's go ahead and run this guy and see what happens. So when we first launch the program, our onResume method gets called, and we again restart our loader, which takes care of initializing it on the very first call. We'll release this. We get the onCreateLoader, which will take care of creating the CursorLoader, which will then do the query for us. I release it. When that query finishes, our onLoadFinished gets called passing us in the cursor that we then associate with the recycler adapter. I'll release this. Let's go ahead and switch over to our emulator. So here we are with our code running in the emulator. We'll go ahead and select the note. That takes us into our NoteActivity. Let's return back to MainActivity. We hit our breakpoint, so let's switch over to Android Studio. So you can see this onResume is called. We call restartLoader. I'll go ahead and release this. And you see this time onCreateLoader gets called. So that'll cause us to issue a brand-new query to get the latest notes information. So I'll release it. OnLoadFinished gets called giving us a cursor from that latest query of the database. I'll release it. Switch back to the emulator. And now our RecyclerView is populated with a brand-new query of the database. So by using restartLoader rather than initLoader, we're assuring our RecyclerView re-queries the database each time we return back to our MainActivity. So our program has taken another big leap forward now. We've modified both the MainActivity and the NoteActivity to query the database using a LoaderManager. And that assures that all of our queries run in a way that works effectively with the lifecycle of our activities.

Summary
So here are a few key things we'll remember from this module. Remember that we always want to avoid performing queries as part of an activity's main flow because they can cause inconsistent user interface performance, and in extreme cases, we can even generate an Application Not Responding error. Instead what we want to do is access data in a way that's lifecycle aware. We do that using LoaderManager and loaders. So now remember that each activity has a single LoaderManager and that one LoaderManager manages all the loaders for that activity. And the LoaderManager's responsible to initiate our loader execution, and it initiates our loader-related cleanup. And the way we work with our LoaderManager is by receiving the LoaderManager notifications. We do that by implementing the LoaderCallbacks interface. Now remember that had three methods. So then its onCreateLoader method will be responsible to create our loader, and its onLoadFinished method is when we receive the data from our query, and then we perform our cleanup in the onLoaderReset method. So that's the place we want to make sure we close our cursor. So the way we loaded our data was using a class called CursorLoader. That's a specialized cursor-based loader. So when we're querying the SQLite database, we simply overrode its loadInBackground method. Inside that method, we did the work to actually issue the query. And when the query returned back a cursor, we simply returned that cursor back from the loadInBackground. Now something we had to keep in mind is that because the LoaderManager actually runs queries on background threads, it can actually run multiple queries at one time, so that creates a bit of a challenge for us because those queries might run in parallel. And as a result, one query might finish before another. So we're responsible that if our activity issues multiple queries at the same time, we need to make sure that all the data that we expect to be available is available before we start working with it. And then the last thing we looked at is the issue of restarting a data load. Remember that the initLoader method will only perform the load once during the life of the activity. So if you call initLoader more than once, it does not reload the data. It simply calls onLoadFinished again. If you want to restart the data load, you need to use the method restartLoader. That wraps up this module. In our next module, we'll see how we can bring together data from multiple tables using something called joins. And we'll also see how we can improve query performance using indexes.

Doing More with SQLite Queries
Introduction
Welcome to our next module, Doing More with SQLite Queries. This is the Pluralsight course, Managing Android App Data with SQLite. My name is Jim Wilson. As we've seen throughout this course, SQLite provides a very rich and powerful data query mechanism. In this module, we'll finish up our discussion of SQLite queries by taking a look at a few additional query-related concepts that we frequently use in our Android applications. We'll start with a look at a concept known as joining tables. Joining tables allows us to issue queries that return back columns from multiple tables. Now joining tables introduce some issues that come up when we access columns by name. So we'll look at those issues next. We'll then look at the role of something called indexes in SQLite queries. And we'll finish up with a look at what's involved in creating indexes.

Joining Tables
Let's look at the way we display notes in our MainActivity. Now we've already done the work to associate our MainActivity with a database. We modified our RecyclerView adapter so that it reads data from the database and then populates the RecyclerView with it. Now the way we're currently displaying notes kind of has an issue though. Remember that each note is associated with a course, and the way we're displaying the notes in our RecyclerView here is that for the course, we show the course ID. And from a user's standpoint, the course ID is probably not particularly useful. I'm sure the user would much rather see the course title rather than the course ID. And the reason we're showing the course ID rather than the course title has to do with the way our database is structured. Remember that we pulled the information from our note_info table. And then that info_table has our note_title, but the only information we have for the course is the course_id. To actually get the course_title, we actually have to look at our course_info table. So what that means then is that we actually need to use both of these tables to display the information for a note. So if we look at our first note there, we've got that note_title, Dynamic Intent Resolution. We know the course_id is android_intents. But we need to actually get that title by going out to the course_info table and finding that the title that corresponds to the ID android_intents is Android Programming with Intents. Then we have to do the same thing for the next row. So the note_title Anonymous classes has a course_id of java_lang. Well we need to go out to our course_info table and find that the course_id java_lang corresponds to the title Java Fundamentals: The Java Language. And again for the next note. So the note title Delegating intents again has the course_id android_intents. We need to go out to our course_info table and again find that its title is Android Programming with Intents. Now one way to resolve this will be to use multiple queries. So we could issue the query to get all the notes from the note_info table, and then for each row that comes back, we could do a separate query to go out to the course_info table and find the corresponding title. But we actually have a better solution available than that. What we can use is a concept known as joining tables. What a join does is enable us to issue a query that contains columns from multiple tables. So we can use the same query method we've been using, but for our first parameter, we've just put a table name. But we can actually do more than that. We can add the keyword JOIN and provide another table name. So what this is saying now is that I want to issue a query that contains columns from both the note_info table and the course_info table. What we have to do is provide information on how to match the rows up from those two tables. So we actually provide the keyword ON, and then we identify how we want the columns matched up. So, first, we'll say that I want the course_id column from the note_info table equals and then the course_id column from the course_info table. So what I'm saying there is that when I issue a query, I want the rows to be matched up based on the course ID values being equal in those two tables. So what happens now is the results returned back to our cursor will have columns from both of those tables. So for our first note, our note title is Dynamic intent resolution, it has the course ID android_intents. The database will automatically go find the corresponding row from the course_info table that has that same course ID. And we will have one row now that includes both the note title and the course title. And it'll do that for each of the rows that come back. So our note_info table has a note with a title Anonymous classes, the course ID in the note_info table is java_lang, the database will find the corresponding row from our course_info table and give us back the course title Java Fundamentals: The Java Language. And that'll keep happening for each of the rows that come back into our result. So our one cursor now contains rows with columns from both of those tables. And we can now process those results just as we did when we issued a query that contained columns from only a single table. So in our next clip, we'll start making the changes to our MainActivity class to use a JOIN to display the note information in the RecyclerView.

Joining Notes and Courses Tables
Here we are in Android Studio. We're looking at our MainActivity class's onCreateLoader method. And inside of there where we create our CursorLoader and then override its loadInBackground method. It's in there that we do the query to get our notes. If we look at the way we are currently calling the query method, we pass in the name of our note_info table. What we want to do now is change that to actually join together both the note_info table and the course_info table. So to get us started, let's just go ahead and add a comment that shows the way the JOIN clause needs to look. So we'll start out with note_info JOIN course_info. So that indicates we want columns from those two tables. I'll add the keyword ON. And then we have to tell SQLite how to match up the rows in those two tables. So we'll start out with note_info. course_id = course_info. course_id. So that's the JOIN clause we want to use in our call to query. But we want to build that JOIN clause using the constants from our DatabaseContract class. So let's go ahead and declare a variable here of type string. And let's just go ahead and call that tablesWithJoin. And then we'll build our JOIN clause. So we'll start out with NoteInfoEntry. TABLE_NAME. Then we'll concatenate the string literal JOIN. And then we'll add CourseInfoEntry. TABLE_NAME. Then we'll concatenate the literal ON. Then we need to indicate that we want to match up on the course ID column from the note_info table, so we'll start out with NoteInfoEntry. TABLE_NAME. We concatenate a literal period after that. And then we'll concatenate the column name. We'll add the equal sign and then a course ID column within our course_info table. So that gives us our JOIN clause. So what we want to do now is go to where we call a query and replace NoteInfoEntry. TABLE_NAME with our tablesWithJoin variable. So with that now, we're issuing a query that we're trying to make a cursor that contains columns from both our note_info table and our course_info table. So that way we can access our note information, as well as the course title that corresponds to that note's course. In our next clip, let's take a look at some of the issues we need to keep in mind when accessing columns in a query that joins tables together.

Column Names in Joins
When we issue a query that contains a join, it creates the possibility of ambiguity in the column names because column names on one table may have the same name as columns in the other table. So when we're identifying a column, we need a way to clarify any potential ambiguity in the column name. We do this by table qualifying the column name. And we table qualify a column name by simply preceding the column name with the table name and separate the two with a dot. And we saw this with our JOIN clause. With the note_info table and the course_info table, both had a course_id column. So when we wanted the one from the note_info table, we simply named it note_info. course_id. If we want the course_id column from our course_info table, we named it course_info. course_id. When working in SQLite, there are times when we can use table qualified names, and there are times when we cannot. We can use table qualified names in a couple of scenarios. Now one we've already seen. In the case of building our join statement, we use table qualified names for the columns. Also, if we're passing the array of column names into our query statement, those column names can also be table qualified. Now we don't use table qualified names once we're interacting with the cursor, so when we call getColumnIndex, we don't want to pass in a table qualified column name. We want to simply pass in the column name. To give us a better sense of how to appropriately work with table qualified names, in our next clip, we'll finish the work of using a join to display the note information in our MainActivity's RecyclerView.

Specifying Qualified Column Names
Here we are back in Android Studio. We're looking at the code in our MainActivity class where we query for the notes. Earlier we changed this code to perform a query that joins the note_info and course_info tables. What we want to do now is make the changes necessary to have the appropriate columns returned. As we talked about in the last clip, when a query involves a join, we often have to table qualify column names to avoid ambiguity. As you can see here where we build the JOIN clause, table qualifying the column names can be a bit cumbersome as we have to explicitly concatenate the three values together--the table name, a period, then the column name. So to avoid all that explicit concatenation, I often add a little helper method to each table's contract class. Let's head over to our NoteKeeperDatabaseContract class. Here we are in the CourseInfoEntry class within NoteKeeperDatabaseContract. And so that we don't have to explicitly concatenate the values each time we need a qualified name, I like to add a method called getQName that takes care of the details of building the qualified name. So we'll add this method getQName that returns a string. GetQName accepts a string parameter, which is the column name. Then in the body of the method, we simply return back the table name concatenated with a period and the column name. With this method in place, whenever we need a table qualified column name rather than having to do the explicit concatenation, we can simply call this method passing in the simple column name, and we'll get back the qualified column name. Let's scroll down a little bit so we can add the same method to our NoteInfoEntry class. So here in our NoteInfoEntry class, we'll add the getQName method, and it'll look exactly the same as it did in our CourseInfoEntry class. So now we have our getQName method added to the contract class for both of our tables. So let's head back over to our MainActivity class, we can try using this method. So you can see here where we build the string to create the JOIN clause to join our note_info and course_info tables together. And let's change the code here where we explicitly built the table qualified names for course ID to now use our getQName methods. So you can see here by using the getQName methods rather than explicitly concatenating the values together, it just helps to make our intention a bit more clear that we're getting a table qualified column name. So now let's look here where we have the list of columns we want returned. Now remember that the reason we're joining the note_info and course_info tables together is so we can actually get the title of the course that corresponds to the note. So let's go ahead and add our course_info table's course title to our list of columns. So now the question is, Do we need to qualify any of these column names that appear in our column list? Now remember that the only ones we need to qualify are those that appear in both tables in our query. So let's start at the bottom. So we have our course title column, and now it only appears in our course_info table, so we don't need to qualify it. But our course ID does appear in both tables. So let's go ahead and quality that with our NoteInfoEntry class's getQName method. Now the note title only appears in our note_info class, so we're okay there. But then we get to the _ID column, and we know that the note_info table has an _ID column and the course_info table has an _ID column. So we have to be sure to table qualify this one. We want to make sure we get the one for the correct table. Remember that we use this _ID value to show the note in the NoteActivity when the user selects it from our RecyclerView. So we want to get the _ID column from our NoteInfoEntry table. So let's go ahead and qualify that with our getQName method. So now we're all set with our list of return columns. In our next clip, we'll add the code to access the column values, and then we'll test everything out.

Accessing Columns in a Join
Here we are back in Android Studio. We're looking at the code in our MainActivity class where we query for the notes. Now earlier we changed this code to perform a query that joins the note_info and course_info tables. Then in our last clip, we changed the list of return columns to include the values that come from our note_info table, along with the course title from the course_info table that corresponds to each note. Now we're ready to start accessing those column values. So let's head over to our NoteRecyclerAdapter class. Here we are in our NoteRecyclerAdapter class's populateColumnPositions method. And this is where we get the indexes of the columns we use in our adapter. You'll notice, though, that the first column we get the index of is the course ID. And remember that the reason we're now joining the note_info and course_info tables is that we don't want the course ID anymore, we want the course title. So let's change that from using the note_info table's course ID column to instead use our course_info table's course title column. So now the next column we get the index of is the note's title. We don't need to make any changes there. And then the last column we get the index of is the _ID column. Now remember that we use this value to display the appropriate note in the NoteActivity when the user selects a note in our RecyclerView. Now both of our tables have an _ID column, which is why we had the table qualify the column and the list of columns we pass to the query method. But here where we're interacting with the cursor, we pass in just the column name. We don't need to table qualify it in this case. So we can just leave that as it is. So those are the three columns we need in our recycler adapter--the course title, the note title, then the note's ID value. So those're also the only columns we need returned by the query. So let's head back over to our MainActivity class where we issue the query. So here in our MainActivity class, you can see the list of columns we're passing to the query method. So we can see we have the three columns we use in the recycler adapter, which is the note's ID value, the note title, and then the course title, but we also have the course ID from the note_info table. And we don't actually need that anymore. And remember that when we're querying the database, we don't need to return back more than we need. So let's go ahead and remove the course ID column from our list of return columns. So now that our list of columns is all set, we have one more thing we want to look at. Notice here where we provide the noteOrderBy value. We're doing that by the course ID and then the note title. Well we no longer return the course ID, so we can use that, and also we probably will go ahead and sort it by the course title because that's what the user's going to see onscreen. So let's change where we say NoteInfoEntry. COLUMN_COURSE_ID to instead be CourseInfoEntry. COLUMN_COURSE_TITLE. So now our sort will primarily be the course title. And then within the course title, we'll sort by note title. So let's go ahead and run this now and verify that everything works as we expect it to. So here we are running in the emulator. And now you can see that our notes each have the course title displayed along with a note title. So our join is returning back the right values. The note title is coming from the note_info table, and the course_title is coming from our course_info table. Let's go ahead and select one of the notes. And when we select the note, it displays the correct note in our NoteActivity. Let's go ahead and return back to our MainActivity. Let's go ahead and scroll down a little bit. And as you can see as we scroll down, all of our course titles are displaying correctly. So displaying the information in our RecyclerView by joining the note_info table and course_info tables together is working just as we want it to. So now in our next clip, let's start looking at the idea of indexes on our SQLite tables.

Indexes
Let's take a look now at how database structure affects our queries. So if we look at the CREATE statement for our note_info table, we created the table, we specified the list of columns and their associated storage class, and for some of those columns, we also provided constraints. So for our note_title and our course_id columns, we have the constraints of NOT NULL. But then in our _id column, we provided a constraint of PRIMARY KEY. Remember that the primary key uniquely identifies each row in the table. But remember that the primary key also helped with the efficiency of finding rows in the table. So if we look at our note_info table, because we marked the _id column as a primary key, the database takes advantage of a data structure to locate the rows in that table when we search for them by the ID value. So if I say I want the row from the note_info table that has an ID value of 5, the database is able to use that data structure to very efficiently locate that particular row. But what if I wanted to find a row in that table not using the ID column but using a different column. Say, for example, we added a feature to our app that allowed a user to type in the title of a note, and we would then go out and find the note that has the matching title. So if the user said they want to find the note that has the title parameters, the way our database is currently constructed, what the database would have to do is basically go out to the first row in the table, check its title, and go, nope, that's not parameters. Go to the next row, nope, not parameters. Go to the next row, nope, still not the title parameters. And then, finally, when it gets to the row that has that title, it could return back that row. So what that means is that what the database would have to do is sequentially scan through the rows in the database until it finds the row that has the matching column value. So to help with the situation, the database allows us to create something called indexes. And indexes provide a data structure that helps it to more efficiently locate rows based on column values. Now in the case of a primary key, a table can have only one. But in the case of indexes, a table can have as many as it needs. So if we create an index over the note_title column, the database will then construct that data structure that allows it to find rows in the table based on a note_title column value more efficiently. So with that in place, when I say I want the row from the note_info table that has the note_title of parameters, it can use the data structure to very efficiently get to that row and return it back to me. Now indexes are helpful in a number of scenarios. Now the most obvious scenario is when a column is part of a selection criteria when we try to find a row based on a value in a column. But they're helpful in other cases too. Another common scenario is when we query data that we return back in a certain order. If I say that I want to have all the notes returned back in order by note title, creating an index on the note_title column will help the database put those rows in order more efficiently. Also, indexes are helpful when a column is involved in a join. Think about when we were populating our RecyclerView with the notes. As the database was returning back all the notes from our note_info table, it had to keep going out to the course_info table and find the row in the course_info table that had the same course ID that was inside of our note_info table's row. So the database had to keep searching for a course in the course_info table by the course ID. Having an index on the course_info table's course ID can help the database do that more efficiently. Now it's important to understand that indexes are a design concept. Indexes don't affect the way we write our queries. We write our queries as we always do. The database will then choose whether to use an index or not based on what we're querying. So when we design our databases, we want to be sure that we put the indexes in place that are helpful for the queries that we're writing. Now it's interesting to note that indexes are sometimes implicitly created by the database. One scenario where that happens is when a column has a unique constraint. So if we look at the CREATE TABLE statement for our course_info table, our course_id column has a unique constraint on it. That unique constraint says that no two rows inside this table can have the same value inside the course_id column. So what that means is that each time we add a row to the course_info table, the database is responsible to look at the course_id values for all the rows that are already in the table and make sure that the new row coming in doesn't duplicate one of those values. To help it do that efficiently, the database implicitly creates an index on our course_id column. But we have many scenarios where it's helpful to explicitly create an index. Remember as I mentioned that a table can have as many indexes as it needs. Now you don't want to create more indexes than are necessary because there's some overhead in the database management of those indexes. But create as many as you need to make your queries efficient. Now by default, an index allows duplicate values. So by creating an index on the note_title column of our note_info table doesn't mean that two notes can't have the same note title because an index does not automatically enforce uniqueness. But you have the option of creating an index that does enforce uniqueness. And so you just want to do whatever's appropriate for the work you're working on. It's also important to remember that an index is not limited to a single column. One index can span multiple columns. So say, for example, that we frequently search for our notes based on the combination of course ID and note title. Well we could create a single index that included both of those columns. And then when the database was constructing that index, it would construct the index based on the combined values of those columns. So now creating an index is really easy. We use the CREATE INDEX statement. When we create the index, we give it a name. And then we identify what table we want an index applied to, along with the name of the columns in that table we want to be in the index. And then once we create the index, the database will do the work of deciding when's the right time to use it when we perform our queries. So to help us understand what it's like to work with indexes a bit more, in our next clip, let's add some indexes to our database.

Adding Create Index Statements
Here we are in Android Studio. We're looking at the code in our MainActivity class where we load up our notes for displaying in RecyclerView. Now you can see where we issue the query, we include an ordering clause. If we take a look at that ordering clause, we're ordering the query based on two columns, the course_title column from our course_info table, and then the note_title column from our note_info table. With the little bit of data we have in our database now, it's very easy for the data to return back all of our notes in order. But in practice, ordering this data can be very involved. Pluralsight literally has thousands upon thousands of courses, so if we loaded up the database with all the available courses from Pluralsight, that would be thousands of records in our CourseInfoTable. And over time, a user could add hundreds and hundreds of notes into the note_info table. So in that case, ordering all the notes by course title, then note title could be involved. So this is a case where adding an index might help the database return back the list of notes more efficiently. So let's hop over to our data contract class, and over there we'll add some constants that we need to go ahead and create these indexes. So here we are in our database contract class. We'll look into the contract class for our course_info table. Again, we want to create an index on our course_info table. So we're going to define some constants to help us do that, and those constants will use some of the other constants we already have in this class. So let's start out by writing up a comment that shows exactly what we want to create. So we want to start out with a CREATE INDEX statement. So now by using CREATE INDEX, that means that we don't want this index to enforce any uniqueness. If we wanted the index to enforce uniqueness, we would actually say CREATE UNIQUE INDEX. But, again, in our case, we don't want uniqueness. So we'll just use CREATE INDEX. Now each index has a name. Now there's no standard rule for the way indexes are named. What I generally do is just use the table name followed by an underscore and then something like index1, index2, and that sort of thing. So we'll call this index course_info_index1. So then we have to indicate what table we want the index created on, so we use the keyword ON and then our table name. And then we have to identify the columns we want the index created on. Now we only want this created on one column, which is our course_title column. So we'll put an open parenthesis, course_title, and then close parenthesis. So that's a statement we would use to create an index named course_info_index1 on our course_info table that included only the column course_title. If we wanted the index to span multiple columns in that table, we'd just list all the column names separated by commas. So now the first thing we need is a constant for the index name. So we'll call the constant INDEX1. And then its value will be the concatenation of our TABLE_NAME constant along with the literal _index1. So that gives us a constant for the index name. So now we want to add a constant for the actual CREATE INDEX command. So let's go ahead and declare a constant name SQL_CREATE_INDEX1. So we'll start out with a literal string CREATE INDEX, the constant for our index name, the literal ON, our TABLE_NAME, then we'll add our constant for course title and close it in parentheses. So then that gives us a command to create an index on our course_info table that includes only the column course_title. So now we want to do that same thing in our NoteInfoEntry class but do it on that table's note_title column. So let's go ahead and scroll down there. So here we are in the NoteInfoEntry class, and the work to create this index is going to be almost exactly the work we did in the CourseInfoEntry class. So now I copy those lines from the CourseInfoEntry class, let's go ahead and paste them in here. So you notice I'm still naming the index constant index1, but its value will now be note_info_index1 because it's using the TABLE_NAME constant from our NoteInfoEntry class. Most of the CREATE INDEX statement's going to be the same. The only thing that's different is the column name. So we've got COLUMN_COURSE_TITLE. Let's change that to COLUMN_NOTE_TITLE. And so that easily, we now have the CREATE INDEX command we need to create an index on our note_info table's note_title column. So we have the constants in place containing our CREATE INDEX commands for both of our tables. The next thing we need to do is actually add the code to run those commands. And we'll do that in our next clip.

Creating Indexes in the Database
So here we are back in Android Studio, and we're looking at our NoteKeeperOpenHelper class. This is a class that takes care of creating our database for us if we try to open the database and it doesn't exist yet. So we've already got the statements in here to actually create the tables that we need. What we want to do now is run the statements to create the indexes that we need. So now running the statements to create the indexes, will be very much like running the statements to create the tables. So we've got that parameter db, which is our SQLite database reference. So we'll say db. execSQL. First, we want to create the index on our course_info table, so we'll say CourseInfoEntry. SQL_CREATE_INDEX1. And then we'll do exactly the same thing for our note_info table. So with that now, the first time someone runs our application, they open up our class, which will take care of creating the database. They'll have our course_info table and our note_info table along with these indexes. But now if someone actually updates to the application and already had data in the database, it won't create the brand-new database. We actually need to upgrade the database. So there are a few things we need to do to do that. Now, first of all, we need to look at our constant here DATABASE_VERSION. Well version 1 of the database only had the tables. Now that we're adding the indexes, we versioning the database. We're actually transitioning the database from version 1 to version 2. So let's go ahead and change the value of that constant. So now with that where version 1 of the database contained only the tables, version 2 of the database contains the tables and the indexes. So what we need to do now is add the code to upgrade anybody who is on database version 1 to database version 2. So let's scroll down to our onUpgrade method. So here we are in our onUpgrade method. Remember, the onUpgrade in addition to getting a reference to a database gets two version numbers. The oldVersion number is the version the database is currently in. The newVersion is what we're upgrading to. So existing users would have an old version of 1, and we're upgrading to version 2. So what we want to do now is check to see if that oldVersion is less than our current version, which is version 2. And you notice there we're actually checking against the literal value 2 versus our constant database version. And the reason for that is that we actually will evolve this onUpgrade method over time because eventually we'll have a database version 3, database version 4, database version 5, and so forth. And we'll probably want to handle the upgrading of specific versions differently. So what we'll do is add our brackets. I'm going to run the same CREATE_INDEX statements that we ran inside of our onCreate method. So now with that in place, if someone runs the application that had version 1 of the database that only had the tables, our onUpgrade method will run and go ahead and add the indexes of those tables. Let's go ahead and put a breakpoint here on our if statement. Let's just go ahead and run our application now and see what happens. So you can see when we run the application, we hit our breakpoint inside of our onUpgrade method. If we look at the Variables window down below, you can see the old version of the database was version 1, and we're upgrading to version 2. So now if we step through here and go past the if statement, we'll run the SQL to create the index on our course_info table. Step again, create the index on our note_info table. Let's go ahead and release this now and see what it looks like inside the emulator. So here we are with the application running inside the emulator. You can see here in our MainActivity, our RecyclerView is displaying our list of notes. Each note shows its course title and its note title. Obviously I can just go ahead and scroll it, and all that works just fine. And the thing that's interesting to note here is that we didn't change our queries at all. And that's really important to understand. When we added the indexes to the database, we made those indexes available for the database to use. We add indexes that we expect to be helpful for the kind of queries we run, but we don't modify the queries themselves. The database does the work of looking at the query that's coming in, looking at the available indexes, and then using them as it thinks is most appropriate.

Summary
Here are some of the key things we want to remember from this module. Remember that joining tables allows us to return a cursor that combines columns from multiple tables. Remember that we can use the same query method when we're joining our tables as we did when querying a single table. But instead of passing a table name, we pass a join statement. In the join statement, we identify the tables we want to join together, and we identify which columns from each table SQLite should use to match up the table rows. Remember that oftentimes when we join tables, individual column names may be ambiguous due to both tables having columns of the same name. When that comes up, we can simply qualify each column by the table it's a part of. And we want to use table qualified names when we're specifying column names in our join statement. We also want to use them when providing a list of columns we return by the query statement. But when we're interacting with the cursor, we want to be sure to use the simple column name such as when we call the getColumnIndex method. Then we finished up with a look at indexes. Remember that the purpose of an index is to improve query performance. They do that by creating a data structure that SQLite uses to efficiently access column values. Remember that indexes can be used even in cases when a particular column value is not unique. However, it does provide the option to enforce uniqueness if that's what our app needs. Remember that an index can be created on a single column or can span multiple columns. And, finally, remember that indexes don't change the way we write our queries. We create indexes that we expect to be helpful based on the queries our app issues, but the database automatically chooses when to utilize one or more indexes. That wraps up this module, and it wraps up our discussion of SQLite queries. In our next module, we'll look at how we add, remove, and modify data with SQLite.

Interacting with SQLite Data
Introduction
Welcome to our next module, Interacting with SQLite Data. This is the Pluralsight course, Managing Android App Data with SQLite. My name is Jim Wilson. In this module, we'll see how to modify data within a SQLite database. We'll start out with a look at the fundamental concepts of modifying data within SQLite. We'll then see how to update existing data. We'll see how to insert new data. And we'll see how to delete data. And then we'll finish up with a look at how to interact with database data in a way that doesn't interfere with the activity UI.

Making Data Changes
As we go through this module, we're looking at the various ways we can make changes to the data inside of our database. But as we go through things, remember that we're still building on the same basic concepts that were in place when we were querying data. The work we do still requires a connection to the database. We're going to get that connection using our database helper class. But now rather than using the getReadableDatabase method, we're instead going to use the getWritableDatabase method. And that still returns back a reference to a SQLite database. It's that reference that we'll use to perform the actual operations. And all of our interactions are still table based. So our operations are performed against a particular table. And those operations will affect rows and columns within that table. So there are three basic ways that we can change the content within our database. One is an update operation. And that's where we'll actually modify column values of existing rows in a table. Then there's an insert operation, and that's where we create brand-new rows in a table. And then there's a delete operation where we actually remove existing rows from a table. So in our next clip, let's start looking at the update operation.

Updating Data
Now as we mentioned, we use the update operation when we want to modify column values of existing rows in a table. Now we perform the update operation by using the SQLiteDatabase class's update method. Now in order to perform an update, we have to provide several pieces of information. We have to identify the table we want the update applied to. We've got to give the names of the columns we want to change and the new values we want those columns to have. And we have to provide a criteria that the update method will use to select which rows to apply the update to. So let's look at an example. So we'll call the update method. We'll pass in a table name, note_info. So that means this update's going to be applied to our note_info table. Let's give it a column name of note_title. So that means when we call update, we want values of the note_title column to be changed. And we want the new value to be Intent note. So now when we call the update method, we want to be sure to always provide an appropriate selection criteria because without an appropriate selection criteria, this call to the update method could change the value of the note_title column to Intent note for every row in the table. Calls to the update method can affect multiple rows. So in this case, we'll say we want a selection criteria based on the course_id column. We want that to be the course_id column with the value of android_intents. So that says I want to apply the update to any row that has the course ID value of android_intents. So the first row has that course ID value and the third row has that course ID value. So what that means now is that when we run the update method, both of those rows will have their note_title column value changed to Intent note. So one called update can affect multiple rows. And, in fact, a return value of update indicates how many rows were affected. So in this case, we affected two rows in the table. So let's look at another example. We'll call the update method. Again we'll specify the note_info table. Let's go ahead and provide the note_title column again. We'll give that a new value of My new title. But we also want to affect a second column. So we want the column course_id, and we want to go ahead and change this guy to android_async. So, again, remember that it's important that we provide an appropriate selection criteria because without one, this one call to update could change all the rows in the table that have that note title and course ID that we're passing in. So let's say in this case, we want to change a specific note. So our selection criteria will be based on the _id column because remember that each row in a table has a unique value for the _id column. In this case, we'll say we want the row that has an ID value of 2, so that's what the change will be applied to. So this one column to update will change both of those columns. So the note's title is now My new title, and the course ID is now android_async. And the update method will return 1 indicating that it affected one row. So fundamentally calling the update method is really straightforward. We specify the table by simply passing in the table name. But when it comes to specifying the columns and values, we need the ability to specify multiple columns and each of their corresponding values. So we use a class called ContentValues that holds a list of column names and their corresponding values. So the way we add the columns and the values to an instance of ContentValues is by using its put method. And then the last thing we have to provide is the selection criteria. And we do this just like we do with the query method. We pass in a selection clause, then a string array containing the values we want to use with that selection clause. So in our next clip, we'll start adding the code to our application to use the update method to save changes a user makes to a note into our database.

Adding Note Update Method
Here we are in Android Studio. And we're looking at our NoteActivity class. What we'd like to do now is add the code to the class so that any changes a user makes to a note are saved to the note_info table in our database. So just a quick reminder of how things work here in our NoteActivity class. The method we're looking here is the readDisplayStateValues method. Remember that this method is called from our onCreate method. So you can see here where it gets the intent it was passed to the NoteActivity and then gets the ID value from that intent. That ID value is then stored in our field mNoteId. So now once we have that ID stored in a field, we'll use a loader to retrieve the note with that ID from the database. Let's scroll down a bit. We'll take a quick look at that code. So you can see here we're looking at our method createLoaderNotes. And this is the code we added that uses a query to retrieve the note from the database. And you can see here when we issue the query, we use the selection clause based on the note_info table's _ID column, and the selection arguments use the value of our mNoteId field. So we can use that same selection criteria when we're doing an update to the note. So let's scroll back up a bit, and we'll start adding the code to update that note in the database. So here we are the NoteActivity saveNote method. Remember that this is the method that uses saves changes to a note into our application's in-memory data model. So let's add a new method just below that that we'll call saveNoteToDatabase. And this method will handle the details of updating the note within our note_info table. So, again, we'll call saveNoteToDatabase, and I'll have a void return type. And let's have it accept three parameters--one for each of the note values. So that'll be the note's courseId, the noteTitle, and the noteText. So let's go ahead and start out by adding our selection criteria. So we'll have a selection clause based on the note_info table's _ID column. And then we'll have our selectionArgs, which go into a string array. And remember that because mNoteId is an integer, we'll actually have to convert that integer to a string. So now in order to provide the values for the columns, we'll create an instance of the ContentValues class, and we'll assign it to a local variable that we'll call values. So then we'll use the values. put method. We want to provide a value for the course ID column, so we'll pass in that constant. Then we'll pass in our courseId parameter so we set this column value to the value in course_id. We'll call values. put again to set the column value for a note_title column, and we'll set that to our noteTitle parameter. And we'll do the same thing again for our note_text column with our noteText parameter. So now the next thing we want to do is get a connection to the database. So let's declare a local variable we'll name db of type SQLiteDatabase. So now we'll get that from our DbOpenHelper. But because we're going to make changes to the database, we use the DbOpenHelper's getWritableDatabase method. And now we're ready to call update. So we'll say db. update. For the table name, we'll pass in NoteInfoEntry. TABLE_NAME. We'll pass in our values. And then, finally, our selection clause and selection arguments. With that, we have the code to do the actual update to the note in the database. The selection clause and arguments identify which note to update. The ContentValues instance identifies the columns and their values. And then we get a database reference and do the update. And you notice that we're not getting a return value back from update. And that's okay because in this case, we know we're updating exactly one row. If we needed to check how many rows were actually affected, we could just get that return value back from the update method. So for our new method to actually update the database, we're going to need the values from the NoteActivity. So in our next clip, we'll add that code, and then we'll test everything out.

Saving Changes to a Note
Here we are back in Android Studio. And we're continuing our work on our NoteActivity class of updating the database with any changes a user makes to a note. Now as you may recall, when we set up our activity earlier in the course series, the user has no explicit save option. Instead we automatically save any changes to a note whenever the user switches away from that note. Remember than whenever you switch away from an activity, the activity's onPause method is called, and you can see here in our onPause method, we then call saveNote. So saveNote is the method responsible for the details of getting the new values and then initiating the update. So let's scroll down to our saveNote method. So now the way saveNote is currently written, it gets the current values from the views on the activity, and then it updates our in-memory data model. We're going to change this now and go ahead and update our database. And we still need to get the values from the views on the activity. So now for the note title and the note text, that's pretty easy. Those are just edit texts, so we can take the result of getText, and assign those to local variables. So let's go ahead and do that. So that gives us the value of the noteTitle and noteText in local variables. Now getting the course ID is going to take a little bit more work. Remember, the course ID is in the spinner, and that spinner is populated from a cursor. So what we need to do is actually get the user's current selection and get that value from the cursor. So let's go ahead and get rid of this first line here in our saveNote method. Let's create a local string variable we'll call courseId. Let's call a method we'll create named selectedCourseId. So we'll go ahead and create the method, so I'll do Alt+Enter, Enter. We'll accept a return type. Now it's this method's job to determine what course ID corresponds to the currently selected course on the activity. So the first thing we need to know is what position is currently selected in the spinner. Let's declare a local variable here of type int. We'll name it selectedPosition. Then we'll call the spinner's getSelectedItemPosition method. So that gives us the selectedPosition. Now we need to figure out what course ID that corresponds to. So in order to do that, the first thing we need to do is get a reference to the cursor that's associated with the adapter that populated the spinner. So we'll create a local variable here of type cursor, and we'll assign it the result of mAdapterCourses. getCursor. So now once we have the cursor, we can use the selectedPosition to make sure the cursor's currently at that position. So we'll call moveToPosition and pass in selectedPosition. So now that we've got the cursor position correctly, the next thing we need to know is what's the index of the column that contains the course ID. So let's declare a local variable here of type int. We'll name it courseIdPos. And then we'll use the cursor's getColumnIndex and pass in the name of the course_id column. And then once we have that, we can actually call the cursor's getString method to get the value of that column. So let's assign it to a local variable of type string that we'll name courseId. So with that now, we'll actually have the course ID that corresponds to the user's current selection in the spinner. So all we need to do now is go ahead and return that back. So now with that, we've got our course ID from the spinner. So what we want to do now is go back up to our saveNote method. Let's add a line to the end of that. And we can go ahead and call our saveNoteToDatabase method and pass in the courseId, the noteTitle, and the noteText. So we now have all the code in place to actually update a database with any changes a user makes to a note. So let's go ahead and run this guy and see what it looks like. So here we are with our code running in the emulator. We can see our list of notes displayed here in our MainActivity. Let's just scroll down here a little bit. And let's say we want to make a change to this note here that's part of the Java Fundamentals: The Java Language course and has the note title Anonymous classes. So we'll go ahead and select that. That displays it on the NoteActivity. And let's make some changes. Let's go up here and change the course it's associated with. So I'll select a different course. I'll select the Android Async Programming and Services. So let's go ahead and make some changes to the title and the text as well. And we'll just do something we can see really easily. So at the end of the title, we'll just add a bunch of Xs. And to the end of the text, let's just add a bunch of Ys. So now if we've done everything correctly, when we return back to our MainActivity, we'll update the values in our database with these changes to the note. I've added some breakpoints for our code so we can see what happens. Let's go ahead and hit the Back button, hit it again. So you can see we hit our breakpoint here inside of saveNote. That's where we call our selectedCourseId method to get back the course ID. So let's go ahead and take a step. And you can see there now the courseId is android_async, so it's actually changed the course ID to correspond to selectedCourse. Let me go ahead and release this. You see now we're inside saveNoteToDatabase where we've already set up our selection criteria. And now we're creating our ContentValues. We're going to put in the values for all the columns. I'll go ahead and release it again. Now I'm going to get the connection to the database. Let's go ahead and take a step. And now I'm going to issue the actual updates. We'll step again. So everything ran correctly. So let's go ahead and release this and see what it looks like in the emulator. And if you'll look here in the emulator, you can see that the note has the title Anonymous classes with a bunch of Xs at the end and is now associated with the course Android Async Programming and Services. So our note updated and is being displayed in our MainActivity. Let's go ahead and select it again. And here you can see it in our NoteActivity now associated with the correct course, Android Async Programming, and our title and our note text all have the changes we made. And this is really cool. If we really think about all the things that just happened. Our MainActivity class got back the list of notes from the database. We selected a note, went over to our NoteActivity. The NoteActivity got that note back from the database. We made changes to that note. When we left the NoteActivity, it updated the database. The MainActivity re-read the notes from the database, displayed the changes. And when we selected that note on MainActivity, we again went to our NoteActivity, which re-read the note from the database showing all of our changes. So we're getting pretty far along here. Our application's beginning to really interact with the database quite a bit. So now in our next clip, let's see how we can insert new rows into a database and delete rows from the database.

Inserting and Deleting Data
So let's take a look now at inserting data into the database. And when we insert data, we're actually creating a new row in a table. So we'll perform the insert operation using the SQLiteDatabase class's insert method. When we do the insert, we have to identify what table we're inserting into, and then we have to identify what we want the column values to be in on our new row. And so we do that again using our ContentValues class. So let's take a look at an example. So I want to do an insert. I've got to I identify what table I want to insert the row into. Then we have to identify the column values for our new row. Let's say we want our new row to have a note_title of My new note, note_text of I love Android, and then a course_id of android_async. So when we execute this method, it will insert one row with those column values. Now in the case of the insert method, the return value is actually the ID column value of our new row. So we can then use that return value to locate the row that was just created by our insert method. And then, finally, we have the delete operation. And the delete operation removes one or more rows from a table. So we use the SQLiteDatabase class's delete method. We identify what table we want to delete rows from, and then we provide our selection criteria--which criteria we want to use to decide which rows to remove. So, again, we'll take a look at an example. I want to call delete. Let's say I want to delete from the note_info table. And now I provide our criteria. So I want to delete based on the value of the course_id column, and I want to delete the rows that have a course_id of android_intents. So we'll look at our data. The first row and the third row each have a course_id value of android_intents. So then when we execute the delete operation, those two rows are removed permanently from this table. Now the delete operation again returns the number of rows affected. So in this case, it would return a 2 saying that it actually deleted two rows. So now in our next clip, let's see how we can utilize the insert and delete operations in our application's NoteActivity.

Note Database Operations in Your App
Throughout this course, we've done a lot of work to transition our application to work directly with the database. So our MainActivity now reads all the notes directly from the database, displays them in our RecyclerView. The user selects the note in our MainActivity. The NoteActivity then reads that note directly from the database. The work we did a little bit earlier in this module had the capability in NoteActivity where when the user hits the Back button, we can now go ahead and update that note directly in the database. So our application's coming pretty far. Let's look at a couple of other scenarios. What happens in this scenario when the user wants to create a new note? Well if you think back to our very first course in this series, we talked about the standard behavior of Android applications. And when following this standard behavior of Android applications, whenever the user takes an action that wants to create a new something, we want to create the backing store for that new something right away. So what that means in this case is when the user is creating a new note with our NoteActivity, we want to go ahead and insert a row for that note into our database right away. Now, initially, we don't know what values we need to store that note. So we can just put some placeholder values in there when we first create the row. But by creating that backing store right away with the insert operation, when the user hits the Back button, the code we've already written to do the update will now update that row with whatever values the user has entered into the NoteActivity. So that takes care of the scenario of the user creating a brand-new note and wanting to save the values. But what happens in the case where a user creates a brand-new note is we insert that new row, but then the user hits the option on our NoteActivity that says, I want to leave without saving. Well if the user leaves without saving anything, that row we just created with the insert would stay in our database. So we'd have a row in our note_info table that doesn't have any real note values associated with it. So what we need to do in the case where a user's created a new note but then says they want to leave without actually saving that note, in that case, we then need to delete that note that we just created. So in our next clip, let's start implementing this behavior.

Inserting a New Note
Here we are back in Android Studio, and we're again looking at our NoteActivity class. What we want to do now is add the code that'll insert the initial row for our note into the note_info table when the user's creating a brand-new note. So we're looking here at the readDisplayStateValues method. And as you recall, this method is called from the onCreate method. So the first thing it does is get a reference to the intent that started our activity and then get the note ID that was passed with the intent. But now if there was no note ID passed with the intent, it's set to the constant ID_NOT_SET. And we use that constant to indicate that we're creating a brand-new note. So that sets our field mIsNewNote. And if it is a new note, it calls the createNewNote method. And you can see that we have our createNewNote method, and currently the createNewNote method creates an empty note in our in-memory data model. So we want to change that to now create a new record in our note_info table. So let's go ahead and scroll the screen here just a little bit so we have some room to work. And then let's go ahead and remove all the existing code from createNewNote. So now in order to insert a new row into a table, we need to provide the values that we want to put into that row. We specify those values in our ContentValues class. So let's create a new instance of ContentValues, and we'll assign it to a local variable named values. And we want to use our ContentValues instance to specify the values for each individual column we want it to put into that row. So when we're inserting this new row, we don't really know what values the user wants to associate with the note we're about to create. So what we can do is just put some placeholders into each of the columns. So let's just go ahead and set each column to an empty string. So now with that, now we have the COURSE_ID column, the NOTE_TITLE column, and the NOTE_TEXT column all set to be the empty string. So now we'll go ahead and do the insert. Now in order to do the insert, we need a connection to the database. So we'll use our mDbOpenHelper and call its getWritableDatabase method. So now our db variable has a reference to the database. So we'll go ahead and call db. insert. We identify the table we want to insert into, so that'll be our NoteInfoEntry. TABLE_NAME. We don't need to use the insert method second parameter, so we'll pass null for that. And then we pass our values as the third parameter. So when we run this code, we'll insert a new row into our note_info table, and all the columns in that row will be set to the empty string. Now, of course, what we want to have happen is when the user actually starts entering data for the note, and that note's saved, we want to update this row with those values. So that means that we actually need to know the ID of this row. And remember that the insert method returns back the row ID. So we want to assign the return value of the insert method to our field mNoteId. So you can see there now that that line is underlined in red. And the issue there is that our mNoteId field is an int, but the insert method returns back a long. So we'll just go ahead and cast the return value to an int. So now our mNoteId field will have the ID of that brand-new row we just created. So then when the user leaves the activity, the update code we wrote earlier will update that row with whatever values the user has entered. So let's go ahead and run this guy and test all that out. So here we are now with our code running in the emulator. Now I've added some breakpoints to our code so we can see what happens throughout the process of creating a new note. So let's go ahead and click the button here to create a new note. So when I do that, we have the breakpoint and our createNewNote method. Let's switch back to Android Studio. So here in Android Studio, you can see we're at the line. We're about to connect to the database. So we've got all of our column values and our values variable. Let's go ahead and step. We get our database connection. So now before we step again, let's look down at the Variables window. Now you see we have our mNoteId field. Now currently that has a value of -1, which is the value which it's initially set to when we're creating a new note. So let's go ahead and step again and do the actual insert. And you see once we do the insert, mNoteId now has a value of 9. So that's the ID of that row we just created. So let's go ahead and release this now and head back to the emulator. So here we are back at the emulator looking at our NoteActivity screen, and we're creating our new note. So let's go ahead and choose a course for it. So I'll click the drop-down. Let's choose Android Programming with Intents. Let's give it a title of My new note. And we'll set the text to something like Text for my new note. So let's go ahead and hit the Back button once to get rid of the keyboard. Let's go ahead and hit it again. And you can see now Android Studio has hit a breakpoint again when we're trying to save the note. So let's switch back to Android Studio. So our saveNote method gets all the values off the screen, and then it calls our saveNoteToDatabase method that we wrote earlier. So let's go ahead and release this, and we'll hit a breakpoint inside of saveNoteToDatabase. So here at our breakpoint inside of saveNoteToDatabase, if we look down at the Variables window, we can see that we have the values that we entered. We have the courseId, it's android_intents. The noteTitle is My new note. And the noteText is Text for my new note. And then notice that our mNoteId field has a value of 9. That's the ID of the row that we just added to the note_info table. So if we go ahead and release this now, we get the connection to the database. Then we go ahead and do the update. And now we've updated the row that we created with the values the user just entered on screen. So let's go ahead and release this now and see what things look like inside the emulator. So here we are in the emulator now looking at our MainActivity. Let's scroll down here a little bit. And you'll see as we scroll down, there's that note that has a title, My new note, associated with the course, Android Programming with Intents. If we go ahead and choose that, we can see that our note shows up in our NoteActivity with the correct course, the correct title, and the correct text. So we've now done all the work to add the ability for a user to create a brand-new note and then have that note correctly saved into the database. And that's another really cool improvement to our application. Our application is getting more and more functional with the database. So now in our next clip, let's add the code to delete that new record in the event that the user decides that they don't want to actually save it.

Deleting Unused Note
Here we are back in the Android Studio, and we're continuing our work on our NoteActivity class. And what we want to do now is add the code that will delete the row from the note_info table that we just inserted when the user was creating a brand-new note if the user decides they don't want to save that new note. So now we're currently looking at our onPause method. Remember, the onPause method gets called when the user is switching away from an activity. Now you notice towards the bottom of the onPause method, we call saveNote. So that's what actually initiates the process of saving a note when the user switches away from the activity. But you notice in our onPause method, we have an if block to check to see if the user's actually cancelling. So the user's saying, I want to leave this activity without saving the changes I've made. And then when the user's cancelling, we have a check to say, Well, are they cancelling a note they just tried to create? And in the event that they're cancelling on a note they just tried to create, we want to go ahead and get rid of the backing store that we just created for that new note. So the code you currently see there did the work of removing that note from our in-memory data model. What we want to do now is add the code that will actually delete that note from the database. So the first thing we'll do is get rid of the line that removes the note from our in-memory data model. Then let's call a method we'll create named deleteNoteFromDatabase. We'll do Alt+Enter to create the method. We'll create it. And we'll accept our return type. So when we're doing a delete, the first thing we need to do is specify our selection criteria. Now in this case, we want to remove the note with a specific ID. So we'll set our selection clause to use the note_info table's _ID column. And then our selectionArgs will be the mNoteId field. So now once we have our selection criteria, we need to go ahead and get our connection to the database. Then we'll use our database connection to call the delete method. We want to delete from the note_info table. Then we pass in our selection clause and our selection arguments. So what this code will do now is delete the row from the note_info table that has the ID value that's contained in our field mNoteId. So now this deleteFromDatabase method is only called in the case that the user has just said they want to create a brand-new note and then says they want to leave the NoteActivity without saving that note. So what ends up happening then is when the user clicked the button to create a new note, we created that initial row in our note_info table. So then if they're cancelling out, we just go out there and delete that row because we no longer need it. So let's go ahead and run this guy now so we can see how it all works. So here we are with our app running in the emulator. I've added some breakpoints to our code so we can see what happens as we go through the different steps. So let's start by clicking on the button to create a new note. You can see we hit our breakpoint inside of Android Studio. So let's switch to Android Studio. So here we are in Android Studio looking at our createNewNote method. You can see we're about to get our connection to the database. So we'll go ahead and step. Then we'll go ahead and do the insert, so we'll step again. So we can see there the new note we created has an ID of 10. So let's go ahead and release this. So now here in the emulator, if we want to create a new note, we would type in the values and just hit the Back button. But in this case, we want to cancel out without saving anything. So we'll go ahead and hit our Cancel option here. You'll see we hit our breakpoint in Android Studio. So let's switch back to Android Studio. So here in Android Studio, we're in our deleteNoteFromDatabase method. And if you look down at the Variables window, you can see there's an mNoteId of 10. So we're about to delete the note we just created. So we'll go ahead and step, step again. And now that row is removed from the database. So let's go ahead and release our application. And now our application handles the flow of creating a note and saving it or creating a note and deciding you don't want to save it. So our application is just about set with regard to its interaction with the database. There's one more thing we need to look at. So in our next clip, we're going to look at how to perform operations like update, insert, and delete in a way that doesn't impact the performance of our application user interface.

Database Interaction and Activity UI
As you recall from our discussion earlier in this course about performing queries with loaders in the loader manager, it was important that we not perform operations that prevent the application's main thread from being available. Well it turns out that we need to keep that same issue in mind even as our app performs update, insert, and delete operations. So when our application is running, there's that main thread that's responsible for taking care of the user interface. Well if we try to do something like an update, insert, or delete operation from that main thread, that thread is now tied up until that operation completes. So that could create the experience of the user interface freezing until that operation is done. So what we want to do is code our applications to not interfere with that main thread. So when our main thread is running and it becomes time to do a database operation, what we need to do is hand that operation off to a different thread and let the operation run on a thread that's not our main UI thread. And that way the main UI thread remains available to take care of the user interface. So now what that comes down to then is that we always want to avoid doing any kind of database action on the UI thread. Whether it's a query, an update, in insert, or a delete, or even a request for a database connection, we don't want to do any of those things on the UI thread. So we're not going to execute any kind of database operation on the UI thread. Now we know in the case of queries, we have the loader and the LoaderManager. But when it comes to doing our updates, inserts, and deletes, there isn't a specific framework for moving the work off the main UI thread. But we can use any of a variety of threading solutions that are available in Android. Now we'll talk about some of those solutions in detail a little bit later in the course series. But when it comes to doing database operations, a common solution we use is a class called AsyncTask. We tend to use AsyncTask because it makes it very easy to do our database work in a way that doesn't interfere with the user interface. So the first thing we have to do is actually implement the database interaction. We do that by extending the AsyncTask class. Now the AsyncTask class has a number of methods we can override. But the one we're interested in is one called doInBackground. So we'll override doInBackground, and then we'll add our database code to the method doInBackground. With that work done, it's very easy for us to perform the database interaction in a background thread. Basically we take our class that extends AsyncTask, and we call its execute method. And then the AsyncTask class will take care of the details of running that doInBackground method on a non-UI thread. To give us a better sense of what this looks like, in our next clip, we'll modify our application to perform our database operations using the AsyncTask class.

Interacting with the Database Using AsyncTask
Here we are in Android Studio. We're looking at our NoteActivity class's deleteNoteFromDatabase method, and what we want to do now is use the AsyncTask class to perform our database operations in a way that doesn't interfere with the user interface. Now remember when we use the AsyncTask class, we need to override the doInBackground method. But we can just do that here as an anonymous class. So let's start up by creating a variable of type AsyncTask, and we'll just call it task. So we want to create a new AsyncTask. But rather than type that all the way out, let's just do a Ctrl+Space, and we'll let Android Studio finish it for us. So you see Android Studio stubs out our doInBackground method. Now one thing we want to do is make sure we have a semicolon here at the end of our statement. Now what we want to place in the doInBackground method are the lines that actually interact with the database. And so that's both the database connection and the delete statement. So let's go ahead and highlight those guys. We'll cut those. And let's go ahead and paste them into our doInBackground method. So you'll notice there when we called delete, the selection and selectionArgs variables are both underlined in red. That's because they're local variables in our deleteNoteFromDatabase method. Now as you may recall from Java, whenever local variables are used in the body of a method within an anonymous class, those variables need to be marked as final. So let's mark our selection and selectionArgs declarations as final. So with that now, our AsyncTask implementation is all set. We've got all the code we need in the doInBackground method. All we need to do now is execute our AsyncTask. So let's go ahead and add a little line here, and we'll say task. execute. So now when we call task. execute, the AsyncTask class will take care of the details of running the code in our doInBackground method on a non-UI thread. So let's go ahead and run this guy now and see what happens. So here we are now with our code running in the emulator. Let's go ahead and click the button for a new note. And once we get into our new note, let's go ahead and cancel out of here. So when we cancel, we hit one of the breakpoints that I added to our deleteNoteFromDatabase method. So let's switch back to Android Studio. So you see here in our deleteNoteFromDatabase method, I've got a breakpoint on the first line, which is the breakpoint we're currently stopped at, but then I have a breakpoint in the body of our doInBackground method, and I have a breakpoint in our call to execute. So I'm going to go ahead and release this now and see what happens. You see when I released it, it went to the call to execute. It hasn't run our code in doInBackground yet. It won't run that until we call execute. So I'll go ahead and release it again. Now see when we call execute, then the AsyncTask class took care of running the code in our doInBackground method on the background thread. Let's go ahead and release it again. And now let's switch back to our emulator. So our application now is interacting with the database correctly when it does a delete. Again, we would want to do that same thing with AsyncTask when we call insert and when we call update. So now with all the work we've done in this course, our application is now a full-blown database application. Our MainActivity and our NoteActivity query the data from the database using loaders and LoaderManagers so they don't interfere with the user interface. Our NoteActivity knows how to update records in the database, insert records in the database, and delete records from the database. And we can do those also without interfering with the user interface. So throughout this course, we've transformed this application from being an application that relies on a transient in-memory data model to now being an application that's able to fully persist its data using a SQLiteDatabase.

Summary
To wrap up, here're some of the key things we want to remember from this module. Remember that when we're connecting to the database to perform modification operations, we use our open helper class's getWritableDatabase method. Remember that all of our interactions are still table based, so the operations performed against a table and those operations affect rows and columns within the table. Remember that we use the update operation to modify column values of existing rows. Those column values are provided with the ContentValues class. And remember that the update operation will affect as many rows as match the criteria. So one call to update can change multiple rows. So the update method returns back the number of rows that were affected. We used the insert operation to create a new row in the table. Again, the values are provided with the ContentValues class. But in the case of the insert method, it returns back the value of _ID column of our newly created row. We used the delete operation to remove existing rows from a table. And, again, it will affect as many rows as match the criteria. So the delete method returns back the number of rows that were affected. Remember that we want to avoid doing any kind of database actions on the user interface thread. We don't want to connect to the database, and we don't want to perform any operations. There are a number of different ways available to avoid performing our database operations on the user interface thread. But as we saw, one of the easiest ones to use is the AsyncTask class. That wraps up this module, and it wraps up this course. Now with the work we did in this course, we now have a full-featured application that matches its data persistently using a SQLiteDatabase. In our next course, we'll learn how to extend our application experience beyond the app itself by using Android features like content providers, notifications, and pending intents.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Intermediate
Rating
4.8 stars with 34 raters(34)
My rating
null stars

Duration
4h 28m
Released
11 Aug 2017
Share course