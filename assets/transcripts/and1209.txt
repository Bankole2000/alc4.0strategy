Kotlin on Android: Managing Preferences and Settings
by Mitch Tabian

Every Android application has some kind of settings screen. In this course, you’ll learn how to leverage SharedPreferences and the Preferences framework to build excellent settings screens that conform to Androids design guidelines.

At the core of modern mobile applications is a thorough understanding of SharedPreferences and Settings Screens. In this course, Kotlin on Android: Managing Preferences and Settings, you will learn how to leverage SharedPreferences and the Preferences framework. First, you will learn about the Preferences framework, which helps you conform to Android's design guidelines and provide a consistent user experience. Then, you will use SharedPreferences to save, edit, and retrieve key-value pairs saved locally on the Android device. Finally, you will implement a number of different interfaces for detecting when changes occur to Preferences and SharedPreferences. When you’re finished with this course, you will have a foundational knowledge of SharedPreferences and Settings Screens that will help you as you move forward to develop mobile applications.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
0 stars with 7 raters
My rating
null stars

Duration
1h 21m
Released
18 Jul 2018
Share course

Course Overview
Course Overview
Hi. My name is Mitch Tabian, and welcome to my course, Kotlin on Android: Managing Preferences and Settings. I'm a self-employed Android developer, and I'm here to teach you about SharedPreferences and settings screens using Kotlin. Having a solid understanding of SharedPreferences and building settings screens is absolutely fundamental to every Android application. It's so important that the Android team built a special framework to assist developers in creating a consistent experience. Some of the major topics that we'll cover include the Preferences framework. If you're building a settings screen, you need to use the Preferences framework. It'll help you conform to Android's design guidelines and provide a consistent user experience. SharedPreferences. We'll use SharedPreferences to save, edit, and retrieve key value pairs saved locally on the Android device. Preference listeners. It's not enough to be able to save preferences. You need to know when they've been changed. We'll implement a number of different interfaces for detecting when changes occur to Preferences and SharedPreferences. By the end of the course, you'll have an excellent understanding of how you can use the Preferences framework and SharedPreferences to build settings screens. Before beginning the course, you should be familiar with Android Studio, and I recommend watching the course named Android Apps with Kotlin: Building Your First App by Jim Wilson. I hope you'll join me on this journey to learn about preferences with my Kotlin on Android: Managing Preferences and Settings course at Pluralsight.

Getting Started
Introduction
My name is Mitch Tabian, and welcome to my course, Android Apps with Kotlin: SharedPreferences and Settings Screens. Since Kotlin was introduced at Google IO in 2017, I've been very excited about it. In my opinion, Kotlin will most certainly become the mainstream programming language when it comes to Android development. I think it'll take quite some time, probably 5 to 10 years, but it'll happen. I think Java and Kotlin will follow the same trend as Objective-C and Swift did with iOS development. Objective-C was a dominant language, but now Swift is definitely used by more developers. I feel very fortunate to be given the opportunity to make a course on an incredible programming language in its early stages. That's enough talk about opinions and gratitude. Let's take a look at the application that we'll be building in this course. So sit back, relax, and enjoy the demo. This is the application. It's a notekeeping application for keeping track of notes as users watch Pluralsight courses. If you're not aware already, this is actually the fifth course in the Android Apps with Kotlin series on Pluralsight. The courses build upon one another and reference the same application, the NoteKeeper application. We're going to be taking the NoteKeeper application to the next level by building a settings screen and an account settings screen. I'll walk you through them. This is the main screen of the app. It's a recycler view that contains some notes. If I click on the menu in the top right, there's a Settings option. That's how we'll navigate to the Settings screen. I'll click it. Here is the main Settings screen. The first thing I want you to notice is that it follows the Android design guidelines for building a settings screen. All settings screens should be very similar. They should be similar because they're all built with the same framework, the Preference framework. The Preference framework provides UI building blocks that we can use to construct settings screens that conform to the Android guidelines. Each of these UI building blocks will save automatically when they're changed. The changes are saved locally on the Android device. For example, if I was to change this setting, the new value is automatically saved. I don't have to write any code to do that. If I press the Back button, then navigate back to the Settings screen, notice the setting is saved. If I want to do something with the new value or maybe update the value on a server, I can use a PreferenceListener to notify me when a preference has been changed. Pretty convenient stuff. There's also preferences that can send users to URL links on the internet. Notice the Send Feedback preference, the FAQ preference, Privacy Policy, and the Terms and Conditions. If I click on any of these preferences, I'm taken to an internet URL. For example, the Privacy Policy takes me to Pluralsight's Privacy Policy. That might not seem incredible to you, and you're right. It's not that incredible looking from the outside. But when you see the code and how simple all this is to do, I guarantee you'll be amazing. Just to reiterate, all this is done with Android's Preference framework. Now let's talk about SharedPreferences. If I scroll up to the top, there's a preference that says Account Settings. There's a little description below that says Edit account settings, so I'm going to click it. This is what I like to call the Account settings screen. The data here is saved using SharedPreferences, and the UI is built using a standard Android layout file that I made. All these properties are editable. For example, I can change the name here, then click the checkmark, and the property is saved to SharedPreferences. Also notice, if I click the checkmark and no properties have been changed, the progress bar does not spin. That's because I'm using a SharedPreferencesChangeListener to detect when the changes occur. So if there's no change, the progress bar does not update. You'll also be able to change the profile photo. If I click the widget, I'm prompted with a dialog that has two options, choose a photo from the phone's memory or take a new photo with the phone's camera. I'll choose one from memory. As you can see, the image was updated in the widget. Now I'm going to save the changes by clicking the checkmark. That's all there is to the application. Thanks for watching, and enjoy the course.

Prerequisites and Dependencies
As I mentioned in the introduction, this is the fifth course in the Android Apps with Kotlin series on Pluralsight. That being said, the other courses aren't required. This course can definitely stand alone, but you'll probably get the most out of it by watching the other courses also. The only one I actually recommend watching before this one is the first course in this series. It's called Android Apps with Kotlin: Building Your First App by Jim Wilson. If you're completely new to Kotlin, that's going to help you get a good grasp of the general concepts before starting my course. Now let's talk about the dependencies. I wanted to keep things as simple as possible, so I tried not to use many external dependencies. The cardview dependency is used in the prerequisite courses. It's not actually used in my course. The support design dependency is needed for toolbars, navigation drawers, recycler views, and other components. We'll be using the glide library to set the profile image in the Account settings screen. And we'll be using this circular image view dependency to easily incorporate a circular profile image view. I'll be targeting and compiling to an SDK version of 27 and specifying a min SDK version of 21.

The Story Behind the App
You are an Android developer that absolutely loves Kotlin. And lucky for you, the job that you've been hired for wants you to program with Kotlin. You've been hired by Pluralsight to build a notetaking application. You're working on a team with a handful of other developers, and you've been assigned to build the settings screens. You've decided to build two settings screens. One will be a settings screen constructed with Android's Preference framework. That will ensure it conforms to Android's design guidelines, and it shouldn't take long since the Preference framework is very simple to use. The second screen will be a more personalized account settings screen. This screen will be constructed with a classic Android layout file. The file will contain a number of edit text fields for capturing input, maybe a spinner or two, and a profile image. The inputs will be saved using SharedPreferences. All code is to be written with Kotlin.

How to Use the Source Code Files
For your convenience, I've added the source code files to a GitHub repository, and I've also attached them to the exercise files for the course on Pluralsight. I recommend using the code on GitHub since it's easy to switch between modules and clips. But if you want to get the code from Pluralsight, you're more than welcome to do that too. Let's walk through how to get the code from GitHub. Start by launching Android Studio. Then click on the Check out project from Version Control option right here. Here's where you're going to put the GitHub repository URL. Open GitHub, and let's go grab it. Navigate to github. com/mitchtabian/NoteKeeper. Click Clone or download and copy this URL. Go back to Android Studio and paste the URL right here. Now click Clone. This message will pop up asking if you want to open the project that you just referenced. Click Yes. Another dialog will pop up asking if you want to add this vcs. xml file to Git. You can click No. You can always click Yes later if you want to. If you already had a project open, you can also import from Version Control by going to File, New, then import project from Version Control, and then just select GitHub. If you're getting any kind of an error at this point, I suggest going to File, Invalidate Caches and Restart, and then click Invalidate Caches and Restart. If you have any issues with loading the source code while following along with the course, the first thing you'll want to try is invalidating the caches and restarting. Now reopen the project. You should be greeted with a dialog that looks something like this. Make sure everything's checked and click OK. Notice that I can't click the Play button yet, so there's still a problem. Open the Logcat. Android Studio is telling us we need to configure the SDK, so click Configure. I'm going to choose Build Tools Version 27. 0. 3 since that's the newest version. Now I'll click OK. If you're still having issues, make sure your Android Studio is the same version as mine, 3. 0. 1, and all the SDK tools are up to date in the SDK Manager. Now accessing the code for each clip is really simple. Just click down here where it says Git, drag this window upwards and expand it, and these are all the clips for the course. So if you wanted to open the source code for the start of the module named defining-preferences-in-xml, then you select the branch named 3. 3. defining-preferences-in-xml-start. If you wanted to see the code for the end of that module, you would go to 3. 3-defining-preferences- in-xml-end, click Checkout as new local branch, and click OK. Now all the code is updated. Let's do another example. Suppose you wanted to open the code for the module named building-a- unique-settings-screen. Once again, click down here. Select 4. 2, building-a-unique-settings-screen-start, Checkout as new local branch, and click OK. Now you're ready to start that module. Keep in mind that once you've checked out a branch, it will be added to the local module section here. If you want to open that same branch in the future, just click it, then select Checkout. You don't need to use Checkout as new local branch since it's already a local branch. If the naming of the branches is confusing to you, let me explain by referencing one of my other courses on Pluralsight. At the time I'm filming this, this course is obviously not published yet, so we'll have to reference a different one. Here's another one of my Android courses. It's called Android Gestures: Getting Started. Pretend we're working on this course, and we just imported the code from GitHub, just like I just showed you. This would be module 1, this would be module 2, this would be module 3, and so on. That's how I've named the branches for this project. Now you're ready to start the course. You can easily access the code for each module by selecting the branch.

Building a Settings Screen
Introduction
Building a settings screen is an important part of every Android application. There's always going to be certain things that users need the ability to customize, and it's usually best to save those properties locally on a device. The Preferences framework was built specifically with settings screens in mind. That is, it's literally made for building settings screens. It contains special UI building blocks that developers can take advantage of and construct a layout. The most beautiful thing about the building blocks is that you don't need to write any code to save changes made by the users. When the user changes a setting, it's automatically saved in a preference file for the application. So literally all you need to do is build the layout using special XML building blocks, and it's good to go. It's a beautiful thing. One question you might have at this point is but Mitch, what if a user has multiple devices, like a tablet or a second phone? The preferences would only be saved locally on each device. If that's your concern, you're right. The preferences are saved locally in a file on a device. To keep the data consistent, you'll need to upload the settings to a server. Then you can have the application query the server and check for the updated settings. The Preferences framework has listeners that are perfect for facilitating that. We can set PreferenceChangeListeners to listen to the keys of the preferences. Then when there's a change, we can upload the changes to a server. We're going to take a close look at PreferenceChangeListeners in the module named Implementing Preference Listeners. Another great thing about the Preferences framework is that your settings screens are guaranteed to meet Android's design guidelines. You're building the layout with special UI building blocks, so there's basically no way you can mess it up. I don't know about you, but not being able to mess something up sounds pretty good to me.

Implementing a Preference Fragment
We're ready to get started building a settings screen with the Preferences framework. Check out the branch names 3. 2-implementing-a-preference-fragment-start. Building a settings screen with the Preference framework requires a special type of activity or fragment. If we take a look at the documentation, there's two options. Visit this URL. The documentation says Because your app's settings UI is built using Preference objects instead of View objects, you need to use a specialized Activity or Fragment subclass to display the list settings. Below that it says If your app supports versions of Android older than 3 or API level 10 and lower, you must build an activity as an extension of the PreferenceActivity class. And then just below that it says On Android version 3 and later, you should instead use a traditional Activity that hosts a PreferenceFragment that displays your app settings. So basically what the Android team is telling us is that we need to use a PreferenceFragment hosted in some activity, any activity, and that's what we're going to do. The activity we'll host the PreferenceFragment in is ItemsActivity. Open it up. This is ItemsActivity. It's the main screen with a list of notes. We want to open our PreferenceFragment when the Settings option is selected from the menu up here. Let's build the fragment. Right-click on the main package directory, go to New, Kotlin File. We'll call it Settings/Fragment, and I'll change this to say Class, not File. Since we're using the Preference framework, we're going to extent the class by PreferenceFragment. That's all we're going to do in here for now. I just want to create the Fragment class. We're not going to inflate any Preferences objects or any views. Go back to ItemsActivity. Our next task is actually adding the PreferenceFragment to a container because remember, all fragments must have a container, and that container must live in an activity. Open ActivityItems. Notice I've added a FrameLayout to the layout file. Its ID is settings_container, and that's where our PreferenceFragment is going to live. Go back to ItemsActivity. There's only ever going to be a single instance of SettingsFragment at any given time, so I'm going to create a global variable just for that. Since we're going to be assigning it later, we need to use the var key word. Remember val is only for immutable objects, or in other words, objects that will not be reassigned again. It's going to be of type SettingsFragment, and it's going to start as being null. Scroll down to just below the onOptionsItemSelected method. We're going to build the build for actually inflating the fragment and then adding it to the container. Call it inflateSettingsFragment. To confirm the method gets called, I'm going to add a log that says inflating settings fragment. If the fragment is null, we want to instantiate a new one. Declare a FragmentTransaction object. Notice I'm using the fragmentManager object and not the supportFragmentManager object. For 99% of situations, you'll want to use the support version because it's compatible with more Android versions, but PreferenceFragments are not, so we need to use the old version. Replace the fragment in the container. The FRAGMENT_SETTINGS constant is in the constants file in case you're confused. Add the transaction to the back stack and finally commit the transaction. Call the method in the action_settings case up here in the onOptionsItemSelected method. Run it, and let's make sure we can see the log output. I'll click the menu and select Settings. There is the log output that we were looking for. Now we're ready to build the preferences layout in XML and inflate the view.

Defining Preferences in XML
Check out the branch named 3. 3-defining-preferences-in-xml-start. By the end of this video, we'll have the view for settings_fragment inflating, and we'll have the preferences ready to use. We'll be able to alter the preferences, and the changes will be saved automatically. I can't wait to show you just how simple this is. As I mentioned earlier, the layout for a PreferenceFragment is a little different than a regular fragment. With a regular fragment, you create a layout file that goes in the layout folder. But with a PreferenceFragment, you need to keep the layout file in an xml folder. I don't even know if it would be correct in calling it an actual layout file because it's just so different. If you take a look at your project's xml folder, you'll see a file named pref_main. Open it up. Here's the layout for the settings screen. At first glance, this might look complicated, but it's actually incredibly simple. I absolutely love the way the Android team implemented this. We're going to walk through it slowly, and I promise by the end of the video, you're going to be an expert on this topic. The opening tag is a PreferenceScreen container. I think this is very intuitively named. It's obviously the parent layout for a preference screen. Next we have a PreferenceCategory container. Every section of the PreferenceScreen should be part of a PreferenceCategory. This is the first one. It corresponds to this General header in the layout. You can see there's several others, Data, Notifications, and if you scroll down a bit, About. Before I move on, I want you to take a moment and appreciate the simplicity here. Every one of these headers has a perfect margin, perfect padding, perfect text formatting. Everything is identical, and it's all implemented in two lines of XML. It's a beautiful thing. If I was to build the exact same thing with a text view in a regular layout, there would be a massive amount of overhead. And the amount of code would be like 10 times that. And then even still, I'd have to copy/paste that huge amount of code for each header. When you consider all that, this truly is elegant. Alright, moving on. This first PreferenceCategory has a single Preference object. This is the most primitive type of a Preference object. Basically it's just a view that you can set some properties to. I'm making it selectable because later I want to be able to click this one. The summary is shown here in a light font, the title is above the summary in a darker font, and the key is what allows us to differentiate this preference from the other preferences in the file, just like an ID does for a widget in a layout file, except the key has some additional functionality. This is the key to the preference. Remember, all preferences are essentially key-value pairs. This is the key to this particular preference. I know that doesn't make a ton of practical sense with this particular example since this one doesn't technically save anything, but it will in a moment when we look at the next preference, which is the EditTextPreferences. Coming into the data PreferenceCategory. The first preference is an EditTextPreference. This is going to make much more practical sense. When I click this preference, a dialog pops up and asks me for input. If I click OK, that text is saved to this preference key. Once again, I want to stop, and I want you to appreciate the simplicity and the power of this feature. I don't have to write any code for this to work. I literally just stick this EditTextPreference into a PreferenceScreen, and it works. There is absolutely no Kotlin code needed to save this value. I think I'm in love, and I think you should be too. The attributes are pretty intuitive. The default value is the default value you saw when the dialog inflated. You know what the key is, the summary is shown here, and the title is shown here. Next, we have another new type of preference, a CheckBoxPreference. This is even more intuitive than the EditTextPreference. The attributes are exactly the same as the last one. There's nothing new here. When you click it, the checkbox changes its state, and that's pretty much all it does. Now we have a ListPreference. This one is quite different. If I click this one, a dialog inflates with a list of options, hence the name ListPreference. The only thing you might be a little confused about is the entries and the entryValues attributes. The entries are what you see in the dialog, all this text here. So this is entry 0, this is entry 1, entry 2, and so on. The entryValues are what the Preference Framework interprets the entries as. I think this is best explained with an example, so let's look at the arrays for these attributes. Open the array file in the values folder. Here are the entries you saw in the dialog, and here are the entryValues that you don't see. Suppose I selected 1 hour from the dialog. That would mean the preference that actually gets saved is a value of 1 because that corresponds to the same position in the values array. If I selected 12 hours from the dialog, that would mean the preference that gets saved is 12, the value of 12, because that corresponds to the same position. Hopefully that clears things up. Go back to pref_main. Continuing on, we have our third category, Notifications. And the first preference inside the Notifications category is a SwitchPreference. This is pretty straightforward. It's a switch. It's either true, or it's false, similar to a checkbox. But something cool about this SwitchPreference is that it's actually being used by the next preference, the RingtonePreference. If we look at the app, when I enable the switch, it allows me to select a ringtone. If the switch is disabled, I can't select a ringtone. So the ringtone preference is dependent on the switch. Once again, I want to point out the elegance. I haven't written any logic for this. It just works. All I need to do is specify a dependency attribute in the ringtone preference. It's pointing to the key of the SwitchPreference. It's so simple, and it's so effective. The RingtonePreference itself is also really great. It automatically searches the device for all the factory ringtones. If I click the preference, a dialog pops up where I can select one. Next is another SwitchPreference. There's nothing new here, so I'm going to move on. Here is the final PreferenceCategory, the About category. These first two preferences are nothing we haven't seen before, just some text. But the third has something interesting happening. There's an intent in the preference. If I click the preference, an internet browser is opened, and I'm taken to the URL specified in the data attribute of the intent. The action attribute is android. intent. action. VIEW. That's going to execute the intent. These last three preferences are exactly the same. It's the frequently asked questions, the privacy policy, and the terms and conditions. This is all very convenient. I didn't have to make any new pages in the app. I can just direct users to the company website. I know I've mentioned it several times, but this really is elegant. I absolutely love what they did with the Preferences framework. It's so easy to build beautiful settings screens that fit the app theme and conform to the Android design guidelines. You don't even have to write new logic to save the preferences. That's all done automatically. Before we can test, we need to do one last thing. Right now the SettingsFragment isn't associated with pref_main. Open SettingsFragment. First, we need to insert onCreate. Press Ctrl+O on Windows or Cmd+O on Mac. Search for onCreate and insert it. To associate pref_main with the fragment, we need to call the addPreferencesFromResource method and reference the file. That's it. The fragment will now inflate with the layout in view. However, there's going to be problems with this. Let's run it, and I'll show you. I'll navigate to the Settings screen. There's the problem. As you can see, the fragment has a translucent background. That's because we're not using a regular layout like with most fragments. We're using a special XML file. Lucky for us, this is a pretty simple fix. Go to SettingsFragment. Inset the onCreateView method. We need to get a reference to the view so we can set the background color. This View object is not going to be changed, so we can use the val key word. Now call setBackgroundColor and reference a white color with ContextCompat. getColor. Pass in activity reference and then the color. Then, of course, return the view. That will fix our problem. Let's run it and take a look. I'll go to the Settings screen. As you can see, the problem is solved. I know in this video I basically talked about nothing but good things from the Preferences framework, and it's for good reason. There really is a lot of great things. However, as you just saw, there's also some shortcomings. And unfortunately, that's not the only one. If you look at the app, right now there's no toolbar. And adding a toolbar isn't a straightforward process because we're not actually using a regular layout file. We can't just add one. Well, we can add one, but it's not the typical way of doing it. In the next clip, we're going to resolve the toolbar problem and address some other shortcomings of using a PreferenceFragment.

PreferenceFragment Limitations
Check out the branch named 3. 4-preference-fragment-limitations-start. Open activity_items. I've made some changes to the layout. Now there's a linear layout with a vertical orientation that contains a toolbar and the FrameLayout for the SettingsFragment. As you probably guessed, this is going to be the toolbar that we use for SettingsFragment. Open layout_settings_toolbar. The thing I want you to notice here is that the app bar layout has a visibility of gone. We're setting this to gone because otherwise we're going to cover up the toolbar in ItemsActivity. We only want to show this toolbar when SettingsFragment is visible, so it needs to start with a visibility of gone. Open SettingsFragment. Scroll to onCreateView. Here's the code required to setup our new toolbar. Since we're using a SupportActionBar, we need to cast the activity reference to a AppCompatActivity. We need to set the SupportActionBar by calling the setSupportActionBar method on the activity reference. Then find the toolbar by referencing its ID and cast it to a toolbar. The SupportActionBar object is what we'll use to set the Back button and the title. We can get a reference to it by calling SupportActionBar on the activity reference since we just set it with setSupportActionBar. We need to setDisplayHomeAsUpEnabled to enable back navigation on the action bar. That going to make this back arrow appear and work properly. SetTitle obviously sets the title. That's all great, but it's not going to show unless we set the visibility when the fragment is inflated. For that we need to use an interface. Right-click on the main package directory. Go to New, Kotlin File. Make sure to change this to an interface and call it IItems. We need two methods, one for showing the app bar and one for hiding it, showSettingsAppBar and hideSettingsAppBar. Open ItemsActivity. Implement the interface. Now click the red light bulb and implement the methods. I'm going to cut these and move them just below the inflateSettingsFragment method. In showSettingsAppBar, we want to set the visibility to visible. In hideSettingsAppBar, we want to set the visibility to gone. Now open SettingsFragment. At the top of the file, create an iItems objects and set it to null. Scroll down to the bottom. Press Ctrl+O on Windows or Cmd+O on Mac. Search for the onAttach method, the one that accepts a context as an input. Now insert it. Write a try catch and catch the class cast exception. There shouldn't be any issues since we're only using this in a single activity, but that's the best practice thing to do. Instantiate the interface by referencing the context and casting it to an IItems type. Just before all the action bar code, call the showSettingsAppBar method on the IItems interface. Now let's run it and take a look. I'll navigate to the Settings screen. Great. So the toolbar is showing, but there's a few problems. For one, we don't want this menu showing in the top right. We only need that for ItemsActivity. Second, the back arrow doesn't do anything when I click it. And third, watch what happens when I navigate back and press the Back button. The toolbar doesn't go away. We'll start working on resolving those issues in the next clip.

Resolving PreferenceFragment Limitations
The first issue we're going to address is hiding the toolbar when the user navigates back. This is surprisingly simple. Open ItemsActivity. I've added a new method named correctSettingsToolbarVisibility. As its name implies, this method is responsible for making the necessary corrections to the toolbar in SettingsFragment. It checks to see if the fragment is visible. And if it is, it shows the toolbar. If it isn't, it hides the toolbar. Pretty simple. I'm calling the method in the onBackPressedOverride method. That way when the user clicks the Back button, it's going to make all the necessary corrections. So that's all great. That resolves the issue when the user presses the Back button, but what about the Back arrow in the toolbar. Right now it doesn't do anything. Let's fix that. Open SettingsFragment. The first thing we need to do is actually enable the use of widgets in the toolbar. Just below where we set the title to the actionBar, call setHasOptionsMenu and set it to true. If we don't set that to true, the back arrow will not work in the toolbar. Now we need to insert a couple new override methods. One of them is going to be for enabling the back arrow, and one will be for removing the menu in the top right-hand corner. Press Ctrl+O on Windows or Cmd+O on Mac, insert onOptionsItemsSelected and onPrepareOptionsMenu. First we'll work on the back arrow. In onOptionsItemsSelected, we need to check for the home icon ID. The home icon ID is defined by the Android SDK. It's defined when you use the setDisplayHomeAsUpEnabled like we did in onCreateView. That's its default ID. But what do we do when a click is detected? We want to essentially press the back button. We can use another interface method just for that. Open IItems. If we add a method that's spelled exactly the same way as the onBackPressedOverride method in ItemsActivity, it will trigger the exact same way. Go back to SettingsFragment. Now call the onBackPressed method on the IItems interface. That's another issue resolved. Now for the menu. To disable the menu icon, the first thing we need to do is get a reference to the menu. The ID for the menu is actionSettings. That's not the default value given by the Android SDK. That's the ID I assigned to it in the menu layout file. OpenItems. xml in the menu folder and see for yourself. There it is. Go back to SettingsFragment. Now we just need to make it invisible. Problem solved. Run it and let's take a look. I'll navigate to the Settings screen. Notice the menu is gone. Now I'll press the back arrow on the toolbar. Great. So everything is working as we expect at this point.

Module Review
In this module, we learned about a powerful tool for building settings screens on Android. It's called the Preferences framework. The Preferences framework gives developers the ability to build beautiful settings screens that conform to Android's design guidelines. The Preference objects, which refer to the individual settings on the screen, are automatically set and retrieved without having to write any code. Literally all you need to do is add the objects to the special XML layout file and then set the layout file to a class that extends PreferenceFragment. A class that extends PreferenceFragment is similar to other fragment classes in that it requires a container to be inflated, and it's essentially just a view. But it's not just any view. It's a special type of view designed specifically for building settings screens. Like everything else with the Preferences framework, setting the XML layout file to the PreferenceFragment is very simple. All you need to do is add the onCreate method to the class, then call the addPreferencesFromResource method, and reference the file. That's it. You can set the preferences, and the preferences will be retrieved every time the layout is inflated. The preferences are saved locally on the Android device. But it's not all sunshine and rainbows. It's mostly sunshine and rainbows, but there are some shortcomings. As we saw in the module, it's difficult to add a toolbar to the PreferenceFragment. It's difficult because you can't use a standard layout file like with other fragments. You can't just add a toolbar. So we had to add the toolbar outside the container and implement some custom functionality to set the visibility. Next we're going to work on building a secondary setting screen for more personalized fields. These fields will be saved using SharedPreferences.

Saving Data with SharedPreferences
Introduction
If you have any experience with Android development, Java, or Kotlin, you probably already know what SharedPreferences are. But since this is a beginner course, let's start with a definition and a brief description. The Android documentation defines SharedPreferences as an API that allows you to read and write persistent key-value pairs to primitive data types: Booleans, Floats, Ints, Longs, and Strings. The key-value pairs are written to XML files that persist across user sessions. So even if your app is killed, you can manually specify a name for the file or use a per activity file convention to save your data. Practically speaking, SharedPreferences is mostly used for saving data in settings screens similar to the fields we were saving using the Preferences framework. To be honest, probably 90% of the use cases could probably be handled using the Preferences framework. SharedPreferences should therefore only really be used for very special cases, situations where the Preferences framework would struggle or possibly create more work than it's worth. Can you think of any special cases like that? Think about the problems that we ran into in the module on the Preferences framework. With the Preferences framework, you can't create unique layouts, and it's cumbersome to deal with toolbars. So those situations are probably best for SharedPreferences. To exemplify a situation where you'd want to use SharedPreferences as opposed to the Preferences framework, we're going to build a fragment with a unique layout. The fragment will have a toolbar with a checkmark icon in the top right. When the user submits changes to SharedPreferences, the checkmark will disappear and a progress bar will appear. The progress bar will spin for a designated amount of time to simulate a server request. After the designated amount of time, the progress bar will disappear, and the checkmark will reappear. There will also be a circular image view widget in the layout. The Preferences framework does not have anything for facilitating images. Other than that, there's going to be a handful of other fields, a name, username, email, phone number, and a gender. Since this is a Kotlin course, we're also going to take a look at higher-order functions, lambdas, operators, object declarations, inline functions, and extension functions. We're going to build a convenience class for handling all the getting and setting of our SharedPreferences values.

Building a Unique Settings Screen
Check out the branch named 4. 2-building-a-unique-settings-screen-start. I've made a ton of code changes for this clip. Before we get into the SharedPreferences content, let's quickly walk through the changes that I made. The phone on the left is running the completed version of the app. The phone on the right is running the current version of the app. I've created a new fragment class named AccountFragment. In the completed version, I can navigate to AccountFragment by going to Settings and then clicking on this preference. This is AccountFragment. But to do this, I need to use a PreferenceListener since I'm clicking on a preference to get to the fragment to inflate. We're going to be looking at PreferenceListeners in the module named Implementing PreferenceListeners. We can't do that in our current version yet. So for the time being, we're going to inflate AccountFragment by selecting the Settings menu item. Later we'll come back to that and fix it. This is just a temporary measure. We'll start by looking at the layout file for AccountFragment. Open fragment_account. This is a standard layout file. The thing I want you to notice here is that we're not using a preference XML file like we did with the SettingsFragment. Also notice, I've added a toolbar to this layout. It's a custom toolbar whose layout it layout_account_toolbar. Open layout_account_toolbar. This is a relatively simple layout. There's two image view buttons, one with an X icon and one with a checkmark icon, a TextView for the title and a ProgressBar. The thing I want you to notice about this layout is the progress bar is over top of the checkmark. In the finished version, when a user makes changes to SharedPreferences, then clicks the checkmark, a progress bar will show for a designated amount of time. Keep in mind, this isn't going to work properly until we look at listeners later in the course. Open AccountFragment. This is the new fragment class. Unlike SettingsFragment, this is a standard fragment class that extends android. support. v4. app. Fragment. Because this is a beginner course, I'll spend some time walking through it. Start with onCreateView. This is the method responsible for actually inflating the view and associated it with the layout. As you can see, we're associating it with fragment_account. OnViewCreated is called immediately after onCreateView. This first line of code is for formatting phone numbers as the users type them. As you can see here, as I type in a phone number, it's automatically formatted correctly. The initToolbar method is for setting onClickListeners to the X icon and also the checkmark icon. If you scroll down, you can see the onClick method. There's four cases, the X icon, the checkmark icon, the profile image, and the text just below the profile image. The X icon needs to navigate back. So we're using the same method we did in SettingsFragment. The checkmark needs to save all the changes made to SharedPreferences. It's executing a method named savePreferences. But right now, savePreferences doesn't do anything except show a progress bar. The profile image and the text below the profile image execute a method named inflateChangePhotoDialog. InflateChangePhotoDialog does exactly what it sounds like. It inflates a dialog that starts the process for selecting a new profile image. It presents the user with two options, choosing an image from memory or taking a new one with the phone's camera. Open ChangePhotoDialog. I don't want to spend too much time on this class since it's outside the scope of this course topic, but you should know generally how it works. There's an interface at the top of the file named onPhotoReceivedListener. It has a single method named setImageUri. After an image has been selected from memory or captured with the camera, the onActivityResult method will fire. Scroll down to it. There's two if statements, one for if the new image came from memory and one for if the new image was taken using the camera. Both of them called the setImageUri method on the onPhotoReceivedListener interface. That's the most important part of this class. Now open ItemsActivity, and we'll see what happens to the URI. If you scroll to the top of the file, you'll see that the class implements the OnPhotoReceivedListener interface. Scroll to the override method, setImageUri. Here the URI is being passed to accountFragment using the setImageUri method that exists in accountFragment. Go back to AccountFragment. Scroll to setImageUri. Here's where our road ends. The URI is now used to set the image to the image view widget using Glide. Next, we'll walk through verifying camera and storage permissions because as you just saw, we need to access the camera, and we also need to access the phone's internal storage for selecting photos. Since Marshmallow, you need to explicitly ask for these permissions using a dialog. First, open the manifest. In addition to explicitly asking for permission, you also need to add them to the manifest. Here's the write external storage permission, and here's the ones required for the camera. Go back to AccountFragment. Scroll to initPermissions. I'm calling a method named verifyPermissions if a Boolean named permissions is false. Scroll to verifyPermissions. This method will actually inflate the dialog responsible for explicitly asking the user for permission to use the camera and permission to write to storage. If the user accepts these permissions, then the permissions Boolean will be set to true. And if the permissions Boolean is set to true, ChoosePhotoDialog will be able to inflate. The last thing I want to show you is where the fragment container is. Open ActivityItems. As you can see, I've added a second FrameLayout here with an ID of account_container. So SettingsFragment and AccountFragment don't even exist in the same container. They each have their own containers. I did this because of difficulties we encountered with the toolbar in SettingsFragment. It's just easier to keep them completely separate. Open ItemsActivity. Scroll to the inlfateAccountFragment method. This method is basically the same as the inflateSettingsFragment method, except it references the accountFragment and the accountContainer. Also notice, I'm calling inflateAccountFragment up here when the menu item is clicked instead of inflateSettingsFragment. Remember this is a temporary measure until we look at the listeners later in the course. That takes care of all the housekeeping stuff we needed to cover before diving into SharedPreferences. Now you understand when the fragment is coming from and how it works.

SharedPreferences as a Singleton
In general, SharedPreferences is a pretty straightforward part of the Android SDK. It's just key-value pairs that are saved locally on the Android device. Because it's just a simple part of the SDK, teaching you how to use it is also very simple. Since this is a Kotlin course, I want to provide some extra value if I can. So we're going to optimize our use of SharedPreferences by taking advantage of some of the features of the Kotlin programming language. I don't want to talk too much about the technical details of how we're going to be doing this before looking at some practical examples, but here are the names of the Kotlin features so you know what to expect, higher-order functions, method extensions, object declarations and singletons, lambda expressions, and operators. Don't worry if you have absolutely zero idea of what those things are. We're going to take a look at some examples and how you can use them to decrease the amount of code you write using Kotlin. Check out the branch named 4. 3-shared-preferences-as-a-singleton-start. Before I show you how to optimize your code, I want to show you what kind of code you're going to be optimizing. Open AccountFragment. Scroll to the savePreferences method. As you can see, I've got some code here that's commented out. This is an example of how you might save key-value pairs to SharedPreferences. You start by getting a reference to SharedPreferences. One way, which is the way that will suit 99% of the use cases, is to use the getDefaultSharedPreferences method. Because we're saving something to SharedPreferences, we also need an editor object. That's easily accessed by calling the edit method on the SharedPreferences object. In this example, I'm saving the name field. So we want to check to see if it's blank. If it isn't, then we can call the putString method on the editor, reference the key, and then reference the value. Then we just call apply and commit the changes to the SharedPreferences file. The process is very simple. There's nothing tricky about it. I'm saving a string value to SharedPreferences with a key that's defined here. That's all great, but imagine you had a screen with something like 20 preferences to save. That could turn into a lot of code. And if you had to do that in other activities or fragments, that's a lot more code, and it's a lot of repeated code. It's not exactly elegant, and that's just for settings values. Retrieving values is a totally different story. So the question is how can we leverage Kotlin to optimize this functionality? We're going to build a helper class for centralizing all the SharedPreferences transactions. The helper class will hold a SharedPreferences instance that is accessible anywhere in the application. Any activity or fragment will be able to access the exact same instance. So we'll basically have a single SharedPreferences object that can be used anywhere and accessed at any time. That's the goal. Right-click on the main package directory. Go to New, Kotlin File. Call it PreferenceHelper. We don't want to create a class. We want to create a singleton of the PreferenceHelper object. In Kotlin, we can do that by using the key word object. Then we write the class name, which is PreferenceHelper. This is also known as a singleton. It refers to the single instance nature of an object, so there's only one throughout the entire application. The purpose of this object is to maintain a reference to SharedPreferences. So we need a method to return that reference. The first method will be to return a reference to the default SharedPreferences. We need the Context as an input, a return type of SharedPreferences, and how to get the SharedPreferences object. The Android documentation says if you're using the SharedPreferences API to save app settings, you should instead use getDefaultSharedPreferences to get the default SharedPreferences file for the entire application. That's what we're doing here. We don't need anything custom. The default SharedPreferences are fine for what we're doing. The alternative to that is creating a SharedPreferences object for specific activities or other random processes. This is how you get a reference to that. I'll call it customPrefs. It also takes the Context, but it requires a second parameter, a key. The return type is still SharedPreferences, but we can call the getSharedPreferences method instead of getDefaultSharedPreferences. Pass the key and then pass the Context. MODE_PRIVATE. Like I said, this is what you'd want to use if you want to create a bunch of SharedPreferences files for your application. A practical use case for this would be if you wanted to save application configuration settings in different files, like if the user had multiple configurations they wanted to save and then switch between the options whenever they wanted. For most cases, probably 99% of cases, the default SharedPreferences option will be enough. We're not going to be using the custom preferences option in this course. I just wanted you to be aware of it. We're done in the PreferenceHelper class for now. Go to AccountFragment. Now to get a reference to the SharedPreferences instance, I just need to write PreferenceHelper. defaultPrefs and then pass the context. Now I know that doesn't save a lot of code, so don't get excited yet. We only had to write a single line to get a reference to SharedPreferences before, and this is still a single line. But have no fear, we're going to see the dividends pay off in the next couple clips.

Leveraging Higher Order Functions to Save Preferences
Check out the branch named 4. 4-leveraging-higher-order-functions-to- save-preferences-start. The first thing we're going to do is build a generalized method for saving values to SharedPreferences. The method will need to handle any of the possible data types, Booleans, longs, floats, ints, and strings. Open PreferenceHelper. Before we walk through the methods, I need to warn you. Regarding the Kotlin programming language, I found these concepts to be the most difficult things to learn. But don't worry, I'm going to take it nice and slow. We'll start with the set method. This is the method responsible for setting the new values to SharedPreferences. It accepts a key and a value. Notice the value can be anything. It's defined as an Any type. Don't worry about this operator key word for now. I'm going to talk about that later. Next, take a look at the method name. It's called SharedPreferences. set. In Kotlin, this is known as a method extension. I'm essentially creating a new method for the SharedPreferences class. Hold down Ctrl and click on SharedPreferences. Let's take a look at what the Android SDK says it can do. This is the SharedPreferences class that's included in the Android SDK. Everything it can do is included in this file. Press Ctrl+F and search for the word set. Notice the SharedPreferences class has no method named set. Go back to PreferenceHelper. Basically what I'm doing here is I'm creating one. That's why it's called an extension method. I'm extending the SharedPreferences class to include a method named set. This would be the same as if I created a custom class and extended by SharedPreferences and then I added a method named set. This is just a shorter way to do that. Inside the set method is a switch statement. This is how you do a switch statement with Kotlin. You use the key word when. Then specify the cases with the key word is. So it's saying if the value is of Editable type, then do something. This is the arrow operator. In the context of this example, it's saying do this. So what exactly is this? For two of the cases, we're checking to make sure the value isn't blank. If it isn't, then we call a method named edit, and there's some weird syntax you probably don't understand. This is where it gets difficult. At least I think this is where it gets difficult. I'm going to explain what's happening here very slowly. The edit method it's referring to is this edit method up here. These squiggly braces signify a function. So I'm passing a function to the edit method. Before we talk about what's happening in the function, let's take a closer look at the edit method. Notice it accepts a function as an input. As a convention, some developers even like to call this variable function. As you can see, I've decided to call it operation. Personally, I don't like calling it function because it is a function. I think it would be weird to call a string variable string or an int variable int. So I like to call it operation since it's performing an operation. Anyway, that's just my preference. The naming isn't really important. The method accepts a function of type Unit. Unit is the same as a void type in Java, so it's basically nothing. It's nothing type. No what does this function do? If we take a closer look at the logic in the method, there's an editor object, which we know is used to save preferences in SharedPreferences. I'm able to use the key word this because it's referring to the type up here. I'm creating another extension method named edit. The edit method is being used on a SharedPreferences object. This is referring to the SharedPreferences object because that's what it says here. If you don't understand, let me do a little example. Watch what happens when I change this object to something else. I'll change it to string. Now if I type this, you can see it's of type string. So whatever we put here is the representation of this. This is going to represent whatever type I have up here. Next we pass the editor object to the operation. Then we apply the changes to the editor. So what is this operation? The operation is what's doing all the work. Remember down here we're calling the edit method and passing a function. The function is the operation. This is the operation that's being performed. It refers to the editor object. I'll go through the flow one more time just in case you don't understand. The edit method is called. It passes the function to be executed. The editor object is instantiated. The operation accepts the editor as an input. The function executes by referencing the editor using the it key word. Then the editor applies the changes. Now let's see it being applied. Open AccountFragment. Scroll to savePreferences. The code up here that took seven lines can be done in two, three if you include the SharedPreferences declaration. And this helper class will work in any project in any situation. You could literally copy and paste this into any project, and it would work perfectly. A few of these need one extra line of code because of formatting, but the SharedPreferences stuff is done in only two lines. There's one thing we didn't talk about yet. I'm sure you're wondering how I'm able to treat the SharedPreferences instance as an array. I'm passing the key to the preference as if it's an array. Normally you'd have to do this, prefs. set and then pass the key and pass the value. We can do it this way by using the operator key word. Go to PreferenceHelper. Watch what happens when I delete the operator key word. Now I'll go back to AccountFragment. As you can see, I'm getting an error. I'll go back to PreferenceHelper and change it back, and now I'll go back to AccountFragment again. The operator key word allows us to do that. It's known as operator overloading. One last thing I want to mention before we move on is that you need to write the import manually. Scroll up to the top of the file. Notice this import. I'm telling the fragment where they can find the set method for the PreferenceHelper class. I'm not sure if there's a problem with my Android Studio or if this is just something you always have to do, but the setter method wouldn't work and Android Studio wouldn't automatically import it for me. I think it's because it's an extension function. I'm not really sure. But anyway, keep that in mind. If you ever make an extension function, you'll have to write the import manually. Unfortunately, we don't have any way to test this until we have a method for retrieving SharedPreferences values. That's what we're going to do in the clip names Reified Parameters and Retrieving Preferences.

Reified Parameters and Retrieving Preferences
Check out the branch named 4. 5-reified-parameters-and-retrieving-preferences-start. We have a way to set SharedPreferences values. Now we need a way to retrieve them. Open PreferenceHelper. Retrieving values is actually going to require quite a bit less code than setting them since setting them requires two objects total, the SharedPreferences object and the Editor object. Retrieving values only requires a SharedPreferences object. Take a look at the method. First, notice there's another extension function. I'm extending SharedPreferences to include a method named get. Get accepts two parameters, a key and a defaultValue. Notice I'm telling the method that the defaultValue could be anything. T denotes anything. I don't know what the default value is because I don't know what the SharedPreferences value is. I only know the key is going to be a string. Notice the return type is the same as the default type. Logically, that makes perfect sense. If it's returning a value, the defaultValue is going to be the same type. In Kotlin, if we need to access an object type inside the method, we can use the reified modifier. That's how I'm able to reference a T type both inside the method and also as an input. If I was to delete this, you can see I get an error on the T type. It doesn't know what it is, so Android Studio tries to recommend imports. Inside the method, we want to return the value from SharedPreferences. But before we can get the value, we need to know what the type is since SharedPreferences has methods for each return type. There's getString, getInt, getBoolean, getFloat, and getLong. Just like we did in the set method, we're using when and passing the parameter in question. But in this case, it's the type we want to know, not the actual value. So we're saying what is T? If T is a string, then call the getString method. If T is an int, then call the getInt method. This probably seems a little confusing to you, so let me explain. GetString obviously returns a string, but the get methods returns a value of type T. String is not the same as type T, at least not to Android Studio. That's what all this is for. First, we need to tell the getString method that the default value is of type string. Then we need to tell the get method that the getString method is returning an object of type T. Then we're good to go. If you're still confused about what's happening here, let me give you another example. Suppose we had some method whose job is to return a string given some key. I'll call it getSomeString. It'll take a key, and it will return a string. If I try to return an integer, it gives me an error and rightfully so. I just specified that I want to return a string. That's the exact same thing that's happening in our get method. It expects a return type of T, so we need to return something of type T. We're done in the PreferenceHelper class. Open AccountFragment. Scroll to initWidgetValues. This is where we retrieve the values from the PreferenceHelper. We start by getting a reference to SharedPreferences. Then retrieving the values is simple. You just specify the key, and that's it. There's a couple variations, but they're very similar. As you can see here, I'm specifying a string type, but I'm not specifying a default value. But for the username, I'm not specifying the type, but I'm specifying the default value. Either one is fine, whatever you prefer. Then just set the value to the widget. One last thing. Scroll to the top of the file. Just like we did with the set method, I'm importing the get method from the PreferenceHelper manually. Android Studio did not do this for me. I don't know if it's a problem with my environment, but I doubt it. So keep that in mind. For extension functions, you'll have to write the import manually. Let's run it and take a look. I'll navigate to the Settings screen. Now I'll change some properties. I'll click the checkmark icon. So everything should be saved now. I'm going to close the app and rerun it. Now I'll navigate to the Settings screen again. Cool, the fields are displaying the correct values. So everything is working as we expect.

Module Review
This module was all about SharedPreferences, what situations to use SharedPreferences, and how we can optimize the use of SharedPreferences with Kotlin. We started by working on a way to save key-value pairs. The standard way of doing this is very straightforward. Instantiate a SharedPreferences object, instantiate an Editor object, make sure the value isn't null, then set the value to the editor and apply the changes. With Kotlin we can optimize that process. We built a singleton class using an object declaration. Its name was PreferenceHelper. By using the object key word, we can reference a single instance of the SharedPreferences object in any context of the application. To set values, we built a method named set that extended SharedPreferences. The set method takes a key and a value as input. The key and the value are used in a function that's passed through the edit method. The edit method is defined in our PreferenceHelper class. It takes a function as an input. That function is named operation. The operation function accepts an editor object as input. That's what you see passed here to the function. After we built the edit and set methods in PreferenceHelper, we were able to save new values to SharedPreferences. To save values, we just needed to get a reference to the PreferenceHelper instance, then set the value like this. We referenced the key and set it equal to the value. Retrieving values from SharedPreferences was a little easier. Once again we created a method extension named get that accepts a key and a default value as input. The trickiest part about this is we don't know what the default value type is. And consequently, we don't know what the return type is. Lucky for us, Kotlin has something called reified type parameters that we can take advantage of. We just add this bit of code, and the method allows us to return an unknown type of T. This saves a ton of code. If we couldn't do that, we'd need to write getter methods for each one of these methods, getString, getInt, getBoolean, getFloat, and getLong. Once we had our getter method, retrieving values was simple. We get a reference to SharedPreferences, then retrieve the value like this by referencing the key. Don't forget you need to import the get and set methods manually at the top of the file. For some reason, Android Studio doesn't recognize extension methods, at least not for me. In the next module, we're going to take a look at Preference listeners. We can use Preference listeners to detect when changes occur to Preferences, SharedPreferences can even detect clicks to Preference objects.

Implementing Preference Listeners
Introduction
Understanding Preferences listeners is fundamental to effectively using the Preference framework and SharedPreferences. With respect to the Preference framework, we can listen for changes made to the Preference objects in a Settings screen. We can also add PreferenceClickListeners to the Preferences objects. We'll be using a PreferenceClickListener to inflate AccountFragment when a user clicks here on the Settings screen. With respect to SharedPreferences, we can listen for changes made to the key-value pairs. In a practical sense, when preferences are changed, you might want to update the values on a server. It's usually best to save settings on a server since that way a user could theoretically log into the app from any device, and the configuration would be the same. Obviously our application isn't real, and there's no server to upload to. So instead, we're going to simulate a server upload using a runnable. That way you get a feel for what it would actually be like.

OnPreferenceClickListeners
Check out the branch named 5. 2-on-preference-click-listeners-start. If I navigate to the Settings screen, we need a way to inflate AccountFragment by clicking on this Preference object. We'll set a PreferenceClickListener, then inflate AccountFragment using an interface method in the iItems interface. Because of the unique design of the Preferences framework, we can't use plain old click listeners. So the Android team has provided us with something special, onPreferenceClickListeners. First, I want to show you that I've changed things back to the way they were before we built AccountFragment. Open ItemsActivity. Scroll down to onOptionsItemSelected. As you can see, I'm calling the inflateSettingsFragment method when the Settings menu item is selected. I just wanted to make sure that I explicitly showed you that so you're not confused. Open SettingsFragment. The first thing I want you to notice is the implementation of the OnPreferenceClickListener interface. It has a single override method called onPreferenceClick. Scroll down to it. As you can see, it accepts a Preference object and returns a Boolean. We want to return true if the click was handled or false if the click was not handled. There is no scenario when the click wouldn't be handled, so I'm returning true. The only situation we care about is if the account_settings preference is clicked, and that's what you see the if statement checking. If the preference key equals the account_settings key, then we want to inflate the fragment. The last thing we need to do is actually set the listener to the Preference object. Scroll up to onCreate. To set a listener, the first step is determining what preference we want to set the listener to. We can get a reference to the preference we're interested in like this. Call findPreference, then pass the key of the preference that we want. Now that we have a reference, we can set a Preference listener. This might seem a little strange, so let me explain. It is referring to the accountPreference. OnPreferenceClick is, of course, referring to our method down here. That's it. Let's run it and take a look. I'll navigate to the Settings screen. Now I'll click this preference. Great, it's taking me to AccountFragment. So everything is working as we expect.

OnSharedPreferenceChangeListeners
Check out the branch named 5. 3-on-shared-preference-change-listeners-start. Practically speaking, I think one of the best use cases for SharedPreferenceChangeListeners is triggering a server upload. So when a preference is updated by the user, the new data is automatically pushed to the server. That ensures data is consistent across any device. We obviously don't have a server with this application, but we can simulate a server upload with a runnable. That way you can get a feel for the whole process. When the user makes a change, then clicks the checkmark icon, a runnable will start and a progress bar will replace the checkmark. The runnable will run for 1 second and then stop. The runnable will not start unless a change is made. Open AccountFragment. Scroll to the top of the file. The first thing I want you to notice is the implementation of the OnSharedPreferenceChangeListener interface. It has a single override method named onSharedPreferenceChanged. But before we look at it, I want to show you how the listeners are set. It's a little different than regular listeners. Scroll down to the bottom of the file. Here we have onPause and onResume. In onResume, I'm calling the registerOnSharedPreferenceChangeListener method on the SharedPreferences instance. And in onPause, I'm calling unregisterOnSharedPreferenceChangeListener on the SharedPreferences instance. The Android documentation recommends this for proper lifecycle management. Scroll up to OnSharedPreferencesChanged. There's nothing we haven't seen here before. We have a when statement taking a key as an input, when the cases for each key. Each case results in the same method being called, the updatePreferencesSuccess method. But each case passes a different key. You can see this one takes the NAME key, this one the USERNAME key, and so on. Scroll to updatePreferenceSuccess. This is where the server upload simulation begins. First, we show the progress bar. Then if the runnable isn't already running, we can move on to the next step. And the next step means executing the simulateServerUpload method. Scroll to simulateServerUpload. This method uses a Handler, a Runnable, and two Long values to determine when 1 second has elapsed. After 1 second, the runnable stops using this logic. The last method to be executed is updateFinished. UpdateFinished will hide the progress bar and reset the image URI. Hopefully this gives you a good idea of what you need to do if you wanted to keep an exact copy of each user's preferences on a server. In general, I think it's almost always a good idea to do so. That ensures a consistent experience on any device. Let's run the app and try it out. I'll navigate to the Settings screen, now to AccountFragment. I'll try pressing the checkmark icon before I've made any changes. Great, it's not executing the runnable. Now I'll make a change. I'll try again. Looks like everything is working as we expect.

OnPreferenceChangeListeners
The last listener we're going to talk about is an onPreferenceChangeListener. Check out the branch named 5. 4-on-preference-change-listeners-start. Open SettingsFragment. An onPreferenceChangeListener does pretty much the same thing as an onSharedPreferenceChangeListener. It will detect when a change has been made to a preference on the Settings screen. The first thing we need to do is implement the OnPreferenceChangeListener interface. Next, we need to set the listener to the preferences we want to listen to. This is how it's done. We create a Preference object and reference the key to each particular preference. As you can see, this one is for the gallery name. This one is for the upload over Wi-Fi preference and so on. These are the keys to the preferences in the preference_main. xml file. Open pref_main and take a look. These keys right here. You can see there's the gallery name and there's the upload over Wi-Fi. Go back to SettingsFragment. The OnPreferenceChangeListener interface has a single override method. It's called onPreferenceChange. Scroll to it. This is the method that will trigger when a preference is changed. Just like we've done with some of the other listeners in the course, we're using a when statement and checking for the different keys. When a particular key is detected, the updatePreferences method is called, and the key is passed as an input. Scroll down to updatePreferences. This would be a perfect time for you to upload the new data to a server. But of course, we aren't using a server in this course, so I'm just calling a method named uploadPreferencesToServer, and that method does nothing. That's all there is to detecting changes with an onPreferenceChangeListener. Let's run it and take a look at the log. I'll navigate to the Settings screen. Now I'm going to click this checkbox. There's a log output letting us know a change was detected. I'll try choosing a different ringtone. That change was also detected, so everything is working as we expect.

Module Review
We started the module by taking a look at OnPreferenceClickListeners. OnPreferenceClickListeners are part of the Preferences framework. Since the Preference objects are basically widgets, having a way to detect clicks is a requirement. For example, in the context of this project, we have a preference that when clicked needs to take a user to a different view. The first thing you need to do if you want to take advantage of the OnPreferenceClickListener interface is actually implement the interface in a PreferenceFragment. Next, set the listener to a preference you want to detect clicks on. You can reference the preference you are interested in by creating a Preference object and specifying the unique key. Then you just set the listener. The OnPreferenceClickListener interface has a single override method, onPreferenceClick. It accepts a preference as an input and returns a Boolean. In our project, we only had a single listener, so an if statement checking for the key was all we needed. Next we looked at OnSharedPreferenceChangeListeners. Unlike the OnPreferenceClickListener interface, this listener doesn't detect any touches or gestures to the application. This interface will fire when a change is detected to any of the SharedPreferences key-value pairs that it's been assigned to. Using this interface is a little different than the other interfaces. Usually with any kind of Preference listener, you start by specifying the key of the preference and then set the listener. However, with an OnSharedPreferenceChangeListener, the documentation recommends you do this. In the onResumeOverride method, you get a reference to SharedPreferences, then call registerOnSharedPreferenceChangeListener and pass the context. Then in the onPauseOverride method, you need to unregister the listener. The last interface we looked at was OnPreferenceChangListener. This is what we used to detect changes to Preference objects in SettingsFragment. Setting the listener was simple. Here's an example. You start by instantiating a Preference object. Reference the key to the preference you want to listen to. Then set the listener and pass the context. Now all changes made to that preference will be detected by the onPreferenceChangeOverride method. We used a when statement to figure out what preference had been changed. Then we executed some methods that actually did nothing so you could get a feel for what it would actually be like to implement something like this. In the next module, we're going to do a comprehensive review of the entire course.

Tying It All Together
Review: Building a Settings Screen
Pretty much every Android application will have a Settings screen. There's almost always going to be some kind of customization available to the user. Because they're used in pretty much every app, the Android team has provided developers with an extremely convenient framework, the Preferences framework. The main goal of the Preferences framework is to streamline the Settings screen creation process. To get started with the Preferences framework, you need to either build a class that extends PreferenceActivity or build a class that extends PreferenceFragment. If your app supports version older than 3, which is the API level 10 and lower, you'll need to use a PreferenceActivity. But if your app supports versions newer than 3, the Android team recommends using a PreferenceFragment. In our application, we used a PreferenceFragment. The layout for a PreferenceFragment is different than a standard fragment layout. The layout file doesn't actually go in the layout folder. It goes in the xml folder. We called ours pref_main. xml. I'm going to open Android Studio so we can review it. Here is pref_main. With a PreferenceFragment, you don't use regular widgets, and the parent layout isn't a layout at all. It's a PreferenceScreen. Inside the PreferenceScreen, you put Preference categories and Preference objects. The first category here is General. That corresponds to this heading right here. Then inside the categories are the Preferences objects. Keep in mind the Preference objects don't need to be in a category. It's optional. But it's best practice to put them in a category. There's six different types of Preference objects, a Preference, which is the most general. By default, it just displays information. An EditTextPreference. This will inflate a dialog when it's clicked. The dialog has an Edit Text field for capturing information. A CheckBoxPreference. You can probably guess what this one does. It's a checkbox. It essentially is just a Boolean value. A ListPreference. When this preference is clicked, a dialog will inflate and display a list of things that you've specified, the list of entries. There's one thing tricky about ListPreferences though. The actual values that are saved are not the entries. It's the entry values. So keep that in mind. As we carry on downwards, we have a SwitchPreference. A SwitchPreference is basically the same as a CheckBoxPreference. It's just a Boolean. Next we have a RingtonePreference. This preference is excellent because it automatically displays the default ringtones available on the device. Also notice the dependency attribute. It's referencing the key to this SwitchPreference above. That will force the RingtonePreference to be unavailable if the switch is false. It will only be clickable if the switch is true. At the bottom of the file, we have a handful of basic preferences, but some of these have intents added to them. If a preference has an intent like this, users can click them and they'll be directed to the URL specified here. Watch what happens when I click the FeedbackPReference right here. It takes me to the contact page of Pluralsight. com. Associating the PreferenceFragment with a layout file is different than with a regular fragment. Instead of setting and getting the view in onCreateView, you just call addPreferencesFromResource and specify the XML resource.

Review: Saving Data with SharedPreferences
You've learned about the Preferences framework and how it can be leveraged to build excellent settings screens that conform to the Android design guidelines. But what if you want to build something custom? The Preferences framework works for most situations, but there's a lot of restriction in terms of what you can build. That's what SharedPreferences is great for. SharedPreferences is a way to save key-value pairs. It's as simple as specifying a key, then setting a value. The API has five primitive data types, Booleans, floats, ints, longs, and strings. Here's a review of how it works. Suppose you wanted to save a string value, a person's name. This is how you'd save it. Get a reference to SharedPreferences. Instantiate an Editor object. The editors is needed to set values to SharedPreferences. Check if the name field isn't null. Get the name from the widget. Call the putString method on the editor. Pass the key and pass the name. And finally, apply the changes to the editor. That's how you'd save a value. Now let's review how you'd retrieve a value. Suppose you were retrieving that same name field that we just saved. You'd start by getting a reference to SharedPreferences called the getString method and then pass the key and a default value. That's it. As I'm sure you're aware, that's not how we did things in the course. We built a custom class and implemented the singleton pattern. The class is named PreferenceHelper. By adding the object key word, the class became an instance object, meaning there's only a single instance of this object that's accessible by any view in the application. The rest of the code in this class was streamlining the SharedPreferences operations or, in other words, getting and setting the key-value pairs. Let's review the methods involved in setting values. I'll open Android Studio so you can review the code. First, we implemented something called a method extension. The SharedPreferences class has no method named set. It has methods named putString, putInt, putBoolean, putFloat, and putLong, but no set method. Basically, we created a method like this. The criteria for the method are as follows. It needs to be able to set any of the primitive data types that SharedPreferences can, and it needs to commit the changes to the editor. You can see here the method accepts a data type of Any, so that covers all the data types. And, as you can see here, it calls the edit method. And inside the edit method, the changes are committed to the editor. Let's quickly review the edit method. This method accepts a function as an input, a function named operation. The operation function accepts a SharedPreferences Editor object as input. And if you take a look at what's happening, that's what you see here. There's the editor object. It's being passed to the function named operation. Then the changes are applied to the editor. Remember this function named operation is actually executing code from the function that was passed to the method, this code right here. It is referring to the Editor object because it's being passed to the function. This is the function. Everything surrounded by curly braces is the function. Now let's review the get method. Here we have another method extension. This time we're extending SharedPreferences to have a get method. Remember SharedPreferences technically has no get method. It has getString, getInt, getBoolean, getFloat, and getLong. Our goal was to build something that can handle any value and still return the correct data type. Remember we don't know what the data type is. We use something called a reified parameter. That's what this bit of code is for. By adding this, we build a method that accepts an unknown data type, called T, and also returns the same unknown data type. I think this is really cool. Doing this with Java would take a ton of code. I would need to write getter methods for each one of these data types, which makes it basically pointless. But with Kotlin, I just need one. Then depending on what the data type is, we can call the corresponding method, getString if it's a string, getInt if it's an int, and so on. Now let's review how the values were actually set and retrieved in the fragment. As long as no special formatting is required, setting the values can be done with only two lines of code. Get a reference to the SharedPreferences instance, then set the value like this. I'm able to treat the prefs object like an array because I used the operator key word in the set and get methods. If you don't remember, here's a review, this operator key word. The last thing I want to review is retrieving values. Just get it referenced to the SharedPreferences instance, then retrieve the value. Very simple, and that will work with any of the SharedPreferences data types.

Review: Implementing Preference Listeners
It's important to know when changes are made to SharedPreferences or the Preference framework since it probably means the user has made some kind of configuration change. Additionally, most of the time it's a good idea to keep a backup of each user's settings on a server. That will ensure a consistent experience on any device. The first listener we looked at was an OnPreferenceClickListener. This is part of the Preference framework. You can use OnPreferenceClickListeners to detect when a Preference object is clicked. The Preference object we set a click listener to was this one. When a user clicks it, we inflated a new fragment. Setting the click listener was pretty straightforward. You can get a reference to the preference you're interested in by specifying the key. Then just set the listener. If you implemented the OnPreferenceClickListener interface, the clicks are handled in the onPreferenceClickOverride method. The next listener we looked at was OnSharedPreferenceChangeListener. This listener detects when changes are made to SharedPreferences. The only thing different about this interface when compared to the others that we looked at in the course is how the listener is set. The Android documentation recommends setting the listener in onResume by calling registerOnSharedPreferenceChangeListener on the SharedPreferences instance. I recommends removing the listener on onPause by calling unregisterOnSharedPreferenceChangeListener. After the listener is set, all changes will trigger the onSharedPreferenceChanged method. We used a when statement to determine which preference was changed. Then we took action. The last listener we looked at was the OnPreferenceChangeListener. This is basically the same thing as OnSharedPreferenceChangeListener, but it's for Preference objects. Or in other words, it's part of the Preference framework and can only be used on Preference objects. Here's an example of how you set the listener to a specific preference. Instantiate the Preference object and reference the key. Then you set the listener. After that, all changes made to the preference will trigger the onPreferenceChangeOverride method. We used a when statement to determine which preference was changed, and then we took that necessary action.

Final Thoughts
I absolutely love what the Android team has done with the Preferences framework. It's so clean and barely requires any code. I think building a consistent experience across all Android applications is really underrated. It's one of the reasons why Apple products have a reputation of being cleaner or easier to use. I think it's because the experience is consistent. So no matter what device you pick up, no matter what application you install, the visuals and interactions are going to be very similar. Regarding Kotlin, I hope this course was insightful and I effectively portrayed its power as a programming language. You saw how we were able to optimize the use of SharedPreferences by taking advantage of higher-order functions, lambda expressions, method extensions, object declarations, and operator overloading. I'm interested in your opinion on Kotlin and whether it's going to be the dominant programming language on Android. Add me on social media and tell me your thoughts. If you add me on Instagram, I often post stories about what I'm working on, what's coming up next for course content, sometimes how you can save some money on Pluralsight subscriptions, and even things about my personal life. I look forward to hearing from you. Send me a direct message and let me know what course you watched and what you thought of it. I hope you enjoyed the course. My name is Mitch Tabian. And, as always, thanks for watching.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
0 stars with 7 raters
My rating
null stars

Duration
1h 21m
Released
18 Jul 2018
Share course
