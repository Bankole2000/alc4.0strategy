Android Data Binding: Getting Started
by Mitch Tabian

Making use of the Data Binding Library is a great way to increase code readability and decrease the amount of code you need to write. You will learn to use custom binding adapters, event handling, and observables to make code more clear and concise.

At the core of every great Android application is a clean and legible code base. In this course, Android Data Binding: Getting Started, you will master the core concepts of the data binding library. First, you will take a close look at how to perform data binding by inflating views, passing variables to views, and using imports. Then, you will see how to use ternary operators, build custom binding adapters, and handle gesture events. Finally, you will build custom data models that extend BaseObservable, so updates to variables are automatic. When youâ€™re finished with this course, you will have a foundational knowledge of Data Binding that will help you as you move forward to develop mobile applications.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
4.8 stars with 35 raters(35)
My rating
null stars

Duration
2h 7m
Released
15 Mar 2018
Share course

Course Overview
Course Overview
Hi. My name is Mitch Tabian, and welcome to my course, Android Data Binding: Getting Started. I'm a self-employed Android developer, and I'm here to teach you about data binding with Android. Making use of the Data Binding Library is a great way to increase code readability and decrease the amount of code you need to write. As you'll see in the course, we use data binding to pass variables directly to layout files. You'll never have to write findViewById, and updates to those variables will happen automatically. Some of the major topics we'll cover include covering the basics of data binding. This will include how to install the Library, how to inflate a data-bound view, how to pass variables to views. Custom binding adapters are like custom methods for specific variables or widgets. We're going to stay very practical and build custom binding adapters for things you'll use in every application. We'll build them for things like initializing RecyclerView, setting images to ImageViews using the Glide library, and setting widget visibilities event handling. In the course, we'll implement gestures like onClickListener, onTouchListener, and a custom interface. One of the major goals of the Data Binding Library is to decrease the amount of code you write. We'll build custom data models that extend BaseObservable so updates to variables are automatic. By the end of the course, you'll have an excellent understanding of the most important concepts when it comes to data binding. Your code will be much more clear, concise, and have an overall elegant feel to it. The course is meant for beginners when it comes to data binding, but targets an intermediate developer overall. You should be very familiar with RecyclerViews, ListViews, onClick events, fragments, and setting images to ImageViews. I hope you'll join me on this journey to learn about data binding with the Android Data Binding course at Pluralsight.

Getting Started
Introduction
My name is Mitch Tabian, and welcome to my course, Android Data Binding: Getting Started. In this course, you'll learn how to build a shopping cart app that makes use of the Data Binding Library for Android. If you're new to data binding or never heard of it before, let me give you some information before you dig deeper into the course. The Android Data Binding Library was first introduced in 2015. The goal of the Data Binding Library is to reduce the amount of tedious code developers have to write and make code more concise and readable. Obviously as a consequence of writing less code and making code more concise, there's typically a significant speed increase when it comes to development time. Some things you'll notice right away about data binding are there's no need to attach widgets to their IDs using findViewById. This is usually the first thing people notice when using the Data Binding Library. Widgets are bound to a sort of class object that can be accessed that way, sort of like how you have getter and setter methods to custom object classes you create. For example, if I created a User class that had two parameters, a name and a surname, I could set the name or surname by writing user. setName or user. setSurname. With data binding, you can do the same thing, but with widgets. So if you have an activity named mainActivity and it has a TextView widget with an ID of myTextView, I could reference the mainActivityBinding object and then set the text of the TextView by writing mainActivityBinding. myTextView. setText, and then maybe, this is some text. Very convenient. Object properties will update automatically if they're observable. This is my favorite feature of the Data Binding Library. You essentially declare objects as observable so that when they change the updated object is automatically sent to the view, and all the properties are also updated. Your code will feel much more organized. Data binding helps to keep these very organized. Everything has a specific place to live, and I find it makes code much easier to read. And that's just the tip of the iceberg really. Those are just some things you'll likely notice right away, but as you'll see in the course, there's a ton of useful concepts to learn about data binding. For those of you who know a bit about data binding, here's some of the topics we'll cover: one-way data binding, two-way data binding, extending models using BaseObservable, binding adapters, onClick events, Listener Bindings, imports, the expression language, ternary expressions, and much more. If you've taken some of my other Pluralsight courses, you know that I like to stay as practical as possible. This course will be no different. We're going to build a shopping cart app with dummy products. Users can add product to the cart, adjust quantities, and even check out. All data is saved locally, and we'll be making use of SharedPreferences to do so. Data binding is a very interesting topic, and I'm looking forward to sharing what I know with you.

Prerequisites
This course is meant for intermediate level Android developers who are complete beginners when it comes to data binding. As I stated in the introduction, my goal is to keep things as practical as possible, so the app we'll be building will be showcasing many different situations. We'll be integrating things like RecyclerViews, fragments, listeners, callbacks, custom object classes, DialogFragments, and much more. Now let's talk about the dependencies we'll be needing for the course. Keep in mind these libraries will already be included in the source code files, so there's no need for you to add them yourself. We'll be using the RecyclerView Support Library for our implementing RecyclerViews; the Design Support Library for CoordinatorLayouts and, consequently, toolbars and other widgets it supports; an open source library for displaying circular ImageView widgets; and the Glide library for setting image resources to widgets. If you want a closer look at those libraries, just open the app-level Gradle file and take a look. Just copy the dependency and paste it into a Google Search. It will direct you to the GitHub page where you can get more information on that library. I'll be using Android Studio version 3. 0. 1 and compiling to a targeted SDK version of 27. As I mentioned, I expect you to have an intermediate level knowledge of Android development with Android Studio. I will be covering how to set up the Android emulator or how to enable developer mode and run apps on a real device. I'm assuming you've learned that on your own, so if you're completely new and never used Android Studio before, you'll need to do some minor research and get apps running on a virtual device or a real device that you have.

The Story Behind the App
For the duration of the project, we'll be approaching app development from the perspective of an imaginary company, Tabian Gifts. Tabian Gifts is a small company with stores located across Canada and the United States. More and more people are choosing to shop online, and they fear their brick-and-mortar stores will go out of business due to the digital revolution. They want to get an idea of what it would cost to build an Android app. You've been hired to build a shopping app prototype. The app must showcase the items they sell; have a rating system; show sale prices, if applicable; and have a shopping cart functionality so users can add items and check out. Your last developer job took way too long to complete, and you're sick of writing findViewById dozens of times in every new activity, fragment, and dialog, so you decide to make use of the Android Data Binding Library to save time.

App Demo
Let's take a look at the app we'll be building in the course. Here's the screen that comes into view when opening the app. This screen just contains a list of products sold by the stores. There's no real theme here. It's just a bunch of random products. There's things like lamps, mugs, hats, shirts, fidget spinners, and paintings. If we click on one of the items, it brings us to another fragment where we can see details on that item. As you can see, each item has a title, an image, a description, a price, a sale price, a rating, and the total number of ratings. From this screen, we can select the quantity by clicking here and then selecting a number. We can then add to the cart by clicking on the Add to Cart button. Notice up here in the toolbar the cart was incremented. It's now showing the total number of items in the cart to be 1. If we go back and select another item, now click Add to Cart, you can see the cart is incremented once more. Let's check out the cart. Click the cart in the toolbar. On this screen, we can adjust the quantities of each item by clicking on these arrows. Notice the quantity is adjusted in the list item, but it's also adjusted to the total number of items and the total cost. If we decrease the quantity to 0, the item is removed from the cart. If we press the Checkout button, a Runnable starts a 1-point second timer. When the timer runs out, the cart is emptied, and the cart fragment is destroyed. That's the complete application demo. Everything in this app is done with data binding. There isn't a single findViewByID, and all widgets are being updated using the Data Binding Library. In the next module, we'll get started building the app.

Data Binding Basics
Introduction
In this module, we'll be exploring the Data Binding Library for Android. For the duration of the module, we'll be working with the source code files in the directory, Module_2/start/TabianGifts. You can download the source code files by navigating to the course on Pluralsight and clicking on the tab labeled Exercise Files. We're going to start off slow since the course is targeting developers with absolutely no experience with data binding. We'll start with the absolute first step, adding the Data Binding Library to your Android project. Next, we'll bind our first view to MainActivity and walk through the similarities and the differences as compared to using the mediator pattern. Right off the bat, I'm sure you'll be pleasantly surprised at how simple it is. After we've bound the first view to MainActivity, we'll work on binding a fragment. The entire application will only have a single activity, MainActivity, so we'll be using fragments extensively. If you ever feel like you need more information about fragments and how they work, I encourage you to check out my course on Pluralsight called Android Fundamentals: Implementing Effective Navigation. In the course, I talk about various types of navigation like activities, fragments, navigation views, navigation drawers, and designing a custom back-stack navigation system. In the Tabian Gifts app, we're only going to use a single activity because it makes communication between views very simple. We'll use an interface for facilitating communication, as you'll see later in the course. I don't want to talk too much about the theory before actually going into some examples, so without further ado, let's get started.

Installing the Data Binding Library
To get started with data binding, we need to install the Support Repository and also enable it. If you haven't already, get the source code files from the directory, Module_2/start/TabianGifts. Once you have the code, open Android Studio, and make sure you have the Android Support Library installed. To make sure, open the SDK Manager by going to Tools, then Android, then SDK Manager. Click on the SDK Tools tab, and make sure the Android Support Repository is installed. If it isn't, just click the checkbox and click Apply. Android Studio will then install it for you. At the time of this video, there's only one simple thing we need to do to enable data binding. Of course, this is subject to change as new updates are constantly being done to the Android SDK, so I encourage you to check out the Android documentation on data binding at developer. android. com. Open the build. gradle app file. All we need to do is write this below buildTypes, dataBinding and then enabled = true. That's it. Sync your project, and we're ready to use data binding. Like I said, everything is subject to change, so checking the official Android documentation is always the best course of action. Before we move on, let's take a moment and talk about the source code I provided. There's a handful of classes here that we'll be using throughout the course, and I think it's important to briefly look at them before moving on. The first thing I want you to notice is the models package. Currently the models package has a single model in it called Product. Open it and take a look. The Product class is modeling exactly what it sounds, the products used in the application. They have eight parameters to define what it means to be a product. It implements Parcelable because it will be sending product objects to fragments using bundles. For those of you who haven't implemented Parcelable before, it's just a way of packaging objects so they can be passed through a bundle efficiently. Literally all you need to do is write implements Parcelable, like I've done here. Then click the red light bulb and implement the methods that Android Studio tells you to. Next, take a look at the util package. The first class in the util package is BigDecimalUtil. The methods in here will be used for converting big decimal objects to a string in this case and a float in this case. You'll see these in action later in the course. Next is PreferenceKeys. PreferenceKeys is just a class for holding all the shared preference keys we'll be using in the course. As you can see, there's only one. The Prices class is used for returning the prices of the product objects. The prices are stored in a HashMap so it's easy to reference them by their serial number. If that's confusing, the product serial numbers are the keys and the product prices are the values. It's going to make it easier for us to retrieve product prices given their serial number. Next is Products. The Products class is the main resource class for our project. It contains an array of all the products our app will contain. It also contains a HashMap named PRODUCT_MAP. PRODUCT_MAP has the serial numbers as keys and the products as values. It's there to make it easy to retrieve product objects given their serial number. And last, but not least, is StringUtil. StringUtil is similar to BigDecimalUtil in that it's responsible for object conversions. It converts integers to strings, as you can see from these two methods. We'll see this in action later in the course. Now that we've gotten all the housekeeping out of the way, let's get started and bind our first view.

Binding Activity and Fragment Views
Now that we have everything to get started, open activity_main, and let's bind our first view. The Data Binding Library is essentially a code generator. And to trigger the code generator, we need to set up the layout files in a certain way. Open the parent layout, open a new tag, and write layout, and then close it. Let's take the parent and put it inside the layout tags. This tells Android Studio that you're going to use data binding in this view. Now open MainActivity. By default, a binding class will be generated based on the name of the layout file. In our case, the layout is named activity_main. Android Studio will convert the name of the layout file to Pascal case, spelled P-a-s-c-a-l, Pascal. Converting activity_main to Pascal case will capitalize the first letter of each new word and remove the underscores. So activity_main becomes capital A, Activity, then capital M, Main. The Data Binding Library then appends binding to the converted Pascal case. So at the end, we have ActivityMainBinding. Android Studio generates a class named ActivityMainBinding. And this class will hold all the bindings from the layout properties. To create our binding object in MainActivity, we need to create an object of type ActivityMainBinding. Write a short heading, data binding, and now declare the object, so ActivityMainBinding, and we'll call it mBinding. If the object doesn't pop up with the autocomplete, just rebuild the project and try again. If it still doesn't, try cleaning and then rebuilding. Now inside onCreate, delete the setContentView method call and write mBinding = DataBindingUtil. setContentView, then the context, which is this, and then R. layout. activity_main. Run the app, and let's take a look. Great, so everything is working fine, and we have our first view coming through. Right now you're probably thinking so what? That doesn't seem like it saved a lot of time. If anything, it took more time because you had to create an extra object for the binding, and you're right. So just hold tight, and you'll see the dividends pay off soon.

Binding Data Objects
So far, we've learned to bind views. Now it's time to bind an actual object. Open activity_main. We're going to inflate ViewProductFragment and demonstrate the most basic form of binding an object. And of course, to inflate a fragment, we need a fragment container. So let's add a FrameLayout and give it an id of main_container. Now open MainActivity. Create a new method named init. Inside init, we want to do the fragment transaction and inflate ViewProductFragment. Create the ViewProductFragment object. Instantiate the FragmentTransaction object. It looks like it's importing the wrong FragmentTransaction library. Delete the android. app. FragmentTransaction import, and now import the support version. Use the replace method on the transaction, and add the fragment to the container. Then commit the transaction. Don't forget to call init in onCreate. Now open ViewProducFragment. As you can see, this is a very similar process to what we did in MainActivity. There's the binding object, but instead of calling DataBindingUtil. setContentView, we write mBinding = FragmentViewProductBinding. inflate and then pass the layout inflater. Then because this is a fragment, you must return the view by calling mBinding. getRoot. That will retrieve the rootView. That's pretty much the only difference when compared to binding an activity view. Before we talk about what's happening in the middle here, let's take a look at the layout. Open fragment_view_product. There's a lot going on here, so we'll take it slow. The first thing I want you to notice is the data tag. To declare variables in imports, you must use a data tag. This is mandatory. There's no way around it that I know of. Take a look at the product variable for now. Ignore everything else. Just focus on this variable right here. Notice the reference to our Product class in the type field. This is defining a variable in the layout named product of the Product class. I'm not required to name this product. This is just a variable name, and I can name it anything. I could name this foobar, for example. It doesn't matter. Go back to ViewProductFragment. Now consider this middle section. Here is where we can set the product variable that I just mentioned in the layout. We're just setting the first product from our resource class. Open Products. We're referencing the zeroth position, so we're passing a RED_LAMP to the layout. Now go back to fragment_view_product. Notice if I change the variable name to foobar and attempt to rebuild the project I get an error. It says product is missing. If I try to change it, it's giving me a suggestion of setFoobar. That's how data binding objects work. You create a variable in the layout file, then the Data Binding Library generate the methods for you behind the scenes. Let's change that variable back to Product. Now rebuild it again. Great, so we have our product object in the layout. Let's take a closer look at what's happening. Run the app so you have reference to look at as we go through this. The first TextView is the number of ratings this product has received. It's this number up here right in the top right-hand corner of the screen. When rating anything to do with data binding in a layout file, you need to start by running the @ symbol and then two squiggly braces. That let's Android Studio know that you're going to do something to do with data binding. Then here is our product variable and therefore our product object. We're calling a method on the product object named getNumberRatingsString. Open the Product class, and let's take a look at it. Scroll down to getNumberRatingsString. So all this method is doing is returning the number of ratings as a string and then surrounding it with brackets. So that's what we see here. It's the number of ratings surrounded by brackets. Go back to fragment_view_product. What using data binding to set text to a TextView, we must convert numbers to strings. You can't set an integer or any other data type here. For example, copy the TextView, comment it out, paste a copy below, and now just write product. num_ratings. Now run the app. You get an error saying reference not found. That's because you can't set an integer or any other data type to a text field in a TextView, and that's essentially what we're trying to do. There's many ways to solve this problem. You can do what I just did and create a method in the object class that returns a string, or you can even just write String. valueOf product. num_ratings. Run the app, and let's take a look. There we go. Everything's fine. Of course the brackets aren't there, but the data comes through fine. Now let's move onto the next widget, the RatingBar. If we take a look at the Product class, notice the rating is a BigDecimal object. So this is going to be different than setting an integer. The rating parameter actually requires a float, not a string. So we need some way to convert a BigDecimal to a float, and that's where this BigDecimalUtil class comes in. Open it up. This getFloat method is the one we're going to be using in the RatingBar. It converts a BigDecimal object to a float. Go back to fragment_view_product. But we can't just reference classes like that without importing them into the layout. Scroll up to the top. Notice the import for the BigDecimalUtil class. That will give us the ability to reference the BigDecimalUtil class in the layout. That's how we're able to use this static method called getFloat. Keep in mind I could've just called floatValue on the rating instead of referencing the BigDecimalUtil class. I'll show you what I mean. Copy the RatingBar. Now comment it out and paste it below. Now get rid of the BigDecimalUtil reference and just call floatValue, so product. rating. floatValue. Now run it. See, we get no errors. That works because that's actually all we're doing in the BigDecimal. getFloat method call. Take a look at BigDecimalUtil again. It's just returning the value after calling floatValue, so this is really basically unnecessary. I just wanted to show you how you could use an imported class to convert a value to something you needed. Next is the title. There's nothing particularly exciting here. We're just calling product. title, and then it's returning a string representing the title of the product. The image is much more interesting. I'm sure you notice the image is not coming through in the app. It's coming through as this purple color. That's because the image parameter in the product object is just a pointer to an image in the drawable folder. So it's actually just an integer that holds the address in memory where the drawable image lives. It's showing as purple because the ImageView widget is interpreting it as a color code. For example, watch what happens when I change this to #fff3. It changes yellow. And if we ran the app, it would also be showing yellow. So the ImageView widget isn't properly interpreting what we're trying to set here. It thinks you're telling to set a color to the ImageView, but really we're passing a pointer to an actual image in memory. We'll take a look at resolving this in future modules when we get started using Glide. Scroll down, and let's take a look at the next widget. These two TextViews represent the price of the product and the promotional or sale price of the product. If you don't know what I mean, open the Product class, and take a look at the price field and the sale_price field. Not every product has a sale price, only some do. Much like a real store, it would only have a few items on sale or promotion. In the RED_LAMP product, we have a price of 10. 99 and a sale price of 9. 50, meaning this item is on sale. But if you look at the YELLOW_LAMP product, the price is 11. 99, but the sale price is 0. We're defining a sale price of 0 to be no sale price. Go back to fragment_view_product. This is what's called a ternary statement. It's a logical statement that says if the product has a sale price, then show the sale price; otherwise, show the regular price. Let's look at the hasSalePrice method in the Product class. HasSalePrice checks to see if the sale price on the product is greater than 0. If it is, then it returns true; otherwise, it returns false. Go back to fragment_view_product. So here, if the product has a sale price, it will display it; otherwise, it just displays the regular price. This is pretty cool. I love being able to do this in the layout. Now take a look at the next one. This TextView is for displaying that slashed out price next to the one displayed in red. No matter what, this is always going to display the price field, and that's what we see here. But there's also a ternary expression on the visibility because we don't want to display a slashed out price if there's no sale. So once again we reference the hasSalePrice method, and if there is a sale price, then we want this widget to show; otherwise, we don't. By default, you can't just reference the view class like this. It requires an import like we did with the BigDecimalUtil class. Scroll up to the top and take a look. Here you can see we import the view class so that we can set the visibility. At this point, I'm guessing one of the questions you have is can you pass more than one variable to a view? So far, we've only looked at the product variable, but what if you needed more than one object class passed to the view, which in all likelihood you will? This qty variable is representing the quantity displayed in this section here. Scroll up to the top of the file. Here you can see the qty variable. It's defined as a type integer. Open ViewProductFragment. We're setting the quantity variable by calling setQty on the Binding, and then passing a value of 1 as an integer. Yes, we could have passed it as a string, but later it's going to make more sense to use integers here. Open fragment_view_product, then we're referencing the StringUtil class to get a special formatted string, and then set it to the widget. This is just like we did with the BigDecimalUtil class, but it's formatted differently. Take a look. Not only do we need to display the quantity, but we need it to read Q-t-y, quantity. Open StringUtil. There's the method. It takes an integer as an input, and then it returns a string formatted the way we needed it. Go back to fragment_view_product, and don't forget the import. Scroll back to the top. To use the methods in the StringUtil class, we need to import the class up here. We covered a lot in this clip. Data binding is a completely different way to approach development, so if you're confused, don't worry. I definitely was the first time I dabbled in data binding. There will be plenty more examples in the clips to come.

Module Review
Let's quickly review everything we covered in the module. We started by making sure we had everything we needed to use the Data Binding Library. In the SDK Manager, we made sure the Android Support Repository was installed. Then we set the dataBinding to enabled in the build. gradle app file. Currently, that's all you need to do to use the Data Binding Library, but there's been multiple changes in the past, so I recommend checking out the Android documentation if you run into problems. I'm making this video in February of 2018. If more than six months have passed, it's very likely this has slightly changed. Visit developer. android. com for more information. Next, we set up activity_main for data binding. We added the layout tag to activity_main and moved the CoordinatorLayout inside. That will cause Android Studio to generate data binding classes for that particular view. After rebuilding the project, you'll be able to declare the AcvitityMainBinding object in MainActivity. Remember the activity binding will be in Pascal notation with respect to activity_main, capital A, capital M, remove the underscores, and append binding to the end. After we had the binding object, we instantiated it and set the view by calling DataBindingUtil. setContentView, then this, and then R. layout. activity_main. At that point, we ran the app and confirmed it was successfully inflating the view. Next, we worked on binding data objects in ViewProductFragment. We followed the same process as in MainActivity and set the binding, but it was a little different. Instead of using the DataBindingUtil class, we inflated the fragment by calling inflate on the FragmentViewProductBinding object. Fragments are a little different than activities, just as they are without data binding. There are two variables in the layout file, a product variable and an integer variable named q-t-y. We used the variables to set the various widgets in the view and in some cases referenced the BigDecimalUtil class, the StringUtil class, or the View class. Remember when setting text in a TextView you must use a string. There are many ways you can do this. You can create a method in the object class, just like I did, with getNumberRatingsString. You can use String. valueOf or create a custom class like BigDecimalUtil or StringUtil and reference a static method. The ImageView widget was not setting our image properly. It was interpreting the drawable resource as a color code when in actuality it's a pointer to a resource in memory. We'll solve this problem later in the course. There was a few examples of using ternary expressions. One was determining if there was a sale price or not. If there was a sale price, it would be displayed and another widget would be visible displaying the original price slashed out. If it wasn't, then only the regular price would be displayed. In the next module, we'll build the product list using a RecyclerView.

RecyclerViews and Data Binding
Introduction
Data binding in lists and RecyclerViews is very simple, and you'll find your adapter classes have much less code then they usually do. For the duration of the module, we'll be working with the source code files in the directory Module_3/start/TabianGifts. You can download the source code files by navigating to the course on Pluralsight and clicking on the tab labeled Exercise Files. The process is pretty much the same as inflating an activity or a fragment view, but of course the code will be in the RecyclerView. Adapter class. Just like any RecyclerView, we'll begin by building the list item layout for each individual item in the list. We need the image; the title; the price; the sale price, if applicable; the rating; and the number of ratings. Then we'll inflate the layout in the RecyclerView. Adapter class by using data binding. To add the items to the adapter and initialize the RecyclerView, we'll build a custom binding adapter. The custom binding adapter will allow us to set the RecyclerView items directly in the layout, like you see here. The products variable will be a list of products. The variable will look like this. You'll have a name of products, and then the type will be List, taking in a list of products. This is a very convenient way to set up a RecyclerView, and it will keep your code nice and organized. After our RecyclerView is all set up, we'll start working on resolving the image issue that we ran into in the last module. Remember, the ImageView widget was not interpreting the data correctly, and it was just displaying a color in the widget. You'll see this happening again in our RecyclerView. To resolve this, we'll build another custom binding adapter and integrate the Glide library. When our new custom binding adapter is complete, we'll be able to set images to widgets like this. After the RecyclerView is completely set up and displaying the correct data, we'll work on adding functionality to navigate to ViewProductFragment when a user selects as item from the list. In this view, the user can get a better look at the individual properties that define each item. They'll also be able to adjust the quantity and add it to their cart. To intercept the click events on the list items, we'll use an interface and implement in the interface in MainActivity. The interface will be named iMainActivity, and we can set it as a variable in the list item layout. Now that you have an idea of what we're going to be working on, let's get started.

Custom Binding Adapter for RecyclerView
As you saw in the introduction, we'll need to build a custom binding adapter to set the list of products to the RecyclerView widget. If you haven't already, make sure you get the source code files from the directory Module_3/start/TabianGifts. I've made a lot of changes since the end of the last module. Let's start by talking about the changes. There's been four new files added: MainFragment, fragment_main, product_item, and ProductsAdapter. In MainActivity, I've also changed the init method to inflate MainFragment instead of ViewProductFragment. We were just using ViewProductFragment as an example in the last module. Open up fragment_main. Start by taking a look at the data tag in this layout. We only have a single variable named products. It's a list of product objects. This notation probably seems strange to you. Let me explain. The left caret symbol can't be expressed into the type parameter, so instead, we need to use the HTML type code. The HTML type code for a left caret is &lt then ;. This will be read and interpreted by the compiler as a left caret. So this is just a list that contains product objects. Also notice that because we're using a list we need to import the List library. I've added a SwipeRefreshLayout so we can refresh the list later on when it's all set up. And finally, we have our RecyclerView. Open up MainFragment. MainFragment is the fragment class that will be inflating fragment_main. xml. Almost everything here we've seen before. There is the binding declaration, the binding instantiation, but what's different is this OnRefreshListener. This is how you apply a listener when using data binding. You reference the binding, then the ID of the widget you want to apply the listener to. Take a look at fragment_main again. Here the id is swipe_refresh_layout. Now go back to MainFragment, and here we see mBinding. swipeRefreshLayout, and then setOnRefreshListener, and then this. With data binding, the underscores are removed, and the first letter of every word is capitalized, except the first letter. These methods down here will be for refreshing the lists later on. You can ignore them for now. Next, open product_item. xml. This is the layout for the individual list items in the RecyclerView. There's nothing special here that we haven't seen before. It's basically just the same old fragment_view_product, but the widgets are arranged differently. Now open ProductsAdapter. Here is the RecyclerView. Adapter class. Scroll down to the BindingHolder class. This is the ViewHolder. You're probably used to calling this class ViewHolder because that's the current convention. But since we're using data binding, I called it BindingHolder because that's what it's doing. It's holding the binding in the view. The first thing I want you to notice is the two options I have here. One of them is commented out. When it comes to data binding in RecyclerViews, there's actually a generic class you can use to set any layout. That class is called ViewDataBinding. So there's absolutely no difference if I use the binding class that was generated for the layout, which is product_item. xml, or I use the generic one, ViewDataBinding. We'll come back to this later if you don't understand. Inside the constructor, we can set the binding by calling binding = DataBindingUtil. bind and then pass itemView. Now let's take a look at onCreateViewHolder. Once again I have one declaration commented out here because this is for ViewDataBinding. If I wanted to use it, I would just comment this out, now uncomment this, and uncomment this. Now comment this out in the BindingHolder. Hopefully that clears things up for you. They do the exact same thing. One is just using a generic class, and one is using a class generated by product_item. xml. Now let's look at the onBindViewHolder method. First, we get the product object for this particular position in the list. Then, set the product using holder. binding. setProduct and pass the product. Notice the setProduct method is giving us an error now. It wasn't giving us an error when we were using the ProductItemBinding. That's because setProduct is a method that only exists in ProductItemBinding. We've commented it out and are currently using the generic class. If you're using the generic class, you need to set the variables this way, holder. binding. setVariable, and then BR. product, and then product. BR is referencing the BR class file that contains all the data binding variables for the project. So instead of referencing the product variable through the ProductItemBinding class, we can reference it directly from the BR class. If you're curious, you can view your project's BR file by going to Packages, then app, then opening the databinding. library, baseAdapters, and then opening the BR class. And here's all the variables we've declared in the project. Okay, let's go back to ProductsAdapter. Keep in mind that setting variables this way will always work. You can always reference them directly from the BR class, as opposed to referencing them using methods like setProduct here. They won't work if you don't reference the binding class that contains that particular variable. If you want kind of a general rule to go by, just set them using setVariable. It will always work. Let's change all the comments back to product_item listing. Notice the errors go away. Now that you sort of understand what's happening here, let's build the custom binding adapter for setting up the RecyclerView. Right-click on the main package directory, go to New, then Package. Name it databinding. Now right-click on the new package, go to New, Java Class, and call it MainFragmentBindingAdapters. To build a binding adapter, we need to start with the @BindingAdapter annotation. Then inside, we need to put a string that will represent how we call the adapter. Just write productsList, so BindingAdapter and then productsList. Now create the BindingAdapter method. Write public static void setProductsList, pass a RecyclerView widget, and then a List of products. When making a binding adapter, you need to pass the layout or view type that you're going to be using it on. We're going to be setting up a RecyclerView, and therefore using it on a RecyclerView layout. That's why we pass a RecyclerView here. And of course, we need our list of products to add to the adapter. Now go about the regular process to set up a RecyclerView. Start by checking to see if the products list is null because if it is, we don't want to set up the list. Next, get the LayoutManager. Write RecyclerView. LayoutManager layoutmanager = view. getLayoutManager. Then if the layoutManager is null, we need to instantiate a new one. So view. setLayoutManager, and then new GridLayoutManager, view. getContext, and then pass the number of columns, which is 2. Let's create a global variable for our number of columns. Scroll up to the top and write private static final int NUM_COLUMNS = 2. And now pass that to your GridLayoutManager. Lastly, we need to instantiate our ProductsAdapter. So ProductsAdapater adapter = (ProductsAdapter) view. getAdapter. If the adapter is null, we need to create a new one. So adapter = new ProductsAdapter, view. getContext, and then products. And then set the adapter to the RecyclerView. That's it. Now let's use it. Open fragment_main. Inside the RecyclerView write app:productsList, and then @ symbol, and reference our products. This will send our products list to the binding adapter that we just created and therefore set up our RecyclerView. Notice I didn't need to pass the RecyclerView as a parameter, even though in the BindingAdapter it's there as an input. Open MainFragmentBindingAdapaters. See? We didn't need to pass it. The BindingAdapter will automatically capture this parameter from the view that you use it in. Go to fragment_main. Because we used this on a RecyclerView, it was automatically passed to the adapter. We're almost done. We just need to write a bit more code in MainFragment. Create a method named setupProductsList. Get the list of products, so Products products = new Products. Now create a new list of product objects and set it to the binding, so List Product productList = new ArrayList, and then productList. addAll, Arrays. asList, and then products. PRODUCTS. Then do mBinding. setProducts and pass the productList. Call the method in onCreateView, and we're ready to test. Run it, and let's take a look. Great, everything is working as expected. We have the list of items coming through and populating the list. Obviously the images are still not coming through because we haven't fixed that issue yet. Go back to MainFragment, and let's finish up by setting up the SwipeRefresh. Inside the onRefresh method write Products_products = new Products. Now create a new list of product objects. Then add the products to the list just like we did before. Then call the refreshList method in the adapter, so reference the ProductsAdapter by writing mBinding. recyclerView. getAdapter. And then call the method refreshList and pass the productList. If you didn't notice the refresh method, open ProductsAdapter, and let's take a look. Up here is the refreshList method. It takes a list of products, clears the current one, and then adds the new list, then, of course, notifies the adapter that the dataset has changed. Run it, and let's take a look. Okay, try swiping down. We can't really tell if it's working correctly at this point because there's no images to be loaded, so we'll have to take a look at it later when we resolve the image problem.

Binding Adapter for Setting Images
As you've seen, we're currently unable to set drawable resources to ImageView widgets. Let's build a custom binding adapter to solve that problem. So far, everything is very organized, and keeping it that way would be ideal. So let's create a separate class just for setting images using Glide and a custom binding adapter. Right-click on the databinding package, go to New, Java Class. Call it GlideBindingAdapters. If you're familiar with Glide, you already know it's very accommodating. You can pass it a drawable, an image URL, a URI, an integer pointing to a resource in memory, or even a URL from the internet. No matter what you give it, it will set the image to the ImageView widget. It's very convenient. In our situation, we're dealing with integers that point to resources in memory, so we'll work on that case first. First, we're at the BindingAdapter annotation, and we're going to call it imageUrl. Now create the method, public static void setImage, and then pass the ImageView widget and the integer resource, and name it imageUrl. We're going to be using this on an ImageView widget. That's why we're passing an ImageView here. The last binding adapter we made was for a RecyclerView, so we passed a RecyclerView as an input. If you don't remember, open MainFragmentBindingAdapter, this input parameter right here. All right, go back to GlideBindingAdapters. Now let's use Glide to set the image. First, let's get the context, so Context context = view. getContext. Now create some request options for Glide. Write RequestOptions options = new RequestOptions. Set the placeholder image, so write. placeholder and then R. drawable. ic_launcher_background. And then set the error image, so. error and pass the same thing. Now set the image using Glide, so write Glide. with(context), then setDefaultRequestOptions and pass the options, load the imageUrl, and then load it into the view. Open product_item. xml. Inside the ImageView widget, get rid of the source parameter. Now write app, reference our imageUrl binding adapter, and then pass the product. image. Now run it, and let's take a look. As you can see, our image is being set now, but there's a problem. What happens if the image resources aren't integers. In our case they are, so it works fine, but what if they were string URLs? String URLs are probably the most common form of resources. I'll show you what I mean. Create a new variable at the top of the file. Just call it testUrl, and give it a type of String. Now go into the ProductsAdapter, scroll to onBindViewHolder, write holder. binding. setTestUrl, and then just pass a blank string for now. I'm just going to get one from the website reddit. com. You don't need to get one from Reddit, but that's where I'm going to go because it's an easy place where you can find tons of images. Copy the URL, go back to Android Studio, and paste the URL in here. Now go back to product_item. Pass the variable testUrl to the binding adapter, just like we were doing with the integer resource. Now run it. Notice we get an error saying Cannot find the setter attribute for app:imageUrl with parameter type String on ImageView. Open GlideBindingAdapters. It's right to be throwing the error. Currently, we're only accommodating the case when the image resource is an integer. Copy the binding adapter. We're going to overload it. All we need to change is the object type for the imageUrl. Change it to a String. Now run the app again. It works. There's the test image coming through. So this is something you need to watch out for. Glide can accommodate a ton of resource types, but you'll need to write custom adapters for each one of them. Luckily, it's simple. You just have to copy the binding adapter and then change the object type. Go back to product_item, remove the testUrl object, and change this back to say product. image. Whoops, we need to remove the setTestUrl method from the binding adapter. Delete that, and run it again. Great, everything's back to normal. The next step in development is going to be inflating ViewProductFragment when a user clicks on an item from the RecyclerView.

Implementing a Custom Interface
The Android documentation says all fragment to fragment communication is done through the associated activity. Two fragments should never communicate directly. But what about data binding? How can we implement an interface with data binding? Before we begin, I wanted to find what we're trying to accomplish. When a user clicks on an item from the list, we want to inflate ViewProductFragment and view the product they selected. So we need to somehow tell MainActivity to inflate ViewProductFragment, and then send the product they selected in a bundle to the new fragment. That's our objective. Typically to accomplish this I'd use an interface in the adapter class and implement the interface in MainActivity. Then capture the click and inflate the fragment. No big deal. We're still going to do that, but it's going to be a little different because we'll be using data binding. Right-click on the main package directory, go to New, Java Class. Make sure to change this to an interface, and call it IMainActivity. Write void inflateViewProductFragment, and then pass the product object. Now here's where it gets interesting. First, open product_item. xml. Create a new variable named iMainActivity, and give it a type of IMainActivity. Inside this LinearLayout, we want to call the interface method inflateViewProductFragment. Attach an onClick listener and write two brackets, then an arrow, iMainActivity, and then reference our method. So when the user clicks the LinearLayout, then encapsulates the entire view, inflateViewProductFragment will be called through the IMainActivity interface. But we're not done yet. We still need to set the interface to the binding. Right now, we just have a variable in the product_item. xml file. Open ProductsAdapter. Normally to add an interface, you need to declare a global variable, then insert the onAttached method for RecyclerView, so onAttachedToRecyclerView, and then instantiate the interface inside onAttached. Then still you need to attach an OnClickListener to the layout and then finally call the interface method inside the OnClickListener. You don't need to do any of that with data binding, so let's delete all of that. All that can be done with a single line of code, holder. binding. setIMainActivity, then IMainActivity, and pass the Context. That's it. Now the IMainActivity interface is added to the view, and we can use the methods like we did in product_item. Open MainActivity, and let's implement the interface. Click the red light bulb, and let's implement the method. Instantiate the new fragment, ViewProductFragment fragment = new ViewProductFragment. Create a bundle, so Bundle bundle = new Bundle. Add the product to the bundle, bundle. putParcelable(getString(R. string. intent_product), and then pass the product object and set the arguments, so fragment. setArguments, and pass the bundle. Copy the FragmentTransaction from the init method, change the fragment tag to fragment_view_product, and we also want to add this transaction to the back stack. So write transaction. addToBackStack, then getString(R. string. fragment_view_product). Easy enough. Open ViewProductFragment. I made a few changes to it. Notice now there's an onCreate method that retrieves an incoming product from the bundle. Then in onCreateView, the product is set to the view. Let's run it and take a look. Looks like the images aren't coming through. Open fragment_view_product, and let's figure out why. Oh, right here. The ImageView isn't using our new binding adapter. Write app:imageUrl, and then reference the image. Now, run it again. Great, everything is working as we expect; however, there's something I want you to notice. Watch what happens when the items open. Glide is taking a moment to load them and then set them to the ImageView widget. And in the meantime, the user sees that default image. That's obviously not a good user experience. Adding something like a progress bar while the image is loading would look much better, and then also hiding that default image until the real image is set. I just wanted to point that out to you and give you something to think about. We'll work on a fix for that in the upcoming modules.

Module Review
We're beginning to dive deeper into the Data Binding Library. Let's quickly review everything covered in the module. We started by setting up the RecyclerView and its adapter class. We still used a ViewHolder, but we called it BindingHolder instead. Remember using the generic binding class called ViewDataBinding is always an option, but we chose to stick with the binding class associated with our layout. The onBindViewHolder method contained much less code than what's usually required when not using data binding. All we needed to do was get the product and set the variable to the layout, then call executePendingBindings. We also added an interface to the list. It was called IMainActivity and was used to inflate ViewProductFragment. Inside product_item. xml we had two variables, a product variable and an IMainActivity interface variable. The product variable was obviously used to display our product in the list. The interface was set to respond to an onClick event when the user clicks on the layout encapsulating the entire list item. To inflate the fragment, we called the inflateViewProductFragment interface method and passed the selected product. To set the list of products to the RecyclerView, we created a custom binding adapter. The adapter would take a list of product objects and initialize the RecyclerView and the adapter. Using the binding adapter was simple. We just need to write app:productsList and then reference the list of products in fragment_main. The list of products was set to the binding in MainFragment with the setupProductsList method. To resolve the issue we were having with the images not setting, we created another custom binding adapter. The custom binding adapter takes the image resource, whether it's a string or an integer pointer, and then sets the image using Glide. Remember, to make sure it's compatible with integer pointers and also string URLs, we needed to overload the BindingAdapter method. We had one that accepted an integer resource and one that accepted a string resource. Other than the input parameter, they were identical. Using the binding adapter in product_item. xml was simple. We just had to write app:imageUrl and then reference the product's image. We've begun to dig deeper into the Data Binding Library. We've bound objects, set up lists, created custom binding adapters, and even implemented a custom interface. In the next module, we'll start working with observables, which in my opinion, is the most useful part of the Data Binding Library.

Custom Observables and Extending BaseObservable
Introduction
As we've seen, data binding gives developers the ability to pass variables to layout files and access their properties. But what happens if the properties change or need to be updated? That's where observables come in. For the duration of the module, we'll be working with the source code files in the directory Module_4/start/TabianGifts. You can download the source code files by navigating to the course on Pluralsight and clicking on the tab labeled Exercise Files. First, let's talk about what an observable is. In data binding, when something is observable, it means the properties of that object will be updated automatically if there's any changes made to it. Another way to put it would be to say the object properties are synchronously updated if any changes are made. The Data Binding Library has a number of Observable classes. The first of which is the Observable interface. A class that implements the Observable interface will allow the binding to attach a single listener to a bound object to listen for changes of all the properties on that object. Implementing the interface is okay, but notifying the objects they've been changed is still up to the developer. To make the process simpler, the BaseObservable class was created to implement the listener registration mechanism. Notifying the objects they've been updated is still technically up to the developer, but there's an annotation we can use to automate that process, therefore making it much simpler. Basically, if you were to compare implementing the Observable interface and extending BaseObservable, extending BaseObservable is going to work for 95% of the use cases and be much more simple. We'll talk more about this when we look at some actual examples. The Data Binding Library also offers a number of convenience classes known as observable fields. Observable fields are exactly what they sound like. They're essentially observable versions of all the primitive Java data types. So you have ObservableBoolean, ObservableByte, ObservableChar, ObservableShort, ObservableInt, ObservableLong, ObservableFloat, ObservableDouble, and ObservableParcelable. I think these Observable classes are great for simple cases, but I think they won't likely be very useful when you're actually developing apps. They seem great in theory, but they lack in customizability. The Data Binding Library also offers observable collections. There's ObservableArrayMaps and ObservableLists. My opinion on these is roughly the same as the primitive data types. They sound great in theory, but because they lack in customizability, you probably won't find them very useful. At this point, you're probably thinking, Mitch, you said this was your favorite part of the Data Binding Library, but all you've done is tell me stuff that isn't actually useful. If you're thinking that, you're mostly right. I did, however, mention the BaseObservable class and how it will work for probably 95% of the use cases you'll encounter. So that's what we're going to be focusing on. We're going to create custom observable model classes tailored to each individual layout file. Take fragment_view_product as an example. Currently we have a product variable and an integer variable named qty. We're going to build a class named ProductViewModel that extends BaseObservable. The class will contain an observable product object and an observable integer object named quantity. Then instead of using product and qty as variables in the layout, we'll use the ProductViewModel object. Then we can access the product or quantity variables by writing ProductView. product or ProductView. quantity. And because the ProductView class extends BaseObservable, everything in the layout will be observable and update synchronously without us having to do anything. It's almost like having a background process constantly running and checking for updates to your variables.

Building a Custom Observable Object Class
As we talked about in the introduction, extending a class with BaseObservable is the sweet spot in terms of ease of integration and practicality, so we're going to take advantage of that and build a custom Observable class for ViewProductFragment. Open fragment_view_product, and let's review what we've done so far. Currently we have two variables in here, one for the product and one for the quantity. What we want to achieve with a custom Observable class is packaging all the variables together in one location and also making them observable. Right-click on the models package, go to New, Java Class. Call it ProductViewModel. Start by extending the class by BaseObservable. Now inside this class, we want to define all the variables that we'll be passing to the layout. Start with the product, so private Product product. Now we need the getter and setter methods for our product object. Press Alt+Insert on Windows or Cmd+Insert on Mac and insert the methods. Now we need to add a Bindable annotation to the getter method. The Bindable annotation will generate an entry in the BR class that we looked at earlier. Then in the setter method we need to notify the BR class that a change was made, so write notifyPropertyChanged, then BR. product. That's it. Open fragment_view_product. We don't need the product object anymore. Replace the variable name with productView and set the type to our ProductViewModel class. Press Ctrl+R, and replace all the product variables with productView. product, and make sure to change this back to ProductViewModel. Now open ViewProductFragment. Currently we're still setting a product object to the view, but we need to set our model class. Create a new ProductViewModel object, so ProductViewModel productView = new ProductViewModel. Now add the model to the binding instead of adding the product. You might need to rebuild here since we've changed the layout. If the binding is still giving you an option to set the product, you need to rebuild. Remove the setProduct method call. Instead write productView. setProduct, and then pass the Product. Then set the model to the binding, so mBinding. setProductView, and then pass the productView. If you're still having issues, try cleaning then rebuilding. You can clean the project by clicking on Build and then Clean Project. I want to take a second and talk about a problem you might run into at this point. I know I did, so I want to mention it. If you're getting some kind of an error saying cannot find symbol BR or anything like that, you'll need to invalidate the Android Studio cache and restart. Cleaning and rebuilding likely won't fix the problem. Open ProductViewModel. Basically what will happen is this BR class will not be able to import. The blue writing will keep popping up and telling you to import it, but when you do, nothing happens. If that's happening, then you'll need to go to File, Invalidate Caches/Restart, then Invalidate and Restart Android Studio. It should be fine after that. All right, so at this point we should be good to run that app and make sure the model is coming through. Okay, click on an item. Great, everything's working. All the data is being displayed. Now let's work on adding the quantity to the ViewModel class. Create a new variable for the quantity. Insert the getter and setter methods, Alt+Insert on Windows or Cmd+Insert on Mac. I like to group the getters together and the setters together. There's no reason for this, just a preference of mine. Now add the Bindable annotation to getQuantity. Then notify the property has changed in the setter. It's not showing up in the BR class, so I'm going to rebuild. There we go. That fixed it. Open ViewProductFragment. Remove mBinding. setQty and instead set the quantity to the ProductViewModel object. Open fragment_view_product; search for the qty variable, so press Crtl+F; and replace it there. Now remove the variable from the top of the file. All right, let's run it. Select a product. Cool, so our new model class is successfully displaying the data. I know this probably doesn't seem all that incredible. So far all we've really done is organize the data better. We took a layout that had two variables and squished it into a single class, but we're just getting started. That was basically an introduction to custom observables. Now we're ready to start using them.

Two-way Data Binding with a BindingAdapter
Earlier in the course, I mentioned an area we could improve on. The images being displayed in ViewProductFragment take a moment to load, and adding a progress bar would likely look much better. Let me remind you. Notice when I select products from the list, the images are taking a moment to load, and we're seeing the default image for a short period of time. Making the fragment invisible until the image is loaded and adding a progress bar would look much better. Compare with the app demo. Notice you never see the default image, and a progress bar is being displayed in the meantime. That's what we're going to work on. Open fragment_view_product, and let's define the problem before we work on a solution. We need a way to hide the layout containing the product object parameters. Hiding this LinearLayout should do the trick. It encapsulates every widget that has to do with the product. Since we'll be hiding the layout, we need to add a progress bar outside of it. Right here would be perfect. Let's just write it in now. Give it a width and a height of 50dp, give it an id of progress_bar, center in the Parent, and set the visibility to gone. Okay, so basically we want to show the progress bar and hide the LinearLayout while the image is loading. Then once it's done loading, hide the progress bar and show the LinearLayout. That seems simple enough. The Glide library has an interface called RequestListener we can use to detect when images are done loading. Sounds like we have everything we need. The logic seems simple enough, and we have a listener for detecting when the image is done loading. But how do we implement this in data binding? Open ProductViewModel. We're going to add another variable named imageVisibility. By default, well set it to false, so private boolean imageVisibility = false. ImageVisibility will be set to true once the image is done loading. Then we can use it to write a ternary in the layout file. Before we finish writing the logic in here, let's write the ternary. Open fragment_view_product. In the ProgressBar visibility write productView. imageVisability and then? View. GONE or View. VISIBLE. Then in the LinearLayout, write the same thing, except do View. VISIBLE or View. INVISIBLE. Notice these two are opposing. If one is visible, the other won't be. Also notice the ProgressBar is set to GONE, but the LinearLayout is only set to INVISIBLE. If we set it to GONE, the listener won't trigger properly later on. I just wanted to point that out. Now go back to ProductViewModel, and let's write the logic. First, insert the getter and setter methods for imageVisibility. I like my setter methods grouped and my getter methods grouped, so I'm just going to rearrange this. Now we just need a way to set the imageVisibility Boolean when the image is done loading. Let's create that RequestListener interface for Glide. So public RequestListener getCustomRequestListener, and now we want to return a new RequestListener. Inside the onResourceReady method write set imageVisibility to true. That will set the Boolean and consequently update the ProductViewModel object. Okay, but how will Glide know what image we're talking about? We need to reference this RequestListener when we set an image. Open GlideBindingAdapters. We need a new binding adapter that can set the RequestListener from our ProductViewModel class. Our new binding adapter will need to take two parameters, the imageUrl, as it was doing before, and then also a RequestListener. Copy the BindingAdapter from above. Add two input parameters, one for the requestListener and one for the imageResource. If you're confused, don't worry. I'm just going to write it all out, and then we're going to talk about it. Change the method to bindRequestListener, change the input resource to imageResource, and pass the new input variable to Glide. We just need to make one small change. We need to set the listener. Add a third variable named requestListener to the input fields. Now set the listener to Glide. Just write. listener, and then pass requestListener. Okay, quite a few things we haven't seen before. First, this BindingAdapter accepts more than one parameter. If you want your binding adapter to accept more than one variable, you need to write it this way, squiggly brackets on either end, and then separate the variable names by commas. Then we have the variables being passed to the method in here, the requestListener and the integer imageResource. Keep in mind the names of these variables don't have to match. For example, I could change the requestListener name to listener, and that would be fine, but the order does matter. The requestListener is first here, so it also has to be first here. All right, there's our new BindingAdapter. Open fragment_view_product, and let's use it. Se the imageResource by writing app:imageResource and then referencing the image. Then set the listener by writing requestListener and then referencing our customRequestListener. Remember the RequestListener is come from our ProductViewModel. This might be confusing to you because I didn't write getCustomRequestListener, but with data binding you don't need to write the get part. It knows what I'm referring to. Open ProductViewModel. It knows that by running productView. customRequestListener I'm actually referring to this, getCustomRequestListener method. Well, let's try it out. Okay, click on a bunch of products. That looks much better. You don't see the default image, and there's a progress bar showing while it loads. If this is your first experience with two-way data binding, you might be a little confused, and that's totally normal. It's a very different way of going about things. We have a listener waiting for a change in the view. Once that view gets changed, it then triggers another change in another view. That's what's known as two-way data binding. I like to think of it as views triggering updates to other views. I don't think you can argue that writing code this way is much cleaner, and everything is very organized.

Module Review
There was a ton of new concepts in this module. Let's quickly review them. We started by talking about observables and the various convenience classes the Data Binding Library provides. There's ObservableBooleans, ObservableBytes, ObservableChars, ObservableShorts, ObservableInts, ObservableLongs, ObservableFloats, ObservableDoubles, and ObservableParcelables. These Observable classes are great in theory, but I think you'll find their use cases very limited. The Data Binding Library also offers observable collections. There's ObservableArrayMaps and ObservableLists. We chose to not take advantage of these convenience classes and instead create a custom Observable class that extends BaseObservable. In my opinion, BaseObservable is the best of the best in terms of observables. It's simple, but very flexible. We created a custom Observable class named ProductViewModel that extended BaseObservable. By the end of the module, we had three variables: a product, an integer representing the quantity, and a Boolean for setting the visibility of the content in the layout. Each variable had both getter and setter methods. The getter methods had the @Bindable annotation signifying that they were observable objects. The setter method set the new values and notified the BR class that a change had been made. They notified the BR class by calling notifyPropertyChanged, then referencing the variable. The ProductViewModel class also had a method for getting a RequestListener. The RequestListener will set the imageVisibility variable to true once an image is finished loading. Implementing the ProductViewModel in fragment_view_product was simple. We just added the variable to the data tag, then referenced the model when setting the properties. For example, setting the title of a product might look like this. To detect when the image is done loading, we built another custom binding adapter. This BindingAdapter was different than the others we've made so far. It accepted two parameters, a requestListener and an integer. It's exactly the same as the other Glide binding adapters we've made, other than the requestListener. Here's how we used it on an ImageView. To set the imageResource and requestListener to the ImageView, we just wrote requestListener = productView. customRequestListener. And then for the image, imageResource, productView. product. image. And lastly, we made a few small changes to ViewProductFragment to incorporate our new model. Instead of setting the product, we instantiate a ProductViewModel object, then set the Product, and set the Quantity. Then set the ProductView to the Binding. When we ran it, we could see the progress bar until the image was loaded. Once it was loaded, the progress bar would be hidden, and the layout made visible.

Leveraging an Interface with Data Binding
Introduction
At this point in development, we have a list of products and the ability to view a product in more detail by clicking on it in the list. We're building a shopping app, so logically the next step should be adding items to the cart. For the duration of the module, we'll be working with the source code files in the directory Module_5/start/TabianGifts. You can download the source code files by navigating to the course on Pluralsight and clicking on the tab labeled Exercise Files. Since the app isn't online, we're going to be using SharedPreferences to save items added to the cart. As I mentioned in the course prerequisites, you should be familiar with SharedPreferences. If you're not and you need a little refresher, check out Android Fundamentals: SharedPreferences on Pluralsight. I'm going to butcher this author's name, but I think it's pronounced Sriyank Siddhartha. SharedPreferences supports a set data structure, so every time a user adds an item to the cart, we'll save a serial number into a set of strings, then save the set to SharedPreferences. It'll look like this, Set String serialNumbers = preferences. getStringSet, then reference the key to the set, and set a default value of a new HashSet. Then add the new serial number of the item added to the cart, serialNumbers. add, and then String. valueOf, product. getSerial_number. We'll also keep track of the quantities using SharedPreferences. Each item saved to the cart will have a serial number. The serial number will act as a key to their individual SharedPreferences integer. Since the cart items will be saved or removed using SharedPreferences, it makes logical sense to manage the transactions in a single location, or in other words, in a single class. It would add unnecessary complexity and repeated code if we have separate methods in each fragment class. So what we'll do is add methods to our IMainActivity interface that we can leverage to build a cart management system. For example, if I'm adding an item to the cart in fragment_view_product, the actual commit of the item to SharedPreferences will take place in MainActivity, not in fragment_view_product. We'll create an interface method that's triggered when a user clicks on the Add to Cart button, then implement the interface method in MainActivity. To select item quantities, we'll build a dialog fragment and once again use the IMainActivity interface to send the quantity back to ViewProductFragment. In a nutshell, this module is going to be all about effectively using an interface with data binding. Let's demo what we want to achieve in the module. We'll be able to select quantities using this dialog. The selected quantity is sent from the dialog to MainActivity through the IMainActivity interface, then from MainActivity to ViewProductFragment, and displayed in this view. If I click Add to Cart, the product gets added to the SharedPreferences shopping cart, and the number of unique items in the cart is incremented up here. So if I go and add a second item, the number of items in the cart is now increased to 2, and that number reflects the new size.

Updating an Observable with an Interface
Selecting a value from a dialog and updating a view usually involves writing a lot of code. As you'll see, data binding reduces the amount of code you'll write and keeps things nice and organized. I've made some code changes since the last module, so you'll want to get the source code if you haven't already. Open up IMainActivity. To inflate the dialog, I've created a new interface method named showQuantityDialog. Open fragment_view_product. The showQuantityDialog method is called down here when a user clicks on the RelativeLayout. Like we've done in the past, we're using an onClick attribute to capture the click, then referencing the interface and calling showQuantityDialog. Open MainActivity, and let's look at the new method. All we're doing here is instantiated the dialog object, then showing it. That won't inflate the dialog, so you just can select a quantity. Now let's look at the dialog itself. Open dialog_choose_quantity. We're going to use a dialog fragment to display numbers 1-10. This is the layout of that dialog fragment. There's nothing special here. It's basically just a ListView containing an array of numbers. The numbers are saved in the arrays. xml file located in the values folder down here. The numbers are set to the ListView by adding an entries attribute and referencing the array. Now open ChooseQuantityDialog. This is the class that inflates the layout we just looked at. There's nothing we haven't seen before. We have our binding and all the layout variables being set. The only thing that's a little different is the fact that this is a ListView, OnItemClickListener, and not a RecyclerView. Inside the listener interface, we reference the IMainActivity interface and set the quantity that was selected. Open IMainActivity. Here is the new interface method. Open MainActivity, and let's look at it. To update the quantity in the ViewProductFragment binding, we need to get a reference to the ViewProductFragment. To get a reference, we can write ViewProductFragment, getSupportFragmentManager, and then findFragmentByTag and reference the fragment tag. Then if the fragment isn't null, we just want to update the quantity. This is a very simple example, but it's a powerful one. This highlights my favorite feature of the Data Binding Library. I can easily update the widgets in a view by simply referencing the binding. Like I said, this is a simple example, but what if we wanted to change the product to a different one and not just change the quantity? Consider this. Let's set a new product. If we weren't using data binding, that would require us to set every single widget in ViewProductFragment or destroy it and then reinflate it while sending a new product object through the bundle. Not a simple task. Watch how easy it is with data binding. I'm just going to get the list of products, and then write fragment. mBinding. getProductView, and then setProduct to a new product. That's it. That will completely change the view. Run it, and let's take a look. Click on the Coffee Mug. Now when we select a quantity, the product should change to something else. And there's the red lamp. So it changed from the coffee cup to the red lamp. Every widget in the view has just been updated instantly, and we wrote one line of code. That's pretty awesome. Remove those two lines, and let's run it again. Click on an item, open the dialog, select a quantity. Great, the quantities are being set.

Saving Item Quantities in SharedPreferences
We have a way to adjust quantities. Now we need a way to add items to the cart. Open IMainAcvitity. Create a new interface method, and name it addToCart. Now open MainActivity. Scroll down to the bottom, and let's insert that new method. I'm just going to type it out, Override, now public void addToCart, and take a product. Start by getting the SharedPreferences object, then the editor object. Get a list of the current serial numbers added to the cart. Remember, we're going to be using a set for this. Add the serial number of the product, add the set to SharedPreferences, and commit. Now we need to save the quantity. Get the current quantity of this item that's in the cart, so int currentQuantity = preferences. getInt, and then reference the serial number. Now sum the currentQuantity with the new quantity. Then commit the changes to SharedPreferences. Whoops, looks like I forgot to add the quantity to the interface method. Add it as an input up here, open IMainActivity, and add it as an input here also. Now reset the quantity that's being displayed on the bottom. This is just referencing the setQuantity method right here. We should let the user know that an item has been added to the cart, so write Toast. makeText, and then just say added to cart. Open fragment_view_product, and let's call the method when the Add to Cart button in pressed. Scroll down to the RelativeLayout labeled add_to_cart. Now write android:onClick, do two brackets, an arrow, then iMainActivity. addToCart, pass the product, and then pass the quantity. That's great. That will add the new item and the quantity to the cart. But we still need a way to update the number on top of the cart in the toolbar. Open activity_main. Open a data tag, and create a variable named numCartItems. It will be an integer. Scroll down to this TextView and write android:text = String. valueOf, number of cart items. Now go back to MainActivity, and let's get the number of items in the cart. Create a new method named getShoppingCart, get the SharedPreferences object, and get the set of serialNumbers. Now write mBinding. setNumCartItems, serialNumbers. size. Call getShoppingCart in onCreate. Then scroll down and call getShoppingCart at the end of the addToCart method. Let's run it. Click on the Red Lamp. Click Add to Cart. Great. The quantity was updated in the cart, and everything looks good. Go back, select the Coffee Mug, click Add to Cart. Cool, so the number of products in the cart has increased, as you can see from the toolbar widget. So everything is working as we expect at this point.

Building an Observable Shopping Cart
Keeping a running total of the number of items in the cart is great, but we want to do more. Remember our end goal is to keep a running total of the number of items in the cart, the item quantities, and the total cost. And all these properties need to be part of the toolbar, along with the Checkout button. Open activity_main. Right now we have an integer variable representing the total number of cart items, but we're going to need something more robust if we want to include all the properties that we just talked about in this view. Let's put our skills to the test and build another custom Observable class. Ideally, the new Observable class will need to have a list of the cart items since that would make it simple to get the total number of items and the cost. But it also needs a Boolean of some kind to represent the visibility of this section of the toolbar. Because remember, we only want to show it when a user navigates to ViewCartFragment. Then we navigate away, and this section of the toolbar is hidden. We'll start by creating a new model class. Right-click on the models package, go to New, Java Class, and call it CartItem. What does it mean to be a CartItem? A CartItem will have two properties that define it. Of course it needs a product, so write private Product product. And it has to have a quantity, so private int quantity. A user could theoretically have 100 coffee mugs, or they could have 1, so we need a quantity variable. Press Alt+Insert to insert the constructor, copy the constructor, and make an empty one. Now press Alt+Insert and add the getter and setter methods, and there's our new CartItem class. Now let's build the Observable class that will hold the list of cart items. Right-click on the models package, go to New, Java Class. Call it CartViewModel. Our first parameter is going to be a list of cart items, so private List CartItem cart = new ArrayList. And then we need a Boolean for setting the cart visibility. We'll just call the boolean isCartVisibile. Press Alt+Insert, and add the getter and setters. I like to group my getters at the top and setters at the bottom just below. Add the Bindable annotation for the getters. And whoops, looks like I forgot to extend the BaseObservable class, so make sure to write that in. Now call the notifyPropertyChange method in each one of the setters, and reference their name. Now we're going to write some custom methods for setting the text in these TextView widgets. This TextView will have to show the total number of items in the cart, append the word Items, and then surround the entire thing with brackets and add a colon. This TextView needs to show the total cost of the cart, make sure the value is rounded properly, and then prepend a dollar sign. We'll work on the one showing the total number of items first. Write public String getProductQuantitiesString. Create a new integer named totalItems. Loop through the cart, and sum the quantities of each product, so totalItems += cartItem. getQuantity. The cart could have a single item, or it could have a bunch of items. So we don't know whether to use the word items, which is plural, or item, which is nonplural, so we need to write a bit of logic for that. String s = blank, and then if total number of items is greater than 1, s = items; otherwise, s just = item. Now return the properly formatted string. So we need to add a bracket and then String. valueOf the total number of items. And then append our s string for items or item, and then close it with our bracket. Next, we'll work on the total cost. So public String getTotalCostString. Create a new double for totaling the cost, loop through each of the cart items, get the quantity of each product, then get the cost of those items. Just take the productQuantity and multiply by the price of each product. I added a HashMap of prices to the Prices class for convenience. That way we can get the price of each item by referencing their serial number. Then add that to the total cost. Now return the properly formatted string. So we just want to have a $ sign, then use our BigDecimalUtil class. getValue, and then new BigDecimal, and pass the totalCost. That will ensure that our dollar value is formatted properly so it's only going to have two decimals. Open activity_main, and let's make changes to the view. Now we need to make a lot of changes to this view, so to save time, I made a gist for activity_main that you can just copy. Visit this link, https://goo. gl/bi4Ayj, and get the new activity_main, or you can just get it from the source code files in the directory Module_5/end/TabianGifts. Okay, let's go over the changes. At the top we have our CartViewModel. If you scroll down, our first use case is right here getting the cart size. This is taking place of our integer numCartItems. Here we have the visibility. Remember if ViewCartFragment is visible, then we want to show this part of the toolbar. If not, then we need to be hiding it. We're using a ternary to set the visibility. Next is our total cart items. Here's where we use the getProductQuantitiesString method that we just created in the CartViewModel class, and next to that is the total cost. Here's the getTotalCostString method from the CartViewModel class. Open MainActivity, and let's write the logic for this view. We need to set the CartViewModel to the binding. As you can see from the warning here, we still have this setNumCartItems method being called. Delete that. Now the first step is getting a list of cart items. Write Products products = new Products. Create a list of cart items, so CartItem cartItems = new ArrayList. Loop through the serial numbers in the set. Get the quantity of each of the product in the set. Now add the new CartItem for that particular product, add the product, and add the quantity. Instantiate our CartViewModel. Set the list of cartItems to that model. Now set the visibility of the toolbar section we've been working on. We'll need to surround this in a try catch because if the fragment has never been shown, the CartView will be null and cause a crash. So just write try catch and catch the NullPointerException, and then just write a Log output saying NullPointerException and print the error message. Inside write viewModel. setCartVisible, mBinding. getCartView(). isCartVisible. The getCartView method call is the one that will cause the crash if the fragment has never been shown. And finally, set the viewModel to the binding. When a user clicks the cart, we want to make it look like a button. So the background color of the layout needs to get darker when it's pressed and then get light when it's released. That's why we need to use an OnTouchListener. We'll create a custom OnTouchListener to achieve this. Write public static class CartTouchListener implements View. OnTouchListener. Click the red lightbulb and implement the method. Inside onTouch, we need to write logic capturing when the user is touching or when the user is not touching. So if(motionEvent. getAction() == MotionEvent. ACTION_UP, that means that they've released it. Else if(motionEvent. getAction() == MotionEvent. ACTION_DOWN, that means they've pressed it. If it's up, then we want to set the color to blue4, which is the color of the toolbar. So view. setBackgroundColor, view. getContext, getResources, getColor, and then reference the blue4 color. Also write view. performClick so this warning message goes away. If the icon is being touched, set the background color to a darker blue. So exactly the same thing, except we want to reference the blue6 color. Scroll up to onCreate. Now attach the OnTouchListener to the layout containing the shopping cart icon. Now we need a way to actually inflate ViewCartFragment. Open IMainActivity. Write void inflateViewCartFragment. Go back to MainActivity. Write Override and then public void inflateViewCartFragment. Check to see if the fragment is already visible by using the findFragmentByTag. So ViewCartFragment fragment = ViewCartFragment, getSupportFragmentManager, findFragmentByTag, getString, and reference the tag. Create a new FragmentTransaction object. Check to see if the fragment is null. If it is, create a new one. Replace the current fragment in the container, add it to the back stack, and then commit the transaction. Inside the OnTouchListener write IMainActivity iMainActivity = (IMainActivity)view. getContext. Then inflate the new fragment. We are almost done. We just need to set the visibility of the extra toobar section if ViewCartFragment is in view. Open IMainActivity, write void setCartVisibility, and then boolean visibilty. Go back to MainActivity, implement the new method, so Override public void setCartVisibility, pass the visibility, and then mBinding. getCartView(). setCartVisible, and pass the visibility. Open ViewCartFragment, reference the interface, and set the visibility. Run it, and let's take a look. Looks like we've got an error. It's saying there's a null pointer in CartViewModel. Oh, we forgot to change this serial number to a string. So just write String. valueOf, and we should be good. Run it again. Okay, try adding something to the cart. Now click on the cart. Notice the OnTouchListener is making it look like it's a button, but it's not setting the color back to the toolbar's original color when the user lets go. That's due to the return value from the OnTouchListener. Open MainActivity. We currently have this set to false. When it's set to false, the listener doesn't register any of the other gestures except the first one. In our case, that was ACTION_DOWN. We need to return true, and it will catch the UP gesture. Run it again. Click the cart. Everything looks like it's working. We have the total number of items, the total cost, and it's all included in the toolbar. Press the Back button. Uh, that's not what we want. This part of the toolbar should be hidden when we navigate away from ViewCartFragment. This is actually an easy fix. Open ViewCartFragment. When the user navigates back, ViewCartFragment is destroyed. So we can just override the onDestroy method and set the visibility to our CartViewModel. Press Ctrl+O on Windows or Cmd+O on Mac. Type onDestroy. Now just write mBinding. getIMainActivity, and then setCartVisibility, and set it to false. Then super. onDestroy. Run it again, and let's take a look. Click the cart. Now go back. Cool, that part of the toolbar is hidden.

Module Review
Our primary goal in this module was inflating a dialog for choosing an item quantity and then adding a new product to the cart. The dialog was simple. It contains a ListView within an array of integers as entries. When the user clicks on an entry, the quantity is sent to MainActivity via the interface method named setQuantity. In MainActivity, the quantity is received through the Override method. Then the quantity is set to the binding in ViewProductFragment. To inflate the fragment, we created another interface method named showQuantityDialog. We called showQuantityDialog when the user clicks on a RelativeLayout in fragment_view_product. We used the onClick attribute to listen for clicks to the layout. ShowQuantityDialog is implemented in MainActivity. We just instantiate the dialog fragment and then show it with the show method. Next, we worked on adding items to the cart. To trigger the addition of an item to the cart, we created another interface method named addToCart. AddToCart is called when a user clicks on the Add to Cart button in fragment_view_product. Once again, we're using the IMainActivity interface and implementing the addToCart method in MainActivity. Since the app is offline, we're adding cart items to SharedPreferences. Every item has a serial number. We save the serial number of every item added to the cart in a set. To save the quantities, we use the serial numbers as keys, then save an integer representing the quantity. Once the new item is added to the cart, we reset the widget to show the quantity of 1 in fragment_view_product. Then we update the shopping cart widget in the toolbar by calling getShoppingCart. At this point, we had an integer variable in activity_main representing the number of items in the cart, but we needed more than that. We want to display the total numbers of items in the cart and the total cost of everything, and all that needs to be in the toolbar in MainActivity. The most efficient way to do this is to create another custom Observable class that contains a list of cart items. The custom Observable class also needs a Boolean for keeping track of the visibility for this extra section of toolbar. We needed a data structure that contained a product and the quantity of that particular product, so we build the CartItem class. CartItem objects are saved in a list in the CartViewModel Observable class we just looked at. Inflating ViewCartFragment is done using an OnTouchListener. The OnTouchListener listens for when a user presses on the cart icon. If they press it down, the background color is changed to a darker one. When they let go, the background color is changed to match the toolbar color. This gives the illusion of a button click. When ViewCartFragment is inflated, the visibility of the extra section of toolbar is set to visible. When the user navigates away from ViewCartFragment, it's destroyed. We took advantage of the fragment lifecycle's onDestroy method and hid that extra section of toolbar. In the next module, we'll work on completing ViewCartFragment and give users the ability to check out and adjust quantities.

Updating Views Simultaneously with Observables
Introduction
The last piece of our application is the shopping cart. For the duration of the module, we'll be working with the source code files in the directory Module_6/start/TabianGifts. You can download the source code files by navigating to the course on Pluralsight and clicking on the tab labeled Exercise Files. Let's take a look at the demo application so we can clearly define what needs to be done. We already have the toolbar done. Activity_main has our CartViewModel bound to the view. It's displaying the total number of items in the cart and the total cost of the cart. Now we need to display the individual cart items in a list and then display their respective quantities. But that's not quite it. The quantities also need to be adjustable. That's what these arrows are for. When the quantities are adjusted, the TextView in the list item needs to change, the total number of items in the cart needs to be adjusted, and the total cost. So essentially, we need to update two separate views simultaneously. The update needs to be triggered by clicking on these arrows. Next, we'll implement functionality that simulates a checkout process. When a user clicks on the Checkout button in ViewCartFragment, a progress bar will start spinning in the middle of the screen, and after a designated time limit it will disappear, and the cart will be emptied.

Observable RecyclerView List Items
So far, we've used the BaseObservable class to build observable ViewModels for fragment_view_product. xml and activity_main. xml. Now let's build an observable ViewModel for a RecyclerView list item layout. I've made a lot of code changes since the last module, so if you haven't gotten the source code from the directory, Module_6/start/TabianGifts, I suggest you do so. Open CartItemViewModel. This is the class we'll be using in the cart list items layout for the RecyclerView. Once again, we're extending the BaseObservable class. The only object we need in here is a cart item. Remember, we just need to display a product and the quantity of that particular product in the cart. The CartItem class was built specifically for that. There's nothing we haven't seen before, just the getter method for the Bindable annotation and the setter method for the notifyPropertyChanged method call. And there's a method down here for displaying the quantity in the format we want. Nothing that we haven't seen before. Open cart_item. Cart_item is the layout we'll be using for the individual list items in the cart's RecyclerView. As you can see, we have a variable named cartItemView for our CartItemViewModel class. As of right now, there's nothing really special about this layout. The up and down arrows don't do anything yet. We'll be taking a look at that in the next clip. Now let's look at the adapter for the RecyclerView in ViewCartFragment. Open CartItemAdapter. Once again, we just have repetitions of what we've already seen before. We're taking in a list of CartItems; setting the binding in the onCreateViewHolder; binding the CartItem in onBindViewHolder, notice the CartItem ViewModel object; and we have a method for updating the CartItems. We'll be taking a closer look at that later. Open fragment_view_cart. As you can see, this layout file has changed since the last time we looked at it. Now we have a CartViewModel variable bound to the view. We built the CartViewModel class in the last module for displaying the total number of items in the cart and the total cost of the cart in the toolbar in MainActivity. We're getting some more use out of the CartViewModel class here in fragment_view_cart. Since the CartViewModel class holds a list of cart items, it's perfect for fragment_view_cart. Just like the RecyclerView in fragment_main, we're using a custom binding adapter to set the cartItems and then initialize the RecyclerView. The custom binding adapter for this RecyclerView is in the ViewCartFragmentBindingAdapters class. Open it up, and let's take a look. Comparatively, it's pretty much the same thing as the binding adapter in MainFragmentBindingAdapters. This one takes a list of cart items instead of a list of products. The LayoutManager is a LinearLayoutManager instead of a GridLayoutManger. Since we're not displaying a grid, we're just displaying a plain, old list. And of course, the adapter is a CartItemAdapter, not a ProductsAdapter. But overall, it's the same general process. We take in a list of items, set the LayoutManager, then set the adapter to the RecyclerView. There's one other small difference. This if else block will create a new adapter if there isn't one already. If there is one already, then it just updates the cart items. Remember that updateCartItems method in the CartItemAdapter class? Here's where it gets used. Next, let's take a look at ViewCartFragment. GetShoppingCartList does the bulk of work in this class. It gets a list of the serial numbers in the shopping cart, then it loops through the serial numbers, and adds the cart items to the list. Notice the quantity variable here. We're adding the product and the quantity of each product to the new CartItem object. Then we instantiate a cartViewModel object, set the cart items, and set the model to the binding. Let's run it and take a look at the cart. Click on the cart in the toolbar. Cool, we have the items and their respective quantities being displayed in the RecyclerView.

Updating Two Views Simultaneously
Let me show you how simple it is to update two views simultaneously using data binding and observables. Open CartItemViewModel. To keep our code nice and clean, we'll write the methods for increasing and decreasing item quantities inside the CartItemViewModel class. Let's start with the increasing quantity method, so write public void increaseQuantity. We want to get the current item quantity, then increment it by 1. So get the current cart item, then set the new quantity. So cartItem. setQuantity, then cartItem. getQuantity() +1. Then set the cart item to the updated one. Now let's work on the decrease method, so public void decreaseQuantity. Get the cart item. We don't want the quantity to ever be negative, so we need some logic for that. If cartItem. getQuantity is greater than 1, then we know we're good. Now set the new quantity, and set the cart item. Now open cart_item. xml, and let's make the up and down arrows clickable. Here's the increase_quantity arrow, and here's the decrease_quantity arrow. Add an onClick attribute like we've done before, reference the CartViewModel, and call the increaseQuantity method, now the decreaseQuantity method. Let's test it and see what's happening. Go to the cart. Now try adjusting the quantities. Cool, that looks to be working. And I'm also unable to make the quantity negative, which is what we want. But we have a problem. Notice the total number of items in the cart isn't changing, and the total cost also isn't changing. Also, these changes aren't actually being saved to the cart in SharedPreferences. The widgets are just being updated in their views, so we need to fix that too. How can we do that? Basically, we need a way to update the cart in SharedPreferences and then recalculate the total number of items and the total cost. Right now, the total number of items and total cost are being displayed by referencing methods in CartViewModel. Open CartViewModel. It's these two methods right here, and CartViewModel is being used in activity_main. Open up activity_main. Given all that information, it seems reasonable to send the updated quantities to MainActivity. Then we can use the IMainActivity interface, then update the cart, and apply the changes to the CartViewModel in activity_main. That sounds like a good plan. Open IMainActivity. Write void updateQuantity. Pass a Product object and an integer quantity object. So we'll send the product we're updating the quantity for and how many we want to add or subtract. Open MainActivity. Implement the new method, so Override public void updateQuantity. Pass the product and the quantity. Get a reference to SharedPreferneces. Instantiate the editor. Create a variable representing the current quantity. Now commit the new quantity to SharedPreferences by summing the currentQuantity and the quantity we just passed through the interface. We need to call getShoppingCart so the total number of items and the total cost is updated in the toolbar. Go back to CartItemViewModel. Inside the increase and decrease methods, we need to reference the IMainActivity interface. Then we can update the quantity. So write IMainActivity iMainActivity = (IMainActivity), and then write context. To instantiate the interface, we need the context, but how can we get a reference to the context inside an observable model class? Actually, this is very simple. Similar to how we can reference views using data binding, we can also reference the context. So just write Context context as an input variable. Now update the quantity. Are you confused? I'm willing to bet you are. How can I just pass the context like that? Take a look at fragment_view_cart. Notice we're only passing the cart items as an input parameter. Now open ViewCartFragmentBindingAdapters. But here, the binding adapter actually references the RecyclerView. The context works in a similar fashion. There's just one small difference. Open cart_item. xml. We need to pass the keyword context to the method. If we don't, Android Studio will give you an error. So add context to the increaseQuantity method call, and also add it to decreaseQuantity. Now go back to CartItemViewModel. Add a context input for the decrease method. Instantiate the IMainActivity interface. Then after the cart item is set, call the method for updating the quantity. Let's run it and take a look. Open the cart. Great, the quantities are being adjusted. The total number of items is being adjusted, and the total cost is also being adjusted. But what if a user wants to remove an item from the cart? A simple way to add that functionality would be to remove the item if the quantity reaches 0. Let's implement that. Below the if statement checking if there's more than 1 item, write else if(cartItem. getQuantity() == 1). Then we want to update the quantity and remove the item from the cart. To remove it, just do the same thing we did before. Now to remove it from the cart, we need another interface method. Open IMainActivity, write void removeCartItem and pass a cartItem. Now go to MainActivity, create the new removeCartItem method, so Override, then public void removeCartItem. Get a reference to SharedPreferences and the editor. Remove the product quantities first by writing editor. remove, then reference the serial number, and then commit. Then retrieve this set of serial numbers in the cart. Now if this is the only item in the cart, we can just remove it from the entire cart. So if serialNumbers. size() == 1, editor. remove the entire cart; otherwise, we want to just remove that particular serial number and then commit the changes. So serialNumbers. remove, and then reference the serial number, and then we want to commit the new updated list of serial numbers. Call getShoppingCart to update the toolbar. And lastly, we need to remove the item from the list in ViewCartFragment, so get a reference to ViewCartFragment. We've already done this many times before by referencing the tag. Then if the fragment is visible, update the CartItems list. Go back to CartItemViewModel, and remove the cart item if the quantity is 1. Run it, and let's take a look. Go to the cart, increment up, and then increment all the way down. Cool, the item was removed. Let's try some more. Looks like everything is working as we expect.

Simulating a Checkout with a Runnable
The last piece of functionality to complete our project mockup is to implement a fake checkout system. We're not looking for anything fancy here. Remember, the project isn't real. It just had to look and feel as real as possible. So when we click on the Checkout button, showing a progress bar and then clearing the cart will be sufficient to simulate a checkout. Open MainActivity. If you haven't noticed, at the top of the file there's a number of new variables that weren't here in the previous module. The ones pertaining to a checkout simulation are mCheckoutRunnable, mCheckoutHandler, and mCheckoutTimer. If you open activity_main and scroll all the way to the bottom, you'll notice that there's also a ProgressBar. That's for the checkout. Go back to MainActivity. Scroll down to down below the getShoppingCart method, and let's write the new checkout method. I'm not going to get creative here. I'm just going to literally call it checkout. Start by showing the progress bar, so mBinding. progressBar. Then set the visibility to VISIBLE. Instantiate the Handler. Instantiate the Runnable by implementing a new Runnable interface. Use the postDelayed method on the Handler, and then set the increment time to 200 ms. We want our timer to match the postDelayed method, so we're going to increment the CheckoutTimer by 200 ms at the same time. Now if the CheckoutTimer is greater than or equal to 1. 6 seconds, we want to empty the cart and reset our Runnable. There's no reason I chose 1. 6 seconds. I just thought it was long enough to feel like a real checkout. To empty the cart, we'll need to create another method called emptyCart. Another very creatively named method. That's going to show red for now, but we're going to make that method shortly. Hide the progressBar by referencing the binding, remove the Callbacks from the Handler, and then reset the CheckoutTimer. Now call run on the Runnable, and that's all done. Just as a side note, if you're unfamiliar with Handlers and Runnables, I recommend checking out the course named Android Processes and Threads by Larry Schiefer on Pluralsight. That's actually the course I watched when I was first learning about processes and threads. Although it's a little old, there's still tons of great information in there. Okay, let's write the method for emptying the cart, public void emptyCart. Get a reference to SharedPreferences like we've done so many times before. Get our set of serial numbers. Now loop through the set and remove the entries. This will remove all the item quantities. Now we need to remove the shopping_cart set so editor. remove, and then just reference our shopping_cart set key. Let the user know the cart's been emptied. I'll just say thanks for shopping. Remove ViewCartFragment from the view, and now get the updated ShoppingCart. Now we just need a way to start the checkout process. Write public View. OnClickListener. We'll call it mCheckoutListener = new View. OnClickListener, and then call the checkout method inside the interface. Now scroll up to onCreate, and let's set the listener to the Checkout button, mBinding. proceedToCheckout, then setOnClickListener, mCheckoutListener. I think we're done. Let's run it. Go to the cart, click Checkout, there's the progress bar, and the cart is emptied and ViewCartFragment is being destroyed. Great, so everything is working as we expect.

Module Review
This module was mostly about applying what we've already learned in the course to a new situation. We needed a way to view all the cart items in a RecyclerView and their respective quantities. Based on what we know about observables and the BaseObservable class, creating a new custom observerable ViewModel for the list items made the most logical sense. We created a class named CartItemViewModel and once again extended BaseObservable. The class has a single cartItem object. That's all we needed since the CartItem class contains a product object and an integer object representing the quantity. The layout of the RecyclerView items is called cart_item. xml. The only variable we needed inside cart_item was the CartItemViewModel we just created. That gave us a way to access the title, image, price, sale price, and quantity of the cart items. To set the cart items to the RecyclerView, we used another custom binding adapter. It worked in basically the same way as our last custom binding adapter. We just passed it a list of cart items, and the custom adapter set up the RecyclerView. Adjusting the quantities was the next big hurdle. If the quantity is increased or decreased, it needs to change the individual list item view and also in the cart's toolbar. To update the quantities in the list item views, we created two new methods in the CartViewItemModel class. IncreaseQuantity was slightly simpler than decreaseQuantity because we didn't have to worry about reaching negative values. We just get the CartItem, increment the quantity by 1, then set the CartItem to update the view. We used the IMainActivity interface to send the quantity update to MainActivity where the shopping cart was adjusted. DecreaseQuantity was similar, but we need to add a bit more logic to prevent negative values. We also needed to remove items from the cart when the quantity reached 0. To remove items from the cart, we created another interface method called removeCartItem. RemoveCartItem is responsible for removing all the quantities of the product in question, then removing the product itself from the cart. The last thing we did to complete our shopping cart was simulate a checkout. We used a Runnable to show a progress bar on screen for 1. 6 seconds. After 1. 6 seconds, the progress bar is hidden, the cart is emptied, and the timer is reset. In the next module, we'll do a comprehensive review of everything covered in the course.

Tying It All Together
Review: Data Binding Basics
Let's quickly review all the major concepts covered in the course. We started off by talking about how to use the Data Binding Library with Android Studio. Installing has become increasingly simple over the past three years, and now there's only two things you need to do. In the SDK Manager in Android Studio, you need to make sure the Support Repository is installed. If it isn't, just click the checkbox, and Android Studio will install it for you. Next, you need to enable data binding in the build. gradle app file. It's very simple. You just need to write dataBinding and then set the enabled flag to true. However, things are always changing, and at the time you're watching this video, it could be different. I recommend taking a look at the Android documentation at developer. android. com to make sure you're taking the necessary steps. Once we had everything enabled, we were ready to bind our first view. To tell Android Studio you want to use data binding to inflate a view, you need to encapsulate the parent layout with a layout tag. That will trigger the Data Binding Library to generate a new class file associated with the layout. If the layout is named ActivityMain, the data binding class will be called ActivityMainBinding with a capital A, capital M, and capital B on Binding. To associate an activity with its data bound view, you first declare the binding object. Then instantiate the binding object by writing DataBindingUtil. setContentView equals this, R. layout, and reference the layout file. Binding a fragment is a little different. For example, if the fragment's layout file is name fragment_view_product, the fragment inflating the layout would need to look like this. To instantiate the binding object, you need to reference the binding object class and then write. inflate and pass the layout inflater. In the first part of the course, we looked at some very simple examples of using data binding. We inflated fragment_view_product with two data-bound variables, a variable named product of the Product object type and a variable named qty of integer type. We also imported three classes to use in the layout, BigDecimalUtil, StringUtil, and the View class. We used the variables to set various widgets in the view and in some cases reference BigDecimalUtil or StringUtil or the View class. Remember when setting text in a TextView, you must pass a string. There was a few examples of using ternary expressions. One was determining if there was a sale price or not. If there was, it would be displayed, and another widget would be visible displaying the original price slashed out. If it wasn't, then only the regular price would be displayed.

Review: RecyclerViews and Data Binding
Next, we picked up the speed and difficulty level of the content. We needed to set up a list of products for sale and display them using a RecyclerView. To set up the RecyclerView, we built a custom binding adapter. It accepted a list of products and initialized the RecyclerView. The RecyclerView. Adapter class was called ProductsAdapter. Using the binding adapter on the RecyclerView was simple. You just write app:productsList and then reference the variable holding the list of products. We had a variable for that list in the variable section of the layout. Remember if you want to use a list as a variable, you need to write the HTML code for the left caret symbol; otherwise, you'll get an error. At this point, we had an issue with the images. They were just displaying color. The images weren't coming through. We needed to build another custom binding adapter for setting the images using Glide. The BindingAdapter was set to an ImageView widget and accepted an integer resource for the image. Remember if your images are String resources, which 90% probably will be, you need to overload the binding adapter to accept input strings. Using the binding adapter in product_item. xml was simple. We just had to write app:imageUrl and then reference the product. image.

Review: Custom Observables and Extending BaseObservable
Next, we talked about observables and the various convenience classes that data binding provides. There's ObservableBooleans, Bytes, Characters, Shorts, Integers, Longs, Floats, Doubles, and Parcelables. These Observable classes are great in theory, but I think you'll find their use cases very limited. The Data Binding Library also offers observable collections. There's ObservableArrayMaps and also ObservableLists. We chose to not take advantage of these convenience classes and instead create a custom Observable class that extends BaseObservable. In my opinion, BaseObservable is the best of the best in terms of observables. It's simple, but very flexible. We created a custom Observable class named ProductViewModel that extended BaseObservable. To make the objects observable, you need to add the Bindable annotation to the getter methods. The setter methods set the new values and notify the BR class that a change has been made. They notify the BR class by calling notifyPropertyChanged, then referencing the variable. Remember, you can view the project variables in the BR class by navigating to the Packages, expanding the app folder, expanding the databinding. library, expanding baseAdapters, then opening the BR file. As the warning indicates, the files under the build folder are generated and should not be edited. Making custom observables by extending the BaseObservable class is a beautiful thing. You can add every variable you want to use in your view to a single class and include all the custom methods. It helps keep your code extremely clean. A great example of this was when we added a custom RequestListener to the ImageView widgets. This method was included in our ProductViewModel class. The RequestListener will set the imageVisibility variable to true once an image is finished loading. To use the RequestListener, we created another custom binding adapter. This one accepted a RequestListener as an input and an integer image as a resource. It did exactly the same thing as our previous binding adapter for setting images, except it added a customRequestListener that we built. To set the imageResource and requestListener to the ImageView, we wrote app:requestListener= productView. customRequestListener, and then for the image, app:imageResource= productView. product. image. And lastly, we made a few small changes to ViewProductFragment to incorporate our new model. Instead of setting the product, we instantiate a ProductViewModel object, then set the Product, and set the Quantity. Then we set the ProductView to the Binding.

Review: Leveraging an Interface with Data Binding
Our primary goal in this module was inflating a dialog for choosing an item quantity and then adding a new product to the cart. The dialog was simple. It contains a list view within an array of integers as entries. When the user clicks an entry, the quantity is sent to MainActivity via the interface method named setQuantity. In MainActivity, the quantity is received through the Override method. Then the quantity is set to the Binding in ViewProductFragment. To inflate the fragment, we created another interface method named showQuantityDialog. We called showQuantityDialog when the user clicks on a RelativeLayout in fragment_view_product. ShowQuantityDialog is implemented in MainActivity. We just instantiate the dialog fragment and then show it with the show method. Next, we worked on adding items to the cart. To trigger the addition of an item to the cart, we created another interface method named addToCart. AddToCart is called when a user clicks on the Add to Cart button in fragment_view_product. Once again, we're using the iMainActivity interface and implementing the addToCart method in MainActivity. Since this app is offline, we're adding cart items to SharedPreferences. Every item has a serial number. We saved the serial number of every item added to the cart in a set. To save the quantities, we use the serial numbers as keys, then save the integer representing the quantity. Once the new items or item is added to the cart, we reset the widget to show a quantity of 1 in fragment_view_product and then update the shopping cart widget in the toolbar by calling getShoppingCart. We wanted to display the total number of items in the cart and the total cost of everything, and all that needs to be in the toolbar in MainActivity. The most efficient way to do this is to create another custom Observable class that contains a list of cart items. The custom Observable class also needed a Boolean for keeping track of the visibility of this extra section of toolbar. We needed a data structure that contained a product and the quantity of that particular product, so we built the CartItem class. CartItem objects are saved in a list in the CartViewModel Observable class that we just looked at. Inflating ViewCartFragment is done using an OnTouchListener. The OnTouchListener listens for when users press on the cart icon. If they press it down, the background color is changed to a darker one. When they let go, the background color is changed to match the toolbar color. This gives the illusion of a button click. When ViewCartFragment is inflated, the visibility of the extra section of toolbar is set to visible. When the user navigates away from ViewCartFragment, it's destroyed. We took advantage of the fragment lifecycle's onDestroy method and hid the extra section of toolbar.

Review: Updating Views Simultaneously with Observables
This module was mostly about applying what we've already learned in the course to a new situation. We created a class named CartItemViewModel and once again extended BaseObservable. The class has a single cartItem object. That's all we needed since the CartItem class contains a product object and an integer object representing the quantity. The layout for the RecyclerView items is called cart_item. xml. The only variable we needed inside cart_item was the CartItemViewModel that we just created. To set the cart items to the RecyclerView, we used another custom binding adapter. It worked in basically the same way as our last custom binding adapter. We just passed a list of cartItems, and the custom adapter set up the RecyclerView. Adjusting the quantities was the next big hurdle. If the quantity is increased or decreased, it needs to change in the individual list item view and also in the cart's toolbar. To update the quantities in the list item views, we created two new methods in the CartItemViewModel class. IncreaseQuantity was slightly simpler than decreaseQuantity because we didn't want to have to worry about reaching negative values. We just get the cartItem, increment the quantity by 1, then set the cartItem to update the view. We used the IMainActivity interface to send the quantity update to MainActivity where the shopping cart was adjusted. DecreaseQuantity was similar, but we needed to add a bit more logic to prevent the negative values and also to remove items from the cart when the quantity reached 0. To remove items from the cart, we created another interface method called removeCartItem. RemoveCartItem is responsible for removing all the quantities of the product in question and then removing the product itself from the cart. The last thing we did to complete our shopping cart was simulate a checkout. We used a Runnable to show a progress bar on screen for 1. 6 seconds. After 1. 6 seconds, the progress bar is hidden, the cart is emptied, and the timer is reset.

Final Thoughts
We've come a long way since the beginning of the course. By now, you should have a powerful new library added to your Android utility belt. Using the Data Binding Library is a great way to help keep your code clean and legible. You can do more with less, and it has a very elegant feel to it. There's definitely a learning curve, but in my opinion, it's well worth it. If you were to master one data binding concept from the course, I recommend building custom object classes that extend BaseObservable. Using those alone will improve your code quality tremendously, and it's so simple. The Android team did a really excellent job with the BaseObservable class and the Data Binding Library in general. If you enjoy the course and thought it provided a lot of value, please leave a rating on Pluralsight. I would really appreciate that from you. Afterwards, send me a tweet to say hi or leave a comment on my YouTube channel. As of right now, I read every single comment. Mention the course so I know where you're coming from, and I can personally thank you for watching. My name is Mitch Tabian, and thanks for watching.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
4.8 stars with 35 raters(35)
My rating
null stars

Duration
2h 7m
Released
15 Mar 2018
Share course