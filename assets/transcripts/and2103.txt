Leveraging the Power of the Android Platform
by Jim Wilson

Android provides a powerful threading model and rich background execution capabilities. In this course, you'll learn how to leverage these capabilities through the use of AsyncTask, Handlers, Services, Job Scheduler, Broadcast Receivers, and more.

Modern applications include many rich time-based and background behaviors that extend well beyond direct interaction with the user. In this course, Leveraging the Power of the Android Platform, you'll learn how to use the powerful capabilities of the Android platform to create applications that incorporate these and other related behaviors. First, you'll explore how to utilize the Android threading model, AsyncTasks, Handlers, and StrictMode to effectively perform long-running work in a way that doesn't impact the user experience. Next, you'll discover how to use Android Services for background work that can be safely performed even after the user exits your application. After that, you'll learn how to use the Android Job Scheduler to create background jobs that rely on run criteria such as networking and power requirements, and delegate those jobs to the Android system for management and execution. Additionally, you'll cover how to use Android Broadcasts and Broadcast Receivers to publish information from one application, and allow other applications running on the same device to subscribe to that information. Finally, you'll delve into scheduling time-sensitive tasks using the Android Alarm Manager. By the end of this course, you'll have the skills and knowledge to create your own Android applications that incorporate the rich time-based and background execution behaviors required to create a successful application.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Advanced
Rating
4.9 stars with 18 raters(18)
My rating
null stars

Duration
3h 3m
Released
7 Nov 2017
Share course

Understanding the Android Threading Model
Introduction
Welcome to the Pluralsight course Leveraging the Power of the Android Platform. This is our first module Understanding the Android Threading Model. My name is Jim Wilson. This is a really exciting course because now we're beginning to move into some of the deeper aspects of the Android platform. This is where we start really digging into those features and capabilities of Android that allow us to incorporate the kind of processing and system interactions that are key aspects of creating successful apps. So in this, our first module, we'll take a closer look at the Android Threading Model. After this module, we'll dig into a type of Android component known as a service. Services are an important part of performing many types of background and non-UI focused processing. We'll then look at the Android JobScheduler and the important role it plays performing data synchronization tasks and other types of recurring work. After that, we'll cover a type of Android component known as a broadcast receiver. We'll learn how to use broadcast receivers to send and receive broadcast level events of interest. And as part of that discussion of broadcast receivers, we'll learn how to use the Android alarm system to schedule time sensitive work. As I mentioned, in this module we're taking a closer look at the Android Threading Model. Our goal in this module is to further develop our understanding of the Android Threading Model and learn how to work effectively with that model. So we'll start out with a closer look at the important role of the main thread of our application and we'll learn how to protect that thread using a class known as StrictMode. After that, we'll take a look at the AsyncTask class. Now we talked about AsyncTask earlier in the series, but now we're going to dig a little deeper into AsyncTask and understand more fully how to use it when performing background work. And as part of that discussion, we'll look at how we can perform background work with AsyncTask while providing the user with regular progress updates on that work. And then we'll finish up, we'll look at something called a Handler, and we'll understand the important role they play in dispatching work from one thread to another, as well as deferring work to sometime in the near future.

Protecting the Main Thread with StrictMode
As you recall from our SQLite discussion from earlier in this series, it's very important to protect our application's main thread because remember that main thread is responsible for maintaining the user experience. So if we perform any kind of long running operations on that main thread, the user experience appears frozen until that operation finishes. When we talked about it earlier, we were looking specifically at data operations, but there are other operations we need to consider. Common operations we want to avoid performing on the main thread are things like reading from a "disk" storage and writing to "disk" storage. Now I have disk in quotes here because most modern devices don't have an actual spinning disk, but they do have a storage system that behaves much like a disk. And performing any interaction with these storage systems from our main thread can interfere with the user experience. We also want to be sure to avoid any kind of network interaction from the main thread, because again, it can interfere with the user experience. Now being certain that we're not performing any of these operations on the main thread can be challenging because applications can often get very complex. So the details of what code is actually doing can be hard to keep track of because you may have written the code over time, other members of your team may have written the code, or you might be using third party libraries. And as a result, you may be performing operations like this in the main thread without even realizing that it's happening. To help us identify when these kind of operations might be happening, Android provides the StrictMode class. Because the StrictMode class can detect undesirable operations and enforce penalties when one of those operations occurs. So what we can do is use the StrictMode class during the debugging and testing phase of our application. Now using the StrictMode class, we've built a desired thread policy, in other words, what do we want to detect and what do we want the penalties to be? And then we set that policy earlier in our application. So either at the application level or at the start of our main activity. So that way the policy stays in effect throughout the lifetime of our application. So the way we set our thread policy is by using the StrictMode class's setThreadPolicy method and setThreadPolicy method accepts an instance of StrictMode. ThreadPolicy. Now the way we create the ThreadPolicy is, again, by using the builder pattern, much like we did earlier in the series when creating notification. So we have a builder class called StrictMode. ThreadPolicy. Builder. When we're building our thread policy, we generally think of doing it in two phases, the first phase is identifying the things we wish to detect. So there are methods like detectDiskReads or detectDiskWrites or detectNetwork, and you can call as many detect methods as you need to to identify that portion of your policy. But now in practice, rather than calling the individual detect methods, we generally just call detectAll, which will detect all of our disk operations, our network operations, as well as a few other things that might happen on that main thread. So now once we identify what we want our policy to detect, we then decide what we want the penalty to be, and a policy can have multiple penalties. So there's a method penaltyLog which says that when you detect one of these operations, write information out to the Logcat. You can also have penaltyException, which says if one of the operations occurs, go ahead and throw an exception. PenaltyDialog, watch it display a dialog if one of the detected operations occurs. In the documentation penaltyDialog is kind of interesting because it evens says will show an annoying dialog, so it's trying to draw your attention to a dialog that one of the operations has occurred. And we also have penaltyDeath, which says go ahead and kill the process if one of these operations occurs. And again, we can have multiple penalties. So if you set both penaltyLog and penaltyDeath in your policy, StrictMode will go ahead and write to the log before it kills the process. So you can be sure to capture the information that you want prior to the process dying. Alright so in our next clip, let's use StrictMode to detect any undesired operations that might be happening on our application's main thread.

Using StrictMode in Your App
Here we are in Android Studio, what we want to do now is use the StrictMode class to detect any undesired work that may be happening on our application's main thread. Now we're currently looking at the main activity class's onCreate method. This is a good place to enable our StrictMode thread policy since this code is run right near the beginning of when our app is launched. Now there are a few steps involved in setting up our StrictMode thread policy. So rather than put that code right here in onCreate, let's do the work in a method we'll create named enableStrictMode. So we'll go ahead and create that method, so we'll say Alt+Enter, Create method, we'll accept our return type, and now we're ready to start setting up our StrictMode policy. We want to be sure that we don't enable our StrictMode policy in our production releases, we only want to do this during debugging and testing. So to help us out, there's a class called BuildConfig that has a static field named DEBUG. So let's place that inside of an if statement. Now this DEBUG field is only true when we create a debug build of our code, so by setting our StrictMode policy within this if, we assure that we don't have the policy in effect when we do our release build, it'll only be inside of our debug builds. So to get us started, let's declare a local variable named policy and the type will be StrictMode. ThreadPolicy. Now as we mentioned, we create our policies using the builder pattern, we use a class named StrictMode. ThreadPolicy. builder. So let's create a new instance of that type. Now as you recall, when we were using the builder pattern to create our notifications, we could create a new builder instance and then start calling methods directly against it. Well we can do that same thing here. So the first thing we want to do is identify the things we want to detect. So let's say we want to detect disk reads, so we'll call detectDiskReads. And we also want to detect disk writes, so we'll call that method. And we want to detect any interactions with the network, so we'll call that method as well. Now as you can see here, we can call multiple detect methods on this one builder instance. And that allows us to identify individual things we want to detect. But in most cases, we want to go ahead and detect everything that StrictMode can detect. So rather than calling these individual detect methods, let's just replace them all with a call to detectAll. So this one call to detectAll replaces our need to call those individual detect methods. Once we identify what we want the policy to detect, the next thing we have to do is indicate the penalty. And in our case, let's just make the penalty writing to Logcat. So we'll call the penaltyLog method. Now remember, we could have multiple penalties on one policy if we wanted to, but in this case we would just want that one penalty writing to Logcat. So we're ready to go ahead and create the thread policy, so let's just go ahead and call the build method. So what that'll do now is create an instance of our StrictMode. ThreadPolicy type that detects each of the things we've indicated and enforces the corresponding penalty. Now once we have the policy created, we want to go ahead and set it. So we'll use the StrictMode class's static method, setThreadPolicy, and pass in our policy. So now when we do a debug build of our application, we'll have a thread policy in place that detects everything that StrictMode can detect and we'll write any violations out to Logcat. So in our next clip, we'll go ahead and run our application and see what StrictMode reports.

Identifying Inappropriate Operations with StrictMode
Here we are back in Android Studio and what we want to do now is run our application and see if this new StrictMode policy that we've added reports any problems with undesired code running on our main application thread. So we'll go ahead and launch our application in a debugger. So now our app is up and running in the emulator. Let's go ahead and choose one of our notes, that displays the note in our note activity. Let's go ahead and return back to the main activity. And now let's switch back to Android Studio. Here we are back in Android Studio and what we want to do now is look at our application's Logcat output. So what we're going to do is go down here where it says Android Monitor, let's go ahead and select that. Now this displays our Logcat output. Let me just scroll this a little bit. Now you can see here, I currently have my Logcat output level set to Debug, and there's a number of messages in here. We can see there's a message near the top that actually comes from the onCreate method of our NoteActivity. That was code we added way back towards the beginning of the series just to report when we enter into our NoteActivity's onCreate method. We see down there at the bottom there's a message for onPause. And you see that between those there's no StrictMode related messages in there, so when we select a note to display in our NoteActivity, we didn't do any undesired work on the main application thread. And remember that we do that work using a cursor loader, and one of the main purposes of using a cursor loader is to assure that any data lookups we do don't run on the main application thread. So that shows us that our data lookups are working just fine in terms of not doing any undesired work on the main application thread. So I'm just going to right click, say Clear Logcat. Let's switch back to our emulator. So here we are back at the emulator. Now this time rather than select an existing note, I'm going to go ahead and click the new note button. You may have noticed that when I did that, in the background you can see Android Studio running a lot of information out to the Logcat. So let's switch back to Android Studio and take a look at what's inside of our Logcat output. So here we are back in Android Studio. You see the top row of Logcat output is that Logcat message about going into the onCreate method of our NoteActivity. If you look down a little bit, you actually see a message labeled StrictMode, it says StrictMode policy violation. So let's scroll down a little bit so we can see more of the information. I'm also going to scroll horizontally. So now we can see that it says StrictModeDiskWriteViolation. So that means that the StrictMode class detected that there was disk output occurring on the main application thread. You can see there's a stack trace there. Now notice that one of the entries in the stack trace is our NoteKeeperProvider class that says it's line 120, let's go ahead and click on that. And of course when we click on that, we can see it's where we do the insert into our database. Now of course, inserting into our database would cause a disk write. Let's see if we can see what part of our application actually caused the insert to happen. So down here in our Logcat output, let's scroll down a little bit further, and when we look here, we can see it's our createNewNote method of our NoteActivity, so let's go ahead and click on that. And you can see that's part of our NoteActivity where we get the ContentResolver and that's where we trigger the actual insert. So let's go ahead and close the Android Monitor so we can see the full CreateNewNote method. So now we can see the whole CreateNewNote method. And as you may recall from earlier in this series, this is the code that's responsible to create that initial database entry to represent the note that's being created. And this is the code we want to assure does not run on the main application thread. Now we've dealt with this issue before, let me scroll to another method where we actually handle this issue. So we're here to deleteNoteFromDatabase method, and as you may recall, this is the method that's responsible to delete a record from the database in the event that the user creates a new note and then decides that they don't want to keep that note. So now you can see here where we have the code for deleting the row from the content provider. We wrap up the actual delete within an instance of the AsyncTask class. Now as we mentioned earlier in the series when we added this code, AsyncTask allows us to perform operations like this on a background thread rather than running them on the main application thread. But as we have the code written here, we're using only a fraction of the capabilities of AsyncTask. AsyncTask is actually a very powerful tool. So in our next clip let's take a closer look at AsyncTask.

A Closer Look at AsyncTask
Now as we've talked about, the main thread is an important part of maintaining our application's UI. Now the main thing we've focused on is the fact that most UI work is performed on the main thread. So because of that, we can't do any long running operations on that main thread or it'll interfere with our UI experience. But another important part of the main thread is that many of our programmatic UI operations are only allowed to occur on the main thread. In other words, if you want to get the value of a text view or you want to set the value of a text view, that work has to be done on the main thread. That sort of work is not allowed to be performed on any other thread. So what that means is when we're doing background work, it's important that we get our threading operations right. So when we're doing the long-running work, we know we want to run that on the background thread. But then when our work is done and we want to present the results, there's a good chance that's going to need to interact with the UI. So we want to make sure that we're presenting the results, that that works runs on our main thread. Managing those threading details ourselves would be cumbersome, so that's where our AsyncTask class comes in, because as we talked about earlier in the series, it manages the threading details. And what it provides is methods for each phase of work and those methods are each run on the appropriate thread. So when we want to perform work using AsyncTask, what we're going to do is define a new class that extends AsyncTask and then we'll override the appropriate methods. Now this first method, doInBackground, is one we've seen before. This method runs on the background thread, so this is where we put the code to do the actual work. But now I want to look at another method, which is onPostExecute, and this actually runs on the main thread. And this is where we add the code to present our work results. So if we look at our threading picture again, we have our main application thread, and we want to go ahead and launch some work. What we're going to do is have our doInBackground method, and so when the background thread runs, the code inside of doInBackground will run on that background thread. But then when we're done, we want to switch back to our main thread, so that's where our onPostExecute will be, and so the code inside of onPostExucute will then run on that main thread. So that allows us to do background work on a background thread, but then present the results on our main thread. Now in order to do work effectively, we often need to pass data between the methods across these threads. So in our next clip, we'll see how to do that.

Passing Data Between AsyncTask Methods
As we use AsyncTask in our application to perform work, we will commonly need to pass data values between the various methods. So when we start initiating the work, we first call the execute method on AsyncTask and the execute method actually accepts a variable length parameter list. Whatever parameters we pass into execute, AsycTask takes care of the details of passing it over to our doInBackground method. So that allows our doInBackground method to use the values we're passing in execute to do its work, and then when doInBackground is done it needs to provide the results. So doInBackground has a return type, so whatever values are returned from doInBackground, AsyncTask takes care of the details of them passing that value into the onPostExecute method. So that gives us a complete cycle of starting the work, passing the values into doInBackground and then taking that result and passing it to onPostExecute. So if we look at what this looks like graphically, where we have our main application thread, we can call execute on AsyncTask. Now of course, that means it's going to start to work running on our doInBackground, but we can actually provide data values to execute and AsyncTask will take care of taking those data values that were passed in our main thread, pass them into doInBackground, and then run doInBackground on the background thread. When doInBackground has done its work, it will produce a result, so of course we want that result to go into onPostExecute. So AsyncTask will take care of the details of taking the result of doInBackground, passing it into onPostExecute, so onPostExecute can then use that value on the main thread to present the results of the work. So now as we pass these data values around, each of those data values need to have a type. So AsyncTask accepts types parameters as part of the class declaration, and it actually accepts three type parameters. The first type parameter indicates the type that we want to pass into doInBackground and doInBackground, again, accepts a variable length parameter list. So what happens is when we call the execute method, again it's a variable length parameter list, an AsyncTask will take care of the details of taking whatever values we pass to execute and pass them into doInBackground. So now our AsyncTask, as we mentioned, has three type parameters. Now the second type parameter we'll talk about a little bit later in this course. Since we don't need it, we'll pass the object type void. But now our third type parameter, that indicates the return type of doInBackground. So what that means is that doInBackground can take the Type1 parameters it received, do whatever work it needs to do, assign it to a result of Type3 and then simply return that result. But then our onPostExecute method will accept a parameter of Type3. So AsyncTask will take care of the details of taking that value that we returned back from doInBackground and pass that as a parameter to onPostExecute. So onPostExecute can then do whatever work it needs to do on the main thread using that result. Alright so to help us understand this a little better, in our next clip we'll use AsyncTask to insert the new row into our database when we create a new note.

Inserting a New Note Using AsyncTask
Here we are back in Android Studio and what we want to do now is use AsyncTask to perform the insert of our new note row using a background thread. We're currently looking at the NoteActivity class's createNewNote method. Now this is the method that performs the insert of our new note row. To perform the insert using AsyncTask, we'll divide the work into two parts. We'll do the actual insert on a background thread and then when that completes, we'll assign the resulting URI to our mNoteUri field on the main thread. So now to get us started, we'll declare a local variable of type AsyncTask. As part of our declaration, we need to provide type arguments to AsyncTask. Now the first type argument identifies the type we want to pass from the AsyncTask execute method into our doInBackground method. Now the values we're passing to insert are contained within a content values instance, so we'll set our first type argument as ContentValues. We'll pass the Void reference type for a second type argument. The third type argument is the Type1 passed from doInBackground to the onPostExecute method, which for us is Uri. So that gives us all our type arguments. So now let's name our variable and we'll name it task. Now we want to create a new instance of AsyncTask, so I'll start typing new Async. Now I could type this all the way out, but if I hit Control+Space, I can let Android Studio finish it for me. So now you can Android Studio has provided the code to create our new AsyncTask and it's given us our doInBackground method. Now currently it's returning null, so let's go ahead and remove that. In addition to the doInBackground method, we also want to have the onPostExecute method, so let's do Control+O, we'll choose onPostExecute, we'll hit Enter. Now we don't need to call the super class method, so we'll remove that. So now we have our AsyncTask class stubbed out and we can begin the work of actually doing the insert appropriately. So now the first thing we want to do is remove that line of code that directly inserts into the database from the main thread. And let's replace that call to our task variables execute method. The execute method accepts a variable length parameter list. The type it expects is based on the first type argument we provided to our AsyncTask implementation, which in our case is content values. So we'll pass in our local content values variable, which is named values. Now the parameter we pass here is then received by our doInBackground method. Now notice that doInBackground also accepts a variable link parameter list. So that means that our params parameter is actually an array of content values. So to access the single content values reference we pass to the execute method, we need to access the initial element of params. So let's declare a local variable named insertValues of type ContentValues and we'll assign it the value of params subzero. So now with that, the insertValues variable is a reference to the same ContentValues instance that we pass to the execute method. So now we're ready to do the insert. So let's first call getContentResolver. insert. We're inserting into the notes table, so we'll pass in the notes table URI, and then we'll pass in our insertValues. Now as we know, the insert method returns back the URI of the newly inserted row, so let's assign it to a local variable named rowUri of type URI. So now that we have that rowUri, let's have our doInBackground method return it. This URI that we returned here will then be received by our onPostExecute method. So we'll go ahead and assign that URI to our mNoteUri field. So now with that, we have all the code in place for the row insert to run on the background thread, the resulting URI is then passed to our onPostExecute method, which then assigns the URI to our mNoteUri field using the main thread. Now you may be wondering if we could have assigned the result of the insert method directly into the mNoteUri field with that code running on the background thread, and the answer is yes. It would have been completely legal for us to do that. But it wouldn't have been a good programming practice. Remember, the code within doInBackground runs in parallel to code that's run on our apps main thread. That means that changing the value of the mNoteUri field within doInBackground would run the risk of having its value change, while code running on the main thread was actively using the value of the mNoteUri field. And this sort of thing can lead to very difficult to diagnose errors. So for that reason, we want to avoid changing the values of any of our activities fields from a background thread whenever we can. Well alright, now that we have our code in place, in our next clip we'll run our program and see what happens.

Verifying AsyncTask Behavior and Threading
Here we are back in Android Studio and we're just about ready to run the code that uses our AsyncTask class to perform a database insert on a background thread. But now before we do that, let's just add some code that will help us track what's going on. Now as you recall, the way we initiate the work with an AsyncTask is by calling the execute method. So right here where we call execute, let's go ahead and write a message out to Logcat. So we'll write it as a debug message, we'll include text that indicates we're calling execute, and then we want to write out the identifier of the thread that this is currently running on. So what we're doing here is using the thread class's getCurrentThread method to get a reference to the current thread and then getting its ID value. And each thread has a unique ID value within our process. So this will help us understand what thread the execute method is being called on. So now it's at that same sort of message inside of doInBackground. So this will log the ID of the thread that doInBackground is running on, and then we'll do the same thing again in onPostExecute. So with each of these log messages in place, we'll be able to look at what threads each part of our processing is running on. So now let's do one more thing. Let's call a method I've created called displaySnackbar, and we'll pass in the value of our mNoteUri. So now as you might imagine, the method displaySnackbar simply displays a snackbar. So with this code in place, when we're running our application, we'll just be able to verify that the row was actually inserted because we'll see a snackbar show up displaying the URI of the newly inserted row. So now we're ready to run it. So let's go ahead and launch our app and let's see what happens. So now our app is up and running, so let's go ahead and click the button to create a new note, and you see there at the bottom now we have a snackbar showing the URI. So that shows us that our row is actually inserted. So let's go ahead and return back to the main activity, and you can see in the background, as all that was going on, a bunch of messages were being written out to Logcat. So let's switch back over to Android Studio. So now back here in Android Studio, as we look at our Logcat output, we can see the message that shows we went into our NoteActivity's onCreate method, and we can also see our message that shows we went into NoteActivity's onPause method. And notice that we no longer see the error message from strict mode. So that indicates now that our insert is running properly, it's no longer running on the main thread, it's instead running on the background thread. And by looking at the log messages we added, we can verify that that's the case. Remember that first we logged a message for our call to execute. Notice that that message has a thread ID value of 1, and thread ID 1 is our main thread. So our call to execute, of course, happened on the main thread. But then notice that doInBackground was run on the thread with an ID of 236, and that value of 236 itself is not important, but it indicates that it's not the main thread, so the actual insert ran on a background thread. And then notice that onPostExecute, again, ran on a thread with an ID of 1, showing us that onPostExecute did indeed run on the main thread. So this all shows that the code we've added with AsyncTask now properly performs the insert on a background thread. But now in this case, the work we're doing on the background thread is actually fairly quick, but what if instead the work we were doing on the background thread actually took several seconds and we wanted to show the user some sense of progress? Well in our next clip we'll see how to deal with that.

Including Progress Feedback with Note Insert
Here we are back in Android Studio and we'll continue our work using AsyncTask. Now the work we currently do with AsyncTask actually runs fairly quickly. We're just doing a single insert into a database table. But there are many situations where the work we do within AsyncTask may take a few seconds. Imagine if the database work we had to do actually ran for a second or two, and then after the database work was finished, we had to do some additional work that then ran for a second or two. Well to help us see what that's like, I've added these calls to a method I've created called simulateLongRunningWork. And this method, somebody puts the thread asleep for about 2 seconds. So with that being the case, the work that runs within doInBackground will actually take about 4 seconds. Well with working running that long, we should probably give the user some kind of progress updates. And Android provides ways for us to do that. So let's head over to the layout resource for a NoteActivity. So this is the layout resource for the content area of our NoteActivity. If you look here at the Component Tree, you'll see that I've added another widget, it's our ProgressBar widget, and if you look at the properties for it, I've given it the ID of progress_bar, you'll notice that style is horizontal, so what that means is that it's a progress bar that renders horizontally and we can fill in blocks within that bar to indicate progress to the user. So you can see that the max value is 3. So what that means is the valid progress values for this particular progress bar are 0, 1, 2 or 3. Zero would be none of it filled in, a value of 1 would make it 1/3 filled in, 2 would be 2/3 filled in, and then 3, of course, would be fully filled in. So basically this allows us to give the user a sense of progress as our work goes on. So now if we look at the visibility property, you can see that's set to gone. So what that means is that unless I write code to actually show that progress bar, it's completely out of the way. And that's what we want. We only want the progress bar visible when there's actually progress to show the user. So with this progress bar in our layout, let's head back over to our NoteActivity code and see how we can interact with it from within our AsyncTask. So we're now back over here in the code for our NoteActivity. Now of course, to interact with the progress bar, we're going to need a reference to it. So in here where we create our AsyncTask class, let's go ahead and add a field of type ProgressBar. So that gives us as field to hold the reference to our progress bar, but of course we're going to need to get a reference. Well just as AsyncTask has an onPostExecute method, it also has an onPreExecute method, which is a method that runs before the doInBackground work. So let's do a Control+O, we'll choose onPreExecute, and we'll hit Enter. Now onPreExecute runs on the main thread, so it's safe for us to interact with user interface. So let's go ahead and get a reference to our progress bar and store it in the field. So now we have a reference to the progress bar. Let's go ahead and make it visible. And now that we have a reference to the progress bar, let's go ahead and set its progress value to 1. So now with this code in place, before we actually start the background work, the progress bar will become visible and the initial 1/3 of it will fill in, and that's goes ahead and gives the user a sense that progress is happening. So now down inside of our doInBackground method, we want to continue to advance the progress bar. So let's say when we finish this slow database work, I'm going to go ahead and advance the progress from 1 to 2. So we'll call the progress bar setProgress method with a value of 2. And then after we finish the slow work with the data, we'll go ahead and set the progress value to 3. So now within our doInBackground method, we've added the code that we want to use to advance our progress bar. But you'll notice that both the calls to setProgress are underlined in red. Well if I put my cursor over the first one, notice that it says that it must be called from the UI thread. So basically this is a method we're not allowed to call from the background thread. So what this tells us is that for us to provide progress updates to the user, we've got to be able to switch out of the background thread and back over to the main thread so we can interact with the user interface. So in our next clip we'll see how to do that.

Providing Progress Updates with AsyncTask
Here we are back in Android Studio and we're continuing our work providing progress updates for within our AsyncTask. Now as you recall in the last clip, we tried to call the progress bars, so progress method directly from inside of doInBackground. But we're not allowed to do that because doInBackground runs on a background thread and setProgress method is supposed to be called on the main thread. Now AsyncTask provides the ability for us to pass progress information from the background thread to the main thread. But now in order to do that, we need to tell AsyncTask what the type of the information we need to pass is. If we look up here at our AsyncTask declaration, that's where that second type argument comes in. Now currently we have it as void, well we want to pass the integers, so let's change that from void to integer. So now notice, both where we declare the variable and where we create the class, we've changed that void to integer. So to provide progress, the AsyncTask class has a method called onProgressUpdate. So we'll want to go ahead and override that in our class. But now before we do that, let's just scroll down here a little bit. So we're now here just after doInBackground. So we'll add the onProgressUpdate method just after doInBackground. So we'll do a Control+O, we'll choose onProgressUpdate, and I'll hit Enter. So notice now that onProgressUpdate now accepts a variable length parameter list of type Integer. So what we want to do now is take whatever value onProgressUpdate receives and pass it to our progress bar's setProgress method. We're only receiving one value, so let's declare a local variable of type int and we'll name it progressValue, and we'll assign it values subzero. And then once we do that, we'll call the progress bar's setProgress method, passing in progressValues. So as you can see here, within onProgressUpdate when we call setProgress, it's not underlined in red because that method runs on the main thread. So what we need to do now is have our doInBackground method pass the progress values into the onProgressUpdate method. So the way we do that is by calling the AsyncTasks publishProgress method. So there we call setProgress to the value of 2, we're going to replace that with publishProgress with a value of 2. So that calls the value 2 to be passed from doInBackground into onProgressUpdate, then onProgressUpdate will set our progress bar's progress to the value of 2 using the main thread. So now we need to do that same thing where we call setProgress with a value of 3 in our doInBackground method. So we now have the code in place for our doInBackground method to pass the progress values from the background thread into onProgressUpdate, which runs on the main thread, when then in turn updates our progress bar. But we have one last thing we need to do with regard to displaying the progress. Remember that in our onPreExecute method we made the progress bar visible, well once we're done, our onPostExecute method runs. So inside of onPostExecute we want to set our progress bar's visibility back to gone. So now when we run this code and we click new note, we should see a progress bar show up, we should see the progress advance, and then when we're done we should see that progress bar go away. So let's go ahead and run this and verify that's what happens. So here we are with the code running, so what we'll do is we'll click the new note button, let's see if our progress bar shows up and behaves as we expect it to. So I'll click new note, you can see the progress bar there, you can see it start to fill in, and then once it fully fills in, it disappears and we see our snackbar show up. So we've seen here that the AsyncTask class provides us with the tools we need to properly handle longer running work. The doInBackground method allows us to do the actual work on a background thread, but then we have the other methods we need to interact with the main thread in those cases where we need to interact with user interface. Alright, so now in our next clip we're going to look at another aspect of Android threading that use things called Loopers and Handlers.

Working with Handlers
Oftentimes when we think of a thread running in a process, we think about that thread just running linearly over time. But now we know in our Android applications, the main thread must be more sophisticated than that because the main thread has to handle a lot of different work. It has to handle the user interactions that go on, as well as the various system events that occur. So the main thread has to have some way of orderly dealing with all that different work that's coming into it. So the main thread is actually a special kind of thread called a Looper thread, and as the name implies, a Looper thread has a Looper. And it also has a message queue, so the way the main thread receives the work it has to do is all that work such as user interactions and system events are fed into the message queue. And then the Looper reads that work off the message queue, and then it takes that work and dispatches it out to something called a Handler, and it's the Handler that actually performs the work. Now of course when our application is started up, the main thread has a default Handler and that does most of the system work. But now in addition to the Handler that the system creates, we can also create our own Handlers and associate with the loop, which means that we can write our own code that takes advantage of this capability of placing work into a queue, then having that work dispatched out to a Handler. Now the Looper thread is a very powerful concept. Now as we mentioned, it contains a Looper and a MessageQueue, and it has the ability to dispatch work out to instances of the Handler class. Our main thread is the most common instance of the LooperThread we interact with, but our application can create additional Looper threads if we need them. But our main point of interaction our the Handlers because the Handler allows us to do the work we need to do on our Looper thread. So we can use an instance of a Handler to enqueue work into the message queue of a Looper thread and then the Looper encounters that work, it will then dispatch the work back out to that Handler instance. So by using a Handler, we're doing our work kind of in two stages. We're queuing up the work in the message queue, and then we're later performing that work within the Handler. Now a Handler is just a type, so we have to construct an instance of a Handler to create one, but now when we construct a Handler, it has to be associated with a Looper. Now if you construct a Handler with its default constructor, it will be associated with the Looper of the current thread, but sometimes we want to construct a Handler on a background thread and then associate it with our main thread. And we can do that by using the Looper class's static method, getMainLooper, that will allow us to get a Looper associate with the main application thread and then construct the Handler that's associated with the main thread's Looper. And the reason that's important is because once you construct a Handler, that Handler is bound to that Looper. Now what that means is if you use a Handler instance to enqueue work, you can enqueue the work form any thread in your application you want to, but the work itself will always be performed on the thread of the associated Looper. So now this idea of a Handler being bound to a Looper on a particular thread opens us up to some powerful solutions. One of the things we can use our Handler for is sending work to one thread from another. In fact, this is how the AsyncTask class works. The AsyncTask class actually uses a handler to switch between the work done on the background thread and the work done on our main application thread. And Handlers also allow us to schedule work to be performed in the future. When we use a Handler to place work into the message queue, we can indicate that we don't want that work performed until sometime in the future, and then the Looper will take care of the details of dispatching that work to our Handler at the right time. So now to give us a better sense of how this works, in our next clip we'll use a Handler to schedule some work to be performed in the future.

Delayed Opening of NavigationDrawer with Handlers
Here we are with our app up and running in the emulator, and what we'll look at in this clip is how to use a Handler to schedule some work to be performed at some point in the near future. Now before we get into those details, let's look at an opportunity we have to improve the user experience of our application. Now we know that our application has a navigation drawer, we can go ahead and open that navigation drawer and it gives us the ability to select options. But now a user who's brand new to our application might not realize that we have the navigation drawer available. So what developers often do is have the application automatically open the navigation drawer when the main activity is initially displayed. So let's add the code to our application to do that. So we'll switch back to Android Studio. So we're back here in Android Studio and we're looking at our main activity class's onResume method. Remember that this method gets called just as activity moves into the foreground. So this might be a good place for us to go ahead and open up that navigation drawer. So let's call the method we'll create named openDrawer. We'll go ahead and do an Alt+Enter and create that method. We'll accept our return type. So now to open the drawer, we of course need to get a reference to the drawer. So we'll assign that reference to a local variable named drawer of type DrawerLayout, then once we have that reference we'll call openDrawer on it, and since our drawer is open from the start edge of the screen, we'll pass in Gravity. START. So let's go ahead and run our application on the emulator again and see what it looks like when the drawer opens. So I've installed the latest version of our app on the emulator, but rather than launching the app directly from Android Studio, I'm going to launch it from our launcher screen so we can see exactly what the experience is like when the application first starts up. So we'll go over to our launcher screen, we'll choose NoteKeeper. You'll notice that when I did that, the navigation drawer just kind of appeared there. But we know our navigation drawer actually has animation associated with it. If I click here, it slides off to the left side of the screen. If I go ahead and click up here, it slides back onto to the screen. So if we want our app to show the user that the navigation drawer is available, we like them to actually see that animation experience of the drawer sliding in from the edge of the screen. Well the reason that didn't happen is because when we called openDrawer, there was still a lot of work left to do in that main activity. So by the time the main activity was ready to be displayed, the navigation drawer was already open. So from the user experience, it seemed like the drawer was just there. Well this is a case where we can use a Handler to delay opening the drawer. So let's head back to Android Studio. So we're back here in our main activity class's openDrawer method and let's go ahead and create a Handler. So we'll declare a local variable of type Handler named Handler, and then we'll create a new instance of Handler. So what this code will do is create a new Handler and associate with the Looper of the current thread. Now we know that this code is run on our main application thread, so that means it would be associated with the Looper on our main application thread, and that's what we want to have happen. But if we were creating this Handler from background thread and we wanted to associate with our main thread's Looper we could explicitly pass in the Looper from our main thread. So in this case it would explicitly associate the Handler with the main thread's Looper no matter which thread the Handler instance was created on. But now notice here, we're creating our Handler and associating it with a local variable, and that's okay for what we're doing because we only need that Handler in this method. But if you needed to keep reusing the Handler, it would be just fine to associate with a field within our class. So now once we have the Handler, we want to put some work in the message queue. So we'll call the handler. post method. Now remember that the work we send to a Handler is placed into a message queue, and there's two ways we can put the work into the message queue. There's a class called message, which we can use to put work into the message queue, or we can use an implementation of the runnable interface. So now in our case, we'll just go ahead and use that implementation of the runnable interface. So I'm going to say new Runnable, then I'll hit Control+Space and I'll let Android Studio write the initial code for a runnable implementation. So now what this does is provide implementation of runnable that will be run on the Handler by passing that work into the message queue and then dispatching it out to our Handler. So now what we want to do inside of here is run that code to open our drawer. So we'll take that code to open the drawer from the body of our openDrawer method and place it within our runnables run method. So now as this code is currently written, as soon as we call post, this work is placed into the message queue, and then as soon as the Looper gets to that point in the message queue, it'll run the code inside of our run method. Now at this point there still may be a lot of work left to display our activity, so there's as good chance that by the time the user sees the navigation drawer, the drawer will still already be open, and remember we want them to see the animation. So what we want to do is put this work into the message queue and indicate that we want to put a delay on when the code is run. So instead of calling the Handler's post method, we're going to call postDelayed. So what postDelayed allows us to do is pass in a timeframe for how long we want the delay to be before the code is run, and we pass that in as milliseconds. So what we'll do is pass in 1000 milliseconds. So now what'll happen is when our openDrawer method gets called, we'll place the work into the message queue indicating that we want it run about a second from now. So then a second later, the code within our run method will run and that'll go ahead and open our navigation drawer, and at that point we should see it open up with the appropriate animations. So here we are back on our emulator, let's go to our launcher screen and we'll go ahead and choose NoteKeeper. And you see when our main activity rendered, we initially saw the main activity, and then after a short delay our navigation drawer opened, and because the main activity wasn't busy doing other things, it appropriately rendered the animations of opening up the navigation drawer. So by using our Handler, it was very easy for us to schedule work that we wanted to run at some short time in the future.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember the important role of the application's main thread. The main thread is responsible for most of the user's experience. In addition to that, most of the work that our program would want to do to interact with the user interface actually has to be run on that main thread. Because the main thread is so important, we want to make sure it doesn't get bogged down doing any lengthy work. So to help us protect against that, we have the StrictMode class. The StrictMode class can detect when undesired operations are happening on the main thread, things like disk interactions or network interactions. And then we can enforce a penalty that we want to occur when one of those operations are detected. It can be something as simple as writing the Logcat or something as severe as killing the process. But now remember, StrictMode is a tool we use during the developing of our application. We don't want to release our application with StrictMode enabled. Then we looked at AsyncTask. Remember the AsyncTask allows us to perform work on a background thread, but it makes it easy for us to perform the appropriate user interactions on the main thread. And part of AsyncTask capability is that it allows us to move data between that background thread and the main thread. And then we looked at a LooperThread, remember a LooperThread is a thread that has a Looper and a MessageQueue. And so work is then placed into the MessageQueue, the Looper reads to that MessageQueue and dispatches work out to Handlers. An application can have a number of different Looper threads if it needs them, but the main thread is always a LooperThread. now was talked about, the work is actually performed in a Handler, so when a Handler is created, it is bound to a Looper, and any work performed by the Handler is then run on the thread that's associated with that Looper So this concept of being able to place work into a message queue and then having a Handler's work always performed on a specific thread, allows us to simplify many common tasks we might need to deal with, doing things like scheduling work to be performed at some point in the near future. Or having work running on one thread, dispatch work out to our Handler knowing that that work will then be run on a different thread, which would be the Handler's thread. Alright, that wraps up this module. In our next module, we'll learn about Android Services. And we'll learn how to use services effectively to perform certain types of background work and non-UI related work.

Performing Background Work with Services
Introduction
Welcome to our next module, Performing Background Work with Services. This is the Pluralsight course, Leveraging the Power of the Android Platform. My name is Jim Wilson. Applications often need to perform non-UI background work and in many cases that work may need to run for an extended period of time. Now attempting this sort of work with an activity can often lead to problems so we need a better solution. In this module we dig into that solution, which is Android Services. So we'll start out and we'll look at the limitations of performing background work within an activity. We'll then see the advantages of using services to perform background work. Then we'll see how to implement a service. In particular, we'll see how to implement a service using the IntentService class. We'll then see how to start a service from within our application and then we'll wrap up with how we can start a service using a PendingIntent.

Background Work and Activities
As we've talked about, activities can initiate background work and there are a number of different ways we can do that. There are very specific things like a cursor loader, which is designed to do a cursor lookup on a background thread or there are more generalized solutions like AsyncTask, but there are limitations to background work that are run directly by our activities because remember that activities have a lifetime and the lifetime of an activity is tied to user interaction. So what that means is if a user stops interacting with an activity, that activity can get cleaned up and the activity's lifetime ending can impact the lifetime of our background work. So what that means is that the threads doing our background work may get cleaned up before the actual work itself is completed. So to help us understand this a little better, let's first look at what goes on when the user interacts with our activities in our application. So we have our launcher here and when the user taps on the icon, the launcher application's main activity, but before Android can actually launch the activity, it has to create the process associated with our application and then within that process it creates our main activity. Then if we need to start a second activity, the main activity will send an intent to start that activity and then the user is now interacting with our second activity, but when the user wants to leave that activity, they hit the Back button. When they do that, the second activity gets cleaned up and the user experience returns back to our main activity. The user hits the Back button again, the main activity gets cleaned up and then at some point after that, the Android system will go ahead and clean up the process associated with our application. So now let's take a look at how this affects our background work. So if the user taps on the icon, the Android system starts your application process, creates our main activity within the process. We send an intent to start the second activity and now let's say that second activity wants to do some kind of background work. So we use an AsyncTask to start doing work on the background thread. So that work is now running on the background thread, the user hits the Back button to leave our second activity. Our second activity gets cleaned up and the user is returned back to our main activity, but now at this point our application process is still running so that background thread can continue to run. But now if the user hits the Back button again, that cleans up our main activity and for some period of time our application process will still be allowed to run. So that background thread just doing our background work could continue to run as well, but now the problem is with no activities existing, Android doesn't really think we need this process any more. So at some point it will clean up that process, including any threads within it. So if that background thread still had work to do, the thread would get cleaned up and destroyed without having a chance to finish its work. So in our next clip, let's look at how Android Services help us address this problem.

Background Work and Services
Services allow us to perform non-UI work within our application, but the key thing about a service is that it makes Android aware that the work we're doing within the service is meaningful work, even though we're not presenting a user interface. So now let's look at the same scenario we were looking at in the previous clip, but now this time we're going to introduce a service. We have the launcher, user tabs on the icon for applications' main activity. Android will go ahead and launch the process for our application, create our main activity. From that main activity we send an intent to start our second activity, but now when our second activity wants to start some background work, rather than using something like an AsyncTask, it's actually going to send an intent that starts a service. So our background work is now running within the service. Now starting the service doesn't change the user's experience at all. The service is doing background work, but it's not presenting any kind of user interface. So the user is still looking at our second activity, but now if the user hits the back button to leave our second activity, that second activity gets cleaned up and the user is now looking at our main activity. Now our service continues running and then when the user is done interacting with the main activity, we'll hit the Back button again, and our main activity gets cleaned up and our service continues running, but now because the work is running within a service, Android considers that work meaningful and we'll go ahead and keep our process alive while the work within the service continues. Then once the service is done, the service gets cleaned up and then at that point, Android can go ahead and clean up the process associated with our application. Now remember as we talked about the very first course in the series, Android is a component-oriented platform and it has a number of different types of components. Now activities are the most familiar type of component, but they're not the only kind. Remember earlier in the course series we talked about content providers. They were a type of Android component. And services are also a type of Android component. So a service has a life cycle, it just happens to not present a UI, but Android still sees it as a component, which means it has a meaningful lifetime to it. Now what services do is they allow us to perform long-running background work and generally, any time we're doing work that takes more than a few seconds, we want to do that work in a service so we can be sure that the work will continue running even if the user switches to another app. Now the way we submit work to a service is using an intent. So we create our intents for our service very similar to the way we create an intent for an activity and intents we create for a service can have extras just like activity intents can have extras, but now of course a key difference is rather than calling startActivity, we call startService and then calling startService will pass the intent into our service so the service can then begin doing work based on that intent. So in our next clip let's see what's involved in implementing a service.

Implementing a Service
When we implement a service, the class we create will extend the Service class. Now the Service class provides things like lifecycle methods, things like onCreate or onDestroy and of course it provides the method that gets called when the work comes into our service. Now we can implement a service by directly inheriting from the Service class. Now if we do that, we have access to a great deal of power provided by services, but we're also left to deal with a lot of details. So if we implement a service by directly inheriting from the Service class, one of the things we have to deal with is our service's threading behavior. Now remember that service exist to do background work, but what's kind of strange about them is when a service receives the work that's sent to it, that work is received on the main application thread, which means that if we started doing the work directly on the thread we received the work, we would actually impact the user interface. So what we need to do then is take that work that we received on the main thread and dispatch it to a different thread so we can actually do it in the background without impacting the user interface. Now another thing we have to deal with is how do we want to handle multiple submissions into our service? So when someone calls startService, if our service isn't running, Android takes care of creating an instance of our service and starting that service running. The service can begin doing its work, but now we're limited to one active instance of our service at a time. So what that means then is that if our service is up and running and it's busy doing some work and startService gets called again for that same service, the new work comes into the existing instance of the service so then if the service is already busy doing some bit of work, we have to decide how we want to deal with that. Do we want the new work to wait until the old work is finished or do we maybe want to get it to spin up yet another thread and do the work at the same time? And then another key issue that comes up is service lifetime. So once our service starts up, do we want our service to keep running or do we want it to shut down as soon as the work is done, or maybe we want it to run for a few seconds and hang around and then shut down. Also in some cases the system may decide to shut our service down. Well, if the system decides to shut it down, we then have to decide how we want to deal with that service being restarted or do we even want it restarted? Alright, these are all housekeeping issues related to services that have nothing to do with the actual work we want to do inside of our service, but now as I mentioned, inheriting directly from the Service class gives us a lot of power, but also burdens us with a lot of things we may not actually want to have to deal with. So in our next clip, we'll see how we can implement a service without having to deal with all those kinds of details.

Implementing a Service with IntentService
To enable us to implement a service without having to deal with all those housekeeping details, we have the IntentService class and basically its job is to simplify service implementation and so it does provide some standard behaviors that work well for most common scenarios. The IntentService class just addresses a lot of those housekeeping issues we talked about. So for example, the issue of threading. Well, an IntentService creates a LooperThread that's separate from our main application thread and then the work we do in our IntentService is actually done on this background LooperThread. So we can do our work without concern about impacting the user interface. When it comes to the issue of dealing with multiple work submissions, remember that a LooperThread has a message queue. Well, what the IntentService does is that for each piece of work that comes in, it just places it into that message queue. So then our class is free to work on the items one at a time and because the work goes into a message queue, we get the work in the order it was sent to us. So we have the simplicity of going through our work submissions one by one in the order they were sent to us. So when it comes to the issues of managing our service's lifetime, what the IntentService does is shut down when the current work is complete and there is no more work in the queue. So by using this IntentService, we go through the work items one by one in the order they're received and we know our service is shut down and there's no more work left to do. Now to implement a service that uses IntentService, all we do is extend the IntentService class. Now the IntentService class does extend service so we are implementing a proper service, it's just taking care of those housekeeping details for us. So when we extend IntentService we need to provide a default constructor that calls the base class constructor, passing in a string that contains the name of our service and that's used primarily just for debugging purposes. And then beyond implementing the constructor, we simply override the appropriate methods for our service. Now when we implement a service using IntentService, we always override the onHandleIntent method and this receives whatever intent was passed into startService. So we could then access that intent as well as any extras associated with it and we perform our work directly in this onHandleIntent method and the IntentService class just takes care of running the onHandleIntent method on this background LooperThread. So the work we do here won't impact the user interface. Now the onHandleIntent method is the only method we have to override, but if we need to, we can also override other service methods. Just when we do that we want to be sure to call the IntentService class' implementation of that method and doing this is helpful for those scenarios where we want our service to tap into the lifecycle of the service. So if you want to do something special when the service is created or when the service is destroyed. Alright, so now in our next clip let's start adding a service to our application.

Your App Note Backup Feature
Here we are with our app up and running in the emulator. Now in this clip what we'll want to do is look at a feature writing to our app that's a great candidate for taking advantage of the capabilities provided by an Android service. So now if we go into our Options menu and we select that, you can see there's a new option here, backupNotes, and this is a feature we've added to allow the user to create a backup copy of all the notes they've created inside of our database. Now let's go ahead and select this. You'll notice that when I select it, the menu option just kind of sits there for a bit and then finally after a bit, the menu closes as it should. So whatever our program is doing when the user selects that option, it's clearly tying up the main application thread. So let's take a look at the code behind it. So here we are in our MainActivity class and we're looking at the onOptionsItemsSelected method. Now this is the method that gets called when a user selects something from our Options menu. Now I've added a new option here with the id action_backup_notes. So that's the id of that new menu option. You notice here that it calls a method called backup_notes. Now if we look here inside of backup_notes, we can see that it's using some class called NoteBackup calling a static method called doBackup and we pass in the this reference of our activity and we also pass in a constant from the NoteBackup class called ALL_COURSES. So let's take a look at the NoteBackup class. So here's our NoteBackup class. You can see our doBackup method. It accepts those two parameters. Now the first parameter is a context which is why we're passing in the activities to this reference and notice that the second parameter is a course id, but now we had passed in a constant to that parameter and that's the NoteBackup class' all courses constant. So let's see what this doBackup method does. So notice first of all we've got a string array and those are a list of columns from our content provider's Notes table. You'll notice just below that we declare variables for the selection and the selectionArgs, we have an if statement that checks the value of the backupCourseId parameter. Now if it's not equals ALL_COURSES, then we build a selection and selectionArgs based on that course id. And then below there we do a query using the content URI of our Notes table along with those columns and any selection criteria we provided. So what this tells us is that we're querying the notes table from our content provider. If we pass in the All_COURSES constant then we get all the rows from our Notes table, but if we pass in a course id, we would only get the notes for that particular course. So the idea here is then is that this doBackup method allows us to back up all the notes in our Notes table or just those notes for a particular course. So let's scroll down here just a little bit. So you see here just below where we do the query, we get the position of all the columns that we've queried for and then we write out to our Logcat and basically we just write out a message that says the backup is starting and we show what thread we're currently running on. Then we just run a while loop and inside this while loop, all we're doing is walking through each of the returned rows and then writing them out to Logcat. So basically for our program we're using Logcat to simulate the idea that we're writing out to a file, but notice where we write out each row's value, right below that we call a method simulateLongRunningWork and that just helps us simulate the experience of having work that runs for a relatively long time. So if this method works as we expect it to, if we go look at Logcat, we should see the values of all the notes inside of our database. So let's go down here to our Android Monitor and we'll choose that. I'm just going to go ahead and scroll this a little bit. So now if we look at the messages that we have in Logcat, notice that we have the message for BACKUP START and it indicates that the thread ID is 1 so that tells us that this code was running on our main application thread and then below that, you'll see a series of messages that all start with the text Backing Up Note. Then each one has a course id, the note title, and the note text. So by looking here at Logcat we can see that our doBackup method behaves just as we expect it to, but based on how long it took this to run, this is something that we definitely should not be running in our main application thread. Now currently, we only have about 10 rows in our table so it takes just a few seconds to write the output, but as the number of notes we have increases, the amount of time it takes for that doBackup method to run will also increase and this could result in our backup eventually taking several minutes to complete. So with that being the case, this is just the sort of work we want to perform within a service. So in our next clip, we'll start doing the work to convert this code to use a service.

Creating the Backup Service
Here we are back in Android Studio and what we want to do now is add a service to our app that will run our note backups and we're currently looking at our NoteBackup class' doBackup method and as we talked about in the last clip, this doBackup method handles the details of doing the actual backup work. So all our service needs to do is call this doBackup method and pass in the two parameters that the method expects. So as you can see here, the first parameter is the context, then the second parameter indicates which course' node should be backed up. So now to get us started, we'll have Android Studio generate a service implementation class for us. So we'll go to our File menu and we'll choose New, and then down there towards the bottom you can see the option for Service. And as you can see, Android Studio gives us two options for services. Now if we choose the first option, Android Studio will create a class that directly extends the service class. As we talked about earlier in the course, directly extending the service class gives us a great deal of control over the service's behavior, but it also requires us to manage a lot of the service related housekeeping details, but now by choosing the second option, Android Studio will generate a class that extends the IntentService class and as we talked about, the IntentService class simplifies the act of creating a service implementation because the IntentService class handles the service-related housekeeping details for us and it does so in a way that works for most common scenarios. So let's choose this option, the one that uses the IntentService class. So now to create our service implementation class, the first thing we have to do is provide a class name. So we'll name our service class NoteBackupService, and then we have this option here Include helper start methods. Now this option had some static methods that can be helpful in scenarios where a service performs a variety of different tasks, but now in our case our service is pretty simple. So we don't really need those methods. So we'll go ahead and uncheck that option and then we'll hit Enter to generate the class, and with that we have a starting point for our service implementation class and as expected, we can see it extends the IntentService class. So let's scroll down here a bit. So now we can see here we have the two required aspects of a service class that extends IntentService. First we have our constructor, which in turn calls the base class constructor, passing in the name of our service, and then we override the onHandleIntent method. Now the onHandleIntent method is where we do the actual work within our service. Now as you can see, the onHandleIntent method receives a reference to the intent that was used to start the service and if we look at the generated code, we can see that we can interact with the intent passed to our service much like we do with the intent used to start an activity. For example, we can see here where the generated code is accessing the values of extras that are associated with the intent. So we'll keep that in mind as we're creating our implementation, but before we start doing our actual implementation work, let's do a quick bit of cleanup with the generated code. Now let's start by removing the code from within onHandleIntent that we don't need. The first thing that onHandleIntent does is check to see that the intent isn't null and then within that if block, it gets the values of some example intent extras and then it calls some stub methods. So let's remove all that code within the if block. So now all that code is gone so let's scroll down here a bit. So now here toward the bottom of our class, we can see we have two methods, Handle action Foo and Handle action Baz and these are just stub methods that were being called by the generated code within onHandleIntent and we don't need these methods so let's go ahead and delete them as well. So now that they're gone, let's go ahead and scroll back to the top of our class. So now you can see here towards the top of the class, the generated code includes several example constants. Now we don't need most of these constants so let's delete all of them, except the last constant for an extra. So now with all that stuff cleaned up we're ready to start doing our implementation work. So the first thing we'll do is change this constant to an appropriate name and value, but since our service needs to pass a course id to the note backup class' doBackup method, we'll accept a course id as an extra. So let's change the name of this constant to EXTRA_COURSE_ID and then we'll change the constant's value to an appropriate string that includes the text COURSE_ID. So now our constant's all set, but while we're here, let's go ahead and remove these extra blank lines from just above the constant. Alright, so now we're ready to start doing the actual work inside of onHandleIntent. So the first thing we'll do is have the onHandleIntent method get the value of the COURSE_ID extra. So let's declare our local variable named backup COURSE_ID of type string. Now our onHandleIntent method receives an intent as a parameter. So we'll call the getStringExtra method against that intent and then we'll pass in the constant for a COURSE_ID extra. So now that'll give us the value of that extra and store it into our local variable named backupCourseId. So with that, we're now ready to call the NoteBackup class' doBackup method. So now the first parameter to do backup is the context. Now just as with an activity, a service can be passed as a context so with that being the case we'll just pass in our this reference. And then for the second parameter we'll pass in our backupCourseId variable and with that our service implementation class is all set. And as you can see, implementing the service is actually pretty straightforward and that's because the IntentService base class is doing all the service-related housekeeping work for us and as part of that work, remember that the IntentService class takes care of running our onHandleIntent method on a background thread. So that means that even though our doBackup method may run for an extended period of time, we can safely call it from within onHandleIntent, knowing that it won't interfere with our main application thread. Alright, so now that our service is all set, in our next clip we'll add the code to start our service and then verify that everything works as we expect it to.

Verifying the Backup Service Behavior
Here we are back in Android Studio. What we want to do now is add the code to start our node backup service and we're currently looking at our MainActivity class' backupNotes method. Remember that this is the method that gets called when the user selects the NotesBackup options menu. Now currently, backupNotes calls our NoteBackup class' doBackup method directly. We know that doBackup can run for an extended period of time. So by calling it directly from within our activity, it causes our user interface to freeze while the backup is running. So what we'll do is replace this direct call do to backup with code that'll actually start our service that will do the backup. So the first thing we'll do is get rid of this line here that calls the doBackup method directly and so now we want to start the service. Now to start our service we need to create an intent so let's declare a local variable named Intent of type intent. Then we'll create a new instance of the Intent class. Now even though we're planning to use this intent to start a service, we create the intent very much like we do when we want to launch an activity. So our first parameter will be the context. So we'll pass in our activity's this reference. Then we want to start the service that's implemented by our NoteBackup service class. So we'll pass in NoteBackupService. class. We know our service expects this intent to have an extra. So we'll call intent. putExtra. We'll then pass in the name of the extra using the NoteBackupService class' EXTRA_COURSE_ID constant, and then for the value of the extra we'll pass in our NoteBackup class' ALL_COURSES constant. So now we've created the intent that launched the service that's implemented by our NodeBackupService class and we provided an extra that indicates we want to back up all the notes. So now all we need to do is actually start the service. We do that by calling the StartService method and then we pass in the intent we want to use to start our service, and that's it. That easily we go ahead and launch our service and pass in the information on what courses we want backed up. So let's go ahead and run this guy now and see how everything works. So here we are now with our application up and running and I've added some breakpoints to our code so we can see what's actually happening. So I'll go to our Options menu, I'll choose Backup notes. You see, when we do that we hit a breakpoint back in Android Studio. So let's switch back to Android Studio. So back here in Android Studio we're in our MainActivity class' BackupNotes method. We can see that we've created our intent and we're about to call StartService. So let me go ahead and release this and you see when I release it, we immediately get to our NoteBackupService class' onHandleIntent method and the first thing we do of course is get our extras value. So hit step and now if we look down in the Variables window, we see we got our extra, which is ALL_COURSEs, which is what we wanted and now we're about to do the actual backup. So let's go ahead and release our code and let's switch over to our Android Monitor. You see on the Android Monitor, you can see the message for Backup Start and you can see we're backing up our individual notes. Then our backup completed. And you notice there in the message BACKUP START we have our Thread id. The Thread id is 108. And as we talked about earlier in the course, the actual thread id itself is not that important. As long as the id is at 1, it tells us it's a background thread, not our main application thread. So that verifies that the code within our onHandleIntent method is running on a background thread. So with all that then, we see that our service works just as we expected. We were able to start the service from our MainActivity class, but then the actual backup work is from the background thread and our service class' onHandleIntent method. So now that we know that our service is working, in our next clip, we'll look a bit more at what goes on when starting a service.

Starting a Service
As we've seen, starting a service is very similar to starting an activity. In both cases, we create an appropriate intent, we associated any needed extras with that intent, then we call the appropriate start method. Start an activity, we call StartActivity, start a service, we call StartService. Now given these similarities between starting a service and starting an activity, it makes sense that both services and activities offer very similar startup options. Now of course the startup option we're most familiar with is starting from within the same app. So we think about our application, we have our main activity and it wants to start our node activity, it create an intent for our node activity and then when we call StartActivity with that intent, Android takes care of creating an instance of our node activity class within our application's process and starting our service worked in much the same way. We create an intent for our NoteBackupService and then we call StartService, which calls Android, creating an instance of our service again within our application's process, but now remember, one of the real powers of Android is that components can be used across applications. Think way back to the very first course in the series. Remember we added the ability to our application for our node activity to send an email using the activity from the Gmail application. Well, how did we do that? Well, first we created an intent that was appropriate for the Gmail application's SendMail activity and then we called StartActivity. Android took care of launching the process for Gmail and then displaying the activity that lets a user send an email. Well, services work in much the same way. If we want to use the service from another application, we create an intent that's appropriate for that service, we call StartService, Android will take care of launching the process, creating the instance of that service, and then running it inside the appropriate application's process. And then we have PendingIntent. Remember that a PendingIntent allows us to delegate the application of starting a component. And so if we think about our application's notification, we have that View All Notes action. Well, if the user taps on that action, it'll start our main activity because we created a pending intent to start our main activity and associated it with that action. Well again, we can extend this behavior to services. So we added another action to our notification such as Backup Notes and we created a pending intent to start our service and associated with that action, when the user taps on that action that PendingIntent can then be used to launch our service running and do the actual backup directly from a user interaction with the notification. So as you see, Services gives us a number of startup options, but there are a few things we want to keep in mind. First one, if we want to have a service be startable from another application, we need to mark that service as exported. Services just like activities and content providers have an entry inside of our application manifest so we can use that entry in the application manifest to mark our service as exported. And then when it comes to working with a PendingIntent, remember that the way we create an instance of a PendingIntent is by calling a static method on the PendingIntent class. Well, the way we created a PendingIntent for activities was by calling the static method GetActivity. So then of course to create a PendingIntent for a service, we used the PendingIntent class' getService static method. To give us a better sense of using a PendingIntent to start a service, in our next clip we use a Pending Intent to allow the user to start our backup service directly from our application's notification.

Using a PendingIntent to Start Your Service
Here we are back in Android Studio and what we want to do now is add the ability for a user to initiate our notes back up directly from our application's notification. Now we're currently looking at our Note Reminder notification class' Notify method. This is the method responsible for creating our notification and then displaying it. So now to provide the user with the ability to launch our backup service, we'll have to add that as an action to our notification and actions use a PendingIntent, but not before we can create a PendingIntent, we first need the intent that we'd use to start the service directly. So here in our Notify method let's create a local variable named backupServiceIntent of type intent. We'll create a new instance of the Intent class and we'll pass in the context and then the class information for our NoteBackupService. So now that we have the intent created, we'll go ahead and associate the extra that indicates we want to backup all courses. So now with that if we wanted to launch a service directly, we could simply call StartService and pass in this intent, but we don't want to start the service directly, we want to associate a PendingIntent with our notification that allows the user to launch the service. So to do that, let's scroll down a little bit. So now we're down towards the end of our Notify method and you can see here where we have our existing call to our builder's addAction and that call adds the action to view all nodes and of course that uses a PendingIntent to display our main activity. So let's make another copy of that call to addAction. So let's modify this call to addAction to allow the user to start our service. So the first thing we want to do is change our display text. So let's change that text View all notes to say BackupNotes. Then we can see just below that text is where we create the instance of our PendingIntent. Now currently this code is using the getActivity method to create the PendingIntent, but that would be a PendingIntent that launches an activity; we want to launch a service. So instead of getActivity, we'll use getService and then within the call to getService we want to provide the intent we want used to start the service. Now currently, the intent within our call to getService is the intent that would launch our MainActivity class. So let's remove that and then instead we'll pass in our backupServiceIntent local variable, and that easily our notification will now display an option that says Backup notes and when the user selects it, it'll launch our NoteBackupService. So let's go ahead and run this now and verify that everything behaves as we expect it to. So here we are now with our application up and running. Let's go ahead and choose and note. That opens our NoteActivity. Let's go to our Options menu and let's select Set reminder. Let's go ahead and minimize our activity now. Let's open up our Notifications drawer and we can see here now that our notification has two actions on it. It has the View All Notes action that we had previously, but now we also have our Backup Notes action. So now if I select that and then switch back to Android Studio, you can see that we have our Backup Start message in there as well as the Backing Up Note messages. So we can see there that our notification properly started the service. So now with that, our application not only has a backup service that the user can launch from within the application, but they can also launch the service directly from our application's notification.

Summary
To wrap up, here are some of the key things we want to remember from this module. Remember that activities can launch background work and it's okay to launch background work directly from an activity as long as that work finishes in a few seconds or less, but in cases where the background work may run longer, we don't want to run that from within our activity because if the user switches to a different application, our application process may get cleaned up before that background work finishes. So this is where services come in because services allow us to reliably perform long-running background work, because by putting that work into service, the work will continue to run even if the user switches to a different application. Remember that Services extend the Service class and Services themselves are very flexible; they give us a lot of power and a lot of capabilities, but along with all that power and capability, there's actually a fair amount of housekeeping that comes in if we directly extend the service class. So because of that, we tend to extend the IntentService class and the IntentService class simplifies the job of creating a service and it does that by taking care of a lot of the housekeeping details that go along with implementing a service and it does so in a way that works well for most situations where we use a service. And remember that we start a service very much like we start an activity. We create the intent for our service, we can associate any extras we need with that intent, and then we launch that service by simply calling the startService method and passing in that intent. And remember, in addition to being able to directly start a service, we can also associate a service with a PendingIntent. So to do that we'll create our service's intent just as we normally would and then we create the instance of the PendingIntent by using the getService static method of the PendingIntent class. Alright, that wraps up this module. In our next module we'll dig into the Android Job Schedule.

Scheduling Background Work with JobScheduler
Introduction
Welcome to our next module, Scheduling Background Work with JobScheduler. This is the Pluralsight course, Leveraging the Power of the Android Platform. My name is Jim Wilson. Performing background work effectively presents challenges both for the Android system as well as for developers. So in this module we'll look at how we can alleviate many of those challenges by using the Android JobScheduler. So we'll start with an overview of the Android JobScheduler. We'll then see how to create the class that will serve as our job's implementation class. We'll then take a look at how to create information and criteria for our job as well as schedule a job. We'll see the appropriate way to launch our work running in the background, and as part of that we'll see the appropriate way to handle the situation with the JobScheduler indicating that our work needs to stop before our work is actually completed, and then we'll finish up with a look at how to choose between a traditional Android service using the JobScheduler to perform our app's background work.

Background Work Challenges and Job Scheduler
Throughout this course we've been talking a lot about background work and the reason we talk so much about it is because we commonly need to do background work in our applications. Because our applications often have long-running work we need to perform, we want to make sure we perform that work in a way that it doesn't affect the user's foreground experience, but doing background work well presents some significant challenges. It presents challenges to the system, as well as the fact that it presents challenges to us as developers. One of the big challenges from the system standpoint is that many applications now need to run background work and most of us have a lot of applications installed in our devices and if many of those applications are running background work, that background work can begin to affect the user's foreground experience. So even though any given application's background work may not directly affect the user's experience, collectively that background work can start to have system-wide impact. Because when we start running a lot of background work, well, that starts using up more of our memory and it starts using up more of our CPU and it begins to drain our battery. Now for us as developers, one of the biggest challenges we face is the fact that much of our background work relies on certain criteria being met before we can do the work. One of the most obvious ones is the issue of network connectivity. We have background work that needs to interact with the server, but we can only do that work when the device is connected to a network, but there are other criteria that come up as well. Maybe there is work you do that uses a lot of CPU so you know it's going to drain the battery rapidly so you only want to do that work when the device is plugged in, or you have some work that has some timing requirements, you want to run it at some time interval or after some delay, and although any one of these criteria may not be that difficult to deal with, as you start to have more and more criteria for your jobs, getting it right can become very challenging because what you have to do is have code that determines if your criteria is currently being met and if it's not currently being met, then we have to have code that will wait until our criteria is met. And then even once we start doing our work, we have to have code to detect if any of that criteria goes away. So we can stop doing the work in an orderly fashion and plan to continue it later when the criteria is again being met. And to help us out with all this, Android introduced the JobScheduler. The JobScheduler addresses most of our background work challenges. From the system standpoint, what the JobScheduler does is give the system more control over when background work is run. With traditional Android services, each application controls when its background work is run, but with the JobScheduler the system has more centralized management over when that work is run. And then for our developer challenges, the JobScheduler takes care of the details of our run criteria. All we have to do is tell the JobScheduler what our run criteria is and the JobScheduler will make sure that criteria is met before it starts running our background work. So in our next clip let's start taking a closer look at the JobScheduler.

Job Scheduler and Job Implementation Class
The JobScheduler is a relatively new feature of Android. It was added at API level 21, which means it's supported by Android devices that run Android 5. 0 or newer. Now as you recall from earlier in the series, we can go over to the Android dashboards and see what percentage of devices support a given API level. If we head over there, we'll see that the majority of Android devices support the JobScheduler. The JobScheduler is really becoming the preferred way to do background work because remember that traditional Android services allow each application to manage its own background work. The JobScheduler allows the system to manage the background work, which means the system can better manage system resources and that means that it can limit how much background work affects the user experience and it can limit how much background work impacts the overall device. The JobScheduler is useful for many of the common scenarios where we would've historically used Android services, but there is one key caveat. Jobs submitted to the JobScheduler may not start immediately. So if you have a scenario where your background work must start immediately, in that case you want to use a regular Android service, but in all other scenarios you really want to look at using the JobScheduler instead. Now as its name implies, the JobScheduler handles each bit of work as a job and a job is created in steps. So the first step is to implement the job and we do that by creating the class that will serve as the component that handles doing the actual work for the job. Then we need to build the information about the job and that information includes a number of things including the criteria to run the job. And then once we have our information, we can go ahead and schedule the job and we do that by submitting the information to the JobScheduler and then the JobScheduler will handle running our job once all the criteria has been met. So let's look at implementing a job. Now jobs are implemented as a service, but it's a special kind of service. We have to extend the JobService class and there are two key methods we have to override. There's the onStartJob method and the scheduler calls that to indicate that we can go ahead and start doing the actual job and we can rely on the fact that when this method is called, any criteria we specified has been met. And then the other method is onStopJob and this is called by the JobScheduler to indicate that the job should stop. Now onStopJob is not always called. Generally speaking if onStopJob gets called, it means that one or more of the criteria we specified is no longer being met. Now we'll look a bit more closely at both these methods a little bit later in this module. Now as we mentioned, we implement our job as a special kind of service and just like all services, it must appear in the manifest. In the manifest entry for a job service is mostly the same as the entry for any other service, but there's one key difference. Job services must be marked with a special permission. So the entry for our job service in the manifest must include the permission attribute, we must set it to the value android. permission. BIND_JOB_SERVICE. If we don't mark it with that permission, the JobScheduler will not run our job. So it's really important that we remember to do that. So in our next clip, we'll take the first step towards using the JobScheduler by adding a job implementation class to our app.

Creating a Job Implementation Class
Here we are at Android Studio. In this clip we're going to start the process of adding job service support to our app. We'll do that by creating the class that will serve as our job service's implementation component. Remember that the job service allows us to run background work and specify criteria for when that work can be run. So what we're going to do is add a feature to our app that allows users to perform and upload their notes data and we use the JobScheduler to perform the work of doing the upload. So now to help us out with the uploading work, I've added a class to our project named NoteUploader. The NoteUploader class simulates the work of uploading data from our content provider's notes table. So to use the NoteUploader class we first have to construct an instance of it and when constructing a new instance we pass in the context reference, which we then store within a field. Now once constructed, the NoteUploader class can be used to perform the upload. We perform the upload with the doUpload method. So let's just scroll down here a bit so we can see more of the doUpload method body. So if we look here at the doUpload method, we can see that it accepts a URI as a parameter. That URI can either be the URI of the whole notes table or it can be the URI of a specific row within the notes table. We then use that URI to issue the query. Now notice that we're not using a cursor loaded to perform the query. Rather we're using the ContentResolver to directly perform the query. And after we perform the query, we're ready to message out to Logcat indicating that we're starting to do our upload work and we include the URI of the data that we're uploading. And then from there we just loop through the cursor to simulate the process of uploading each row contained in the cursor. Now the way we simulate the upload process is by writing out the values of the current row to Logcat and then calling a method that puts the thread to sleep for a couple of seconds. By putting the thread to sleep, that just helps us simulate the relatively slow nature of sending data over a network. So if we look at it, this doUpload method is really a great candidate for being run by the JobScheduler. DoUpload directly queries the database and interacts with the network. So we want to be sure to run that work on a background thread and since we have to have a network connection in order to do the upload, we can specify network connectivity as part of our run criteria and then let the JobScheduler manage the details of assuring that a network connection exists before it starts the job. So to get us started with the JobScheduler, we'll add a class that'll serve as our job's implementation component and to do that we'll go to the Android Studio File menu. We'll choose New and then we'll go down and choose Service. The version of Android Studio that's available at the time and recording of this video doesn't have an option to directly create a job service class. So what we'll do instead is just choose a regular service. Now notice that I'm choosing the one that just say Service, not the one that says IntentService. So we'll select that. And we'll make our class' name NoteUploaderJobService and then here where it says Exported, I'm going to uncheck that. When a service is exported that means that other applications can access it. We don't want other applications to access our service. This service is just for the JobScheduler. So we'll go ahead and hit Enter to create the class. Now because we created a regular service, the class that was created inherits directly from the Service class. We want to change that to inherit from that JobService class. And then the onBind method was created for us. Let's go ahead and get rid of that. And then finally we need to override the onStartJob and onStopJob methods. So to do that I'll hit Alt+Enter. I'll choose Implement Methods. Then I'll just say OK. So that now gives us the skeleton of the class that will serve as our JobService class. Now remember that in order for this to be a JobService class, there's a permission that we have to provide inside of our manifest. So let's go over to the Project window and let's scroll up to the top. Now notice that in the Project window, I currently have the Android view selected. I'm at the manifests node. Go ahead and click on that. And I'm going to select AndroidManifest. And you'll notice there that there is a service element that has the name NoteUploaderJobService and so that's the entry in the manifest for our JobService class. Remember we said that job services have to have a special permission. So let's go ahead and add the android:permission attribute and we'll give it a value of android. permission. BIND_JOB_SERVICE. So now remember that we always want to include that permission on any job service because if we don't, the Android JobScheduler will not allow our job service to run. Alright, so with that, we have the starting point for our JobScheduler's implementation component in place. So now in our next clip we'll see how to specify the required information about a job and we'll also see how to schedule a job.

Job Information and Scheduling
Now the next thing we need to do is provide the information about our job and that's the purpose of our JobInfo class. The JobInfo class includes a number of things. It has the application-defined job ID and all that is is an integer value that identifies this job within your app. Information about the class that serves as our job's implementation component. The criteria for our job, and if we need to, we can also pass in job-specific data as part of the information. Now the JobInfo class is another scenario where we use the builder pattern. So we actually create our JobInfo instance by using JobInfo. Builder. So now of course, to use our JobInfo. Builder class we first have to construct it. The constructor accepts two parameters. It accepts the app-defined job ID as well as the information about our job's implementation component, and then once we construct the answers to the builder, we use set methods to begin associating additional information. So for example, we want to go ahead and associate our job's run criteria and it actually supports a pretty wide variety of job criteria and you can set as many of those criteria as you need, but you have to be sure to set at least one. If you try to submit a job that has no criteria associated with it, you will actually get an exception. So as I mentioned, there's a pretty wide variety of criteria that we can provide. For example, we can specify our network criteria. So we can say something as simple as the fact that our job just needs to have a network connection, or we can be more specific. We can specify whether it needs a metered or unmetered connection. Alright, a metered connection is a network connection where you generally pay for usage data; that's very commonly a cellular connection. An unmetered connection is one where you generally don't pay for usage and that's very commonly a Wi-Fi connection. Other criteria include power criteria. So I only want to run this job when the device is currently charging, alright? I only want to run this job as long as the battery is not low. We have device state criteria. Is the device currently in the idle state or is the device currently not low on storage? You might use that in a scenario where your job downloads a lot of data. Then we also have timing criteria. I don't want to start this job running for some period of time, maybe wait 30 seconds or a minute, or I want to run this job at some regular interval. I want to run it once every hour. And then you can even provide what's called an override deadline and this specifies the maximum amount of time you want the job to wait, and what this allows you to do is make sure your job runs even if the criteria isn't met. So basically the JobScheduler will watch for the criteria; if you've specified an override deadline, if you reach that deadline and the criteria is still not met, it'll then go ahead and run your job anyway. Now as I mentioned, in addition to the criteria, we can also specify job-defined data and that basically allows us to associated extras with the job information. So we can pass data into the job. And we do this using what's called a PersistableBundle and what that allows us to do is create a collection of name value pairs and what will happen then is when the job is run, the job can then get those extras and those are basically service parameters for our job. And then once we have all the information specified, we're ready to schedule the job. So we'll need to get a reference to the JobScheduler. Now the JobScheduler is a system service, which means the way we get a reference to it is by calling the getSystemService method of our current context and we specify the service named JOB_SCHEDULER_SERVICE and once we have that reference we're ready to schedule the job. So we'll call the schedule method and we'll pass in the JobInfo instance we created with the JobInfo. Builder class. And then from there the JobScheduler takes over. So the JobScheduler will monitor for our jobs criteria and then we'll run our job after that criteria is met, but it's important to understand that it doesn't run the job necessarily as soon as the criteria is met. Remember that the JobScheduler is responsible to manage system resources so it won't necessarily launch your job at the very instance your criteria is met. So in our next clip, let's get back into the code. We'll put together our job's information and then go ahead and schedule it.

Scheduling Your Job
Here we are back in Android Studio and what we want to do now is give the user the ability to initiate the notes upload work that will be handle by our NoteUploaderJobService. Now to do that, let's put together the information for our NoteUploaderJobService, then schedule that job with the JobScheduler. Now we're currently looking at the Options menu for our main activity and as you can see, I've added a new option labeled Upload notes. Now the ID for this option is action_upload_notes. So let's head over to our main activity class where we'll add the code to schedule the NotesUploaderJobService when the user selects our Upload notes option. Here we are in our main activity class' onOptionsItemSelected method. Remember that this is the method that gets called when the user makes a selection from the Options menu. Now I've already added the code to check for the action_upload_notes selection. When the user selects that option we call a method I've added named scheduleNoteUpload. It's here in scheduleNoteUpload where we'll add the code to schedule our job. Now to schedule our job we'll first need to build the information about the job and one of the most important pieces of information we need to provide is the description of the component that will handle the job. To provide that description we'll use a class called ComponentName. So let's declare a variable named ComponentName of type componentName. We'll create a new instance of ComponentName and now the first parameter we need to pass is the context. So we'll pass in our this reference and the second parameter is the class description of our JobServiceImplementation class. So we'll pass in NoteUploaderJobService. class and with that our componentName variable contains a description of the class that will serve as our JobService component. So now we're ready to begin building an instance of our JobInfo class. So let's declare a variable named JobInfo of type jobInfo. And we'll build the JobInfo instance using the JobInfo. Builder class. So let's create a new instance of JobInfo. Builder. So now the first parameter to the JobInfo. Builder constructor is an app-defined integer that identifies the job. So let's use the literal value 1 and then we'll change that literal value 1 to a constant and let's name that constant NOTE_UPLOADER_JOB_ID. And then for our second parameter we need the description of our JobService component. So we'll pass in our componentName variable. Now that we have the builder constructed, we can start specifying our job criteria. Now since our job uploads data, we'll need to have a network connection. So let's call the Builder method setRequiredNetworkType and for the network type we'll pass in the constant NETWORK_TYPE_ANY from the JobInfo class and this indicates that our job can use any available network. We could've been more specific about the network type if that was a requirement of our job. We could've said we wanted a metered or unmetered network if that was appropriate for our situation, but in our case, any network connection will do. And the network connection is really the only criteria we need to set for job and if we did have additional criteria, we would just continue making the appropriate method calls. But since the network is the only criteria our job has, we can go ahead and create our JobInfo instance by calling our builder's build method. And now that we have our JobInfo we can go ahead and schedule our job. So to do that we'll need to get a reference to the JobScheduler. So we'll declare a variable named JobScheduler of type JobScheduler. Remember that the JobScheduler is a system service so we access it by calling the getSystemService method and passing in the constant that identifies the JobScheduler service. And now that we have a reference to the JobScheduler we can schedule our job by calling the JobScheduler's schedule method and passing in our JobInfo variable. And with that, we provided all the necessary information to describe our job. We specified our required run criteria and we scheduled the job with the JobScheduler. So now in our next clip, we'll see how we can pass job-specific values into our job implementation service using JobInfo extras.

Passing Job-specific Data Values
Here we are back in Android Studio and what we want to do now is see how to pass job-specific data values to our JobImplementation class. Now we're currently looking at our NoteUploader class' doUpload method. Remember that this is the method that handles the details of doing the actual upload. The doUpload method accepts as a parameter the URI of the data that should be uploaded. So what we'll need to do is pass the URI of the desired data into our NoteUploaderJobService class when we schedule the job. The our NoteUploaderJobService class can then pass that URI to the NoteUploader class' doUpload method when it does the upload. So let's head over to our NoteUploaderJobService class. The way we pass values to a JobService class is as extras and just as with intent extras, we identify each extra using a string constant. So let's add a string constant to our NoteUploaderJobService class named EXTRA_DATA_URI and we'll give the constant an appropriate value that includes the string DATA_URI. And now that we have the constant defined, let's head over to our main activity class and we'll add the code to pass to the URI value as an extra to our job service. So now we're looking at our main activity class' scheduleNoteUpload method and remember this is where we provide the information for our job and then schedule our job. So now to associate the extras with our job information we're going to use a PersistableBundle class. So we'll create an instance of PersistableBundle and we'll assign it to a local variable named extras, and then once we have our PersistableBundle, we can add values to it using any of the available put methods. Now the value that we want to provide as an extra is the URI of our content provider's notes table, but the PersistableBundle class doesn't have a put method that accepts a URI value directly. So instead we'll pass the URI as a string. So we'll call it extras. putString. For the name of the extra we'll use the EXTRA_DATA_URI constant from our NoteUploaderJobService class. And then for the value we'll pass the content URI of our content provider's notes table converted to a string. So that gives us our Notes table CONTENT_URI stored within a persistable bundle. If we had other extras we wanted to pass to our job we'd put them into the same bundle, but in our case, we have just this one extra so we're ready to associate the extras with the information for our job. So to do that we'll call the setExtras method of the JobInfo. Builder class, passing in our extras local variable. So now when our job is run, the onStartJob method of our NoteUploaderJobService class will have access to the value we've placed into our job extras. So in our next clip, let's take a look at what's involved in implementing that onStartJob method.

Performing Job Work
As we talked about earlier in this module, the JobScheduler calls our job service class' onStartJob method to indicate that our work should begin. Now something that's unexpected though is that the JobScheduler calls the onStartJob method on the main application thread. So that means that we can't perform any long-running work directly within the onStartJob method, but now of course the reason we're using the JobScheduler is because we want to do some kind of background work. So what are we supposed to do? Well, what we have to do is dispatch that work over to a different thread and there's a variety of solutions we can use for that, but most commonly we'll use either AsyncTask or we'll use a handler that's running on a different thread. But now since we're running work on a different thread, we actually have to coordinate that work with the JobScheduler. We have to let the JobScheduler know what's going on. So we have to indicate to the JobScheduler that we did indeed start doing background work and we have to let the JobScheduler know when the work is done. So now the onStartJob return value is an important part of coordinating with the JobScheduler because the onStartJob return value is either a true or a false, and if we return true, that tells the JobScheduler that we did indeed start doing some kind of background work. And the way that we indicate that the work is done is by using the jobFinished method. Now the jobFinished method is a method in the JobService class that we call rather than being a method that we override. And as part of calling jobFinished we have the option of asking the JobScheduler to reschedule our work to run again later. Now as part of performing the job we may need to know a bit of the configuration and identification about that job and that's where the JobParameters class comes in. When the JobScheduler calls our onStartJob method, it passes this in a reference to the JobParameters class and included in the data inside the JobParameters class are the extras that were associated with the information for this job. So any job-specific data that was passed as extras on the JobInfo class is available to our onStartJob method through the JobParameters class. So in our next clip we'll start implementing our job's onStartJob method.

Launching Job Work in the Background
Here we are back in Android Studio. What we want to do now is add the code to our JobService class to perform the upload work. Now we're currently looking at our NoteUploaderJobService class' onStartJob method. Remember that this is the method that the JobScheduler calls to indicate that our job should start doing its work. Now we'll be using the NoteUploader class to handle the details of doing the upload. So let's declare a local variable named NoteUploader of type noteUploader. We'll go ahead and construct a new instance of NoteUploader. Now the NoteUploader constructor accepts the context as a parameter. Now just like with a regular service, a job service can be passed as the context. So we'll go ahead and pass our this reference. We'll be using the NoteUploader in a few different places within our JobService so let's go ahead and promote this variable up to a class level field. So now as we recall, the onStartJob method is called on the main application thread. So we can't do our upload work directly within onStartJob. Instead, we use AsyncTask to do the work. Now in order to do our background work, we'll need a reference to our job parameters so let's go ahead and make the first type parameter of AsyncTask, JobParameters. For the other two type parameters we'll just pass Void, then we'll go ahead and name our variable task and we'll start creating our AsyncTask instance. Now rather than manually create the AsyncTask implementation, we can just let Android Studio create it for us. So we'll do Ctrl+Space and I'll just hit Enter. Now that gives me the starting point of my AsyncTask implementation. Let's go ahead and make sure we add a semicolon to the end of our statement and now before we go much further, let's make one quick change to the code that was generated by Android Studio. Notice in the doInBackground method, the name of our parameter is params. Then notice also that the name of the onStartJob parameter is also params. Now from a Java language standpoint, both of these parameters having the same name is perfectly legal; however, it does create a situation that can be very confusing when working with the code. So let's change the name of the parameters in doInBackground and let's instead make it backgroundParams. So now our doInBackground method receives the JobParameters as a variable link parameter list. So let's declare a variable of type JobParameters named jobParams and we'll assign it the first element of backgroundParams. Now JobParameters contains a variety of configuration and identification data about the job and as part of that, JobParameters includes the PersistableBundle we associated with the JobInfo class' extras when scheduling the job. So to access those extras, we call jobParams. getExtras. Now getExtras gives us access to the whole PersistableBundle, but to access an individual value we call the appropriate get method. Now in our case we'll call getString and we'll pass in EXTRA_DATA_URI as the name of the value that we want to access, and then we'll assign the result of getString to a local string variable named stringDataUri. So now in order to use the URI's value, we need to convert that string back into a URI. So we'll pass stringDataUri to the Uri. parse method and then we'll assign the result of the parse method to a local variable of type Uri named dataUri and now that we have our dataUri, we can go ahead and do our upload work. So we'll use our mNoteUploader field from our JobService class and we'll call its doUpload method, passing in dataUri. Now with that, we have the code in place to do our actual upload work. So in our next clip we'll add the code to start running that work in the background and then coordinate the work with the JobScheduler.

Coordinating Background Work with the Job Scheduler
So here we are back in Android Studio. We're currently looking at the onStartJob method of our NoteUploaderJobService class and what we want to do in this clip is add the code that will actually start our background work running and coordinate that work with the JobScheduler. So the first thing we need to do is start the actual background work running. So to do that we'll us our AsyncTask's execute method. Now as part of the call to execute, we want to pass in the JobParameters reference that the onStartJob method received. So we'll add a call to our task variable's execute method and we'll pass in params. Now once we call the execute method, the onStartJob method will immediately return and as part of the return from onStartJob, we need to let the JobScheduler know that we've started work that will run in the background. So the way we do that is by having onStartJob return true. So by returning true, we're letting the JobScheduler know that our process needs to be allowed to keep running until our background work finishes. Now this of course means that we need to include code that tells the JobScheduler when the background work is finished. So to do that, we'll go back up into our AsyncTask's doInBackground method. And at the end of doInBackground we'll call the JobService class' jobFinished method. So the first parameter the job finished is the parameters for the job we're running. So we'll pass in our jobParams variable. The second parameter is a Boolean value. A value of true tells the JobScheduler to reschedule the job to run again later. A value of false indicates that our job is all done and does not need to be rescheduled. Now in our case our job is all done so we'll pass false. So with that, we have all the code in place to run our work on the background thread and then coordinate that work with the JobScheduler. So let's go ahead and run our application and see that everything works as we expect it to. So here we are with our app up and running. I've added some breakpoints to our code so we can see what actually happens. So we'll go into our Options menu. I'm going to use Upload Notes. You can see as soon as I choose that, we get breakpoint in Android Studio. So let's head back to Android Studio. So here in Android Studio you can see we've stopped in our main activity's scheduleNoteUpload method. The code is already run to put our Notes. CONTENT_URI into our PersistableBundle. We've created the component name for our service. So now we're about to build the jobInfo. We'll go ahead and release this. So then once we build the jobInfo, we're going to get a reference to our JobScheduler service and we're just about to call schedule. So let's go ahead and release it again. And you can see when I release it, we now find ourselves back in our NoteUploaderJobService's onStartJob method. So we've created our NoteUploader and we're about to call execute on our AsyncTask. So if I release it again, our AsyncTask went ahead and launched our work running on a background thread. If we look down at our Variables window, we can see that we've gotten our dataUri out of our extras. So we have the URI to do our upload. So let's go ahead and release this again. And now our upload works and should now be running on a background thread. So let's head over to the Android Monitor. If you look here in the Android Monitor, we can see that our upload code is actually running. So the JobScheduler took care of running our code just as we want it to and that code is running on a background thread, not interfering with the user interface. So now let's head back over to the Emulator. So here we are again with our app running in Emulator. And as you recall, when we set up our job, we specified that the network is requirement for our job to run. So let's see what happens if I disable the network and then try running the job. So we want to go up here, pull the top edge down. I'm going to put the Emulator into airplane mode. We'll return back to our application. Let's go over to our Options menu. Then let's choose Upload notes. You can see we had a breakpoint back in Android Studio. So let's switch back to Android Studio. So when we chose the Options menu our scheduleNoteUpload got called. We're about to build the JobInfo. Let's go ahead and release this and then we're going to go in and schedule the job so I'll release it again. Now notice in this case when I schedule the job, our onStartJob method inside of our NoteUploaderJobService class didn't start running. So let's head back to the Emulator. So here we are back at the Emulator. Let's go ahead and pull the top edge down and let's take the Emulator out of airplane mode. And when I take it out of airplane mode, the network again becomes available. Let's head back to Android Studio. So here in Android Studio we can see we've hit our breakpoint inside the onStartJob method of our NoteUploaderJobService class and we're about to call execute on our AsyncTask. So I'll go ahead and release this. We can see that our upload method is about to start running inside the doInBackground method of our AsyncTask. I'll go ahead and release it again and now our code is off and running. So as you can see, the JobScheduler not only takes care of running our code, but it takes care of enforcing the criteria we specified. Our job required the network so when the network wasn't there, it didn't allow the job to start running, but then when the network became available, it then allowed the job to run. So now in our next clip, let's see what happens in the scenario where our job is already started and the requirements we've specified become no longer available.

When Work Needs to Be Stopped
As we've talked about, one of the real powers of the JobScheduler is it allows us to associate run criteria with our job and then we'll only run our job when that criteria is met, but now just because our work is started, doesn't mean the work will have time to complete. In some cases, the work has to be stopped before it's complete. And that usually happens in the case where whatever criteria we specified is no longer being met and that's where the onStopJob comes in. The JobScheduler calls onStopJob to indicate that the work we're doing needs to stop. Now as part of handling onStopJob, we need to tell the JobScheduler whether we want our work rescheduled or not and we do that through the onStopJob return value. If we return back a true, that tells the JobScheduler that we do want to be rescheduled. If we return back false, that means we don't. Now when it comes to handling the stopping of our work, the details are going to be specific to each job. In many cases stopping the work might be something as simple as just exiting the loop you're using to walk through your work. In other cases, it might be more involved, but whatever the case, a key part of properly stopping our work is in this scenario we don't want to call jobFinished. Remember we call the jobFinished method to indicate that we're done doing whatever background work we want to do. Well, in the case where the system tells us to stop doing the work by calling onStopJob, in that scenario we do not want to call the jobFinished method. So to give us a better understanding of how all this works, in our next clip, we'll add the code to our job service to properly handle when the JobScheduler calls our onStopJob method.

Handling Work Stoppage
Here we are back in Android Studio and what we want to do now is add the code to properly stop our job when the JobScheduler calls our job's onStopJob method. Now we're currently looking at our NoteUploader class. Remember that this is a class that performs our actual upload work. Now notice here that our NoteUploader class includes a method named cancel. The method itself is pretty simple. It just sets the class' mCanceled field to true. Notice also that the class has a public method, isCanceled and that can be used to check the value of the mCanceled field. Let's just scroll down here a bit. We're now looking at the NoteUploader class' doUpload method. As we talked about earlier, the doUpload method loops for the results of a cursor to perform the upload work and as you can see, that while loop includes a check for the mCanceled field not being set to true. Setting mCanceled to true will cause the upload loop to exit. So with that being the case, we can use the NoteUploader class' cancel method to stop our upload work in the event that our job's onStopJob method is called. So let's head over to our NoteUploadJobService so we can add in the proper handling for our onStopJob method. Now let's look first here at our JobService class' onStartJob method. Now as you recall, we created an instance of NoteUploader and assigned it to a class named mNoteUploader and then its mNoteUploader that we used in our job's background thread to perform the upload. So now let's scroll down so that we can see the onStopJob method. So down here in our onStopJob method we can simply call mNoteUploader. cancel to cause the uploading work to stop. Now once we stop the work, we need to indicate to the JobScheduler whether we'd like the work rescheduled. If we have onStopJob return false, the work will not be rescheduled. If we return true, the work will be rescheduled. In our case, if the JobScheduler stops our job, we would like to have the work rescheduled so we'll return true. Now that takes care of actually stopping the work, but there is one more thing we want to be sure that we do. Up here in onStartJob we have the doInBackground method erasing task. When the background work completes normally we call the jobFinished method, but in the case where the JobScheduler tells our job to stop, we don't want to call jobFinished. So here where we call jobFinished, let's add an if statement to only call jobFinished if mNoteUploader isn't cancelled. So with that, we have all the code in place to properly handle the scenario so the JobScheduler indicates that our job should stop. So our next clip will just verify that everything works as we expect.

Verifying Work Stoppage Behavior
Here we are with our app up and running and what we want to do now is verify that our job service properly handles when the JobScheduler tells our job to stop. Now I've added some breakpoints to our code so we can better see what's going on. So let's go to our Options menu. Let's choose Upload notes. You can see in the background that we've hit a breakpoint. So let's switch back to Android Studio. So here in Android Studio we can see we're in our main activity class' scheduleNoteUpload method and we're just about to schedule our job so let's go ahead and release it. When I release it, we get to a breakpoint that's inside of our background code. This is our NoteUploaderJobService class and we're inside of our onStartJob's AsyncTask's doInBackground method. So that shows us that our background work is running. So I'll go ahead and release this. Then let's switch back to the Emulator. So here at the Emulator, let's go ahead and put it into airplane mode. You can see as soon as I do that, we hit a breakpoint in the background. Let's switch back to Android Studio. So you can see it's our onStopJob method, we're about to cancel the background work. So let's go ahead and release this. If we go to our Android Monitor, you'll notice there at the bottom there's a message showing that the upload was cancelled. Now let's head back to the Emulator. Now here on the Emulator, let's go ahead and take it out of airplane mode. And you see when I did that we hit a breakpoint again. So let's again switch back to Android Studio and you can see we're again inside of our NoteUploaderJobService class' onStartJob method where we called the doInBackground method of our AsyncTask. So you can see that the JobScheduler has restarted our job. So let's go ahead and release it. Let's head back to our Android Monitor and you can see there now that just below where we had our UPLOAD CANCELED message we have our UPLOAD START message and we're doing the upload again. So you can see that the code that we've added now properly handles when the JobScheduler tells our job to stop. When onStopJob is called, we stop doing the processing. We tell JobScheduler to please reschedule our job, and then when our criteria is again available, our job restarts. So now in our next clip, let's talk about the right way to choose whether to do our background work using the JobScheduler or using a regular Android service.

Choosing Between Services and JobScheduler
Throughout this module we've been looking at the JobScheduler. In the previous module we looked at Android Services and there's a lot of commonality between the kind of work we can do in the JobScheduler with Android Services. So I just want to take a moment to walk through how we choose between the two. Now if we look at Android Services, Android Services are really about application control or if you have any kind of criteria you need for your background work to run, as a service, you have to handle the details of making sure that criteria is being met, but services do give us a lot of control. They give us control over when our execution starts which means that when we use services, we can be sure that our service starts running immediately. Now the JobScheduler is much more about giving the system control. Now there's a real benefit to that because we can simply state whatever run criteria we have and the JobScheduler makes sure that criteria is met before it starts our work running because the JobScheduler controls execution so it decides when we start. So in general, the JobScheduler is going to provide a lot more benefits to us as developers than services do. The one caveat is that scenario where we need our work to start immediately and in that one situation, that's where a service is really a better choice. So what it really comes down to is that as developers we want to prefer the JobScheduler. The JobScheduler is going to work well for most scenarios that we encounter and using the JobScheduler allows Android to provide better management of system resources so it can minimize the impact of background work on the battery. It can minimize the impact of background work on the user experience and as time goes on, it gets even more important to prefer the job scheduler because starting in Android 8, which is API level 26, Android starts to put limits on the execution of services. Android starts limiting when services can run and for how long they can run. So as developers we're generally going to have a much better experience and provide our users with a better experience if we choose JobScheduler any time we can.

Summary
To wrap up, here are some of the key things you want to remember from this module. Now of course our focus throughout this module has been on the JobScheduler and the JobScheduler is a relatively new aspect of Android. It's available on Android devices running Android 5. 0 or newer and that is the majority of devices currently in use. Now the JobScheduler is becoming the preferred way to do background work. One of the main reasons for that is it allows the system to better manage resource usage and as part of that, it allows the system to help assure that the user has a better interactive experience. Now for us as developers, one of the main benefits of the job scheduler is that it manages the details of job criteria. So we can specify whatever criteria is required for our job to run, and the JobScheduler will make sure that criteria is met before it starts our job. Then once our job is up and running, if any of that criteria no longer becomes valid, then the JobScheduler will notify our job that it needs to stop. Now in order to schedule a job we have to provide information about that job, which is where the JobInfo class comes in. Now it includes a number of pieces of information. It includes an app-defined ID for our job. It specifies the component that will be used to perform the work of our job. It includes the criteria to run our job. And if our job needs it, we can also provide job-specific data. To create an instance of the JobInfo class we use the builder pattern. So in order to do that we use the JobInfo. Builder class. Now the component we create to implement our job is actually a special kind of service. So we create it by extending the JobService class. Now from the standpoint of the manifest, it looks very much like any other service with one key difference. It has to include the permission BIND_JOB_SERVICE. If we don't mark that entry with that permission, the JobScheduler will not run our job. Now to create our JobService class there are three important methods. The first one is onStartJob and that's a method that we override. The JobScheduler calls that method to indicate that our work should begin, but remember that onStartJob is called on the main application thread so we can't do any long-running work directly in onStartJob. We always want to dispatch that work off to a different thread. Then we have the onStopJob method. Again, that's a method that we override and that's called by the JobScheduler to indicate that our work should stop and normally what that means is one more piece of the criteria we've provided is no longer valid. And the third method is jobFinished and that's a method that we call and we call that method to indicate that our work is complete, but we don't want to call the method in the case where our work is stopping because the scheduler called onStopJob. We call jobFinished in the scenario where our background work finishes normally. Alright, that wraps up this module. In our next module we'll look at another type of Android component known as a broadcast receiver.

Working with Broadcast Receivers
Introduction
This is the Pluralsight course, Leveraging the Power of the Android Platform; my name is Jim Wilson. Oftentimes applications need to be informed when significant events of interest occur. These events may come from the Android system, or they may come from other applications. In this module we'll see how Android makes distributing and handling these sort of events possible. So we'll start out with a look at Android broadcasts. Then we'll see how our applications can send Android broadcasts, and then we'll see how to handle those broadcasts by implementing something known as a broadcast receiver. Now in many cases we want to create our broadcast receivers at runtime, so we'll learn how to do that using something called a context registered receiver, and then we'll finish up by seeing how the system can automatically launch or broadcast receivers using something known as a manifest declared receiver.

Broadcasts
In application development we have a very widely used pattern known as publish/subscribe and all publish/subscribe is is a commonly used model for distributing information about events of interest. So the idea is that we have a publisher that actually sends out that information about the event of interest. Then we have subscribers where we have one or more parties that are interested in being notified about that event of interest. Well in the Android platform we have what are called Android broadcasts. And broadcasts are a local device publish/subscribe model. In other words it's way to send events of interest around to applications running on a particular device. So we have the act of sending a broadcast and that's equivalent to publishing the information and then on the other side we have what's called a broadcast receiver and a broadcast receiver is the way that we receive that information of interest. So what we do that anyone who is interested in receiving that information has to implement a broadcast receiver and they become a subscriber to a particular broadcast. So broadcasts are very commonly sent by the system and there's a number of them available. There are things like a broadcast to tell applications that the device is entering airplane mode or it's leaving airplane mode. Broadcast to indicate that the device has started charging or stopped charging. Broadcast to indicate that the device just finished booting, in case your application needs to do something special right after the device boots. And there are quite a number of others available as well, but broadcasts are not limited to the system. Applications can also send broadcasts. So an application can actually define a custom broadcast and then that broadcast can be available to other applications running on the same device. Now let's look at our application. When our application is installed on device, we won't be the only application on that device. Right? There'll be at least one other app on there, but probably more than that. So there's some app on there, there's some other app on there, and yet another app on there. Who knows how many other apps might be on that same device. So let's say what we want to do in our application is add a feature so that when a user opens up our note activity, we want to send a broadcast out and what we want to do is notify other applications that the user has begun editing a note related to a particular course. So what we can do is send that broadcast and that broadcast becomes available to other applications on the same device, but those applications won't be able to receive that broadcast unless they implemented a broadcast receiver. So by appropriately implementing a broadcast receiver, they can now receive that broadcast and one of the real powers of broadcasts is we're not limited to one receiver. So if another app also implements an appropriate broadcast receiver, they will also receive that broadcast. So we have one publisher, but we can have multiple receivers. So now in our next clip, let's take a closer look at sending broadcasts.

Sending Broadcasts
So now when it comes to sending a broadcast, any application component can send a broadcast. The context class has a method sendBroadcast and calling that will send the broadcast, but now when we send the broadcast we have to send the information of interest and we do that by using an intent. And with that intent we're going to identify what kind of receivers should receive this broadcast as well as any additional information we want to provide with that broadcast. Now when we send broadcasts we commonly use what are called implicit intents. Now as you recall, there are two kinds of intents, explicit and implicit. Either one could be used with a broadcast, but we commonly use implicit intents. So now we haven't talked about this idea of an explicit intent versus an implicit intent since way back in the first course in the series. So let's have a quick refresher on the difference between the two. Now explicit intent is an intent that explicitly identifies a particular target and this is the kind of intent that we commonly use within our application because we specify a very particular component class. So when we want to show our note activity, we create an intent that has noteActivity. class. That's an explicit intent. We're explicitly identifying the specific activity we want to show, but there is also the implicit intent and in that case the target is not explicitly identified. Instead, the target is implied and we imply that target by specifying characteristics. Now as you'll recall, implicit intents support a number of different characteristics. The first one is the characteristic action and that's simply a string that identifies what action this intent represents. Now there are many standard actions available, for example, action view is a very commonly used standard action, but there are a number of others as well. Applications can also define their own actions. An action is the only characteristic that's required to appear in an implicit intent, but there are other characteristics. There is also the category characteristic and that just provides some kind of extended qualification and although categories are available, we don't tend to use those a lot when we're sending an intent. But then we also have the data characteristic and that's the URI of the data that's being acted upon. So if we were working on a particular kind of data we might put something like https://Pluralsight. com to indicate that this is an intent related to that URI, and along with the data, we can also have the mime type. So the mime type can be any of the common mime types or app specific. So it might be a common one like text/html or it might be an application-specific mime type like we've created with our content providers in an earlier course in this series. So these characteristics allow us to identify what kind of broadcast receivers should receive a particular broadcast. So let's think about how we would send a broadcast with our application. So again we have our note activity and we what we want to do is send a broadcast that indicates that the user has begun to edit a note related to a particular course. So of course we're going to have to create an intent and this is going to be an implicit intent. So as an implicit intent it has to at least have an action and we're going to use an application defined action COURSE_EVENT and as part of our intent we're also going to have some extras to provide additional information about that event. So one of the pieces of information we'll put in there is the COURSE_ID. So what we'll want to do is take the course that's associated with the note that was just opened and take that course ID and put that in as an extra in our intent. So in this case we'd have an extra COURSE_ID with a value android_intents. And then we also want to include a message in our intent and that message indicates more specifically what's going on. So our message in this case is going to be Editing Note. So when a user opens up our note activity we'll call sendBroadcast. We'll pass in an intent. That'll be an implicit intent and the only characteristic in it is the action COURSE_EVENT, but it'll also have extras in it to identify the COURSE_ID and a specific event that's going on, which in this case is Editing Note. So now in our next clip, let's go ahead and start implementing this behavior.

Broadcasting When the App Starts Editing
Here we are in Android Studio and what we want to do in this clip is add the code to have our note activity send out a broadcast and that broadcast will indicate that the user has started editing a note for a particular course. Now to help us out, I've added a new Java class to our project. That class is named CourseEventBroadcastHelper and it has one static method named sendEventBroadcast. SendEventBroadcast accepts three parameters. The first parameter is the context, the second parameter is the courseID, and the third parameter is a message. So now to send our broadcast we'll be using an implicit intent. Remember that implicit intents identify their target by providing characteristics and those characteristics must include an action. That action can be one of the built-in action strings or it can be app-defined action string. In our case we're going to use an app-defined action string. So here at the top of our class I've included a string constant to identify our action. The constant is ACTION_COURSE_EVENT and its value includes the literal COURSE_EVENT to qualify with our app's package name. So down here in sendEventBroadcast, we're going to need to create an intent instance. So let's start with a local variable named Intent of type intent. We'll construct a new instance of the Intent class and we'll pass in the constant for our action as the parameter to the intent constructor. So that takes care of creating the intent to include our course event action as a characteristic and in our case that action is the only characteristic our intent will need, but now we do need to include some extras in the intent to provide some additional information. To identify the extras we have two constants declared at the top of the class and those constants identify extras for the course ID and for the course message. So down here in sendEventBroadcast, we'll set our first extra. We'll call the Intent class' putExtra method, passing in our EXTRA_COURSE_ID constant. For the value we'll pass in the sendEventBroadcast method's COURSE_ID parameter. So now to set our other extra we'll again call the Intent class's putExtra method. This time we'll identify the extra with our EXTRA_COURSE_MESSAGE constant and for the value we'll pass in our sendEventBroadcast method's message parameter. Now that takes care of the intent, so now we're ready to send the broadcast. So to do that we use the sendEventBroadcast method's context parameter. Then we'll call the context class' sendBroadcast method and then we'll pass our intent to sendBroadcast and that's all there is to it. Our course event broadcast helper class' sendEventBroadcast method now takes care of the details of sending a broadcast about our app's course event. So now let's head over to our NoteActivity class and we'll add the code to call our sendEventBroadcast method. So here we are in our NoteActivity class and we're currently looking at its displayNote method and as you may recall, this is the method that takes care of displaying the contents of a note within our note activity. And this method is a good place for it to send out our course event broadcast. So here at the end of displayNote, let's call our course event broadcast helper classes sendEventBroadcast method. Now the first parameter to sendEventBroadcast is the context. So I'll pass in our NoteActivity class' this reference. The second parameter is the course ID. We're here at the top of displayNote, we have a local variable that's assigned the ID of the course being displayed. So as our second parameter to sendEventBroadcast, we'll pass in that coursed local variable, and then the last parameter is a message relating to the specific event so we'll pass the literal string, Editing Note, and with that, we have all the code in place to send out a broadcast any time a user starts editing a note. So now the next thing we want to understand is how to add support for receiving broadcasts. So in our next clip we'll start looking at broadcast receivers.

Broadcast Receivers
A broadcast receiver is a type of Android component much like a service or an activity as a type of an Android component, but now in the case of a broadcast receiver, their job is to handle broadcasts. Now the broadcast receiver does not present a UI. It's only purpose in life is doing the work specifically related to dealing with the receipt of a broadcast. Now the way we implement the broadcast receiver is pretty straightforward. We extend the BroadcastReceiver class and we're responsible to override one method, onReceive. Now the onReceive method is called when a broadcast appropriate for this broadcast receiver comes in. Now the onReceive method receives two parameters. The first parameter is the context and that's kind of an important point because in the case of components like activities or services, those components themselves are contexts. In the case of a broadcast receiver, a broadcast receiver is not itself context, but it does receive the appropriate context as a parameter to the onReceive method. Now the other parameter onReceive is the intent, so the broadcast receiver will actually receive the intent that was broadcast and then it can do the appropriate work based on the contents of that intent. But now when it comes to doing the work in the onReceive method, it's important to understand that the onReceive method is another method that runs in our application's main thread and because of that, we want to be sure that the work we do within the onReceive method is actually kept very short because as we've already learned, doing any long-running work on the main application thread can negatively impact other aspects of the application. So in our next clip, let's create a broadcast receiver that's appropriate for handling the broadcasts that our application sends.

Implementing a Broadcast Receiver
Here we are back in Android Studio and what we want to do now is create a broadcast receiver that can handle the broadcasts sent by our NoteKeeper app's NoteActivity class. Now we'll be adding that broadcast receiver to a new application that I've created. The new application is named CourseEvents and it's a relatively simple app that will display the information from the received broadcasts. Now we're currently looking at the layout resource for the CourseEvents app's only activity. The activity display area is filled with a list view and the information about the received broadcasts will be displayed within that list view. So let's head over to the activity's implementation class. Here we are in the activity class for the CourseEvents app. As we mentioned, all this activity is designed to do is display information from the broadcast we receive. Now here in the onCreate method, the activity does the initial work to be able to display that information. Notice that we create an array list, we assign it to a classable field named mCourseEvents. We associate that array list with an adaptor and assign the adaptor to a field named mCourseEventsAdapter and once the adapter is created, we get a reference to the list view and associate the array adaptor with that list view. So with that, the list view will display the values contained in the mCourseEvents array list. So let's create a broadcast receiver that will cooperate with this activity, display the information about the broadcasts sent by our NoteKeeper app's note activity. So we'll choose File, then we'll choose New and then within the New menu we'll choose Other, and then there within Other we'll choose Broadcast Receiver. We'll name our broadcast receiver CourseEventsReceiver. We'll leave both the Exported and Enabled options checked. So then we'll hit Enter to go ahead and create the class. So that creates our CourseEventsReceiver class. As expected, it extends BroadcastReceiver and it overrides the onReceive method. Then as we can see, the parameters passed on receive are the current context, along with the intent that was broadcast. So we'll use that intent to get the broadcast details. So to do that, let's add constants to our broadcast receiver for the intent's action and extras. Now these constants have the same exact values of the action and extra constants that were used when we sent the intent. So now we're ready to start working with the intent. So the first thing we'll want to do is go into our onReceive method and take out those comments and the line that throws the exception. So now the first thing I always like to do in the onReceive method is verify that the received intent conforms to the expected characteristics. So let's add an if statement that calls the equals method on our ACTION_COURSE_EVENT constant. We'll then call the intent's getAction method and pass that result into the equals method. So now as long as that matches, we can go ahead and start getting the extras from the intent. So let's declare a local string variable named courseId. We'll then call the intent's getString extra method, passing in our EXTRA_COURSE_ID constant. So that gives us our course ID. So now let's use the EXTRA_COURSE_MESSAGE constant to get that extra from the intent and we'll assign that result to a local string variable named COURSE_MESSAGE. So with that, the CourseEvents app now contains a broadcast receiver and that broadcast receiver can retrieve the broadcast information from the intent. So in our next clip, we'll add the code to have the broadcast receiver pass the broadcast information to the CourseEvents app's activity.

Passing Receiver Events to an Activity
Here we are back in Android Studio with the project for our CourseEvents app open. What we want to do now is add the code to have the broadcast receiver pass the broadcast information to the app's activity. We're currently looking at an interface declaration I've added to this app. The interface name is CourseEventsDisplayCallbacks and this is the interface that the broadcast receiver will use to pass information about the received broadcast. Now the interface has just one method, onEventReceived. My method accepts the courseId and course Message as parameters. So now with that interface in mind, let's head over to our activity class. Here we are at the activity class and notice that the activity class implements the CourseEventsDisplayCallbacks interface. So let's scroll down to where the activity implements the interface's onEventReceived method. Here we are at the onEventReceived method. Now the implementation of this method is pretty straightforward. It creates the display text by combining the courseId and message. It then adds the display text to the mCourseEvents array list. Once the display text is added to the array list, the code calls notifyDataSetChanged on the array adaptor. So basically, calling this method will add an item to the list view that displays the courseId and message that was received from the broadcast. Let's head over to the CourseEventsReceiver class and we'll add the code to call the onEventReceived method of the CourseEventsDisplayCallbacks interface whenever a broadcast is received. Here we are in the CourseEventsReceiver class. Now in order to use the CourseEventsDisplayCallbacks interface, we'll need a reference to it. So let's add a private field of type CourseEventsDisplayCallbacks and we'll name the field mCourseEventsDisplayCallbacks. So now let's go and add a setter for the field. So we'll right-click on it, we'll choose Generate, and then we'll choose Setter, and then we'll hit Enter and that takes care of generating a setter for our new field. So let's just scroll down here a little bit so we can see all of the onReceive method. So now here inside of onReceive, we'll add the code to take advantage of the interface. So now the first thing we'll want to do is make sure our field is non-null. So let's add an if to check that. Then as long as it isn't null we'll call the onEventReceived method and we'll pass in the courseId and message. So that gives us the code that will allow the receiver to call the interface method any time a broadcast is received. So now let's head over to our activity class and we'll add the code to create our receiver. We're now looking at the onCreate method of our activity class and at the end of the onCreate method is where we'll create the receiver instance. There will be a few steps involved so let's call the method we'll create named setupCourseEventReceiver. We'll go ahead and create the method so we'll say Alt+Enter, Enter, and we'll accept our return type. So the first thing we'll do in here is declare a local variable of type of CourseEventsReceiver and we'll name it courseEventsReceiver. We'll construct a new instance of CourseEventsReceiver and let's go ahead and promote that local variable up to be a field. And then once we create the instance, we'll call it setCourseEventsDisplayCallbacksMethod and then we'll pass in the activity's this reference. And with that we're just about done. We have the code to create the broadcast receiver and we have the code that will associate the activity as the callback when a broadcast is received. There's just one thing missing. We still need to tell Android that we'd like our broadcast receiver to receive the kind of broadcast being sent by our NoteKeeper app's note activity. In our next clip we'll see how to do that.

Context Registered Receivers
In order for Android to route broadcast to a broadcast receiver, that receiver has to be registered and we can register a receiver at runtime and when a receiver is registered at runtime, it's known as a context-registered receiver and when we register receivers at runtime what we first need to do is explicitly create an instance of our receiver and then we do the registration. The way we register that receiver is by calling the context class' registerReceiver method and when you register a receiver, you want to be sure that you unregister that receiver when you're done with it and you unregister receiver by using the context class' unregisterReceiver method. As part of registering a receiver, we have to specify what broadcasts we want that receiver to handle. In other words, we have to identify what intents that receive is interested in and we do that by using the IntentFilter class because remember those intents are going to have characteristics. So what the IntentFilter class lets us do is specify what intent characteristics we want to match on and any intent that matches those characteristics will be routed to our receiver. Now working with the IntentFilter class is pretty straightforward. We can specify some of the characteristics directly in the IntentFilter constructor. There are several overloads. There's an overload that accepts an action as part of the constructor. There's another overload that accepts an action and a mime type as part of the constructor, but the IntentFilter supports all the characteristics that we need to handle. So there are methods for all the characteristics that need to be matched. So there are methods to add actions to an IntentFilter. There are methods to add mime types to an IntentFilter. You can specify a URI or parts of a URI in the IntentFilter and if you need to, you can even specify categories as part of the IntentFilter. So once we register the receiver, any broadcast intents that match our IntentFilter will be routed to that receiver. So in our next clip, let's add the code to register our receiver to handle broadcasts that are sent by our NoteKeeper app's NoteActivity class.

Registering Your Broadcast Receiver
Here we are back in Android Studio and we currently have the CourseEvents project open. What we want to do now is add the code to register our broadcast receiver to handle broadcasts sent by the NoteKeeper app's NoteActivity class. Now we're currently looking at our CourseEventsReceiver class. Remember, we want this receiver to handle broadcasts that include the action identified by our constant ACTION_COURSE_EVENT. So what we'll need to do is create an intent filter that contains that action. So let's head over to our activity class and we'll add the code to register this receiver to handle broadcasts that contain that action. Here we are in the activity class and we're currently looking at the setupCourseEventReceiver method. Now this method already has the code in place to create the receiver. So now we want to go ahead and register it, but before we can register the receiver, we need to specify which broadcast intents we're interested in. So to do that, let's take a look at our local variable of type IntentFilter named IntentFilter. We'll create a new instance of IntentFilter and then we'll pass in the ACTION_COURSE_EVENT constant from our CourseEventsReceiver class as the action that we want to match. So that takes care of creating our IntentFilter. So now we're ready to register the receiver. So to do that we'll call the registerReceiver method. The first parameter is a reference to the broadcast receiver so we'll pass in our mCourseEventsReceiver field. The second parameter is the IntentFilter that specified that broadcast we want the receiver to handle. So we'll pass in our intentFilter variable. So with that when a broadcast is sent containing our specified action, the onReceive method of our CourseEventsReceiver class will get called. Now one last thing we want to be sure to do is unregister the receiver. Now since we called the code to register the receiver from the activity's onCreate method, we want to unregister the receiver from within the onDestroy method. So here within onDestroy we'll call unregisterReceiver and then we'll pass in our mCourseEventsReceiver field and with that, now we're all set. So let's run the code and verify that everything works as we expect. So here we are with our CourseEvents app up and running in the Emulator. It's already registered to receive the broadcast and I also have the NoteKeeper app up and running as well. So if we switch over to NoteKeeper, when I select this note, that'll display the note activity and we know that our note activity will then send the broadcast. Now I have a breakpoint in that code so we can see when it's about to send a broadcast. So we'll go ahead and select the note. You can see in the background that we've hit a breakpoint. Let me switch over to Android Studio. So now we're currently in the Android Studio instance for our NoteKeeper app. We've already displayed the note and that code is called our SendEventBroadcast method. So if I go ahead and release this, it should send that broadcast and our CourseEvents apps should then receive it. So let me go ahead and release this and you'll notice that when I did that, we switched to the instance of Android Studio that's associated with the CourseEvents app and you can see we're in our broadcast receiver's onReceive method. So we've actually received that broadcast. So now the first thing we do is check and make sure it's the action we expect, so let's step. It is the action we expect so we'll step through and get each of the extras. We'll then verify that we've got a valid reference to the callbacks and we do so I'll go ahead and release this. Switch back to the Emulator. So now here in the Emulator you can see that the note activity is currently displayed, but now if I switch over to CourseEvents, you can see that we actually have that message displayed, indicating the courseId, which is android_intents and then the course message which is Editing Note. So that shows us that we were successfully able to send a broadcast from one application and have a broadcast receiver in another application handle it. So now we have everything working just as we'd like. Our NoteKeeper app sends the broadcast any time the user opens a note in the note activity and our CourseEvents app registers for those broadcasts when its activity is started and it'll receive those broadcasts sent by the NoteKeeper app until the CourseEvents app's activity is destroyed. In our next clip we'll look at another way that broadcast receivers can handle broadcasts using what are known as manifest-declared receivers.

Manifest Declared Receivers
When we're working with context register receivers, our application code is responsible to create the receiver instance and then associate that receiver with the IntentFilter we want to use to handle our broadcasts, but manifest-declared receivers work a little differently. In the case of manifest-declared receivers, the system can create a receiver instance for us. Now as its name implies, manifest-declared receivers must appear in our application manifest and what happens in this scenario is the system will manage the lifecycle of our receiver. So when an appropriate broadcast comes in, the system will create a receiver instance for us and even if our application isn't running, the receiver will then take care of launching the process for our application and then creating the receiver within the newly launched process. But now the lifetime of the receiver is tied directly to the work that it's doing. So when the receiver returns back from the onReceive method, the system will then destroy that receiver instance. Manifest-declared receivers can work with both implicit and explicit intents. So in the case of implicit intents, we need to associate the receiver with the characteristics of the broadcast that we want to handle. We do that with an IntentFilter. So in this scenario we have to describe the IntentFilter using XML elements within the manifest. Now manifest-declared receivers handling implicit intents was a technique we used to use a great deal in older Android applications, but in newer applications, we don't use it so much anymore and the reason for that is that most of the scenarios that we used to use manifest-declared receivers with implicit intents can now be handled much more efficiently by the Android JobScheduler and it's really important that we take advantage of the capabilities of the job scheduler because starting in Android 8 there are only specific scenarios where we're allowed to use manifest-declared receives with implicit intents and most of the scenarios we used to use to those will instead use the job scheduler now. But manifest-declared receivers are still really important, particularly in the scenario of associating them with explicit intents. Remember, an explicit intent identifies a particular component that should handle the intent. So what that means is that we can actually have the receiver within our application be notified of a broadcast of interest even if our app isn't running. It's just that broadcast has to be directed specifically to our receiver and there are a number of scenarios where this is helpful. In our next module when we talk about the alarm manager, we'll see how we can take advantage of this capability.

Summary
To wrap up, here are the key things you want to remember from this module. Our focus in this module was on Android broadcasts and Android broadcasts are just a way to publish information and have other applications on the same device subscribe to that information. Now the system can send broadcasts, but our applications can also send broadcasts. Now the way we describe the information in our broadcast is with an intent and when the applications send broadcasts we tend to do that using implicit intents. Now in order for an application to handle a broadcast, we have to implement a broadcast receiver and the way we implement a broadcast receiver is by extending the BroadcastReceiver class and then to do the actual work we override the onReceive method. Now remember that the onReceive method runs on the main application thread so we want to be sure that any work we do in there is kept short. There are two parameters passed to the onReceive method. The first one is the context and that's an important point because it tells us that a broadcast receiver itself is not an instance of context, instead it has to be passed to context, and the other parameter is the intent that was broadcast. So that's how we access the information that was broadcast. Now one of the ways we can use broadcast receivers is what are known as context registered receivers and with context registered receivers our application code is responsible to create the instance of the receiver and that receiver is registered at runtime. Now when we register a receiver we have to specify what broadcast we want it to handle and we do that using an IntentFilter and with the IntentFilter we can identify the characteristics of the broadcast intent that we want to match. And we finished up with a look at manifest-declared receivers and with manifest-declared receivers, the system is responsible for managing the lifecycle of the receiver. It will create the receiver, it will take care of destroying the receiver when it returns back from the onReceive method. In the case of manifest-declared receivers, the system will take care of creating the process to host that receiver is that application's process isn't already running. Now when working with manifest-declared receivers, there are only very specific scenarios that we want to use them in association with an implicit intent. In general, we're going to use manifest-declared receivers in conjunction with explicit intents. Alright, that wraps up this module. In our next module we'll look at how we can schedule time-sensitive work using the Android Alarm Manager and as part of that discussion we'll also look a bit more at broadcast receivers.

Using Alarms to Schedule Time-sensitive Tasks
Introduction
Welcome to our next module, Using Alarms to Schedule Time-sensitive Tasks. This is the Pluralsight course, Leveraging the Power of the Android Platform. My name is Jim Wilson. Applications frequently need to schedule tasks to be performed at some later point in time and in many cases, those tasks need to occur even if the user is no longer engaged with the app. So in this module we'll see how the alarm manager allows us to reliably schedule just these sort of tasks. So we'll start out with a look at the way our application handles this Note Reminder feature and see how scheduling that reminder at some point in the future would actually improve that feature. We'll then take a look at the alarm manager and just how it works. We'll then see how to create a broadcast receiver that we're going to associate with the with the alarm manager. We'll see how to set the alarm, and then we'll finish up with seeing how to use the alarm manager to improve our application's Note Reminder feature to show that reminder at some point in the future.

The App's Note Reminders
Let's look at the way the Note Reminder feature currently works in our application. So the user goes to our note activity and on that note activity we have an option menu and one of the options on the menu is Set reminder. Well currently what happens is when the user taps on that option we immediately display the notification that's meant to serve as a reminder for the user to review that note again later and displaying that notification immediately is probably not the best way to provide a reminder to the user. A better solution would be that when the user taps on the menu option we kick off some kind of timing delay so that we can then show the user that notification when the timer expires. So maybe an hour later we could show them the notification so then it would serve as a meaningful reminder for the user to go back and review the note. Now throughout this course we've talked about a few different features that provide timing delays and let's see if any of them are useful for this scenario we're looking at now. Now one option would be to use a handler because we know a handler allows us to post something with a delay and then that code will run later and that seems like it might be a good choice to display our notification, but the only problem is for a handler to work, our application must be currently running. So if the user is switched away from our application and the system kills our application process, the handler wouldn't have a chance to run. Now another possible solution might be the job scheduler because we know that jobs that are scheduled with the job scheduler can run even if our application isn't currently running and the job scheduler even allows us to specify a latency to delay the start of the job, but the problem we have there is that that latency is a minimum latency. So the actual latency of running the code may be longer than we actually would like it to be. So in our next clip, let's start looking at the alarm manager and see if provides the kind of behavior that we need.

Alarm Manager
The alarm manager gives us the ability to provide reliable timing behavior and one of the key aspects of the alarm manager is this timing behavior is not tied to the lifetime of our application. Now in order to use the alarm manager we of course need to get a reference to it. The alarm manager is a system service so we're going to use the Context. getSystemService method to get a reference to the alarm manager and we identify that service with the ALARM_SERVICE constant. So now even though the alarm manager allows us to provide timing behavior outside the lifetime of our application, it allows us to run application-defined work because when we work with the alarm manager we pass it a pending intent. So we can use that pending intent to actually execute our work when that timer expires and when we work with the alarm manager, we're very commonly using it in conjunction with broadcast receivers and in many of those cases we'll use it with manifest-declared broadcast receiver because remember, in the case of a manifest-declared broadcast receiver, the system can take care of creating the instance of the broadcast receiver, letting that broadcast receiver do its work, and then the system will clean up the receiver when that work is done. So in our next clip, let's add a broadcast receiver to our application that we can use to display our notification.

Creating the Note Reminder Receiver
Here we are back in Android Studio and what we want to do now is create a broadcast receiver that we can use to display a Note Reminder notification. So to get us started, let's look at the way the NoteActivity class currently displays the notification. Now we're currently looking at the NoteActivity class' showReminderNotification method. This is the method that we call when the user selects the Set Reminder menu option. Now the way this method currently works is that it gets the values of each of the note fields and the corresponding views within the activity. Those values are then passed to the notify method of the NoteReminderNotification class that we created earlier in the series. It's that notify method that handles the details of displaying the notification. Well, if we place that call to notify within a broadcast receiver, we can use the alarm manager to run that receiver at some point in the future and that would in turn display the notification. So let's create a new broadcast receiver. So I'll choose File, then I'll choose New. We'll head down there to where it says Other, and then here under Other we'll choose Broadcast Receiver. We'll name our broadcast receiver NoteReminderReceiver and then we'll hit Enter to create the new broadcast receiver. So that gives us our broadcast receiver. So now in order to display the notification we'll need extras for the values we want to display. So let's add three constants that will identify the extras we need. One for note title, one for note text, and one for note ID. So that gives us the constants for our extras. So now we can start implementing the receiver's onReceive method. So let's first clear out the generated code within the method. Now as you recall, the onReceive method receives the broadcast intent as parameter. So let's use that intent to access our three extras and assign them to local variables. So now with those values stored in variables, we're ready to display the notification. So we'll call the NoteReminderNotification class' notify method. The first parameter to the notify method is the context. So what we can do is take the context that was passed in the onReceive and then pass that to notify. And then we can pass in the variables for the note title, note text, and note ID. And so now with that, we have a broadcast receiver that can display our NoteReminderNotification. So now let's head back over to our NoteActivity class and we'll start adding the code to take advantage of the alarm manager. Here we are back in the NoteActivity class' showReminderNotification method. The first thing we'll do is remove the call to the notify method of the NoteReminderNotification class and now we can start adding the code that will use the alarm manager to schedule a call to our broadcast receiver and we know that the alarm manager uses a pending intent to run the desired work. In our case that's our broadcast receiver, but to create a pending intent, we first need to create the intent. So let's declare a local variable named Intent of type intent and then we'll create a new instance of the intent class, passing in our activity's this reference and our NoteReminderReceiver class info. So now with our intent created, we'll go ahead and add the extras for or note title, note text, and note ID. So now our intent's all set so we can go ahead and create the pending intent. So we'll first declare our variable named PendingIntent of type pendingIntent. We're creating a pending intent for our broadcast receiver so we'll call pendingIntent. getBroadcast. The first parameter to get broadcast is the context so we'll pass in our activity's this reference. For the second parameter we can pass 0 and for the third parameter we'll pass our intent variable, and the last parameter is a flag. So we'll pass in the PendingIntent class' FLAG_UPDATE_CURRENT constant, and by using that flag we're telling Android to replace any previously created pending intents for that receiver with the one we just created. So now that we have our pending intent, we're ready to get a reference to the alarm manager. So let's declare a local variable named AlarmManager of type alarmManager and then we'll call getSystemService passing in the ALARM_SERVICE constant. So with that we have a reference to the alarm manager and we have our pending intent. So the next question is, how do we use the alarm manager to schedule our pending intent, and that's what we'll see in the next clip.

Setting the Alarm
When we're using the alarm manager we're of course going to want to set an alarm and most commonly we just want to set a single alarm. So we do that using the set method and by using the set method the operation will be performed one time at the specified time, but there are scenarios where we want to set a repeating alarm. So we do that by using the setRepeating method and in that case we provide the time that we want the operation first performed and then we provide an interval that we want to have the operation repeated. So for example, I want it to start an hour from now and then repeat every 15 minutes after that. Now when setting a repeating alarm, the alarm will continue firing until we cancel it. So we do that using the AlarmManager's cancel method. So now when we're setting an alarm, there are two different types of time we can use to set the alarm and each of them is intended for a specific scenario. The one we tend to use most often is what's known as elapsed real time and this is useful when we want to set a relative time. I want to set a time like an hour from now or 2 hours from now, that sort of thing and when we're setting elapsed real time, we'll generally do that in conjunction with the elapsedRealTime method of the class system clock. So we'll use the elapsedRealTime method to get the current time and then we add the specified amount of time to that value to indicate when we want the alarm to fire. But now in addition to elapsed real time we also have what's called real time clock and that's useful when we want to set an absolute time. So I want to set an alarm for 2 o'clock today or set an alarm for 4 o'clock today. So now we're using real time clock, we'll often do that in conjunction with the Calendar class. So we'll use the Calendar class to create the alarm time and then we take the value created by the counter class and then pass that into our alarm manager. So now when we're setting an alarm, we have to consider the case of the device being asleep when it's time for the alarm to go off. So what we have to decide is, well if the device is asleep, can the alarm just go ahead and wait until the device wakes up for another reason, and most commonly that is what we want to do. We want to let the device just stay asleep and whenever the device wakes up for another reason, then at that time go ahead and perform the operation associated with the alarm, but we can have the alarm manager wake up the device. So if the device is asleep, the alarm manager will wake up the device to perform the actual operation, but we want to be very careful about doing that because if we wake up the device too often, we can really undermine the battery management and burn the battery out much more quickly than we need to. So whenever we're setting an alarm, there are two things we need to indicate. What type of time we want to use, and how we want the alarm to behave if the device is sleep and there are constants for each of these situations. So in the case of elapsed real time, if we specify the time, passing in the constant ELAPSED_REALTIME, the time will of course be elapsed real time and it will not wake up the device if it's asleep when it's time for the alarm to go off. Instead the alarm will wait until the device wakes up for another reason, but if we pass in the constant ELAPSED_REALTIME_WAKEUP, we're specifying the time using elapsed real time and if the device is asleep when it's time for the alarm to go off, the alarm manager will wake up the device. And then for a real time clock, we pass in the constant RTC, it says we're using the real time clock, but we don't want the alarm manager to wake up the device if it's asleep when it's time for the alarm. Instead we want it to wait until the device wakes up for another reason and then we have RTC_WAKEUP, which says that we're using real time clock and if the device is asleep when it's time for the alarm to go off, that we want the alarm manager to wake up the device. Alright, so in the next clip we'll add the code to our application to set an alarm.

Displaying the Note Reminder with the Alarm Manager
Here we are back in Android Studio and what we want to do now is add the code to use the alarm manager to help us display a Note Reminder notification at some time in the future. So we're back here in the showReminderNotification method of our NoteActivity class. We've already created a pending intent that can start to broadcast receiver that displays our notification and we already have a reference to the alarm manager, so we're just about ready to set the alarm. Now the first thing we need to do though is calculate the time we want to set the alarm to and let's say that we want to set the alarm for 1 hour from now. So that means we're setting a relative time. So we'll start out by calling SystemClock. elapsedRealtime. ElapsedRealtime gives us the number of milliseconds that have passed since the device was last rebooted. So for the purposes of setting a relative alarm time, we can treat the value returned back from elapsed real time as if it's our current time expressed in milliseconds. So let's assign its result to a local variable of type along named currentTimeInMilliseconds. So now let's declare a local variable named ONE_HOUR. Now we know that there are 60 minutes in an hour and we also know that there are 60 seconds in a minute, and then finally, there are 1000 milliseconds in a second. So now our variable ONE_HOUR has a value that represents 1 hour in milliseconds. So now let's declare another local variable and we'll name this one alarmTime and we'll assign it to sum of currentTimeInMilliseconds plus ONE_HOUR. So that'll give us a value that represents a time one hour into the future and we'll use that value to set our alarm, and to do that we'll call the alarmManager. set method. Now the type of time we're using the set the alarm is elapsed real time. So let's pass in the alarmManager class' ELAPSED_REALTIME constant. Then we'll pass in our alarmTime and our pendingIntent. So now we have the code in place to have the alarm manager execute our broadcast receiver one hour after the user selects the setReminder menu option, but now notice there's no place in our code where we ever create an instance of NoteReminderReceiver. We're instead relying on the system to do that. So what that means then is that we want our NoteReminderReceiver class to behave as a manifest-declared receiver. So let's head over to the manifest and verify that NoteReminderReceiver does indeed appear in our manifest. So now we're looking at our application's manifest file and here near the bottom we have this receiver element and the value of the name attribute is NoteReminderReceiver. So that tells us that NoteReminderReceiver is a manifest-declared receiver. So now that we've verified that, let's head back over to our NoteActivity class. So now we're back here in the ShowReminderNotification method of our NoteActivity class. Now as you may recall from the end of the previous module, we mentioned that in most cases we want to use manifest-declared receivers in conjunction with explicit intents. So let's see if that's what we're doing in this case. Now when we use the alarm manager to start our receiver, we provide a pending intent. That pending intent wraps an intent and notice that when we create the intent that we're explicitly specifying the NoteReminderReceiver class. So this is an explicit intent. So what we're doing with the AlarmManager and our NoteReminderReceiver class is indeed a case of using explicit intent to allow the system to start a manifest-declared receiver and that's exactly what we wanted to do. Now before we run our app, let's make one small change to the way we're setting the alarm. Now we're currently setting the alarm for one hour in the future and waiting one hour for that notification to display would be an awfully long demo, so let's declare another variable named TEN_SECONDS and we'll set it to 10 times 1000. So that gives us 10 seconds expressed in milliseconds. So let's change the value we assigned to alarm time to use 10 seconds rather than one hour. And so now for the purposes of our demo, our notification will appear 10 seconds after we select the SetReminder menu option. And so with that we should be all set. So let's go ahead and run our app and verify that everything behaves as we expect. So here we are with our application up and running. So now I've added a breakpoint to our NoteReminderReceiver class so we can see when our alarm actually fires. So to try things out let's go ahead and select the note. Let's go up to our Options menu. We'll select Set reminder. We'll exit the NoteActivity. We'll minimize our application. And now you can see in the background that we've hit our breakpoint. So let's switch back to Android Studio. So here we are inside the onReceive method of our NoteReminderReceiver class and we're just about to display the notification. So let's go ahead and release this. We'll switch back to our Emulator and you can see here in our Emulator that we have a notification icon displayed at the top. So let's go ahead and expand our notification drawer. So there's our notification displaying the correct note title and note text. Now let's go ahead and select the notification and it properly displays our note activity. So our app is working just as we'd like it to. When the user selects the SetReminder menu option, we set the alarm manager which then causes our broadcast receiver to execute when the alarm fires, and our broadcast receiver in turn displays our notification.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that we have the alarm manager and the alarm manager provides reliable timing behavior and the timing behavior is not tied to the lifetime of our application. Now we'll use the alarm manager to launch application-defined work and we specify that work using a pending intent, but most commonly that pending intent will reference a broadcast receiver. But now remember, when we set alarms, we can specify the time in two different ways. Most commonly we use what's known as elapsed real time and we use that when we're setting an alarm for a time that's relative to the current time, but in cases where we want to set an alarm for an absolute time, for that scenario we use a time known as real time clock. But no matter which way we set the time, we have to remember that the device might be asleep at the time our alarm goes off. Now we have the option to force the device to wake up at the time the alarm is supposed to fire, but in general we don't want to do that because that can be really detrimental to the battery. So what we generally prefer to do is just allow the device to stay asleep and then when the device wakes up for another reason, the alarm manager will take care of running our work at that time. Alright, that wraps up this module and it wraps up this course. We have just one more course to go and in that course we'll dig into the features of Android that enable us to create apps that engage with the broadest audience we can. So we'll look at things like supporting multiple languages and cultures, adapting to device differences, and incorporating support for users with accessibility needs. We'll also look at features like deep linking and app widgets that allow our app to engage more fully with the user's overall experience.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Advanced
Rating
4.9 stars with 18 raters(18)
My rating
null stars

Duration
3h 3m
Released
7 Nov 2017
Share course