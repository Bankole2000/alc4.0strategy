Angular Forms
by Mark Zamoyta

This course will cover the fundamentals of working with forms in Angular. You'll learn how to create forms, style them, and use data binding and validation. You'll be able to post a form to a server, and work with third-party form controls.

Forms are a vital part of web applications, since they're the primary way you collect data from your users. You want your forms to look good and offer a simple, smooth experience. In this course, Angular Forms, you'll learn how to create template-driven forms using the Angular framework. First, you'll discover how to style them, use data binding and then validate your forms. Next, you'll explore observables and posting your forms to a server. Finally, you'll learn about third-party form controls which offer much more functionality than standard HTML5. By the end of this course, you'll be able to build great looking forms that offer your users a simple way to input any data.

Course author
Author: Mark Zamoyta	
Mark Zamoyta
Mark started in the developer world over 25 years ago. He began his career with a Bachelor of Science in Computer Science from St. Johns University. After spending 10 years on Wall Street working...

Course info
Level
Beginner
Rating
4.6 stars with 39 raters(39)
My rating
null stars

Duration
2h 3m
Released
2 Apr 2019
Share course

Course Overview
Course Overview
Hello everyone. My name is Mark Zamoyta, and welcome to my course, Angular Forms. I've been designing and coding software for over 30 years, and I'm currently a software developer in the Tampa Bay area. One of the most important features of our Angular applications is how to collect information from our users. Whether we simply need to collect an email address for a newsletter or have a complex purchasing process for our users, forms are needed to gather information. This course will show you how to build and work with template driven forms to gather data from your users. Some of the major topics that we will cover include building a form from scratch using HTML5 controls, data binding the form to an object in code, validating our form data, sending our form data to a server, and looking at third-party form controls to enhance our forms. By the end of this course you'll know how to create functional and great looking forms for your Angular applications. You'll know how to style your forms with Bootstrap 4 and integrate third-party controls from the NGX bootstrap library. This course focuses on Angular's template-driven forms. From here you should feel comfortable diving into Angular's more complex form technology in a course titled, Angular Reactive Forms. I hope you'll join me on this journey to learn how forms work in Angular with the Angular Forms course at Pluralsight.

Introduction
Introduction and Course Overview
Welcome to my course, Angular Forms. My name is Mark Zamoyta. The user of forms is the primary way we collect information from our application users. A form can be as simple as collecting a user's email address for a newsletter or a little bit more complex, collecting a username and password, all the way up to having a very complex form, as in a shopping cart application or some registration form that an application user could spend a great deal of time filling out. Our forms need to help the user by giving validation feedback at the right time, and our forms need to look good. Let's take a look at what this course on Angular Forms has to offer. In this introductory module we'll start off by looking at Angular's two forms technologies. One is template-driven forms and the other is reactive forms. This course mainly deals with template-driven forms. Next, we'll install the Angular CLI, and that'll let us quickly get up and running with an Angular application. I'll be using Visual Studio Code as the editor of choice, but of course, you're free to use whatever editor you'd like. The next course module will cover form basics. We'll create a simple user settings form, and we'll cover a wide variety of controls. Here you can see a text input, a checkbox, radio buttons, a select with options, and a send button. So we'll see how to build forms and style them with Bootstrap. Next, we're interested in data binding. We have our form, but we need to store its data somewhere in Angular. We can store it in a regular JavaScript object or a TypeScript class, but mainly we'll be using an interface. The interface gives us type information about the different fields on the form and let's us store that data in a JavaScript object. We'll see how to get the form to two-way data bind to our object. In the next course module we'll look at form validation. HTML5 has many validation attributes and we'll take a look at those, those who work hand in hand with Angular, and we'll see how to apply styling and show error messages to a field when there's some kind of error. Next, we'll look at posting the form using HTTP. Form data is usually posted to a server and stored in some sort of data store, such as a database. We need to make sure that the form is validated first, and we need to handle the posting properly. Posting to a server is an asynchronous event, so we'll see how to work with RxJS observables in handling the posting and showing error messages when needed. Finally, we'll take a look at some third-party controls that have to do with forms. We'll quickly look at PrimeNG, which is a good source of form controls, and we'll look at Angular Material, which has its own set of form controls, but most of this module will be spent on NGX Bootstrap. This library offers many controls that we can use to standardize the look and feel of some form components across browsers. We'll be looking at checkbox buttons, a field to select a date, and another field to select a range of dates. We'll see a control to enter some time of day, and finally, we'll look at a rating control to rate something with a certain number of stars. By the end of this course you'll be able to create functional and good looking forms using the template-driven form technology in Angular. In the next clip we'll take a look at template-driven forms and see how they differ from Angular's other forms technology, a more complex technology called reactive forms.

Angular's Form Technologies
Let's take a look at Angular's two form technologies, template-driven forms and reactive forms. This course will focus on template-driven forms. And when we create a component in Angular it has a view. The view is called a template. Usually that's put in the HTML file that goes along with the component. So we build our form using HTML5 tags directly in the template. Unit testing against the template driven form is rather difficult because you need to unit test against the DOM. The technologies to do this are rather slow and sometimes inaccurate. With differences among browsers, it could be very difficult to unit test forms like this. Reactive forms also use a components template. You use HTML5 tags just as you do with template driven forms. The big difference, though, is that you also in TypeScript code create a form model. The form model is a list of fields that match up with the template, so there is some duplicate coding involved. If you change the template you need to change the form model, and you've got to keep these two in sync. It's extra work, but the big benefit is that you can unit test against the form model. So there is a way to create very fast unit tests, however, you still need to be very careful in that the template and the form model need to be in sync. And it's much easier to test validation in the form model. If you absolutely need unit testing, reactive forms may be a better choice, but if all you need is for Angular to process regular HTML5 type forms you can quickly get things done with template-driven forms, and template-driven forms is what we're covering in this course. In the next clip we'll take a look at the Angular CLI and build our demo project that we'll use throughout the course.

Creating the Demo Application
Let's create an Angular application that we'll use throughout this course. We'll build on it module by module. There are a few things we need to get set up first. One of the first things you'll need is node. You can get that at nodejs.org. If you've already been working in Angular this is most likely installed on your system. I am on Windows, but you could always click the Other Downloads button and get access to builds for Mac or Linux. And, of course, you'll need some kind of text editor. I'll be using Visual Studio Code, which is available here at code.visualstudio .com. This editor works great with Angular. It has IntelliSense, which makes code completion easy, but also it helps out tremendously with imports, and you'll see that when I need to start adding ES6 import statements. Again, I'm on Windows, but there are builds for Mac OS and Linux as well. So with node and an editor installed the next thing we need is the Angular CLI. As it says here, this is a command line interface for Angular. I'll bump up the font a bit. By executing these four lines of code a full Angular application will get built for you and served up using webpack. Whenever I use an Angular CLI command in this course I'll explain it. They're simple commands, but if you want more detailed information on the Angular CLI here's a course by John Papa, Angular CLI, and you can get more detailed information here. So let's go to a command line and enter these four lines of code and get our Angular application up and running. I can check my version of the CLI by executing ng, which is the main command for the Angular CLI, --version. And you can see that I'm running on version 7.1 .4, but if the CLI isn't installed you can execute npm, which is the Node Package Manager command, install -g for global @angular/cli. I won't be executing this because they already have it installed. And once the Angular CLI is installed we can go ahead and create a new application. We execute ng new to create a new application, and we give it a name. I'll call it ps-demo. Would you like to add Angular routing? Not for this course, so I'll type no. Which version of CSS would you like to use? I'll keep it on plain CSS, and after some time our application will be built. You see some warnings about line feeds and end of line markers, but that's fine. So everything was created in a folder called ps-demo. Let's go there, cd ps-demo. If we take a look at the files we have everything to run our Angular application. The Angular CLI works with webpack, which has its own dev server. The way to run that and see this application is to execute ng serve, and it compiled successfully. Looking at the message here, you can see that we need to look at localhost calling 4200. So let's take a look. And here's our Angular application. So what we'll be doing is we'll be cutting out this template, and we'll be working with a form in this course. Looking at Visual Studio Code, I'll go to File, Open Folder. And I'm in the ps-demo folder, and I'll select this folder. And here's our application. If we look in src, app, here's our main app module, and the component that we saw, app.component. If you want to look at the markup that we saw in the browser it's in the app.component .html file. One of the features I like about Visual Studio Code, it has an integrated command line. If you go to View, Terminal, and you can see the shortcut is Ctrl back tick on Windows. Here's our terminal and I'll bump up the font. I used Ctrl+ to make the font size bigger, but usually I like serving the Angular application directly from here. So I'll go back to the command prompt and shut it down. I'll type Ctrl+C, and I'll terminate the batch job, and back to Visual Studio Code. We'll run our dev server from here, ng serve. So our development web server is running, and in order to execute more Angular CLI commands we need to hit the plus button right here. We can easily switch back and forth between terminals by using the dropdown. Here's our server, and here's where we can execute new Angular CLI commands while the server's running. So we're all set up and ready to go. In the next course module we'll create our first form.

Form Basics in Angular
Introduction
Welcome to this module titled Form Basics in Angular. My name is Mark Zamoyta. We have an Angular project all set up, and the next thing we need to do is add a form to it. We'll be doing that in this module. Let's see what we'll cover exactly. We'll start off by importing Angular's form module into our application's root module. Without this Angular won't know anything about our forms. Next, we'll go ahead and create a form component. Visually, an Angular application is made up of components with templates, and that's how we'll create our form, as a simple component in Angular. We'll be using Bootstrap for styling our form, so we'll need to add that to our project, and we'll style a simple input text field. Then we'll continue by styling checkboxes and radios. We'll cover select controls and their options, and we'll add a few more controls to our forms. We'll add things such as dates, colors, a password field, and we'll see how we can add any type of HTML5 input control to our form. So let's get started and look at Angular's FormsModule.

Angular's FormsModule
Angular applications are made up of many different types of modules. Typically you'll have your app module and some feature modules, but Angular itself is made up of modules which give certain functionality. For template driven forms we need Angular's FormsModule. Here we can see how to add the FormsModule to our app. We import FormsModule from @angular/forms, and this is built directly into Angular. There's no need to download a separate package. So once we have access to FormsModule we use it in our imports metadata. We already have a BrowserModule and we just list FormsModule after that. Once we do this Angular will be aware of our forms and any template where we're using a form tag Angular will be aware of it, and take over some control of the form. Let's add FormsModule to the application we made in the last course module. I'll go to the src, app folder, and here we have our app.module .ts file. I'll add the import, and here's our import section right here. We'll just list out FormsModule. So now we're all set up and Angular will be aware of any forms we create. In the next clip we'll create our first form.

Creating a Form Component
Let's create a form, and the way we'll do that is we'll create a regular Angular component that will hold the form. Using the Angular CLI, let's go ahead and go to View, Terminal to open up a terminal. The shortcut here in Windows is Ctrl back tick. And to use the CLI we'll execute ng, g for generate, c for component, and the type of form we'll be building is a user settings form, so we'll call it user-settings-form. So let's open up the folder that was created for that, and we'll take a look at the TypeScript file. The selector is app-user-settings-form, and we'll go with that. I'll copy it, and we'll go to our app.component .html file, and we'll delete what's in here. We don't need the boilerplate that came with the Angular CLI. And we'll add our form right here. I'll make sure everything's saved, and let's kick off our webpack dev server. Again, I'll go to the terminal and I'll execute ng serve. This'll serve up our application so that we can view it in the browser. And we'll have a live refresh. The application will automatically refresh in the browser. And I navigated to localhost:4200 and we get our message, user-settings-form works. So everything is up and running fine. Let's create our form. We'll go to our user-settings- form.component .html file, and we'll create a simple form right here. So here's the simple form where we input a name, and there's an OK button. I saved it, so let's view it in the browser. And there's our first form. It doesn't do much yet, but throughout this course we'll be building it up. If we used Chrome's dev tools to inspect the page you can see our form tag right here, and Angular is controlling it. It placed a novalidate attribute for us, so it shut down the browser's validation and we'll be covering form validation later in the course. We'll also be covering these classes that you see, nguntouched, ngpristine, and ngvalid. Those give us a clue to the status of the form and how to style it. So we're up and running with our first form, and Angular is in control. In the next clip we'll take a look at loading Bootstrap into our application so that we can style our forms, have them look better, and look consistent across the various browsers.

Using Bootstrap for Styling
We want our forms to look good, and we want them to look consistent across browsers. Let's take a look at using Bootstrap to accomplish this. Let's head to their web page. I'm at getbootstrap.com. Now we don't need to download Bootstrap here. We're going to be doing that with npm. The reason why we're at this site is because we might need the documentation. So I'll click on the Documentation menu item, and I'll click on Components, and Forms. This page shows all the Bootstrap classes that we can use to style forms. If we scroll down a bit we can see a simple form here and the HTML for it. So we'll be using this as a reference throughout this course module. Let's go to Visual Studio Code. I'll open up the terminal window, and you can see here that we're still running our development environment, so I'll hit the plus button to create a new terminal. And let's install Bootstrap. We'll execute npm install --save bootstrap. So Bootstrap has been installed into our node_modules folder, and the way we include that in our Angular project is through the Settings file, angular.json. It's right here. We can see a styles property right here, and this is where our application level styles are kept in styles.css. So let's go ahead and add Bootstrap right before this. So we're looking in node_modules, and we'll get the minified version of Bootstrap, bootstrap.min .css. And because we're placing it here in angular.json it'll automatically get picked up in our single page app. So I'll make sure to save this and let's go to our form. It's in user-settings- form.component .html. And just to make sure Bootstrap is working, let's add a few Bootstrap classes to the button. We'll add btn and btn-primary. I'll save this. Before we'll be able to see this there's one other thing we need to do. Because we changed angular.json we need to shut down our developer server and restart it. Changes to that file aren't always picked up immediately. So I'll go back to our first window here in the console, and I'll hit Ctrl+C to terminate the batch job, and I'll simply hit the up arrow button and execute ng serve again. And let's take a look at the browser. So we're getting our Bootstrap styled button. Bootstrap is being included in our single page application, which right now is just this form, so I'll go to the form and I'll add some more Bootstrap formatting. So the first thing we do is we wrap the form in a container. This is a Bootstrap class that will give the form some margins, pull it away from the edge of the browser. Then we'll set a header, an h2 header for user settings, and then we have our form. Normally when we have controls on a form in Bootstrap we wrap each control in a class called form-group, and that's what gives it the Bootstrap styling. We create a label called Name, and the input field. The label has a for attribute, so name here links up with the id name right here on the input. So clicking on the label will give focus to this input control. We'll also give the input control a name, simply called name for now, and we'll give it a class of form-control for Bootstrap formatting. And because we have a label, we don't need the placeholder. You can leave it in or take it out as you see fit. So I'll save this. Here's our form styled with Bootstrap. In the next clip we'll take a look at using checkboxes and radio buttons and adding those to our form.

Checkboxes and Radios
So far our form has a simple text input control, but we want to build it out a bit. Let's add some checkboxes and radios. I'm in the Forms section at getbootstrap.com, and on the right side menu I'll click on Checkboxes. Here we can see a simple checkbox. We won't be concerned with the disabled one right now, but here's the code for the enabled one. You'll notice that the input tag comes first, followed by the label. That's the opposite of our text input control. Also, everything is wrapped in a class of form-check. So let's use this Bootstrap styling and add a checkbox to our form. I'll add it right after this form group for the name field, and I'll go ahead and paste in the code. So here's the markup for our checkbox. Everything's wrapped in a class of form-check, and we have our input control and our label. Again, the label links up with the input by using the for attribute. EmailOffers must be the ID of the input field. Looking at the form, we need a little bit of spacing around the checkbox. It's too close to the Send button, so we can also add a class of form-group that's a Bootstrap class. So now the spacing is better, and our checkbox works. Let's go back to the Bootstrap documentation and we'll take a look at radio buttons. If we scroll down a bit, here we see radio buttons. We won't be concerned with the disabled one for now, and the way these radio buttons get grouped together is by the name attribute right here. Even though they're different input controls of type radio they need the same name, and that's what makes them work together as a group. And like with the checkboxes, the input tag comes first, followed by the label tag. So I'll add some radio buttons into our form. Here are the three radios that I added. I added a header for the section called User Interface Style, and this will just let the user select a light interface, medium, or a dark interface. So for these three radios they all have a name of interface style and values of light medium, and dark. So for now we just want to get the styling right, and throughout the rest of this course we'll be using this with Angular, but for now our radio buttons are working fine. We can select just one interface style. In the next clip we'll add a select control with options.

Select and Options
Let's add an HTML select control with its options to our form. We'll start off by looking at the Bootstrap documentation. I'm here at the Forms page, and I'll just click on Form controls, and here we see a Example select with options. It's a dropdown that has just five options, one through five. Looking at the code for this, it's straightforward. We have a form group, and a label, and the select tag. So let's add one to our form. I'll add it at the bottom right after our radio buttons, and I'll go ahead and paste in the markup. So here's our form-group wrapper. We have our label of Subscription Type, and our select control. It has three options for the subscription type. It can be monthly, annual, or lifetime. And I'll save this to make sure it shows up in our form, and it's working fine. In the rest of this course we're going to be working a lot with selects. It's pretty rare to have all your options hard-coded here. Usually you want to get these options out of some kind of data service, ultimately from your database, and also it's likely they would come in asynchronously. So later in the course we'll see how we work with the ng for directive in Angular, and also how to work with an async pipe to handle the asynchronous nature of it all, but for now our interface is set up and the styling is good. In the next clip we'll take a look at a few more controls that we could add to our form.

Other Form Controls
Let's add some more controls to our form. We have the whole range of HTML controls available to us, so let's start off by looking at a text area. After our select and options I'll add a text area right here. I'll paste it in. So we have our form-group wrapper again, and we have a label and a textarea tag. One of the attributes of the textarea is rows. Here you can see that it's set to three, which allows for three visible rows at a time. I'll save this, and here's our notes field, and the text area is used for entering multiple lines of text, and if you go beyond the three lines of text you'll see the scrollbar show up. Another common control that you might work with is a password field. I'll paste one in here. So we have our form-group, a label for password, and I'll just adjust this so we can see it fully, and our password form-control. And it doesn't make sense to add a password here in our form, but we just want to make sure it works. When we type in characters our password is hidden as these are typed. So that's working. And to get this password field we simply set the type to password. And we have access to the full range of HTML controls. Let's take a look at a few. First of all, I'll copy this and just create a general control that we can work with. So I'll just set all the values to testing for now, and let's use Visual Studio Code's IntelliSense to see what types we have available. One common type of control is a date control right here. I'll save this. Looking at our form, I'll scroll down and here's our date field. If you hit the dropdown you'll get a pop-up of a calendar. So we can select the date that way or we can use these up and down arrows to change the month, day, and year, and hit X to clear it out. The problem with a control like this is that all the visual elements of this control belong to Chrome. Different browsers will have different interfaces. Later on in this course we'll take a look at using ng bootstrap, which is a third- party library that'll give us a consistent look and feel to some of our controls, such as selecting dates and times, but just keep in mind if you try this on different browsers you'll get a different user experience. Looking back at our markup, let's take a look at a type of color. Now the user can select the color. Again, the interface is going to be different for every browser, but on Chrome it works really well, and looking at more input types we, of course, can have an email type, which would make sure the email format was valid. We can have a number type and so on. But throughout the rest of this course we're going to be working with a simple form, so let's clean this up a bit. We don't need this testing code, and we don't need our password field. And this User Interface Style is a little bit too dark. Let's see where that comes from. It's an h5 tag, so we can just make that a paragraph to make it look similar to the rest of the form. I'll save the form, and that looks good. So we have a simple form to work with throughout the rest of the course. Let's wrap up this module with a summary.

Summary
We started off this module by looking at Angular's FormsModule. We saw that it needed to be imported into app's root module. This let Angular take control of any form we had in any template, and without this Angular wouldn't know anything about the form. Next, we created a form component. It's just like any other Angular component, but it has a form tag in it, and we used Bootstrap for styling. We needed to add the npm package for Bootstrap, and we needed to add the CSS file to angular.json in the styles section. We added checkboxes and radios to our form, and we added a select control and its options to the form, and we wrapped things up by looking at other form controls. We worked with dates, colors, passwords, and we saw how we could use any input type to add a control to our form. So we have a good looking form now styled with Bootstrap, and Angular is aware of it, but Angular still doesn't know about the data content behind all these controls. In the next course module we'll take a look at how we can get Angular to work with the data behind the controls.

Data Binding in Angular Forms
Introduction
This module is titled Data Binding in Angular Forms. My name is Mark Zamoyta. When working with a form, we need to keep track of all the data entered into the form, and we may need to populate that form initially with some object. This object is called a model or a data model, and we use the technique of data binding to get this data into the form and back out of the form as the user modifies it or hits the save button. We'll start off by seeing how Angular has an ngForm directive that it automatically adds to every form in the project. We got this functionality by importing the forms module earlier in the course. We'll see how we can work with the ngModel directive. This is used on fields in the form, and it helps build up our model, the object used to hold our data. We'll see how we can create a custom data model. This is usually something stored in permanent storage, either on the browser side, or usually we get it from a data service over the web. And then once we have that object, to use it in the form, we use two-way data binding. We'll see how this works, and we'll see the syntax for it. And finally we'll see how to make a copy of the data that we're working with, so that we don't run into data corruption issues when working with a form. In the next clip, we'll take a look at using ngForm.

Using NgForm
When we imported our forms module into our application, we let Angular take over our forms by using an ngForm directive. This directive gives us valuable information about our forms, and let's see how we use it. So here's a form tag and an ngForm directive, but this is internal to Angular. We never had to add this ourselves. When Angular parses a template, it'll look for the form tag and add this directive. Angular will see this directive and create an instance of ngForm. Let's see how we access that. The first thing we need to do is create a template reference variable. We use the # symbol and a variable name. So #form is the variable, and we assign the string ngForm to the variable. And even though that looks like a string here, we will get access to the ngForm object. Now before we see how to use this, let's take a quick look at the Angular documentation on ngForm. We'll see the benefit that it gives us. I'm here at angular.io, and I'll search for ngForm. And we'll click on the directive NgForm. There's a lot of detailed information on the NgForm directive here, but if we scroll down a bit, we can see that ngForm is inherited from something called AbstractControlDirective, and let's take a look at some of these properties. We have a value property, which will give us the value of each field in our form, that's very important. And we also have lots of status variables, whether the form is valid or invalid, disabled or enabled, and so on. And we'll cover validation in detail in the next course module, but this is a great reference to find out what information is available on your form. Also if we scroll back up, we can see that one of the properties on ngForm is submitted. This tells us if the user has attempted to submit the form, and there's also ngSubmit, which is an EventEmitter. We might want to execute some custom code when the Submit button is pressed, and we can do it with ngSubmit, but again we'll take a look at that later in the course. For now, let's just see how we can get an instance of ngForm. And we get it right here in our #form variable. And to use this variable, we can go ahead and place it in the markup. We'll use the double-curly braces for interpolation, and form here refers to the #form template reference variable. That is our ngForm, and we're going to pipe that object through the JSON filter. That'll just format it nicely for us so that we can see the properties and values accurately. So let's go to our form project in Visual Studio Code, and we'll work with this form template reference variable. Here's our template for the user-settings-form. We'll take a look at the form tag, and let's add the template reference variable here. We'll call it form, and we'll set it to the string lowercase ng capital F form. So now #form is a variable that we can use anywhere within this template. Let's use it on the bottom of the form, and we'll just print it out. We use double-curly braces for interpolation, and we specify form. I'll save it, and we'll get the refresh, and we can see that we're getting a JavaScript object. So to make this more useful, we'll pipe it through the JSON filter. I'll save it, and now we can see all the properties belonging to our ngForm instance. It starts off with submitted being false, and you can take a look at any property you'd like, but mostly we're going to be looking at the value property, which is right here on the very bottom, and that's being sent to an empty object. And even if we go into our form and enter some values, we can still see that value isn't being updated, and the reason for this is that we need to let Angular know about each one of these fields in our form. We use the ngModel directive for that, and we'll take a look at it in the next clip.

NgModel
When building a form, the ngModel directive gets placed on every field that we want Angular to know about. NgModel helps us build up that values object that we saw in the last clip. Let's go to our template. Here's our first input control, and we'll simply add ngModel. Angular is aware of ngModel when we imported the forms module from @angular/forms, so we don't need to do anything else to set up this directive. Now another thing I want to do is go to where we're printing out our form, and instead of showing the entire form, let's just show form.value. That's the object that Angular will create for us based on all the form controls. I'll save this. And because we added ngModule to the name field, we get the name property with an empty value. Let's type in the name field. I typed Milton, and now that's showing up in the object. And just to make that a little bit bigger, I'll wrap it in an h3 tag. And there we go. And that's the only field showing up right now because name is the only field with an ngModel directive. And if you're wondering where this property name comes from, it comes from the attribute name on the input tag right here. So I'll go through the entire form, and I'll add our ngModel directive to each field. And we don't need to add it to the button. I'll save it, and I'll enter a name Milton again, that shows up. I'll click on the Email Special Offers checkbox, and we can see that Email Offers toggles from true to false, so that's good. I'll select the user interface style of light, that shows up, medium, and dark. I'll set the Subscription Type to Lifetime, and we can see that that's not working, there's not even a property in our object for subscription type, which means we need a name attribute. Looking at our select tag, we can see a class attribute, an id attribute, our ngModel, so let's add a name. We'll call it subscriptionType like the id. I'll save it, and now we get a subscriptionType in our object. I'll set that to Annual, and it shows up fine. In our Notes, I'll just type some notes, and that shows up in our object as well. I'll just quickly fill in this form again, and here we can see the full object that Angular has created for us just by using the ngModel directive. Now this is only beneficial if you don't need to populate the form at the start. Remember when our forms started, everything was blank, and that won't always be the case in the forms that you build. Sometimes you'll want to populate the form before the user even sees it. But in the case where you have a simple form where you're collecting information for the first time, we can use this mechanism within Angular. Again looking at it, we can look at our form template reference variable and access the value object. In the next clip, we'll take a look at working with a data model. That way we'll keep track of an object in our TypeScript class that we can use to populate the form before the user even sees it. And then as the user changes the form, the object will get updated, and we'll no longer need form.value. So let's see how we can create a data model for the form.

Creating a Data Model
In the last clip, we saw how Angular would build an object for us as we filled out our form, but in many other cases, we're already going to have an object that we want to use to populate the form, and then we'll want that object to change as the form gets filled out or saved. So let's take a look at how we can create a data model. Here in the project, I'll open up the src folder, and the app folder, and let's create a new folder called data. Eventually we'll be putting a data service in here, but for now, we can either create a class whose properties would hold the values for the form, or we could just create an interface that'll tell us the shape of the model, and I'll do that. I'll name it user-settings. And we have to make sure we give it a .ts extension to be picked up as a TypeScript file. And we'll create our interface, and we'll name it UserSettings. And of course we're going to want to export this, so I'll do that now. And for each field in our form, I'll add a property, name is a string, emailOffers is boolean, true or false, interfaceStyle is a string, subscriptionType is a string, and notes is a string. So I'll save the interface, and I'll go to the user-settings-form, and open up the TypeScript file. So in our user-settings-form component, we'll create a variable called userSettings. And the type is userSettings, the interface we just created. And we're going to need to import that. We'll import userSettings from the module data/user-settings, the one we just created. Now one thing we could do is we use IntelliSense to populate each value. I'll hit Ctrl+Space, and you can see the five properties of the interface right here, but they're in alphabetical order. I like to keep the properties in the order that they appear in the form, so I'll just add them that way. Start with name, again it's Ctrl+Space to pull up IntelliSense, emailOffers, interfaceStyle is lowercase dark, subscriptionType is Annual, and finally notes. So now we have a valid object that conforms to the userSettings interface, and we want to use this as our data model. So everything's all set up. We need to take this model and use it to populate the form, then as the form changes, we want to make sure that this model gets updated. So we'll use two-way data binding for that. We'll see how to accomplish this in the next clip.

Two-way Data Binding
So we have a model all set up with our data, now we want to establish two-way data binding between that model and the form. Here's our TypeScript file for user-settings- form.component, and remember that the properties name is UserSettings. So I'll go to the template, and the way we accomplish two-way data binding, we'll start off by looking at this input here for name, but we establish two-way data binding by using the banana in a box syntax. It looks like this. So we surround ngModel with parentheses, and then we surround all of that with the square brackets, and that establishes two-way data binding. You'll see this referred to as banana in a box syntax. The parentheses form somewhat of a banana, and the square brackets are like a box. And we need to give this a value. We want to bind to userSettings.name, and you can even see here that we are getting IntelliSense. Visual Studio Code is looking out into the TypeScript file to give us some support. I'll just make more room here, and here we see the full data binding syntax. When this form is shown, the input control will get its value from userSettings.name. And as the user changes the value of this name field, it'll get placed back into userSettings.name, and one way we can prove this is by looking at userSettings. So instead of looking at form.value, we'll take a look at userSettings. I'll save this, and I'll pull up the browser. And you can see that when the browser refreshes, we get the name Milton. Looking at user-settings- form.component, our TypeScript file, we can see that name is set to Milton to start off with. So our two-way data binding is working in one direction, and if I change this name, we can see that it changes in our object. So two-way data binding is working. So what I'll do next is I'll go through this entire form, and I'll change all of the ngModel directives to use our two-way data binding syntax. So I made all the changes, let's just quickly look through them. We're binding to userSettings.name, .emailOffers, for the radios, we're binding to interfaceStyle, and that will have the same binding for each one of these radio buttons. We're binding to userSettings.subscriptionType for our drop-down, and for notes, we're biding to userSettings.notes. I'll make sure the page is refreshed, and we can see that our form is getting populated as soon as it displays for the user. The name, checkbox, radio buttons, our drop-down, and our notes are all populated properly. And if we go through and change everything, I'll uncheck the Special Offers, I'll set the Interface to Light, I'll set the Subscription Type to Lifetime, and here are some more notes. When we look at our object, we can see that all of our changes do get updated in our object. So now we know how to create our data model. We're not doing much with it yet. We'll see how to work with it and send it to a server later in the course. But for now, the data is there, and it is getting populated correctly, and our form is being shown property initially. So there's just one common problem I want to go over, which could lead to data corruption and some other problems if you're not aware of it, and we'll see that in the next clip.

Copying Form Data
There's a certain scenario you need to be aware of when working with forms and data in Angular. What happens if a user starts filling out a form and then either presses a Cancel button or a back button? You want to make sure that the changes that they made are cancelled. So one way to do that is to make sure that you're always working with a copy of the original form data. Let's see one way to accomplish this. I'll go to our components.ts file, and you can see that we're using userSettings here, but let's rename this to originalUserSettings. Now as the user modifies the form, we don't want to change the originalUserSettings, we want to go ahead and do what we're doing now, which is modify plain old userSettings. So we need to make a copy of originalUserSettings. One way to do that is with the spread operator. The spread operator, the … right here will take originalUserSettings, and copy each property into userSettings. This is a simple way to create a copy of the top-level properties. If you wanted to make a deep copy of objects within objects, you would need to use some other method. Angular doesn't give you a method for this, but you could use Lodash. Lodash has a function called deep clone that'll fully copy an object. But for our purposes here on this flat object, this technique works fine. So I'll save this, and as I change Notes, we can see that the userSettings do change. However, if we show our originalUserSettings, I'll save this, and I'll modify Notes, you see that Notes did not change. So now we just have to make sure that when the user clicks Send or OK, that we copy the data back into originalUserSettings. And again this is a way to protect our data in case the user presses the back button in our application, or a Cancel button, or somehow exits out of the form without saving it. And we'll take a detailed look at saving form data and using this technique later in the course. So let's wrap up this course module with a summary.

Summary
In this module, we took a look at ngForm. This is the directive that gives us access to all of Angular's information about the form. The way we use it is we set a template reference variable. So on our form tag, we have # variable name, here's it's #form, and we set it to the literal string ngForm. Then we can use this template reference variable within the template to access its information. Next we looked at ngModel. This is a directive that gets placed on the fields within a form. It builds up the form.value object. And the name attribute is required. The name ends up being the keyname in a key value pair in our form.value object. And if we don't want Angular to create our data model for us, we can use our own data model. In our case we used an interface to shape the data model, but you can go ahead and use a class if you want to use a class. And once we had our data model, we used two-way data binding to link up the model with the form. We saw how to use the banana in a box syntax on ngModel, and that achieved our two-way data binding. We just needed to specify the variable to bind to. And we wrapped up this module by seeing how we can copy form data. Very often a user is going to either navigate out of a form, or hit the Cancel button, or navigate to some other aspect in the application, and when this happens, we want to make sure that our original data is not corrupted. So our form works with a copy of the data. The way we accomplish this is we use the spread syntax in JavaScript. This made a simple copy of originalObject and stored it in object. If you wanted a deep copy, you would use a utility such as Lodash with its deep clone function. In the next course module, we'll take a look at validating all this data. We'll see the mechanisms that Angular has in place to see that required fields are filled in and other validation checks do take place. So I'll see you in the next course module.

Form Validation
Introduction
Hi, my name is Mark Zamoyta, and this module is titled Form Validation. We want to give our users feedback on what's happening with the form, so we're going to see how to add error messages to the form when required fields are missing, when a regular expression doesn't match up, and other criteria. We'll start off by looking at HTML5 field validation. Angular works hand in hand with this. Many attributes already exist, such as making a field required, specifying a regular expression, a minlength, a maxlength, and that kind of validation. Next we'll look at Angular CSS classes for validation. Angular applies classes to input fields, as well as the whole form. And in addition to classes, each field also has ngModel properties that we can use for validation. We'll take a look at those. And once we're familiar with those CSS classes and ngModel properties, we'll be able to style our form when validation errors pop up. Next we'll look at submitting forms. It's a common design pattern not to show any form errors until the user attempts to submit the form, so we'll see how to work with that. And finally we'll look at handling regular HTML5 events with Angular. We're concerned with the form control events, such as blur, which occurs when a field loses focus because we can take action at that point. So let's start off and look at HTML5 field validation.

HTML5 Field Validation
Before we look at Angular validating fields and validating forms, we need to take a look at HTML5, and see how field validation gets done there. In HTML5, validation is done mainly with attributes on each field. The required attribute marks the input as required. You'll get an error if there's nothing entered in that field. And pattern lets you specify a regular expression for the input control. And these are the two main attributes that get used. We also have some length-based attributes and value-based attributes. Minlength and maxlength let you control the size of the string that gets input, and min and max work with numbers, that would be an input with a type of number. And it's the minimum number that's accepted and the maximum number that would be accepted. Let's go to Visual Studio Code, and we'll take a look at our form and work with these attributes. I'm in our user-settings- form.component, and the reason I'm here is I just want to null out all these values. I'll do this quickly. So we're starting with an empty form, everything's nulled out. And let's go to our markup. I'm in user-settings- form.component .html, that's our template. Earlier in the course, I showed how Angular turns off the native browser validation, but we want to add that back in for now. So I'll go to the form tag, and we can add an Angular directive here. NgNativeValidate will allow the browser to validate each control now. Angular turns this off by default because there are many differences between the various browsers on how errors get displayed and how they get corrected when a form is posted, but for this clip, it's okay to turn it back on. We'll turn it off in future clips. So looking at our first input tag for name, let's just give it a required attribute. I'll save this, and we'll see how the browser deals with it. So in the Name field, this is now required, but if I Tab out of it and attempt to post the form by hitting the Send button, you'll see we get the Google error message, and this is unique to Google. Other browsers don't show the error this way, and that error disappears on its own after a bit of time. Let's look at pattern. This lets us specify a regular expression that can be used as a pattern to validate the field. I'm not going to go into regular expressions in detail, so let's just create a simple one. Let's say the pattern needs to begin with the letter B, and then any character can follow, and it can be any number of those characters. So the B means that B needs to match, capital B, and then. *, that will match any characters you type. So I'll save this, and I'll type a name that does not begin with a B, I'll post it, and we get our error, Please match the requested format. If we began with a B, and posted it, everything's fine, we get no error. Other attributes that we saw for validation are the maxlength and minlength. So let's say the minlength is 3, I'll save this, and let's type a Name with 2 characters, Ab. I'll post it, and we get an error, Please length this text to 3 characters or more. And likewise for maxlength, let's set a maxlength of 3, and as I type in the field here, it doesn't let me enter more than 3 characters. So the browser is taking over control of that one, I didn't have to post the form. And finally we saw min and max, but those are for number fields. So let's specify a type of number, and we'll say min for the minimum value would be 3, and the max, let's just say 300. I'll save it. So if we enter a value of 2, we get an error, Value must be greater than or equal to 3. And if we enter 2000, Value must be less than or equal to 300. But if we enter 200 and post it, everything's good, we get no error. So those are the validation attributes that are native to HTML5, and Angular works with those as well. When we build forms in Angular, we use those same attributes. One of the benefits of Angular is that it adds CSS classes to these input fields for validation, and we'll take a look at that in the next clip.

CSS Classes for Validation
Angular is constantly looking at our form and adding classes to our input text. This is done for validation purposes. Let's take a look at the six classes that Angular works with. Ng-untouched and ng-touched, a field starts off with the ng-untouched class, and when we visit a field, we may or may not modify it, but at some point we're going to blur that field, blur means lose focus. That could mean Tabbing off of the field or hitting the Post button to cause the field to lose focus. When that happens, the ng-untouched class is removed, and ng-touched is placed on the field. We also have a pair of ng-pristine and ng-dirty. A field's value starts off as pristine, and that means unmodified, and as soon as you modify that field, ng-pristine is removed and ng-dirty is placed on that field. So a class of ng-dirty just means that the field has been modified. And finally we have ng-valid and ng-invalid. As we saw in the previous clip, if we're using some kind of attribute for a validation, Angular will know about that, and as long as the field is valid, ng-valid will be a class name on that input field. If the value is invalid, we get ng-invalid instead. Let's see these in action. Here's the template for our form, and let's work with the first input field again. I'll remove the validation from the last clip, and let's make this required. And let's also add a template reference variable, so we can take a look at which classes are placed on this tag. We can simply type a variable name starting with the # symbol, and let's just call it #classTest. We just want to test and see what classes are being applied. And right underneath this field, let's create an H3 tag, and we'll show our classes. We'll reference classTest, and the property that shows classes is className. So looking at our form, we can see the classes that are applied to the first input control. Form-control is a bootstrap class, we know about that one, and the next class we see is ng-untouched. So let's give focus to the field, and when I Tab off it, we'll see what happens. It went from ng-untouched to ng-touched. Right now we're just inspecting these classes, we're not going to be doing any kind of styling just yet, that'll come later in this course module. Let me refresh the form, and you can see that another class that's applied immediately is ng-pristine. Let's see what happens when I start typing in this field. I typed a single letter, and it changed from ng-pristine to ng-dirty. And if I delete the character I typed, it stays ng-dirty. So once you make a modification, it never reverts back to ng-pristine. And I'll refresh the form again, and we see ng-invalid, and this is invalid because we have this required attribute right here. If we remove that, I'll save it, and now we're valid, we have the ng-valid class applied. If we enter a minlength of 3, I'll save this. So with a minlength of 3, we can see that ng-valid is applied. That's because we don't have a required attribute, the value is null, but as soon as we start entering characters, we have 2 characters now, and the ng-invalid class is applied. As soon as we type 3 characters, that switches to ng-valid. So let's just check this again with the required attribute, as well as the minlength attribute. I'll save it, and now our field is invalid, as we type 2 characters, it's still invalid, and the third character validates it. We have ng-valid applied. So these classes are great, we can work with these and style with these, but we can also work with properties that are associated with these classes. The properties are applied to ngModel, and we'll take a look at those in the next clip.

NgModel Properties for Validation
We saw how Angular applies classes to the control elements of a form, but it also adds properties to the ngModel object. And these classes and properties match up one for one. Let's see what they are. We have the classes ng-untouched and ng-touched. The associated ngModel properties are simply untouched and touched. So we remove the ng- prefix for the properties. Likewise, we have ng-pristine and ng-dirty, the properties are pristine and dirty. And for the classes ng-valid and ng-invalid, we simply have valid and invalid as properties. The important thing to remember is that these properties exist on the ngModel object. So let's see how we access them. Here's our form template, and let's work with the first input again. I'll keep the required attribute, and instead of classTest, let's call this propertyTest. And I'll remove our debugging information right here, and I'll paste in something more useful. So I'm simply showing our six properties, dirty, pristine, touched, untouched, valid, and invalid. We have to make sure that propertyTest references ngModel. The way we do that is by assigning it the string ngModel. So I'll save this, and let's look in the browser. We can see our values, dirty is false, pristine is true, touched is false, and untouched is true, and valid is false, and invalid is true. So if we enter a value here, and I'll Tab out of it, we can see dirty is now true, and pristine is the opposite, touched is true because we gave focus, typed a value, and then left that field, and valid is now true because this field is required, and we entered something. These are simply the property values that we access in this way right here. We create a template reference variable, in this case propertyTest, and we assign it the string ngModel. So now that we know about these validation classes and properties, in the next clip, we'll use those to actually style our form, and styling is important because we want to help our users fill out the form properly, let them know what's valid and invalid at the right time.

Styling Forms with Validation Errors
We've seen that classes and ngModel properties that Angular applies to the fields in a form, so let's work with these to give the user feedback. We want to give a visual indication if a required field wasn't filled out or some other validation error occurred. Here's our form from the last clip. We can take out our debugging information, and instead of propertyTest, let's call this nameField, and that's a better name for the template reference variable. So as far as showing an error message goes, let's start off by using the classes that Angular assigns to this input field. I'll open up the File Explorer, and let's go to the CSS file. This is user-settings- form.component .css. So any selectors we place here apply only to the form. You might want to move these selectors out into its own forms.css file, or even the globalstyles.css file. So let's select the class for ng-invalid. I'll add a border to invalid fields, 1px solid red. And I'll make sure everything gets saved, I'll do a Save All, and let's take a look at the browser. So we see two problems, we have a red outline around the entire form, and we also have a red outline around the Name field, but we didn't have a chance to enter a value yet. So let's handle the border around the form first. Instead of ng-invalid, we'll add a :not form. Ng-invalid is getting applied to the form, so this'll make sure that the selector ignores the form. I'll save it, so that worked. The next problem is the red border around the Name field. We only want to show that after the user has had a chance to type in a value. So in our selector, right after the ending parentheses here, I'll specify the class ng-touched. I'll save this, and the red outline is gone. Let me give focus to the field, and I'll Tab out of it without entering a value. And as expected, we get our red outline. So this is working, but we should also have an error message show. And one way to do that is by using the properties on the ngModel object. But before I leave this CSS file, I just want to point out that you can't have a space or a comma between these selectors here. If we enter a space before .ng -touched, it won't work as expected. We don't get our outline when we Tab off of it, and we don't want a common here either, we want both of these selectors for ng-invalid and ng-touched to be checked at the same time, so we take out any space or comma between them. So let's look at adding an error message now. We can add a div right below our input field, and we'll show this div depending upon the properties of ngModel. I'll paste in the markup. So here's the div, we'll ignore the hidden attribute for now, but we're applying bootstrap classes of alert and alert-danger. Basically that shows in red. And the error message is simply Enter a name. And looking at our hidden property, we're going to be binding to that, so we want to take our namefield, our template reference variable namefield, and we want to use the expression namefield.valid or namefield.untouched. So if the field is valid, we'll hide the error message, or if the namefield is untouched, meaning the user didn't have a chance to enter anything yet, we'll also hide the error message. I'll save it, I'll go to that field, and I won't enter in a value, I'll Tab over it. And our error message shows up. If I go back and enter a name, and Tab out of it, everything's fine. So it's totally up to you how you'd like to style your form. This is one way to do it by using properties here, and you can also use the CSS selectors as you can see right here. Some designers and developers also prefer that no error messages get seen until the user attempts to submit the form. That way if you have a large form, the user can jump around from field to field, not having to deal with error messages. So we'll take a look at how to do that in the next clip.

Submitting Forms
Let's take a look at how we submit forms, and we'll be focusing on the validation aspect of this. In the next course module, we'll look at actually making HTTP calls and posting the form for real, but for now we're more concerned with validation. Here's our form, and let's just go to the Name field, and I'll Tab off of it. So the Name field is required, and the field highlighting and the error message show up as soon as we leave that field. But many designers and developers don't want this functionality, they want to wait until the user attempts to post the form, which would be by clicking the Send button in this case. The key benefit of this is it allows the user to jump around, especially on a larger form, and fill out the form as they're able to, without having to deal with error messages all over the place. so let's see how we can suppress this formatting and the message until the user clicks the Send button. We'll go to our form tag, we'll take off the ngNativeValidate, we don't need that anymore, and we'll work with the ngSubmit event. Because it's an event, it's in parentheses, and we'll create a function that we'll call. We'll simply call it onSubmit, and we'll pass it the form. Form comes from the template reference variable right here. So I'll save this and go to the TypeScript file. And let's create that method, onSubmit, and it takes a form of type NgForm. We'll use Visual Studio Code to import NgForm from the module angular/forms. So this is where we could perform any validation before the form actually gets submitted, and we'll be working with this in the next course module, but for now let's just write to the console the message in onSubmit and form.valid. That's a boolean value that will be true if the form is valid. Let's make sure this method is getting called. I'll save the file, I'll open up the console, and I'll scroll down and hit the Send button. So you get the message in onSubmit, and form.valid is false. So that's working fine, and we could use form.valid to conditionally execute code. But if we look up at the Name field, there's no styling showing us that there's an error. So let's have this error show up. We'll go to the CSS file for the form, and instead of using this complex selector right here, let's create our own class. We'll call it field-error. So now it's a matter of applying this class wherever we need it. Going to our template, we'll go to the name field, and we'll add that field error class conditionally. The way we do that is we bind to class.class name, in our case the class name is field-error, and we assign an expression. The expression will evaluate to true or false. If it's true, field-error is added as a class to the input, if it's false, it's removed as a class from the input. So we only want to show the field error if the form was submitted. So we'll take our template reference variable form, and that has a property called submitted. So if that's true and the field has an error. So the field is nameField, that's the template reference variable right here, and if it's invalid, invalid will be true. And we need to use this same logic for our div right here. You want to hide this div if the form is not submitted or the name field is valid. So we hide the error message if the form hasn't been submitted yet or if the field is valid. I'll save this and let's take a look in the browser. I'll go to the Name field, and I'll Tab out of it, and we don't get our error message, that's fine. When the user clicks Send, we get our error highlighting and the message showing up. If we enter a value, and I'll Tab out of it, the error goes away. And the form should be valid now, so I'll click on Send again. Our valid flag is true. So everything's working fine. There are many different design styles and opinions when it comes to how to show error messages, but by working with classes and by working with properties, and of course using the template reference variables, you are now able to style the form however you'd like. In the next clip, we'll take a look at HTML5 events, and how we can use those with Angular, specifically the blur event when a control loses focus.

Handling Form Control Events
Let's take a look at handling form control events. We're able to handle any HTML5 event in Angular, but the key one we want to look at is the blur event. When a field loses focus, the blur event is fired, and at that point we can do custom validation or we could just evaluate the entire form and modify the user interface as needed. Perhaps you want to open up a whole new region of a form based upon a value of a field. Here's our name field, and let's execute code when this field loses focus. That's done with the blur event. We put the event name blur in parentheses, and we call a function, we'll call it onBlur. And we can go ahead and pass this field. We'll use the template reference variable nameField. I'll save this, and let's create our function in the TypeScript file, onBlur, and it's being passed the field is type NgModel. And we'll add NgModel to the existing import declaration from @angular/forms. And just to make sure this is working, let's console.log in onBlur, and we'll show field.valid. I'll go to our Name field, and I'll Tab out of it, and we get the message in onBlur and false, so the field is not valid, which is correct. But the point I wanted to show here is that now we're able to add any code we'd like. You can modify the form based on the value of this field, and you can even show a whole new region of the form based upon the field's value. So by using Angular events, you have full access to all of the HTML5 events. Let's wrap up this course module with a summary.

Summary
We started off this module by looking at HTML5 field validation. We needed to understand this before we started working with Angular. We looked at the required attribute to make the field required, non-optional, and the pattern attribute, where we could specify a regular expression. We worked with minlength, maxlength for strings, and min and max for numbers. We looked at the CSS classes that Angular adds to our input fields for validation. These included ng-touched and ng-untouched, depending upon whether the field was visited or not, ng-pristine, which is the native state of the data when it's first shown, or ng-dirty, after the value's been modified, and the ng-valid and ng-invalid classes, depending upon the validity of the field. Next, we looked at the ngModel properties for validation, and these are based on the classes without the ng- prefix. We were able to use these properties within expressions in our template, and this is an alternative to working with classes. Next we looked at styling the forms with validation errors. We worked with the various classes and properties that we just saw in order to give the user a good experience while filling out the form. We saw how to submit forms, we handled the ngSubmit event. In this case it's calling a function called onSubmit. And we also saw how form.submitted, form being the template reference variable for the form, but form.submitted is a flag that's very useful in styling the form. It can be used in expressions. Finally we looked at handling form control events, and the key event we worked with was blur, but you could use focus or other events as well. We handled the blur event, in this case calling a function onBlur. So now you have the basic information on how to style your forms to give the user a good experience. Depending upon your design preferences, you can use the classes, or ngModel properties, and other features I talked about to style your forms properly. In the next module, we'll take a look at actually submitting form data. We'll start working with HTTP.

HTTP Form Posting and Data Access
Introduction
Hi, my name is Mark Zamoyta, and this module is titled HTTP Form Posting and Data Access. We're ready to post our forms over the internet, and Angular gives us the mechanisms to do that using HTTP. We're also going to see how we can grab some data for our HTTP select tag with options. The first thing we'll do is we'll create a data service. This will encapsulate all of our HTTP access, so it's not spread out all throughout our application. This will be the one place in our application where we can access the internet. Next we'll see how to post a form using observables. Observables are implemented in the RxJS library, and that's mainly used for asynchronous programming. Essentially we're observing the network connection, and when we get a response, the observable fires off, and we handle the response. The way we work with HTTP in Angular is by using its HttpClient service, and we have to be sure to import the HttpClient module because that's where it exists. Next we'll inject the HttpClient into our DataService and use that to post a form. And of course we're going to need to handle any errors that pop up. We need to make sure they're handled smoothly, and that the user is notified through the user interface. And finally we'll retrieve data for select elements. So far we've been hard coding options into our select element, but it's more likely you're going to need to reach out over your DataService and populate the options that way, depending upon an HTTP get. So we'll see how to do that. Let's get started by creating our data service.

Creating a Data Service
There may be several different areas in our application where we need to reach out over HTTP to either post data or grab data. It's good to centralize our data access to encapsulate it, and an Angular service is the perfect place to do that. So let's create a data service. I'm in Visual Studio Code, and we have a data folder. Earlier in the course, we created user- settings.ts, and this was a simple interface that we used for our form. But we can go ahead and create a data service right inside this data folder. I'll go to View, Terminal to pull up the terminal, and this terminal is running our dev server for Webpack, so I'll hit the plus button to create a new terminal, and let's go to this data folder. I'll cd to src/app/data. We'll use the Angular CLI to create the data service. We'll execute ng, that's the core Angular CLI command, and then g for generate, and s for service, and we'll call it data service, so we'll just specify the word data as the name. The Angular CLI will take care of the rest. So let's look at the two files that were created. We have our data.service .spec file, that's for testing, we're not going to look at that in this course, and the one we're interested in is data.service .ts. I'll close the console, and let's take a look at this file. So we're exporting a DataService class, and there's nothing in it right now, but we'll be adding functionality throughout this course module. The DataService is marked as Injectable, and it's provided in the root of our Angular application, and that's fine, we only want one DataService to span the entire application. And because we're using the providedIn field here, there's no need to add it to app.module .ts. If we look in there, we see no reference to it because we don't need it. So what we'll be doing is we'll be adding methods to this class. We'll need a method to post the form, and we'll need to pass it userSettings, and that's of type userSettings. That's the interface we created earlier. And I'll select the first line that comes up here to auto import it. And we get our import statement above. We won't be concerned with a return value yet, we'll be working with that soon, but I'll just close out this method, and we'll be ready to work with this in the next clip, where we'll be looking at observables.

Form Posting Using Observables
When we post a form, we send the form data to a server, and we wait for a response, and that's an asynchronous operation. We don't know how long we're going to be waiting for the response, it could be a few milliseconds, or if we have a slow network connection or a slow server, it could be a few seconds to a few minutes. In JavaScript, you might've worked with promises, but in Angular we go a step further, and we mostly work with observables. You could use promises, but in this clip we'll see how to use observables for asynchronous programming. Here's our DataService from the last clip, and we need our method postUserSettingsForm to return an observable. And we can also specify a type for the observable. We want it to return UserSettings data. And we're going to need to import observable from a package called RxJS. So we added the import above. So for now, let's make this method simple, and we'll just return the user settings that are being passed in. And one way to create an observable is to simply use the of function, which is also part of RxJS. Of shows up in our IntelliSense, and we'll automatically import it from RxJS, and we'll pass it userSettings, our data. Later on in the course, we'll get this post to an actually HTTP server, but for now let's just work with this to make sure our framework is set up right. So the next thing we need to do is call postUserSettingsForm when we're ready to post the form. So I'll open up user-settings-form, and I'll go to our TypeScript file, the component. Now we're going to need access to our DataService, so in the constructor, I'll specify a private dataService variable of type DataService, and we'll auto-import that. And by marking our DataService as private here in the constructor, that'll give us access throughout this whole class. In our onSubmit method, we can call our DataService method, this.dataService .postUserSettingsForm. The IntelliSense helps us. And we'll pass it our userSettings. If you remember, this is the object that gets built up as the form is modified. So as it stands, this line of code will return an observable, but it's not doing anything with it. To get an observable to start working, you need to call the subscribe method. And the first argument we need to send is a function that'll execute on success. So I'll create an arrow function, and I'll just write something to the console, logging out the result. And the second argument is another function, but it'll get called in case there's some error. So let's take a look at this again because it's important to have all the parts. We call the method on the DataService, postUserSettingsForm, and we pass it the data from the form. And we need to subscribe to this observable. If you forget to subscribe, you'll never get a result. And our first arrow function will execute when we get a successful result. On any type of error, the second arrow function will execute. So I'll save this, and let's take a look at the browser. I'll specify a Name, and I'll hit the Send button to submit the form, and we can see that our success handler got called, success, and the result is the object that we originally passed into our DataService. So that's working fine. If we look back at the DataService again, we're simply using the of function from RxJS to create a new observable, passing back the userSettings data. In the next clip, we'll take a look at starting to work with HTTP to actually call a real server.

HTTP Access Using HttpClient
Let's get set up so we can actually post our form to a real web server. So we'll be doing an HTTP post, and the way we can do that in Angular is with the HttpClient, that's the built-in service. So let's get that set up. I'll go to our app.module .ts file, and to work with the HttpClient, we need to import the HttpClientModule. So let's import HttpClientModule. That's an @angular/common/http. And I'll save this because that's all we need for our app.module. Let's go to our DataService. Instead of having HTTP access spread throughout our code, we'll use this DataService exclusively for HTTP access. That makes things a lot simpler and a lot more encapsulated. To work with the HttpClient, we inject it. I'll call the variable http, and that's of type HttpClient. And we'll automatically import that from the right place. We've been working with this fake observable right here, so we don't need that anymore, I'll just comment it out in case it's useful later on, but now we want to use our HTTP variable to post the form, this.http .post. And the first argument is our URL. We'll be entering a valid URL soon, so I'll put a placeholder for now. And the second argument is the data, which is the user settings that get passed to this method, and it just so happens that the HttpClient also works with observables, so we can return this post. And to simplify the types, we'll return an observable of any. That way we can handle whatever post returns. So we're all set up with HTTP access. The next thing we need to do is find the place to post our form to. It's too much work to create a whole server in addition to our Angular application, so we'll be posting to an online service, and we'll see how to do that in the next clip.

Posting a Form
Let's see how we can post our form data to a real HTTP endpoint. We can do that very easily using a web service. Here's a tool that we can use, and it's called PutsReq, PutsReq. The Req is for requests, we can send requests, and build a response, and send it back. And it's very easy to use, so I'll click the button Create a PutsReq. And we can see our endpoint right here. I'll copy this out of the curl command, and I'll go to Visual Studio Code, and I'll paste the URL into our post method call. So now we'll be posting our userSettings to this endpoint, and it's all wrapped up in an observable. Going back to the website, you can see where we can enter some JavaScript code to build a response. I'll make the font larger here, and we can just go ahead and delete this code. If you want to read up on how to build a response, you can click this information button, and you'll go to the GitHub page for the service. You can see here how to access the request. Because we're posting the rest.request_method will be POST, the request.body will contain the JSON object that we're posting, and we have request.params for parameters and request.headers for headers. And there's some useful code here to parse a JSON request, which is what we have. When we post the form, the data gets placed in the body as a JSON object. So let's just copy this one line of code, and we'll get to that in a second. The response is very simple. We have response.status, we can return any status code we'd like, we can specify headers in response.headers, and we can specify some text or an object for the body. So going back to our Response Builder, I'll paste the code we copied. So this will look in the request.body, which will be our userSettings object, and that gets passed to json.parse. It'll end up in this variable parsedBody. Now a real web service would process that object in some way. After it saves it to a database, it might store the ID in there, and we'll see that later in an upcoming clip, or it might alter the data in some fashion. But for now, let's just return the object. And it gets returned in the response.body. I'll hit the Update button. So that's been updated, and we can see that the number of requests made to this endpoint is 0. Let's go to our code. And I'll make sure this is saved. And let's go to our component. So when the user clicks on Submit, we'll execute our dataService.postUserSettingsForm, and on a success, this function will execute. We're using an arrow function here, which is a simple way to go about it, but this could be any function, whether it's a method of this class or a standalone function. But for simplicity, we're just using an arrow function. If any kind of error arises, the second arrow function will execute. So we're expecting a success, along with the object, which would be a userSettings object. Let's go to our form. I'll enter a Name, and I'll hit the Send button to post the form. Looking in our console, we got our success, and we got the userSettings object with a name of Milton. So it appears it worked. Let's look at the website. And now we can see that Requests is set to 1. So everything's working fine. Let's just add some data to parsedBody just to make sure that things are going through properly. It's very common when you post a form or post some kind of data that you're going to want to know the unique ID that was assigned to that in the database. So let's create an ID field. We'll say parsedBody.id = any arbitrary ID, 1234, and remember to hit the Update button. And back in our form, let's post it again. I'll hit the Send button again. So again we got success. And when we open up the object, we see our id of 1234, and our Requests was bumped up to 2. So our Response Builder is working. So we've seen the successful cases where our data gets posted and we get a successful response. In the next clip, we'll take a look at handling errors.

Handling POST Errors
We've seen what happens when things go right, but we're also going to need to check for errors. When we execute a post on a remote server, usually the errors that come back are in the 400 range, which would be client-side errors that are expected to be fixed on the client side, or 500 errors, which means there's something wrong with the server. Hopefully it's only temporary and it gets fixed soon. Let's see how we can make sure our code works well with these errors. Here's our Response Builder, and I'll comment these lines out for now. We may use them later. And quickly looking at the documentation again, you can see that response.status is where we can place the status code. And I'll set the status to 400 for a client error. I'll Update this, and we get the refresh, and let's go to our form. I'll click the Send button again to post the form, and now you can see we get an error. This error is from the browser, but our code was able to process the error right here. We're printing out the string error and the object we got in response. I'll open it up. And we can see the status 400. A lot of this other information in here, such as the message and the name, that came from this tool that we're using, PutsReq. This is the line that executed right here. Writing to the console helps us as developers, but it doesn't help our end users at all. We need to give some kind of visual feedback to the user, showing them that the form did not post, and they need to correct something. Let's do that by calling a function right here. We'll call onHttpError, and we'll pass it the error object we received. And I'll create that function, it'll be a method on this object. And we need the this keyword to start it. So here's where our code goes to give some kind of visual indication to the user that there was an error in the form. I'll paste in the code, and we'll walk through it. Here's the code for onHttpError. I'm calling the argument errorResponse now, and the first thing I do is I log that out. Different servers may package responses differently, so when you're in development, you want to make sure you get a good look at that object. Next we'll set a private variable postError to true, and we'll set another local variable postErrorMessage = to errorResponse.error .errorMessage. And that's where an error message comes through when we're using Postreq. Let's just see that really quick. So we're responding with a status of 400, and response.body is being set to an object where our error message gets placed, Some error goes here. Looking back at the code, that error message gets placed in postErrorMessage, and if we scroll to the top of this component, you can see our two new variables right here, postError is initialized to false, and postErrorMessage is initialized to an empty string. Looking at our template, this is our button for posting the form, and right above that will show an error message if needed. We'll hide the error message if there's no postError, and we'll style it with bootstrap's alert and alert-danger classes, and we'll simply display the postErrorMessage. We're using interpolation to get at that value. Let's look at our form. I'll enter a Name, and I'll post the form. We get our post error as expected, and looking at the form in detail, I'll close the inspector here, we see that we get our error message. For a 400-type error, this could show the user what needs to be fixed before resubmitting the form, or for a 500-level error, this could just tell the user to try again later or contact customer support. So let's do a little bit of cleanup on this form. One thing we need to do is to make sure that there are no errors before we submit the form. Here's our onSubmit method, and we'll make sure the form is valid before we submit. And if the form is not valid, else we can show an error. PostError = true and this.postErrorMessage, Please fix the above errors. Now let's make sure we have some validation. I'll look at the template again, and we'll make the name required. And it already is, so we're good. Let's look at the form. I'll try to submit the form without a name, and we get our message, Please fix the above errors. And we know to enter the name right here. So everything's working fine. We're getting this error here because that's what we're testing. You can go ahead and uncomment this code when you need to. So that covers submitting our forms. In the next clip, we'll take a look at another use of observables and using data for our forms. That involves getting data for a select and its options. We'll see that in the next clip.

Retrieving Data for Select Elements
We have a select element in our form with several options. It's extremely common to get these options off of some kind of data service. That way they can be built dynamically on the server side or even built in the data service itself. Let's take a look at our template for our form, and find the select element. Here's our template, and scrolling down, here's our select tag with several options. Let's get these from the DataService instead. I'll delete two options, and in the first option, we'll see the ngFor directive, that's *ngFor. And that'll let us create several options based on data. So we'll say let type of subscriptionTypes. So we need a property on our class called subscriptionTypes, and for each one of those subscriptionTypes, it'll be assigned to the variable type, so let's show that in the option. So I'll copy this variable name we're using, go to the component, and we'll add this in. And for now, let's make it a simple array of strings. And I'll use one, two, and three. So I'll make sure everything is saved with a Save All, and let's look at our form. Under Subscription Type, we get one, two, and three. So that's working fine, the only problem is we're still hard coding the values into our application, one, two, and three right here. We want to reach out to a DataService and get the values from there. So let's just say that subscriptionTypes is an observable, and the type can be a string array. If you want to get objects, that's fine too. We'll Import Observable from module rxjs. And we need to populate subscriptionTypes now. We can do that in ngOnInit. We have our DataService, and we'll create a new method on that, we'll call it getSubscriptionTypes. And we don't need to pass it anything, but we're working with observables, so we can actually assign this whole observable to subscriptionTypes. And let's create this method. It created it here in our DataService. I just want to put it underneath the constructor. Here's where we can use the of function again. We'll return of, and we'll say Monthly, Annual, and Lifetime. And we're working with a string array, so we'll make sure we have an array. So we're not reaching out to a DataService, we've already seen how to do that with our post, in this case we would simply use a get, but it's good enough for now to work with an observable created by the of function. One last thing we need to do is to go back to our template, and subscriptionTypes is now an observable, so we need to use what's called the async pipe. We use the pipe symbol and the keyword async. This will wait until the observable has gotten its data and is completed until it builds up our options. So I'll make sure everything's saved with a Save All, and let's take a look at our form. I'll look at the Subscription Types, and we get Monthly, Annual, and Lifetime. So that covers all the data scenarios I wanted to cover in this module. We'll wrap things up with a summary.

Summary
In this module, we saw how to create a data service. A data service is an Angular object that's marked as injectable, and it has a property providedIn with the value root. So that creates a singleton that we can use throughout our application. Next we saw how to post a form using an observable. Observables are used for asynchronous programming, and the way we work with them is we get our observable, and we call the subscribe method on it. That will kick off any asynchronous call. When the asynchronous action completes, either a success function will be called or an error function will be called. Next we used Angular's HttpClient for our HTTP access. We had to make sure to import the HttpClientModule into our app's main module. And then once we did that, we could inject HttpClient into our data service. We saw how to post a form using HttpClient. Assuming that HTTP is our injected object, we called the post method. We pass it the URL and the data that we want to post, which comes directly from our form. Next we saw how to handle POST errors. You have to be aware of client-side errors, which are in the 400 range or server-side errors in the 500 range. And the important thing about that is to inform the user of what's going on. We saw how to modify the user interface in Angular to deal with this. Finally we saw how to retrieve data for select elements. We used the async pipe feature in our template. It looks like this. We used ngFor, and we assigned it this string, let item of items, and of course items would be some kind of observable. And we used the pipe symbol, and we pipe it to async. This way if we're waiting for items to load asynchronously, we won't get any template errors. As soon as items resolves, our selected options will be updated. And make sure that items is an observable. If it's simply an array, you're going to have problems. So that wraps up this module. Now you're able to post form data and handle any response, whether the form was posted successfully or there was some error you need to show to your users. In the next course module, we're going to take a look at some third-party components, so I'll see you there.

Third-party Form Controls
Introduction
Hi, my name is Mark Zamoyta, and this module is titled Third-Party Form Controls. One of the problems when we work with HTML5, especially the input tags, is that each browser implements form controls differently. By using third-party form controls, we can get a standard experience across browsers. You can also get much more powerful functionality than you get from normal HTML5. We'll start off by going to angular.io, and looking at the resources that are available there. Next we'll focus on ngx-bootstrap. We'll install it and see how to use it in our Angular application. Ngx-bootstrap is one of the many third-party controls that we could use, and it does a good job working alongside Bootstrap. Then we'll look at these ngx-bootstrap controls in more detail. We'll look at its buttons, we'll see how to work with dates and date ranges, we'll see how the user can enter a time, and we'll wrap it up by looking at a rating control. Usually when you rate a product, you give it a certain number of stars, and that's also part of ngx-bootstrap. In the next clip, we'll take a look at angular.io and the resource section.

Form Resources at angular.io
There are many places we can get third-party controls to add to our forms. One of the best lists of resources are the form resources at angular.io. I'm here at angular.io, and there's a valuable RESOURCES link, so I'll click on that. Here we can find all kinds of resources for developing with Angular. Here's an IDE section, and Data Libraries, and here's what we're interested in for forms, UI Components. I've counted them up, and there are 27 different projects here that offer UI components. Let's just quickly look at a few of these that I'm somewhat familiar with. One is Angular Material. This is an open-source project by the Angular team, and there's a complete course on this at Pluralsight. It's right here. Angular Material is much more than forms, but it does offer a lot of form controls. If we click on Components, you can see a link to Form Controls right here. And there are a lot of choices to add the Angular material-style controls to your forms. Going back to angular.io, we'll look at some more UI components here. There's a project, ng-bootstrap, which is a GitHub repository for Bootstrap-style components, and there's also one called ngx-bootstrap, which is very similar. And ngx-bootstrap is what we'll be looking at throughout this course module. Another library I'm familiar with is Prime Faces right here. If we open up this Input link, we can see a wide range of controls we can add to our forms. For RadioButtons, you can see it has much better styling than the standard styling you get in a browser, and it has its own ColorPicker. Going back to the RESOURCES at angular.io, it's definitely worth it to look around throughout this whole list, and find the right components for your project. If we scroll to the bottom of this list, there's a community section, and there's a link to a Catalog of Angular Components and Libraries. And this is a GitHub repo called awesome-angular-components. Scrolling down, we can see a Form section, and this has links to several other GitHub repos and projects that you can use for controls. For example, if you wanted a Rich Text Editor as a field, it has some options right here. So feel free to look through these resources. For the rest of this module, we'll be looking at the ngx-bootstrap GitHub repo. Even if you don't plan on using these controls, the process to integrate them into Angular is similar across all these controls. So in the next clip, we'll take a look at ngx-bootstrap.

Installing and Using ngx-bootstrap
Let's install ngx-bootstrap into our project and start using it. Here's the page we were looking at in the last clip at angular.io /resources, and I'll click on ngx-bootstrap. Here's its homepage, and I'll click on GET STARTED. You can see the components listed on the left. Some of these components are not suitable for forms, things like Alerts or a Carousel, usually you don't see that in a form, but other things are useful for forms, such as Buttons, we can use radio buttons and check buttons, a Datepicker is useful, a Rating control is useful, and a Timepicker is another component we'll be looking at in this course. But let's start off by installing something simple. I'll click on Buttons. So in Buttons, I'll scroll down, and here we have a simple toggle button. It toggles between 2 values, 1 and 0, and for 1, the button is shaded slightly darker. So let's start off by adding this toggle to our form. It can be an On/Off switch. Scrolling back up, since we're using the Angular CLI, here's a command we can use to add the Buttons component to our project, ng add ngx-bootstrap --component buttons. So we specify a single component, we don't have to integrate the entire ngx-bootstrap library into our project, which is good. So let's execute this in Visual Studio Code. Here's our project, and I'll open up a new console, and I'll execute ng add ngx-bootstrap --component buttons. So the package is installed, let's see how we add this to our application. So we're going to need to import the ButtonsModule from ngx-bootstrap/buttons. And then we're going to have to make sure we import it. So let's do that. I'll open up src, app, and click on app.module, and let's add our import here. And we need to make sure we import ButtonsModule. So now we should be able to use buttons from ngx-bootstrap in our application. And let's look at the example. Here's the toggle button, and I'll just copy the button code. We'll go to our user-settings-form, the template, and I'll just add it after the name field. So we're mainly interested in making sure that ngx-bootstrap is installed properly and we can work with it. So this is binding already to something called singleModel. So let's add that to our component. And we'll set it to On to start with. We'll create an On/Off switch. We'll make sure true is on and btnCheckboxFlase is Off. And there's no name field, so we need to make sure we set a name field, singleModel. Now we can go ahead and show the on or off status right here. So I'll make sure everything's saved, and let's look at the browser. And here's our button, toggle is set to On, and it toggles On and Off fine. So we're all set up and ready to go. In the next clip, we'll take a more detailed look at buttons.

Working with Buttons
Our form currently has radio buttons, and the styling for those radio buttons has been around forever. Since the beginning of the web, those types of radio buttons have always looked the same. But in modern applications, we have to be ready for mobile devices. So it's more common to replace radio buttons with some form of larger buttons, and we can do that with ngx-bootstrap. I'm at the Buttons section of ngx-bootstrap, and here's the section on Radios. If we see how this operates, we have a Left, Middle, and Right button. And this is a much more modern way of working with radio buttons. Let's add this to our form. We can see the div right here that we need to add, everything is wrapped in a button group, and then each button is actually a label with a role of button. So I'll copy this, and I'll paste this into our template. Here's the template, I'll scroll down until we see our radio buttons, and they're right here. These are the Light, Medium, and Dark settings for the user interface style. So what I'll do is I'll just go into our form-group, I'll paste the code we copied, and I'll go ahead and fix this up, and we'll review it. I removed the old radio buttons and added this. Here's our div with a class of btn-group, that's the wrapper, and our three labels for Light, Medium, and Dark. One of the things I had to do after pasting in the code was to add the name field. We're using this in a form, so we definitely need that name field. And we set btnRadio to Light, Medium, or Dark. So I'll save this, and we'll take a look at the form. So here are new radios. We have Light, that works, Medium, and Dark. We need to make sure that the data is going through properly. So let's go to our component, and we're not interested in posting the form anymore, so I'll comment out the code to post it. We're working in the user interface, so we just want to make sure that the form data is accurate. So I'll log out form.value. So I'll open up the console, I'll click on Light, submit the form, and we can see our interface style is Light right here. If I click on Dark and submit the form, we can see that our interface style is dark. So the buttons are working fine. So this interface is a lot more modern looking and it works much better on mobile devices than the old radio buttons. In the next clip, we'll take a look at working with dates and date ranges with ngx-bootstrap.

Dates and Date Ranges
One of the problems with working with dates across various browsers is that each browser gives a different experience. We want our date controls to be standardized across browsers. Let's see how we can do that with ngx-bootstrap. In our Component list, I'll click on Datepicker. And here's how we can add it to our root module. Let's execute this command. I'll open a new console window, I'll pull up the previous command, and here's our command, I'll execute it. So that installed. Let's go to app.module. And you can see that we need to import BsDatepickerModule from ngx-bootstrap/datepicker. And after the ButtonsModule, we'll import the BsDatepickerModule. We also need to execute forRoot because there's some configuration we need to set up. We should do that with the ButtonsModule as well in case anything needs to be configured. So I'll save this, going back to the documentation, we can see an example of our Datepicker here. We can move forward and backward through the months, or we can click on the month to select the month, or click on a year to select the year. For our Daterangepicker, we simply have two calendars, and we select one date and the secondary date. Let's put a datepicker into our form. I'll copy this input here, we can see that it's simply a text input, and it operates as a datepicker because of this bsDatepicker directive right here. So I'll go ahead and paste this into the form. I'm in our template, and I added the Start Date field. It's wrapped in a form-group, and it has a label of startDate. Here's our input tag, and we're binding to startDate, so we'll look at that in a second in our component, and it has the bsDatepicker directive. Looking at the component, I added a variable here, startDate, and we initialize it in ngOnInit right here. So that'll be today's date. So I'll go ahead and save this. One other thing to look at is the angular.json file, it's right here. In our styles, you want to make sure that our bs- datepicker.css file is included here. That should've been added automatically when we added the component, but sometimes when we automatically add styles like that, we need to restart our dev server. So in the console, I just had to Ctrl+C and execute ng serve again, so just be aware of that. Going back to our component, I'll make sure this is saved, and let's look at it in the browser. Here's our Start Date field. You can see below it I'm showing the Start Date right here, and that's just for debugging. We can click on the field and select any date we want. We can change years, and that's working fine. There are tons of options that we can use with dates, but I won't be going into them in detail. Let's just quickly look at the documentation. If we scroll down, we can see that we can make the whole datepicker in line where it's always open. And we can customize our date formatting. We can also do things such as set a minimum and maximum range for our date. The last thing I want to show is the rangepicker. I'll scroll back up, and here's an example of range right here. The only difference is the directive name. For a single date, we use bsDatepicker, but for a range, we use bsDaterangepicker. Going into the code, if I change this to bsDaterangepicker, I'll save it, and we'll look at the form. I'll click on the Date field, and because we have a narrow viewport, it shows the months vertically, we still pick a range. The 13th through the 13th, so that's fine. You'll notice the values are separated by a comma. In the next clip, we'll take a look at the timepicker to have the user input times of day.

Timepicker
In addition to entering a date, you may want the users of your form to enter a time, a time of day, and you can do that with the ngx-bootstrap timepicker. In the list of components, I'll scroll down and select Timepicker. I won't go through the whole installation again, but you can see the pattern. We execute this command, and then in the module, we need to import timepickerModule, and we need to make sure we list that in our imports, calling the forRoot function on it. Let's see how it works here. Here's a basic example. We can modify the hours, or we can just go ahead and enter a new hour, we can modify the minutes, by default it looks like it goes in increments of 5, and we can modify the AM and PM setting. You can see here that we use a component called timepicker. So I'll copy this, and I'll go ahead and paste that into our form. Here's the template for our form, and here's what I added. The timepicker is wrapped in a form-group, it has a label called startTime, and in our timepicker element, we simply bind startTime to ngModel and give it a name. We also need an ID to get the label to work. So I'll save this, and let's take a look at the form. Here's our Start Time. Well right now it's 2:29 PM, and I can change the hour, change the minute by increments of 5, and change the meridian from AM to PM. And if you look right below it, you can see that I am logging out the start time. And again, just like the datepicker, there are tons of options. Just to see a few, we can set a min and max time, and we can also toggle minutes and seconds, and there are a lot more features you can find useful. When we were binding this, if we look at our component quickly, you can see that we bind it to startTime, and we're initializing it right here in ngOninInit. In the next clip, we'll take a look at ratings, another type of control.

Rating Control
The final control we'll look at is a rating control. This involves rating something usually from 0 to 5 stars. In a lot of cases, a rating control really isn't part of a form, it's used to instantly send feedback, but it could also be used in a form where it posts along with all the other information in a form. So on our list of components, I'll scroll down, and Rating is right here. Again I won't go through the installation, you can install it with this command, and you want to make sure to import ratingModule from ngx-bootstrap/rating. And in your import list, you need ratingModule.forRoot. The example I want to look at is this dynamic rating right here. I'll mouse over it, and you can see that it adjusts from 1 or 10% up to 100%. And I can click on one of the stars to set it. Let's say I set it at 3. When I mouse off, it keeps that value. So let's add this to our form. We'll let the user select the number of stars from 1 to 10. Here's the component for it, it's rating, and you can see that it uses ngModel and max to set a max value, in our case it'll be 10 for 10 stars. And we're not concerned with readOnly, we want it to be writable, and we're also not interested in these two events, onHover and onLead. You can handle those if you want to, but for a form, we don't really need it. And I'm not sure the value of the titles property either. If you notice if I hover over the first star, it says one underneath it, and that's what those titles are. They're like little tooltips for the stars. So we can pretty much ignore those. I'll go ahead and add this rating to our form. Here's our rating control, we're wrapping it in a form-group, and we're not using a label, we're just using userRating, along with the rating component. We're two-way data binding this to userRating, and we also have a maxRating variable, we'll see those in a second. And the only other important piece of information is the name because we need that with all our form components. You can also see that I'm printing out some debug information right here. We'll show the userRating in the form. I'll save this, and let's take a look at the form. Here's our User Rating, it's set to 0, and as I hover, we can see the stars growing and shrinking. I'll set it to 5, and our variable updates. I'll set it to 10, and our data binding is working fine. Looking at our component, you can see the userRating and the maxRating right here, and those are being bound to the component. So that's the last component from ngx-bootstrap that I wanted to show you. Feel free to look around ngx-bootstrap and all the other third-party control providers that you can find at angular.io or anywhere on the internet. Let's wrap up this module with a summary.

Summary
In this module, we started off by looking at the form resources at angular.io. We quickly looked at Angular Material, Prime Faces, and ngx-bootstrap. We spent the majority of this module looking at ngx-bootstrap components. We saw how to install ngx-bootstrap, we used the Angular CLI command ng add in order to install ngx-bootstrap. Once we did that and imported the module into our root module, we were able to use it in our templates. We took a look at buttons, specifically the buttons used as radio buttons. That gave the form a more modern look and worked well across mobile devices as well. We looked at dates and ranges of dates, and we looked at ngx-bootstrap's time control. Finally we looked at ngx-bootstrap's rating control, and saw how to integrate that into a form. That wraps up this module and also completes this course. You should now be able to easily create template-driven forms for your Angular applications. You've learned how to validate form data, post a form to a server, and work with third-party controls. Good luck with using forms in your Angular projects.

Course author
Author: Mark Zamoyta	
Mark Zamoyta
Mark started in the developer world over 25 years ago. He began his career with a Bachelor of Science in Computer Science from St. Johns University. After spending 10 years on Wall Street working...

Course info
Level
Beginner
Rating
4.6 stars with 39 raters(39)
My rating
null stars

Duration
2h 3m
Released
2 Apr 2019
Share course