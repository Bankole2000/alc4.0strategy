Broadening Android App Appeal and Reach
by Jim Wilson

The Android platform encompasses a rich ecosystem of users and devices. In this course, you’ll learn how to create apps that effectively engage this ecosystem through multiple language support, device adaptability, accessibility, and custom views.

The Android platform encompasses one of the largest user bases of any platform and provides those users with a rich device ecosystem filled with choices. In this course, Broadening Android App Appeal and Reach, you’ll learn how to succeed in this environment by creating apps that effectively engage the needs of these users and that adapt to their individual device capabilities. First, you will see how to use the Android resource system to create apps that dynamically adapt to device features and capabilities. Next, you’ll explore how to create locale-aware apps that have multiple-language support and display text in the user’s language of choice. After that, you’ll dive into creating custom views that allow your app to present a rich and engaging user experience. You’ll then learn to add Android Studio design-time configurability to your custom views and incorporate interactive features. Finally, you’ll gain an understanding of how to create apps that provide support for accessibility features such as non-touch navigation and screen readers. By the end of this course, you’ll have the skills and knowledge to create your own Android applications that that effectively engage and meet the needs of the rich ecosystem of Android devices and users.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Advanced
Rating
4.7 stars with 23 raters(23)
My rating
null stars

Duration
4h 4m
Released
2 Jan 2018
Share course

Working with Resources for Localization and Adaptability
Introduction
Welcome to the Pluralsight course, Broadening Android App Appeal and Reach. This is our first module working with resources for localization and adaptability. My name is Jim Wilson. This is the final course in our series, and I have to say it's one of my favorites because, in this course, we'll cover those Android capabilities that allow us to create apps to provide an engaging experience that work well with a rich universe of Android devices and support a broad user base. So in this module, we'll look at how we can use resources to help our apps adapt to device differences. Then later in the course, we'll see how to create custom views, we'll see how to handle custom views sizing and positioning, we'll see how to make our custom views interactive and provide configuration capabilities to Android Studio, and then we'll finish up by learning how to incorporate accessibility features into our apps. The Android resource system is at the heart of creating apps that adapt to the different needs of devices and users. Understanding how to use these capabilities is our focus in this module. So we'll start out with a look at how resources allow our apps to adapt to different device needs, and then from there, look at a number of specific situations. We'll look at how we can load different values based on a device's screen width, we'll see how we can create orientation specific layouts for our activities, we'll see how we can localize UI text into alternate languages, we'll see how we can use different drawable resources so that our images render effectively on differing device screen densities, and as part of that discussion, we'll take a look at the physical folder structure used to store our resources.

Resources and Adaptability
Earlier in the course series, we introduced this idea of resources. We talked about the fact that resources allow us to externalize content from our code and we have a wide variety of resource types. We have things like layout resources or menu resources, we even have string resources and other value resources, and by having our content resources, that content can be maintained separately from the source code. So we can actually make changes to the resource content without having to touch our actual source code. And when we introduced resources, we also just mentioned in passing that resources simplify application adaptability and it's this issue with adaptability that we want to look at now because Android supports a very rich device ecosystem. There are a wide variety of device types out there that run Android and we want to be sure that our applications can effectively adapt to the differences in these various devices and there are quite a number of differences that can come up between individual devices. There are things like hardware differences, differences in the way devices are actually manufactured, things like how large is the screen on a particular device, or what is the pixel density on a particular device, but there are also differences that are a bit more dynamic based on how the user has something set or how the user is currently interacting with the device, things like is the user holding the device currently in a portrait orientation and then they rotate it to a landscape orientation or maybe the user turns night mode on a device and then later turns night mode off. Then other differences are based more on the devices setup or installation, things like the locale, is the device set up to use US English, or is the device set up to use something like Argentinian Spanish, or is it set up for something like German in Germany or English in India, alright, all of these things affect the way our application needs to display content. Then there is even something as fundamental as what version of Android is currently installed on a device and these are just examples of the kind of differences that occur between individual devices. Now because Android supports such a rich ecosystem of devices, that creates a lot of opportunity for us as developers, but dealing with all those differences can actually be quite challenging because if we had to manually encode, deal with all these various differences, it would take an incredible amount of code to do that effectively. So to help us out, we have the Android resource system. The Android resource system can actually help us deal with differences between devices. Because we create resources, we can actually associate resources with specific device configurations, and then what will happen is at the time our application is running, Android will select the appropriate resource for the current device configuration and this can all happen without us having to make changes to our application code. So help us understand this a little better, in our next clip, we'll start looking at how resources can be helpful in dealing with device configuration differences.

Identifying Need for Adaptability
Here we are in Android Studio, and what we want to do now is start looking at a scenario where we need to adjust our app's behavior based on a devices configuration. Now we're continuing to work with the same NoteKeeper app that we've been working with throughout this course series. We're currently looking at the code for our NoteKeeper app's MainActivity class and this is the MainActivity class' initializeDisplayContent method. InitializeDisplayContent is where we do the work to set up our main activity's RecyclerView that displays our list of notes and our list of courses. And we have our code in here to get a reference to the RecyclerView and create instances of the layout manager we use in the RecyclerView to display the notes and display the courses. Now in the case of the courses, we're using a GridLayoutManager. Notice here we construct the GridLayoutManager that the second parameter is showing up highlighted in green. This indicates that we're using a resource that specify the value of the grid's span and that resource contains a value of 2. Now if we hover over that green highlight, Android Studio shows us the actual code we typed to access the resource value, which in this case, is an energy resource named course_grid_span. So now if I click on that code, we can interact with it. Now the see the resource file entry for course_grid_span, if we go over here and right-click on it, we choose Go To, and then we choose Declaration, that takes us to the resource file where we declare a course_grid_span. That file's name is ui_constants. Now we can see that file over in the Android Studio Project window and I currently have the Project window's Android view selected. All of our resources are located under the res folder, then within the res folder, we have the values folder, and then within the values folder, we have our ui_constants file. Now by maintaining the grid span as a resource, we can change its value right here in our resource file without ever having to modify our app source code. So now let's run our app and take a look at how the list of course appears when displayed using our course_grid_span value of 2. So here we are now with our app up and running in the emulator and we're currently looking at the list of notes, and in the case of the list of notes, we use a simple linear layout. So the cards for each note are laid out in a linear list. But now let's open up our navigation drawer and we'll select Courses. Now the list of courses is displayed within the Recycler view using our grid layout manager. And just as we specified in the resource file, the courses are displayed in two columns. Now using this two-column layout looks pretty good on this phone style device. Let's run our app on a device with the wired display and see how the two-column layout looks on that device. So here we are now with our app up and running on a tablet style emulator, and just as before, we start out with our list of notes displayed in the Recycler view, let's open up the navigation drawer, we'll select courses, and again, our list of courses is displayed in two columns, and that looks okay, but with such a wide display, this of course, might look a bit better if we went with three columns rather than two. So now that presents us with a challenge because on the smaller display devices, we want to go ahead and stay with that two-column layout. Well on devices like this that have a wire display, we like to use three columns instead. So in our next clip, we'll see how we can do exactly that through the use of resource files.

Loading Different Values Based on Screen Width
Here we are back in Android Studio and what we want to do now is see how we can adjust our app's behavior based on a devices configuration. Specifically, what we want to do is adjust the number of columns used to display the list of courses depending on the width of the devices screen. Now as you recall, we specify the number of course display columns using an integer resource named course_grid_span. Because that value is contained in a resource file, adjusting the value based on a device configuration becomes easy. The current value we have for course_grid_span is contained in a resource file that isn't associated with any device configuration characteristics. But now if we specify a different value of a course_grid_span and do it within a resource file that is associated with device configuration characteristics, that value will be used when our app is run on devices with that configuration. Now one way to create a new resource file is to go over here to our res folder, we'll right-click on it, we'll choose New, and then choose Android resource file. Now going this route would work well if we were creating a brand new resource because we can specify the resource file name, its type, and other related information. It also allows us to associate the new resource file with specific device configurations, but in our case, we don't need to create a brand-new resource. What we want to do is create an alternate value for an existing resource, so there is an easier way to do this. So let's cancel out of here. So what we can do instead is select our resource, and then we'll click on the lightbulb, and then we'll choose Override Resource in Other Configurations. So now this opens up a dialog that allows us to create an alternate values resource. Down here in the lower section of the dialog, we can select the device characteristic qualifiers that we want to associate the new resource with. Now there is a pretty broad set of qualifiers, but now in our case, we want to specify a resource value based on the width of the device's screen. So let's choose Screen Width and then we'll click on those double arrows to make this a chosen qualifier. Now once we make screen width a chosen qualifier, we need to provide a specific width value. As we've talked about earlier in the series, we generally use device independent pixels or DPs to specify a size. So when we're specifying our desired screen width value, we'll specify that value using DPs. So let's set the value to 640. Now as you recall, there is 160 DPs per inch. So by specifying a value of 640 DPs, we're indicating that we want to create a resource file that's used when our app is running on a device that has a screen width of 640 DPs or greater. So let's go ahead and hit Enter to create the file and now that creates a new ui_constants resource file containing our course_grid_span resource. Let's quickly confirm that we now have two versions of the ui_constants resource file. So let's go over here to the Project window and let's expand our values directory. Now notice next to our ui_constants entry, we have the number 2 in parentheses and that tells us that there are 2 versions of that resource file. Let's expand that ui_constants entry and we can see that there are indeed two of them. Now notice that the second ui_constants entry has w640dp in parentheses next to it. That indicates that it's associated with devices with a screen width of 640 dp or greater. The one above has no qualifier next to it and that means that it's the default version of that resource file. Now looking at the ui_constants file that we currently have open in the editor, notice that the name tab for that file includes w640dp, so that indicates that we're currently editing the version of the ui_constants file that's associated with that w640dp characteristic. So that we can see things a bit better, let's split the Editor's screen. So I'll right-click on the file name tab, I'll choose Split Horizontally, and then let's go ahead and close the top split. So that gives us the default version of the ui_constants file on the top part of the screen and the w640dp version on the bottom portion of the screen. In the w640dp version, let's change the value of course_grid_span from 2 to 3, and with that, we run our app on devices with the screen width of 640 dp or greater, the value of course_grid_span will be 3, otherwise, it's value will be 2. So that means when we run our app on devices with wider screens, we should show the courses with three columns. In the other cases, we should show it with two columns. So let's run our program and verify that all works as we expect. Here we are with our app up and running on the phone emulator. The phone emulator has a display that's less than 640 dp wide. So we should expect when we display our list of courses, you should only have two columns. So we'll select our navigation drawer, we'll choose courses, and just as expected, our list of courses is being displayed using two columns. So everything is working just as we'd like on this device. So now let's see what the app looks like when we run it on a device with a wider display. So here we are now with our app running on a tablet emulator, let's open up the navigation drawer, we'll choose Courses, and on this device, the list of courses is being displayed with three columns. So that means that we were able to change the display behavior of our app without changing any of the app's code. All we had to do was create a new resource and then associate that resource with the desired device configuration characteristics, and then Android took care of the details of selecting the correct value. So in our next clip, let's look at another scenario. We'll look at adapting an activity's layout based on whether the user is holding a device in a portrait orientation or in a landscape orientation.

Creating Orientation-specific Activity Layouts
Here we are back at Android Studio and what we want to do now is look at another scenario where we can use resources to adapt our app's appearance to differing device configurations. In this case, we'll look at adapting an activity's layout based on the device orientation. Now we're currently looking at the layout resource for the Content area of our note activity. Now just about all the work we've done with our app throughout this course series has assumed that the device is being held in a portrait orientation. We should probably verify that our layout still works well when the device is held in a landscape orientation. Now one way to get a sense of the note activity's landscape appearance would be to run our app, open the note activity, and then rotate the emulator to a landscape orientation, and we'll definitely want to do that at some point, but we can get started a bit more easily. Now as you may recall from our discussion earlier in the series by the Android Studio layout designer, we have the ability to preview the appearance of our layout on a few different device configuration variations. Now one of the variations we can preview is differences in orientation. So clicking this button here switches our Layout view between portrait and landscape orientations. Now we're currently viewing our layout in portrait, so let's switch to landscape. And our activity's appearance in landscape doesn't look too bad. Because we've laid out all of our views with proper constraints, the views have all positioned and resized appropriately, so our layout will definitely work in landscape. But you know, I wonder if we could maybe do a bit better. Let's switch back to portrait. Now as we're looking at our note activity layout here in portrait, I think it looks really good. So we want to be sure the changes we make to the layout for landscape orientation don't affect the appearance of the layout when viewed in portrait. So what we'll do is create a copy of this layout resource and associate that copy with the landscape orientation. So now to do that, we'll click this button here and then we'll choose Create Landscape Variation. Notice now that we're viewing the layout resource as it appears in landscape and we'll look at the name tab at the top the resource file name is preceded by land indicating that this file is associated with a landscape orientation. Before we start making changes to the layout, let's see what things look like in the Project window. So we'll open up the Project window, let's scroll down here a little bit, so now we've scrolled down to the Resource section of our Project window. We have our Project window open up in the Android view. If we look here at the layout folder under the res folder, we can see an entry for our content_note resource. That resource has a number 2 after it indicating that there are 2 variations. The first variation is our default variation and the second variation has land after it indicating that it's associated with a landscape orientation. So everything looks good there, so we'll go ahead and close up our Project window. So now we're ready to start modifying the landscape version of our layout. So let's do this, let's divide the Screen area into left and right sections with the course name and the note title on the left side of the screen and then that'll leave plenty of room on the right side for the note text. Now since we created this layout using a constrained layout, making this change would be pretty simple. So the first thing we'll do is add a guideline to the layout. Now we can do that by clicking this button here and then we'll choose Add Vertical Guideline. Guidelines give us anchor points that we can use for layout purposes, but the guidelines themselves aren't visible to the user so let's drag this guideline to the middle of the screen. Now guidelines can be positioned by fixed distances from the edge of the screen or by ratio. Now initially, it's positioned against the left edge of the screen. To change the positioning, we put the circle at the top, so clicking it once, changes the positioning to be relative to the right edge, clicking it again changes the positioning to be a ratio. Now we currently have our ratio set at 50% so that means that our guideline divides the screen in half and that's just what we want. So now we can start positioning our views relative to the guideline. So the first thing we'll do is select our spinner, then we'll select its right edge, and then we'll drag it to the guideline. Since the text views for the note title and the note text both have their right edge positioned relative to the spinner, all three of these views are currently positioned on the left side of the screen. So now let's go ahead and select our note_text view, we'll select its right edge, and we'll position that relative to the right edge of the screen and then we'll position its left edge relative to the guideline. So now that gives us our note text on the right side of the screen, but we have one last change to make. Currently, the top of the note text is positioned relative to the bottom of note title. So let's go ahead and position the top edge of note text relative to the top of the screen. So now, we have a landscape variation of our note activity layout, the position of the course name and the note title on the left side of the screen, and the note text on the right. So in our next clip, we'll run our app and verify that everything works as we expect.

Verifying Activity Orientation Change Behavior
Here we are back in Android Studio, and what we want to do now is verify that our note activity works as we expect and the device is rotated between portrait and landscape orientations. We're currently looking at the two layout resources for the Content area of our note activity, on the left is the default layout and on the right is the layout associated with the landscape orientation. Now it's important to keep in mind that these are two separate layout files. So going forward, any changes we make in one version of the layout, we want to make sure that the corresponding changes in the other. Now one place that's especially important is in our view IDs. Remember that our Java code retrieves references to the views based on the view ID. So for example, the course_spinner and default versions of the layout has an ID of spinner_courses. So the course_spinner in the landscape version of the layout also must have that same ID and we want to be sure that we maintain that same kind of consistency for all the views contained within the layout. So now, let's take a quick look at the NoteActivity class just for a quick reminder of how the Java code interacts with our layout resource. Here we are in our NoteActivity class and we're currently looking at the onCreate method. So now here with our onCreate, we load our layout resource by calling the setContentView method, and when we call setContentView, Android takes care of loading the appropriate version of the layout resource based on the device's current configuration. I'll load the landscape or the default version depending on the device's current orientation. And once the layout is loaded, we can access the individual views. So for example, to access our course_spinner, we call findViewById passing in a spinner_courses ID value. Now as we mentioned, because we rely on his id values to access the views, it's critical that the view ID stay consistent between the different versions of our layout resource. But now once the activity is displayed, what happens if the user rotates the device from portrait to landscape. Well it turns out the system will actually destroy the activity and then recreate it. So what that means then when we rotate the device from one orientation to another, the onCreate method will get called again. So we've rotated the device from portrait to landscape, this call to setContentView will then load the landscape version of the layout and this process of destroying and recreating the activity happens each time the device's orientation changes. So let's go ahead and run our app now and we'll see how things look. Here we are with our app running in the emulator. So let's go ahead and select a note and our note activity looks good. So our portrait layout is working just as it did before. Now let's rotate the emulator to a landscape orientation and that looks good too. When a device is in a landscape orientation, we're using the landscape version of our layout resource and that's exactly what we wanted to have happen. So Android completely destroyed the instance of our activity that was initially displayed then created a brand-new instance of our activity and it loaded in the landscape version of our layout. Now it's critical to always keep in mind that changing the device orientation causes the activity to be destroyed and recreated because if it's not handled correctly, we can have problems. So let's see what happens now when we rotate the device back to portrait, and as you can see, our app crashed. So in our next clip, let's dig into the reason our app crashed and we'll see how to fix it.

Manage Activity State on Orientation Changes
Here we are back in Android Studio and what we want to do now is understand why our app crashed when rotating the device between different orientations. Now as you recall, the app seemed to work fine when we initially rotated the device from portrait to landscape, but then we tried to switch back to portrait, the app then crashed. Now to help us identify the problem, have the Android Monitor tab of Android Studio open. Now we can see here that we encountered the error inside of our NoteActivity class and the error appears to be a NullPointerException and that usually means that we have a field or a variable that's not properly set. So down here in the stack trays, we can see a link to the part of the code where the crash occurred, so let's click on that and see what our code looks like. So here we are in our NoteActivity class and we can see that the error occurred in our saveNoteToDatabase method. Now this is the method that gets called to save the current data values to the database whenever the activity's onPause method gets called and a specific line to the method where the error occurs is while we're attempting to update the database. Now the problem is most likely related to this field mNoteUri. Now the mNoteUri field contains the provider Uri for this specific note, but now how could that be null. Well remember, our activity is destroyed and recreated each time it's rotated to a different orientation. While thinking back to the very first course in this series, We talked about the importance of saving an activity's state when that activity is being destroyed and then we can restore that state when the activity is recreated. Well the value of our mNoteUri field is set when the activity initially creates the loader for the note. So mNoteUri is actually a part of this activity's state, and as a result, we need to be sure to save and restore it, so let's go ahead and add that code. Now to do that, the first thing we'll need to do is scroll to the onSaveInstanceState method. So here we are now in our onSaveInstanceState method. As you recall from our discussions back in the first course of the series, the onSaveInstanceState method receives a Bundle and we store our state inside that bundle. So what we'll do here is call the bundle's putString method. We need to identify the value we're storing, so we use the constant I've added named NOTE_URI and then we'll pass in the value of our mNoteUri field as a string and that takes care of saving the value of mNoteUri. Now we need to restore the value when our activity is recreated. So to do that, we'll scroll up to the onCreate method. So here we are in our onCreate method. Remember that when an activity is recreated, the onCreate method receives a bundle containing the activity's saved state. The bundle is passed into the savedinstanceState parameter. So let's go down here to where we check to see if the activity is being recreated and we determine that by checking to see if the savedInstanceState bundle is null. If it's not null, then we know our activity is being recreated. So down here in the else part of our if statement will retrieve back to string value the URI that we stored in the bundle and then we'll convert the string to a URI and assign that value to our mNoteUri field. And with that, we now properly save the value of our mNoteUri field when our activity is being destroyed and restore its value when our activity is being recreated. So let's go ahead and run our app again and we'll verify that everything now works as it should. Here we are now with our app up and running, let's go ahead and select a note, all looks good there. So now let's go ahead and rotate the emulator to a landscape orientation and that looks good too. But now remember, this time when we rotated the emulator and our NoteActivity class was destroyed, we saved our state, so that way when it's recreated, we can restore that state. So now let's rotate back to a portrait orientation. And notice everything now continues to work. So now remember, the key issues here were that we provided the appropriate layout resources for each configuration and we made sure that our activity properly maintains it state between each destruction and recreation. So now in our next clip, let's look at how we can use resources to provide appropriate UI text based on a devices locale.

Localizing UI Text into Alternative Languages
Here we are back in Android Studio and what we want to do now is look at how we can use resources to provide appropriate UI text based on a device's locale. Now we're currently looking at the default content layout for our note activity, and as part of the layout, we include hint text for the EditText fields, and as you may recall, whenever we need to provide a string value in our application, we can specify that value as a string literal or as a string resource. For example, we look here at the EditText field for our note title, and we look over here at its hint property, we can see it starts out with an @ symbol followed by the word string, so that tells us that we're using a string resource and the name of the resource is note_title_hint. Strings are a type of value resource, so we look over here in our Project window, we have our values folder, and then within that folder, we have our strings file, so now we're going to select that file, and then here within the file, we have each of our resources along with our corresponding values. So we can see that we have our entry for our note_title_hint resource and we also have an entry for our note_text_hint resource. And as we talked about it earlier in the course, using string resources provides a number of advantages of using string literals. Now one of the key advantages is that string resources simplify the task of adding multiple language support to our app. So notice here near the top of the screen, we have this message edit translations for all locales in the translations editor. So what that's telling us, we can create variations of our string resources that are associated with different locales, and then within those resources, we can associate the appropriate localized text. So by doing that, our output to display the appropriate localized text based on the locale settings of a user's device. So let's try it out. We'll go up here where it says open editor and we'll click on it, and by clicking that link, we've opened up the translation editor. Now let me just close the Project window so we can see a bit better. So now if we look here at the translation editor, the left most column labeled Key is our resource name. Then the column labeled Default Value is a value of each resource as defined in our default string resource file. Now currently, we only have default values, so the default values we used no matter what a user's device locale is set to. We can, however, add values for specific locales, and then by doing that, we'll enable our app to appeal to a broader set of users. So let's try it out. Up here near the top left, we have an image of a globe and click on that image will allow us to select another language that we'd like to add support for. We'll go ahead and click on the globe and we'll scroll down a bit. So now I've scrolled down here to where we have the entry for Spanish, so let's go ahead and select Spanish. And now you can see here that we have another column displayed and that column is labeled Spanish. And what Android Studio is actually doing is creating a new string resource file that's associated with Spanish. Now we can see that by checking out apps resources. So let's open up our Project window and we can see here under the strings that we now have two entries. The first entries are a default string resource file and the second one, the one labeled with es in parentheses, is a string resource file associated with the language Spanish. So now if we double-click on the Spanish version of our string resource file, we can see that its only entry is a string resource associated with our app's name, so it's our responsibility to provide the resource values and we can do that within our translation editor. So let's go ahead and close this file. So we're back here in our translation editor. So now to set the translated values, we can select the desired resource in the top section here and then we enter the translated value for that selection using the bottom section. Now for simplicity, I'll just add Spanish translated values for those resources that are displayed within our note activity. So I'll start with the hints for the note text and the note title. Now you can see up top here that I've already added the value for the note text hint, and I currently have the note title hint selected, and down below, I've entered its Spanish value. So with our two hints set, let's go ahead and scroll down a bit. So now we've scrolled down to and selected the resource for the note activity title. Let's go ahead and add the translated value, and so now, we have Spanish translated values for the note text hint, the note title hint, and the note activity title. So with that, any time our app is run the device that has a language setting of Spanish, we'll display the Spanish values for those three strings. So in our next clip, we'll run our app and we'll see how things look.

Verifying Localized Text Behavior
So here we are now with our app up and running and we have our note activity open. Now currently, our app is using the default values for our string resources. So of course, the question is, how do we see what things would look like on a device that had a locale that uses Spanish. Unfortunately, the Android emulator includes a solution for that. Let's go ahead and minimize our app, we'll open up our application launcher. So you can see here, we have an app labeled Custom Locale, let's go ahead and select that app. And what this app does is allow us to change the locale settings of our emulator. Now if you look here at the top, it shows what our current locale setting is. We're currently set for English United States, but then down below here, we have a list of other locales that we can select from. So let's go ahead and scroll down here a bit. And you can see once I've scrolled down, one of the options we have here is Spanish, so let's go ahead and choose that. And then down below here, we have a button labeled Select ES, and if we click that button, it will switch our emulators locale to the locale that we just chose, so let's go down here and click that. So now if we look up top, we can see our current locale is Espanol. So let's switch back to our app, so I'll click over here so I can see the apps, I'll choose our app, and what happens is that because the device just experienced the configuration change, Android went through the process of destroying and recreating our note activity. And now that it's been recreated with a device set to a locale of Spanish, for the other strings that we've provided Spanish values, the Spanish values are being displayed. So we look at our activity, up top here, we have our activity title displayed in Spanish, and if we look at our edit text fields, we have the hints for both the note title and the note text displayed in Spanish and that easily we're now providing Multilanguage support in our app. The key point to remember is that we used resources to specify our string values, and by doing that, we were able to easily provide translated values for each of those strings and then enable our app to support those various languages. Alright, so we're all set here. So now in our next clip, we'll take a closer look at how resources are stored and we'll also see how to provide graphics that work effectively with differing screen pixel densities.

Drawable Resources and Device Screen Density Differences
We introduced drawable resources earlier in the course series and drawable resources are used for pretty much anything that can be drawn to the screen, use them for things like the images on our menus, images on a navigation drawer, the icon on the status bar, an image in our notifications, all those sort of things. As we talked about earlier, there are two general types of drawable resources. There are vector drawable resources and those are scalable vector graphics so they adjust to differences in screen density and they work well for simple graphics. The other kind of drawable resource is raster and those are our non-scalable graphics files and those are the image files that we're generally most familiar with, things like PNG files, but can also be JPEGs or GIFs. Now as we've mentioned, Android supports a really rich universe of devices and there will be a wide variety of pixel densities supported by those devices. Some devices might be relatively low density, some devices may be relatively high density, and there will be all kinds of devices in between and that presents a challenge when working with raster graphics because raster graphics don't scale well. When you try to scale them up, they stretch and tend to lose their quality. So we have a PNG file that's a 100 by 100 image and we render that on 160 dpi device. It may look really good quality, but now if I want to render that same image on a device that has twice as high of a screen density, but still have the image appear to be about the same size, that 100 by 100 image has to be stretched to 200 by 200, and as part of that stretching, it'll begin to lose some of its quality. And if I want to render it on a device that still has twice as high of density again, that original 100 by 100 image has to become a 400 by 400 image if I want it to appear to be about the same size when rendered on screen. And so, as I'm scaling up the image, it keeps losing image quality. So what we really need to do is have different images for each screen density. Now as we've seen throughout this module, Android gives us the ability through resources to deal with different device configurations and screen density is one of those configuration issues. So Android categorizes devices by their screen density and each screen density has a different drawable folder within our project, so what that allows us to do is create different versions of each of our graphics files sized appropriately for the different screen densities. So what Android does is it divides devices into different screen density categories. Each of those categories corresponds to a specific number of pixels per inch, and then for each of those categories, our projects include a corresponding drawable folder. So for example, we have the category mdpi or medium density and many of the early Android devices were mdpi devices and those are devices that have approximately 160 pixels per inch, so the corresponding drawable folder is drawable-mdpi. So the version of any graphics file we create that's targeting devices with screen density of 160 pixels per inch, we put that file into our project's drawable-mdpi folder. So now our next category is hdpi or high-density devices and those are devices with approximately 240 pixels per inch. The corresponding drawable folder there is drawable-hdpi. And then we have our extra high-density devices and those are devices with about 320 pixels per inch, our drawable folder is drawable-xhdpi. And then we have extra, extra high-density devices and those are devices with about 480 pixels per inch. And then we have our extra, extra, extra high-density devices and those are devices with about 640 pixels per inch. So when we create our projects, we're going to have versions of each graphics file that corresponds to the device categories that we want to support. So to help us get a better understanding of all this, in our next clip, we'll add some appropriately sized images to our project.

Understanding the Device Screen Density Challenge
So here we are now with our app running in the emulator and we're currently looking at our app's note reminder notification. So what we want to do now is start looking at how to provide drawable resources that are size appropriately for the various screen densities supported by Android devices and we're going to use our note reminder notification to help us do that. So looking at our notification, we can see that it has two pieces of content that are created from drawable resources. We have the small icon here in the top left, and we have a larger image for the Pluralsight logo over here on the right. So now thinking back to earlier in the series when we added the code to display the notification, we specified the small icon as part of the process of using Android Studio to generate the class that handles notification display details. So Android Studio took care of adding the drawable resources for that small icon to our project. But in the case of the Pluralsight logo, we added the image file for that resource ourselves, and at the time, we provided the image file in only one size. So now to assure that our logo always looks crisp and sharp no matter what our devices screen density is, we need to add a logo image to our project in a few different sizes. So now to get us started, let's head over to Android Studio. Here we are back in Android Studio and we're currently looking at our apps note reminder notification class. This is the class that handles the details of creating and displaying our notification. Now to include our logo in the notification, we first used a Bitmap factory class, and as part of working with that class, we specified the drawable resource for our logo. And then once we have the bitmap, you can see down here that we include the logo in the notification with this call to setLargeIcon, but remember that in addition to the logo, we also have a small icon and we specify the small icon here in this class as well. In the case of the small icon, the name of the drawable resource is ic_stat_note reminder. So let's see what these resources look like over in our Project window. So now as you can see here, I currently have the Project window set to display using the Android view, and then down here in the Project window, we have our resource drawable folder, and then down near the bottom of the drawable folder, we have our logo resource and there is that the logo resource doesn't have any specific screen density associated with it. And as we've talked about in a previous clip, when we're dealing with PNG files and similar raster graphics files, we want to create specific sizes for each supported screen density. So now before we add additional drawables for our logos resource, let's take a look at the resource for our notification small icon. We can see that resource here just above our logo resource and that's our ic_stat_note_reminder resource and notice that it has the number 12 to right of it and that tells us that when we use the Android Studio to generate our notification helper class that Android Studio added 12 variations of that resource to our project. So let's expand ic_stat_note_reminder and see what's there. And let's go ahead and widen our Project window, and when we expand it, we can see that there are variations for different screen sizes. For example, we have the one marked mdpi and that's for our medium density devices, then we have the hdpi version, that's for high density devices, and then the same thing for extra high density and extra, extra high density. Now in the case of ic_stat_note_reminder, there are also some additional variations listed and those are to handle different notification icon requirements of various Android versions. Now those issues are specific to notification small icons. For our logo, we don't have to deal with those issues. We can just focus on the different screen densities, and we'll start doing that in our next clip.

Drawable Resources and Project Structure
Here we are back in Android Studio and we're continuing in a process of adding the appropriate drawable resources for our Pluralsight logo so we can use them with our note reminder notification. Now for most resource types, we generally create the resources directly within Android Studio, but when we're dealing with image files, that tends to be different. When it comes to image files, those files are generally created by the graphics folks on our team. Then what we do is just add those image files into our project. So to get us started, let's switch over to the before folder from the exercises for this module. So now here in our before folder, there's another folder named logo images. Let's head into that folder. And then here within our logo images folder, we see there are several other folders and each of these folders are named based on a size. What we have in each of these folders is our logo image at a different size. So let's head down to our folder named 64x64 and what we have in here is our logo. png file sized at 64x64. So this is the version of the logo that we'll use with medium density devices. So let's go ahead and pop back up, and then below the 64x64 folder, we have another folder named 96x96, let's head in there. And what we have in here is our logo. png file sized at 96x96. Now 96 is 50% larger than 64 and high-density devices have a resolution that's 50% higher than medium density devices. So this logo file is the one we'll use on high density devices. Let's go ahead and pop back up and this sizing process continues. So for example, extra high-density devices have a resolution that's twice as high as medium density devices. So instead of using 64x64, for extra high density devices, we'll use the images inside of our folder named 128x128. So what we always want to do is make sure we have the appropriately sized versions of our images for each of the screen densities we want to support, and then once we have that, what we can do is copy the appropriate logo. png file, into the corresponding drawable folder within our project. So let's head back over to Android Studio. So now we're back here in Android Studio and we're ready to start the process of copying the logo files into the appropriate resource folders in our project, and as we talked about, we need specific drawable resource folders for each screen density. So for example, we need a drawable-mdpi for medium density devices, we need a drawable-hdpi for high density devices, and so on. Let's go over here to our res folder, and we'll right-click, we'll choose New, then new gives the option of Android resource directory. Now creating a new Android resource directory sounds like what we want to do, so let's go ahead and choose that. So we want to create this new resource directory, now first, we want to make sure we have the right type. So here where it says resource type, we'll choose drawable. Then we have that list of available qualifiers. Let's scroll down a little bit. And then here under qualifiers, we'll choose density and we'll click the double arrow to select it, and then for a specific density type, we'll select medium density. And then up there at the top of the dialog, we add that field directory name and we can see the name of the directory it's going to create is drawable-mdpi and that's the name we want, so let's go ahead and hit Enter to create it. And when we do that, we get an error, and notice what the error message is, it says that our resource folder drawable-mdpi already exists. So the question is, what's going on? So let's close this error message and the new resource directory dialog and let's see if we can figure out what's going on. So now looking at our Android studio Project window, if we look at our res folder, we can see the drawable folder underneath there, but there is no drawable-mdpi folder listed. So if there is no drawable-mdpi folder, why did Android Studio tell us that it existed when we tried to create it? Well the issue has to do with the Project window view that we're using. Remember that we currently have the Android view selected and the Android view is basically a convenience view. It shows us a folder structure tied to the way we generally work as Android developers, but that view doesn't fully reflect our project's physical folder structure. Now most of the time, the Android view is the most convenient way to work, but every once in a while, it's helpful to be able to see the physical folder structure, and in our next clip, we'll see how to do that.

Adding Density-specific Drawable Resources
Here we are back in Android Studio and we're finishing up the process of adding up the appropriate drawable resources for our Pluralsight logo, so we can use it with our note reminder notification. Now we're currently looking at the Project window of our app displayed in the Android view, and as we mentioned in the previous clip, the Android view is the view we tend to most commonly use, but it doesn't fully reflect the physical folder structure of our project, and every once in a while, it's helpful to be able to see that physical folder structure. So to do that, let's select a different view. So we'll click on Android and then we'll come down here and we'll select Project, and when we do that, we switch to the Project view and the Project view more closely represents the physical structure of our project. So let's expand this top entry here labeled the NoteKeeper and we'll come down here where it says app, we'll expand that, and then we'll come down to here where it says src, then we'll expand that, then under src, we have main, we'll expand that, then here under main, we have our resource folder, the folder named res, so let's go ahead and expand that as well. And then when we expand that res folder, now we can see our drawable folder, but in addition to the regular drawable folder, we can also see other drawable folders. So let's scroll down a bit. So now you can see here, in addition to the regular drawable folder, we also have drawable-mdpi, drawable-hdpi, drawable-xhdpi, and so on. So question is, what's going on here? Well it turns out that whenever we create a resource and associate it with a particular device configuration characteristic, what actually happens is that a version of the resource folder qualified by that characteristic is created and then the resource file gets placed into that folder. So when we generated our notification helper class, it created these various drawable resource folders and placed appropriately sized versions of the ic_stat_note_reminder resource into those folders. So when we go here to the drawable-mdpi folder and we expand it, we see the ic_stat_note_reminder file sized appropriately for medium density devices. And then we head up here to the drawable-hdpi folder and we expand that. We see the ic_stat_note_reminder file sized appropriately for high-density devices and this is true for the various drawable resource folders and the same idea of characteristic qualified resource folders applies for all the resource types. So if you notice down near the bottom of the screen, we have that layout-land folder, and if we expand that, we see the landscape variation of the content area of our note activity that we created earlier in this module. So of course, the question now is how does understanding this resource folder structure help us with the problem we're trying to solve. We want to add appropriately sized logo files to our project. Well it turns out all we have to do to do that is simply copy them in. So let's switch back to the folder containing our image files, we'll navigate into the 64x64 folder, we'll go to our logo. png file, right-click, choose Copy, and since this is the version of the logo file that we want to use with our medium density devices, we can head over to the drawable-mdpi folder, we'll right-click, and then we'll choose Paste. And then once we do that, Android confirms the file name that we want to use and where we want the file copied, so we'll just hit Enter to accept everything, so that copies that file into our project. Let's head back over to our image files folder, we'll pop up, we'll go to our 96x96 folder, we'll right-click, we'll choose Copy. This is the one we want to use with high density devices, so we'll head over to our drawable. hdpi folder, I'll select that, and this time, I'll just do CTRL+V. That pastes it in, I'll hit Enter to accept everything, and so now we have the version of the file we want to use with high density devices in our project and we would do this same process for each individual screen density. Now one important thing to note, in this particular case, we had all the variations of the drawable folder that we needed and that was because Android Studio had created those folders when we generated that notification helper class. Now depending on what you've done in your project, you may not already have all the various drawable folders that you need, so at any time you need a drawable folder for a device configuration and you don't already have that folder, you can create that folder by right-clicking on the res folder, choosing New, and then selecting Android resource directory, and then specifying the screen density that you want to create the drawable folder for. Alright, so we're doing pretty well here. Let's see what our project now looks like when we look at it in Android view. So we go up to here, we'll select Project, we'll go down here to Android, we'll select that. And now under our res folder, if we look at the entry for logo. png, it actually has a 3 next to it, so we head down there and expand it, we see the three versions that we have there, we have our default version, one labeled mdpi, and one labeled hdpi. So the mdpi and the hdpis are the versions that we just added. So now before we wrap up, let's see what happens if we try to paste one of our logo files in using this Android view of the Project window. So we'll head over to the Windows folder containing our files, in this case, let's go in to the 128x128 folder, this will be the 1 we use with extra high-density devices, so right-click, we'll choose Copy, we'll head over to our drawable folder, I'll right-click here, and I'll choose Paste. And notice Android Studio prompts me for which drawable folder I want to use. So this is for extra high density devices, so I'll choose the drawable-xhdpi, then I'll hit Enter. Android Studio prompts to confirm the name and the folder, I'll hit OK. And now, notice that logo. png has a 4 next to it. If we head down there and we expand it, we can see we now have our xdpi version there as well. So that shows us that both the Project view and the Android view are useful for adding these image files. The Project view allows us to see the actual physical structure of our project and that in turn allows us to easily determine which resource folders already exist, but then once we knew we had the resource folders we need, we could add the image files using the Android view because Android Studio would prompt us to select a specific resource folder to use. So with that, with just a little bit of copy and paste, we were able to add screen densities specific versions of our logo files to our app and the same process will work for any other image files that we need to add to our applications.

Summary
To wrap up, here's one of the key things you want to remember from this module. Remember that resources allow us to externalize our content from our code and this simplifies incorporating adaptability into our applications and that's important because Android supports a very rich device ecosystem and those devices out there will have a broad set of differing characteristics. So by using resources, we can associate the resources with specific characteristics. So then when our application is run on a particular device, Android will take care of selecting the appropriate resources for that device. Now remember that some of those device characteristics can change at Runtime, and when that happens, Android will destroy our activity and then recreate it with the appropriate resources. So it's important that our activities always properly handle the situation of saving their state and restoring it and one of the situations where this commonly comes up is in our activity layouts because remember that we often create different layouts for device orientations or device's screen size and you always want to be sure to keep the IDs consistent of the views in those layouts because remember that's those id values that our code relies on to interact with the views. We always want to be sure that any text that appears in our application's UI is contained in string resources because by using string resources, it simplifies adding Multilanguage support to our app because remember that devices have a language specific locale and by associating a string resource with a specific language and the user is running our application, Android will take care of displaying the appropriate strings for that language. Now an area where we commonly use characteristic-specific resources is our drawables because remember that raster graphics don't scale well, so things like PNG files don't scale well, so we want to be sure we have appropriately sized versions of those files for all the screen pixel densities that our app supports. And remember the physical structure of our project resource folders reflect the characteristics associated with those folders and we can see that physical structure by switching the Android Studio project window to use the Project view. And seeing that characteristic specific structure can be really helpful when we're doing things like copying drawables into our project. Well alright, that wraps up this module. In our next module, we'll learn how to create custom views and how to incorporate those views into the Android Studio designer.

Creating a Custom View
Introduction
Welcome to our next module, Creating a Custom View. This is the Pluralsight course, Broadening Android App Appeal and Reach. My name is Jim Wilson. Android includes a powerful and rich set of view classes, but sometimes, you want to provide features, capabilities, or appearances to go beyond what's provided by the built-in view classes. Custom views allow us to do that. So we'll start out with an overview of custom views. We'll then see how to add a custom view class to our project using Android Studio. We'll then look at how to provide the custom appearance for our view. Now a key part of providing that appearance is properly calculating our drawing positioning, so we'll look at that next. And then we'll finish up, we'll look at the details of performing our custom drawing.

Custom Views
Views are at the heart of providing our Android application user experience and Android includes a very rich set of view classes, but sometimes, we want to move beyond those built-in view classes and in Android we can do that because views can be customized. Most of the view classes can be extended. So we can create a new class that extends the Edit Text class. We can create a new class that extends the Spinner class, we can do those sort of things. And this new class we create can do things like add new methods to simplify common usage scenarios. So you're thinking of the idea of using a spinner to display the list of courses, well that's something we did frequently, we could add a new method to our class that accepted a cursor and then that method would take care of the details of displaying the course information within the spinner. So now in addition to creating new methods, we can also override existing methods and customize their behavior as well. So what this allows us to do is create specialized versions of these existing Android view classes. But now sometimes we're creating custom views rather than building on the capabilities of the existing classes like edit text or spinner, we want to take much more control than that and that's where fully customized views come in. In the case of fully customized views, we actually extend the View class itself, so what that means now is that we're creating a new class that kind of plugs into the view architecture of Android, but doesn't really provide many capabilities of its own. So what we can then do is take over from there. So taking this approach gives us full control over our view's appearance. In addition to having full control over its appearance, we also have full control over its behavior. So we're creating a view and we define what it looks like and how it behaves and we can even do things like include custom events so we can interact with our activity in a way we define. So these fully customized views, in effect, give us the ability to create brand new kinds of views and fully customized views are going to be the kind of custom views we focus on in this module. So let's see how we could use a fully customized view in our application. So we have our note activity. Remember that in our note activity, we're keeping notes related to a course. Well courses are made up of modules, so it will be nice to have module information as part of these notes. Like it'd be great to know how many modules a course has and which ones I've completed. So that's what we'll do, we'll create a brand-new view called ModuleStatusView, this will be a fully customized view, so this custom view will appear on our activity and it will show the number of modules and which ones we've completed. Now in order to do that, we'll of course, extend the View class and we will add a method called setModuleStatus and setModuleStatus will accept a Boolean array and what we'll do is use the size of the array to determine how many modules a course has. So if we pass in a five-element Boolean array, we know it has five modules, so we'll draw five circles to indicate that there are five modules. And then the way we'll indicate which modules are complete is by true values. Alright, so for each element of the array that has a value of true, we'll fill in that circle with orange and then the filled in circles will indicate the modules that we've already completed. So what we can then do is take the ModuleStatusView class, place it on our note activity, and then in our Java code, pass in the Boolean array and all the work of displaying the view is handled by the custom view itself. We'll draw the appropriate number of circles based on how many elements the array has and we'll fill in all the circles for elements that are set to true. So to get us started, in our next clip, let's go ahead and create this new ModuleStatusView class.

Adding a Custom View to the Project
Here we are in Android Studio and what we want to do now is add a custom view class to our project. So now to create a custom view class we click up to the File menu and choose New or from right here in the Project window, we can right-click on the package name, we'll choose New, and then from here, we'll choose UI Component. And then once we have UI component, we'll go over here to where it says Custom View and select that. Now we, of course, need to give our custom view class a name, and as this message down here indicates, we can make the class name pretty much anything we want, but we normally want to end the name with the word, View. Since we're using our custom view class to display module status information, we'll make its name ModuleStatusView. So now once we've specified the name, we're ready to create the class. So I'll go ahead and hit Enter and let Android Studio do its work. Now when we created our Custom View class, Android Studio actually added two files to our project. You'll notice this tab here, this is the Java class that actually implements our custom view and we'll take a look at that guy in just a moment. But the other file that Android Studio created is this sample_module_status_view. Now this is a sample layout file and the only view the sample layout contains is our new custom view. So with this file, we can see just how the changes we make to our custom view affects the view's appearance. So now if we look over here in our Project window, we can see that sample_module_status_view file is part of our project much like any other layout resource, but if we wanted to, we could delete the file because we don't need that file for our custom view to work, but let's go ahead and keep it around for now because it's a great way to quickly see how the changes we make to our custom view affect a view's appearance. Now to see our sample layout a bit better, let's go ahead and close the Project window. Now looking here at the sample layout, notice that we're getting an error, and if we look down below here, we can see that the message says that the class we just created ModuleStatusView can't be found. Well it turns out, this is a pretty easy fix. All we have to do is build our project. So we'll go here to our Build menu and we'll choose Make Project. And now once the build completes, our error message is gone and our view now renders properly. Now the current appearance of the view is due to the code generated by Android Studio and all it's basically doing is drawing a drawable resource and displaying some text. We'll change the appearance to match our needs shortly, but the key thing to know here at this point is that once we did the build, our view is able to display without any errors and that's what we were going for. So now let's take a look at the Java code for our custom view. So here we are now looking at the Java code for our ModuleStatusView class and we can see here that our class directly extends the View class. And as we mentioned earlier, by directly extending the View class, we're creating a fully customized view, and as a result, we're responsible for all aspects of our view's appearance and capabilities. Now remember that the appearance and capabilities of our view are tied to the modules in a course, and as we've talked about, we'll be using a Boolean array to store that information. So let's go ahead and add a private field named mModuleStatus, we'll make it a boolean array. Now the Java code of the activity that uses our view will need to be able to set the status array and retrieve it, so let's go and add a getter and setter for it. So we'll right-click, we'll choose Generate, we'll then choose Getter and Setter, now the dialog already has mModuleStatus selected so we'll go ahead and hit Enter, and that gives us both our getter and our setter. So with our class generated and the ability to get and set the module information, we have the starting point for our custom view. So in our next clip, we'll start looking at how to customize our view's appearance.

View Appearance
Now that we've created our custom view class, we're now ready to provide our view's appearance and we provide our view's appearance by drawing. Now remember that we're creating a fully customized view, so we're going to be responsible to provide all aspects of drawing the appearance of our view. So now when it comes to drawing the appearance of our view, there are four questions that we have to address, when to do the drawing, where to do the drawing, what to draw, and how to draw it. Now when to draw is pretty straightforward. The View class has a method on draw and we'll override that onDraw method and the system will take care of calling our onDraw method whenever it's time for us to render our user interface. So within this onDraw method is where we're going to do all of our drawing and when the system calls the onDraw method, it passes in a reference to a type known as a canvas. Now the canvas type is a key part of answering the where question because the canvas serves as the target of our drawing so it's a surface that we're going to draw everything onto, and then within that canvas, we're going to position the individual items. So all of the items are drawn within the bounds of that canvas and we're going to provide our positioning using pixels within that canvas. And the canvas type is also a big part of what to draw because it provides a variety of methods that will allow us to perform our drawing. So if we wanted to display some text, the Canvas class has a drawText method. If we wanted to display a bitmap, the canvas class has a drawBitmap method. And if we wanted to display individual geometries, things like lines, squares, or circles, there are methods, drawLine, drawSquare, or drawCircle. And there is actually a whole bunch of other geometry-based drawing methods within the Canvas class. But now simply knowing what to draw doesn't really answer the question of how to draw it. So the paint type is where we specify how to draw things and a key part of using paint is specifying the color. Do we want it to be a black line or a yellow line or an orange line and there are a number of other characteristics we can provide to paint as well and we'll see those in just a second. Now when we create an instance of the paint type, we'll generally create it specifying something known as anti-aliasing. And all anti-aliasing means is that we want the system to smooth the edges of any lines, so when we draw things like curves, we don't want the pixels to create rough edges. So anti-aliasing tells the system to go ahead and smooth out those edges for us, and in general, we will want to specify anti-aliasing when creating our paint objects. Now the additional characteristics that we provide to the paint object depend on what we're drawing. So we're drawing text, there will be a number of characteristics we use for that. So things like what's the size of the text, the exact the spacing, the alignment, do we want to use effects like underline or strikethrough, what typeface do we want to use, other words, what font, do we want it to be bold, that sort of thing. The Paint class also includes helper methods for displaying our text, so we can do things like measure how large a string is going to be, get the metrics of our font, those sort of things. And there is a class called TextPaint that extends the Paint class and it does include a few additional fields beyond what's in the Paint class, but the Paint class is actually the work horse of drawing text. Now you can use the TextPaint class anytime you're drawing text since it inherits from paint, it's valid to pass it anywhere a paint is expected, but it's just helpful to remember that it's the Paint class that does the bulk of the work because you'll see that most methods that draw text actually expect a paint reference rather than explicitly expecting a text paint reference. Now when it comes to drawing geometries, we're going to provide other characteristics and one of the most important characteristics for drawing geometries is the paint style, do you want it to be a fill style or a stroke style. A fill style says I want to fill the shape in, so if I draw the square I want it fully filled in. The stroke style basically says I want to draw the border, so when I draw the square, I don't want to fill it in, I just want to draw its border. When I'm using the stroke style, I need to identify the width of the stroke over to how many pixels wide do I want the stroke, and if I'd like to, I can also specify effects like drawing the line as a dash and so forth. Alright, so with these general ideas about drawing our user interface in mind, in our next clip, let's plan out how we're going to draw our custom view's appearance.

Planning the View Appearance
So when it comes time to draw the appearance of our view, the system will call our onDraw method and passes in a reference to the canvas. So that canvas is the general answer to the where question. We're going to draw everything onto that canvas, but then we need to identify the positioning of the individual shapes within the canvas. Alright, so one thing we have to identify is the size of the shape we want to draw and let's say for now, we'll draw all of our circles within 144-pixel area. So that basically gives us the rectangle of where we want to draw the first circle. But now, of course, we need to draw multiple circles because courses have multiple modules. So we'll identify the spacing between each of the module circles. We'll say that's 33 pixels, so that'll give us the rectangle in which to draw the circle for the next module and I want to repeat that for all the modules in a course. So what we can do is calculate out all these rectangles and then we'll store them so each time we're drawing, we can simply used the stored rectangles rather than have to recalculate them every time. So now of course, the next question is, what do we want to draw? Well, we want to draw a circle. So if we're going to draw a circle, how do we want to draw it. Well we actually need to draw that circle two different ways. First of all, we need the outline, so we'll create a paint object for the outline, we'll specify its style is stroke, we'll give it a color of black, and we'll say that the width of the stroke is 6 pixels. So with that paint object, we can draw a circle within that first rectangle and then we can repeat that within each of the individual rectangles and that would give us the circles for each of the modules within the course, but remember that for the modules that are already complete, we want to fill in the circles. So we'll create another paint object, we'll go ahead and give this one a style of fill and we'll specify its color is orange. So this paint gives us a different how, it's different from the how we used for the outline, but we're still using the same what and where. So when we call drawCircle for the first rectangle, it'll fill that one in, and then we would walk through and fill in the other circles for any other modules that are complete. Alright, so that's the plan for what we want to do. In our next clip, let's start implementing this behavior.

Calculating the Drawing Positioning
Here we are back in Android Studio and what we want to do now is begin the process of adding drawing behavior to our custom view by calculating the positioning information that we'll need. Now we're currently looking at our custom view class, ModuleStatusView. Before we begin adding any drawing code, I'm going to first do a quick bit of clean up. When Android Studio created our ModuleStatusView class, it included some sample drawing code. I'm going to remove all that sample code just to avoid any confusion with the drawing code that we'll be adding. Alright, so that removes all the sample drawing code. So now we're ready to start adding our own drawing code. So now to get us started, let me just scroll down a bit so we can see all of our class constructors. And now that we've scrolled down, you can see that our custom view class includes three constructors. We'll talk a bit later about why we have three separate constructors. The thing I want to point out now is this call to the init method. Notice that all three constructors call the init method. Now there is nothing special about the method name init. We're not overriding a base class method or anything like that. What's important about the init method is that it's the method where we're going to do our view's initialization work. Remember that it's in our onDraw method where we do the actual drawing for our view, and at runtime, a view's onDraw method may get called quite frequently. So with that being the case, we do as much drawing prep work as we can when the view is initially created and that helps to assure that our onDraw method is as fast and efficient as possible and we'll do that prep work in our init method. So let's scroll down so we can see the init method a bit better. So here we are now in the init method and the first thing we want to do in here is set up some of our sizing values. So we'll start by creating a variable to specify the width of the outline that we want to draw around each of our circles. So we'll name the variable outlineWidth, it will be of type float, and we'll give it a value of 6 pixels. So now for the size of each the shapes we'll be drawing, we'll create another float variable. We'll name this one shapeSize, we'll give it a value of 144 pixels. And then for the spacing between each of our shapes, we'll declare a variable named spacing with a value of 30 pixels. Now we'll be needing these values in a few places, so let's go ahead and promote all three of these variables to be fields. Now once we have these values, we can create the list of rectangles that we'll use to position each of the circles when it comes time to draw them. So to do that, let's call a method we'll create named setupModuleRectangles, we'll do an Alt+Enter to create it, we'll hit Enter, and we'll accept the return type. So now to store the rectangles, we use an array of type Rect and we'll name the variable moduleRectangles. We'll create a new rect array instance and the size of the array will be whatever the size of our ModuleStatus array is. We'll go ahead and promote that variable to be a field. So now that we have the array for our rectangles, let's create a loop so we can populate the array. So now the first thing we'll need for each rectangle is the position of its top, left corner. So let's declare our local variable of type int named x. Now x will contain a position of the left edge of the rectangle for the module. So we'll first need to calculate how much space each module needs, so that will be the sum of our shape's size plus the spacing that follows it. So that gives us the space we need for a single module, but now to figure out the positioning of each of the individual modules, we'll need to multiply that value by the module index. So for the first module, moduleIndex is 0, so we'll take the sum of the shape size and the spacing, which is 144 plus 30 and that will give us the sum of 174, so the left edge of the first module is 0 times 174, so its left edge is 0. And then for the second module, moduleIndex will be 1, so the left edge of the second module is 1 times 174 making its left edge 174 and this continues for each of the modules. So now once we have the left edge, we'll need the top edge. So we'll declare an int variable named y. So now the top edge of each of the module rectangles is the same. So let's just go ahead and set that value to 0. So now with x and y, we have the top left corner of the current rectangle. So with that, we're ready to start creating the rectangle. So we'll assign our current array element a new instance of the class, rect. For the first two parameters of the rect constructor, we'll pass in x and y. So that provides the left and top edges of the rectangle. So now the third parameter is the position of the right edge so we'll pass in x plus the ShapeSize. And then the fourth parameter is the position of the bottom, so we'll pass in y plus the ShapeSize. So now that easily we have the code to loop through and calculate the positioning information we need to draw the shapes that correspond to each of the modules. So now in our next clip, we'll add the code to set up our paint instances and draw the circles.

Drawing the Custom View
Here we are back in Android Studio and we're continuing our work of adding drawing capability to our custom view. Now we're currently looking at the init method of our ModuleStatusView class. Now in the previous clip, we calculated the positions of where we need to draw the circles within our custom view, so now we're ready to start creating the paint instances. Now remember that we'll be using two separate instances of paint, we'll use one to draw the line around the circle and then another to fill the circle in. So let's create the one for the outline first, but before we create the instance of paint itself, let's first create a variable to hold the outline color. So we'll declare a local variable of type int and we'll name it outlineColor and then we'll set its value to Color. BLACK and let's go ahead and promote that up to be a field. So that gives us our color. So now we can declare our local variable of type paint named paintOutline. Then we'll create a new instance of paint passing in the flag that indicates that we want to use anti-aliasing. And we'll go ahead and promote this to be a field as well. So now we're ready to start setting our paint details. Since we're using this paint instance to draw the outline of our circles, we'll set its style to be STROKE. So with a style of stroke, we need to set the stroke width. So we'll set our stroke width to be the value of our mOutlineWidth field. And then finally, we'll set the paint's color to be the value of our mOutlineColor field. So that takes care of the paint instance that we'll use to draw the outlines. Now we're ready to create the one that we'll use to fill in our circles. Now for this instance, we want the color to be orange. Now as you may recall from earlier in the series, we created a color resource called Pluralsight orange, so I'll just use that for our color value. Let's first declare our local variable of type int named fill Color. So now in order to access our resources, we need our context, so we'll call getContext, then we'll access the resources by calling getResources, and then finally, we'll get our color by calling the getColor method and we'll pass in the value for our Pluralsight_orange color resource. So now we have the value for our Pluralsight_orange, so let's go ahead and promote this up to be a field. So with our color value in that field, let's go ahead and declare a new paint variable, we'll call it paintFill. Then we'll go ahead and create a new paint instance passing in the flag for anti-aliasing. We'll promote our variable to be a field. So now we're ready to set our details. Now in this case, we're going to use the instance to fill in the circles, so we'll set its style to fill. And then finally, we'll set its color, we'll set that to the value of our mFillColor field. So now, we have both of the paint instances we need. The first one we created we used to outline the circles and then the second one we created we used to fill them in. So now we're ready to do the actually drawing. So scroll down to our onDraw method. So here we are now in the onDraw method and this is where we do the actual drawing work. Now remember, the key part of doing our drawing is positioning each of our circles in their correct place. So in order to do that positioning work, we'll need to loop through that rectangle array that we created earlier. So the first thing we'll do here is create a for loop that counts for the indexes we need to access our mModuleRectangles array. So now to draw each of the circles, there is a few things we need to determine. The first is the x and y coordinates of our circle center point. So for the x coordinate, let's declare our local variable of type float named x and then we'll assign x the value returned by the center x method of our current rectangle. So that'll give us the x coordinate of the center of the current rectangle. So now I want to do the same thing for the y coordinate. So now we have the x and y coordinates of our center point. So the next thing we'll need to draw the circle is the circle's radius. So let's declare our variable of type float named radius. Now for our radius, we want to be sure that our circle, including the outline, stats within out specified rectangle. So for the radius, we'll subtract the OutlineWidth from the ShapeSize and then divide that by 2. So now with that, we have everything we need to draw our circles. So let's first draw the filled-in circle. Now remember that our onDraw method receives a canvas as a parameter, so to draw the circle, we use the canvas parameter and call its drawCircle method. And then to draw a circle, we'll pass in the values of x, y, and the radius. And then, since this is the circle that we're filling in, we'll pass in our field, mPaintFill. So now that takes care of drawing our filled-in circle. So now we're ready to draw the outline circle and we're going to draw this circle just like we did the filled in circle, the only difference is we're going to pass in our mPaintOutline rather than mPaintFill. And so now, whenever onDraw is called, we'll first draw our filled in circle and then we'll draw our outline circle. So our onDraw method is just about ready. We just have a couple more things we need to address. Now first, remember that we only want to fill in the circle when a module is complete. So the call that draws the filled in circle should actually be within an if and that if should check to see if the corresponding element of our mModuleStatus array is currently true. So now with that if in place, we'll only fill in the circle for those modules that are marked as completed. Alright, so that takes care of the details of the drawing. There is just one last thing we need to address. Remember we mentioned earlier that the onDraw method gets called quite frequently, so it's really important that we make the onDraw method efficient by doing as much work in advance as we reasonably can. Well with that in mind, let's look at our radius variable. Now we calculate the value for that variable every single time for every single circle in onDraw, but the thing is the value of radius never changes, it's the same for every circle, so we don't need to do that work here in onDraw. So let's go ahead and promote the radius variable to be a field, then we'll remove that line from here inside of our for loop, and now, let's scroll up to our init method. So here we are in our init method and you can see here where we set the values for our OutlineWidth, our ShapeSize, and our Spacing. So let's go ahead and assign the value for our Radius field here. And now, by doing the assignment here, we do the calculation only once where before we were doing it over and over again every time every circle was drawn. Alright, so with all the done, we now have our custom drawing behavior in place. So in our next clip, we'll check it out and we'll see how things look.

Verifying View Appearance Within Android Studio
Here we are back in Android Studio and we're just about ready to check out the appearance of our custom view. Now when we're using a custom view, we will, of course, be able to see its appearance at runtime, but remember, we can also see the view's appearance within the Android Studio designer because we'll see it when we're editing a layout that uses the view. And it's important to be sure that our custom view provides a reasonable appearance when we use it in a designer. So now we're currently looking at the setupModuleRectangles method of our ModuleStatusView class. Now remember that this is the method that calculates the positioning rectangles that we'll use to draw each of our module circles. The first thing we do in this method is create the array that we will be using to store the rectangles. Now notice that the size of the rectangle array is based on the size of our module status array. Well when our custom view is being used within a running app, the application code will take care of setting our module status array, but when we're using the view inside the Android Studio designer, there is no chance for the application code to set the module status array. So the question is, what do we do? Well let's scroll up to our init method and see if we can find a solution. So here we are now in our init method, and as we talked about earlier, this is the method where we do the initialization work for our view and it's actually very common when working with custom views to have to do some additional initialization work when our custom view is being used within a designer. In fact, the view class provides a method called isInEditMode that allows us to check to see if our view is currently being used within a designer. So let's add an if statement here that checks the value returned by isInEditMode. And if isInEditMode returns true, let's call a method we'll create called setupEditModeValues, we'll hit Enter to create the method, hit Enter, and we'll accept our return type. So here in our setupEditModeValues method, we'll do any extra setup work that's necessary when our view is being used within a designer, and the extra work that we need to do is provide status values that we can use to display an example what the view might look like at runtime. So let's declare a Boolean array here named exampleModuleValues. Now we can create this array to be any size we want. Let's give it a size of 7. Now that size of 7 has no special meaning, it's just an arbitrary size, but let's go ahead and make that literal value 7 a constant. So this constant, EDIT_MODE_MODULE_COUNT, has a value of 7. So now once we have this array, we can go ahead and pass it to our setModuleStatus method. So by adding this code, the appearance of our view the designer will be based on having seven modules. Now currently, all the module statuses are set to false and when we're providing a design to my appearance of a custom view, we want that appearance to be representative of the runtime appearance. So to provide a more representative appearance, let's then have the module status values to true. So to do that, we'll create a local variable named middle and we'll assign it the result of EDIT_MODE_MODULE_COUNT divided by 2. And then what we can do is loop through and set the values in the first half of the array to true. So with that code in place, our custom view's design time appearance will have seven circles, indicating seven modules, and the first half of those modules, which will be the first three circles will be filled in. So now with that, we're ready to see what our view looks like when viewed in a designer. So let's head over to the sample_module_status_view layout. So here in sample_module_status_view, as you can see, our custom view's appearance isn't quite what we would expect. It still looks just like it did before we added any of that new drawing code, and the reason is that we need to do a build. Remember that the designer is always going to use the most recent build of the custom view, so any changes that we make to the appearance of our custom view are not reflected in the designer until we do a build, so let's go ahead and do that build. I'll hit Ctrl+F9 and now that's a lot better. Our view looks much more like we would expect. We have the circle displayed for the modules and the first three circles are filled in, but there is a bit of an issue. We were expecting there to be seven modules and there are only six being displayed. If we look really closely, we can see part of the start of the seventh circle and it turns out that we are drawing seven circles, but the last one is getting clipped. So our custom view is off to a great start, but we still have a few issues to address and we'll see how to address those issues when we get into our next module.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that views can be customized because most of the Android view classes can be extended. So we can extend classes like edit text, text view, spinner, as well as most of the other view classes. And our new class can add additional methods, as well as override methods that it inherits from the base class. When we inherit from the higher-level classes like edit text, text view, or spinner, we're inheriting a great deal of functionality, but sometimes, we want to take even more control. We want to create a fully customized view. Now fully customized view normally extends the view class directly. and in the fully customized view, we're going to take full control over the view's behavior and we're going to take full control over the view's appearance. When we take full control of the view's appearance, we're responsible to do the view's drawing. So the first question that comes up is when do we do the drawing and that's where the view's onDraw method comes in. The system will call our onDraw method when our view needs to be drawn, so that's the method that will contain our drawing code. Now the onDraw method receives a reference to a canvas. And the Canvas class is an important part of our drawing because it addresses where to do the drawing and what to draw because the Canvas class serves as the target of our drawing and the individual items we draw will be positioned within that canvas and the Canvas class includes a number of drawing methods. So using the Canvas class, we can draw our text, we can draw bitmaps, or we can draw geometries. And then we have the Paint class and the Paint class addresses how to do our drawing because with the Paint class, we specify our color, as well as other characteristics we want to use when performing the drawing and the specific characteristics we provide will depend on what we're drawing, but in most cases, when we're doing our drawing, we want to use a Paint class instance that has anti-aliasing enabled. And remember that all anti-aliasing does is help our drawing have smoother edges and avoid rough pixelated edges. Alright, that wraps up this module. In our next module, we'll continue our discussion of custom views, and we'll learn how to properly handle view measurement, sizing, and positioning.

Handling Custom View Positioning and Sizing
Introduction
Welcome to our next module, Handling Custom View Positioning and Sizing. This is the Pluralsight course, Broadening Android App Appeal and Reach. My name is Jim Wilson. In this module, we continue our discussion of custom views. And so, we'll start out, we'll look at how our custom views are placed within a layout and how positioning is managed. We'll then look at how our custom views manage padding within their drawing area, we'll see what our custom view's responsibilities are in terms of indicating its needed measurements, and as part of that process, we'll look at how our custom view can actually make its measurements adaptable. And then by making our measurements adaptable, we can see how we can adapt a way our view is drawn so it can deal with variations in the available size.

Placing a Custom View and Positioning
With our custom view class created, we're ready to start placing that custom view within a layout and working with our custom view classes is very much like working with the built-in Android views and then we're going to put them inside of a layout resource and they'll normally be contained within some kind of container view within that layout resource, so something like a constraint layout or frame or something like that. And when it comes to specifying our custom layout within the layout resource, we have two choices for how we do it. One way is actually use an element name that's our actual class name. That element has to include the full package qualified name. So for our class, that would be com. jwhh. jim. notekeeper. ModuleStatusView. So we can use that class name as the element or we can use the built-in Android element view and that allows us to specify a particular class using its class attribute. So in this case, we would use the view element, we would include the class attribute on that element, and for the value of that attribute, we would include the package qualified name of our class. Now once our custom view is part of a layout, we get into the issue of positioning, and when it comes to the issue of positioning the custom view itself, that responsibility falls onto whatever container contains our custom view. So if we're positioned within a constraint layout, that constraint layout is going to manage the positioning of our custom view itself, so it will dictate where within the layout our custom view is positioned. But now within our custom view, that's now our responsibility, so where we draw those circles within the bounds of our custom view, that's our responsibility. And one of the key things we have to keep in mind there is that we're responsible to handle the padding within our custom view. Remember that the padding is the spacing that runs along the inside edge of a view, so we want to make sure that those module circles that we draw allow for any padding values that the user might specify. The way we get those values is by these getPadding methods. So we want the left padding, there is a getPaddingLeft method, with the bottom padding, there is a getPaddingBottom method and so forth. So to help us understand this a little better, in our next clip, we'll incorporate the handling of padding within our custom view.

Incorporating Custom View Padding
Here we are in Android Studio and what we want to do now is begin that proper handling for padding to our custom view. We're currently looking at the sample_module_status_view layout resource. And as you recall from the previous module, the only thing this layout resource contains is our ModuleStatusView custom view. If we look here at the appearance of our custom view in the designer, notice that the left edge of the left most circle is pressed directly against the left edge of the custom view itself. Similarly, the top edge of all the circles are pressed directly against the top edge of our custom view. So now the appearance of our custom view would probably look better if we had some extra space between the edge of the circles and the edge of the custom view and this is where padding comes in. Padding controls the amount of space along the inner edge of a view. If we look over here at our Properties window, we can see the section for padding, and notice that the paddingLeft property currently has a value of 20dp. And then for our paddingTop property, there is no value at all. So let's change paddingLeft and paddingTop to a fairly large value. Let's say we set both of them to 50dp. So now we've changed both of those properties, but if we look at the appearance of our custom view, the circles are still pressed against the left and top edges, so changing the padding didn't work. So let's head over to our ModuleStatusView code and see what we can do to fix things. So we're here in our ModuleStatusView class and we're currently looking at our setupModuleRectangles method. Remember that this is the method that calculates the rectangles that control the positioning to each of the circles that we draw. Remember that the x position is the value used for the left edge of each rectangle and the y position is the value used for the top edge of each rectangle. Let's start by looking at our y position. Notice that the y position doesn't take padding into account at all. Our y position is always set to 0 and the 0 position is the very top edge of the canvas on which we're drawing our circles. So by making every rectangle's y position 0, the top edge of every circle will draw directly against the top edge of our custom view. So rather than making the y position 0, we should instead make the value of the top padding, so to do that, we'll call the getPaddingTop method. So now with that change, the top edge of the rectangles we use to determine where to draw the circles are all now shifted down by the amount of the top padding. So now with our y position all set, we now need to do the same sort of thing for our x position. So our current x position calculation starts the left edge of the first rectangle at 0 and then each additional rectangle's left edge is increased by the sum of our mShapeSize and mSpacing fields. So what we need to do is change the starting position of the first rectangle's left edge from 0 to the amount of the left edge padding. So now, the first rectangle's left edge starts at the padding amount rather than starting at 0. And then for each additional rectangle, we increase the position used for the left edge by the sum of the mShapeSize and mSpacing just as we did before. And so now with that, we should be all set, both our top edge and our left edge should properly account for the padding. So let's head back to our designer and we'll see how things look. So we're back here at the designer and the positioning of our circles hasn't changed yet, but that's because we still need to build our project. So I'll do the build by pressing Ctrl+F9, and now, when the build completes, our circles are shifted down and to the right. So our position calculation for the circles is incorporating the padding. But looking at our custom view within a designer, using a paddingLeft and paddingTop value of 50dp is probably larger than we need it. So let's take our paddingLeft value and let's change that from 50dp to 10dp. I'll press Enter, and notice that our circles immediately shifted to the left, they're immediately incorporating that new padding value. So let's head down the paddingTop, we'll change that to 10dp as well, and I'll hit Enter, and that positioning changed immediately as well. So now, our custom view is properly incorporating both the left and top padding values when determining the positioning of where to draw the circles. So with that working, in our next clip, we'll add our ModuleStatusView to our note activity layout.

Adding the Custom View to the Note Activity
Here we are back in Android Studio and what we want to do now is add our ModuleStatusView to the layout resource for the Content area of our note activity. But now before we head over to our note activities layout resource, let's take a closer look at our sample_module_status_view layout resource. So what we'll do is go down here to the bottom where you have that tab that says text, we'll select that. Now as you recall, this resource file was created by Android Studio as part of generating our custom view class, and as we can see here, the XML element that was used to add our custom view to this layout is our custom view's package qualified class name. So this shows us that anytime we're working with a custom view, we can use the custom view's package qualified class name as the XML element to add that custom view to the layout resource. So now with that in mind, let's head over to our layout resource for the content area of our note activity. So here we are now in the default layout resource for the content area of our note activity and what we'd like to do now is add our ModuleStatusView to this layout just below the edit text field for the note text. Now normally, when we want to add a view to a layout, we just head over here to the Palette, find the view we want, then drag that view to be part of the layout. But the only thing is, if we were to look for our ModuleStatusView in the list of views here, we won't find it. Now one option we have is that we could switch over to this layout's text view and manually type in the tag for our custom view. In other words, we could manually enter that tag that was the package qualified class name for our custom view and that would certainly work, but it turns out there is an easier way. I'm over here in the Palette, we have our list of categories, and one of the categories is Advanced, so let's go ahead and select that category. And now within advanced, one of the available selections is named view. So let's go up and select view and then we'll drag it onto our layout. And when we do that, Android Studio prompts us to select a view class we'd like to use and right here at the top is our ModuleStatusView, so let's go ahead and select that, and then I'll hit Enter. And now, we can see our ModuleStatusView appear on the layout. So let's head down here to our tab that says text and we'll switch over to our layout's text view by selecting the Text tab, let's scroll down here a bit, and we can see here when we added the custom view using the designer, rather than using our package qualified class name as the tag, Android studio added it using the built-in view tag and then the view tag specifies our custom view class using the view tag's class attribute and giving it a value of our custom view class' package qualified class name. So that shows us we can include our custom view within a layout using either the view tag referencing our custom view class with the class attribute as the Android Studio designer has done here or we can use our package qualified class name as the tag and that's what Android Studio did when it generated our sample_module_status_view layout when it originally generated our custom view class. And either one of those is fine because they both work well. So let's switch back to our Design View. So now we're back here in the Design View and we're ready to position our custom view. And remember, the positioning of our custom view itself is controlled by the container in which we're placed. And if we look here at the Component Tree, we can see that our ModuleStatusView is located within a constraint layout so that means that we'll position our custom view using constraints. So let's start by anchoring the top edge of our custom view to the bottom edge of the edit text for our note text. And then we'll go down to our left edge and we'll anchor that to the left edge of the note text edit text. So now that takes care of our top and left edges, but now what about the bottom and right edges. If you take a look at the outline around our custom view, you notice you can't even see the bottom and right edges. And to understand why that's the case, we need to take a look at our Properties window. Let's take a look at the layout with and the layout hide properties and notice that both of them have a value of wrap_content, and with a value of wrap_content, the designer is expecting our custom view to indicate its desired width and height and the problem is that our custom view doesn't yet know how to provide that information. So in our next clip, let's see what we need to do within our custom view class to provide that desired width and height information.

Indicating Custom View Measurements
One of the key responsibilities of our custom view class is to provide our view's measurements and we do that by overriding the onMeasure method. And what we'll do inside of the onMeasure method is calculate the desired sizing for our view, but the size that we use has to fit within constraints that are placed on us because our view will only be given so much space within the layout. So our onMeasure method receives two parameters. Those parameters are the width and height constraints placed on our view. Now those values are received as integers, but they're received as what are called encoded integers. What that means is bit masking is used to put more than simply the size inside of that integer, so we can't use those integer parameters directly. What we do instead is take advantage of a class called MeasureSpec, it's a nested class within a view class that allows us to extract specific values out of those encoded integers. For example, there is a getSize method that will allow us to get access to the size value that's encoded within the integer. So now once we've calculated our desired sizing, we need to resolve that against the constraints. So there is a method called resolveSizeAndState. So what we do is we pass in our desired size along with the constrained size and it will return us back the appropriate value based on whether our desired size fits within the constrained size. And then once we get those values back, we have to specify those values to the system. So the way we do that is by calling a method setMeasuredDimension and what we'll do then is pass in the width and height values that receive back from resolveSizeandState. So now in our next clip, we'll override our own measure method and provide the sizing information for our custom view.

Providing a Simple onMeasure Implementation
Here we are back in Android Studio. What we want to do now is implement our custom views onMeasure method. Now we're currently looking at the code for our ModuleStatusView class. So the override the onMeasure method, I'll press Ctrl+L, let's scroll down a bit, we'll then select onMeasure, then I'll go ahead and hit Enter. So now that adds the override for the onMeasure method to our class. Now we don't need to call the super class implementation, so I'll go ahead and remove that line. So here within the onMeasure method, what we're going to focus on at this point is calculating the desired width and height for our custom view. So to start us out, I'm going to declare two local variables, desiredWidth and desiredHeight, they'll both be of type int and initialized to 0. So now with those variables in place, we're ready to do the calculations. So let's first work on our desiredWidth. So now in order to calculate our overall width, we need to start out with the width for one module, so each module requires the width of mShapeSize, the width required to draw one circle, plus the spacing to the right of it. So that's our width for one module, so then multiply that times the length of our mModuleStatus array. So now that gives us the width required to draw the circle for each of the modules, as well as the space to the right of each of those circles and that actually means we're including one extra bit of spacing, so let's go ahead and subtract off mSpacing from this overall result. So now our desiredWidth variable contains the width required to draw each of the module circles and the spaces between each of those circles. So that's our drawing width, but remember, we also have to include any padding, so we're going to take that desiredWidth value and add to it the left and right padding values. So that gives us the width required to do all of our drawing, as well as the padding to the left and to the right. So now we need to do this same sort of calculations for the height. Since we're only drawing one row of circles, our desired height is simply our shape size. So that gives us the height required to do our drawing, but we still need to account for the padding so add our top padding and bottom padding values to our desiredHeight. So that gives us our desiredWidth and our desiredHeight, but remember, we may not be able to use those desired values because our onMeasure method received constraints for the width and the height and that's our widthMeasureSpec and heightMeasureSpec parameters. So what we need to do is resolve our desired values against those constrained values that are passed into onMeasure. So let's first do it for our width. So we'll declare our local variable of type int named width and then to help us resolve the difference between our desired value and the constrained value, we can call the method resolveSizeAndState. So now the first parameter here is our desired value, so we'll pass in desiredWidth, the second parameter is a constrained value, so that'll be the widthMeasureSpec that was passed into the onMeasure method. And for the third parameter, we can pass 0. So with that now, our width variable will contain either our desiredWidth, if there is not room for that, it'll contain a value based on the widthMeasureSpec. So now we'll do that same thing for the height and then we'll call resolveSizeAndState passing in desiredHeight and heightMeasureSpec. So now our width and height variables contain the appropriate values based on the desired values we've calculated and the constrained values that were passed into onMeasure. So now what we need to do is inform the system what those values are, so to do that, we'll call the method setMeasuredDimension and we'll pass in width and height. And that gives us an initial implementation of our onMeasure method. We calculate our desired width and height, resolve those against the constrained width and height that's passed in onMeasure, and then we inform the system of the values to use. So in our next clip, we'll head back to the layout designer. We'll see how the addition of the onMeasure method to our custom view affects that custom view's behavior.

Positioning the Custom View with Constraints
Here we are back in Android Studio and what we want to do now is see how the addition of the onMeasure method to our custom view affects the appearance of our custom view here in the designer. Now we're currently looking at the layout resource for the Content area of our note activity, and I haven't yet done a build of our code since we added the onMeasure method, so we can still see the problem that we were having. We couldn't see the right edge or the bottom edge of our custom view. So let's go ahead and do a build now and see how our onMeasure method changes things. So I'll go ahead and do a Ctrl+F9, and you can see once the build completes, we can now see all four edges of our custom view and that's what we wanted. So our onMeasure method looks to be working pretty well. So we currently have constraints in for the top and left edges. So let's go and add a constraint for the right edge. So we'll constrain our right edge against the right edge of the edit text for the note text above it. So now with that, we have our custom view constrained on the left, top, and right edges. So now let's look over here to the Properties window and add in the properties we need to use our custom view. We'll start out with our id. So let's make our id module_status. So that gives us our id value, now let's look at the margins. Now we're constraining the left and right edges of our custom view against the left and right edges of the edit text above them. So instead of our margins being 8 for the left and right edges, let's make both of those 0. So that gives us our margins, so now let's look at the layout with property. Now the layout with property is set to wrap_content and wrap_content says that the custom view should use its calculated width as its width and what we want it to do is use the constraints to determine the width. So we'll change that wrap_content value to be 0dp. So now with that, the width of our ModuleStatusView will be determined based on the constraints. So now for our height, let's keep that value as wrap_content. With the height being wrap_content, our ModuleStatusView is free to determine its own height. So now, let's do one last thing. If we look at our custom view, the circles within the custom view are pressed right up against the edges of the custom view itself, so let's add some padding to provide some extra room there. So let's switch over to the full list of properties, we'll expand the padding section, and rather than set each padding value individually, let's just go ahead and set it all around padding of 5dp. And now by adding that padding value, we can see there is extra space between the edges of the circles and the edges of our custom view. So all this shows us is that our custom view's onMeasure method appears to be working perfectly, it allows us to interact with our custom view properly here within the designer. So this takes care of the default layout resource for the Content area of our note activity, but as you recall, earlier in the course, we added a landscape version of this same resource, so we'll need to add our ModuleStatusView to that layout as well. So let's head over to our landscape version of our layout. So here we are now in our landscape layout resource, so let's go ahead and add our ModuleStatusView to this layout just as we did to the other layout. So we're over here in the palette, we have the advanced category selected, we'll grab view, just drag it over here onto the layout, we'll select ModuleStatusView, I'll hit Enter. So now in this layout, let's go ahead and place it relative to the note title. So we'll constrain its left, right, and top edges to the note title field. So that gives us our constraints. Let's go ahead and set its id to the same id we used on the other layout, which is module_status. So now with our id in place, one last thing I want to make sure we do is go down here to our layout_width property. Let's change that from wrap_content to 0dp, so we'll use the constraints to determine our view's width. Now that we've set our layout with the 0dp, take a look at the custom view. Notice that the layout circle is now being clipped and that's because with the layout_width of 0dp, the constraints are limiting the width of our custom view and that constrained width does not leave enough room to draw the contents of our custom view as we currently have them laid out. So in our next clip, we'll look a bit more closely at this issue of sizing our custom view so it can work properly within the provided constraints.

View Sizing Adaptability
When we're implementing our custom view, we want to be reasonably adaptable in the measurements we're capable of supporting because our views are often going to be constrained in the available size they have access to and we want to avoid this idea of just being clipped because we can allow our view just to be clipped, and if there is not enough room, we lose part of the drawing, but we really don't want to do that in most cases. We want to do something better than that. Now one option we have, if the measurements don't allow us to do our complete drawing is to provide some visual indicator that we're only displaying a subset of the content. Like some views, if they can't display all their text, they'll put a … at the end to indicate to the user that there is more text, it's just not visible. Or what we can do is change the size of our contained drawings. So in our case, if there is not enough room to draw the circles at the size we want, we could choose to draw the circles smaller so that they would all fit inside of the size that's available to us. And another option we have is that we could wrap. So if there is not enough width available to draw all the circles, we can add additional rows and draw the remaining circles underneath those circles so we can display all the content. Now if we think about the way our custom view currently does drawing, we actually calculate out our drawing positions as soon as the view is created. We never factor in the measurements that are available. So what happens then when it's time for our view to draw, we're given a canvas and we draw using those precalculated positions, and as long as that canvas is large enough, all the circles we draw are visible. But when the measurements constrain the drawing space, we still draw using those same positions. So our drawing actually goes beyond the area where we can actually draw into, and as a result, everything we draw past the end is clipped and not visible to the user. So let's change our custom view so it has more measurement adaptability and what we'll focus on is this idea of a constrained width and being able to grow the height of our view if we don't have enough width to draw all the module circles. So when our own measure method gets called, we'll be given an available width, and what we'll do is we'll take a look at that width and we'll calculate how many of our module circles will fit inside of that width. If it's wide enough, we can again draw all the circles right on that one line. But if it turns out that we want to do something like draw seven module circles and the width we're given only allows room to draw four of them, what we'll then do is calculate how many rows it will take to draw all seven of them. So if we can only fit four circles in the available width, then we want to grow the height to allow us to draw two rows of circles. So what our onMeasure will then do is calculate a width that fits inside of that constrained width and the height that gives us room to draw two rows of circles, and then once we know the width and height, we can calculate the positions in which to draw the circles. And so, when it comes time to draw those circles, we'll draw four circles in the first row and the remaining three on the second row, and then that way, our custom view is able to adapt to constraints placed on the available width. Now when we're implementing the measurement behavior of a custom view, it's important to understand that the measurement and placement of views is really kind of a negotiation and there are actually multiple passes involved. So the system may go through, ask individual views for the measurement they want, come back, ask again, and even ask again because what's happening is the container views will generally do their best to accommodate desired measurements from the views. Now specific behavior will vary depending on what kind of container you're using, but the system really does want to do the best job it can to give the individual views the measurements they want. So with this negotiation process in mind, we want to make sure we implement our onMeasure method in a smart way because our onMeasure method may get called several times and a complex layout involving many container views and many nested container views, our onMeasure method can get called many times. So we want to make sure our onMeasure method is efficient. So inside of our onMeasure method, we generally don't want to calculate individual drawing positions. What we want to focus on in the onMeasure method is just calculating the overall width and height measurements. So we basically are calculating the width and height of the rectangle that we want to use for our custom view. Then we'll implement another method onSizeChanged and the onSizeChanged method is called when our view size is actually determined or for some reason our size changes because of a change in the layout. But what's important to understand is the onSizeChanged method receives the width and the height that our view is actually going to use. So it's inside this method we're going to calculate our actual drawing positions because we now know what the width and height we have available to us is. So now in our next clip, we'll start implementing our more adaptable onMeasure method.

Making onMeasure More Adaptable
Here we are back in Android Studio and what we want to do now is implement our onMeasure method to be more adaptable. Now we currently have the code for our ModuleStatusView open and we're looking at the onMeasure method as we currently have it implemented. Now the maker onMeasure method more adaptable, we'll change the implementation to check to see if the available width is too small to fit all of our module circles, and if that's the case, we'll adjust the height of our ModuleStatusView to allow the circles to be drawn over multiple rows, and one of the key aspects of being adaptable with the width of our custom view is that we need to check the value that was passed into our widthMeasureSpec parameter. So let's declare our local variable of type int named specWidth. Remember that the value passed into the widthMeasureSpec parameter is an encoded integer, so we use methods to access the contain values. Now the value that we want from the parameter is the size, so we'll use the MeasureSpec class' getSize method and then we'll pass in widthMeasureSpec. So now our specWidth variable will contain the total width. To determine the width we have to work with, we need to account for the padding. So we'll declare a local variable of type int named availableWidth and we'll assign it the value of subtracting the left and right padding from the specWidth. So that gives us the available width we can use to draw the module circles. So now we need to figure out how many module circles will fit within that width. So let's declare a local int variable named horizontalModulesThatCanFit. We'll then start with the width required for each module and that's the sum of the mShapeSize and mSpacing and then we'll divide the available width by that value. So that tells us the most modules that can fit horizontally within that width. But now that value might be more width than we actually need depending on how many modules we need to draw. So let's declare an int variable named maxHorizontalModules and then we'll call the min method from the math class and we'll pass in horizontal modules that can fit and the length of our mModuleStatus array. So what this does if there is enough width available to draw all the modules, then maxHorizontalModules contain the length of our mModuleStatus array. Otherwise, maxHorizontalModules will contain the number of modules that can fit within the available width. Now we'll actually need this value in other parts of the class, so let's promote maxHorizontalModules to be a field. So with that work done, now we're ready to calculate our desired width. Currently, we always use the length of the ModuleStatus array to do that calculation. So what we want to do now is switch from using the length of our mModuleStatus array and instead use the value in our mMaxHorizontalModules field. So now at this point, our desiredWidth variable contains the width we need to do our actual drawing, but remember we still have to account for the padding. So in our next line, we add in our left and right padding just as we had done previously. So that takes care of our width. So now we need to calculate our height. Now previously, we always drew just one row of module circles, so our height was simply our mShapeSize value, but now, we need to calculate the desiredHeight, and so to do that, we need to determine how many rows are required. So let's declare a local variable of type int named rows. So to calculate our number of rows, we'll start out with the length of our mModuleStatus array -1, we'll divide that by our mMaxHorizontalModules field, and then we'll add 1 back in. So that gives us the number of rows required to draw all of our modules. So we're now ready to calculate our desiredHeight. Well since we now may have multiple rows, we'll need to have space in between each of those rows. So the height for one module needs to be the sum of the shape size plus the spacing. We'll then multiple that times the number of rows and then we'll subtract our mSpacing value from that result because we won't need any spacing after our last row. So that calculation gives us the height we need to draw our actual modules, so once we have that, on our next line, we add in our top and bottom padding. So at this point, we have our desiredWidth and our desiredHeight, so we'll go ahead and resolve and set our measurement just as we did before. So with these changes, our own measure method now adjusts the required measurements to take into account any constraints that might limit our available width. So now in our next clip, we'll see how the changes to our onMeasure method affect the appearance of our custom view, and we'll add the code to adjust the position of our module circles to support displaying them across multiple rows.

Calculating Drawing Positions Based on View Size
Here we are back in Android Studio and we're continuing the work of making the sizing of our custom view more adaptable. Now we're currently looking at the landscape version of the layout resource for the content area of our note activity, and in the previous clip, we modified our own measure method to extend the height of the custom view if there isn't sufficient width to draw the module circles. Now we haven't yet done a build of that code. Now currently, before we do the build, the rectangle around our custom view has the height that's appropriate for displaying a single row of module circles. So let's do a build. I'll press Ctrl+F9, and notice after the build completes, the rectangle around our custom view is now taller. The height of the rectangle now allows room to draw two rows of module circles. So that shows us that the changes to our onMeasure method worked. So with that code working, we're now ready to add the code to calculate the positioning of our circles so the circles can be drawn across multiple rows. So to do that, let's head over to our ModuleStatusView class. So here we are in the code for our ModuleStatusView class and we're currently looking at our setupModuleRectangles method, and as you recall, this method calculates the positioning of where the module circles will be drawn. Now as we have this method currently implemented, all of the circles are drawn on a single row. So we need to update the method to include support for drawing across multiple rows. Now if we look just below our setupModuleRectangles method, we have our onMeasure method, and when we implemented this method, one of the first things we did was a series of calculations based on the width value we were passed and then those calculations gave us this value, mMaxHorizontalModules, and that value indicates how many modules we can draw on each row. So what we'll need to do is use our mMaxHorizontalModules field to adjust the positioning of our module circles and we'll, of course, do that work up here in our setupModuleRectangles method. Now here within setupModuleRectangles, we have this for loop where we go through and calculate the x and y positioning for each of the rectangles used to draw the circles. So to add support for drawing our circles across multiple rows, let's start by adding a couple of blank lines to the beginning of our for loop, and then here within the loop, we can calculate the appropriate row and column for each of the rectangles. So let's add a local variable of type int named row, and to determine our row, we'll divide mModuleIndex by mMaxHorizontalModules. Since both module index and mMaxHorizontalModules are ints, that means we're using integer division rules, so the result will be an integer representing the number of whole times that mMaxHorizontalModules will divide into module index. So for example, if our mMaxHorizontalModules has a value of 4, then if our module index is 0, 1, 2, and 3, the row value will be 0. And then for module indexes 4, 5, 6, or 7, the row value will be 1 and that process will continue for each of the module index values. So with our row value calculated, now let's declare an int variable named column. And in this case, we'll perform a module's operation between module index and mMaxHorizontalModules. Now remember, the modulus operator gives us the integer remainder of an integer divide. So again, if we use that example of MaxHorizontalModules having a value of 4, then for module index values of 0, 1, 2, and 3, the modulus operation will give us column values of 0, 1, 2, and 3 respectively. And then for module index values 4, 5, 6, and 7, we'll again get column values of 0, 1, 2, and 3 and this process of repeating the sequence 0, 1, 2, and 3 will continue as we loop through the module index. And so, with those calculations in place, we have both our column and row values, so using those, we can then calculate our x and y values. So for the x value, we can use basically the same formula we have now, all we'll need to do is change moduleIndex to instead be column. So that gives us our x position, so now for y, we'll start with the top padding just as we do now and then we'll add to it the result of multiplying the row value by the sum of the shape size and spacing. And with that, we now have the calculations in place to position our module circles across multiple rows. So in our next clip, we'll tie in these calculations with our custom view's onSize method.

Connecting View Sizing to onSize Implementation
Here we are back on Android Studio and we're ready to do the last bit of work to make our custom view more adaptable to size variations. Now we're currently looking at the init method of our ModuleStatusView class. Remember that this is the method that gets called when an instance of our custom view class is initially created. And as our class is currently implemented, we're calling our setupModuleRectangles method from here within our init method and this is, of course, too soon because we don't yet know our custom view size. So let's remove the call to setupModuleRectangles from here within the init method. So now with that call removed, let's scroll down in our class a little bit. So here we are now just before our onDraw method and since we need to know our view size in order to calculate our drawing positions, let's override the onSizeChanged method. So I'll do a Ctrl+O, we'll scroll down a bit, and once we've scrolled down, I'll select onSizeChanged, and I'll hit Enter. So that gives us our onSizeChanged method. Now let's go ahead and remove the call to the Super class implementation because we don't actually need that. And instead, we'll call our setupModuleRectangles method. So now with this code in place, we'll set up our positioning rectangles when the system tells us that our view size has changed. But now before we move on, let's take a closer look at onSizeChanged. Notice that it accepts four parameters. The first two parameters are the current width and height. The second two parameters are the previous width and height and those two may be meaningful. If a situation arises with the view size changes from one size to another for some reason, but in our case, let's focus on those first two parameters the current width and height. Now it's important to remember that the width and height that we ultimately have available may be different than the desired width and height that we specified in our onMeasure method, so any positioning work we do, we should use the values that are passed to our onSizeChanged method. Now all the work we've been doing has been to make our ModuleStatusView class adaptable to being insufficient width to draw all over our modules on a single row. So let's pass the width value we receive into the onSizeChanged method to our setupModuleRectangles method. So let's scroll now to our setupModuleRectangles method. So here we are now at our setupModuleRectangles method. So the first thing we want to do is add a parameter to receive the width. So this parameter will receive the width that our view is ultimately sized to. And remember, the width affects how many modules we can draw in a single row. We keep that module count in our mMaxHorizontalModules field and we use that field when determining which column and row to position each module. Now just below our setupModuleRectangles method, we have our onMeasure method and here within the onMeasure method, we have the calculations to determine mMaxHorizontalModules. So what we need to do now is repeat that calculation within setupModuleRectangles using the width value we received from onSizedChanged. So the first thing we need to do is determine the available width and we'll do that by subtracting the left and right padding from the width value we received. Now once we have our available width, we determine how many modules can fit horizontally, and then once we know how many modules can fit horizontally, we take the lesser of that value and the number of elements in our ModuleStatus array. Notice here that we're storing a result in a local variable MaxHorizontalModules, and since we won't need this value outside this method, a local variable is fine. There is no need to put it into a field. What we'll do now is change our column and row calculations to use the MaxHorizontalModules variable. And so now with that, we have our rectangles properly calculated to position our module circles across multiple rows based on the width that our view ultimately receives. So let's head back to the designer and let's see how things look. So here we are back in the designer and we haven't yet done a build. So the module circles are all still being drawn in a single row. So let's go ahead and do a build. I'll press Ctrl+F9, and now, when our build completes, we draw the last module circle on the next row. So that shows us that our custom view now properly handles sizing and positioning. If there is not width available to draw all the modules on a single row, then we grow the height of our custom view to allow us to draw those modules across multiple rows.

Summary
To wrap up, here is one of the key things you want to remember from this module. Remember that we use our custom views much like we use the built-in Android views. We'll normally place our custom view within a layout resource, and within that layer resource, we can specify our custom view one of two ways. We can either use our class' package qualified name as the element tag or we can use the view element tag and specify our class name using the view tag's class attribute. Now when it comes to positioning our custom view, the positioning of our view itself is normally handled by the container that our view is placed within, so that will normally be something like a constraint layout or a frame. But the positioning within our custom view, that's our custom view's responsibility, so we're going to manage our drawing within our custom view itself, and as part of calculating that drawing positioning, we want to be sure to incorporate any padding values that have been provided. Now one of the key responsibilities of a custom view is to provide that custom view's measurements and we do that using the onMeasure method, but we can't use just any measurements we want because we'll normally be constrained in some way. So the measurements we use have to fit within those constrained size values that we receive into the onMeasure method. And once we determine the measurements we want to use, we have to tell the system what they are. So within the onMeasure method, we need to be sure to call the setMeasuredDimension method passing in the width and size that we want to use. But remember, view measurement and placement is a negotiation. The system will often go through multiple passes determining what size and positioning to use. So we indicate our desired sizing inside the onMeasure method, that's what we tell the system, this is what we'd like to use. But the size we ultimately receive is passed into the onSize method, so it's inside the onSize method where we actually calculate our drawing positions. Alright, that wraps up this module. In our next module, we'll finish up our discussion of custom views. We'll start using our custom view within our activity class, and we'll learn how to incorporate interactivity and configurability into our custom view.

Incorporating Custom View Interactivity and Configurability
Introduction
Welcome to our next module, Incorporating Custom View Interactivity and Configurability. This is the Pluralsight course, Broadening Android App Appeal and Reach. My name is Jim Wilson. In this module, we'll wrap up our discussion of custom views, we'll look at some of their more dynamic capabilities. So we'll start out, we'll look at how we can access and interact with our custom view from within our application code. We'll then see how to add touch support to our custom view, so we can actually respond to user touch actions, and as part of that discussion, we'll see how to trigger updates to our custom view drawing so we can actually reflect any changes in the state of our custom view, and then we'll look at custom view configuration attributes and that'll actually allow us to provide properties that are accessible from within the Android Studio designer so that allows us to set design time values for things like our drawing colors and our drawing dimensions. And then we'll finish up, we'll look at how to manage our drawing dimensions within our custom view so we can draw consistently across different screen densities.

Interacting with the Custom View from Code
Here we are in Android Studio, and we're continuing our work with our custom view. Up until now, all of our work with our custom view has been from within the Android Studio designer. So to get us started in this module, we'll add the code to our new activity class to work with our custom view at runtime. We're currently looking at the onCreate method of our NoteActivity class. Just as with built-in view classes, we need to get a reference to our custom view to be able to interact with it. So here near the end of the onCreate method, we'll declare a local variable of type ModuleStatusView, we'll name that variable, viewModuleStatus. We'll then call findViewById passing the id we assigned to our view within the layout resource and that id is r. id. module_status. We'll then cast the findViewById return value to be of type ModuleStatusView. And with that, our viewModuleStatus variable will now have a reference to our ModuleStatusView. Now we'll need to use that reference in other parts of our NoteActivity class, so let's promote the ViewModuleStatus variable to be a field. And so now, we can use our mViewModuleStatus field to access our custom view from anywhere within our NoteActivity class. Now that we have a reference to our custom view, we need to go ahead and set our custom view status values. So let's call a method we'll create named loadModuleStatusValues. To create the method, we'll press Alt+Enter, Enter, and we'll accept our return type. In real life, we need to add a table to our content provider to track the modules for each course and then we look up the status values for the currently selected course from that table. But for simplicity here in our demo, we'll just manually set up an array with status values. And to make it interesting, let's make that array fairly large. So we'll declare a local int variable named totalNumberOfModules and we'll set its value to 11. And then we'll declare another int variable named completedNumberOfModules and we'll set that to 7. And then we can set up a boolean array named moduleStatus sized to totalNumberOfModules. And then we'll set up a for loop that uses our completed number of modules variable to set the first seven array elements to true. And then once we have our status array set up, we'll call the setModuleStatus method on our mViewModuleStatus field. And that's all there is to it. Our custom view will take care of all the details of displaying appropriately based on the passed status array. So lets run our app and we'll see how things look. Here we are with our app up and running, let's go ahead and select a note, and there within our note activity, we can see our module status view. We're displaying 11 modules with the first 7 modules filled in to indicate that those modules have been completed. Because the width of our activity doesn't allow displaying the module circles in a single row, our custom view displays them across three rows. There are five modules in the first row, five modules in the second row, and one module on the third row. So things are looking pretty good here. So let's rotate the emulator to a landscape orientation and see how things look then. And everything still looks good. Our custom view has adapted its layout to deal with the fact that it needs to fit into a more narrow area. Now in this orientation, we have four modules on the first and second rows and then three modules on the third row. So our custom view is behaving just as we'd like it to, so let's switch back to portrait. And things still look good. So let's add some more functionality to our custom view. Let's add the ability for users to tap on a module circle and set that module to be complete or incomplete. And we'll start looking at how to do that in our next clip.

Custom View Touch Support
As our custom view is currently implemented, it's display only. Now remember, the purpose of our custom view is to provide information about which modules are complete and it would be nice if the user could actually change that completion status for modules using our custom view. So to do that, we'll add touch support to our custom view. So that way, if the user touches our custom view over a particular module, we can then mark that module as complete. So what we can do is actually change the value and the status array to be true for that module and then we can actually draw the circle for that module filled in and we'll include support so that if a user changes their mind and wants to actually take a module that's complete and mark it as incomplete, they tap over it again, we'll simply mark it as false in the array and then draw that circle not filled in. To provide this behavior, we need to know where within our custom view the user has touched. And when we know where they have touched, we can then look through that rectangles array that we used to draw the circles and whichever rectangle they've touched within indicates which module we need to affect. So we'll be working with our custom views onTouchEvent method, and by overriding this method, we can handle touch actions. Now we won't necessarily want to handle every touch action that comes through this method, so for the one's that we actually handle, we'll return a value of true from our onTouchEvent method. For the ones that we don't handle, we'll actually call the super class implementation of onTouchEvent. The onTouchEvent method receives one parameter which is a MotionEvent. The MotionEvent class describes that touch event. The MotionEvent describes a type of action, things like did the user put their finger down on their screen or did they lift their finger up off the screen, those sort of things, and it also includes the x and y coordinates of the touch. So we can use those x and y coordinates to determine which course module we need to affect. So in our next clip, we'll start implementing this behavior within our custom view.

Adding Touch Support to the Custom View
Here we are back in Android Studio and what we want to do now is add touch support to our custom view. We're currently looking at the onDraw method of our ModuleStatusView class. Here within the onDraw method, we loop through this mModuleRectangles array. The circles we draw correspond to each course module are drawn within the rectangles in this array. So we use the mModuleRectangles array to determine which module the user has touched. To get us started implementing our touch behavior, we'll need to override the onTouchEvent method. So I'll press Ctrl+O, we'll scroll down, I'll select TouchEvent, and I'll hit Enter. That gives us our onTouchEvent method, but let's scroll up and give ourselves some room to work. So now we're ready to start implementing our onTouchEvent method. The onTouchEvent method receives this MotionEvent parameter. As you can see, the parameters name is event. The event parameter is what provides us with information about the TouchEvent. One of the key things it provides is the touch action. So let's call the event. getAction method. So that'll tell us the specific action that occurred. Let's put that call within a switch statement. The MotionEvent class includes constants to identify the actions. One action that we'll want to handle is when the user presses their finger down on the screen. So we'll add a case for our MotionEvent. ACTION_DOWN. Since we're handling that action, we'll return true and we'll want to do the same thing for MotionEvent. ACTION_UP. So for those two actions, we return true to indicate that we're handling them, and all other cases, we just call the super class' onTouchEvent. So here within the case for the up action is where we're going to do all the work. We indicate that we handle the down action just on a default down press behaviors occur. It's the up action that we're really interested in. So when the user lifts their finger off the screen, we want to do the work to change the module status. So the first thing we need to do is determine which module was touched. So we'll declare a local int variable named moduleIndex and then we'll call a method we'll create named findItemAtPoint. We want to pass the x and y coordinates of the touch to our findItemAtPoint method. So we can get those values by calling our event parameters getX and getY methods. Now let's create our findItemAtPoint method, I'll press Alt+Enter, Enter, I'll accept the return type, and our parameter types in names. Here within our findItemAtPoint method, we want to figure out the index at the rectangle that the user touched. So let's start by declaring a local int variable named moduleIndex. We'll set its initial value to -1, and let's make that -1 a constant named INVALID_INDEX. So now, to figure out which module was touched, we'll set up a for loop to loop through the rectangles array. So now here inside of our for loop, let's add an if statement, and inside the if statement, we'll call the current array elements contains method and then we'll pass in our x and y parameters. The contains method returns true if the x and y coordinates are contained within that rectangle. So if the contains method returns true, then we know the user touched the circle that corresponds to the module that's drawn within this rectangle. So with that being the case, we'll assign the array index to our module index variable, then we'll break out of the loop, and then we'll return the module index from findItemAtPoint. So now, we know which module the user tapped. So in our next clip, we'll add the code to update our custom view's appearance and we'll verify that it all works.

Updating Drawing in Response to Changes
Here we are back in Android Studio and we're finishing up the work of adding touch support to our custom view. Now we're currently looking at our ModuleStatusView class' onTouchEvent method. In a previous clip, we did the work to get the index of the module that the user had touched and then we store that index here in this variable moduleIndex. So now let's add the code to update the module status. To do that, let's call a method we'll create called onModuleSelected. We'll pass in moduleIndex and then we'll press Alt+Enter to create the method. We'll hit Enter, we'll accept the return type, parameter type, and the parameter name. Now it's always possible that the user touched our custom view in an area that's outside of all our module rectangles. So the first thing we'll do here is add an if statement, and in that if statement, we'll check to see if the moduleIndex is set to our constant, INVALID_INDEX, and if it is, we'll just go ahead and return. So now as long as we get past this if statement, we know we have a valid moduleIndex, so then we know that we need to set the mModuleStatus value that corresponds to that index and we want to set it to the opposite value that it currently has, so we'll assign it the not of itself. So if our module has a value of false, this statement will set it to true, and if it has a value of true, this statement will set it to false. So let's go ahead and get ready to test this code. We'll first put a breakpoint here at this statement and then let's go ahead and run it. So here we are at our note activity and we have our ModuleStatusView down here at the bottom, so let's try tapping on a module. So this last module is currently not complete, so let's go ahead and tap on it. And we can see here in the background that we've hit our breakpoint. So let's head back to Android Studio. So we're here now in Android Studio and we're stopped in the line that says our ModuleStatus. If we look down below here in our Variables window, we can see that its current value is false. So let's go ahead and step, and once we step and we look down the Variables window, we can see that status is now true, so that part worked, it changed our status value. So let's go ahead and release this now and return back to the emulator. So we're back here now at our note activity, and as you can see, our module circle doesn't look any different and now we saw the code set the status value to true, so it seems like that circle should be filled in, but it's not. So let's head back over to Android Studio and see what's up. So we're back here now in onModuleSelected method and we know this line here is properly setting the status value, so why doesn't the appearance of our view change? Well the problem is that our view's appearance has already been drawn, and when it was drawn, that status value was false. If a change occurs within our code that impacts the appearance of our view, we need to inform the system that the view needs to be redrawn and the way we do that is by calling the invalidate method. So now when the user taps on the module, our view class will change the status value and then ask the system to call our onDraw method and then that call to onDraw will cause our view to draw its appearance with the most up-to-date status values. So let's go ahead and run this again. So now we're back here again at the note activity and let's try tapping on that last module, and this time, it correctly switched to the appropriate appearance for a completed module. So let's go ahead and tap it again, and now it switches to the appearance for a not completed module and this will work for all the modules that we display. We can click around and their status appearance will keep switching back and forth. So our touch support is working just as we'd like it to. So in our next clip, we'll start looking at adding configurability to our custom view.

Custom View Configurability and Designer Support
As our custom view is currently implemented, all of our drawing behavior is fixed. Other words, we always draw our lines at the same width, we always draw them in the same colors, and when you create a custom view, you generally make some aspects of it configurable, so let's add some configurable attributes to our custom view. So one of the attributes we'll add is outlineWidth and that will allow us to specify a configuration option to indicate how wide we'd like the outline. We'll also provide an attribute that allows us to specify the color of the outline, and we'll add one more which gives us the ability to specify the shape. So rather than always drawing a circle, we'll have a configuration attribute that allows us to specify that we'd rather draw squares, instead of circles. Now any configuration attributes we provide should include design time support, in other words, we should be able to set them using the Android Studio designer. So that means that our attributes will need to appear within the Properties window of the designer. In order to do that, we have to identify what those properties are and we identify the properties that our view supports using a declare-stylable resource so that will identify our view's configurable attributes, it will give each attribute's name, and it will give each attribute's format, and the format identifies what kind of values are valid for that attribute. So for example, our outline with attribute would have a format of dimension indicating that it accepts dimension values, whereas our outline color attribute, we have a format of color indicating it accepts color values. Now our custom view will need to know the attribute values that were set within a designer. So those values are actually passed to our view constructor and we receive there what's known as an AttributeSet and the AttributeSet is the raw values from the Properties window. So what that means is the value is exactly as entered. So for example, if we have a color attribute and that color is specified using a reference to another color, we would get the name of the reference rather than the color itself. So in order to make these attributes easier to work with, we want to convert it from an attribute set to what's called a typed array and we do that using the context class' obtainStyledAttributes method. And what the TypedArray does is give us access to the values in a more usable form, so again, thinking of our color example. So if our outline color value was specified with a reference, the TypedArray would give us the actual color value itself, not the name of the reference. Also, the TypedArray will have any appropriate styles applied to the values. So basically, the TypedArray gives us the value in a way that we can directly work with them. So the TypeDirect class has a series of get methods and there are separate get methods for each attribute format, so there is like getDimension method or getColor method. And the way we access our attribute values is by using constants. So each of our attributes will have an R. stylable constant, so it will be R. stylable. the name of our attribute. So now TypedArrays are a shared resource, it means the system may choose to reuse them for other purposes. So when we're done with our TypedArray, we want to make sure we call the recycle method to indicate to the system that we're now done using that TypedArray. So now in our next clip, let's start the work of adding configuration attributes to our custom view.

Adding a Color Configuration Attribute
Here we are back in Android Studio, and what we want to do now is start the process of adding configuration attributes to our custom view. We're currently looking at a resource file the Android Studio generated for us when we created our custom view. It's in this resource we'll specify our configuration attributes. Now looking over here that the Project window, we can see that the resource file was created within the values resource folder. Now the name of the resource file itself doesn't actually matter, but by convention, it starts with attrs and then it's followed by a name appropriate for the custom view. Now looking within the resource file, we can see here we specify this as a declare-styleable resource and the name provided here identifies the custom view class that this resource is associated with and it's important that this name value match our custom view class name. If it doesn't, our custom view's attributes won't appear within the Properties window of the designer. Since our name here is ModuleStatusView, this is where we'll specify our configuration attributes for our ModuleStatusView class. So let's add a new configuration attribute for ModuleStatusView. We'll add our outline color. So we'll use the attr element tag, we'll specify its name as outlineColor, we can then specify the format. So to see the available formats, we'll just press Ctrl+Space and this is our outline color, so we'll choose color. And that easily, we've now indicated that the ModuleStatusView class supports configuration attribute named outlineColor. Now before we move on, let's clean this file up a little bit. These other attributes that are listed here are all just examples of Android Studio included when it generated the resource file. We don't need any of those, so let's go ahead and remove them. So those are all gone, but one thing to note, once we remove those attributes from here, it's important that they're not referenced within any layout resource that uses our custom view. So now with that in mind, let's head over to the sample ModuleStatusView layout resource. Remember that this is the layout resource that Android Studio generated when we created our custom view, and if we wanted to, we could just delete this layout resource. Let's go ahead and keep it around for now. But if we're going to keep it around, we need to clean it up a bit. Let's switch to the text view, and when we switch to the text view, we can see we have our ModuleStatusView element and when Android Studio generated this resource, it set values for all those example attributes. Now that we've removed those attributes from our declare-styleable resource, leaving those attributes here would result in build errors so let's go ahead and remove them. So now those attributes are all gone, so to confirm that all is well, let's do a build. I'll press Ctrl+F9 and everything builds just fine, so we know we don't have any references to those example attributes anywhere. So let's switch back to our Design View. So now here in our Design View, let's go ahead and select our ModuleStatusView, then over in the Properties window, we'll switch to the full list of properties and then we'll scroll down a bit, and once we scroll down, we can see our Properties window includes our outlineColor attribute, so our declare-styleable resource worked, it's made the outlineColor configuration attribute available for our ModuleStatusView. So now in our next clip, we'll add the code to our ModuleStatusView class to utilize that attribute value.

Accessing a Color Configuration Attribute
Here we are back in Android Studio and we're continuing the work of adding support for our outlineColor configuration attribute for our ModuleStatusView class and we're currently looking at our ModuleStatusView class' constructors. As we mentioned earlier in the course, custom view classes are generated with three constructors. Now the first one accepts only a context, but note that the other two constructors accept an AttributeSet and that's how our configuration attributes are passed into our custom view. Now the third constructor also accepts a style resource and that provides style information in addition to the AttributeSet. As you recall, all the constructors call our init method and those constructors that receive an attributeSet pass that attributeSet to the init method. Let's scroll down so we can see more of our init method. So now here we are in our init method and notice right here near the beginning we get a reference to a TypedArray and we get that reference by using the context to call the obtainStyledAttributes method and we pass in the attributeSet and the identifier of our R. styleable resource and that identifier is the same as our custom view class name, so in this case it's R. styleable. ModuleStatusView. So by doing this, we get the attribute values from the attributeSet in a way that makes them easy to work with. So now once we get the TypedArray, just below there, you can see we call the recycle method, and once we call the recycle method, we can't interact with that TypedArray anymore. We need to get all of our attribute values after we get the TypedArray reference and before we call recycle on it. Now what we want to do is get the value for our outlineColor configuration attribute. Well down below here is where we currently set our outlineColor field, and as the code is currently written, it's always set to black. So let's remove that line, and instead, we'll set our mOutlineColor field just after we get the TypedArray. Now our OutlineColor attribute's format is color, so we'll call the TypedArray's getColor method. And since the attribute that we want to access is the OutlineColor attribute within the ModuleStatusView, we'll pass in the identifier, R. styleable. ModuleStatusView_outlineColor, so that indicates what attribute we want to access. The second parameter is the default value, and in this case, we'll again pass Color. BLACK. So now with this line in place, if a value is specified in the designer for outlineColor, we'll use that value, but if no value is specified in the designer, then in that case, we use black. And that's all there is to it. We should now be all set. So let's head over to the default layout resource for the content area of our note activity. So now here we are in the designer, so now let's do a build so that we're using our custom view's latest code. So now our build completed fine and now let me just zoom in a bit so we can see a little better. So now we're zoomed in. Let me go ahead and select our ModuleStatusView and then we'll switch our Properties window to the view that lets us see all the properties, and then we'll scroll down. So now there is our outlineColor attribute. Now currently, outlineColor isn't set to anything, so as a result, our outline is being drawn in black, which is our default outlineColor. Now let me go ahead and select outlineColor here and I'll enter in the hex value for pure red. So once I have the value there, I'll go ahead and hit Enter, and now our outline is pure red. So our custom view is properly using the color value we specified here in the Property window. But now we're not limited to color literals. We can also select color resources. So let me go over here to the …, select that, over here in the Resources dialog, I'll select color, then down there on the right of that holo_green_dark, I'll select that, and then I'll hit Enter. And now, our outline is being drawn that dark green and you can look there in the Properties window, we can see that its value is actually set to the color resource. So our outlineColor attribute is working just as we'd like it to. So in our next clip, we'll add a shape attribute that allows us to display our modules using it as circles or squares.

Custom Enumeration Configuration Attributes
Here we are back in Android Studio and what we want to do now is add a configuration attribute to our custom view that allows us to select the shape we use to represent a module. We're currently looking at the resource where we specify the configuration attributes for our ModuleStatusView. So now to specify the desired shape, we declare configuration attribute named shape. For this attribute, we want to be able to select either circle or square as the value to use. So what we'll do is give this attribute a format of anum. The format anum allows us to specify selections that can be picked from a drop-down and we specify the selection values here between our attributes open and close tags. So now let's specify a value, we use the anum element, we use the anum's name to specify the selection's display text. So for our first anum, we'll make the name circle. So the word circle will appear on the selection list, but when we access the value of our attribute within our code, the value is returned as an integer, so we indicate the integer to return using value. So with this entry, when the user selects circle, the actual value that we'll receive in our code will be 0. So let's add another anum for square and we'll make its value 1. So that takes care of adding our shape configuration attribute. So let's head over to the layout resource for our note activity and see what this attribute looks like in the Properties window. So here we are in a designer, I've already done the build to the code, I have the ModuleStatusView selected, and our Properties window is displaying the full list of properties, and if we look there under Properties window, we can see our shape attribute. So now if I select that attribute, we can see it's a drop-down, and if I expand the drop-down, we can select either circle or square. So our shape attribute is working correctly here under designer, so let's head over to our ModuleStatusView class and add the code to retrieve its value. Here we are in the init method of our ModuleStatusView class. To retrieve the value of our shape attribute, we'll again need to use our TypedArray. As I mentioned, anum attribute is returned as int. So just below where we retrieve OutlineColor, we'll declare an int variable named shape. We'll call the TypedArray's getInt method. We want to retrieve the shape attribute of ModuleStatusView, so we'll pass in R. stylable. ModuleStatusView_shape to identify the attribute. We need to provide a default value, so we'll pass 0 as our default. Zero is the int value for our circle selection, so let's make that 0 a constant named SHAPE_CIRCLE and let's go ahead and promote that shape variable to be a field. So now we have the value of our shape attribute and our field mShape, so let's go ahead and scroll down to our onDraw method. Here we are in our onDraw method. Now as our onDraw method is currently implemented, we always draw circles, but now if we look just below the onDraw method, I've added another method named drawSquare. This method uses the Canvas class' drawRectangle method to draw a square rather than a circle. So now here within the onDraw method within the for loop where we loop through our list of rectangles, let's add an if statement to check to see if the mShape field is equal to our SHAPE_CIRCLE constant, and if it is, we'll draw circles just as we do now. But now let's go ahead and add an else block, and here within the else block, we'll call our drawSquare method. So now with that, our custom view can draw circles or squares depending on the value of the shape attribute. So lets head back over to our note activity layout resource and we'll see how things look. Here we are in the layout resource, I've already done a build of the project, and I have our ModuleStatusView selected. So we have our Shape property here and we expand the drop-down, let's go out here and choose square, and notice when we do that, our custom view now renders squares rather than circles. If we head back up to our shape property, expand it, choose circle, we again draw circles. So our shape attribute is working just as we'd like it to. So now in our next clip, we'll add our OutlineWidth attribute, and as part of that, we'll look at how to appropriately deal with different screen resolutions.

Dimension Configuration Attributes
Here we are back in Android Studio and what we want to do now is add a configuration attribute to our custom view that allows us to set the size of the outline we draw. Now we're again looking at the resource where we specify the configuration attributes for our ModuleStatusView. To provide the ability to set the outline size, we'll declare an attribute named outlineWidth and we'll go to format of dimension. Giving this a format of dimension allows us to provide values expressed in any of the valid dimension units, things like pixels or device independent pixels. So that takes care of adding our outlineWidth configuration attribute. So now let's head over to our ModuleStatusView class and we'll add the code to retrieve the attribute value. Here we are now in the init method of our ModuleStatusView class. So now currently, this line here sets our outlineWidth field to always be 6 pixels. So let's go ahead and remove that line. And instead, we'll assign our outlineWidth field just after we get the value for our shape attribute. Since the format of our OutlineWidth attribute is dimension, we use the TypedArray's getDimension method, and to identify the attribute, we'll pass in R. stylable. ModuleStatusView_outlineWidth, and for our default value, we'll pass in 6 pixels. So that takes care of retrieving our outlineWidth, so now let's head over to our note activity layout and see what things look like. So now we're here at the designer with our layout resource open, I've already done a build, we have ModuleStatusView selected, and the Properties window is displaying the full list of properties. So now looking at the Properties window, we can see our OutlineWidthAttribute, so we'll go ahead and select outlineWidth. So now to set outlineWidth, we have to provide both a value and the units to use. Now as we talked about earlier in the series, we generally use device independent pixels as the unit. So let's set our outlineWidth to be 5dp, that's 5 device independent pixels, and then I'll press Enter. And now looking at our custom view, we can see that we're drawing a thicker outline, we're drawing an outline that's 5 device independent pixels wide. So that property is working just as we'd like it to. The outline property displays using the width that we provided. So now before we finish up, let's go ahead and run our program and see what value we're actually getting back for outlineWidth. Here we are with our app up and running and I've added a breakpoint within our ModuleStatusView. So let's go ahead and open up a note and take a look at things. And we can see in the background that we've hit a breakpoint, so let's switch to Android Studio. Here we are in Android Studio and we're stopped as we're about to get the value of our outlineWidth, and as you recall, we set the value of outlineWidth to be 5 device independent pixels. So let's step and see what value we get. And if we look down at our Variables window, we can see that the value is 15, not 5, and the reason is that the value we're getting back is returned in pixels. The getDimension method is taking care of doing the work to convert those device dependent pixels to be physical pixels based on the current screen density and the physical pixel value is what we use to do our actual drawing. Now we're currently running on a device with an extra, extra high screen density. So there are three physical pixels for every device independent pixel. So 5 device independent pixels becomes 15 physical pixels on this screen density. Now as we've talked about, we want to prefer expressing dimensions and device dependent pixels rather than physical pixels because using device dependent pixels helps to assure consistent appearance across different screen densities. But now with that in mind, look at our outlineWidth default value, that's being expressed in physical pixels. So our default value is always 6 physical pixels and 6 physical pixels will look differently on different screen densities. On an extra, extra high-density display like we're on now, a width of 6 physical pixels renders relatively thin. On a lower density display, a width of 6 physical pixels would look thicker. On a higher density display, it would look thinner. So what we should really do is express our default value in device independent pixels, and then at runtime, we can convert that value to the appropriate number of physical pixels based on the current display density. And in our next clip, we'll see how to do that.

Screen Density Independent Drawing Values
Here we are back in Android Studio. What we want to do now is modify our custom view to use device independent pixels rather than physical pixels for our default drawing values. We're currently looking at the init method of our ModuleStatusView class, and here within the init method, we have this line where we treat the value of our outlineWidth attribute. Now if no value was provided for that attribute, we use the default value of 6 physical pixels. Well rather than expressing the default value as a constant number of physical pixels, we should instead use a constant number of device dependent pixels that we then convert to the appropriate number of physical pixels for the current screen density. So now to get us started doing that, let's declare a local variable of type float named default outlineWidth pixels, and for now, let's go ahead and set that variable to our default value of 6 physical pixels. And then down here where we retrieve the value of outlineWidth, let's replace that constant value of 6 with our default outlineWidth pixels variable. So now we're all set there. So now we're going to start the work of being able to convert between device independent pixels and physical pixels. Well to be able to do that conversion, we need to know the current device's display metrics. So we'll declare a local variable of type display metrics named dm. To retrieve the display metrics, we start by using our context to get a reference to our resources and then we use the resources to access the display metrics. And so now, we can use our dm variable to retrieve information about the current display metrics. Now the information we're interested in is displayDensity. So let's declare a variable of type float named displayDensity and we'll assign it the value of dm. density. So now, our displayDensity variable contains the factor we can use to convert device independent pixel values into physical pixel values. So now looking at our default outlineWidth pixels variable, we're currently setting it to the constant value of 6 physical pixels, so let's get rid of that 6, and instead, we want to take our display density and multiply that by some other constant value, and that constant we use should be the number of device independent pixels we want to use as our default. Well when we stepped through our code in the last clip, we saw that the device we've been testing with has 3 physical pixels for every device independent pixel. So if we've been using a default outlineWidth of 6 physical pixels during our testing, then that's going to be the same as 2 device independent pixels. So we'll find our default physical pixels by multiplying screen density by the value 2. So that would mean on this device we'll end up with a physical pixel count of 6, which is the value we've been using. So let's convert that literal value 2 to be a constant. So now our constant default outlineWidth dp has a value of 2, so that means now that we'll always start out with a default outlineWidth of 2 device independent pixels and then using the display metrics of the device that our app is currently running on, we convert that value to the appropriate number of physical pixels and we want to follow this same pattern for all of our drawing dimensions. So if we look down here where we set our shapeSize and Spacing, what we'd want to do is declare constant values expressed in device independent pixels and then we'd use our displayDensity variable to convert those values to physical pixels. So let's go ahead and run our code and we'll verify that we're setting our default outlineWidth as we expect. So here we are with our app up and running and I've again added a breakpoint within our ModuleStatusView class. So let's go ahead and select a note, we can see in the background that we've hit a breakpoint, so let's go ahead and switch to Android Studio. So now we're here in Android Studio and we're stopped just as we're about to calculate our outlineWidth value and pixels. So now if we look down at the Variables window, we can see the value of our displayDensity variable and its value is 3. 0, so that tells us that there are 3 physical pixels for each device independent pixel. So let's go ahead and step, and when we step, we can see our default outlineWidth expressed in pixels is 6. 0 and that's the value we expected. And so that shows us that by incorporating this displayDensity calculation, we now have a default value for our outlineWidth that adapts appropriately to whatever displayDensity our custom view is used on. And again, we can use this same technique for all the drawing dimensions within our custom view.

Summary
To wrap up, here is one of the key things you want to remember from this module. Remember that when we're working with our custom views, we're probably going to access our custom views from code at some point and the way we interact with our custom views in code is pretty much just like the way we interact with the built-in views. We get a reference to our custom view by calling the findViewById method, and then once we have that referenced, we can call the methods on our custom view. But now within our custom view's implementation, we'll commonly want to handle touch events. We want our view to respond to touch actions performed by the user. The way we do that is by overriding the onTouchEvent and to know the details about that touch action, the onTouchEvent method receives a parameter, which is a motion Event, and that indicates the kind of touch action that's been performed, as well as where within our custom view the touch occurred. Now throughout the life of our custom view, the state of our custom view may change. It might change in response to a user action, it might change in response to a method call, but when that state changes, we'll probably want to initiate drawing, and the way we initiate drawing is by calling our invalidate method, and then that will in turn trigger our call to our onDraw method and that will give us an opportunity to draw our custom view in a way that reflects its current state. Now when we create a custom view, some aspects of that custom view are probably configurable. So configuration attributes allow us to expose configurable capabilities of our custom view. We describe those attributes within a declare-styleable resource, and by describing them in that resource, those attributes are now available within the designer. So the attributes we list here will appear as properties within the Property window of our Android Studio designer. Now at runtime, we'll need to know what values have been provided to those attributes, and those values are passed to our constructor as an AttributeSet. Remember that the AttributeSet is a very raw representation of the attribute values. What we want is a TypedArray because the TypedArray gives us a representation that's much easier to work with. The way we get the TypedArray is by passing the AttributeSet to the Context class' obtainStyledAttributes method. But now remember, a TypedArray may be reused by the system so we have to tell the system when we're done with it and we do that by calling the recycle method on a TypedArray once we've gotten all of attribute values from that TypedArray. Now we'll very commonly have configuration attributes whose format is dimension and that dimension configuration attribute actually accepts a number of different units. The values can be expressed as device independent pixels, they can be expressed as physical pixels, as well as some other units. But when we call a TypedArray's getDimension method, it always gives us back physical pixels. So that getDimension method always gives us back the value in a way that we can use it for drawing without having to do any conversion. But now within our code, we may have constants that we use for our drawing dimensions and we want to make sure that any constants we use for drawing dimensions in our code are expressed in device independent pixels. We don't want to express them in physical pixels because remember that the appropriate number of physical pixels will change based on a device's screen density. So what we want to do is start out with our value as device independent pixels and then we get the device's display metrics and that will then give us a factor that tells us how many physical pixels we need to use for each of those device independent pixels. So using that factor, we can convert from device independent pixels to physical pixels. Alright, that wraps up this module. In our next module, we'll start learning how to incorporate accessibility features into our apps.

Adding Accessibility
Introduction
Welcome to our next module, Adding Accessibility. This is the Pluralsight course, Broadening Android App Appeal and Reach. My name is Jim Wilson. As developers, we often assume that all of our users can see the display and are physically able to touch the device. However, in many cases, the user's physical condition, the application usage scenario, or device's capabilities may make one or both of these difficult. So in this module, we'll learn how incorporating accessibility into our apps empowers users to fully experience our app even when unable to see the display or physically touch the device. We'll start out, we'll look at our goals when incorporating accessibility into our applications, we'll then look at the key accessibility tools, which are screen readers and D-pad style navigation, we'll see how we can provide descriptions for our views to the screen reader, we'll see how to control D-pad navigation behavior, and we'll finish up and look at how we can automate the testing of our app's accessibility features.

Goal of Accessibility and How It Works
So we talked about this idea of adding accessibility to our applications. What are we trying to do? What's our goal? Well our goal of accessibility is to provide usability that goes beyond our traditional expectations of how users physically interact with a device. In other words, we want to expand our thinking about how people use and interact with our applications. So now to do that, we might have to expand our application's supported usage scenarios. So what we want to do is make sure that our application empowers users who have physical limitations, users who may have visual challenges, or users who may have challenges with their physical movement, but accessibility goes beyond that. Accessibility is also a key part of our application supporting devices that are non-phone and non-tablet devices, things like smart TVs that may not have a touch screen or things like Android devices installed in cars where the user may not always be able to see the display. The Android accessibility system is a key part of supporting these kinds of devices. So now to do this, we need to change our assumptions about the way users interact with our applications. We have to change our assumptions about how information is presented, and we have to change our assumptions about how users navigate through our application. So let's first look at this idea of presenting information. So if an application presents a screen, in this case, it's a simple login screen, and we want to present the information to the user, the names of the fields, the purpose of a button, that sort of thing. Traditionally, we assume that the user can actually see the display, so the user looks at the display and can read with their eyes the information being displayed, but that's not always the case. You may have a scenario, again where we have an Android device in the car and the user is driving, so they can't look at the display, so they have to have a way to know what's being displayed without actually being able to see the screen. And we also have issues of users who are blind, who are unable to actually see the screen at all. And then going beyond that, in addition to blind users, there are many users out there who can see, but they have what's called low vision. With low vision, they don't see that clearly so it may be very difficult for them to read the contents that's being displayed on the screen. So the way we deal with all these situations is using what are called screen readers. Now far and away the most common screen reader on Android is something called TalkBack. What TalkBack can do is actually read out loud the content that's on the screen so the user can know what's being displayed by listening, they don't have to actually be able to look at the display. But there are many other screen readers as well. For example, there is one called BrailleBack and what BrailleBack does is take the contents that's being displayed on the screen and translate it into braille and allow users to read the screen content using braille. So now in addition to presenting the information, we've got the issue of navigation. When we build our applications, we generally assume that the user is able to touch the screen. So if they want to select the username field, they can just touch it. If they want to move to another field, they can just move to that field. If they want to click on a button, they can just tap on that button. But that's not always the case. Again, if you're thinking of the idea of a smart TV, the TV may not be a touch screen, so navigation may have to occur through a directional pad on a remote control or a user may have physical challenges that makes it difficult for them to have the fine motor control to touch individual fields on a display. So for these scenarios, we have to provide use with some way to navigate from field to field. So they have to have the ability to select an individual field, they have to have the ability through a controller to move to another field, and they have to have the ability through a controller to do things like click a button. So the way we deal with these scenarios is by incorporating D-pad support. D-pad is just common name for a directional pad. A directional pad can present something like an assistive device, which allows a user who may have physical challenges to move through and select fields in our applications, when in addition to that, there are many common scenarios where a D-pad is a four directional controller, so we can actually move up, down, left, and right. And we'll see those in situations like smart TVs where there is a directional controller on the remote or you might even see those in a car where the steering wheel has a four-directional controller that the user can use to move through fields in an application. So as we build our applications to be accessible, we need to support both these interactions. We have to make sure our application can present information in a way that screen readers can read it to the user and we have to make sure that users can navigate through our application using D-pad and D-pad style controllers. So in our next clip, let's see how our application does when used with a screen reader and a D-pad.

TalkBack Screen Reading and D-pad Navigation
So here we are now in our emulator, and what we want to do now is see how our app behaves in an accessibility enabled runtime environment. The emulator we're using here has been configured to include D-pad support and has TalkBack installed. TalkBack is installed by default in pretty much all physical devices, but it's not installed by default on emulators. For emulators, we actually have to download and install it. So in the Before folder for the exercise files in this module, I've included instructions for how to set up the emulator with D-pad support and how to install TalkBack. Alright, so now to test out our app, the first thing we'll need to do is turn on TalkBack. So I'll open up our application list, I'll scroll down, once we scroll down, I go to Settings and I'll choose that, we get to our list of settings, I'll scroll down, and once we've scrolled down, you see one of the options is accessibility, so we'll go ahead and select accessibility and that brings up a number of accessibility options and you'll notice that one of them we have here is TalkBack and TalkBack is currently turned off. So let's go ahead and select TalkBack. So now we're here in TalkBack and TalkBack is currently turned off, so let's go up to that switch, I'll select the switch, that brings up an alert to confirm that I want to turn TalkBack on, we'll choose OK. TalkBack on, TalkBack. You can see TalkBack announced that it was on. So now let's go up to the text that's displayed here near the top and then I'll click on it. When TalkBack is on, your device provides spoken feedback to help blind and low vision users, for example, it describes what you touch, select, and activate. So as you can see, TalkBack was reading to us the text that's displayed there and it would have continued reading all of it, except I clicked Again, and once I click Again, it actually stopped reading. So to leave TalkBack, you can see we have that arrow up there in the top left-hand corner. Let's go ahead and select that. Navigate up button. And notice that when I click the arrow, I didn't leave the screen. Instead, Talkback told us that we had just selected the navigate up button and then it drew this green highlight around it to show that it's selected and this behavior is part of what's called the Explore By Touch feature of TalkBack. Touching or navigating to any kind of control like an arrow, a button, or anything similar to that doesn't actually perform the associated action. Instead, TalkBack simply selects it and gives us a description of it. To perform the actual action, we actually have to double-tap on it. Accessibility. So when I double-tapped, we left TalkBack, went back to accessibility, and TalkBack told us that we were at accessibility. So let's head to our overview button on the bottom right of the screen, let's go ahead and select that. Overview button. So it tells us that it's the overview button, I'll double-tap on it. Overview, NoteKeeper. That gives us the list of available apps. One of those is our app. So I'll go up to our app, double-tap on that. NoteKeeper, showing items one to five of eight. So it told us we were in the NoteKeeper app and it tells us how many items are actually being displayed in the list. So let's go up here to our very first card, let me go ahead and select that. Android Async Programming and Services. Long running operations. So as you can see, TalkBack is reading to us the contents of that card. So our card views inside of our Recycler view seem to be working well with TalkBack. Let's head down to this button down here. Let's go ahead and select that. Unlabeled button. So TalkBack called this the unlabeled button. So for a user who couldn't see, they would have no idea what this button is for because they wouldn't see that plus graphic that's displayed within the button, so we're going to have to make some kind of improvement there within our application. So let's head back up to this first card, I'll select it. Android Async Programming and Services. Long running operations. So now I'll actually go into our note activity, I'll actually double-tap on it. Editing Long running operations, edit box, edit note. So we went into our note activity, TalkBack told us the title of the activity, edit note, and told us that we were in this edit field and it read the content, long running operations. So that shows us how TalkBack itself interacts with our application. Now over here on the left, you see we have our D-pad. So let's click the up arrow on the D-pad and see what happens. Drop-down list, Android Async Programming and Services. So we moved up to our course title field, so that's working as we might expect. Let's go ahead and choose the down arrow. Editing long running operations edit box. Showing item one of four. So I'll move down to our note title field, so that's reasonable. So our up and down seems to be doing okay. Let's go to our right arrow, let's click on that. Capital L. So we'll click on it again. O. And again. N. So each time we click on the right arrow, we're moving to the next character to the right and TalkBack is reading to us the character we just passed. And I want to click on this several times to get to the end of the field, so I'll click on it one more time. S end of field. So TalkBack told us that we went passed the character S and we're at the end of field. So let's hit the right arrow again. Cancel. And you can see with the right arrow there, we actually jumped up to our Cancel menu option. Now that might be a bit confusing. Let's try another field. So I'll go ahead and hit the down arrow. Drop-down list, Android Async Programming and Services. So that takes us to our course title field, so that was good. So now let's hit the right arrow from here. More options button. And with the right arrow there, we jumped up to the more options button, and again, that might be confusing. So now it might make more sense that when we're in the course title field, the right arrow would take us to our note title field, and then in our note title field when we hit the right arrow there, it might make more sense to go to our note text field. So that's another thing we might want to see how we can improve in our application because your application is kind of doing okay with a D-pad and TalkBack, but there is certainly room for improvement. So in our next clip, let's see what's involved in providing those kinds of improvements.

Content Descriptions and Focus Navigation Control
When we use TalkBack with our application, we saw that as a screen reader, it did its best to infer the appropriate description for each view, so it basically used any view's displayed content as the description that it read for that view and this behavior works well for most of our text based views, things like text views and spinners, but there are times where you may want to specify an explicit description and we can do that by using the contentDescription attribute in the layout resource, so each view can have an explicit contentDescription associated with it and this works well for non-text view types, thing like floating action buttons and other views that don't have a display text associated with them. Now our applications often include EditText fields, and when we enter text into an EditText field, we would, of course, expect for that text to be included in a description, but an EditText field is more than simply the entered text. Edit text fields also have a purpose. Alright, there is a field for the note title, there is another EditText field for the note text, that sort of thing. And the screen reader has to be able to identify that purpose to the user and there are a couple ways we can do that. Now one way we can do it is by using the hint attribute. Now when we use the hint attribute, when the EditText field has no text entered into it, the screen reader reads the hint as part of the description of the field. But then once text is entered into the EditText, the hint is no longer read, only the contained text is read and this is very consistent with the behavior of an EditText visually. When we're looking at our screen and we look at an EditText field, if there is no text entered, the hint is displayed. Once we type text into the EditText, the hint is no longer displayed, so very consistent behavior between the visual experience and the screen reader experience. But now as an alternative to the hint attribute, we can instead use a TextView to identify the purpose of an EditText because we can actually link a text view to an EditText. TextView includes an attribute labelFor and if we associate the id of an EditText with a TextView's labelFor, then that TextView will always be included in the description of the EditText, and again, this is very consistent with the visual experience. When we use a TextView to label an EditText, you can always see the TextView, so the screen reader description always includes the TextView. Now when we were working with our application, as we saw, Android can infer the directional relationship between views and its default behavior is pretty good. We saw as we tried to move up and down our views using the D-pad, it moves in a consistent and meaningful way, but there are times where it may need help. We saw one use the right arrow from within a view, we were jumping up to our Options menu and that may have not been the best choice. So when we need to specify directional relationship, we can use layout attributes to do so and there are a series of layout attributes that accept view ids and that indicates which view you want to move to in a specific direction and there are attributes available for each of the directions. So there is a nextFocusUp attribute that we use to indicate what view we want to move to when the user presses the up arrow. In the same way, there is a nextFocusDown, nextFocusLeft, and nextFocusRight. So we can provide navigational control on any of those four directions that we may need to. Alright, so now in our next clip, let's update our application to work more effectively with the screen reader and directional navigation.

Controlling App Accessibility Behavior
Here we are in Android Studio and what we want to do now is incorporate better accessibility support into our app. Now we're currently looking at the layout resource for our main activity and the first thing we'll do to improve our app's accessibility support is address our app's interaction with the screen reader. Now when we ran our app earlier, most of it worked well with the screen reader. There was one key place though that didn't. That was the floating action button on our main activity. But since our floating action button has no associated text, there was no way for the screen reader to infer a description, so we'll instead need to explicitly provide a description. The layer resource we have open, activity_main, is the top-level layout resource for our main activity. Now looking here at the preview, we can see our floating action button, but as you recall from earlier in the course, layout resources often include other layout resources. And if we look at our component tree, we can see that there is no floating action button within the activity_main resource. This resource does, however, include another layout resource, that's app_bar_main. So let's head over to that resource file. Here we are now in the app_bar_main layout resource, and looking at this component tree, we can see that this layout resource does contain the floating_action button, so let's go ahead and select it. And then once we select it, we'll need to go over to our Properties window and switch over to the full properties list. So now here on the Properties list, let's go ahead and scroll down, and then once we scroll down a bit, we can see our attribute contentDescription. So let's give the contentDescription a value of Create new note. And by simply doing that, the screen reader will now use create new note as the description for this button and we'd want to do the same thing for any other views in our app where the reader couldn't infer an appropriate description. Okay, so that takes care of our main activity. Now let's head over to the layout resource for the content area of our note activity. So here we are now in our note activity's layout resource and let's address some of the navigation issues we experienced when we ran our app earlier. As you recall, when we ran the app, our up and down navigation worked well, but we ran into issues navigating to the right from our course title spinner and the note title edit text, so let's fix that. Now looking at the Properties window, we can see that we already have our spinner selected. So let's switch to the full view of our properties and then we'll scroll down. Now once we scroll down, we can see a group of nextFocus attributes and the one that we're interested in is nextFocusRight. So when the user navigates to the right from the spinner, we want the focus to move to our note title field. So let's set nextFocusRight to @id/text_note_title, so now that looks good. We've got the id value for our note_title EditText field. So now before we move on, let's go and do a build, and when we did the build, we got an error. Now looking here at the error message, it says that there is no resource with the id of text_note_title, but that doesn't sound right. In fact, if we look at the XML for our layout resource, we can see our EditText field and it does have an id of text_note_title. So what's the issue? Well just above where we declare the editText for our note_title, we can see the spinner for our course title and here is where the nextFocusRight attribute is set. And the reason that we're getting an error is that the build process has encountered that nextFocusRight reference to our text_note_title id before the EditText with that id has been processed. Now let's look closely at the value for our nextFocusRight attribute. Now it starts out with @id then /. If we think way back to the beginning of our course series, we talked about the fact that when we started an id reference with @id that id value must already exist and text_note_title doesn't yet exist as an id value, and the way we fix this issue is by placing a + sign just after the @ symbol. As we talked about earlier in this course series, by including that plus sign, we indicate that the id value may not yet exist. So with the plus sign there, we can prevent this sort of build error. In fact, whenever we set layout attributes that reference the id value of another view, we generally want to include the plus sign just as we did here. So now let's switch back to our Design View. Now back here in the Design View, as we look at the preview of our layout, you'll notice that our custom view isn't rendering correctly and that's simply because we had a failed build. When we do a successful build, that'll again render correctly. But before we do that, let's go ahead and set the nextFocusRight attribute on our note_title field. So here in our component tree, I'll select the note_title field. In the Properties window, let's scroll down. So we're here now at the nextFocusRight attribute and we'll set this one to the id value of our note_text field. At this time when we set nextFocusRight, we were sure to include the plus sign in the id reference. So now we should be set on the right navigation for these two fields. Navigating right from the course title spinner should take us to the note_title field, and navigating right from the note_title field should take us to the note_text field. Now before we move on, let's do another build. This time, everything builds correctly. So including those plus signs and the id references took care of the build issue we were encountering earlier. So it looks like we're all set here. So in our next clip, we'll verify that everything works as we expect.

App Behavior with Accessibility Control
Here we are with our app up and running and what we want to do now is verify that the accessibility support that we've added to our app works as we'd expect. So the first thing we'll take a look at is our new note button. Remember that we've actually added a content description for this button, so I'll go ahead and select it. Create new note button. And as you heard, TalkBack now describes it as create new note button. So our content description is working just as we want it to. So I'll go ahead and double-tap on our new note button. Editing note title edit box. Edit note. Showing item one of four. And so, when I do that, we'd go into our note activity to create a new note. Now we're currently positioned on our note title field, now this is an edit text and it doesn't have any content in it. So as you heard, TalkBack read the hint as the description for this edit text field. So now let me go ahead and enter some text, something like this is the title. So we've added some content to our edit text field. So let's start using the D-pad to navigate through the fields, and by doing that, we can see how our navigation behaves, we'll also see how TalkBack changes the description of the field we navigate back to it. So the first navigation we'll do is just navigate up. This is a title beginning of field. So when I first click Navigate up, the selection moves to the beginning of the edit text field. Let's go ahead and navigate up again. Drop-down list. Android Async Programming and Services. So our navigating up continues to work properly. So now let's try navigating to the right. So I'm going to go ahead and click navigate right. Editing this is a title edit box. And notice now it moves from the course title field to our note title field. So the navigation setting we added to the layout resource is working just as we specified. We wanted the right navigation to move to our note title field. Also, since the edit text now contains content, TalkBack reads the content this is the title rather than the edit text hint. So now I'm going to click NavigateRight several times to get to the end of our edit text field. So now we're at the end of our note title field, let's go ahead and navigate right. Editing note text edit box. And it properly navigated to our note text field. So now our right navigation is working just as we specified in the layout resource, but in addition to the navigation we specified in the layout resource, the inferred navigation by Android should continue to work just as it did before. So if I go ahead and navigate up. Editing this is a title edit box. So we navigate up to our note title field, and if I navigate down. Editing note text edit box. We navigated down to our note text field. So all those accessibility behaviors that we added are working just as we'd like them to and the inferred behaviors continue to work as well. Now up to this point, all of our accessibility interaction has been with the built-in view classes. So let's see what happens when we try to navigate to our ModuleStatusView. So I'll navigate down, I'll try again, and you notice that when I try to navigate down to our ModuleStatusView, nothing happens. And that's because when we create a fully customized view class, we're responsible to incorporate support for accessibility into that view class. We'll see how to do that in our next module, but before we do, in our next clip, let's see how we can incorporate accessibility testing into our automated UI testing.

Automating Accessiblity Checks
Thinking back towards the beginning of this series when we talked about user interface testing. We talked about the fact that complete user interface testing requires doing manual tests to fully verify the experience. But we want to automate as much of the UI testing as we can. Well accessibility is no different. We will need to do manual tests to fully verify our accessibility behavior, but we want to automate as much of our accessibility testing as we can, so we actually want to make accessibility part of our regular UI testing, and by doing that, we can automate checks for common issues that may come up with accessibility. And the automated testing system for accessibility covers things like the content descriptions and equivalent, other words, making sure the screen reader has something to read for each of the views. It also checks for things like duplicates. It makes sure that multiple views don't have the same content description. Having duplicate content descriptions would be confusing to our user who relies on the screen reader and it incorporates some other tests as well that are common things that have to be checked for to verify proper accessibility behavior. So the way we're going to automate our accessibility testing is by using a class called AccessibilityChecks and enabling that class before we run any of our tests. What the AccessibilityChecks class does is it creates what are called global view assertions. Now if you think back to when we talked about the way automated UI testing works is we rely on a class called ViewAction and ViewAction performs testing actions. Well global view assertions are assertions, other words, they're checks that are performed for every action within ViewAction. So what that means is the UI testing that we're already doing will automatically perform our accessibility testing as well. Now using the AccessibilityChecks class is really straightforward. Alright, we'll start out with our test class, remember as we talked about earlier, whenever we're doing UI testing, we mark our test class with the RunWith annotation indicating that we're using Junit4 to perform the test. Within our test class, we'll have a method, and we'll mark that method with the BeforeClass annotation, and as you recall, what that means is the code in this method will run before any of our tests are run. And inside this method, we're going to use the AccessibilityChecks class and we're going to simply call its enable method and then that's all we have to do. From there, we set up our rules and our tests just as we normally would, and then each time a ViewAction is performed against a view, the accessibility checks are performed against that view and its descendants. So by using the AccessibilityChecks class, we can verify the appropriate accessibility behavior of the views throughout our application as part of the UI testing that we're already doing.

Summary
To wrap up, here is one of the key things we want to remember from this module. Remember that our goal of accessibility is to provide usability beyond traditional expectations and move beyond that idea that someone can always see the device or always physically be able to touch the device. So by doing that, we empower users who may have physical limitations, but also, we enable our applications to work on devices beyond the traditional phone and tablet devices. So for an app to be accessible, there are kind of two interactions you need to support, we need to be able to present information in a way that screen readers can read it and we need to support navigation that works well with D-pad style devices. So now when it comes to the screen readers, in many cases, the screen reader can infer the description as long as the content contains text, they can be text views, it can be spinners, even edit text. Remember that edit text had some specific considerations in terms of the way it worked with hints or text views it'll use as labels. Remember that we can always control that description though. The view classes support an attribute called contentDescription and the text we provide for contentDescription is what the screen reader will use if it's provided. Now for D-pad style navigation, Android again does a pretty good job of inferring which view to move to when a user navigates, but again, we can take control by using the next focus attributes so we can indicate which view to move to when the user navigates left, right, up, or down. So just like all aspects of our user experience, we want to test our accessibility behavior and we can actually incorporate accessibility into our automated UI testing. We do that using the AccessibilityChecks class, and once we enable that, accessibility is automatically checked on any view and its descendants that we perform a ViewAction action against. Well alright, that wraps up this module. In our next module, we'll see how to incorporate accessibility features into our custom views.

Making the Custom View Accessible
Introduction
Welcome to our next module, Making Our Custom View Accessible. This is the Pluralsight course, Broadening Android App Appeal and Reach. My name is Jim Wilson. In this module, we'll learn how to incorporate accessibility features into our custom views. So we'll start out, we'll look at the key considerations for making our custom views accessible. We'll then learn how to use the ExploreByTouchHelper class. The ExploreByTouchHelper class handles many of the core details for incorporating accessibility features into a custom view. We'll then learn how to expose our custom view's content to the accessibility system as virtual views. And then we'll finish up, we'll look at how to handle accessibility actions within our custom view.

Custom View Accessibility Support
When we were testing out our applications accessibility features, all the built-in Android view classes worked well with the accessibility system, but our custom view didn't work well, in fact, we couldn't even navigate to our custom view. Now to support navigating to our custom view is actually pretty simple. All we need to do is make our custom view focusable, other words, our custom view has to support the idea of being selected. And to do that, all we need to do is call the setFocusable method passing in true and our custom view would become focusable. Now that's an important step, but all that would do is allow our custom view itself to be selected. It wouldn't provide any ability to access the module shapes within our custom view from the accessibility system. So what we need to do is describe the items within our custom view. So each of the module shapes within our custom view, which is normally a circle, need to be treated like a virtual view, so it needs to be presented to the accessibility system as if it's a view, which means we have to describe its characteristics and we have to provide its interactive features. So let's look at what happened when we were testing out our application. So if we wanted to navigate through the fields in our note activity, if we start out with our spinner selected, navigating down, took our highlight from the spinner to the edit text for our note title, navigating down again, took the highlight from the edit text for our note title down to the edit text for our note text. But then when we tried to navigate down again, we couldn't reach our custom view. Now as we mentioned, by making our custom view focusable, that actually would allow us to navigate down to it. But what would happen is we would navigate down to the whole custom view. There would be no way to interact with the individual modules in our custom view, just the overall custom view. Now in order to make our individual module shapes accessible, we need to understand a little bit about how the accessibility system interacts with the views inside of our activity. The accessibility system doesn't actually interact directly with the views. Instead, the accessibility system actually builds a parallel hierarchy of nodes that describe the accessibility characteristics of each of the views. So if we look at the content area of our note activity inside the accessibility system, there's a node. And then within the content area of our note activity, we have our spinner. So in the accessibility system, there is a node underneath that content area node that represents a spinner. Then we get to the edit text for our note title, there is a node that represents that edit text, gives the edit text for a note text. There is a node inside the accessibility system that represents that edit text. And then we get to our custom view class, there is a node inside the accessibility system representing that view class because all the Android view classes have the support necessary to present these nodes into the accessibility system. But now we don't want to stop at our overall custom view class. We want to support interaction with the individual shapes that represent each module. So what that means then is for each of the shapes within our custom view, there needs to be a node under our custom view node that represents that shape in the accessibility system. And so, our first shape has a node, our second shape will have a node, our third shape will have a node, and that will continue on for all the shapes contained within our custom view, but now they're not actually views, right, they're virtual views. So what we'll need to do is somehow generate these accessibility nodes into the accessibility system that represent each of the shapes within our custom view. Now the accessibility system is actually a very sophisticated system. If we had to actually manually wire up all that code ourselves to interact with the accessibility system, that would be a great deal of work. So to help us out with that, there is a class ExploreByTouchHelper and this actually provides the core accessibility support that we'll need. So what we need to do is extend ExploreByTouchHelper to create our own helper class that's specialized for our custom view. Now when we create this helper class, we'll generally nest it within our view class because the helper class will actually need to interact with our custom view class quite a bit. And what this helper class is going to do is provide the information about the virtual views within our custom view and any interaction features that they have. Now of course, simply creating our helper class isn't enough. We also have to associate our helper class with our custom view, and to do that, we're going to use a class called ViewCompat and it has a static method setAccessibilityDelegate, and what this does is it tells the accessibility system that our helper class provides all the accessibility information for our custom view class. Now in addition to associating the helper class with our custom view class, there is also a few view callback methods that we need to forward to the helper class. We want to make sure we forward the dispatchHoverEvent method, dispatchKeyEvent method, and onFocusChanged method, and forwarding these callback methods is really straightforward. Basically, all we do is whenever the callback method is called in our custom view class, we call the corresponding method in the helper class. Alright, so now in our next clip, we'll start implementing our helper class and we'll associate it with our custom view class.

Creating and Connecting Accessibility Helper Class
Here we are back in Android Studio and what we want to do now is start adding accessibility support to our custom view class. To do that, we'll create an accessibility helper class and connect the helper class with our custom view. Now we're currently looking at our ModuleStatusView class and we have our cursor position just before the end of the class. We'll be creating our helper class as a nested class so we can access the members of ModuleStatusView. So now to get us started, let's declare a private nested class named ModuleStatusAccessibilityHelper, then we'll have it extend ExploreByTouchHelper. The ExploreByTouchHelper class handles many of the accessibility related details. So our ModuleStatusAccessibilityHelper class will just need to provide the information and behaviors specific to our custom view. So now to do that, we'll need to implement the abstract methods that we inherit from ExploreByTouchHelper. So to implement those methods I'll press Alt+Enter, I'll choose Implement methods, we want all those methods so we'll just hit Enter again. So now we'll also need a constructor that calls our base class constructor. So I'll again hit Alt+Enter, I'll choose Create constructor matching super, and that gives us the skeleton of our accessibility helper class. So let's just scroll down here so we can see the whole class. So as we can see, we have our constructor, our constructor accepts a view as a parameter, and that view will actually be a reference to our custom view class, and then our constructor simply calls the base class constructor, and in addition to the constructor, we have four methods and we'll look at those methods in detail shortly, but before we do that, let's get the helper class instance created and connected to our custom view. So to do that, we'll scroll up a bit. So here we are now in our ModuleStatusView class' init method, and in here is where we'll do the work to start adding the accessibility support to our custom view class. So now the first thing we'll need to do is called a setFocusable method and we'll pass in true. So now once we do that, we'll need to create an instance of our accessibility helper class, so we'll declare a variable of type ModuleStatusAccessibilityHelper, we'll name the variable accessibilityHelper. Then we'll create a new instance of ModuleStatusAccessibilityHelper, and then we need to pass in a reference to our custom view so we'll pass in our this reference. Now we'll need the reference to our accessibilityHelper in a few different places, so let's promote this variable to be a field. So now that we have our accessibility helper, we need to inform the accessibility system that this helper class provides accessibility information for our custom view. So to do that, we'll use the ViewCompat class and then we'll call it static method setAccessibilityDelegate. So now the first parameter to setAccessibilityDelegate is our this reference and the second parameter is our AccessibilityHelper reference. So now by calling this method, it indicates that our mAccessibilityHelper is providing the accessibility information for our custom view. So we now have our helper class connected to our custom view. But now in addition to doing that, we also need to forward some of the view class callbacks to our helper class, so let's scroll down here a bit. So now we're here just after the init method of our ModuleStatusView class. Now in order to forward the callbacks to our helper class, we'll need to override the appropriate methods here within our ModuleStatusView class. Now the methods that we need to override are onFocusChanged, dispatchKeyEvent, and dispatchHoverEvent. So let's go ahead and add those methods. So we now have those three methods in our ModuleStatusView class. So all we need to do in each of these methods is call the appropriate corresponding method on our helper class. So we'll start here in our onFocusChanged method, so just after we call the super class implementation, we'll call our helper class' onFocusChanged method and then we'll pass the parameters received by the view class' onFocusChanged method to our helper class' onFocusedChanged method. So that takes care of onFocusedChanged. So now we need to forward the call to dispatchKeyEvent. Now dispatchKeyEvent returns a Boolean indicating whether an event was handled. So in this case, instead of always calling the super class implementation, we first want to call our helper class' dispatchKeyEvent and want to pass in that KeyEvent parameter. So now the helper class' dispatchKeyEvent will return true if it handled the event, otherwise, it'll return false. If it returns false, then in that case, we want to call the super class' implementation. So what we can do is place an or operator here and then call dispatchKeyEvent on the super class. So this way, by using the or operator, we first call the dispatchKeyEvent method on our helper class, if that returns true, we immediately return from our view class' dispatchKeyEvent. But if the helper class method returns false, then in that case, we call dispatchKeyEvent on our super class and that's behavior we want. Always giving the helper class the first chance at the event, but when the helper class doesn't handle it, then going ahead and passing in that event up to the super class. So now, down here in our dispatchHoverEvent method, we use that same technique. So now here in dispatchHoverEvent, we always give the helper class the first chance at the event, but if our helper class doesn't handle the event, then we pass the event up to our super class. And so now with that, we have our helper class connected to our view class and we're forwarding the appropriate callback methods to our helper class. So now in our next clip, we'll start looking at what we need to do to start implementing the methods in our helper class.

Custom View Item Accessibility
As we've talked about, when the accessibility system interacts with one of our activities, it doesn't actually interact with the actual views within that activity. Instead, the accessibility system relies on a node structure that describes those views in a way that's appropriate for accessibility. So what we want to look at it now as how do we provide the information required to allow the accessibility system to interact with those module shapes within our custom views. In other words, how do we have each of those module shapes appear to the accessibility system as if they're a virtual view. And basically, what we're going to have to do is describe each of the virtual views and virtual views have many of the same characteristics as actual views do. So one of the first things we're going to have to do is associate id values with each of our virtual views and those id values will behave much like id values on actual views, that's how we identify each of our virtual views within our custom view. Now once we associate the id values with each of our virtual views, we then need to describe those virtual views to the accessibility system. To do that, we're going to use a class called AccessibilityNodeInfoCompat. We describe our virtual views by setting properties on that class and each of our virtual views will have a node in the accessibility node hierarchy. So what's going to happen is the system is going to say well you gave me an id value, describe that virtual view that corresponds to that id value. So it's going to do that for our first virtual view, then it's going to go to our next virtual view and say well here is the id value, describe that virtual view to me, and this carries on for each of our virtual views until we've described all the virtual views within our custom view. And it's our accessibility helper class that's responsible for doing all this work. So it's that helper class that's going to be responsible to assign the ids to our virtual views. It's that helper class that's responsible to describe the characteristics of each of our virtual views. And it's that accessibility helper class that's also going to be responsible for any interactions that occur through the accessibility system with our virtual views. So now each of these jobs are handled by a particular method in our helper class. So the first method we want to look at is getVisibleVirtualViews and it's this method's job to return the id values that correspond to each of our virtual views. Now the id values we use here don't have to be unique throughout the activity, we just need them to be unique within our custom view. So these could be any integer values we want. One of the things we commonly do is just use indexes as the id values. So our custom view class already maintains arrays to manage the rectangles that correspond to each of these shapes, so we can simply use the index from that array as the id value for each virtual view. So the next method we want to look at is onPopulateNodeForVirtualView. And so now what happens is once we've given back that list of id values, the accessibility system is going to say well you gave me this id value and here is an AccessibilityNodeInfoCompat instance, set properties on that AccessibilityNodeInfoCompat instance to describe the characteristics of that virtual view. So this is the method that's really responsible for identifying the characteristics and capabilities of each of our virtual views to the accessibility system. But now users can actually interact with their virtual views and there is a couple of methods that handle that. One method is getVirtualViewAt and this receives an X and Y coordinate within our custom view. So what this method does is when a user taps within a bounds of our custom view, the accessibility system needs to know what virtual view they've interacted with, so the accessibility system passes in the X and Y coordinates of the tap. We then return back the id of the virtual view that's at that coordinate. And then the last method we'll look at is onPerformActionForVirtualView. Now this receives an ID value of a virtual view that was interacted with and a constant that identifies the action. So this method is called when one of our virtual views is interacted with through some mechanism of the accessibility system. So maybe a user clicks on one of her virtual views using the accessibility system. So it's this method that's responsible to perform the appropriate behavior based on the action that occurred through the accessibility system. Alright, so now in our next clip, let's start implementing our accessibility helper class.

Assigning Item IDs and Characteristics
Here we are back in Android Studio and what we want to do now is start implementing the details of our custom view's accessibility helper class and we're currently looking at our ModuleStatusAccessibilityHelper class and one of the first things we want to do here is provide the id values for the virtual views that correspond to each of the module shapes within our custom view. So we'll do that work here in our getVisibleVirtualViews method. Now this method receives a list of integers as a parameter, so what we'll need to do is add the id values of our virtual views to that list. Now for each of our virtual view ids, we can just use a corresponding index from our custom view class' ModuleRectangles array. So let's set up a for loop that counts through the indexes of our ModuleRectangles array and then we'll add each of those indexes to the integer list and that simply we've assigned the id values for each of our virtual views. So each virtual view, we identify by its corresponding array index in our mModuleRectangles array. Now there is one other thing we want to do in here. Let's go ahead and add a check to the beginning of the method to see if our mModuleRectangles array is null, and if it is, we'll return. And this if statement just assures that we don't run into any problems in the event that our getVisibleVirtualViewIds method gets called before we've set up our rectangles array. Alright, so we're all set with our virtualViewIds, so now we need to describe each of those virtual views and we'll do that work here in our onPopulateNodeForVirtualView method. So this method receives two parameters, the first parameter is a virtualViewId and our second parameter named node is a reference to an instance of AccessibilityNodeInfoCompat. So what we need to do now is describe the virtual view that corresponds to the id value that was passed to us by setting the appropriate properties on node. Now virtual views support many of the same characteristics as regular views. So for example, we want a user to be able to use the D-pad to navigate through each of our virtual views and those virtual views will need to be focusable. So we'll call the setFocasable method on node passing in true. So now as a user is navigating to the virtual views, accessibility system will need to know the bounds of each of those views. So to set the bounds on this view, we'll call node. setBoundsInParent and then we'll pass in the corresponding rectangle from our custom view classes and ModuleRectangles array. And this call to setBoundsInParent really shows the benefit of using the array index as our virtualViewId and when we needed to access the array. We didn't have to do any special work. We could simply take the virtualViewId we received and directly access the item in the array. That's one of the main reasons we like to set the id values to the array indexes when we can because it makes this sort of work so easy. So now by setting the bounds, the accessibility system knows the area within our custom view that corresponds to the virtual view. Now this area is important for a few reasons, but one key reason is that it indicates where to draw the highlight box when the user selects the item. So now, the user can use the D-pad to navigate through our module shapes and each one of those shapes will be properly highlighted. But now in terms of accessibility support, we still have one key thing missing. We don't do anything to support the screen reader, so we need to provide the screen reader with is a content description. So let's call node. setContentDescription. Now we can set this content description to pretty much any text we'd like. Now in real life, we might want to provide the actual title of the module. For simplicity here in our demo, let's just use the word Module followed by the virtualViewId. So now this way, each time one of our module shapes are selected, the screen reader will read something like module 0, or module 1, or module 2, and so forth. So now the work we've done here in onPopulateNodeForVirtualView, we've provided our based accessibility information, but one thing we still need to handle is when a user taps on one of our virtual views when using the accessibility system. For example, a blind user will select one of our virtual views by tapping on it and then screen reader will need to know which virtual view was selected so we can actually read the appropriate description. So we do the work of indicating what virtual view was selected and the user taps on one of them and this method getVirtualViewAt. So when a user taps on the area within our custom view, the accessibility system calls the getVirtualViewAt method passing in the X and Y coordinates of where the user tapped. So what we're responsible to do is return back the Id value that corresponds to the virtual view that was touched. So let's start out by declaring an int variable named moduleIndex and then we'll call our custom view class' findItemAtPoint method passing in the X and Y values. Now as you probably remember, we created findItemAtPoint earlier in the course and it handles the details of determining which module shape was touched and that's the exact behavior we want here. So then once we return back from findItemAtPoint, moduleIndex contains the index of the module shape that was touched. And since we use these indexes as our virtualViewIds, that's the value we can return back to the accessibility system. But one thing we have to keep in mind, the user may have tapped an area within our custom view that doesn't correspond to a module shape. So now in that scenario, our moduleIndex variable will have a value of invalid_index. So here in our return statement, let's check to see if moduleIndex is equal to INVALID_INDEX. Now Invalid_Index is a constant we made up to indicate that no module was selected. So now the way we indicate to the accessibility system that no virtual view was selected is by returning back the constant INVALID_ID that's contained in the class ExploreByTouchHelper. Now if the user did tap on one of the module shapes that corresponds to our virtual views, well in that case, we can just go ahead and return back moduleIndex, and with that, our custom view class should now have some basic accessibility support. We assigned virtualViewIds, we described the virtual views, and we handled the user tapping on a virtual view. So in our next clip, let's run our program, we'll verify that it all works.

Verifying Accessibility Behavior and Adding Checked State
Here we are with our app up and running and what we want to do now is verify that the accessibility support that we've added to our custom view is working. So we're currently looking at our note activity and with our note text edit text field selected. Earlier when we tried to navigate down to the module circles within our custom view, we weren't able to. So let's see what happens now that we've implemented our accessibility helper class. So over here on a D-pad, I'll navigate down, --- Module two. ---and as you can see, when we navigate down, we position to the module circle within our custom view that was just below where the cursor was positioned within the edit text field and then TalkBack read the description as module two and that's just the behavior we wanted. So let's try navigating to the left. Module one. TalkBack reads the description as module one. Let's go left again. Module 0. And then TalkBack reads the description as Module 0. So our D-pad navigation and TalkBack are working well. So now let's try selecting a module as if we're tapping on it. So I'll go ahead and click here. Module seven. And when we tap on the module, the highlight box shows it as selected and TalkBack reads the description. So our custom view is actually behaving pretty nicely from an accessibility standpoint, but we know there is some room for improvement. For users who are able to see, they can tell whether a module is complete by the visual indication of the module circle being filled in or not being filled in, but for users who are unable to see the display, we've provided no indication at all as to whether a particular module is complete. So let's head back to Android Studio and see what we can do to provide that information. So we're back here in Android Studio and we're looking at our onPopulateNodeForVirtualView method from our ModuleStatusAccessibilityHelper class and remember that this is the method where we describe our virtual views. So what we need to do here is expand our virtual view description. So let's think about how we've implemented our custom view where we use the circles represent modules in a course and each of the circles can mean one of two states, it's either complete or it's incomplete and we can think of these two states as being checked or unchecked. So what we need to tell the accessibility system is that each of the virtual views supports this two-state concept of being checked or unchecked and we do that by calling the node. setCheckable method and passing in true. And then once we indicate that the virtual view was checkable, we need to indicate whether it's currently checked. So to do that, we'll call node. setChecked and then we'll pass in the current element from the custom view class' mModuleStatus array. Remember that the view class' mModuleStatus field is a Boolean array that contains each module status, so for those modules that are complete, the accessibility system will indicate that module is checked. For those modules that are not complete, the accessibility system will indicate that module is unchecked. So let's go ahead and run our program again and we'll see how things have changed. So we're back here with our app running and let's try navigating down to our custom view. Checked module two. You notice that time when we moved down to this module circle, TalkBack first said checked before it said module two. So let's navigate down again. Not checked module seven. And this time, TalkBack said not checked before saying module seven. So now, each of our virtual views properly indicates it state to the accessibility system, but now what if our person using a D-pad wants to change the state of a module. Well in that case, they'd click the center button on the D-pad, so let's try doing that. So I'll click our center button, I'll click it again, and nothing is happening and this is a really important feature. Users need to be able to change the completion status of the modules. So in our next clip, we'll see how to add support for using the D-pad to change the completion status of the modules.

Changing Accessibility State with D-pad
Here we are back in Android Studio and what we want to do now is add accessibility support for changing the module completion state of the virtual views within our custom view. We're currently looking at the onPopulateNodeForVirtualView method of our ModuleStatusAccessibilityHelper class. To allow users to change the virtualView state using the D-pad center button and other similar accessibility devices, we need to add support for the click accessibility action. Now the supporting accessibility actions are part of a virtual view's characteristics, so we'll need to set that characteristic on the node parameter passed into onPopulateNodeForVirtualView. So to do that, we'll call node. addAction, we'll then pass in the constant for the accessibility click action. So that takes care of indicating that the virtual view supports the click action. Now what we need to do is actually handle the action and we do that in the onPerformActionForVirtualView method, and as its name implies, the onPerformActionForVirtualView method is called when an action is performed on a virtual view. As parameters, it receives the virtualViewId and the action constant. So the first thing we'll do is add a switch statement that checks the value of the action parameter. Then we'll add a case for the ACTION_CLICK constant. Since we're handling this action, we need to return back true from onPerformActionForVirtualView. So now when the user clicks on the virtual view with an accessibility device, we want to perform the same behavior we performed if a user who is not using an accessibility device tapped on the module. So we'll call our custom view class' onModuleSelected method and we'll pass in the virtualViewId. So we're basically saying that a click from an accessibility device is the same action as a tap by a non-accessibility user. So now with that in mind, let's scroll up and take a look at the custom view class' onModuleSelected method. So we're here now in the onModuleSelected method of our ModuleStatusView class, and as you recall, the main purpose of this method is to change the module completion state. So for modules that are incomplete, this method makes them complete. For modules that are complete, this method makes them incomplete. So now thinking back to earlier in the course when we implemented this method, remember that when we change the state of a module, we had to tell the custom view to invalidate, and by invalidating, it would cause the custom view to redraw its appearance to reflect the change in state. Well we need to do that same sort of thing from an accessibility standpoint. So here, just below where we call invalidate to update the visual state of our custom view, we need to update the accessibility state. So we'll use our AccessibilityHelper field and we'll call invalidateVirtualView passing in the index of the affected module. So now, our accessibility state is updated in much the same way as our visual state. Now before we finish up, we need to do just one more thing. We need to send a notification about the click event to the accessibility system. So to do that, we'll call our AccessibilityHelper class' sendEventForVirtualView method and then we'll pass in our moduleIndex and the constant for our click event. So now with that, we should be all set. So let's go ahead and run our program. So now we're back here with our app up and running and we're currently looking at our note activity. So let's go ahead and navigate down. Checked module two. So TalkBack says it's a virtual view for module two is checked and that's correct. So let's see if we can use our D-pad center button to change this state. So I'll click on the center button--- Not checked. ---and when we do, TalkBack indicates that the module is now not checked and the visual appearance of the module properly updated to show that module is now marked as not complete. So let's select the D-pad's center button again, --- Checked. ---and when we do, TalkBack indicates that module is now checked and the module's visual appearance properly updates as well. So we're in really good shape now. Our custom view supports screen readers like TalkBack, supports D-pad style navigation, and it supports the interactive capabilities of accessibility devices.

Summary and Where to Go from Here
To wrap up, here is one of the key things we want to remember from this module. When we create custom views, they, of course, need to be accessible, and in order to make a custom view accessible, it needs to be focusable so we can move to it using a D-pad style device, and we need to describe the content contained within the custom view, and what we do is we represent that content to the accessibility system as virtual views. So the accessibility system is able to interact with our custom view content as if that content is actual views. Now a big part of being able to do this is the ExploreByTouchHelper class because it provides the core accessibility support. There is a lot going on in terms of tying into the accessibility system. ExploreByTouchHelper class takes care of most of those details, all we have to do is extend it to specialize it for the specific needs of our custom view. And remember, when we associate our accessibility helper class with our custom view, there are two key things we have to do, one is we have to designate it as the accessibility provider for our custom view, other words, we have to tell the accessibility system that it's the helper class that handles the accessibility details for the custom view. But remember, that isn't enough. There are also a few callback methods that we have to be sure to forward to our accessibility helper class because if we forget to forward those callbacks, our view will not provide appropriate accessibility behavior. Alright, that wraps up this module and it wraps up this course. And that wraps up this series, so congratulations. You've made it all the way through Pluralsight's Google Associate Android Developer path. Now throughout this path, we've covered a lot of content and having a firm understanding of this content is central to your success as an Android developer and being prepared for Google certification process. So the big question is, where does one go from here, and there are a few things that you'll want to do. Now first, be sure you've gone through the learning checks throughout the series. They're a great way to confirm your understanding of the topics we've covered. Also, be sure to take the skill IQ that accompanies this path as that skill IQ will provide a good picture of your overall understanding. Next, be sure to spend time in code. As developers, it's spending time in code that really deepens our understanding. So if you haven't already done so, work through the exercises that accompany the courses in this series and be sure to spend time creating and experimenting with Android code. And finally, re-watch clips and courses to reinforce your understanding. After having gone through the course series, you have a much deeper understanding of the content than you did in the beginning, so watching those videos again in the light of what you've already experienced will help you to develop a more complete understanding of the content. So from me and my best recording buddy, my cat Franklin, thank you for spending this time with us. I hope you've enjoyed it as much as we have. We sincerely wish you success in all that you do.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Advanced
Rating
4.7 stars with 23 raters(23)
My rating
null stars

Duration
4h 4m
Released
2 Jan 2018
Share course