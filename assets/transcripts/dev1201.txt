Orchestration and Automation: The Big Picture

by Josh Duffney

Automation is the key to surviving in today's tech world. In this course, you'll learn what automation is and how it is managed with orchestration.

Technology is changing at an ever-increasing rate. Humans can no longer effectively maintain the administration of technology without leveraging automation. Automation is the key to surviving in today's tech world. Throughout this course, Orchestration and Automation: The Big Picture, you'll learn what automation is and how to manage automation with orchestration. You'll also learn the benefits of investing in these two technologies and how they can make your daily work easier and more enjoyable. By the end of the course, you'll have an understanding of what orchestration and automation are and why they're beneficial to today's IT landscape.
Course author
Author: Josh Duffney
Josh Duffney

Josh Duffney is an IT Professional turned PowerShell Developer who is fascinated by all things DevOps and automation. He is a Pluralsight author, speaker, blogger, technical writer, and an...
Course info
Level
Beginner
Rating
4 stars with 63 raters(63)
My rating
null stars
Duration
0h 49m
Released
17 Jul 2017
Share course

Course Overview
Course Overview

Hello everyone. My name is Josh Duffney, and welcome to my course, Orchestration and Automation: The Big Picture. It's no secret that technology is changing at an ever-increasing rate, a rate at which we can longer effectively maintain the administration of technology without leveraging automation. Automation is the key to surviving and thriving in today's tech world. This course starts off by introducing you to what automation is and how to use it. Next, it covers the benefits of automation. I will discuss the benefits that you will receive as an individual, as well as the benefits an entire organization gets when their teams start to leverage automation effectively. The course then moves on to talk about orchestration and how you can use orchestration to manage your automation. You will also learn about the different types of orchestration. Understanding these different types will help you choose which orchestration tool is best suited for your automation. By the end of this course, you will have the foundational knowledge required to start implementing automation, as well as how to manage it with orchestration. I hope you will join me on this journey and learn more about automation and orchestration.
Automation: What It Is and Why You Should Invest in It
Introduction

Hello and welcome. My name is Josh Duffney, and this is my Pluralsight course titled Orchestration and Automation: The Big Picture. The technology landscape is undergoing a transformative change, and automation is a huge part of that. Automation is the key to unlocking the potential of any IT team, as well as any individual willing to put forth the effort to learn automation. This course teaches you what automation is, and how you can manage it with orchestration. This course is intended for developers who are seeking a better understanding of automation and how it fits into their world. With concepts like continuous integration and continuous deployment, it is important to understand automation because it's the glue that holds your software development pipelines together. This course is also intended for IT operations professionals and IT managers. As I mentioned previously, the technology industry is going through a transformative change, and these two career fields won't escape that change. A new mindset is required to become successful in this new frontier, a mindset to allows you to change the way that you've always done things, moving away from manual tasks and checklists, to fully automated solutions or self-service solutions. Before you begin, I would like to establish a storyline to help illustrate the concepts explained throughout this course. Allow me to introduce you to Quinn who is a systems administrator for a medium to large company. Quinn has three main problems he hopes to address with automation. The first problem he has is he's overworked. He can no longer keep up with the requests that come in for different tasks that he's responsible for completing. The second problem is his team is understaffed. This is one contributing factor to why he can't keep up with is daily work. The next problem is he's pretty backlogged. He can't get to the really awesome, cool, fancy projects that he wants to work on that would be more exciting because he's stuck doing lots and lots of manual, repetitive work instead of getting to those backlogged items that would propel the business forward. While Quinn researched a solution to these problems, he came across the concept of automation, and from everything that he has read thus far, it seems like the perfect solution to all of these problems. Quinn also has a few strengths that are going to help him greatly in his journey to understand automation and implement the concepts and principles of orchestration and automation. The first strength is he loves learning, and is always willing to learn new things and accept new challenges. One of his other strengths is he's extremely passionate about technology, which enables him to love learning about it that much more. Quinn has three primary reasons for wanting to learn automation. First, he wants to learn how to use automation to automate manual routine tasks. Automating those manual and mundane tasks will allow him to free up his time and reduce his current workload, which is his second reason for learning automation. His final reason for learning automation is he wants to use that newly found time to unblock his backlogged work. Everyone knows that the technology industry moves very fast. Being in that career field, he knows that he needs to carve out some time to focus on learning new things to better himself and his company. He of course knows that there are going to be some mandated projects coming up that he must work on, but he hopes that he can automate enough to find time for both of them.
What Automation Is

So what exactly is automation? The rest of this module answers this question and a few additional questions you might have around automation, such as what does it mean to automate something? How does automation run, and what triggers it? Let's start by defining automation. Automation is a technique, method, system, or process with the overall goal of reducing human intervention to a minimum. Reducing human intervention is the key part of this definition, because to truly automate something means to simply just remove the human elements out of the process as much as possible. To provide some context, let's take a look at a manual process, and then walk through what it would look like to automate that process. Quinn has a very manual process of onboarding new users. This is his first case for automation. The process starts off with a new user onboarding request. The first thing that he has to do upon receiving the request is to create the user accounts with the information provided in the request. Once the account has been created, he then has to determine which groups or group to add the user to, to grant them appropriate permissions to do their work. After the user is created and added to the appropriate groups, he then has to add a user share for them to store their documents. Fortunately and unfortunately for Quinn, his company is experiencing a lot of growth, and these requests are frequent and very time-consuming for him. This type of manual work is perfect for automation. It's rather simple, and it's frequent, which both qualify as a great opportunity for implementing some automation.
What Automation Looks Like

What would the previous task look like if it was automated? Well, you'd have to start with gathering the required information first. Just as you would in the manual example, you have to know certain pieces of information in order to complete the request. In the case of onboarding a new user, you need to know a few things like the first and last name and what department they were hired for. Once that information is obtained, it can then be passed to the automation, and then the automation would take that information and make decisions based on that input. Quinn has three different types of users, the first of which are developers, the second are sales, and the last one is marketing. Each requires slightly different tasks to be completed. Providing the department information to the automation would be enough to determine which set of tasks to complete. If the new user was hired for the software development department, they would have the title of developer and the automation would then execute the tasks for that user's role, such as adding them to the appropriate groups, and perhaps granting them access to shares and other things they would need to do their job. Similarly, if the new user was a member of the sales team, it would then execute an entirely different set of tasks to complete that request. And lastly, if they were a member of the marketing department, a different set of tasks would be executed. The automation can become as complex and complicated as you make it, but this demonstrates the overall looks of what automation is. You take the human element out of the process as much as possible. When working with automation, the information required for it to run is often referred to as the input. In our case, this input is the information required for the new user request, such as the first and last name and possibly the department that they're going to be hired into. The next piece of the automation is the trigger. Something has to kick off this automation. I'll talk more about triggers shortly. After the automation has been triggered, it then evaluates the input and decides what to do. Using the previous onboarding a new user example, the automation would evaluate the department information provided, and decide which type of user to create. If the new user was a developer, do X. If they were sales, do Y. And if they were a marketing person, do Z. Once it's determined which type of user to execute and the tasks associated with that user, it then executes X, Y, or Z.
Types of Automation

The previous few slides might have left you wondering what triggers automation? How does it know when to run, and how does it get the information it needs for its input? Those are both great questions, and the answer to that question is of course, it depends. There are four main type of automation, the first of which is manual automation. Now, of course, this doesn't mean a manual task that we were previously talking about. This task is automated, but it's manual in the sense that it requires you to put input into it, and hit the Enter key and kick it off yourself. So there's still some manual facet to this type of automation. I would say this is the most common type of automation because it's the easiest to start building and managing because you have control over when it runs and what gets inputted into the automation. The limitation to this type of automation is of course that it requires you to interact with it, and it's not fully 100% hands-off and unattended. The second type of automation is scheduled. Some automation does not require any input, and in that case, it's a great candidate for being scheduled at a specific time or a random time. A great example of this would be maintenance tasks such as a server reboot at a specific time in the early hours of the morning. There's no need to wake up at 2:00 a. m. to reboot a server every day. The third type of automation is event-based, meaning that something happens and then some automation can react to that event to handle the situation. A good example of this would be hard drive space. Once the hard drive space reaches 90%, it could kick off some automation to start cleaning up temporary files on the server, freeing up space and removing you from the process of having to remote into the machine and clean up space yourself. Now just like scheduled automation, events-based automation typically doesn't require any input. It knows exactly what it needs to do, and then can execute that automation. The last form of automation is self-service. Typically, this type of automation is front-ended by a website or ticket system. The reason for that is because this type of automation requires additional information, and unlike manual automation, this type does not require input or any effort from the operator, hence the name self-service. At the beginning of this module, I covered several reasons for why you should invest in automation. Automation reduces manual effort, which frees up your time, and in turn allows you to focus on more important things such as learning new technologies or working on a new and exciting project. You then learned what automation is. Remember, the overall goal of automation is to reduce human intervention as much as possible. After defining automation, you saw an example of taking a manual process of onboarding a new user, and what it would look like to automate that process. You were then introduced to several different types of automation, manual, scheduled, event-based, and self-serviced models of automation. Each of these types has its advantages and disadvantages, and it's going to be up to you to determine which type is right for the task at hand. In the next module, you will learn about the benefits of automation.
Discovering the Benefits of Automation
Introduction

The transition from being a point-click operator to an automator isn't always easy. There is a bit of a learning curve each time you encounter a new set of challenges, and with that learning curve requires additional time to complete the task, but often that's only the first time around. Still, this cost is more than most people are willing to pay, even though it pays dividends in the end. That's why it's important to understand the benefits of automation, both the short-term and the long-term. Understanding the benefits of automation will help you push past the urge to resort to your old ways of manually completing tasks. At this point in the story, Quinn has already embraced automation, and he took it upon himself to automate several of his routine tasks to free up time, which would allow him to work on bigger projects, and of course, to further his knowledge about automation. So far Quinn has automated the retrieval of information from servers. This was a common and very frequent request from developer teams wanting to know more about the systems their code resides on. The next task that Quinn automated was updating and restarting of servers. He's quite thrilled that he doesn't have to spend one weekend a month patching systems. The next task that he automated was the remediation of low disk space on critical servers. Other admins and operators on his team and other teams would often leave large temp files on the system, and to preserve storage he wrote some automation to clean up the temp files along with some other known directories and files when a server reached a certain percent of disk space full. The last request that Quinn automated was the installation of software. He was able to work with the service desk team to provide a self-service solution for users to request certain software.
Manual Automation: Getting Information from Systems

As I mentioned previously, the first automation Quinn wrote was to gather system information from specified servers. This was a manual type of automation because it required him to input target names into the automation. Once the target names were provided, it would then query for specific types of information, such as the network interface, disk space utilization, and the CPU specs. Quinn chose this as his first automation project because he often got requests from developers wanting to know more about the systems they were deploying their code to. Automating this would certainly yield some time savings for him, but that wasn't the only reason he chose this as his first automation project. He also knew that this would only require him to retrieve information from a system, so there was no chance of him causing any harm to those remote systems that he queried with his automation. The fear of the unknown stops a lot of us from starting anything new. It brings us out of our comfort zones. If that's the case for you, start learning to write automation that gathers information. It provides you a safety net which allows you to gain confidence in the automation that you write. After writing this automation, Quinn noticed several benefits, the first of which was a huge reduction in time required to complete the task. He no longer had to remote in to each system, find the piece of information required, and then write it down in a spreadsheet. The computer now does all of that for him and returns back the results. He also found it much easier to add additional information to the automation. Instead of adding another row to the spreadsheet and then look up that information, he now just updated his automation to include that new piece of information. The last benefit that he noticed was how repeatable it was. He no longer had to rely on his own memory or a checklist to complete the work. The automation would do the same thing every single time, which reduced human error.
Scheduled Automation: Updating and Restarting Systems

How much of your time or your team's time has been spent updating and patching systems? My guess is a lot. Performing updates is a touchy subject for a lot of organizations. They are necessary, but have adverse effects at times, which makes people really cautious about applying them. Luckily for Quinn, he didn't get too much pushback from the organization when he told them he wanted to automate this process. He decided to schedule this automation to run at the same time every month. This way, he could communicate out to the organization and they'd be prepared for possible reboots, as well as made aware of the changes that were being made. At that scheduled time the automation would trigger and run the updates on the target servers. After all the updates were complete, the automation would then reboot the servers. The automation would stagger the reboots to avoid taking down critical systems. The last thing the automation does is it verifies the servers came back online. It also checks to make sure that critical services were restored. At a glance this doesn't appear to be a good candidate for automation because it's complex and it has a lot of steps. In addition to that it has the ability to negatively affect the organization. These reasons actually make it a better candidate for automation. If this was left as a manual task, how likely do you think it would be that a server would get missed during this update process? For that matter, how often do you think the update process would even get ran? And what about the verify step? How likely do you think it is that this would get skipped? Depending on the number of servers, I'd say it's pretty likely that one would get missed during the update process. I'm also willing to bet that this process isn't executed very frequently, maybe once a quarter or maybe even less than that, which isn't good. You want to do this as frequently as possible. As soon as patches come out that affect you, you want to be able to apply them. And because organizations perform updates at night and over weekends, I'd say the probability of skipping the verify step is pretty high. The point I'm trying to make is it's better to have automation do this. Imagine no more weekends spent patching systems. In order to automate something, you have to have a firm understanding of what the process is. Without a clear process defined, you won't be able to write the automation that executes all the required steps. For that reason, the first benefit of the previous scenario is improved process. Before Quinn automated the update process, the process wasn't documented at all. It was more of a "get it done" kind of thing. He can now examine his automation's actions and extract a high-level overview of the process that can be shared with his team and the entire organization, which brings more awareness to the process for everyone involved. The next benefit is consistency. The updates are now performed in the same way every time, the servers are rebooted in the same order every time, and verification is always done. The improvement to the process and the improved consistency result in a more reliable solution, not only for Quinn but for the entire company. And that's the last benefit of the previous scenario's automation.
Event Based Automation: Remediating Low Disk Space

Low disk space has been the bane of many system administrators' lives. Having low disk space on a system is bad, but it's worse when it's a critical system that negatively impacts the entire company. Often low disk space goes unnoticed until it results in poor performance of a system. At that point a ticket is filed with the operators and they personally investigate the issue. This is a very reactive approach. By using automation, Quinn became proactive in resolving these disk space issues, solving them before they were even noticed by his customers. To accomplish this, he chose to use an event-based automation. The automation searches the log files for a specific event to occur. In this case, the warning indicates the disk is filling up. Quinn set the automation to trigger when it reaches 10% disk space remaining. If the trigger meets that condition, it then executes the automation that cleans up temp directories and known directories that often hold large documents and files that aren't needed. Most organizations have monitoring solutions in place to alert you when this type of thing happens. While that is useful, it shouldn't stop there. Start to think about how you can automate the remediation of those alerts. First and foremost, the best benefit of the previous example is being proactive versus reactive. Most people view being reactive as a negative thing, and your customers might think the same thing as well. Being proactive improves your customer experience because you solve problems before they even knew they were problems. This, in turn, improves your customer's confidence in you and in your team. Low disk space issues are so common in many organizations that people view them as a daily part of life, but it comes with a higher cost than you might think. Having to be reactive to issues like this causes a high degree of context switching, pulling you away from important project work and other higher priorities. Automating this reduces context switching and allows you and your team to remain focused on other tasks.
Self-service Automation: On Demand Software Installs

Quinn's most recent automation project has resulted in a self-service solution for his end users to request software. The automation is front-ended by the company's ticket system, which uses a form to gather all the required information. Once the information is provided, the automation then has to make a decision. It first evaluates to see if the software is free. If the software is free it will go ahead and then download and install the software for the end user. However, not all software is free, and Quinn accounted for that in his automation. He included some logic that requests a manager's approval when the software is a licensed product, which would result in higher costs for the company. He also knew that he didn't have every piece of software out there in the world, so he included a path for a user to request new software through a form if the software wasn't available at the company's app store. Software installations typically take a lower priority for operations teams, meaning users have to wait hours, if not days, for the task to be completed. Since putting this automation in place, the completion of these tasks is much quicker, which of course results in a much happier customer because they no longer have to wait for the software they need to do their work. As you can imagine, not having to deal with the vast majority of software installations, Quinn and his team have reduced their workload, thus saving a lot of time.
Individual and Organizational Benefits of Automation

Throughout this module you were introduced to several different examples of automation. Each of them had their own specific benefits, but collectively the benefits of automation are broken down into two categories, the first of which is individual benefits, which of course means how automation can benefit you. One of the more noticeable benefits listed in each example was the increased speed of performing the work. The bottom line is the computer can perform the work faster than you, so why not let it? In addition to that, in each example the number of mistakes made and errors were reduced. Remember the goal of automation is to remove as much human intervention as possible. Automation also makes every one of these examples repeatable. They will be performed the same way every time, making the process more consistent and reliable. A less obvious benefit of automation is it's shareable. Have you ever completed a really lengthy process and then tried to document that so you could share it with the rest of your team or, say, a knowledge base? Well depending on the task, it could be 2 to 10 pages of screenshots and paragraphs of instructions. Because automation requires the instructions be written out, oftentimes in code, it's a lot more shareable. In some ways you've already documented the process by simply automating it. And that's the next benefit of automation is it's documented. Whether it's in code or in an automation tool, it is documented in some way. The process is at least loosely defined, so you have an overview of what's going on. And lastly, automation is a lot of fun. I tried to convince myself early on in my career that I didn't want to be a programmer or write any form of code. I just didn't see the appeal. However, I can now say that writing code in automation is what's rejuvenated my career with excitement and reignited my passion for technology. You're not the only one who benefits from automation. The company that you work for benefits as well. Because you chose to learn and practice automation, the company increases its operational efficiency. Through automation, you get more done with less, which means the company's investment in you yields a higher return on investment. It's not uncommon for someone with automation skills to outperform their peers. Sometimes the person with the automation skills can do the work of 5 to 10 people, if not more. Automation also increases the quality of the work being done. It accomplishes this through a variety of ways, such as reducing human error, consistency, and so on. The bottom line is when quality improves, everyone wins. Another benefit, and a huge motivator for pretty much everyone, is reduced cost. Each of the examples of automation in this module resulted in a lot of time savings, and if you do the math, that's a lot of money. Throughout this module you were shown several examples of automation and their benefits. Every piece of automation has its own benefits because it's addressing its own specific problem. However, you also learned that there are individual benefits to you of automation, such as increased speed of execution, reduced effort and errors, reliable and repeatable processes, shareable code, documented processes, and enjoyment of your work. In addition to individual benefits there are also organizational benefits as well, increased operational efficiency, improved quality, and reduced cost just to name a few. In the next module you'll learn about orchestration, which allows you to manage all of these different types of automation.
Managing Automation with Orchestration
Introduction

As awesome as automation is, it does have a few downsides, one of which is, the more automation you have, the harder it is to manage. This is where orchestration comes in. There are a few different types of orchestration, but the overall goal is to help you manage your automation. Quinn has implemented numerous automation projects. He has even started to teach others on his team about automation and how they can both contribute to his automation and/or create their own. This has led to a few new problems he didn't expect. The root of the problem is unmanaged automation. Because he's no longer the only one running or writing automation anymore, he no longer has the answers to these questions: What runs where, who ran it, and when did it run? As you can imagine, this is a fairly serious problem. Not having the answers to these questions when something goes wrong is going to raise a lot of concern. If you can't prove when and where automation is running, and by whom, automation will be blamed for every unexplainable event. I've seen this happen firsthand where several engineers worked independently to automate various tasks. None of the engineers knew what the other was doing, so when something went wrong that made massive changes, automation was to blame and no root cause was discovered because no one knew where to look and how to troubleshoot the problem. This ultimately led to a distrust in automation, which hindered the engineers using it. Because you know the benefits of automation, you know that a distrust of automation should be avoided at all costs. Another problem Quinn is facing is how to connect several pieces of automation together into a continuous workflow. It's one thing to automate something, but to create an end-to-end automated process is an entirely different thing. He needs something that will act like the glue between the pieces of automation he's already written. So what's the solution? The solution to this problem is to implement orchestration. Using an orchestration tool, engine, or service will help you manage your automation and provide you with answers to all of the questions previously mentioned.
What Is Orchestration?

After you've written or created enough automation, you'll start to ask yourself, how do I get this automation to talk to that automation? And then when it's done, how do I put the output in a database or do something else with it? This is where orchestration comes in. It is the glue between individual pieces of automation. Orchestration describes the arrangement and coordination of automated tasks. Orchestration sits on top of the automation, acting like a conductor for the automation, instructing each piece to do its part and then to hand off work when needed to the next piece of automation. Arranging and coordinating is orchestration's primary purpose, but there are many other benefits and reasons to use orchestration. The first reason and benefit of using orchestration is centralized management. Orchestration gives you a single pane of glass to look at all of your automation. Everything is ranked through a single interface, making it much easier to keep track of the automation that's running and from where. This increased visibility will help you keep track of and manage your automation. Centralized management answers the question of what runs where. The next reason for implementing orchestration is auditing. Eventually something won't go as planned. The automation you ran will do something unexpected or encounter a condition you hadn't yet thought of, or it could be as simple as someone ran something at just the wrong time. In any of these scenarios, people will come knocking and start to ask questions. Questions like who ran what, what did they run, what did it do, and how do you fix it? While auditing can't tell you how to fix the problem exactly, it can tell you what ran, who ran it, and when, giving you a timeline and something to inspect to see how to reverse or correct the problem. Having auditing for your automation is critical for the success of the implementation of automation and the maintenance of automation. One of the most powerful features of orchestration is its enhanced workflows, which allow you to combine individual pieces of automation together into a fully automated or self-service solution. One of the questions Quinn had was, how do you connect automation into a workflow? Orchestration's enhanced workflows is the answer to this question. Workflows give you the ability to arrange automation into a sequence. It's the sequence that makes the workflow. Workflows also handle the communication between the individual pieces of automation in the workflow, tying them together into a single process. Most orchestration tools provide you with a web front end, which means you can use it to provide a self-service portal for all of your automation. You might be asking yourself, what's the benefit of a self-service portal? Isn't the point of automation to get away from GUI tools? To an extent, automation is about getting away from the GUI, but they still have their uses. Let's use the gathering system information automation as an example. Right now, Quinn has the automation stored in source control. If anyone wanted to use that automation they would have to download the code, figure out how to load it, and then run it. This is easier than doing the work manually, but imagine if the person wanting to run the automation could go to a website, fill out a few textboxes, and click Run. Self-service portals are a great way to empower other teams and your customers to perform work that you typically do-- but now they can do it through automation.
How Does Orchestration Work?

With all this talk about orchestration, it's time to take a minute to talk about how it works. There are three main components of orchestration, the first of which is a runbook. A runbook is a compilation of routine procedures, in this case, automated procedures. In orchestration, each piece of automation is often referred to as a runbook. Several runbooks connected together create a workflow. Workflows can be very basic or extremely complex. You could have a 3-step sequential workflow or a 30-step workflow that has complex run conditions, as well as parallel and sequential steps. In the end, though, workflows are what enable you to create fully-automated, end-to-end solutions. The last component of orchestration is called a pipeline. Pipelines are commonly used to explain software development processes. Things like continuous integration and continuous deployment tools are often used to create release pipelines for software. Pipelines are mostly used for software development, but they can be used by IT operations as well to handle complex processes that are tied together from source control. Something like infrastructure as code would fit nicely into an orchestrated pipeline. To add some context to each of these components, let's now take a look at an example of each of these, starting with a workflow.
Workflows

Quinn has an automated process that refreshes his QA environment with new databases copied from production. Even though the process is automated, there are several critical steps that he has to perform in between the automation to complete the process. He now wants to combine it all into a workflow and use orchestration to take him out of the picture entirely. His workflow ended up looking something like this. It starts off by copying production databases to a staging environment. Once the databases are copied to the staging environment, it then executes a masking process to blank out or randomize any personal or sensitive data in the databases. This helps protect the company and its customers from data leaks. After the masking process finishes, it then refreshes the QA databases with the new mask databases from the production environment, giving developers the most up-to-date data without compromising security. This workflow seems simple, but each of these icons represented here contain several runbooks. Let's take a look at what the refresh QA databases runbook looks like.
Runbooks

The refresh QA databases runbook starts off by first attaching existing databases. Since this is going to be refreshing existing databases and potentially adding new ones, Quinn needs to make sure that the old ones are detached first. Next, the runbook copies the masked databases from a staging environment to the QA environment servers. Once the databases are copied, the next step is to attach the new mask databases to the QA servers. And, finally, the runbook finishes by deleting old QA databases and cleaning up log files to preserve space on the servers. Each runbook can have as many steps in it as you want, but they are normally scoped to perform a specific process or procedure, and in this case, it's the process of refreshing QA databases with automation. Now that you've seen an example of a workflow and a runbook, you can now better understand how they fit together to create a solution. The workflow connects to the runbooks, but ultimately it's the runbooks that carry out the work.
Pipelines

Pipelines are called several different things: build pipelines, release pipelines, and/or deployment pipelines, to name a few. These pipelines are often referenced when talking about software development. They are used to automate the release of software applications, but they can also be used to manage and release automation. If you stop and think about it for a minute, what's so different about that business application from the internal automation you've written? In the end, they're both reduced to source code files with written instructions for the computer to interpret. A pipeline is one of the options you have available to you to help you manage and deploy automation you've written. So what does a pipeline look like? A pipeline starts off with source code. The source code is stored in a source control repository. When changes to that source control are made, it triggers a build, which is the next step in the pipeline. The build is responsible for assembling and putting together the automation. It combines any dependencies and is responsible for outputting an artifact that can be distributed. Once the artifact is created, tests should be run in order to ensure that the automation runs properly and no bugs were introduced with the changes that were made. These tests are automated using a framework that can test the source code. Most modern languages have some unit testing framework that can be used to test the source code. The build and the test phase are often the responsibility of a continuous integration system, which I'll talk about in the upcoming module. After the tests have finished and they pass, the pipeline moves on to the release phase. The release phase is responsible for deploying the new artifact and performing any actions necessary to make it operational on its targets. Continuous deployment tools are often responsible for this release phase, but not always. There are several types of orchestration tools, and depending on which one you are using, it can handle all or only a few pieces of this pipeline. I will talk more about the different types of orchestration tools in the next module. This module started off by introducing you to the concept of orchestration. You then learned the benefits of using orchestration, which are: centralized management, auditing, and enhanced workflows. You then learned how orchestration works. You learned about the different components of orchestration and how they work together to create a fully automated end-to-end solution. The orchestration components you learned about were: workflows, runbooks, and pipelines. In the next module, I will be covering the different types of orchestration.
Types of Orchestration
Introduction

There are several different types of orchestration tools, and each of them is designed for a different purpose, but all of them can be used to manage automation. This module focuses on breaking them down and explaining each type of orchestration. As you progress through the module, you'll have a better understanding of each type of orchestration and how it can be used to manage your automation. Going back to our storyline for a moment, Quinn now has an understanding of the benefits of orchestration and even has a broad understanding of how they work. But, he doesn't know which type of orchestration to use for his automation. After speaking with several different teams within his organization, he learned that several of them have their own orchestration tool. However, each of them operates differently and he's not sure what's the best fit for his automation. Quinn has two main questions that he wants to answer before he decides where to put his automation. What types of orchestration are there? He's curious if there's a better orchestrator for his automation or if he should just use another team's implementation. The other question he wants to answer is, how do they work? Quinn wants a better understanding of each type of orchestration so he can make well-informed decisions when it comes time to choose an orchestration tool for his automation.
Types of Orchestration

The first type of orchestration that I'll mention is an operating system task scheduler. The name is pretty spot-on for describing them. They are built into the operating system and their primary use is to schedule something to run. And in most cases, that something is automation. The next type of orchestration is runbook orchestration. Runbook orchestration normally requires additional infrastructure consisting of a management server and runbook runners responsible for executing the automation. Runbook orchestration provides the ability to create complex workflows discussed in the previous module. Next is cloud-based automation. Cloud-based automation is provided as a service through different cloud providers. You can use it through an API or a web portal, allowing you to manage and automate cloud resources and the configuration of those resources. Yet another type of orchestration is configuration management, which allows you to automate system state changes and provisioning of infrastructure. Next up is continuous integration, often referred to as CI. Continuous integration tools are typically used to automate the building and testing of software, but they also make a great orchestrator for automation. CI tools can be used for much more than just building software. They can also be used as a centralized location for executing and building automation. The last type of orchestration is continuous deployment. Continuous deployment tools are primarily responsible for deploying and installing software of some kind, but just like continuous integration, these tools make a great orchestrator for automation. Unlike continuous integration, continuous deployment runs decentralized, having an agent on every server in the environment that it needs to run on. This has its advantages and disadvantages, which we'll discuss later in the module. Before we dive into each type of orchestration, I want to quickly mention the different communication methods they have. Some types only communicate locally, such as the operating system task schedulers, while others use a remoting protocol to communicate between the management server and its clients. In some cases, they use an agent instead. An agent is a piece of software that is installed on the client that allows it to communicate with the central server. The last type of communication I'll mention here is a service. A service is used to communicate with all the different resources in the cloud that you manage.
Operating System Task Schedulers

The simplest type of orchestration is operating system task schedulers. Operating system task schedulers are built into the operating system, meaning they are available to use as soon as you install the operating system. At first you might not consider these to be an orchestration tool, but they certainly are. They provide a place to centralize your automation and even keep some basic logging on the tasks being executed. These two features alone make it a feasible orchestration tool for managing some basic and simple automated tasks. Operating system task schedulers work by defining a trigger. These triggers are scheduled at a specific time or interval, such as hourly, daily, weekly, monthly, and so on. Some even let you define the trigger based on an event that happens. Either way, the trigger is what kicks off the action. The action is the second part of the operating system task scheduler. The action specifies the program, script or automation that runs when the trigger goes off. The communication method for operating system task schedulers is local. The tasks that are stored in the operating system task scheduler run locally on the machine. All the settings and code used to run the automation is also stored locally. As you can imagine, this has its advantages and disadvantages. Having to store everything locally doesn't make this a very scalable solution. But don't count this out as an orchestration tool. It's a great choice for running simple and even some complex routine automation. This is also the easiest orchestration tool to use because it doesn't require any additional infrastructure or tooling.
Runbook Orchestration Platforms

Runbook orchestration provides you a workflow management system that allows you to coordinate, deploy, and monitor automation. The workflow management system gives you the ability to create complex workflows and runbooks that are centrally managed and auditable. Unlike operating system task schedulers, runbook orchestration requires additional infrastructure. The setup requires a management server, runbook runners, which are responsible for executing the automation, and it requires a database. The database holds all the information required to operate the runbook orchestrator. It keeps track of things such as runbooks, workflows, and everything else the management server needs to operate. All the interaction that you'll have with the runbook orchestrator is done through a web interface or a graphical console of some kind. This interface is used to create, edit, monitor, and audit workflows and runbooks inside the runbook orchestrator. The runbook orchestrator uses a communication method of agent. Agents are installed on every server that you want to be a runbook runner. When the management server wants to execute any automation, it communicates to the runbook runner through the agent. The agent then receives the request and executes the automation inside of a runbook. Runbook orchestration is a great tool for complex routine tasks involving handoffs between different systems. It also provides you all the benefits of orchestration. The ability to use runbooks and workflows is obvious, but it also gives you a single pane of glass to look through to see all of your automation. In addition to that, it also provides you with auditing and a self-service portal with the ability to delegate rights to certain workflows and runbooks, empowering other members of your team and people in different departments to execute workflows and runbooks that you've created.
Cloud-based Automation

Cloud-based automation platforms are offered as a service by different cloud providers, and what they provide is an end-to-end automated workflow that allows you to coordinate lower-level automation through an API or a web portal for cloud services. Cloud-based automation is provided as a service and is accessible through an API or a web portal. Cloud-based automation manages and coordinates cloud runbooks, cloud workflows, lower-level automation, and cloud resources. Since cloud-based automation is in the cloud, it only makes sense that the communication method used is a cloud service. This cloud service handles all of the communication and management of the previously-mentioned tasks, such as runbooks and workflows. The runbooks and workflows in cloud-based automation work the same way as the runbooks and workflows in a runbook orchestrator, but they of course manage cloud resources instead of on-prem resources. The lower-level automation tasks, however, need a little bit more explaining. This could be something as simple as executing a script that backs up a database, or something more complex like invoking code that configures a cluster of servers. Because the cloud is highly automated and was built with automation in mind, there is little you can't do with cloud-based automation to manage its resources.
Configuration Management Tools

Configuration management tools give you the ability to make system state changes, as well as the ability to provision infrastructure through automation. The purpose is to drive all the changes to a system or an environment through the same repeatable process. Configuration management tools require additional infrastructure, just like runbook orchestration platforms do. They require a central server, sometimes called a management server. There also has to be a way for the central server to communicate to its targets. Some configuration management tools use agents to transfer this communication, while others use a remoting protocol. Either way, there has to be a way for the central server to communicate with the target systems in the environment. Most, but not all, configuration management tools are heavily focused on declarative infrastructure. If you are not familiar with this term, it is the process of managing and provisioning infrastructure through machine-readable files or code. Essentially, the entire state of your system is defined in code with some type of file, opposed to the manual process of configuring a system, which involves remoting into that system and making changes by hand, everything is abstracted out into code files. These files are written in DSL. DSL stands for Domain Specific Language. Each configuration uses a different DSL, but their purpose is the same. It is to abstract out system changes to human and machine-readable files. Configuration management tools are used to handle entire environments, so it's critical that each machine in the environment be able to communicate with the central server. Configuration management tools communicate with either an agent or a remoting protocol. Keep in mind that all the automation a configuration management tool runs will be executed on the remote system. None of the automation actually runs on the management server. The management server's purpose is to deliver instructions to the remote system. The remote system then executes the automation. This is a bit different from the runbook orchestrator in the sense that there are no dedicated runbook runners, or servers that are used to run automation. Instead, every system in the environment is in charge of handling its own automation. This is a huge factor to consider when deciding which type of automation to use configuration management tools for. Keep in mind that the purpose of this type of orchestration tool is to handle changes to the state of the system, not necessarily automation that interacts between those different systems.
Continuous Integration Tools

Continuous integration tools are designed to automate software development build processes that are triggered by changes to code in a central code repository, hence the term continuous integration. Even though their main purpose is to automate software build processes, they also make a great orchestrator for automation. Just like the runbook orchestration platforms, they do require additional infrastructure. They require a continuous integration server, a database, and they require a build agent. This is very similar to the runbook runners used with orchestration platforms. As I mentioned, this does require additional infrastructure, but if you work for a company that has an internal software development team, chances are one already exists inside your organization. If such a department exists and you are looking for an orchestration tool, I highly recommend seeking out the owner of that tool and asking them how you can get plugged into their process. And if nothing else, ask for guidance on how to set up your own instance of their continuous integration system. Using a common orchestration tool will greatly help you break down the silos between the teams, and is a great learning opportunity for both sides. As I previously mentioned, continuous integration tools provide a way for you to automate the software build process, as well as the testing of that software created from that build process. But they also make a great orchestration tool for automation because they operate a lot like a runbook orchestration platform does. Both utilize dedicated servers to execute their automation from, and both of them have a centralized server that is in control of all the automation. Continuous integration servers also give you a web interface that you can use to manage all of your automation from a central point, giving you that single pane of glass just like a runbook orchestration platform does. Continuous integration servers also provide all of the other benefits of orchestration such as auditing and self-service portals, and if you haven't already guessed it by now, the communication method used by continuous integration tools is agent.
Continuous Deployment Tools

Continuous deployment tools are designed for automating the deployment of software releases. Continuous deployment tools in the previously- mentioned continuous integration tools are pipeline tools that work together to release software. But just like continuous integration tools, continuous deployment tools are a great orchestrator for automation. Just like the majority of all of the other orchestration tools that I've mentioned so far, continuous deployment tools do require additional infrastructure. It requires a continuous deployment server or servers to be stood up in order to use the tool. These are the central servers, just like continuous integration has a central server and runbook orchestration has a central server. In addition to that, it does need a database of some kind. Lastly, it does require agents to be installed on all the deployment targets. Deployment targets are anything that you want to deploy to from the continuous deployment server. Continuous deployment tools provide a way to automate the deployment of software across different environments, which means you could also deploy automation to those environments as well. Even though continuous deployment tools are designed for software development, they give you all the benefits of an orchestration tool for handling your automation, such as runbooks, the ability to create enhanced workflows, a centralized place to manage the automation, and the ability to audit automation. Since the purpose of continuous deployment tools is to deploy software, their targets might not consist of every server in the environment, but instead consist of only the servers that require updates when the software is released. This is different from other tools, such as configuration management tools, because they target every server in the environment. This is just something to keep in mind when choosing your orchestration tool. The communication method used by continuous deployment tools is, of course, agent.
Summary

In this module you learned about the different types of orchestration, which can be categorized as built-in, runbook platforms, cloud-based, and/or pipeline tools. Throughout the module you also learned how the different types of orchestration work, and when they might be used to manage your automation. You also learned about the different communication methods of these different types of orchestration, which plays a huge role in determining which one you should use. You learned that some used a communication method of local, which means everything ran locally on the machine, while others used a remoting protocol. Several of the orchestration types used a communication method of agent, which is software that is installed on the machine that the management server uses to deliver instructions on how to execute the automation. Lastly, you learned that cloud-based automation uses a cloud service to run its automation. That wraps up this module and this course on Orchestration and Automation: The Big Picture. I hope this gave you some insight into the exciting world of automation and has inspired you to learn more about automation and apply it to your daily life.
Course author
Author: Josh Duffney
Josh Duffney

Josh Duffney is an IT Professional turned PowerShell Developer who is fascinated by all things DevOps and automation. He is a Pluralsight author, speaker, blogger, technical writer, and an...
Course info
Level
Beginner
Rating
4 stars with 63 raters(63)
My rating
null stars
Duration
0h 49m
Released
17 Jul 2017
Share course


