Continuous Integration and Continuous Delivery: The Big Picture

by Barry Luijbregts

Automating software delivery is key to success. This course will teach you that continuous integration and continuous delivery can help your organization make better software, release faster, save money, and respond faster to customer needs.

Building and delivering software isn't easy. You want to have a consistent quality and to be able to deliver new functionality quickly. In this course, Continuous Integration and Continuous Delivery: The Big Picture, you will learn how the practices of Continuous Integration and Continuous Delivery can help you to build and deliver quality software in a reliable way. When you've finished this course, you'll have a foundational knowledge of the concepts of Continuous Integration and Continuous Delivery that will help you to get your organization ready to deliver great software.
Course author
Author: Barry Luijbregts
Barry Luijbregts

Barry Luijbregts is an independent architect and software developer focused on preparing business applications and solutions for the cloud. A Microsoft Azure MVP, Barry is a skilled educator and...
Course info
Level
Beginner
Rating
4.1 stars with 248 raters(248)
My rating
null stars
Duration
0h 59m
Released
16 Feb 2017
Share course

Course Overview
Course Overview

Hi everyone, my name is Barry Luijbregts, and welcome to my course, Continuous Integration and Continuous Delivery: The Big Picture. I'm an independent software developer and architect with a passion for the cloud. Continuous integration and continuous delivery will enable your organization to build better software, release it faster, at lower costs, and be able to respond to the needs of customers faster. This course is an overview of the concepts of continuous integration and continuous delivery. Some of the major topics that we will cover include what continuous integration is and how you can use it, what continuous delivery is and why it is important, and what you need to do to implement continuous integration and continuous delivery. By the end of this course, you'll know what continuous integration and continuous delivery is and what you need to do to implement these concepts. Before beginning the course, you should be familiar with the basics of the software development process. I hope that you'll join me on this journey to learn continuous integration and continuous delivery with the Continuous Integration and Continuous Delivery: The Big Picture course here at Pluralsight.
What Are We Trying to Accomplish?
Introduction

Hi, I'm Barry. Welcome to this course, Continuous Integration and Continuous Delivery, the Big Picture. In this course you will learn what continuous integration and continuous delivery is and how these concepts can help you to improve your organization. Let's kick off with the first module. In this module, we will examine what we are trying to accomplish in our organization with continuous integration and delivery. In the module we will look at a fictional scenario of a company that we can improve with continuous integration and delivery. This will help you to understand the concepts of the course better. Also we'll look at what we can improve with continuous integration and delivery by examining the fictional scenario. And we look at the goals that we have. These aren't only the things that we can improve, but the overall goals that we strive to when we use continuous integration and delivery.
Exploring Your Scenario

Let's dive in. This course is built up around a fictional scenario. This will help you to put the concepts of continuous integration and continuous delivery in context. The scenario revolves around the company called Value Through IT. Value Through IT is a company that builds software for their clients. Their main client category is logistic companies. Value Through IT creates software as a service for these logistic companies. Value Through IT creates and maintains the software and deploys it in the cloud. The logistics company just uses the software. They don't have to download and install it, which makes this very easy on them. The software that Value Through IT creates is specific to the logistic companies. It has modules to manage logistics warehouses, their inventories and modules that manage schedules of employees that work in the warehouses. There's a lot of work involved in creating this software. Let's take a look at how Value Through IT does it. They have product management teams that talk to the customers and do market research. They use this knowledge to determine what functionality the software should have and how the software can be made better. The product management teams interact a lot with the software development teams. Product managers want to know what certain functionality will look like. Or if it is possible to create it at all. They also use input from software architects and development team leads to plan their functional road map and prioritize features. The software development teams take the input from product management and then start the process of creating features, which in itself involves things like software architecture and test design and software development. Whatever the software development teams create they pass on to the integration and operation teams. They integrate the work from the different software development teams and deploy the result into the infrastructure environments, like dev, test, acceptance, and production. After that, the quality assurance team tests the software with all sorts of tests. Performance tests, security tests, acceptance tests, you name it. They feed the results of the tests back to the product development and software development teams who can then determine which errors need to be fixed first. Value Through IT works iteratively, meaning that this whole process works in short iterations of three weeks. Together with product management, the software development teams take on enough work for three weeks and have it ready for integration and operations at the end of the iteration. Often there is no new release to production after three weeks as quality assurance has found errors and unexpected behavior that needs to be fixed before it goes live. This often means that after the initial three week iteration another follows to fix the errors and the result of that iteration is deployed to production. Let's take a look at all the teams that are involved in the creation and delivery of the software of Value Through IT. The software has different modules that all work together. However, the software developers are all separated into teams that only work on one module. So there is a team for the warehouse module, one for the schedule module and one for the inventory module. Each team consists out of several software developers and the team lead or architect. Besides the software development teams, there is also a dedicated integration team. This team is responsible for integrating all of the work from the different software development teams into one product. The integration team works heavily with the software development teams. Once there is an integrated product, the operations team takes this product and deploys it through the different environments. The operations team is also responsible for making sure that the environments keep running well. The product development and quality assurance teams are also involved in the process, but aren't mentioned here because they do not actually create or deploy any software. Let's zoom into the software development process. There are three software development teams that work on the different modules for the software. They all write lots of code for their specific modules. Also, all of the teams use source control to make sure that their code is safe and so that the team can collaborate on the same code basis. Each of the teams has their own branch in source control. This makes it easy to separate the work. The integration team controls the source control and merges all of the branches into one big bucket, which we call the main line. This is the integrated version of the code. At the end of each iteration, the integration team merges all of the modules into one bucket in source control. After that, they build the code that is in the integrated bucket. They do this on their own PCs as that is what they use to merge the code with. Building means that they compile the code, which succeeds or fails, and if it succeeds, results in the end result, the software that can be used. After building the code succeeds, they pass the resulting software on to the operations team so that they can deploy it on the different environments. Now, let's take a look at the deployment process of Value Through IT. So the integration team integrates the code and builds it which results in a release, the software to be deployed. They always accompany a release with a long Word document containing the installation instructions for the release. The steps to install the release are sometimes different depending on what the software developers created. These instructions are very detailed. They contain things like unzip the release package, put folder warehouses on the C disk under the folder warehouses 1. 0 and so on. The operations team receives the release and instructions every iteration and then goes on to deploy the release. They simply follow the instructions, which aren't always complete, to install the new release on the dev, test environment. And then they repeat the process for the acceptance environment and also for the production environment once all of the tests are successfully pass and the quality assurance team is happy. Let's zoom out to see the complete picture. Software gets created by different teams and then it is integrated into the main line in source control. It's then built and the results including installation instructions are passed to the operations team which installs the release on the different environments.
What Can You Improve?

Now that we know how the process within Value Through IT works we can start to identify areas that we can improve. Here we see the overview of the complete process again. We can divide the process roughly into the software development process and the software deployment process. Let's look at what we can improve for the software development process. Integrating the source control branches only happens once every iteration. This means that the integration team has a lot of merging to do. This is a lot of effort and extremely error prone. This also means that there is just one moment in every iteration at which the software development teams can see if their code works well with the other modules. This potentially introduces lots of rework as the teams might not have anticipated certain behavior or changes from the other teams. This is an area that we can improve. After merging, the integration team builds the code on their own PCs. When an error is found it will be hard to reproduce the exact conditions of the PCs of the integration team. Each has specific versions of software and libraries installed which makes the software behave slightly different. All of this makes it so that there can only be one deployment each iteration. If there are errors in the deployment it won't be released to production. This is also an area that we can improve. Now look at the deployment process. The operations team gets a list of installation instructions that they need to follow to install the software. Often, these instructions aren't 100% correct, leaving some room for interpretation to the team. This sometimes leads to errors where something should have been installed differently and now behaves differently. Also it's difficult to follow the instructions exactly the same for every environment. Sometimes, steps are forgotten. This can certainly be improved. Let's summarize that. We can improve the integration process. This takes too much effort, it's error prone and happens only once every iteration. We can also improve the deployment process. The instructions aren't bullet proof and are sometimes hard to implement which results in errors and differences between environments. So what can we accomplish with the improvements? We can create software of a higher quality with fewer errors. We can deliver software and new features faster to the customer. The whole process will cost less effort and is less complex, resulting in lower costs overall. And we have the ability to change things more and more quickly. This makes us more flexible in our ability to react to the needs of the customers. All of this results in the ultimate goal, happy users. Happy users means satisfied customers, which is Value Through IT's goal. Revenue, profits, happy employees will follow from there. How do we get there? By using continuous integration and continuous delivery. The next modules will explain what these concepts are and how they will help in accomplishing our goals.
Summary

In this module, we have seen that the fictitious company, Value Through IT, creates software as a service for its logistics company customers. They do a lot of things manually, like integrating source control branches, building the code and deploying it. This means that they have lots of challenges and lots of opportunities to improve things. We want to improve lots of things in Value Through IT. These things will lead to higher quality of the software, higher delivery speeds so that customers can use new features earlier. The improvements will lead to lower effort which leads to lower costs of the process. Because of all of the above, Value Through IT will be more flexible. They will be able to react to the needs of customers more quickly. Ultimately this will lead to happy users and higher customer satisfaction, which is exactly what we want. We will get there by using continuous integration and continuous delivery. In the next module, you will learn what continuous integration is and how it can help us to accomplish our goals.
What Is Continuous Integration?
Introduction

Welcome to the module, What is Continuous Integration. In this module you will learn what continuous integration is. We will recap the problems that we are trying to solve with continuous integration. Then we'll go on to look at continuous integration in more detail. We will take a look at where continuous integration came from and what it is exactly and we'll talk about some principles of continuous integration. Finally, we will evaluate the benefits of continuous integration. This module will not show you how to implement continuous integration, we will do that in a later module.
What Was the Problem Again?

What was the problem again? Why are we looking at continuous integration again? Here is an overview of the software development and deployment process of value true IT. Let's recap. Software development teams create software for specific software modules and check the software into specific source control branches. The integration team merges these branches into the main line source control bucket once every iteration. They them build the code on their own PC and pass along the resulting release and installation instructions to the operations team. The operations team takes the release and follows the instructions to install it onto different environments. In the software development process, there were some areas to improve upon. The integration takes a lot of effort and is error prone. It is only done once every iteration, which can result in lots of rework by the teams as the feedback cycle is too long. Also, creating the release and reproducing integration bugs is unreliable because the integration team builds the integrated code on their own PCs. In more detail, there are lots of potential problems with the current process. There is a high chance of bugs and rework. This has many causes, one of them being that integration is a large, manual job which is very error prone. Defects are only found at the end of the iteration when integration takes place. This is the only time in the iteration where the teams get to see if their code works with the code of the other teams. If it doesn't, the team might need to do a lot of rework. Also, because defects are detected late, developers have moved on to work on other problems and have forgotten about the minute details that might have caused the defect. It will take them time to go back to those pieces of code and understand them fully again, especially in a large system like this. Integration take a lot of effort, in this process, usually a day or more and it involves lots of people. The integration team often sits in a room with all of the lead developers from the module teams to figure out how things fit together. Sometimes the release has to be compiled again. It is difficult to create the exact same release packets each and every time, as the integration team uses their own PCs to build the release. Every member of the team has a slightly different configuration of their PC with different versions of applications and libraries on it. They try to keep their PCs as similar as they can, but automatic updates and personal preferences make this difficult. The team can only deliver the release packets to operations once every iteration. This causes lots of delays and often results in a release not being deployed to production until it has been fixed in a subsequent iteration. We can improve the process a lot by just improving the integration story.
What Is Continuous Integration?

Now that we know what we can improve, let's see if we can do so with continuous integration. This is the definition of continuous integration. A development practice that requires developers to integrate code into a shared repository several times a day. Where did the concept of continuous integration come from? In 1994, Grady Booch mentioned the phrase continuous integration for the first time in his book called Object Oriented Analysis and Design with Applications, second edition which describes his software development method also called, the Booch method of software development. In the book, he used continuous integration to explain how when developing using microprocesses, internal releases represent a sort of continuous integration of the system and exists to force closure of the microprocesses. Then in 1997, Kent Beck and Ron Jeffries invented Extreme Programming including continuous integration while on the software project at Chrysler. In 2001, Cruise Control was created and released by ThoughtWorks. This is an open source, java-based framework for a continuous build process which allows you to perform continuous integration. This was the first ever continuous integration server. After that, many products from many vendors followed. Continuous integration is the practice of developers integrating their code into a central repository often. In the value true IT scenario, developers check in their code into specific source control branches for the software modules that they are working on. This helps them to separate their work. To do continuous integration, the developers need to change how they work. They should now all use a central source control repository. This will require them to integrate code themselves, meaning that each team and each developer has to do a bit more work to make sure that their code works with the rest of the code. This makes sense, right. The developers that create the code know it best, so they know how it should fit with the rest and what could go wrong. Somebody else would have a more difficult time judging that. To check if the code actually fits together and works it should be compiled regularly. Even every time when anybody checks in code. It should be compiled on a dedicated build server. This way, the configuration for building things is centralized and is therefore more controllable. All of the developers should also have access to the results of the build, so that they can see if their code compiled or if there is a problem that they need to fix. The build should not only include compilation of code, but also automated tests to make sure that we have the best result possible. These tests would run against the compiled version of the code, possibly against a temporary, local deployment of the code. These tests can be of any kind, unit tests to check if code yields the expected results, automated UI tests to check if the UI responds as it should, security tests to see if the application is secure, and so on. Whatever you include, the whole build process, compilation, and test should be quick. This way the results of code check in can be communicated to the developers quickly, who can then fix whatever needs fixing so that the code base stays healthy and everybody is able to continue work. The process of compiling and testing should be automated. It should run very regularly, possibly every time when somebody checks in code. To make this work, developers might need to change the way they work. Continuous integration can be successfully adopted if an organization adheres to these principles. You need to have a single place where all of the code lives, this is usually in source control, in a central repository that we call that the main line. All developers check in their code at least once a day, maybe more, but at least once a day. This way each day we can make sure that everything still compiles and all of the tests still succeed. Developers should take extra care to make sure that what they check in compiles, as it now influences a lot of people immediately. The build process needs to be automated. Developers and the rest of the organization should prioritize fixing a failing build over building new functionality. There is no point in building anything new if you can't release anyway. The complete build, the compilation, and the tests should run quickly. This way it can be executed many times and developers get feedback quickly. Every time a developer checks in code the build runs. This is the principle for the strictest definition of continuous integration. You could also buffer check ins if you have a lot of them and run the build every time you have a bunch of check ins, but at least multiple times every hour. Tests should be automated as much as possible. These automated tests should then be part of the automated build process. Everybody should be able to see if the build succeeds and if not, where it went wrong. Everyone should be able to see everything. This includes the things that other people are working on. All the source code, all of the builds and test results, and how the build works. Better communication translates into better results.
The Benefits of Continuous Integration

What are the benefits of continuous integration? We've seen what we should do to get to continuous integration, so let's talk about what the benefits of it are. Take a look at the continuous integration setup for value true IT, again. Multiple software development teams check in their code every day to a central source code repository called the main line. This code then gets compiled and tested by the build process. Tests can include things like unit tests, automated UI tests, security tests, and anything else that can be automated. This process provides us with many benefits. The integration process takes less effort. It's still there, in a way, as every developer now integrates their own code into the central source code repository, instead of a dedicated team integrating whole branches into the central repository. Whenever code is checked in, the build is triggered and will compile and test the code. This will produce a result which the developer can use to potentially fix his code. Before continuous integration, this happened only once every iteration. Now it can happen many times a day. This surfaces issues early on, making it easier to fix them. Integration isn't an enormous manual task anymore and the build and test are automated. Just because of the fact that there is less manual work, there will be less chance for humans to make mistakes, resulting in less issues. The process is very visible to everybody involved. Anybody can see what has been checked in and what the result of the latest build is. This is beneficial because it provides feedback to the software developers, confirming that everything fits together or not. This also results in better, overall team communications. The teams aren't working in their isolated silos anymore. By having improved communication, the chance that everything fits together well becomes higher, resulting in better software. Because of the short feedback loops, the teams can make changes more often allowing them to react to customer needs better and maybe, most importantly, the code can be delivered to operations more often. Potentially resulting in more releases. This means shorter time to market and the higher ability to react to customer needs. All of those benefits ultimately result in software of a higher quality, less issues and less time needed to resolve issues, being better software. Software that can be delivered faster. It could be delivered to the operations team many times during an iteration. Potentially resulting in multiple releases during an iteration. Because of reduced efforts in integration and less effort needed for resolving issues, the overall costs of the software process will decrease and shorter integration iterations result in the ability to change things more often allowing for more flexibility, which ultimately is the ability to react to the customers needs more quickly. All of this results in happier users and higher customer satisfaction. Besides that, the people involved in the software development process will be happier as they are now working with a much more robust and repeatable process. This instills them with trust in the code base and the systems in which the application lives. That's a good place to be at as an organization.
Summary

Let's look at what we have learned in this module. Continuous integration is the practice of integrating code into a central repository every day, potentially multiple times a day. It requires automation of the build process. This means that when code is checked in, the automated build process will try and compile the code. Additionally, the build process will also run automated tests, like unit tests and UI tests. All of this results in lots of benefits like a higher code quality resulting in better software, faster delivery of the results to the operations team potentially multiple times per iteration, lower costs overall because things cost less effort, and more flexibility to make changes because the process is much shorter than it was. In the next module you will learn what continuous delivery is and how it works together with continuous integration.
What Is Continuous Delivery?
Introduction

Welcome to the module What is Continuous Delivery? In this module, you will learn what continuous delivery is. We will recap the problems that we are trying to solve with continuous delivery. Then, we'll go on to look at continuous delivery in more detail. We'll look at what continuous delivery is, and which principles it involves. Finally, we will evaluate the benefits of continuous delivery. This module focuses on what continuous delivery is, not per se on how to implement it. We will focus on that in a later module.
What Was the Problem Again?

What was the problem again? Why are we looking at continuous delivery? Here is the overview of the software development and deployment process of Value True IT. Let's recap it. Software development teams create software for specific software modules and check this software into specific source control branches. The integration team merges these branches into the mainline source control bucket once every iteration. They then build the code on their own PCs and pass along the resulting release and installation instructions to the operations team. The operations team takes the release and follows the instructions to install it onto the different environments. In the software deployment process, there were some areas to improve upon. The operations team gets a list of installation instructions that they need to follow to install the software. Often these instructions aren't 100% correct, leaving some room for interpretation to the team. This sometimes leads to errors, where something should have been installed differently and now behaves differently. Also, it's difficult to follow the instructions exactly the same for every environment. Sometimes, steps are forgotten. All of this makes it so that deployments take a long time and are error prone. There are lots of potential problems with the current process. There's a high chance of errors during the deployment process. The installation steps need to be created or changed, which can go wrong. They have to be interpreted and executed, which can go wrong, and they have to be executed against multiple environments, which can go wrong. A lot of stuff that can go wrong, mainly because this is a manual process. Deploying a release takes a lot of effort. The whole installation script has to be executed against all environments. This is a lot of manual work. Because the deployment is manual, it is somewhat hard to exactly do the same things in every environment. This is mainly because different environments are managed by different members of the operations team and they might interpret the installation steps differently. Different members of the operations team manage different environments for the application, and because of this there are slight differences in all of the environments. These differences are things like differences in versions of software and libraries that are installed on the servers. Because of the manual and error prone nature of deployment, deployments are seen as something scary, something that you'd rather not do, certainly not on a Friday afternoon. Because of all of this, there is usually just one deployment during an iteration. Ultimately, this leads to slow delivery of functionality to users. Imagine that we could solve most of these problems. That would help the organization enormously.
What Is Continuous Delivery?

Now that we know what we can improve, let's see if we can do so with continuous delivery. Here is a definition. Continuous delivery is a software development discipline where software can be released to production at any time. The point is to get to a state from which we can deploy to production always. We should always be production ready. I want to address a common naming misconception. Continuous delivery is sometimes called continuous deployment, and vice versa. However, these are two different concepts. In continuous delivery, we are in the state where we can deploy to production at any time. We can. This is a choice. In continuous deployment, software is automatically deployed to production all the time, continuously. There is no choice in that. Deployments happen as soon as new code checks in. There might be situations where you want to have continuous deployment. In our scenario, we don't want that, because we want to have control over what is in production so that we can train the users for that functionality. So, we use continuous delivery, not continuous deployment. All right, previously, the operations team received a release and installation instructions to deploy onto different environments. They would only receive this at the end of each iteration. This works differently now that we have the concept of continuous integration. For argument's sake, let's assume that Value True IT already adopted continuous integration. All of the developers check in their code into a central repository that gets compiled and tested automatically at least once every day. This results in a release every day, without installation instructions. In continuous delivery, we take this release and feed it into a release pipeline. This pipeline is an automated process, that is executed on a server. This process takes the release package and installs it with steps similar as those that were in the installation instructions. These steps are things like copy files to a certain location, reset the IAS server, and so on. All of these steps together deploy the release to whatever environment we want, like dev, test, or production. To take it a step further, we could do the same for creating and updating environments. Instead of the release package for the application, we would need the infrastructure for an environment like production as code, or IaC, infrastructure as code. This is done by scripting the complete creation or update of an environment with things like PowerShell and JSON script. This is a practice that is becoming more and more popular and you should consider using it in your organization. Once you have your environment, your infrastructure as code, you can deploy or update it to a similar process as the application. The release pipeline would execute all of the scripts to create or update an environment. By using this, maintaining and environment becomes much more easy and all environments will be exactly the same, as they are created by exactly the same scripts. This is not a requirement for continuous delivery, but something that becomes possible when you have continuous delivery. Let's zoom out. A possible setup of continuous delivery would be this. There are developers that create code and commit this into a central source code repository. The operations team does the same with infrastructure as code, and with the scripts and configuration to automate the release pipeline. This is a very different way of working than before. Developers and operations people need to work closely together in a similar fashion. Traditionally, developers would have different goals than operations people. Developers want to create new things because that is what they are incented to do. They get paid to create. Operations people want everything to stay the same, because they get paid when everything keeps running, and the best way to ensure that is to keep everything the same. In this new way of working, everybody should be incentivized to get new functionality successful in the hands of users. This means creating new things, and keeping everything running. Now, this should be the responsibility of the developers and operations. They need to work together, not against each other. This way of working is what is commonly referred to as devops. The code for infrastructure scripts and the application is in source control. The build pipeline automatically picks this up, and compiles the code and tests it with automated tests. After this, the release pipeline can pick up the results and do things like create infrastructure, deploy the release to one or more environments, and potentially execute more automated tests. Potentially, quality assurance can perform more tests that can't be executed automatically and can then decide to deploy the release to a subsequent environment, like production. Eventually the release is deployed on production, where users can start using it. They use it, maybe they find bugs, or want things to work differently and feed that back into the organization through product management, which starts the cycle all over again. Together with software development and operations, product management decides what the new features or bug fixes for the next release should be, and the cycle starts over. It is important to remember that everything that happens in the build pipeline is automated. The code is picked up as soon as it is checked in, and is then compiled and tested. Everything in the release pipeline is on demand, meaning that if we choose deliberately when we want to release anything to any environment. We do this so that we have control over which version of the software is in which environment, which allows us to train users and to do proper marketing around new features. We've heard a lot of them already, but let's list out the principles for doing continuous delivery. You need continuous integration in place to be able to do continuous delivery. If you haven't got continuous integration, you can automate your delivery, but you will never be in a state where you could deploy to production at any time. Development and operations should work together, not against each other. This is not a new thing. They should have always done that, but traditionally they were incentivized to do different things, and thus, work against each other. This needs to change. This is not a requirement, but a very nice to have. If you have your infrastructure as code, and you automate a creation and maintenance of it, your environments will be consistent, causing less errors and costing less effort to maintain them. The release process should be automated. This means that you should examine the installation steps that you currently have and automate these into scripts, like PowerShell scripts and other scripts that can be used by the release pipeline. Basically, try and automate everything that you can, including your acceptance tests, as far as possible. Deploying a release to production should be part of your definition of done. A feature isn't done until it is successfully running in production. Releasing shouldn't happen automatically. You choose when to release. It should be on demand. As with continuous integration, communication is key. Everyone should be able to see the status of the process. Everyone should be able to see what succeeded and what failed, and everyone should have access to the latest release that is running on dev, test, or somewhere else.
The Benefits of Continuous Delivery

What are the benefits of continuous delivery? We've seen what we should do to get to continuous delivery, so let's talk about what the benefits of it are. Let's look at the overview of the continuous integration and delivery in Value True IT, again. Developers and operations people check in code and infrastructure as code into a central source code repository. This code gets compiled and tested in the build pipeline. Then, infrastructure gets created or updated, and code is deployed to one or more environments and potentially automatically or manually tested before being promoted to the next environment. This gets new features in the hands of users, who then feedback to product management to start the process all over again. This process provides us with many benefits. Releasing takes a lot less effort. All of the manual work is now automated, and is less error prone, causing less rework. Releasing is now more reliable, because less errors happen as things are more automated. And it is more repeatable, because we just run the same scripts again. Releasing a new version is an on demand process. This puts the power to release into the hands of the business, product management, or test departments. They can decide when a new version is released to an environment. We can release more often, many times in an iteration. This puts new features in the hands of users and testers much faster, which means that software developers and operations people can get feedback much faster, ultimately resulting in a better product. All of those products ultimately result in better software of a higher quality. Because we can get feedback faster, we fail faster, and are able to fix things faster, resulting in higher quality. We have a much higher time to market, because we can deliver faster. This all results in lower costs, because there is a lot less effort involved in releasing and rework. And, we are more flexible. We can change the software faster, enabling us to react to customer needs faster. This all makes for happier customers, and happier employees. It's not easy to get into the state of continuous delivery, but it's definitely worth it.
Summary

Let's look at what we've learned in this module. Continuous delivery is not continuous deployment. Continuous delivery is an on demand process, where continuous deployment deploys to production automatically, all of the time. You need continuous integration to be able to have continuous delivery. Continuous delivery involves a release pipeline in which you automate the whole release with installation scripts, and automate acceptance tests as much as possible. Using continuous delivery ultimately leads to better software of a higher quality, that is delivered to users faster, with lower costs and more flexibility to react to customer needs. In the next module, you will learn how to implement continuous integration and delivery, and what the most common pitfalls are.
How Do We Get to CI and CD?
Introduction

Welcome to the module, How Do We Get to CI and CD? In this module, we'll discuss how to get to the state of continuous integration and delivery. We will recap where we want to go, what the ultimate state is that we want to achieve, and then, we will look at how to get there. We will look at how to implement Continuous Integration Continuous Delivery. During this discussion, I will also tell you about the pitfalls that you might run into when you are implementing continuous integration and delivery.
Where Do We Want to Go?

Where do we want to go? Let's recap to what state we want to go to. This is the current state of the process of value through IT. Software development teams create software for specific software modules and check this software into specific source control branches. The Integration team merges these branches into the main line source control bucket, once every iteration. Then they build the code on their own PC and pass along the resulting release and installation instructions to the Operations team. The Operations team takes the release and follows the instructions to install it onto different environments. This process has lots of areas that we can improve upon, to have software of a higher quality, deliver software faster at lower cost and be more flexible. Let's look at the state that we want to be in, the Ultimate State where continuous integration and delivery are fully implemented. Teams of software developers and operations people create source code, deployment scripts, and infrastructure as code that they commit to the central source control repository. The Build Pipeline takes this source code and compiles and tests it, resulting in deployable infrastructure scripts and software. This is automatic. Source code gets compiled and tested as soon as it is committed into the source control repository. After that, the Release Pipeline picks up the software and infrastructure artifacts. It creates or updates infrastructure environments with infrastructure as code, and then it deploys the software to the environments. After that, the Release Pipeline executes automated acceptance tests. These can include things like performance tests. Additional manual tests are done by the Quality Assurance team, which eventually promote a deployment to the production environment. Users can start using the new software, and feedback bugs and ideas for new features or changes to the Product Management team. Product Management initiates the whole cycle again by determining the new features and bugs to be fixed in the new iteration. This is the ultimate state that we want to be in. But how do we get there? The next clips will show you how to implement continuous integration and delivery.
Implementing Continuous Integration

Let's take a look at how you could implement continuous integration. Obviously, the steps to do this are different for every organization. I'll take you through the most common steps and pitfalls for implementing continuous integration. In continuous integration, software development teams create software and commit their changes to a central source control repository. After that, the source code automatically gets built and tested. To get to continuous integration, there are couple of steps that you need to take. First of all, all code needs to reside in a single source control repository. This sounds simple, but it really isn't. Once you have that, you need to implement an automatic build pipeline that compiles your code using an automated process and runs tests against it. Let's go through these steps. Step 1, get to a single source control repository. The first thing you need to do is come up with a solid branching strategy, I mean a strategy for managing branches of source code. This will work different, now that everything will be in one repository, where it previously was in a branch or module of software. There are many strategies that you can use. The one that fits best depends completely on your own situation. Often, there is just one main branch, representing the source code that is currently in production. Next to that, there would be branches for alt fixes and other branches. Whatever branches you create, make sure that it is a common branch used by all and everybody commits to it daily. A common pitfall here is that organizations create many branches for all sorts of things, like separate feature branches or versions of the software. This can work, but only when they are treated as main branches, meaning that everyone commits to them daily, otherwise the benefits of continuous integration go away, as you would have to do big manual integrations anyway. The second thing to do is to start clean. All of the current branches should be merged into a single repository to which everybody would then commit daily. The Integration team knows exactly how to do this, however, the Software Development teams now need to wait until this integration is done and reconnect to the resulting main line, as they can't use their module-specific branches anymore. The third thing to get to a single source control repository, collaboration. This is by far the most difficult change. Developers need to start working differently. Previously, the teams worked isolated and only communicated when integration happened. Now they need to know what the other teams are doing all the time to always make sure that all of the code fits together. This requires change and time. You could change the process to have joint planning sessions at the start of an iteration, or swap people from team to team on a regular basis. It is very common that this doesn't work at first. This is mostly because change is hard and most people don't like change. Try and facilitate communications by slightly changing the processes that are already there. When everybody commits to a single repository daily, you need an automated build process. To get there, you need a dedicated build server. By dedicated, I mean that the purpose of this server should only be to build and test code. A common mistake is that organizations use another server that is doing something else to run the build and test, just to save costs. The build and test server is very particular. Sometimes, you need very specific pieces of software or library versions installed on it. You do not want other software influencing your build results. You also need to install a build engine on the server. There are many vendors that provide this and you can also instantiate complete build and test servers in the cloud, or consume them as a service. The most difficult part is to create the build definitions. These are the steps that the build process should go through to compile your code and create a deployable software package. This can be as simple as invoking a build engine on source code to as difficult as running all sorts of custom scripts that you write. The hard part is automating it. Once it works, remember to keep the build scripts safe. This means committing them to source control, as well. This is the most common pitfall that organizations make. Build scripts are kept on someone's machine and only that person knows how they work. These scripts are very important, so make sure that they are treated as such. Once you can compile automatically, the next step is to create an automated test process. This process is meant to test your application as much as you can with automated tests. The first step is to run static tests with the build. This is an extension of the build definition. In here, you should start static tests. These are things like unit tests and static code tests that determine code quality. One of the common pitfalls is that organizations run all of these tests, but only a few people have access to the results of the tests. The results of the tests should be part of the build results that everybody should be able to see. Whenever the build is finished, it will produce deployable software. A common but optional step in continuous integration is to deploy the software somewhere so that you can run additional tests on it. This deployment could be on the build server where you have the minimum configuration running. This deployment is very temporary in nature, as it is automatic and will be overwritten every time that the build runs. However, this allows you to do additional tests, like user interface tests or security tests. This does take extra effort, as you need to automate the deployment of the software already, which you would usually do when you implement continuous delivery. The biggest pitfall when running automated tests in continuous delivery is that running tests makes the process take too long. Running tests can take a long time. You should design your tests in such a way that they can execute very quickly and the new build and tests can be initiated quickly when new code is committed into source control. One way of doing that is to execute tests in parallel, for instance, on multiple servers at once. This does make the process more complex, as you would have to gather the test results from multiple places and aggregate them into a single place where everybody could see them. By executing the previous steps, you can implement continuous integration. You can create processes that run constantly whenever new source code is committed to source control and processes that also run on demand or nightly, just to make sure that everything is integrated and tested every night. It isn't easy to implement continuous integration, but it's definitely worth it.
Implementing Continuous Delivery

Now let's look at Implementing Continuous Delivery. Continuous integration is a prerequisite of implementing continuous delivery. The continuous integration process results in a deployable software package that we call a release. In continuous delivery, we take the release and pick it up in the release pipeline, which executes steps to deploy the software to all of the environments. Additionally, we could script all of our environments, resulting in infrastructure as code, or IaC, which we also feed into a release pipeline. The pipeline then executes steps to deploy or update infrastructure components in the different environments. To implement continuous delivery, we need to at least take the following steps. We need to have continuous integration in place. This is a requirement. You can't do continuous delivery without continuous integration. Unite developers and operations to work together instead of against each other. And finally, we need to create a release pipeline that can deploy the software to the environments and run additional tests against it. And optionally, can also create or update infrastructure with infrastructure as code. Let's go through the steps. We will skip the first step, as we covered continuous integration in the previous clip. After we have continuous integration implemented, we need to unite developers and operations people. Developers want to create new software and new features for software. Traditionally, this is what they are incented to do, this is what they are paid for. Operations people want to keep everything running as it is. This is their job, this is what they are paid for. Therefore, they don't like to install new software or new features, they want everything to stay as it is. When we start to implement continuous delivery, this needs to change. The role of operations people changes. They no longer take a document with installation instructions and execute it. They create scripts that can deploy software and infrastructure. Like developers, they commit these scripts into source control. Operations people need to know a lot more of the software than before. And developers need to know about the scripts that will deploy their software. They need to work together, not against each other. A common way to do that is to put the teams together. Software development teams consists of software developers and operations people, commonly called DevOps. Often, also testers and business analysts are part of the Software Development teams. All of them together create and deploy the software and keep it running. When something goes wrong, they make sure that it is fixed. There are many different ways to solve this. This is just one suggestion. Whatever you do, make sure that software developers and operations people work better together. To deploy and test the release, we need a deployment server. This is a server that is capable of executing all of the deployment steps that puts software in the different environments. Usually, the most difficult thing here is to make sure that the deployment server has the appropriate access rights to execute deployment scripts on the different environments, for instance, to execute a PowerShell script on a server in production. There are many products from many vendors that help with this, and can sometimes even be consumed as a service. Once you have the server, you need to create the release definitions. This involves scripting the deployment of your software. This often involves steps like copying files to servers and updating database schemas. This is not an easy thing to do. The installation scripts that value through IT used before it's a good place to start. The release definitions should also contain who is able to promote a release to certain environments. Most continuous delivery products support the notion of gated deployments, where a signoff needs to happen before a deployment to a certain environment can happen. And finally, the release definitions should also contain any tests that you want to run. After the software is deployed, you could run additional tests like performance tests or automated UI tests to accept or reject a release. Optionally, you could automate the creation of your infrastructure, as well. I highly recommend doing this, as it will provide great consistency and agility in your environments. To incorporate this in your continuous delivery process, you should first script your environments. This is not easy. The way you script your environments can be different, depending on the tool that you use to do continuous delivery. Some tools like scripts in PowerShell formats, others in the form of JSON files, but most are fine with basic script formats, like PowerShell or bash scripts. Scripting your whole environment isn't easy. You will go through many iterations of the scripts before you have the exact configuration that you want. There are tools that can help you to script your environments, and you should use them. The most difficult part of scripting your environment is writing down what your environment actually is, which components do you have, what is installed on them, which versions, who has access to what, and so on. As with the software deployment process, you need to create release definitions for the infrastructure as code. This is different than those for software. Now you need to define how the scripts should be executed to create or update your infrastructure. And finally, the release definitions should incorporate any tests that you want to execute at your newly created or updated infrastructure. These are tests like, ping my virtual machine to see if it's up, or connect to the database that I've just created. This whole process should be as fast as you can make it. Creating and updating infrastructure to scripts is usually slow. If you can make it fast, you can use this process to easily instantiate new environments, maybe even complete personal development environments for developers or specific environments that you want to use for just a short time, like for running a very specific test.
Summary

Throughout this module, you have learned that the road to continuous integration and delivery is long. It's surely not easy, but definitely worth it. The two main things that you should do is to automate everything and to have developers and operations work together better. There are many other specific things that you need to do, but these are the basics. As you've also seen, continuous integration and delivery are very powerful. When fully implemented, they will result in better software that we can deliver to users faster, that costs less money to create, maintain and deploy, and is more easily adjusted to customer needs.
Course author
Author: Barry Luijbregts
Barry Luijbregts

Barry Luijbregts is an independent architect and software developer focused on preparing business applications and solutions for the cloud. A Microsoft Azure MVP, Barry is a skilled educator and...
Course info
Level
Beginner
Rating
4.1 stars with 248 raters(248)
My rating
null stars
Duration
0h 59m
Released
16 Feb 2017
Share course
