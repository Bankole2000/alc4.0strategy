Android Security: Inter-app and Network Communication Security
by Nitin Singh

This course will give you a better understanding of how you can ensure that your app’s interaction with other apps is secure and how to configure your app so that the network requests being made from it are not prone to attacks by malicious entities.

All Android apps need to interact with other apps on the device and make network requests to the backend servers. Having a good understanding of the security mechanisms provided by the Android platform to safeguard user data against attacks is a very important part of creating robust apps that users love and trust. In this course, Inter-app and Network communication security, you will gain an in-depth understanding of the tools provided by the Android platform so that you can guard user data in your app from other malicious apps and transmit it securely over network. First, you will learn about the various types of mechanisms used by apps to interact with one another and the precautions to take while using them to ensure that only trusted apps gain access to your app’s data and functionality. Next, you will discover how to make network requests such that intermediate or malicious entities are unable to access or modify the data while it's in transit. Finally, you will explore some advanced techniques to protect your app’s network requests against more sophisticated network attacks. When you are done with this course, you will have a very well rounded understanding of Android’s security model and you will have a great tool box to come back to whenever dealing with security considerations for an app.

Course author
Author: Nitin Singh	
Nitin Singh
Nitin is an Android / iOS developer with over 6 years of experience developing world class apps and SDKs that are used and loved by millions of users. He currently leads the Mobile team at Razorpay...

Course info
Level
Beginner
Rating
0 stars with 3 raters
My rating
null stars

Duration
0h 41m
Released
15 May 2019
Share course

Course Overview
Course Overview
Hi everyone. My name is Nitin, and welcome to my course on Android Security called Inter-App and Network Communication Security. I am a freelance Android and iOS developer with multiple apps featured on both the app stores. Having a good understanding of the security mechanisms provided by the Android platform to safeguard user data against attacks is very important, as it allows you to create robust apps that your users trust and love. In this course, we are going to learn how to protect your app's data from other malicious apps on the device and how to safely transmit data over the internet. Some of the major topics that we will cover include securing incoming and outgoing intents, setting up network security configuration, using HTTPS correctly to ensure data being transmitted is always encrypted and tamperproof, and advanced network security techniques like customizing certificate authorities trusted by your app and certificate pinning. By the end of this course, you will have a very well-rounded understanding of Android security model, and you will have a great toolbox to come back to whenever dealing with security considerations for an app. I hope you will join me on this journey to learn about Android security with the Inter-App and Network Communication Security course, at Pluralsight.

Securing Interaction with Other Apps
Securing Interaction With Intents
Hey guys. This is Nitin. Welcome to the Android Security course on Inter-App and Network Communication Security. This is the first module, Securing Interaction With Other Apps. One of the fundamental ways of interacting with other apps on Android is intents, so let's start by understanding how we can secure intent-based inter-app communication. Intents in Android can be categorized into two types: outgoing intents, which are intents that originate from your app, and incoming apps, which are intents that originated in other apps and your app is performing the action requested by the intent. Let's start by understanding how we can secure outgoing intents. There are two types of outgoing intents that your app can fire, implicit and explicit. In case of explicit intent, your app specifies the exact component of the exact app that needs to handle the action performed. Since the app to be used and the component within the app to be used is hardcoded by you in the code, we don't need to take any extra steps for securing it; whereas in case of implicit intents, your app just indicates to the system that it wants to perform some action, and the user is shown a set of apps on the device that can handle that action. The problem, however, is that the user may set an app as the default app for the action, and this can be an issue when the action involves sensitive user information, as the user is no longer given an option to choose an app they trust with the sensitive information. To solve this, we need to use something called an app chooser. This is what an implicit intent flow with app chooser looks like. The user performs an action that needs to fire an implicit intent. The app checks if multiple apps can handle the user intent. If only one app can handle the intent, launch that app. If multiple apps can handle the intent, show a chooser dialog every time so that the user can select an app that they trust for the given action. This is what the sample code for this flow looks like. We query how many activities on the system can handle the intent, and if the size of the returned activities is greater than 1, we show the chooser dialog, and if not, we simply start the activity. Let's see this in action in a demo now. For this course, we'll be working with a contact application and see what security issues it might have and try and fix those. We will begin by implementing an app chooser for implicit intents fired by the contact application and see what that looks like. This is the Contacts App project that we will be using for demos for this course, and this is what the Contacts App looks like. As you can see, it's a pretty simple app with a login screen, and once you log in, it shows you a list of your contacts. On tapping one of these contacts, it will actually try to share it using an implicit intent. As you can see, on firing the implicit intent, the system will show you a list of apps that can handle the implicit intent, but on selecting one of these apps, the system will mandatorily ask you to select the Just Once or Always options. Now, if the user were to select the Always option, the next time that same intent is fired, the system will not show a list of apps and instead redirect the user to the previously selected app. To fix this, let's go back to the code which actually fires the intent and see what changes we have to make there to use the app chooser instead. As you can see, the code here is actually just firing a startActivity call with the implicit intent. Let's replace this with the code that actually starts an app chooser, which we saw earlier. Now let's run this and see what happens. Let's try and tap on one of the contacts and see what happens. As you can see, the system presents a list of apps, but is not asking the user to select a once or always option, and this is what will be shown to the user every single time. So if you want to give users control of what apps to use for certain actions, especially those involving sensitive information, you should always use an app chooser and not implicit intents.

Securing Incoming Intents
Let's now turn our attention towards incoming intents and see what we can do to secure those. Incoming intents are intents fired by other apps that your app can handle. The way you safeguard your app's components that are supposed to handle the incoming intents is by defining proper Android permission attributes for these app components. Whether the incoming request was triggered by an explicit or implicit intent does not matter. As long as the app triggering the intent had the permissions requested by the component handling it, the action will succeed, else it will fail. So, permissions are a key piece in securing your app's components against incoming intents from malicious apps. Let's understand the different types of permission protection levels that are available on Android and their behavior so that you can use the right one for the permission you defined on you app components. There are four permission protection levels defined by Android. They are normal, dangerous, signature, and special. The normal permissions are used for accessing device features that are low risk to a user's privacy or other apps. These normal permissions are auto-granted to any app that asks for them in its manifests and require no user interaction. You will rarely define a custom permission at this protection level for your app's components, as any app can get it by simply defining that permission in its manifest, An example of this would be the permission needed to access internet by an app. The dangerous permissions are used for guarding features that allow access to sensitive user data or device features. For an app to obtain a dangerous permission, it needs to request the same from the platform, which shows a dialog asking for explicit content from the user. The only way to get these permissions is via user interaction. This is the most useful prediction level for custom permission defined for securing your app's components against intents. An example of this is the camera permission to access the camera sensor on the device. Signature permissions are usually custom permissions that are to be used between apps from the same developer and which are signed using the same certificate. Since they are signed by the same certificate, they are auto-granted at install time if the certificates match. They are used when an app developer might have several apps on the device which want to use each of these components, but don't want to expose those to other apps. The last type of permission is called special permissions. These are used to protect features that can affect a user's entire experience on the device. They are usually system-defined permissions and apps need to use them very rarely. These are used via system intents and the system controls the whole UX for showing the warnings to the user and explaining the repercussions of granting the permission as well. Any permissions that allow an app to change a device-wide setting is a special permission. Let's go back to our contact application demo where we'll create a custom permission and guard our app's content provider using it so that only apps with the required permission can access the content provider. Let's go to the manifest file and see how the content provider is declared currently. As you can see, the content provider does not specify any permission attribute, and hence, it can be accessed by any app. To fix this, let's define a custom permission for our content provider. Now that we have defined a custom permission for our content provider, let's specify that permission in the Android permission attribute for the content provider so that the next time someone tries to access this content provider and they don't have this permission, the system will throw a security exception, and that's it. This is all that you have to do to protect your app's component from other apps which might not have the necessary permissions. Define a custom permission and enforce that custom permission using the android:permission attribute on the respective component.

Preventing Other Apps From Accessing Your App’s Components
Let's now discuss the scenario where your goal is to completely prevent other apps from accessing certain sensitive components in your app. This is different from the permissions-based guarding we saw in the last section, as in this case we are not just authorizing access to the app components, but instead we don't want to expose the app component in question at all to other apps. This is achieved using the android:exported tag on the component. It takes true/false as input, and setting it to false prevents other apps from accessing it. Even if they define an explicit intent to the component, the system will raise an exception. Keep in mind though that the value of this is true for API level 16 or lower by default. So, you have to explicitly define it as false in the manifest under the appropriate components. Here is a sample of how to set this to false for a content provider, thus preventing it from getting exposed to other apps. Let's go back to our contact application demo now and use the android:exported attribute to safeguard an activity in our app from other apps so other apps cannot launch it at all. This is a test app that I have created, which on the click of a button launches the contact list activity in the MyContacts app by specifying the exact package name and name for the contact list activity in the intent. Let's see what that looks like. As you can see, the test app has successfully launched the MyContacts app's contact list activity. Now let's see how we can use the android:exported attribute in the contact list activity in the manifest to prevent other apps from launching it. All we have to do here is go to the activity tag for the ContactListActivity and make android:exported false. Let's now run this and see what happens when the test app tries to launch the contact list activity. Let's try to launch the As you can see, the MyTestApp has crashed. Let's see what the logs have to say. As you can see, the system has thrown a SecurityException, indicating that the activity that this app was trying to start is not exported. This is the way you protect your app's components from other apps by specifying the android:exported attribute as false and the system will ensure that no other app can access it. Here is a summary of what we learned about securing inter-app communication in this course until now. We learned the differences between incoming and outgoing intents and also implicit and explicit intents. We learned how to secure outgoing intents by using an app chooser and how to secure incoming intents with proper permissions. We also learned about the various permission protection levels and how each of them behaves. And finally, we learned how to prevent our app components from being exposed to other apps using the android:exported attribute. In the next module, we will learn about securing network communication using network security configs for Android applications. I hope to see you there. Thank you.

Securing Network Communication Using Network Security Configurations
Difference Between HTTP And HTTPS Connections
Hey guys. This is Nitin. Welcome to the Android Security course on Inter-App and Network Communication Security. In this module, we will learn about Securing Network Communication using the Network Security Configs provided by the Android platform. Let's start by understanding the differences between the HTTP and HTTPS connections, which are the network protocols used by most apps to communicate with their back-end servers. We will try to see if one is better than the other for security, and if so, why. Let's first understand the way HTTP communication works. The way HTTP communication works is that whenever your app needs data, like a web page or an image from a server, it makes an HTTP request with jumps via many in between hops, like proxies, routers, etc., and eventually reaches your server. The server then responds with the data or an error, which is delivered back to the app. The problem with HTTP is that in order for the data to reach your servers, it needs to pass through many untrusted entities, like proxies, routers, etc. All of these in-between entities can see the data being transmitted in plain text, as it's not encrypted, and thus any of these in-between entities can either modify or intercept the data being transmitted. This is an obviously huge security issue. Now let's see how this can be solved such that we can transmit data via these untrusted hops without them being able to read or modify it in transit. The solution is simple, use HTTPS instead of HTTP. HTTPS is HTTP with TLS or SSL protocol. The TLS/SSL component ensures that all data transmitted over the network is encrypted so that no in-between entities can read it and that integrated checks are performed on the data received so as to ensure that the in-between entities cannot modify the data in transit. This flow diagram explains how HTTPS works and what additional steps and entities are involved to ensure that the communication is really secure. When a client requests, say, an image from a server using HTTPS, the client first handshakes a secure SSL connection from the server as a part of which the server responds with an SSL certificate issued to it by a trusted CA. The client examines this certificate against its locally stored set of trusted certificates to verify that the certificate is in fact valid, thus validating the identity of the server. From this point onwards, all requests are encrypted using the keys provided by the server during the handshake and a secure communication between the client and the server is established. Now that we understand how HTTPS guarantees secure communication between client and server, let's see what changes we need to make in our app to ensure that we are using HTTPS properly. First, ensure that your back-end server has a TLS or SSL certificate issued by a well-known certificate authority. This certificate is what will be served to the app for establishing the identity of your server, and if it's not from a reputed certificate authority or is invalid, the connection will be aborted by the client. In your networking code, start using HttpsUrlConnection class instead of HttpUrlConnection class so that your app can make requests to HTTP endpoints. And lastly, ensure all endpoints in your app have the HTTPS protocol and not the HTTP protocol. Keep in mind that starting with Android P, if you try to make calls to HTTP endpoints or use HttpUrlConnection, all requests will fail. If for some reason you still need to use HTTP on Android P, you need to modify your network security configs to allow HTTP traffic on those domains. We will talk more about this in the next section of this module. For now, let's go back to our contact application demo and see how data being sent using HTTP requests can be read by intermediate hops and how we can migrate to HTTPS to avoid this security issue in our app. For the purpose of this demo, we will be using the login functionality of the Contacts App, as login is a pretty sensitive network request as it carries the user's username and password. As you can see here, we are using HttpUrlConnection for the login request with the endpoint to example.com, which has HTTP as the protocol. We will be using a tool called Charles proxy, which is nothing but a proxy server sitting between the Android app and the server at example.com so that all requests have to pass through this server. Let's perform a login request and see what happens. As you can see, the moment we made a login request, the request popped up in the proxy server, and as you can see, since we have used HTTP, the intermediate server can clearly read out the user's username and password in plain text, which means the user's privacy is at huge risk. Let's now migrate the login request to HTTPS and see how the behavior changes and if the proxy server is still able to read the user's information in clean text. To migrate the login request to start using HTTPS, we will first change the endpoint so that its protocol is HTTPS and not HTTP, and then we will start using HttpsUrlConnection class instead of the HttpUrlConnection class. Let's run this and see what happens. Now let's try to perform the login request and see what happens. As you can see, once we have done the login, not only is the username and password not visible, the intermediate proxy server is not even able to read what endpoint are we exactly trying to hit. Instead, it is showing us an IP. By these two simple steps, which is using HTTPS endpoints instead of HTTP and using HttpsUrlConnection class instead of HttpUrlConnection class, we have safeguarded our app from all untrusted intermediate entities, and this is something that you must do for all requests.

Network Security Configuration
In this section, we will learn about setting network security configurations for your app. The key purpose of network security configs on Android is to provide apps with a super flexible and safe way of modifying their network security settings using a config file rather than modifying them in code. The fact that it's a config file and not a bunch of if/else statements spread over the code base means that the risk of an app exposing its data accidentally due to a bug is reduced dramatically. Here are the key capabilities supported by network configuration. The ability to opt out of cleartext or HTTP traffic, the ability to specify separate settings to be used only in debug mode, the ability to customize the set of trust anchors or certificate authorities trusted by the app, the ability to pin certificates to avoid man-in-the-middle attacks in case of a certificate authority issuing fraudulent certificates. To add a network config to your app, you need to use the android:networkSecurityConfig attribute on the application tag in your manifest. The config file itself should be placed in the XML folder. This is what the structure of a network config file looks like. The root tag is always the network-security-config tag. The base-config is the config applicable to all requests. The values in domain-config tags are used only when making requests to domains specified by the domain-config tags. The configs specified in the debug-overrides tag are used only when the app is compiled with debuggable set to true. Let's go through each of these tags that can be present in a network config file one by one and understand their use case and behavior. The network-security-config tag is always the root tag, and it can have 1 or 0 base- config or debug-overrides tag, but it can have multiple domain-config tags. The base-config tag specifies values to be used for all requests, except the ones that are specified in domain-config tags for that particular domain. To specify where the cleartext traffic is permitted or not, we can use the cleartextTrafficPermitted attribute on the base-config tag. It takes true/false as input. A base-config tag can have one or more trust-anchors tags. We will learn about trust anchors in the next module, as they are related to certificate authorities. The domain-config tag specifies values to be used when making requests to domains specified by the domain subtags that it contains. To specify whether cleartext traffic is permitted or not, we can use the cleartextTrafficPermitted attribute on the domain-config tag. It takes true/false as input. In case multiple domain tags specify the configurations for the same domain, the one specifying the URL which is the closest match to the request being made is used. Also, domain tags can be nested inside other domain tags. If you want to opt out of cleartext traffic completely for your app, you can use the base-config tag's cleartextTrafficPermitted attribute and set it to false. This is recommended for apps targeting below API level 27, as on those versions, cleartext traffic is allowed by default. And doing this will prevent accidentally allowing cleartext traffic in case a URL used by the app gets updated by a server or a remote config. The domain tag is the subtag of the domain config tag, which is used to specify the domains to which the values provided by the domain config should be applied. Here is an example of how you would use the domain tag for a host at example.com. If you want to apply the same settings to all the subdomains of the host specified by the domain tag, use the includeSubdomains attribute. It takes true or false as values. The debug-overrides tag is used to specify values to be used when the app is compiled with debuggable as true. It can have one or more trust-anchors tags. The purpose of this tag is to avoid conditional code for debug and release versions, and thus avoid accidentally shipping the wrong network configuration for the released version of the app. As we have seen, the same set of values, like cleartext or trust-anchors, can be specified in both the base configs and the domain configs. How does the system decide which one to use when making a request? Here is how it works. The values not set in a child domain config tag are picked up from the parent domain config tag. Remember, nesting is allowed for domain tags. Values not in the parent domain tag are picked from the base-config tag. Values not set in the base-config tag are picked up from the system's default values. With that in mind, let's add a network-security-config to our contact application and modify it such that the cleartext traffic is allowed, but only for certain domains. As we have seen earlier in the slides, the cleartextTrafficPermitted field should always be false by default for all endpoints in your app so that cleartext traffic is not accidentally going through. This is what the current network-security-config looks like, which disables cleartext traffic in the base-config. Let's see what happens when, with such a config, an app tries to make an HTTP request. Here is a piece of code that is trying to make an HTTP request from an app with the config that we have seen just now. Let's make this unsecure request and see what happens. As you can see, the moment we made the request we got an IOException saying, Cleartext HTTP traffic to example.com is not permitted. This is because in the network-security-configs, we have specified that plain text traffic should not be allowed. Let's see how we can alter this so that cleartext traffic is allowed, but only to the unsecure.example .com subdomain. To do that, let's go to the network-security-config file and add this domain-config, which allows cleartext traffic only to example.com and its subdomains. Let's run this and see what happens. Let's make the request once again. As you can see, this time there was no exception thrown by the system, which means cleartext traffic is permitted, but only to example.com and its subdomains. If any other domain is requested with the HTTP protocol, the system will throw the IOException that we just saw. This is the way you whitelist endpoints where your app is allowed to make cleartext network requests. Here is a summary of what we have learned about network security on Android so far in this course. We started with understanding how apps use HTTP protocol to talk to their back-end servers and what security risks HTTP presents. Then, we learned about HTTPS and how it solves the security issues faced by HTTP and how we can migrate our apps to take advantage of HTTPS on Android. We then explored the capabilities supported by the network configuration functionality on Android and how to create a network configuration for our app. We finally dove into the various tags of a label in a network config file and how they interact with each other. Now that we have covered the basics of network security on Android, in the next module, we will learn some advanced concepts that will allow us to make our app's network communication even more secure against attacks by using a custom set of certificate authorities in a technique called certificate pinning. See you there. Thank you.

Securing Network Communication Using Certificate Authorities and Certificate Pinning
Customizing Certificate Authorities (CAs) Trusted By An App
Hey guys. This is Nitin. Welcome to the Android Security course on Inter-App and Network Communication Security. This is the advanced and final module where we discuss Securing Network Communication Using Certificate Authorities and Certificate Pinning. One of the ways you can add an additional layer of network security over what Android provides by default in your app is by customizing the set of certificate authorities trusted by your app and not just blindly trust whatever ships with the system. Before we learn how to do that, let's understand what a certificate authority exactly is. A certificate authority is an entity that issues digital certificates to organizations. The Android platform has a huge list of trusted reputable CAs baked into it, and as long as a server signs a request by one of these trusted CAs that is present on the system, the system will allow the request, else the request fails. By default, apps trust the preinstalled CAs that ship with Android, and even the user-installed CAs in case of API level 23 and below. So, as you can see, the decision to trust or not trust a CA is critical to the network security of an app. Now, given that Android ships with a huge list of preinstalled CAs, what are the scenarios where you would want to customize the set of CAs trusted by your app? One such scenario would be when your app wants to connect to a host which serves a custom CA which is self-signed or is available only within a particular organization. Another valid reason would be when you don't want to blindly trust all the preinstalled CAs on the system. And finally, what if you want to trust a CA that is missing from the preinstalled CA list? So, now that you have decided you want to customize the set of CAs trusted by your app, let's see how you can actually do it. You can do so using the trust-anchors tag with one or more certificates subtagged within it in the network config file. The trust-anchors tag can be specified inside either the domain-config tag, or the base-config tag, or the debug-overrides tag. Let's understand the certificate tag in depth, as the trust-anchors tag is just a holder for the various certificates tag. A certificate tag has two attributes. The first one, source, specifies what certificates to trust, and the second one, overridePins, indicates whether certificate pinning should be respected or not. Certificate pinning is another advanced technique used to add an extra layer of security to your app, which we will discuss in the next section. The source attribute is used to define the set of trusted CAs. The possible values are system, for preinstalled CAs, user, for user-installed CAs, and raw, for when you want to embed a certificate file in the app's APK itself. In case of a raw file, it should point to a resource file which should be an X.509 certificate encoded in the PEM format. The overridePins attribute is used to enable or disable an additional security mechanism called certificate pinning for the certificate in question. It takes true or false as values. The default value is false unless the certificate tag is inside a debug overrides tag where it's true. If the value is true, certificate pinning will be bypassed for the certificate in question, and this is mostly used only for debugging CAs or when you want to simulate a man-in-the-middle attack by bypassing the certificate pinning mechanism, which prevents that, as we will see in the next section. If you want to use a different set of CAs in debug and release mode, you can do so by placing the certificates tag inside the debug-overrides tag in the network config file and specifying there which CAs to trust during debugging. This avoids conditional code and accidentally shipping the wrong certificates. Let's go back to our contact application and see what happens when a host serves a self-signed certificate that is not there in the list of preinstalled CAs, and then we will see how we can configure our app to trust this self-signed certificate. For this demo, what we have done is configured our server, or rather the proxy server, child server, to serve a self-signed certificate whenever someone tries to hit example.com. So, let's see what happens when we try to make a request with this setup. Let's make the login request and see what happens. As you can see, after some time we get this error in the logcat which says, SSLHandshakeException: Trust anchor for certification path not found. This is essentially telling us that the certificate that was served by the intermediate server, or the server, is not something that the system trusts. Let's see how we can make our app trust such a self-signed certificate. To achieve this, what we have done is added the certificate, which is self-signed, to the raw folder under the app's resources, and now let's go to the network config file, and for the domain-config for example.com, let's add the trust-anchor tag such that the certificate which we just placed in the raw folder is trusted by the system. Now, let's run this and see what happens. Let's make the request, and as you can see, the request went through and there were no exceptions printed in the logcat. This is the way you specify your app to trust a self-signed certificate. Place the certificate in the raw folder under resources, and in the domain-config for the specific domain for which it will be served, specify that in the network config using the trust-anchors and certificates tag.

Certificate Pinning
As we have seen in earlier sections, the CA is an entity that issues certificates to an organization, and when an app sees a certificate from a CA it trusts, it allows the request to go through and assumes it's actually talking to the host specified in the certificate. But what happens if a CA issues a fraudulent certificate? For example, what if a trusted CA issues a certificate for Pluralsight.com to some random person accidentally? This is how it will play out. A trusted CA issues a fraudulent certificate to someone for Pluralsight.com. The app trusts the CA-issued certificate, as it's in the trusted CA list. The random person can now do a man-in-the-middle attack by posing as Pluralsight.com and intercepting the traffic. Since the app trusts the certificate he's serving, there is no way for the app to know that it's not talking to Pluralsight.com This is obviously a huge security issue, and the answer to this is a technique called certificate pinning. Here is how it works. The basic premise is that the app which wants to perform certificate pinning will provide a set of public key hashes for the certificates that are to be trusted. These keys are essentially hardcoded in the app's network config file. Now, when a host serves a certificate during an HTTPS handshake whose hash is not present in the set of hashes specified in the config, the request will fail. This will happen despite the host serving a certificate that was issued by a CA trusted by the app, but since the hash for the certificate didn't match any of the pinned hashes, the request failed, whereas if the hash of the certificate served by the host matches any of the pinned hashes, the request goes through. So, in a way, by pinning the hashes, the app is saying trust exactly these set of certificates and nothing else, irrespective of whether the CA is trusted or not. In such a situation, even if the attacker gets a certificate signed by one of the app's trusted CAs, he can't pose as Pluralsight.com since the app will simply not trust any certificates outside the list specified. Here is how you can configure certificate pinning in your app. The first tag is called pin-set tag and it contains a list of certificates to be pinned. It contains one or more pin tags which hold the SHA-256 hash of the public key of the certificates to be pinned. Here is some in-depth details on these tags. The pin-set tag can either be specified in the domain-config or in the base-config tag. It can contain one or more pin tags, and it can have an expiration attribute which specifies a date in the yyyy-mm-dd format. The app will not enforce pinning for the certificate specified under the pin-set tag after the expiration date passes. This is to ensure that the apps keep functioning for a user, even if it does not update the app on this device for a very long time where the pin certificates have become invalid in the meantime. The pin tag, as we discussed, is specified within the pin-set tag, and it holds the Base-64 encoded SHA-256 hash of the public key of the certificates to be pinned. It might seem like certificate pinning is the holy grail of network security for your app, but there are some pitfalls that you should be aware of while using it. Always include a backup key for each certificate in case the primary certificate gets compromised or expires. Set expirations on pin-sets so that if a user does not update his app and the certificate expires, the app keeps functioning. Keep in mind that if you set an expiration, attackers might figure that out and take advantage of it by manipulating time on the device to bypass pinning. Here is a sample that shows how the network config of your app would look like if you want to pin certificates for an endpoint called, say, example.com, along with a backup certificate. Now let's see this in action in our contact application where we will pin a set of certificates in our app and see what happens when a non-pinned certificate is served. To start this demo on certificate pinning, let's go to our network config and first pin a certificate for the example.com domain. We'll replace the domain-config tag with the following values. As you can see here, we are pinning 2 certificates with expiration 2020, one the main certificate and another one the backup certificate. With this config, now let's run the app and see what happens when a server serves a certificate which is not in the pin certificate set. Let's make the request now and see what happens. As you can see, the system threw an exception, SSLHandshakeException, saying the pin verification failed. This is telling us that the system did not find that the certificate that was served by the server was one among the ones that were pinned in our app. This is how you accomplish certificate pinning. Here is a summary of what we have learned in this final and advanced module on network security on Android. We explored the scenarios when we should consider customizing the set of CAs trusted by your app and how to configure your app to trust a custom set of CAs in regular and debug mode. We also learned why certificate pinning is needed and how it works to ensure your app is completely secure against attackers. We finally learned how to actually configure the network config of your app to pin certificates and the precautions to take while doing so. I'm confident that after watching this course, whenever you are working on an app, you would have a toolbox to come back to when thinking of security considerations for it. I hope you have enjoyed exploring the intricacies of inter-app and network security on Android as much as I have during the course. Thank you.

Course author
Author: Nitin Singh	
Nitin Singh
Nitin is an Android / iOS developer with over 6 years of experience developing world class apps and SDKs that are used and loved by millions of users. He currently leads the Mobile team at Razorpay...

Course info
Level
Beginner
Rating
0 stars with 3 raters
My rating
null stars

Duration
0h 41m
Released
15 May 2019
Share course

