Android Services Fundamentals
by Sriyank Siddhartha

A Service is one of the most basic android components that can perform a long-running task in the background and it does not provide a user interface. This course covers each and every fundamental concept related to a Service in Android.

A Service is an application component that can perform long-running operations in the background and does not provide a user interface. Another application component can start a Service and it will continue to run in the background even if the user switches to another application. In this course, Android Services Fundamentals, you'll learn everything you need to know about a Service. First, you'll explore Service, Threads, and Process. Next, you'll discover Started Service, Intent Service, Bound Service, and lifecycle of the Services. Then, you'll move on to Inter-process Communication. Finally, you'll wrap up by learning how to use Messenger and AIDL for IPC. By the end of this course, you'll have a very strong foundation on the topic of Service.

Course author
Author: Sriyank Siddhartha	
Sriyank Siddhartha
Sriyank began his career with a Bachelor of Technology in Computer Science from India. After working 2 years in Java, he found a great interest in Mobile Application Development. Sriyank works with...

Course info
Level
Beginner
Rating
4.7 stars with 50 raters(50)
My rating
null stars

Duration
3h 14m
Released
3 Feb 2017
Share course

Course Overview
Course Overview
Hi, this is Sriyank Siddhartha, and I welcome you all to my fundamental course of Android Services. I am a techie, and love to share knowledge that I have in my head. I believe sharing knowledge is the best way to gain knowledge as well, and today, I will share all the fundamental concepts related to the Android services with you all. It's always been a big thing as a big nerd to understand the implementation of the background traits, process, and how to effectively use services in our application, and service is one of the building blocks of Android, without which, your professional application is actually incomplete. So, if you are looking for all the fundamentals related to the Android services, then this course will be your final stop. So, some of the major topics that this course covers include: what is a service? What is a thread, and what is a process, and how they are interrelated to each other. What are the various types of services, such as started service, intense service, and also, bound service. Excluding the lifecycle of a service, inter-process communication, and at last, using Messenger and AIDL for inter-processed communication, that is IPC. And each of the topics in this course, we will cover it with the help of demo application, and also with the help of practical examples. So by the end of this course, you will have a very strong foundation on the topic of Android service. So, come, join me, and let's together explore the Android services in detail, only at Pluralsight.

Introduction
Overview of Modules
Hi, this is Sriyank Siddhartha, and welcome to the first module of Android Services Fundamentals. In this module, I will show you what are the topics that we will cover in this fundamental course. So let's get an overview of the topics that we will cover in this course. So first, we will get the brief introduction to the Android services in context of its practical usage, and next, we will check out what are threads and what are processes, and furthermore, we will check out what is exactly a main thread, and what is a worker thread. Also, what is the difference between these two, and as a big nerd, the developer's find or create a fake ID to understand the concepts of thread and process, with respect to the Android application. So, we will check out this topic in detail with the help of practical examples, and proceeding further, we will check out what are the various types of services in Android, such as, the Scheduled Service, Started Service and Intent Service, and also, Bound Service in Android. The topic of Scheduled Service we will check out in brief, but the topic of Started Service, Intent Service, and the Bound Service, we will check out in detail with the help of demo application, and then, proceeding forward, we will learn how to manage the lifecycle of a service to provide stability to our application. And then, how to take care of the application security while using services inside our application, and at the end of this course, we will learn how to perform the inter-process communication with the help of Messenger service and also, AIDL interface, that is, Android Interface Definition Language. And we will try to explore each and every topic mentioned in front of you with the help of demo application, and also with the help of real application examples.

Make the Most out of This Course
So how to follow this course effectively, and how to make the most out of this course. So for that, there are some prerequisites for this course, such as, you should have the Android Studio installed in your system, and also, you should know how to run Android application in your Android emulator, because in almost each of the modules, we will create our demo application to learn concepts in detail. So for that, please make sure you have Android Studio installed in your system, and also you should know how to run the Hello World application in your emulator. And proceeding forward, in each of the modules, as already said, we will create demo application to learn new concepts. So, how to follow the demo videos of this course. So for that, you have to download the exercise files from the course learning page of this course. So simply download the exercise file, and you will get a zip folder, and inside the zip folder, you will get this folder of android-fundamentals-services, within which, you will get all the slides in the PDF format that I have used to explain the concepts to all of you, and along with this, you will get all these exercise files, that is the source code of the demo application that we have made inside each of the modules. And inside each of the folders, you will get two subfolders of before and after. So, before is the project that you need to import inside the Android Studio before you get started with your demo application, and after is the final result of the demo application that you will make yourself by following the demo video at the end of each of the modules. So this after project will act as a reference for you, such that in any case, you find any difficulty, or you run into any error, then you can simply compare your code with this after project that is present inside each of the module folder. So please download these exercise files, and get started from the next module onwards.

Getting Familiar with Service
Module Overview
Hi, this is Sriyank Siddhartha, and welcome to the next module of Android Services Fundamentals. In this module, we are basically going to check out what exactly is a service, and also we will check out the various concepts related to the service in Android. So, let's check out what you will get at the end of this module. So in this module, we will first explore the various android components that is provided to us for making the application, and next, we will check out what exactly is a service, how it operates, and what are its advantages? If we decide to use a service inside our application, and along with this, we will check out what are the different types of services present inside the Android. And proceeding further, we will check out what exactly is a process, and also what exactly is a thread, and how they are related to the service and also other Android components in an Android application. And regarding the thread, we will further check out, what is a main thread and why it is also known as UI thread, and along with this, what is a worker thread or you can say what is a background thread. Now, generally as a big nerd, the developers are always confused regarding the process and also the thread, and how this process and also this thread are actually connected with the Android components. So in this module, we will cover each and every topic in detail so that you will get a clear picture of what exactly happens when you open your application.

Building Blocks of Android: The Four Components
Now in Android, basically we have four Android components provided to us for making the Android applications, and these four components are as follows: the Activity, the Service, the BroadcastReceiver, and also at last, we have the ContentProvider, and these four components are actually known as building blocks of Android, just because without these components, you cannot make your Android application, so at least, you need to make use of these components to add functionalities to your Android application, and now, the topic of Activity and also the BroadcastReceiver, I have already covered in a separate course of Android Fundamentals: Activities and also Android Fundamentals: BroadcastReceivers. And now, it's time to explore Service in detail in the current course of Android Services Fundamentals, and now, if you have not watched the courses of Activities and also the BroadcastReceiver, then also, you will understand each and every concept related to the service that I will talk about in this course, but make sure after you complete the Services course, then, you must go through these two courses of Activities and also the BroadcastReceiver in Android.

Introduction to Service
So let's now check out what exactly is a Service? Let us understand it by taking real life example. Now suppose you start an application and the screen that is present in front of you is basically an activity. So, whatever is visible in front of you simply represents an activity, and now, in the background, suppose you want to perform some tasks, such as, while you are using your application, you want to listen to the music or you want to download a file in the background. So, these two tasks that you perform in the background will be basically be carried out by the Android component of Service. So the Service is an Android component that allows you to perform tasks in the background without disturbing your current interaction with the activity. And now, let us take another example, such as, let us see you are playing a game. So the screen that is visible to you is actually an Activity, and now, in the background, suppose you want to perform some tasks, such as updating your application from the Play Store or uploading an image or a file, and now again, these two tasks in the background will again be performed with the help of Android Service. And proceeding forward, you must have noticed inside the Settings application, if you check the current usage of device memory, then you will find out of 2 GB, there is about 86% of the memory usage. Now, sometimes we think that all the applications are currently closed. Then how come this much memory is getting consumed, and out of this much memory, we have 14% free memory to use? And now the memory is actually getting used by several applications that are actually running the services in the background. So even if the application is closed, then also, the service keeps on running in the background, such as, let's take example of the Facebook application and the WhatsApp application. So here, it has services that are running in the background, and fetching their data from the server. So in short, we can see the services is actually an Android component that executes their task in the background. So even if the application is closed, then also there might be a possibility that a service of that particular Android application is actually running in the background. So the service does not contains any user interface, that is, you cannot interact with the service like you can do with an activity, and at last, to be straight, the service runs in the application main thread, that is, the service does not run in a separate thread, and it also does not run in a separate process as well. And regarding these two points at the end, we will talk about it shortly.

Types of Services
Proceeding forward, let us now check out what are the various types of services available to use in Android? So there are basically three different types of services in Android. The first one is known as Scheduled Service, and next comes the Started Service, and at last we have the Bound Service in Android. Now the service is set to be scheduled when the Job Scheduler API starts the service. And now, the service is set to be started when the Android Component actually starts the service, and at last, we have the Bound Service, so the service is set to be bound service when an Android Component actually binds to a service. And now, in case of Bound Service, we have two-way communication between the Android Component and also the Service. So after processing their data, the service, by default, has a mechanism to return back the result to the calling Android Component, but in case of Started Service, that default mechanism to return back the result is actually missing.

Scheduled Service: JobScheduler API
Proceeding further, let us now check out what exactly is a scheduled service in Android. So as already said, it is the Job Scheduler API that starts the service, and the service is now known as a Scheduled Service. And this Job Scheduler API was actually introduced in API 21, that is Android Lollipop 5. 0, and this API cannot be used for the Android devices below API 21. So as per the Google documentation, if you target API 21 and above devices, then you should go for this Job Scheduler to perform the background tasks of your application. So in short, it is actually recommended by the Google, and this Schedule Service is used to run or execute a task based on a certain specified conditions, and it is actually not time specific in nature. So the Job Scheduler API simply does the service based on a certain specified condition, not at a specific time. And now, this Job Scheduler is basically the replacement of the AlarmManager API, and now in case of AlarmManager, it was actually time specific, not the condition specific, so now, we use the Job Scheduler instead of AlarmManager in Android. So let us take few examples where we can use it, so we can use it to sync data with the server only when connected to the Wi-Fi, or start downloading the file only when their device is actually plugged in. And now, in these two examples, you can clearly see, it is based on the conditions, that is, when connected to Wi-Fi, or when device is actually plugged in. So that is why we say it is condition specific, not the time specific. And now, the topic of Scheduled Service we are not going to cover in this course, because the Job Scheduler API is only useful when you have the minimum SDK version of API 21. So, instead of focusing on Scheduled Service, we will put more focus on the Started Service, and also the Bound Service in Android, and if required, I will create a separate course on this topic of Scheduled Service implemented by Job Scheduler API.

Started Service
Let us now check out the second type of service, that is, the Started Service in Android. So in case of Started Service, it is basically the Android Component that starts a service. So that is why it is known as a Started Service in Android, and now, what are the Android Components that can start the service? So the Android Components can be the Activity, the BroadcastReceiver, the Content Provider, or the Service itself. So these are the components that can actually start the service, and now the method that is used to start the service is actually known as startService method. Proceeding further, when the service is actually started, it can run in the background indefinitely, which simply means if the calling component is actually destroyed, then also it will have no impact on the running service. So if this Android Component is actually destroyed, then this service will continue to run in the background. And now, the Started Service is actually meant to perform a single operation at a time, and by default, the Started Service does not return anything back to the caller. So how do we get data back from the Started Service so far that we have to find an alternative option, such as using the ResultReceiver, BroadcastReceiver, or the Bound Service instead. And now, how to get data back from the service using the ResultReceiver, and also the BroadcastReceiver, we will check it out in our upcoming modules. So as of now, I am just giving you an overview of the properties of the services, and at the end, you have to call stopSelf or stopService method to stop the service manually, because as already said, if the Android Component is destroyed, then the service will keep on running in the background, so it will simply result in the memory leak. So for that, you have to stop the service or destroy the service manually by calling stopSelf or stopService method. And the topic of Started Service, we will check out in our next module in detail.

Bound Service
And now, let us check out the third kind of service, that is, Bound Service in Android. So the Bound Service is also started by an Android Component, but this time, this Android Component actually binds to the service, and there is a two-way communication between the Android Component and also the service. So what are the Android Components that can bind to this service? So the Android Components that can bind to the service are actually Activity, Content Provider, and also the Service. So here, in case of Bound Service, the BroadcastReceiver cannot bind to a service, and the method that is used to bind to a service is actually known as bindService method. And now, next, the Bound Service actually exists as long as there is at least one component bound to it. So if all the bounded components are actually destroyed, the service is also destroyed, which means when this Android Component will be destroyed, then the service will also be destroyed. So here, in case of Bound Service, we have the service class that is totally dependent on the calling component, and next, the Bound Service continuously interacts with the calling component. So, by default, it has a mechanism to return the result back to the caller. That is, from the service, we can simply return the data back to the Android Component that was bounded to it, and the topic of Bound Service, we will again cover in this course in detail in our upcoming modules. So this was just an overview of various types of Android Services.

Process, Main Thread, and Worker Thread
Let us now proceed and check out what is a Thread and what is actually a Process. So let us understand it by taking some example. Now suppose you start your Android application, and now, let us represent our application with the help of this blue box. So from now onwards, this blue box will represent our application. And now, whenever we start our application, the Android system, by default, creates a process for our application. So the green box is actually their default process associated with our application. So, inside the application, we have supposed the MainActivity, the Service, the BroadcastReceiver, and also the Content Provider, and now, by default, all Android Components, that is MainActivity, Service, Content Provider, and also the BroadcastReceiver, actually runs inside the same process. So all the four components are present inside the default process of our application. And now, when our default process for our application is created, then there is also a Thread associated with it. So here, we have a Main Thread inside which all the application components runs, and this Main Thread is also known as UI Thread. So we can see now, when we launch our application, our default process is created, and then, our default thread, that is also known as the Main Thread, is created inside which all the application components runs. And suppose we cleared one more Android Component, such as Second Activity. Now this Second Activity will again run inside the Main Thread. So always remember, by default all the Android Components runs inside the same process and perform operations inside the Main Thread. And now, what are the operations that you can perform inside the Main Thread? So inside the Main UI Thread, you cannot perform a long operation. So for that, there is also a possibility to create a separate thread to perform a long-running operation. So we also have an option to create a separate Background or Worker Thread to perform some long-running operation. And now, if you want, you can also create one more Worker or Background Thread to perform some other long-running operation. So inside our Android application, now we have a Main Thread and two Worker Thread, which is also known as the Background Thread. So always remember, inside the Main Thread, we should only perform some short-running operation, and if you want to perform some long-running operation, such as download of a file, playing the music, or uploading a file to the server, then for that, you have to make use of these two Background or Worker Thread. And now, let us come back to process in Android. Similar to the Worker Thread, is there any possibility to create a separate process for our application? The answer is yes. You can create a separate process in which you can simply run your Android Component. Now suppose we have MySecondService present inside our Android application, and you want the service to run inside the separate process. So, you can simply create a separate process for your new Android Component. Find and insert this process too, we also have a thread associated with this process. So by default, each process has a Default Main Thread associated with it, within which you can simply run your Android Components. And now, along with the Main Thread inside the Process 2, you can also create a Worker Thread to perform a long-running task in the background. So this is how the process, the thread, and also the Android Components are actually interrelated to each other. And now, to summarize this slide, let us take another example. So visually, let's check out what we saw in the previous slide. So here, this is our application. So by default, when an application starts, the Android system creates their default process for our application, and there is also a thread associated with our Default Process, known as Main Thread, in which all the Android Components are present. Now let's assume this Main UI Thread is represented by this arrow. So what are the operations and tasks that you can perform inside the Main UI Thread? So inside the Main UI Thread, we always need to perform the small operations that consumes less amount of time. Now this is simply because in the Main UI Thread, all the user interaction takes place, such as the click of the button, the touch feedback, the ripple animation, zoom in, and zoom out of the image, and so on, and along with this, you can also perform some logical operation, or the mathematical operation inside the Main UI Thread. So whatever is the operation, it should never consume a large amount of time to complete its execution. And now, if you want to perform a long-running operation, then what should you do? So in that case, you can simply create a Background or Worker Thread, and now, inside the Worker or Background Thread, you can perform some long-running operation or the expansive operations, such as, Network-related operations. For example, downloading a file, loading the image from the server, and also, getting out heavy database queries. So I hope now you've got the clear picture regarding the Process, Main UI Thread, and also, Worker or Background Thread, and along with this, we also saw what are the various operations that you can perform inside the Main Thread and the Worker Thread.

Summary of Threads and Processes
Let us now proceed and summarize what we learned in the previous video regarding the Thread and also the Process. So, whenever we launch our application, there is a default Linux process associated with our Android application, and that Linux process has a single thread of execution that is known as Main Thread or we can also call it as UI Thread, because all the user interaction takes place inside the Main Thread. And now, all the Android Components, such as the MainActivity, the Service, and so on, by default, runs inside the Main Thread, and also in the same process. And the Android, what they do when the Android device is low on memory, then the Android system has got the right to shut down the process. So when the Android system simply destroyed the process, then all the Android Components that will actually present in that process, are also destroyed. So along with the process, all the Android application components are also destroyed when your Android device goes low on memory. And now, proceeding forward, by default, all the Android Components of the same application runs in the same process, and most of the application should not change this unless required. So in the extreme case, if you want, you can also create a different process for your different Android application components. Like we saw in the previous video, MySecondService was actually running in a different process, and this can be made possible by using the attribute of android: process with the Android application components inside the Manifest file. So, if you want your BroadcastReceiver to run in a separate process, then you can simply use this syntax. Define the process and give the name of the process as a string, and similarly, for the activity and also the service, you can do the same thing, but let me tell you, this is not the recommended approach unless required, because creating a separate process for your Android Components will simply consume a large amount of memory, so never do it unless required in the extreme case. And then, proceeding forward, we should never execute heavy operations on the Main UI Thread, because doing so will simply block the UI and the application will simply hang and system will generate application not responding dialog, and eventually, your application will definitely crash. So always use a separate thread that is a Worker or Background Thread to perform long-running operation, such as download of a file, uploading an image, or getting out heavy database queries. So this was all about Android Processes and Threads. Now coming up in the next module is the topic of Started Service in Android. So let's explore the Started Service in the next module. Thank you.

Working with Started Service
Overview
Hi, this is Sriyank Siddhartha, and welcome to the next module of Android Services Fundamentals. In this module, let us start exploring the started services in detail. So first of all, let's check out the properties of the started service. Now as you all know, the started service is basically independent of the calling component, that is, suppose we create a service from an activity, then that service is not at all dependent on the activity, even if the calling component is destroyed, then also the service continues to run in the background. So even if the started service is independent of the calling component, it runs on the main thread. So basically it means we should never perform a long-running task in the main thread, that is, inside the service, in case if we do so, then it may block the UI, and in the extreme case, if we block the main thread for longer duration of time, then the Android system may generate the application not responding dialog, and your application may crash. So always remember the started service, by default, runs on the main thread. Now the started service is always used to perform a single task of shorter duration, and by default, it does not have any mechanism to return anything back to the calling component, that is, the activity in our case. So you should find a way out to return the data back to the calling component from the started service. Now the started service can receive the data through an intent that is used to start the service, but as already said, it cannot return the data back to the calling component. So for that purpose, to return the data back, we can use the Bound Service, and the topic of Bound Service, we will cover in our upcoming modules. And alternatively, we can also implement a reserved receiver to receive the data back to the calling component, and how to implement the reserved receiver to receive the data back, we will check out, again, in the upcoming module.

Starting and Stopping a Service
So now, let us now proceed and check out how do we start a started service, that is, how do we instantiate a service from an Android Component, such as Activity. So for this purpose, we just need to make use of the method of startService that takes a parameter of intent, so whenever we call this method, then in that case, in case the service is not running, then it will be instantiated and also started. So the sequence in which the method inside the service will be executed are onCreate and also onStartCommand method. So, when the onCreate method is executed, it simply means the service has been instantiated successfully, and when the onStartCommand is getting executed, then it simply means the service has been started and it is now running in the background, and yes, always remember the started service runs in the main thread, that we already discussed in the previous video. And now, what if I call startService method twice? So in case we call the startService method again, so the started service that was previously running will continue to run, but in this case, what are the methods that will again be executed? Now in this case, when we execute the startService method again, then the onStartCommand method will be again executed. Now since the service is already in running state, so that is why onCreate method was not executed. So only onStartCommand will again be called, and at last, the startService method is actually the method of class Context. Now, as you all know, Context is actually the super class of the activity, so you may simply use it inside the Activity class without any hesitation. And now, after starting a started service, it is our responsibility to stop it as well because after you start this started service, the started service runs indefinitely in the background. So it is totally your responsibility to stop it. So, how to install a started service, let's check out. Now there are basically two ways to stop a service. The first method to stop a service is to simply call stopService and pass the intent associated with the service. So whenever we execute this statement, stopService, it simply terminates the ongoing running service. Now this method stops a started service no matter how many times the startService method was earlier executed. Now suppose you have called startService method twice or thrice, and soon after that, a single call to this method of stopService will simply terminate the background running service, and now, what will happen if you simply call stopService if the service is not already running? So in that case, calling the stopService won't affect your application. So if the service is not running, the calling stopService does nothing. Now the second way to stop a service is by using the method of stopSelf. Now this method, you have to call it from inside the started service class. So if you want to stop a service from inside an activity, simply use this method of stopService, and in case you want to stop the service from inside the service class itself, then simply use this method of stopSelf.

Steps to Create a Started Service
Now, how do we create a started service, that is, what are the steps involved, and what are the methods that we need to override inside the started service? So for this purpose, we need to subclass the service, and in our case, we are going to name our class as MyStartedService. java, and next, what are the important methods that we need to override inside our service class? So for this purpose, the first important method that we already talked about is actually onStartCommand method. So for the started service, this method should be overridden, and now, when this method is executed, onStartCommand, it simply means the service will now continue to run indefinitely in the background, but in the main thread, until stopSelf or stopService method is actually called inside the service or from the calling component respectively. So in short, it is our responsibility to stop the service, and now the next important method is known as onBind method. Now, whenever we use the service class, we need to override the onBind method, so it is always required to override it, but for the started service, we should always return null from the onBind method, and next comes the onCreate method. Now the onCreate method is only called once when the service is instantiated or created. So if the service is not already running and needs to be created, then onCreate method is always called, so no matter how many times you execute the startService method, the onCreate method is always called once at the time of creation. And at last, we have the opposite method of onDestroy method, which when executed, marks the termination of the service, that is, the service is no longer being used and has been destroyed, so these were all the important points related to the started service. So make sure all the points that we discussed so far are totally clear in your mind.

Let's Explore Started Service
So let us now proceed and check out our demo application related to started service, and with the help of this demo application, we are going to explore each and every concept and its practical uses as well, related to the started service. So let's check it out inside the Android Studio. So let's open our Android Studio, and let us create our new project, and name it as Services Demo. Hit our Next, let's keep it the default one. Let's hit our Next, and let us select this Empty Activity, hit our Next, and then hit on Finish. So here inside the Android Studio inside our new project, let us change the project view to project level hierarchy, so let us expand our Project, app module, source, main, java, resource, layout folder, and now, inside activity_main. xml, let us modify our code. So here, I have simply modified my layout with two buttons on the screen. The first button is meant for starting the started service and the second button is meant for stopping the started service, and on click of each of the button, these are the two methods that will be executed inside the main activity. So let us create these two methods inside the main activity one by one. So here we go, these are the two methods that will be executed on click of respective buttons. And now, let us create a new Java class inside the main package, and name it as MyStartedService, and now, simply extend the super class as Service, so it will simply show and edit, we have to override the abstract method of onBind, so simply press Alt+Enter, and implement the methods, such as onBind method. Now, in case we want to make our service as the started service, so we always need to return null from inside the onBind method, so let's keep it as it is: return null. And now, let us override our onCreate method that is always called when a service is being created, and after onCreate method, let us override our onStartCommand method, and at the end here, let us override the onDestroy method, and next, let us create the default tag for our MyStartedService class, and then, let us put the log statements inside each of the method. So here, inside all of these methods, I've simply placed log statements, and I'm simply going to print what are the methods and in what sequence they are getting executed, and also the name of the thread within which all of these methods are getting executed, we will also check out that too. And now, from the MainActivity, inside the startStartedService method, let us write our code to start the service. So let us define our intent equal to new Intent, and simply pass context of the MainActivity, and then, the second parameter will be MyStartedService. class, and then simply start the service like we start an activity. Find, so this is a syntax how you start a service. Now, whenever we start a service, it is our responsibility to stop it as well. So here inside the stopStartedService method, let us again define the intent, simply copy it, and paste it here, and then simply stop the service by calling stopService and pass the intent as a parameter. So these are the goals to start and stop the service, and now, since service is an application component, so we need to declare it inside the Android Manifest as well, like we do for Activity and also the BroadcastReceiver. So simply define the service tag, and declare MyStartedService, and now, let us run our application, and let's see what we get inside of our application. So here our application is now up and running, and here inside the lock cad, let us apply our lock filter. Now first of all, before starting our started service, let's check out what will happen if I directly click on STOP THE STARTED SERVICE. So here I go, as soon as I click on this button, nothing happens. So calling stopService, provided the service is not running, does nothing, and now, let us start the service. So here we go, onCreate and onStartCommand was executed, and both of these methods are executed in the main thread. So this is the name of the thread that you can see here, main thread, and again, main UI thread. Now what will happen if I start the service once again? So here, let us click on this button. So here we go, as soon as I clicked on START THE STARTED SERVICE button again, then here, only onStartCommand was again executed, not the onCreate method. So no matter how many times you start the service, only onStartCommand will be executed again, and now, let us stop the service. So here we go, onDestroy method was executed and tagged to in the main thread. So no matter how many times you start the service, once you call stopService method, the service will be destroyed completely, and now, let us start the service again. So here we go onCreate and again, onStartCommand was executed, and now, what will happen if you shut down the application? So, if we are going to shut down the application, then it won't affect the service, because the started service is basically independent of the calling component, so even if an application is closed, then also in the background, the started service will be in the running phase. So, let us now open our application, and then stop the service because it is our responsibility to stop the service manually. So here, if I'm going to call stopService method, then here we go, onDestroy method was executed. This simply shows even if our application was closed, then also the service was in running state. So let's check out what will happen if I again try to stop the service. So, as soon as I clicked on stopService method again, then nothing is happening, fine. So here, inside the MyStartedService class, whatever operation we want to perform, we have to perform it inside the onStartCommand method, and now, since the onStartCommand make use of the main thread, so you should keep your task very simple and of shorter duration, and we should never perform a long duration task that will simply block the UI. And now, what about this return value, that is, integer value? What should we return from the onStartCommand and what kind of short operation that we can perform inside the onStartCommand, we will check out shortly in our upcoming videos.

onStartCommand Return Flags
So let us now explore more on this started service. So inside the onStartCommand, what are the integer flags that we can return? So before that, let us understand the significance of the flags. Now sometimes the Android system may terminate the service. May be due to lack of memory, so as to free up memory for the more priority task inside the Android device. So for this case, we have to handle our service on our own. So how to handle this situation? We have to handle this situation with the help of integer flags. Now there are basically three important flags that we need to make use of. The first flag is the START_STICKY flag. Now, whenever the Android system terminates our service due to the lack of memory or some other reason, then in that case, using this flag will automatically restart our service, whenever the memory is available, but in case of START_STICKY flag, the intent delivered to our service will become null. Now the second flag that we may use is START_REDELIVER_INTENT. In this case, the service restarts automatically and the intent is also redelivered. That is, the service also gets started and the intent also do not become null, and at last, we have the third flag as START_NOT_STICKY, and in this case, the service is not restarted, and also the intent is lost, that is, becomes null. So here, inside the Android Studio, instead of returning super. onStartCommand, you can simply return START_STICKY, that will simply restart the service, but the intent that is being delivered to this method will become null, and you may also use START_REDELIVERED_INTENT, which simply means the service will be restarted and the intent delivered to this method will not be null, that is, it will be freshly delivered with the previous value. And at last, we have START_NOT_STICKY, which means the service when destroyed, won't be restarted automatically, and also the intent will be null, fine. So you may choose these flags as per your requirement. As of now, I will simply keep it START_STICKY.

Started Service by Default Works in Main Thread
Now as we all know, the started service works in the main thread, so we should never block the main thread, as it will block the UI, and the system may generate the application not responding dialog, and the application will finally crash. Now the question arises, what we will do in case if we want to perform a long-running task inside the started service. So for this purpose, we have to find an alternative. Either we should use the intent service, or we should make use of the class of asynchronous, async task class. So what are the possible solutions? So let's check out practically about this problem inside our application. So here, inside the onStartCommand, let us perform a dummy long-running task, such as Thread. sleep, let's say 10000ms, and let us surround it by try and catch, and now, let us do one thing from the MainActivity inside the startService method, here, let us pass a parameter intent. putExtra, let's give the key as sleepTime, and then simply pass 10 seconds as a parameter, and this integer value will be received inside the service inside the onStartCommand method with the help of this intent. So here, let us retrieve int sleepTime equal to intent. getIntExtra, and simply give the key as this SleepTime. Simply copy it and paste it here, and also make sure you give the default value, let's see, 1, and now, as a parameter, simply replace this 10000ms by sleepTime into 1000ms, and now, inside the activity_main. xml, let us put a checkbox at the top so that we can check out if our application UI is working perfectly fine or not (working), and let us now run our application. So here we go, our application is now up and running, so here, currently we are able to interact with our checkbox, that is, our application UI. Now, as soon as I click on START THE STARTED SERVICE method, since the service is running in the main thread, so here, you can see our checkbox is not at all working, that is, we are unable to interact with our checkbox, that is application UI, and here we go, the system has generated application not responding dialog. So this simply means our application has crashed, and we should never ever perform a long-running task in the main thread, and we should never block the UI as well, because in that case, the user will have a very bad user experience, and he will probably delete your application. So here, let us command this block of code, because this is not the recommended approach to perform a long- running task inside the onStartCommand method. So what is the possible solution for this? So for this purpose, we should perform the long-running task in the background thread. So let's check out the solution for this inside our demo application in the next video.

How to Use Started Service to Execute Long Operations
So let us now jump to our Android Studio, and let us explore the solution of the problem that we encountered in the previous video. So here, inside our service class, down the side, let us create our new class, such as MyAsyncTask. That extends the async task class, and as a parameter, initially let's pass Void, and also the third parameter as Void, and now, simply override the doInBackground method, and also, let us override doIn methods, such as onPreExecute, onPostExecute, and also, onProgressUpdate method. And now, let us insert the log statement in all these methods. So here inside the MyAsyncTask. class, I have simply overridden onPreExecute, doInBackground, onProgressUpdate, and also onPostExecute method. Now out of all these methods, there is only one method that works in the background thread or the worker thread, and that method is doInBackground method, and all these methods, such as onPreExecute, onProgressUpdate, and onPostExecute, works in the main thread. So we are only left with one option where we have to perform our long-running task. So here, we need to perform our long-running task, such as downloading a file, playing the music, etc., etc. So here inside this method, what we can do, let us write my code. Let us write the same code that we have written here. So for this purpose, first, we need to pass this int sleepTime to our MyAsyncTask. class. So here, let us remove all this code from here, and instead of this, let us instantiate our new MyAsyncTask class. execute, and simply pass sleepTime as a parameter. Now this parameter will be received by doInBackground method. So here, we need to change this Void to Integer add in, and again here, we need to change the first parameter from Void to Integer, and then simply extract the sleepTime data equal to params from the first index, and now, let us write the similar kind of code that we have written ever (typing). Fine, and now this method, publishProgress simply triggers this method onProgressUpdate, that is executed in the main thread, and here, this publishProgress simply tried to send a string parameter. So for this purpose again, let us change the second Void to String, and now, down the side, let us again, change it to String, and then simply display our Toast message (typing). So here, I have simply added a Toast statement, and also updated my log statement. So this piece of code here will act as a Dummy Long Operation. You can perform a long-running task, such as download of a file or uploading an image, etc., and yes, I forgot to implement the content, ctr++, and now, we are done with the coding part, so let us now run our application and let's see the output. So here our application is now up and running, so let us now start our service that eventually creates a worker thread to perform a long-running task. So let's start the service. So here we go, this simply has created the AsyncTask class that has started the counter, and here we are able to interact our UI as well. So this has actually provided a solution to our problem, and now, since our task is done, so we have to immediately stop our service, by simply calling STOP THE STARTED SERVICE, so our service is now destroyed; and now, let us explore more. If you notice the onCreate and also the onStartCommand works in the main thread, and then this onPreExecute works in the main thread as well, but if you look at doing background method, then this method actually works in a separate thread of AsyncTask, or you can see, it is a background thread, it never works in the main thread. That is why our UI was not blocked, but in case of onProgressUpdate method, you can notice it again works in the main thread, where we actually displayed a Toast message, because we cannot display a Toast message from the doInBackground method. We can only display the Toast message or any of the UI element from the main thread only. That is why here I have made use of onProgressUpdate method, and at the end, we have onPostExecute method that again operates in the main thread, and finally, onDestroy method was executed. Now if you want your started service to terminate automatically, so in that case, inside the onPostExecute method, what you can do, you can simply call stopSelf method. So, this simply destroys the service from within the service class itself. So you do not have to click on this button to stop the service manually. So let us test it again inside our application, and now, let us start the service, and let's see if our service stops automatically or not. So our service has been started, so at the end, when our task is over, the service has been destroyed due to the execution of stopSelf method. So in this way, you can make your service destroy itself automatically. So what basically we did in this video: so from the main Activity that runs in the main thread, we started a service, and also passed our data that was received by onStartCommand method that runs in the main thread. So, from the onStartCommand method, we actually started another class of AsyncTask, and this AsyncTask class has a method of doInBackground that runs in the background. So the very first method that is triggered in the AsyncTask class is actually the onPreExecute method, that again runs in the main thread, and after this method, we have doInBackground method that is executed and this is the only method of this class that runs in the background, that is, a separate worker thread where we can perform our long-running operation, and soon after the execution of doInBackground method, we have onPostExecute method that again runs in the main thread. Fine, so this was the overall scenario that we saw in this video. Now there are a few points that you should always remember. Now, you should always access any UI element from the main thread, such as a TextView button, or something like that, but if you are using the worker or background thread, then you cannot access the views. You should just perform a long-running task, and then return the result. Fine, so always remember, you should never access the views present in the main thread from the worker thread, or the background thread, because doing so will put you in trouble.

Summary
So finally we have reached the end of this module. So in this module, we learned that the started service runs on the main UI thread, so we should always use it for the short-running operation, and never block it by performing the heavy task. And we should always perform the long-running task with the help of the background or worker thread, so as to ensure the smooth running of our application, and now, how to start the started service by simply calling the method of startService method, and how to stop it with the help of the method of stopService or by calling StopSelf method. And now, proceeding forward, we also checked few of the flags that we can return from the onStartCommand method, such as START_STICKY, START_REDELIVER_INTENT, and also START_NOT_STICKY. And now, what's coming up next. In the next module, we are going to explore the intent service that is basically the modified version of the started service class. So let's explore it in the next module.

Creating Intent Service
Overview
Hi, this is Sriyank Siddhartha, and welcome to the next module of Android Services Fundamentals. In this module, we are going to check out how to create and use the intent service in Android. So first of all, let's check out what is actually an intent service. Now, the intent service is basically the subclass of the started service, so this is our super class, and this is the sub class. So you can see, in short, the intent service is basically the modified version of our service class. So let's check out its properties. Now the intent service is designed in such a way that it, by default, runs on a separate thread that is worker thread, or you can say the background thread. So without any hesitation, you can perform a long-running task inside the intent service class. Now, the first step while creating the intent service is to override the onHandleIntent method. So when the onHandleIntent method is invoked multiple times, then the intent service simply creates a work queue that simply passes one intent at a time to the method of onHandleIntent. So this simply means we do not have to worry about the multi-threading details that are actually handled internally by the intent service. Now, unlike the started service, the intent service stops automatically when the work is completed. So we do not have to call stopService or stopSelf method explicitly. As soon as the task is over, the intent service destroys itself automatically, so again, we do not have to worry about the memory leak. Now, the intent service provides a default implementation of the onBind method that simply returns null, and previously in the started service as well, we already saw we have to return null in case of onBind method. So here also by default, the onBind method returns null. This is simply because the intent service is basically the variant of the started service. Now, this intent service class also provides the default implementation of the onStartCommand method. So we do not need to override it, but in the previous module, we saw it is the onStartCommand method that handles the incoming intent. So what about the intent service? Coming from the calling component, such as activity, is handled here. So for that purpose, we have the intent flow like this. So whenever we pass an intent from the calling component, such as activity, the intent is first received by the onStartCommand method, and from this onStartCommand method, the intent is then delivered to the work queue, and suppose the onStartCommand method has been triggered three times, then all those intents get accumulated inside the work queue. And this work queue simply delivers the intent one at a time to the onHandleIntent method, so that is why we do not have to worry about multi-threading here, because it is handled internally by the intent service by the work queue itself. So this was all about the intent service. Let's check out how to implement it inside our demo application in the next video.

Let's Explore Intent Service
So let us now proceed and check out our demo application of intent service. So here inside of the Android Studio, this is the same application that we created in the previous module. So all we need to do is simply modify the activity_main. xml by adding a button at the bottom (typing). So here I have simply added a button at the bottom. Now for the intent service, we do not have to create stop intent service button because as soon as the task is completed, the intent service stops itself automatically. So let's create startIntentService inside the MainActivity, and here, let us write our code, but before that, let us first create our intent service subclass. So simply right-click, and simply create a New Java class, and name it as MyIntentService, and now, let us extend the IntentService class. So here we go, it simply shows an error, it simply says to override the onHandleIntent method, within which you are going to perform your long-running operation in the background. And now, it again shows an error, let us define an empty constructor. Let us press Alt+Enter, and simply create the constructor matching the super, and now here, we have to modify something, let us make our empty constructor instead of parameterized constructor. And now, within the super, we need to name our background thread, or the worker thread, so let's give it a name as MyWorkerThread, so this name will be the name of our background thread. Fine, and now, let us define the tag, and we already know, by default, the intent service provides the default implementation of onStartCommand method, so we do not have to override it again, and apart from this, it also provides their default implementation of onBind method, that it does null by default. So again, we do not need it here, let's remove it. Now just for the sake of knowledge, let us override our onCreate method, and also, let us override onDestroy method, so that we can know what's going on inside our intent service class, and now, let us put the log statements inside each of these methods (typing). And now, inside the MainActivity, let us complete our code. So in order to start the intent service as well, we need to make use of these two lines of code, and now, our next step will be to declare the service inside the manifest file, because the service is Android application component. If we do not declare it, it will simply throw an exception in our log cad, and our application will crash. So after this, let us now run our application, and let's see in which sequence the methods are getting executed, and what are the name of the thread in which these methods are working. So here our application is now up and running, so let us start the intent service. So here we go, these are the methods that are executed: onCreate, onHandleIntent, and finally, onDestroy method has been executed. Now if you notice, the onCreate method and onDestroy method runs in the main thread, but the onHandleIntent method, you can notice it works inside the MyWorkerThread. That is our worker thread, or you can say the background thread, and this is the name that we have specified here. So this is the proof that our onHandleIntent method works in the background. So we can make use of this method to perform the long-running operation, and one more thing you can notice here, after the onHandle was executed, the service was terminated, that is, onDestroy was executed. So we do not have to stop the service manually, like we did in the previous module. So now, to pass our data from the MainActivity to the service, we again need to copy the statement, and paste it here. So this integer value will be received by onHandleIntent with the help of this intent parameter. So let us retrieve the value, get an extra, give the key as sleepTime that we have given here, and then, put the default value as one, and now, we will simply navigate to MyStartedService, and down the side, within the AsyncTask class, within the doInBackground method, let us copy this statement, and paste it inside onHandleIntent method. And now, instead of publishProgress, let us use Log. i, and print the value of the counted. So now this code snippet will act as a dummy long operation, so instead of this code snippet, you can perform the long-running task, such as fetching some data from the server, uploading a file, or heavy database queries. So let us now run our application and let's see if everything is working fine. So let us now start our intent service. So here we go, our application UI is again working perfectly fine, nothing is blocked. This is because of the worker thread or the background thread. Fine, so this was all about the intent service in Android. This is the modified version of our service class, and you can simply open this intent service class, and you can notice it simply extends from the service class.

Started Service vs. Intent Service
So let's now conclude this module by comparing the started service and also the intent service. Now the started service, by default, operates in the main thread, while on the other hand, the intent service operates in the worker thread. The started service when used, may block the UI, but the intent service does not block the UI, and the started service is meant for shorter duration of time, that is, to perform very light operations, such as mathematical operation you can see, but on the other hand, the intent service can be used for longer duration of time, that is, for heavy and expensive operations. So by this, we have completed our discussion on intent service. Thank you.

Understanding Communication Flow Between Service and Activity
Problem Statement
Hi, this is Sriyank Siddhartha, and welcome to the next module of Android Services Fundamentals. In this module, we are basically going to check out the communication flow between the service and also the activity. Now let us first understand the problem statement. So sometimes there exists a situation when a calling activity that starts a service needs the data back from that service, but the problem is the services, by default, do not have any mechanism to return the result through the intent back to the calling component, that is, activity. So sometimes, we need the result back to update the UI element presented inside the activity class. So how can we do it, let's check out in this module. Now, there are basically two solutions for this, to pass a data back from the service to the calling component or the activity. The first solution if a very basic one, that is, using the BroadcastReceiver, and the second solution is to simply use a ResultReceiver that is meant for that purpose to get the result back from an application component. Now, if you have the communication between two applications, then you can simply go for BroadcastReceiver, but if you have the communication flow within the same application, then you may go for ResultReceiver, and this BroadcastReceiver can also be used for the communication within the same application as well, but down the side, this ResultReceiver can only be used for communication between the application components within the same application. So for the BroadcastReceiver, what we are going to do, from the activity, we are simply going to pass our data or the intent to the service, and from the service, we are again going to return our data back to the activity with the help of BroadcastReceiver. Now for the BroadcastReceiver, we again have two options. The first is the local broadcast, if we want the communication within the same application, and second, we have the normal broadcast if we have the communication flow between two different applications, and for the ResultReceiver, we are again going to perform the same thing. From the activity, we are simply going to pass the ResultReceiver object to the service, and from the service, we are going to send our data back to the activity again with the help of ResultReceiver.

Using ResultReceiver for Communication
So let us now proceed and check out our first solution, that is, communication flow with the help of ResultReceiver in Android, and this ResultReceiver allows the communication flow within the same application, not outside the application; hence, increasing more security. So here inside the Android Studio, this is the same application that we created and used in the previous two modules. So in this module as well, we are going to make use of this application only. So inside the activity_main. xml, let us update our application UI. So here, let us add a TextView. So here, inside our Activity_Main. xml, I have simply added two TextViews, and both our TextViews will display the result coming back from the started service and also the intent service class. So this TextView will simply display the result coming back from started service class, and this TextView at the bottom will simply display the result coming back from the intent service class. So here inside the MainActivity. java, let us initialize these two TextViews (typing), and now, for the demo of ResultReceiver, we are simply going to make use of the intent service class. So here, our first step will be to create a ResultReceiver subclass, so private MyResultReceiver extends_ResultReceiver. Please select android. os. ResultReceiver, and here it shows some error, let's press Alt+Enter, and simply create the constructor matching the super, and now, just below the constructor, let us override onReceiveResult method, which is the callback method that is responsible to receive the data from the intent service class. And now, our next step will be to initialize this myResultReceiver class, and simply pass null as a parameter, which will be our handler, and now next, we have to simply pass this ResultReceiver as a possible extra through this intent object. So here, simply pass intent. putExtra, and let us give the key as receiver, and the value as myResultReceiver. So this myResultReceiver is actually a parcelable object, because, if you notice, this ResultReceiver simply implements a parcelable, so this MyIntentService, which is our intent service class, is simply going to receive the parcelable extra with the help of this indent object. So here, our next step will be to retrieve our ResultReceiver, so simply type resultReceiver equal to intent. getParcelableExtra, and simply pass the key as this receiver. Simply copy it, and paste it here, and now, down the side, after the operation has been completed, we need to return back the result to the MainActivity. So for this purpose, we can simply make use of this resultReceiver object that we have retrieved here. So simply type resultReceiver. send, and here it expects two parameter. The first is the resultCode, let's make it 18. As a second parameter, it expects a resultData, which is our bundle object. So for this, first, we need to create the bundle object that we need to send back to the MainActivity, and then, bundle. putString, let's give the key as resultIntentService, and second parameter as a string value: Counter stopped at, let's put the counter value, fine; and then as a second parameter, simply pass this bundle object. So this statement: resultReceiver. send method is simply going to trigger the onReceiveResult method present inside MyResultReceiver class. So here, we need to make use of the resultCode and also the resultData that is a bundle object. So let us put our code here. If the resultCode is equal to equal to 18, and the resultData is not equal to null, then only enter into this code block, and now, this 18 should be equal to this 18 that we have defined here. Now, if you define here, 21, then please make sure this is 21 here. So as of now, let's make it 18 only, and now, inside this if block, we can simply retrieve the String: incoming result with the help of this bundle object, resultData, which is our bundle,. getString, and simply give the key as this resultIntentService, copy it, and paste it here. And then, let us display the data with the help of this IntentServiceResult text view, and now, if you notice, earlier I told you the intent service works in a separate thread, so this onHandleIntent method works in a worker thread, not the main thread. So inside the MainActivity, this onReceiveResult method also works inside the worker thread, not the main thread, so as per the rule, we cannot access the text view from the worker thread because it will simply crash our application and throw an error. So for this purpose, what we need to do, we need to define our handler. So at the top as a fill variable, let us define our handler, and down the side, with the help of this handler that we have defined inside the main thread, here, let us put handler. post, create the new Runnable object, and override the run method. So let us grab this code from here, and paste it here, and yes, let's make this string to final. So what we are basically doing here, from this method of startIntentService, we are simply passing the parcelable object of ResultReceiver by using intent. putExtra, give the key, and as a value, pass the object. Fine, and this myResultReceiver will be received inside the onHandleIntent method here, and now, down the side, after the operation is over, we are simply sending the data back to the MainActivity, that, hey, the operation is over and the counter has stopped at 11 seconds or 10 seconds, something like that. And now, inside the MainActivity, this onReceiveResult method will be invoked, where, for the safety purpose, I am simply checking the resultCode and also if the resultData is not equal to null, and soon after this, we are simply going to retrieve the data from the resultData bundle, and store it inside the result String. And now, since the onReceiveResult method is executed in the worker thread, so that is why I'm simply using the handler to post the data back to the UI element of the main thread. And now always remember, the handler is something that is here helping us to access the UI element from the worker thread. And now, just for the sake of knowledge, let us insert the log statement here, so that we can know in which thread this onReceiveResult method is getting executed, and also, inside the run method, let us put our log statement here as well, and let us give the tag as MyHandler. So let us now run our application. So here, I have simply applied my log cad filter, and now, let us start the intent service. So here we go, onHandleIntent has been triggered, and after 10 seconds, we have got the result back to the MainActivity, counter stopped at 11 seconds. So this 11 was the last value of counted variable in CTR, and now, here you can notice something interesting. This onHandleIntent was executed in the worker thread, that we have given it a name of MyWorkerThread, and now, after this, when onReceiveResult present inside MyResultReceiver class was executed, it was also executed inside the MyWorkerThread, that is, it was not executed in the main thread, and here you can notice, this is MyHandler that was executed inside the main thread. So this simply means this onReceiveResult method was executed inside the worker thread that is a background thread, and this method, public void run, was executed inside the main thread. So that is why we were able to update our UI element here. So this is we use a ResultReceiver to get the data back from an application component.

Using BroadcastReceiver for Communication
So let us now proceed and check out our next solution, that is, using the BroadcastReceiver to get the data back from the service. So when we are using the BroadcastReceiver, we have two further options. To use either the local broadcast, and also the normal broadcast. So if you want, you can use the local broadcast if you have only the communication within the same application, and you can also use the normal broadcast for the local communication as well, but you may use it for communication between two different applications. So here inside the Android Studio, we are going to use the normal broadcast receiver to get the data back from the started service. Now, this time, we are going to use MyStartedService. java, and in the previous video, we have used MyIntentService. java to get the data back with the help of the ResultReceiver example. So inside the MainActivity, our first step will be to create a BroadcastReceiver. So, just above MyResultReceiver class, let us write the comment line so as to avoid any confusion. So here, let us create our BroadcastReceiver, and let's give it the name as: myStartedServiceReceiver equal to new BroadcastReceiver, and simply override the method of onReceive method, and now, the topic of BroadcastReceiver, I've already covered in the course of Android Fundamentals: Broadcast Receivers. So if you have followed that course, then you must be knowing here, we have created the BroadcastReceiver dynamically. So when we created the BroadcastReceiver dynamically, we have to register it with the help of the intent filter dynamically as well. So here, I am simply going to override the onResume method, and then, I'm simply going to define my IntentFilter, and then, we will define its action, that will be a string constant. So let's give it a user defined name, let's say action. service. to. activity, and then, simply register this receiver dynamically inside the context of this activity, and as a second parameter, simply pass intentFilter as a value. So this completes the registration of our dynamic BroadcastReceiver. Now, again, whenever we register our dynamic BroadcastReceiver, then it's our duty to unregister it as well, before we shut down the activity or the application. So here, just below it, let us override onPause method. So inside the onPause method, let us unregister our BroadcastReceiver. So here, this completes our code inside the MainActivity, and now, let us move to MyStartedService. java. So inside this class, we are here getting the result inside the MyAsyncTask class. So here down the side, within the onPostExecute method, this method, onPostExecute, is the last method that gets executed in the main thread. So here, how can we get the value of counted in similar way that we did in the previous video? So for this, this method, doInBackground, actually returns a value in the main thread, and that value is basically received by the onPostExecute method in the form of this parameter. So as of now, this doInBackground method simply returns a void. So here, let's make it a string, and now, let us return a string value. Let's say, Counter Stopped at, add the counter value, plus a suffix of seconds, and now again, at the top, we have to change this void to a string type. Fine. So this rectifies our error, and now, down the side, here again, we have to change it to String, and also let us rename this parameter to String str, or something like that, and similarly here as well. And now, here what we're going to do, we are simply going to broadcast an intent that will be received by the MainActivity. So for this purpose, let us define our intent equal to new Intent, and now simply pass the string action. Now this string action will be similar to what we have defined here. So let us copy this string action, and paste it inside the Intent. So this creates an intent object that has this string action that is acting as an identifier, and now, let us add string to the intent, putExtra, let's give the key as startServiceResult, and then, pass the value as string str, and this str is actually this string str. And finally, send the broadcast by using sendBroadcast method, and pass intent as a value. So when this statement will be executed, inside the main thread, this will be received by the BroadcastReceiver present here. So here, we are going to receive the same intent that we are sending from there. So inside this, let us extract the String result with the help of this incoming intent, intent. getStringExtra, and give the key as what we have defined here: startServiceResult. Copy it, and paste it here, and finally, update the UI text view StartedServiceResult. setText, simply pass a result as a value. So this completes our coding. So what we are basically doing here; we have created a BroadcastReceiver and a registered it dynamically inside the onResume method with a specified action name, and then, with the help of this method, startStartedService, we are simply starting the service. And now, inside the MyStartedService, on execution of onStartCommand, the service gets started, that simply creates a background thread that is AsyncTask, that performs some tasks in the background with the help of this method: doInBackground. And this doInBackground method simply returns a value in the former string that is actually received in the main thread with the help of this onPostExecute method. So this onPostExecute method that is executed in the main thread, simply broadcasts an intent that we will receive by the BroadcastReceiver in the MainActivity. So inside the MainActivity, down the side, this is the BroadcastReceiver that is going to receive the intent, and from this intent, we are simply extracting the result, and then displaying it to the UI element that is our text view. And finally, when the application will close, we are simply unregistering our BroadcastReceiver, which is a mandatory step. So let us now run our application, and let's see the output. So here, our application is now up and running, so let us start the started service. So here we go, the background thread has started, and now finally, we have got the result back from the started service with the help of BroadcastReceiver, counter stopped at 11 seconds. So this is how we use a normal broadcast to get the data back from any application component, and now, what are the features and what are the properties of the BroadcastReceiver? I will let you know a good reference from where you can study about this BroadcastReceiver, and in the previous two videos, I have used the ResultReceiver and also the BroadcastReceiver. So, you can use either of these two with any of the service, and in this video, I have simply used the BroadcastReceiver for the case of MyStartedService, and in the previous video, I have used the ResultReceiver in case of intent service for the communication flow. Now, you may use the ResultReceiver for this MyStartedService as well, and the BroadcastReceiver for this intent service as well. It is totally up to your choice. I had two options and two service class, so one by one, I have showed you how to use it by taking these two services class as the example. So it is totally up to your choice, what do you want to use for the communication flow.

Summary and References
So finally we have reached the end of this module. Now whatever options that we saw in this module, among those two options, what should I choose? So, if you have the communication flow within the same application, then you can use the ResultReceiver and also the BroadcastReceiver both. The choice is yours, but if you have the communication flow outside the application, then you have to use the BroadcastReceiver, and now, from where you can get the detailed knowledge of the topic of BroadcastReceiver. So for this, you have to go through the course of Android Fundamentals: Broadcast Receivers, where you will get all the deep knowledge of local broadcast and also normal broadcast, in what scenarios you can use it, when to use it, and how to use it, everything will be answered in detail in the course of Android Fundamentals: Broadcast Receivers. So make sure you go through this course. So this was all for this module. Thank you.

Getting Familiar with Bound Service
Overview
Hi, this is Sriyank Siddhartha, and welcome to the next module of Android Services Fundamentals. In this module, we will proceed a step ahead and check out what is a bound service. So let us recall a few of the things from the previous two modules, and let us call it with our new concept of bound service. So in the previous two modules, we learned about the started service, and also we learned about the intent service in Android, and we also learned in order to start a service or to invoke an intent service, we needed startService method that should be called from inside the application component, such as activity. And now, how to start a bound service from an application component. So in order to start a bound service, we have to make use of the method of bind service method, so whenever we start a service, with the help of this method, bindService, this will simply attach the service to the calling component, such as activity. So this is the basic difference between a started service and the bound service in Android. Now, let us proceed further. Now, as you all know, in case of started and also the intent service, once the service has been started by the calling component, it continues to run indefintely. So in case of started service, or the intent service, if the calling component is destroyed, then also the started service continues to run normally. So the started service, once started, becomes independent of the calling component that started it. So until we call stopService or stopSelf, the started service continues to run indefinitely in the background, or in the case of intent service, that stops automatically when the task has been executed completely. So in short, in case of started or the intent service, you have to somehow stop the service by calling stopService or stopSelf method. But, let us come to bound service. Now in case of bound service, the scenario is a little different. Now the bound service is totally dependent on the calling component that started the service by calling bindService method. So if the calling component in case of bindService is destroyed, then the bound service is also destroyed simultaneously. So in this case, the bound service is totally dependent on the calling component, and now, on the left-hand side, you can see I have simply retained the application component, not the activity service or BroadcastReceiver. So the point of discussion is that in case of started service, the application component can be an activity content provided service itself, or the BroadcastReceiver. So all the four components has the right to start the service in our first case. But in case of bound service, what are the application component that can bind to a service? So in our second case, we have only the activity, content provider, and also the service itself, but here in case two, we cannot use a BroadcastReceiver to bind to a service. So always remember this point. The BroadcastReceiver can never bind to a service by calling bindService, and now, let us talk about the communication flow. Now in our first case as we saw in our previous module, we have to find an alternative for the communication flow from the service, back to the calling component, such as an activity. So we have to find an alternative of using the ResultReceiver, and also the BroadcastReceiver for communicating back to the calling component, but here in case of bound service, we have the two-way communication. So the bound service has a native mechanism to communicate back to the calling component, such as an activity, which was actually lacking in the case of started service. So you may call it an advantage of the bound service, that it has a native mechanism to communicate back to the calling component, such as an activity. And now, let us proceed and check out a few of the points related to the bound service. Now similar to the started service, the bound service also works in the main thread, so there is no point of performing a long-running operation inside the bound service methods. And now, this bound service is basically based on a client-server relationship principle. As for example, the component that binds to the service is known as client, and our bound service will act as a server. So the bound service that is acting as a server, continuously interacts with the calling component, which is our client. So that is why if the calling component that is our client is destroyed, then our bound service, which is our server, will also be destroyed simultaneously. And now, any application component can bind to this bound service, except the BroadcastReceiver, which we already talked about in the previous slide. And now, if the number of active components that is bound to the service is destroyed, then this bound service is also destroyed simultaneously, which we already talked about in the previous slide as well. And now, proceeding forward, let's check out few of the methods, such as, in case of bound service, the onBind method always returns iBinder, unlike the case of started service that returns null. Now we always have to bind to a service with the help of bindService method, and if we want to unbind from the service, we can simply call unbindService method. So these were all the important points related to bound service in Android.

Initial Project Setup
So let us now proceed and check out our initial project setup inside the Android Studio. So here, inside the Android Studio, we are simply going to make use of the same application that we used in the previous modules. So here, inside the layout folder, let us create our new layout file, and name it as activity_second, and now here, I am simply going to pause the video, and simply going to modify my layout. So here, I have simply modified my layout with four buttons on the screen, and along with the four buttons, we have to edit text to get the user input and also add the center, we have our TextView to display the result, and with the help of this layout, we are simply going to perform a mathematical operation on two numbers, and display the result to the user. So let me show you the code. So here, this is our EditText one, and then I have another EditText to get the number to as an input from the user, and then, we have add button, then subtract button, multiply button, and at the end we have division button. And now, we have a TextView to also display the result in front of the user, so these are the code, and if you notice, on click of each of the button, onClickEvent method will be executed inside our SecondActivity. java. So here are the onClick attributes, and also at the top, we have the onClick attributes here, and now, let us create our SecondActivity. java, and simply extend AppCompatActivity, and simply override onCreate method and also link the layout, and now, inside the layout file, let us press Alt+Enter, and simply create onClick event inside the SecondActivity. java. So, on click of all these four buttons, a common method will be executed, known as onClickEvent method, and now, let us initialize all these EditText and also the TextView inside the SecondActivity. java (typing). So here inside this method, I have simply initialized my two EditText and also a TextView, and here, these two lines of code are simply extracting the values from the EditText, and also converting it to the integer value. And now here at the top, I will simply create a boolean variable, whose usage I will let you know shortly in the next video, and now, down the side, I will simply write a switch case statement, but before that, I will simply keep a check if our activity is bound to the service or not. So if isBound, then only enter into the switch case statement for the respective buttons. So here, I have simply retained my code for the switch case statement for various buttons present in our ActivitySecond. xml, that is these four buttons, and now, our next step will be to create our bound service. So here under the main package, let us create a new java class, and let's name it as MyBoundService. java, and now here, I will simply extend a service class, and here it is showing some error. So, we will rectify this error in the next video. So as of now, let us complete our project setup. So for our project setup, I'm simply going to add few of the methods here. So these are the methods that I have simply added inside MyBoundService. java so as to perform the mathematical operation between two numbers that will be inputted by the user. So this marks the completion of the initial project setup, and let's continue our discussion in the next video.

Let's Explore Bound Service
So let us now proceed and explore the bound service in detail inside the Android Studio. So here inside the Android Studio, we have our activity class that will be our calling component, and this is our BoundService. java class to which our activity is going to bind. So to establish a connection between the calling component and also the service, we need to make use of a special class of service connection. So here inside the SecondActivity, let us create our ServiceConnection class. So this ServiceConnection class overrides two methods: onServiceConnected, and also onServiceDisconnected. So as the name suggests, this method will be executed when there is a connection established between the SecondActivity and also the bound service, and this method onServiceDisconnected will be executed when this SecondActivity will unbind from this service class. So when the service connection will be established, then let us make this isBound variable to true, and when the service is disconnected, then let us make isBound variable to false, and now, let us come to MyBoundService. java. So here it is still showing some error. So let us press Alt+Enter, and simply implement the method, and let us override onBind method. Now, in case of bind service, the onBind method should never return null, it should return the instance of binder object. So for that, we have to create a local binder that will simply help the activity to bind to this service. So here, let us create an inner class a binder, and name it as MyLocalBinder that extends a binder class. Now, if you notice, this binder class simply implements the interface of iBinder, which is basically this iBinder. So we can simply here return the instance of MyLocalBinder. So for that purpose, let us create affiliated variable of MyLocalBinder, and now, simply return MyLocalBinder object from the onBind method. So this simply means we have just now converted this service class to bound service, so this class will now act as a bound service, and now, this local binder should return the instance of this MyBoundService. java. So for that purpose, let us create a method that will return MyBoundService object, so here, simply return MyBoundService. this, that is current instance of this class, and now, we have simply completed the code inside MyBoundService. java. I will again explain you the methods and functions present inside this class in detail shortly. So let us now move back to SecondActivity. java, where we need to override onStart method. So whenever the activity starts, we need to make this activity bind to this service, so here, let us define our intent and second parameter as MyBoundService. class, like we define any intent to start a service or bind to a service, or start a activity, and now here comes a twist. Instead of startService, we need to simply write bind to the service, with the help of bindService method. Now here it expects three parameters, the first is the intent itself, so simply pass intent. Now second is the ServiceConnection instance, so here at the top, we already have the service connection. So simply pass mConnection variable. Now the third parameter is basically the integer flag that I will again talk about it shortly. So as of now, let us simply return BIND_AUTO_CREATE that we generally use while binding to a service. So please don't worry about this flag, I will talk about this flag shortly, in my upcoming video. And now, our next step will be to create the field variable of MyBoundService. Soon after this, inside the onServiceConnected method, here we have two parameters. The first is the ComponentName and second is the IBinder. Now, whenever we invoke the service with the help of bindService method, we pass the second parameter as the service connection, so whenever this method is executed, inside the MyBoundService. java, the onBind method is also executed. So when this method is triggered, this simply returns the instance of myLocalBinder, which is actually received by the service connection, onServiceConnected method here. So this is basically the service that we are getting here. So instead of service, just for the sake of better understanding, let's rename it to iBinder, and now, if you notice, from the MyBoundService method, we are returning the instance of myLocalBinder, so this is basically the iBinder. So here, that is why I have changed it to iBinder, so as to avoid any confusion. So from this iBinder, we can simply extract our local binder. So for this, let us type MyLocalBinder, space, myLocalBinder equal to iBinder, and now simply typecast it to MyLocalBinder type. So here with the help of this iBinder, we are able to get back MyLocalBinder. Now, inside the MyLocalBinder class, if you notice, here we have defined a method: getService, so with the help of the instance of MyLocalBinder, we can simply call this method, getService, that is simply going to return the current instance of MyBoundService. java. So here, let us simply call myLocalBinder. getService. So this method, getService, is simply going to return the instance of MyBoundService class. So, let us assign it to MyBoundService that we have defined here, and now, we have successfully got the reference to this MyBoundService. java. So our next step will be inside the onClickEvent method. So here, let us define a string, resultString, and now, inside each of the case statement, let us call myBoundService since we got the reference to this MyBoundService. class, so we can easily access these public methods, such as add, subtract, multiply, and also divide. So, within the SecondActivity. java, simply call myBoundService. add method, and simply pass integer numOne, and also integer numTwo, and now, simply assign it to resultStr equal to this, and this add method simply returns integer value. So let us convert it into string (typing), and now similarly, let us repeat it for the other case as well: subtract, multiple, and finally, divide. So this completes our code inside the SecondActivity. java. So after running the application, I will simply walk you through what we have actually done inside our demo application. So at the end, we forgot one more step. So after we get the result, simply display it in the UI. So, txvResult. setText, simply pass resultStr, and now, inside the manifest file here, let us declare our service and also the activity. So let us declare our bound service, and also our SecondActivity. java. And now, inside the MainActivity, here we need to add a button at the bottom that will help us to navigate to our SecondActivity. java. So let us define a button, and now, simply create this method, move to SecondActivity inside the MainActivity, and here, let us write the code to start the SecondActivity. So we are now done with the coding part, so let us now run our application and let's see the output. So here, our application is now up and running, so this is our MainActivity, and let us now move to bound service demo activity. So this our application UI of SecondActivity. So, let us now add two numbers, so here we have 0 and 0 as our default value, so the result is 0. So let us now add in here, and let's say seven here in the second EditText. So, let us now click on add button. So here we go, 17 is the result, subtract, 3, multiply, the result is 70, and divide, the result is 1. 4 some floor valued. So we have successfully made our activity bind to the service, and the bind service continuously gives response to the calling SecondActivity, so that is why we are able to perform the operation continuously with the help of the methods present inside MyBoundService. java here. So these are the methods that are actually exposed to the SecondActivity, and the SecondActivity is continuously making use of these methods, and one more point to remember, the bound service always operates in the main thread. So if you want, you can put a log statement and get the name of the thread in which it is actually running, and now, let us press the back button, and let's see what happens. So here we go, inside the log cad you can see it has thrown some error. It is actually ServiceConnectionLeaked error. It simply shows ServiceConnectionLeaked. Now, this is simply because within the onStart method, we have actually made the activity bind to the service with the help of this statement. Now, when we are moving out from the SecondActivity, then we also need to override onStop method where we are going to unbind our service. So for this purpose, first, we will check if the activity is actually bound to the service or not. Now if it is bound to the service, then simply unbind the service by simply passing the instance of ServiceConnection, and after this, let us make our isBound variable to, let's say, false. So when the statement is executed, it is simply going to trigger this callback method, onServiceDisconnected. That way, the connection between the SecondActivity and MyBoundService is now stopped, and if you run the application right now, everything will work smooth. So let me quickly walk you through what we have done here. When the application starts, this method, bindService, will be executed. That will simply trigger onBind method inside MyBoundService. Now this onBind method simply returned the instance of LocalBinder, that is, this class, and this class is a subclass of binder class. So, when onBind method simply returned the instance of LocalBinder, this will be received by the service connection that is onServiceConnected, with the help of this parameter, iBinder, and now, with the help of this iBinder, we are retrieving back the instance of MyLocalBinder. And with the help of the instance of MyLocalBinder, we are getting the instance of the current bound service right here, with the help of this method at the top. And now, down the side, with the help of this current BoundService instance, we are able to perform the various operations that you can see here. So this is how the things goes on when we use a bound service that is actually private to our application.

Bound Service Demo: Code Summary
So let us now proceed and check out the code snippet of the demo that we saw in the previous video. So in the previous video, we had our calling component and activity named as SecondActivity, and we also had a bound service named as MyBoundService. java, and now, inside the SecondActivity that is the calling component, we had a ServiceConnection class defined as a field variable. And inside the ServiceConnection, we had onServiceConnected method that we need to override anyhow, and it has a second parameter known as iBinder that is of primary importance. and now, inside the MyBoundService class, we have the LocalBinder that is really helpful to bind to the service, and this simply returns the current instance of MyBoundService class with the help of a custom defined method of GetService that I have not mentioned here. And now, as a field variable, we are simply going to initialize the instance of MyLocalBinder with the help of this statement, and inside the onBind method, we are simply going to return this instance of MyLocalBinder, such as, return myLocalBinder. So, when the onBind method simply returned the instance of myLocalBinder, then this instance will be received inside onServiceConnected method. And now, inside the MyBoundService class, we have a add method that will be exposed to the SecondActivity when the ServiceConnection will be established. So, inside the SecondActivity. java, when the application starts, we simply call bindService, that takes a second parameter of ServiceConnection. So this simply triggers this onBind method that simply returns the instance of myLocalBinder that is received by onServiceConnected method here. So inside this method of onServiceConnected, we are simply going to get the reference of myLocalBinder, that is actually present here. So this myLocalBinder is now available inside the onServiceConnected method here, and now, with the help of this myLocalBinder, we are simply going to retrieve the instance the bounded service that is myBoundService. So once we got that reference to the current instance of myBoundService, then with the help of this reference variable, we can now perform tasks, such as, myBoundService. add method. So this is how the add method got exposed to the calling component of second activity, and now, at the end, when the application closes, or shuts down, you need to unbind the service by calling unbindService, and pass ServiceConnection as a parameter. So this was all about the explanation of the code snippet that you saw in the previous video. I hope now there is no doubt how the bound service operates in our application, and how the methods get exposed to the calling component. Thank you.

Various FLAGS for Binding
And now, let us now proceed and check out the flags, that is a third parameter when we call BindService method. So what I'm talking about is actually this statement, BindService, where we passed the third parameter as BIND_AUTO_CREATE. Now, generally we pass BIND_AUTO_CREATE as an option. So let's check out the other options as well. So the first one is a very common one, BIND_AUTO_CREATE. So when we use this flag, it automatically creates the service as long as the components are bound to it, pretty simple, and now next comes BIND_DEBUG_UNBIND. Now this flag is mainly helpful while debugging. This flag creates debug information for any unmatched bind or unbind calls. So when you are debugging a particular bound service that is actually being called for many different components that are bound to it, then you might need it, and now, next flag is of BIND_NOT_FOREGROUND. So as the name suggests, the bound service will never be brought to the foreground process level. Now what does this foreground process level stand for? It is basically that level where your activity runs. So when you use this flag, the Android system will not bring this bound service to that foreground process level, where your activity is actually running, and now at the end, we have 0 as an integer value straight, that simply stands for none of the above. So if you want nothing, then simply use 0, and now, there are many other flags as well, but those are rarely used, so you do not have to worry about those flags. I have simply mentioned you a few of the flags that can be used while you are making any application.

Started Service vs. Bound Service
So finally we have reached the end of this module. So here in this video, let us compare the started service or the intent service with the bound service. Now the service on the left-hand side is basically used to accomplish or finish any task. That may be a long task, but on the right-hand side, we have the bound service whose primary purpose is to serve a long-standing connection between the calling component, such as activity and the service. So whenever the activity will need the service, it will use the service, so that is why we have used the term of long-standing connection, and now, the started service or the intent service starts by startService method, but for the bound service, any component can bind to the service with the help of bindService method. And now next, in case of intent service or the started service, the onBind method simply returns null, and we need to override the onStart command method if we are starting the service. And now in case of bound service, onBind method simply returns the iBinder that simply points to the local binder object, and now here in case of bound service, we do not have to override the onStart command method. And now, in case of started service or the intent service, it continued to run even if the calling component is destroyed, but in case of bound service, the scenario is different, the bound service is basically dependent on the calling component, so if the calling component is destroyed, then the bound service will also get destroyed. So these were the basic differences that we need to know about between the started service and the bound service. And now, few important points to remember. So in this video, we used onStart and onStop method to bind our unbind the service, and in general application scenario, we make use of onStart and onStop method to do the same. So in this case, the bound service is only active when the activity is visible to the user, that is, user is able to interact with the service, but in some special case, if you want your activity to bind to the service even if it is not visible, that is, the activity is in paused state, and in that scenario, if you still want your activity to bind to the service, then you may simply use the onCreate method to bind the activity to the service and you may unbind the service inside the onDestroy method. So, instead of onStart and onStop, now you need to use onCreate and onDestroy method to bind and unbind the service, respectively. Then only your activity will be able to interact with the bound service even if it is in paused state. So yes, we can now conclude this module, thank you.

Managing the Lifecycle of a Service
Exploring Lifecycle of Started and Bound Service Visually
Hi, this is Sriyank Siddhartha, and welcome to the next module of Android Services Fundamentals. This module is going to be a very short module in which we will talk about the lifecycle methods of the services in detail. Now, in the previous modules, we already saw the started and also the bound service, and we have also overridden all the lifecycle methods, such as onStartCommand, onCreate, onBind, and so on. So one by one, we will check out the lifecycle methods of the started service and also the bound service. So on the left-hand side, we will have the lifecycle of the started service, and on the right-hand side, we will have the lifecycle methods of the bound service, and at the center of the screen, we have a pink box that will simply depict the active lifetime of a particular service. So let us start with the started service. So these are basically the Android component that has the right to start a service, such as Activity, BroadcastReceiver, Service itself, and also the ContentProvider. This simply means all the Android components have been given the right to start a particular service with the help of a method of startService. So calling startService and passing intent as a parameter will simply trigger a method inside the service class known as onCreate method. So the Android system simply invokes this method to perform one times setup procedures when the service is initially created. And now, if our service has already been started, and if you again start the same service, then this onCreate method won't be called. This simply means onCreate is called only once at the time of starting the service. So this onCreate is basically the entry point of your Android service, and soon after onCreate, the control enters into the method of onStartCommand method. And now, for a service to behave as a started service, it is mandatory to override this method of onStartCommand. So this onStartCommand method comes within the active lifetime box. So after onStartCommand method gets executed, then the service runs indefinitely in the background, and always remember, the started service runs in the main thread. So never perform a long-running operation inside the main thread; either you should create a separate worker thread to perform any long-running task that we did using the AsyncTask class, or alternatively, you can simply use IntentService class and override the onHandleIntent method. So when the started service starts to run, then it is your responsibility to stop the service as well, and this can be done with the help of two methods, such as stopService or using stopSelf method. Now, stopService method can be used from inside the calling component, such as Activity, BroadcastReceiver, Service, or the ContentProvider. So any component that started the service can simply call stopService and pass intent as a parameter to stop the started service, or if you want, the started service to stop automatically, then simply call stopSelf method after the task has been executed inside the started service itself. So, calling these methods will simply call the onDestroy method that simply results in the destruction of the started service, and now, what are the possible operations that you can perform inside the onDestroy method? So when the service is no longer used and is getting destroyed, then this onDestroy method is triggered. So inside this method, you should free up the resources, such as threads, registered listeners, or the receivers, and make it available for other components to use it, because this is the last method inside the started service that gets executed and marks the destruction of the service. And now, coming to the bound service, what are the application components that have got the right to bind to a service? So these application components are the Activity, Service, and also the ContentProvider, and now, make a note, the BroadcastReceiver can never bind to a service, so it is only the Activity, Service, and the ContentProvider that can bind to a service. And now, in order to bind to a service, you have to simply use the method of bindService inside these application components. So calling this method will simply trigger the onCreate method that is present inside the service class, and now again, the onCreate method of the bound service behaves in similar fashion as compared to the onCreate method of started service, so this is again, the entry point of the bound service where you can simply set up everything, such as initialization of the field variables, and so on. So this marks the creation of the bound service, and after this, this simply triggers the onBind method, and now here in case of bound service, the active lifetime starts with onBind method, and inside the bound service, the onBind method simply returns the iBinder that simply points to a local binder object that we already saw in the module of Working with Bound Service. And now, in case of started service as well, we need to override this method of onBind, but in case of started service, we need to simply return null from inside the onBind method, but in case of bound service, we cannot return null. We need to return an interface that will allow the communication between the calling component and also our bound service. So here in case of bound service, the onBind method simply returns the interface that simply points to the local binder instanced, which will facilitate the communication flow between the calling component and also the bound service. And now, with the execution of onBind method, the client get bound to the service, and now there is a continuous flow of data between the calling component and also our bound service. And now, how to unbind a client from a bound service? So for that, we need to simply call the unbindService method from inside our calling component. So calling this method will simply trigger a method known as onUnBind method, and now soon after onUnBind method, this simply executes the last method of the service class, known as onDestroy method. So this marks the end of our bound service class, and now, if you compare the started service and also the bound service, you can notice the entire lifecycle exists between the onCreate method and also onDestroy method. The basic difference between the started service and bound service is that we start the started service by calling startService method, and we bind a client to a service with the help of bindService method. And during the active lifetime, in case of started service, onStartCommand method plays a key role, and in case of bound service, onBind method plays the key role. So this was just the comparison between the lifecycle methods of started service and also the bound service, just to make your concept more clear about the topic.

Lifecycle Summary
So let us now summarize the lifecycle methods that we saw in this module. So what were the common methods in both started and bound service? The first method that was the entry level method for both these services is actually onCreate method. So this onCreate method, it is similar to the onCreate method of the activity, where the service class initialized itself, such as, you can simply initialize your variables, and now, next comes the onDestroy method that was again a common method to both these service classes, and this onDestroy method is also similar to the onDestroy method of an activity class. So with the execution of this method, the service class stops and starts execution, and free up all the sources and memory, and now, again, it is your responsibility to try to free up memory and resources as much as possible, like unregistering any listeners, nullifying the field variables, and so on. And now, the entire lifetime of a service occurs between the time the onCreate is called, and the time the onDestroy method returns something. So in between the onCreate and onDestroy method comes the active lifetime of these service classes, such as the active lifetime of a service begins with either onStartCommand or onBind method, depending upon whether you are starting a service or binding to a service, and these methods actually receive an intent object either by using the method of startService or bindService, respectively, from the calling component. And now, how to stop a started service. It can be done by using stopService or stopSelf method that we have talked about it many a times while doing our demo application, and how to unbind a bound service from an application component. We can do it by unbindService method, and when this method is executed, onUnbind method is triggered inside the service class that simply says, now all the clients have unbound with the current bound service. So till this point, I have covered everything related to the started service and also the bound service. So I hope everything is now crystal clear in your mind. Thank you.

Enhancing App Security with Service
Taking Care of Application Security
Hi, this is Sriyank Siddhartha, and welcome to the next module of Android Services Fundamentals. In this module, we will check out how to take care of the application security if we are using Android services in our application. So, first of all, let's check out the most important attribute that plays a crucial role to make your service private to your own application. Now suppose this is your primary application that has the MainActivity and also it contains a service named as MyService. And now, you have some other application, let's say My Caller Application, that contains a MainActivity and also a method that will try to start our service from the caller application. Now, inside the MyPrimaryApplication, we have the manifest file within which we declare our service, and within the tag of service, we are going to use a new attribute known as android:exported equal to false. Now by default, this attribute, android:exported, has a false value. So even if you don't declare it, then also it will have a false value. This simply means your service is by default, private to your own application, so no outside application can access your service. And now, suppose from inside the caller application, within the MainActivity, if we try to define an intent to start the service, that is, to start our MyService, and now since we have android:exported equal to false inside the manifest file, so when this code is executed, then this MainActivity will not be able to access MyService present inside our My Primary Application. And now, as per the Android documentation, your service should always be private to your own application. So, you should never allow some other untrusted application to access your service, and suppose if you want to allow some other applications to access your service, then simply make this android:exported equal to true. But let me tell you one thing: this is not at all recommended as per the Google guidelines. So, when we make android:exported equal to true, then in that case it simply makes your application vulnerable to security threats. So in that case, you have to take care of your application security. So, how can you do that? Let's check out a few of the points. The service should be made accessible for the Android components present within the same application, so don't allow other applications to access your service unless required. And now, in case you allow some other application to access your service, then make sure the application to which you want to grant access should be your own trusted application, that is, it should be made by the same developer. And suppose this is your own caller application that you have made and you want to give access to this application to access your service. So in that case, make sure these two applications share a common user ID, and both the applications should be signed with the same certificate, but again, don't allow other applications to access your service unless required. And now, let us check out a few of the other points, such as when we start a service or bind to a service, either from inside the application or outside the application, then we simply pass an intent. Now, if you remember from our demo application, by defining the intent, we always used the explicit intent to start or bind to a service, or even to stop a service. Now, as per the Google documentation, always use explicit intent to start or bind to a service, never use implicit intent to access your service. Now starting from API 21 and above, that is, from Lollipop onwards, if you simply use implicit intent to bind to a service, then it will simply throw a security exception, and your application will probably crash. So, never ever use the implicit intent while starting or binding to a service, and now, maybe if you are watching this video after one or two years, then there may be a possibility that the start service has started throwing the exception if you use the implicit intent, but currently, we have only bindService that throws an exception if you use the implicit intent. And now, at the end, never use intent filter within the service tag present inside the manifest file. Now, the usage of intent filter is directly associated with the usage of implicit intent, so that is why using the intent filter is highly discouraged while defining the service inside the manifest file. So let's check out all these points in the demo application in the next video.

Enhancing Application Security While Using Service
So let us now proceed and check out how can we enhance the application security while using services in our application? So in the previous video, we explored few of the points, like using the Android exported attribute, implicit intent, explicit intent, and also regarding the intent filter declaration. So, this is the same application that we created in our previous modules. So simply select the project label hierarchy, and simply navigate to the manifest file of your application. So within the main folder, we have AndroidManifest. xml. So let's open it, and now, within the java, we have the main package, and we have all the services that we created in our previous modules. So, within the AndroidManifest. xml, we have the services declared here. So by default, the services that are declared here are actually accessible by the components present inside your own application. So by default, no other application can access your service. So, this simply means, by default, the android:exported attribute is basically false. So this simply ensures that MyBoundService is not totally protected from other untrusted application. So if you want, you can also declare it explicitly for other services as well. And now, our next point of discussion was always use explicit intent while starting, or stopping, or binding to a service. So here inside the Android Studio, what I'm talking about is within the MainActivity, if you notice here, I have simply defined the intent to start or stop a service. So here, if you notice, I am simply using the explicit intent, so the call to the service is totally explicit in nature, and now, what is the basic difference between the explicit call and the implicit call; I will give you a good reference from where you can get the detailed knowledge of the intents. So right now, always remember, whenever we start a service with the help of the class name directly, then this call is basically explicit call. So this intent becomes the explicit intent. Now here, if we refer to the started service class by some action name, like my. action. name, then this call will be actually the implicit call. So using the implicit intent is highly discouraged while starting or binding to a service. So always use explicit intent for the service. And now, our next point was to never use the intent filter within the service tag inside the manifest file. So here inside the Android studio, inside the AndroidManifest. xml, what this point simply means that you should never define the intent filter tag within the service tag, simply like intent filter and add some action name, like we can do for the activities and also for BroadcastReceiver. So defining the intent filter within the services is again, highly discouraged, so never do so. And now, there was one more point of discussion that if in certain case you want some other application to access your service, then that application should be your own trusted application, and that application should share the same user ID as that of this application, and both the applications should be signed with the same certificate. Now what does this actually mean? So this simply means inside the manifest file of both the application, you have to define a sharedUserId, and in the manifest file of both the applications, you have to define a string that has to be unique, let's say my. unique. id. string. So this string should be same in both the applications, but as for the Google guidelines, tampering with the user ID of your application is highly discouraged, so never, ever tamper your shared user ID, which is actually provided to your application by default by the Android system. So always avoid this step. Fine.

Summary and References
So finally we have reached the end of this module, and this was a very short module with few of the important points that will really help you while making your application with the help of services. So let us summarize our module. So never use intent filter tag within the service tag present in the manifest file. And now, always remember to use only explicit intent to start, stop, or bind to a service, because usage of implicit intent is highly discouraged, and from API 21, that is Lollipop onwards, using implicit intent with bindService simply throws an exception, and your application will simply crash. And now, services should be made accessible from the components within the same application. Now this is the recommended approach to use services in your application, and in the extreme case, if you want some other application to access your service, then make sure it should be your own trusted application, and the application should have the same shared user ID as that of your own application containing the service, and it should be signed with same certificate. Now, in this module, I did not talk about how to sign your application with the same certificate. So the certificate that I'm talking about is basically the key of your application that you use for your application security while uploading your application to the Play Store. So if you have ever uploaded your application to the Play Store, or you are going to upload your application to the Play Store, then you will come across this term of certificate, or the key of your application. So, you always need to create a key and sign your application AP key with it, and then only you can upload your application to the Play Store, and then any user from a smartphone can download your application. And now since this is a beginner course, so that is why I did not talk in detail about the shared user ID and also the certificate. At this moment, this much information is enough to proceed ahead. And now, let us check out the good references from where you can get the extra information regarding the implicit and explicit intent. So these two topics I have simply covered in the course of Android Fundamentals: Activities. So if you want, you can simply go through the initial modules of this course to get the details of these two topics. And now, regarding the intent filter, how to use it, and where to use it, again, I have used it in the course of Android Fundamentals: Activities, and also Android Fundamentals: BroadcastReceivers. Thank you.

Performing Inter-process Communication
Overview of Inter-process Communication i.e. IPC
So finally we have reached the end of this course. So let us conclude this course by checking out what is inter-process communication. Hi, this is Sriyank Siddhartha. So, first of all, what do we mean by inter-process communication? So for that, we have to first understand what actually happens when we open our application. So whenever we open our application, the Android system, by default, creates a process within which your application runs, and also provide the process with a unique name. So let us assume our process name is Process 1, and now, by default, all the Android components of your application, such as your MainActivity, or the Service, or the BroadcastReceiver, belongs to this default process, and now suppose this service belongs to this Process 1, so this MainActivity can easily access this service. So that is why I have named this service as a Local Service, and now suppose you create another service, and in this case, you want this service to operate in a different process. So for that, there is also an option that you create a separate process for this service, and how to create a separate process for your application, I will let you know, but at this point of time, this service is now running in a separate process, and this process name is also defined as Process 2. So, currently we have two processes, that is Process 1 and Process 2, that is associated with the same application. Now since this service belongs to a separate process, so for this MainActivity, this service will act as a Remote Service. So this is the difference between a Local Service and also a Remote Service, and now, in case you want to access this Remote Service from this MainActivity, then there is also a mechanism to access it, but if you notice, this communication between the MainActivity and the Remote Service is actually taking place between two processes. So that is why this mechanism of communication is known as inter-process communication, or you can say, in short, it means IPC. So what basically is IPC? That is, Inter-process Communication. Now this mechanism is basically the communication between two application components present inside two different processes, and just now we saw a live example that follows this definition, and now, for example, when an activity in Process 1 tries to access methods or the variables of a service present in another process too, then this mechanism is known as IPC. Fine. Now the question arises, how can we achieve this inter-process communication? So for this purpose, we can simply make use of the bound services, such as, the Messenger and also the AIDL. That is, Android Interface Definition Language. Now the term Messenger and AIDL are totally new in this course, so let's check out what is a messenger and what is a AIDL.

Messenger and AIDL ( Android Interface Definition Language )
So let us now proceed and check out what is Messenger and also AIDL. Now the Messenger and also the AIDL are basically the bound services, and the topic of bound services we have already covered in this course, and now, there are basically three kinds of bound services. That is, you can simply bind a service to an activity in three different ways. The first way is basically the Local Binder, and this Local Binder is actually used inside the same process. So the Bound Service that we saw in the module of Working with Bound Service was actually the Local Binder, that is, the communication between the activity and the service within the same process. And now, the second kind of bound service is actually the Messenger. Now, this Messenger is basically used for inter-process communication, that is, between two different processes, and this Messenger basically uses a single thread to execute, which I will again talk about it, shortly in detail, and now, the third way to implement the bound service is actually AIDL. So, this is also used for inter-process communication, and this AIDL is basically has a multi-threaded design and can handle multiple requests at a time simultaneously, which again, I will talk about it shortly. So the topic of Local Binder, we have already covered, and this topic of Messenger, we are going to cover in this module, and this topic of AIDL is highly not recommended as per the Google guidelines. So that is why I have decided not to cover this topic of AIDL in detail, just because using AIDL for inter- process communication can simply drag your application towards instability, fine. So as per the Google documentation, you should avoid using AIDL in your application. So, instead of AIDL, you should always use the Messenger as an option. So in this module, we will check out how to use the bound service using Messenger.

Local Binder Cannot Be Used for IPC
So here in this video, first, we will check out why can't we use our Local Binder for performing IPC. So let's proceed and check out our demo application on this concept, and find out the reason why can't we use the Local Binder for inter-process communication. So here inside the Android Studio, this is the same application that we created in our previous modules. So, let us navigate to AndroidManifest. xml. Now as we all know, by default, all the Android components that we have inside our application are present inside the same process, and by default, utilize the main thread. So here as well, all these services are actually the part of the default application process. So here, firstly, let me remove the android:exported attribute, because by default it is false only. Now this is our MyBoundService where we actually implemented our Local Binder in the module of Working with Bound Service. So this service as well is present in our default application process. So suppose you want your service to run inside some other process, then how should you do it? How can we make our service run inside the separate process? So for that purpose, we have an attribute known as process, and the syntax to define a separate process for your Android component is that colon, followed by the process name, let's say my_own_process. So this is the name of the process in which our MyBoundService will run. So this is our MyBoundService, and this is our SecondActivity. java that will simply try to bind to the service, and now as for the current Android manifest declaration of the service, we have this bound service, which will run in a separate process. So, this SecondActivity will try to communicate with the service present in some other process. So in this situation, we can see we have the inter-process communication scenario, and inside the MyBoundService, we are using the Local Binder. So let's check out if we are able to perform IPC or not. So here our application is now up and running, so let us now click on BOUND SERVICE DEMO ACTIVITY, and now, here our application has crashed. So let's check out the log cad for the reason. So here inside the log cad, you can see it has simply thrown a BinderProxy exception. So this exception is usually thrown when we are trying to perform the inter-process communication with the help of the Local Binder, which is not allowed. So you cannot use a Local Binder to communicate with the service that is actually present inside some other process. Fine, so let us simply remove it. So that is why in the next video, we are going to check out how we can use Messenger for the IPC.

Initial Project Setup
So let us now proceed and check out our initial project setup inside the Android Studio. So here inside the Android Studio, what we can do, first, inside the resource directory, we are going to create a separate activity layout, and name it as activity_messenger, and now, I will simply pause the video, and simply going to modify our layout. So here, I have simply modified my layout. So here, what do we have? We have two EditText at the top to get the user input, and this is the result, TextView, and this is the add button. So as compared to the layout of the bound service, here, we are simply going to perform an add operation on two numbers, instead of all the operation, and here, down the side, I have two buttons, bind the service and unbind the service. So in our current example of Messenger, we are simply going to bind and unbind from the service manually. So let us check out the code. So this is the EditText at the top, this is another EditText, and then, we have an add button, on click of which, performAddOperation will be executed, and now, we have another button known as bind service, and down the side, we have another button of unbind from the service, and at last, we have a TextView that will help us to display the result. Fine, and now, corresponding to this xml layout, let us create our Activity class, and name it as MyMessengerActivity. And now, let us put some code inside our activity class, and now, let us create the onClick handling methods that will be executed on click of respective buttons. So here, let us first create performAddOperation method, Alt+Enter, simply created inside our Activity class, and similarly, let us create bindService, Alt+Enter, and then at last, let us create unbindService, and our next step will be to initialize our EditText and also the TextView inside our Activity class. So here, let us initialize our TextView, and also, let us initialize our EditText as well, and now, let us extract the values that user will enter inside these two EditText. So, let us extract the two integer values, and now, let us create a service connection that will help us to establish a connection between the activity and also the service. So for that, let us use private ServiceConnection, space, mConnection equal to new ServiceConnection, and override these two methods. Fine, and now, similar to the bound service that we saw here, let us create a boolean variable of mIsBound, that will help us to know if the connection between the activity and the service has been established or not. Now these steps are similar to what we saw in case of MyBoundService, so please don't get confused. So inside onServiceConnected method, simply make isBound to true, and now here, let's make it to false, and now our next step will be to create our service class and name it as MyMessengerService, and this class will simply extend from the Service class. So let us override the onBind method here, that is a mandatory method that we need to override inside each of the service class, and now, let us create a method that will be exposed to MyMessengerActivity when the connection between these two will be established. So here, let us create public. addNumbers int a and int b as a parameter, and simply return a + b as a value, and now here, inside the ActivityMain. xml, what we can do, we can simply put a button just above this button at the bottom, so that on click of this button, we can simply navigate to our MyMessengerActivity. Fine, so here, let us create our button. So here, I have simply created a button, and placed it just above this bound service demo activity, and now, make sure on click of this button, this method, moveToMessengerActivity, will be executed, and also make sure I have simply provided this button with the ID, so that this button will be placed simply above this button, bound service. So let us create moveToMessengerActivity, inside our MainActivity. java, and now, on click of this button, we need to navigate to our MessengerActivity, so let us define our explicit intent, and also, let us come to our AndroidManifest. xml, and let us declare our activity and also the service. And also, let us declare our service, such as MyMessengerService, and here, I will simply define a process so that we can perform the inter-process communication and name our process name as my_own_process, and now, our next step will be inside the main package. So here, inside the package, there are too many files present, so let's clean it up by separating them inside their own packages. So let us create two packages, and let's name it as activities, and the second package, let's name it as services, so that our code will now look more cleaner. So let us select all the activity files, and drag and drop it inside the activities package, and simply refactor it, and now, let us also place all these services inside the services package, let us drag and drop it. So here inside the SecondActivity, we have some error, we need to modify the access specifier of this method of getService, so let's open it, and let's make it public. So this rectifies our error. Also, let us rename the SecondActivity to MyBoundService activity, Refactor, Rename, and let's rename it to MyBoundActivity. So this process of refactoring is also very crucial while making any application. So always try to make your code more and more cleaner. So this was all about the initial project setup inside the Android Studio.

Using Messenger for Inter-process Communication
And now, let us all proceed and implement our Messenger inside the Android Studio, inside our application for performing inter-process communication. So here, inside the AndroidManifest. xml, you have to first make sure that your MyMessengerService is actually present inside a separate process, so that we can perform the inter-process communication, and now, let us navigate to MyMessengerService. java. So here, we need to write a bunch of code, and now as we all know, the Messenger service is basically a bound service. So, inside the bound service, the onBind method should never return null, it should always return the binder object. Fine, that simply implements the interface of iBinder. So for that, here, what we have to do, we have to simply create a Messenger. So let's create a Messenger, new Messenger, and this simply takes the parameter of handler. Now what this handler stands for, I will let you know, but before that, here, from inside the onBind method, we need to return Messenger. getBinder. So here, we get the instance of the binder that will help us to bridge the communication gap between the activity and also the service, and now here, as a parameter, it simply expects a handler object. So now, what we can do, let us create our handler, and let's name the class as IncomingHandler, that simply extends from the Handler class, and now, let us override handleMessage method, and within which, we will use the switch case statement: msg. what. What is it all about? What operation we need to perform inside the service class will be determined with the help of this what, and this what simply returns the int constant, and now here, inside the constructor of Messenger, let us pass the instance of new IncomingHandler, and now the question arises, why do we need to use a handler here? So for that purpose, we need to again recall this slide. Now, if you remember from our previous module, the handler is something that handles a message. Maybe the message is coming from some other thread. In this video, we are simply going to pass the data from the MainActivity to this Remote Service. That is our Messenger service. Now here, we have Process 1, and here we have Process 2. So, each process has a default thread associated with it. Let's say Thread 1 and Thread 2. So we are simply passing the message from Thread 1 to Thread 2, so that is why we need to use a handler that will simply handle the incoming message coming from some other thread or process. So I hope now you know why we are using handler here. So this handler will simply receive the message coming from the MessengerActivity that is present in some other process, and now, let us come to MyMessengerActivity. So here, inside this class, within the bind and unbindService, let us complete our code. So let's define our Intent, space, intent equal to new Intent, MyMessengerService. class, and then, simply bind to the service. Simply pass intent as a first parameter, and second parameter will be the service connection that we already know about it, and the third parameter will be BIND_AUTO_CREATE, and now here I have done a typo mistake, the spelling of connection. So let us press Ctrl+T, and simply rename it to, let's say, Connection. So this simply resolves our mistake that we have done here, and now, let us unbind from the service. So first, we need to check if our service is actually bound or not. If it is bound, then only unbind from the service by simply calling unbindService, and simply pass ServiceConnection as a parameter, and let us make mIsBound equal to false, and now here, when this method will be executed, this MyMessengerService will simply return the binder object from this onBind method, that we will simply receive by onServiceConnected method that is here. So here, what I will do, I will simply create the instance of the messenger, and let's name it as mService, let's initialize it to null, and here, let us get mService equal to service, and now, from the service instance, we can simply get the reference to our Messenger that is actually present here. Fine, so with the help of this binder, we are able to get the reference of this Messenger inside the Messenger activity here. So once you get the reference here, so with the help of this reference, what you can do, you can simply send the message to the remote process. So here, let us define our bundle object, and simply insert these two integer values inside the bundle, and now, in order to send data from this activity to the service, we need to define our message object. So this method, obtain, is a static method that will simply return the instance of the message object, and it takes two parameters. The first is the handler, and second is the constant value that I will talk about it shortly. You can give it any constant value, such as 49, 94, and something like that. So here, as of now, I will simply give it 43, and now, let us rename this variable to msgToService, that is, this message we are simply sending to the service, and then, simply put this bundle object inside this message. So, msgToService. setData, and simply pass bundle as an object; and finally, what we can do, we can simply use the instance of the service class to send a message to the service, so mService. send, and simply pass msgToService as a parameter. And here, you have to surround it by try/catch, so simply press Alt+Enter, and surround with try/catch, and now, this method will simply trigger the handler that is present here. So that is why I have written the switch case statement, and now here, I will simply write case 43, that is our constant, and then break, and also define the default for this switch case statement, and cut the super call from here, and paste it here. So here, we get an incoming message from the activity. So with the help of this message, let us retrieve our bundle object. Bundle, space, bundle, equal to msg. getData, and then, let us extract int numOne and numTwo, and also give it a default value, and then, let us call this method to perform some operation, such as addition. So here, I will simply call addNumbers and pass numOne and numTwo as a parameter, and store it within the int result variable, and now, let us display our toast message: Toast. makeText, so, we are now done with the code. So let us now run our application, and let's see if everything is working fine. So here, our application is now up and running, so let us open our Messenger Activity, and now here, let us bind to the service, and now, let us click on ADD button. So here, the result is 0, 0+0 is 0, and now, let us make it 2, and let's make it 10, and let us add these two numbers, so here we go, the result is 12, so our application is now working perfectly fine, and now, let us unbind from the service, and close the activity. So let me now explain you what actually I have done in this demo application. So here, this is our MessengerActivity, and this is our Remote Service that is actually running in its own process. So, from the MessengerActivity, I have simply called the bindService method. So as you all know, when this method is executed, onBind method is called inside MyMessengerService class, that is, this method will be executed, and now, this method simply returns the instance of the binder object that we are retrieving from the Messenger. So this binder object will actually be received inside onServiceConnected method, that is here. So with the help of this object, we are now getting back the reference to our Messenger, that is, this Messenger. Fine, and now, once you get the reference to the Messenger, then you can perform any task, but since the Messenger service is actually running in a separate process, so, you cannot send the message directly. So for that purpose, you have to define a handler here, that will simply handle the incoming message from a different process, or the thread. So here, inside the Activity class, inside the performAddOperation method, I am simply using a special class of Message. And now, using the bundle object, I will simply insert my two values using the key value pair, and then put the bundle inside the message object with the help of this statement, and finally, with the help of the reference of the Messenger, we are simply sending the data to our service class with the help of this statement. So this message will be received inside our handler here. So now, with the help of this constant what, which simply contains the value of 43, now this 43 is exactly same as this 43 present here. If you define here 9, then please make sure this is also 9, and here, with the help of these two keys, numOne and numTwo, that is actually present here as well, we are retrieving back the value from the bundle object, and then here, we have simply performed the add operation on two numbers, and simply displayed our toast message, hey, the result is 12 or something like that. Fine, so this is how we perform the inter-process communication with the help of a Messenger.

Returning Data Back via IPC
So in the previous video, we saw how we can use Messenger for the inter-process communication, from Activity to the Service class, and now, how do we return data back to the Activity from the Messenger service? What exactly I am talking about is in the last video, we saw we send the data from the MainActivity to the Remote Service present in some other process, and now, suppose we want to return back the data from the Remote Service back to the MainActivity, then how can we do it? So for that, we have to perform the reverse IPC, which is again, basically the inter-process communication, and now in the previous video, we saw in order to receive the message from the MainActivity, we have to create a handler inside the Remote Service, and also, a Messenger. So similarly with the case in case of MainActivity as well in this demo video. So in order to get the data back from the Service to the MainActivity, we have to create a messenger, and also the IncomingHandler within the MainActivity as well, so that this handler can now receive a message coming from some other process, or you can say, some other thread. So let us now come back to our Android Studio, and let us perform the IPC, but this time, we will send the result back to the MainActivity. So for that purpose, we now need to create a Messenger, and also a handler inside the Activity class. Fine, so the things are very simple here as well. So what we need to do, we need to simply create private Messenger, and let's name it as incomingMessenger equal to new Messenger, and now again, we need to create our target handler. So for this, I will simply create a new class, and name it as private class of IncomingResponseHandler that simply extends the Handler class, and now, let us override the handle message method, and now let us write a switch case statement, similar to what we did in case of service class, msg. what, and then simply pass the instance of new IncomingResponseHandler within the Messenger constructor. Here it is showing some error; by mistake, instead of Messenger, I've simply written the message as a reference, so simply change it to Messenger. And now next, by sending the data to the Messenger service, we need to define a reply to Messenger, so for that, we need to type msgToService. replyTo. Now this replyTo will simply expect a Messenger reference, so here, let us pass incomingMessenger as a value. So this msgToService will contain the incoming Messenger reference. So inside MyMessengerService, within the handler, what we can do, we can simply get the reference to the incoming Messenger, that is Messenger, space, incomingMessenger equal to msg. replyTo. So with the help of this replyTo, we are getting back this incomingMessenger here inside the handler of the Service class. So once you get the reference to the incomingMessenger of the Messenger Activity, then you can use it as per your wish. And now, let us create a new bundle, bundleToActivity, because we will send this bundle to the Activity class equal to new Bundle, and then, simply insert this value of result inside this bundle object,. putInt, simply give the key as result, and value as result variable. And now, let us define a message, and this message will be sent to our Activity class; msgToActivity equal to Message. Obtain, pass the handler as null, and then give a constant value of, let's say, 87, and now again, you can give a constant value as per your wish, and our next step will be to put this bundle object inside this message object. So here, let's type msgToActivity. setData, and pass bundleToActivity as a parameter, and our final step will be to use this incomingMessenger to send this Message object back to the Activity. So here, let's type incomingMessenger. send the message, and then simply surround it by try/catch. So, the code snippet here will be to send data back to the Activity. Fine, and our next step will be inside our Activity class. So here, inside our handler, let us complete the code again. So let us define our case, let's say 87. Now this 87 should match with this 87. Fine, again, a constant value, and then let us retrieve this result with the help of this key inside the Activity class. Let us get the bundle object from this incoming message: Bundle, space, bundle equal to, and let us rename this message to msgFromService, so as to avoid any confusion because our code is now a little complicated or bulky, msgFromService. getData to retrieve the bundle and then retrieve the data, such as int result, give the key, and also the default value if you wish to. And now here, let us rectify our error, msgFromService, and here again, msgFromService, and now, finally display the result with the help of this TextView. So here, txvResult. setText, let us put the default statement inside the switch case; so this completes our code. So let us now run our application and let's see if everythign is working fine. So let us now move to Messenger Activity. So here, let us bind to the service, and then let us edit the data, let us give the user input, and now, simply add the number, so here we go, we have got the result back to the MainActivity from the service, result is 90, that is addition of these two numbers. And now simply unbind the service, and get out of the Activity, as we are done with our class. So here, what exactly we have done in this demo video. So in our to receive the incoming message from the service, we have defined the IncomingResponseHandler class, that is simply associated with this Messenger, and this Messenger, I'm sending it along with the message to MyMessengerService with the help of this statement: msgToService, replyTo, equal to incomingMessenger. So when we send this message, with the help of this statement, this message will be received inside the handler present inside the MyMessengerService class. So here, I have simply retrieved my incomingMessenger, and with the help of this incomingMessenger, I'm simply sending the data back to the MainActivity in the form of message object, and this will be again received inside our handler class that we have defined here, and then, we are simply displaying the data with the help of our TextView. So this is how we perform the two-way inter-process communication: send the data, and then receive back the data. So I hope now you know how a Messenger service works to perform inter- process communication, and also, I will put all the comment lines, so that next time you open this application, then this application will act as a good reference for your intent service, bound service, messenger service, and also the started service. So make sure you download this demo application and refer it whenever you are making your application with the help of services. Thank you.

Messenger vs. AIDL: Which One to Choose?
So let us now proceed and check out the differences between the Messenger and also the AIDL. Why should we use Messenger instead of AIDL for inter-process communication? So the Messenger is very simplest way to perform the inter-process communication, as compared to AIDL, that is very complicated to implement and should be avoided. And now, on the left-hand side, in case of Messenger, the Messenger uses a single thread of execution and accepts one request at a time, that is, it can perform one task at a time. So it does not perform multiple tasks simultaneously, but in case of AIDL, it is actually multi-threaded, and can accept multiple requests simultaneously at a time. So this may result in the stability issues of your application. So since the Messenger is basically single- threaded, so it is actually thread safe, so you don't have to worry much about its design implementation. The Messenger internally takes care of the task execution that is one at a time. Now in case of AIDL, which is actually multi-threaded, so you have to make your application thread safe manually, because AIDL does not internally take care of this thing. So whenever we use AIDL in our application, we have to make it thread safe ourselves. So looking at all the points, the Messenger is the most preferred option for inter-process communication, and you should always avoid using AIDL as an option as it may result into the unstable application. So it will simply affect your application performance. So this was all about Messenger versus AIDL. Now, let us proceed and check out when should we use a Messenger and when should we use AIDL? So the first point of the application is during inter-process communication, which we are already aware of, and now, on the left-hand side, you should use Messenger to handle one request at a time as it is single-threaded. And now, if you want to perform multiple requests at a time, that is, you want your service to perform multiple requests at one time, then only you should go for AIDL, but as per my experience, you won't get any requirement to use AIDL in your application, so don't think of this as an option, always use Messenger whenever you want to perform IPC.

Summary
So finally we have reached the end of this module. So let us summarize this module by concluding the fact for Local Binding, you should simply use a Local Binder, that we have already implemented in our demo application in the module of Working with Bound Service. And, to perform inter-process communication that is accessing the service of some other process from another process, we should use Messenger, which should always be preferred, and usage of AIDL for inter-process communication is highly discouraged. So that is why I did not show you how to use AIDL in your application.

What Next?
So here we have reached the end of this course. So what are the courses that you should go for after taking this course? Since service is an Android component, so you should go for the courses related to the Android components, such as Activity, BroadcastReceiver, and also the ContentProvider, and now, I have already published the courses related to the Activity and also the BroadcastReceiver, so make sure you go through these two courses, and also, please search for the courses related to ContentProvider as well. This is Sriyank Siddhartha, signing off, and happy coding. Thank you.

Course author
Author: Sriyank Siddhartha	
Sriyank Siddhartha
Sriyank began his career with a Bachelor of Technology in Computer Science from India. After working 2 years in Java, he found a great interest in Mobile Application Development. Sriyank works with...

Course info
Level
Beginner
Rating
4.7 stars with 50 raters(50)
My rating
null stars

Duration
3h 14m
Released
3 Feb 2017
Share course

