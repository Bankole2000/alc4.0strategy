Creating Your First Android App with Android Studio and Firebase
by Simone Alessandria

When you create Android apps, you often need to deal with server-side technologies. This course will teach you how to use Firebase within your app so that you can build great full-stack apps quickly and follow best practices.

At the core of creating full-stack apps with Android Studio is a thorough knowledge of server-side technologies. In this course, Creating Your First Android App with Android Studio and Firebase, you will learn how to use Firebase in your Android apps. First, you will learn how to use the Firebase Realtime Database. Next, you will explore authentication and authorization with Firebase. Finally, you will discover how to use Firebase Storage in your Android apps. When you are finished with this course, you will have a foundational knowledge of Firebase in the context of Android programming that will help you as you move forward to creating full-stack apps with Android Studio.

Course author
Author: Simone Alessandria	
Simone Alessandria
Simone Alessandria wrote his first program when he was 12: it was a text based fantasy game for Commodore 64. A few years later, he is now a trainer (MCP), author, speaker, passionate software...

Course info
Level
Beginner
Rating
4.7 stars with 19 raters(19)
My rating
null stars

Duration
2h 15m
Released
20 Apr 2018
Share course

Course Overview
Course Overview
Hi everyone. My name is Simone Alessandria, and welcome to my course, Creating Your First Android App with Android Studio and Firebase. I'm an author, trainer, and proud coder at softwarehouse. it in Italy. Firebase is a great tool for any Android programmer. When you combine the power of Android Studio and Firebase, you'll be able to build apps that have both a client side and a server side really fast. In this course, we're going to share data, files, and deal with authentication and authorization with Firebase, building a full stack app from scratch. Some of the major topics that we will cover include using the Firebase Realtime Database in your Android app, managing authentication with email and password and Google, sharing files with Firebase Storage, understanding database and storage security rules. By the end of this course, you'll know how to use Firebase in your Android apps. Before beginning the course, you should be familiar with Android Studio. I hope you'll join me on this journey to learn Firebase for Android, with the course, Creating Your First Android App with Android Studio and Firebase, at Pluralsight.

Getting Started
Getting Started
Hello. This is Simone Alessandria. Welcome to the course, Creating Your First Android App with Android Studio and Firebase. Creating an app involves so many steps. Client side, you need to design the user interface and create the features you want to give to your users. But except for the simplest apps, you also need solid server-side code, a shared database, or dealing with authentication. Maybe you want to save files into a web space and secure them and you want to be able to scale when your app is successful. As you certainly know, all this is a lot of infrastructure, a lot of code, and a lot of time. Of course, there's no magic formula that's perfect for everything single app in the world, but I hope I'll be able to show you that Firebase can really help you build great apps in a fraction of the time you would need if you had to write your server-side code from scratch. And in the couple of hours we have together, I'll show you all the features I've mentioned before. You will use a database, make your users authenticate, upload and download files from a shared cloud storage, and what's more, you'll also secure files and data server side, giving your administrators writing privileges, while the other users will be able to read data after authenticating, and meanwhile, you'll build an Android application from scratch. No copy and paste. No starting project. We'll write every single line of code together in these two hours. That's our challenge.

The Travelmantics App
First, let me show you the app we'll be building together throughout the course. Our customer is Globomantics Travel that needs to create an app so that its customers can get information about travel deals in real time. The first time you open the Travelmantics app, you are presented with a log-in screen. For the login, you'll have two options, insert a username and password, or use a Google account. After the login, two things may happen. If you are a customer, you'll see the list of travel deals currently available, and if you click on one of the deals, you'll see the details of the deal you have selected with a bigger image, but if you are a Globomantics administrator, you'll also be able to create new travel deals, insert pictures, or edit and delete existing travel deals. All data and pictures will be stored remotely within Firebase Realtime Database and Firebase Storage, and authentication will also happen on the cloud. The user interface, the connection to Firebase services and interaction with users, will happen from the app. Let's see how we are going to approach this project. In this module, we'll have a look at the Firebase console and create our project there. In the next module we'll see how to write data to the Firebase Realtime Database. Then we'll see how to read from the database, show data to our users, edit and delete items in the database. In the following module, we'll deal with managing authentication with Firebase, and the last module is all about Firebase Storage and its security rules. Before we start building our project, let's see a few prerequisites so you can decide whether this is the right course for you right now. This course is for developers with some exposure to Java and Android. This shouldn't be the very first app you build with Android Studio. It may be the second. If you have never used Android Studio before, I recommend you watch the course, Understanding Android Application Basics, here on Pluralsight before following the this course. No prior knowledge of Firebase is required. If you have used it, it's okay, you'll probably find something useful for you during this course as well. You should have the latest version of Android Studio already installed on your PC or Mac before getting to the next module. Firebase is free for basic usage, so for this app, you won't need any credit card. All you need is a Google account. In the unlikely event you don't have one, you can get one for free at the address below. For all the demos, I'll be using an emulator. If you want to use a physical device, everything will work as well. At the end of this course, you'll be able to use Firebase Realtime Database authentication and storage in your Android apps, and I hope you'll find these to be invaluable tools to add to your developer skills. We'll be writing all the code from scratch, as I believe this is the best way to learn programming, but in the exercise files, you'll find the code of the app as it is at the end of each module, so you can jump in, or get the working code any time during the course. Okay, I think we are all set. Let's jump in and create our Firebase project next.

Creating the Firebase Project
In order to create a Firebase project, you'll need to have a Google account. Our home for Firebase is console. firebase. google. com. It's from here that we'll create and manage our project. So, let's create our project. Let's click on the Add project button. We'll call this project Travelmantics. Under that, choose your region, and then click on the CREATE PROJECT button. After a few seconds, our project will be ready. Now this is the overview of our project. If we expand the menu, under the DEVELOP section, we can see some of the features we'll be using. Database is the first tool we'll use in our app. Note that there are two flavors of database within Firebase. The Realtime Database and the Cloud Firestore, which is in beta at the time of this recording. Both are NoSQL databases. For this course, we'll be using the Realtime Database. We'll use Authentication to sign in our users. Then we'll be able to choose between two providers, email and password within our app, or a Google account. Storage is the service that our app will use to save and retrieve files. Our travel deals will have an image, and this is the place where we'll store our files. Okay, I guess we are ready to go. Let's begin this journey together, starting with the Firebase Realtime Database.

Writing to a Firebase Database
Introduction to the Realtime Database
Hello. This is Simone Alessandria. Welcome to this module of the course, Creating Your First App with Android Studio and Firebase. In this module, you'll get an introduction to the Firebase Realtime Database in the context of developing Android apps. First we'll see some features of the Firebase Realtime Database. It's a NoSQL, or No S-Q-L, database, and you'll see what this means for you when designing an app. Firebase uses JSON to serve data, so we'll see some of the JSON features in the context of the Realtime Database. Next, we'll take a glimpse of the Firebase Database rules and change them for our project. This is a necessary step as we won't be using authentication at first. The setup of our app will involve a few steps, but the process is pretty straightforward. Finally for our demo, we create our app and make it write to the Firebase Realtime Database. At the end of this module, our app will contain an activity to write data to the database and the related classes. Both the Firebase Realtime Database and the new cloud Firestore are NoSQL databases. What does that mean for us? Well, several things actually. In case you have only developed apps with relational databases until now, let's quickly have a look at some of the differences between the two approaches. First, relational databases have schemas. That means that before you can insert the first record into a relational database, you generally have, at the very least, to decide the table name and for each field, the name, type, and size. This is not so in the Firebase Realtime Database. You just write some key-value pairs into a specific address, and that's it, and the next object could be completely different. This approach is easier to implement, but it's up to the developer, that is you, double-checking the consistency of data. SQL databases are normalized. That means that you tend to avoid data repetitions whenever possible, and you create several related tables in order to achieve this. In a NoSQL database, data repetitions are okay because the speed of reading and writing data is the key point. That also means that there are no joins in a NoSQL database. In a relational database, you generally use the SQL language to read and write data. In the Firebase Realtime Database you use JSON and paths to achieve the same result. In other words, NoSQL is generally better suited when you don't need a database to implement data consistency on its own. JSON is a text-based format made of key-value pairs, and today most web services, and Firebase itself, use it to store and serve data. Here you can see an example of JSON. Each attribute, or key, is enclosed in quotes because it is a string. The firstName value, Paul, is also a string, and strings are enclosed in quotes. The colon character separates the key from its value. Booleans and numbers are not enclosed in quotes. Objects are unordered collections of key-value pairs. Objects are delineated with curly brackets and use commas to separate pairs, while within each pair the colon character separates the key, or name, from its value. The Firebase Realtime Database allows nesting data up to 32 levels deep, but in practice, it's best to keep your data structure as flat as possible to avoid retrieving unnecessary data and to avoid an overly-complicated structure. With the Firebase Realtime Database, we'll use objects extensively. Arrays are ordered lists of 0 or more values, each of which may be of any type. Arrays use a square bracket notation with elements being comma separated. Although you can use arrays in Firebase, it is not recommended, and they actually get stored as objects.

Setting up Firebase into Your App
Let's get to our project in Firebase and see how to insert data into the Firebase Realtime Database. So, we'll select Database from the left menu, and then click on the Realtime Database GET STARTED button. Here we'll click on the plus button of the object that was created. Let's begin with a simple string. We'll write Title as Name and Matrix as Value, and click ADD. So, this is simply how you create a new object into the Firebase Realtime Database. Now, let's see what happens if we nest elements. I create a new object and put Films as Name, then we'll click on the plus button over there and insert a couple of titles. Matrix and Blade Runner will do. Now the link that you can see at the top refers to the main object. If we click on one of the objects we have created, the address changes. This is how we can reach data on the Firebase Database through paths. We'll see how it works from an Android app later during the course. Among the actions we can perform here is the Export JSON function. Let's try it out. From the menu on the top right, let's select Export JSON. This will trigger a download. Let's open up the file, and you can see that we obtained a standard JSON file as we described earlier. You can also do the opposite. From a JSON file you can import data into Firebase, but from now on, we won't be writing data from here, but only from our app. And before doing that, we need to set up our app, and that's what we are doing next. First, let's create a new project with Android Studio. We'll call it Travelmantics, and we'll leave example. com as the Company domain, then let's click Next and accept the default values for the form factors. Let's click Next again, and from the following screen, let's add an Empty Activity into our project, and click Next. The name of the activity will be InsertActivity because from there we'll insert data to our Firebase Realtime Database, and this will be the first activity that we'll develop. Let's click Finish to create the project. Now, the first thing we need to do is get a debug signing certificate. This is required in order to implement Google sign in for authentication in our app. This is something we'll do in the next modules, but it's better to set up the application right from the start. Firebase will require a hash representation for the debug key store, and we'll need to use the keytool command line tool in order to get it. To put it simply, the debug keystore is a group of hashed characters that you obtain with the keytool command. Please note that these characters identify your computer, so you should keep them secret. So, let's open the terminal from Android Studio and move to your JDK folder. Then, let's type the command that you see below. When asked for a password, just type android, all lowercase. After a few seconds, some numbers and letters should appear in the terminal. What we need is the S-H-A-1, SHA1, string, which we will now copy. From our Firebase project, let's click on the Add Firebase to your Android app button. We'll write down our package name in the first textbox, and then we'll paste the string we have just copied in the Debug signing certificate textbox. Now let's click on the REGISTER APP button, and download the google-services. json file. We need to copy this file into the app folder of our project. So let's get back to Android Studio, and in the project window let's switch to the Project view. Then we can just drag the file we have downloaded into the app folder and click OK when prompted. Back to our browser, let's follow the instructions for the last part of the setup. We now need to update the Gradle files of the project. So let's copy the first line of code that will update the project Gradle file. Back to Android Studio, let's switch back to the Android view, open the project Gradle file, and paste the code within the dependencies object. From the browser, let's also copy the app Gradle update, and back to Android Studio, open the app Gradle file, and paste the code at the end of the file. Now, let's sync our project. There's just one last step to complete the setup of our app. As we have seen, Firebase contains several services. We need to specify the dependencies of the service, or services, we want to use in the Gradle file in the dependencies section. At the address below, you can find the dependencies for each Firebase service. Please make sure you check this link when you create a new project, as this is the only way you can make sure you are using the latest version of the files. Right, at the beginning, we'll only be using the Realtime Database, so the only dependency we need is this one. Let's copy it, and then in the dependencies section of our Gradle file, let's paste it and include it in a compile statement. Okay, our setup is now complete. Let's make sure everything is fine so we'll run the app. And after a while, a welcoming Hello World appears. If something went wrong in your app and you received a could not find error, make sure you have the latest Google repository in the Android SDK Manager. Just follow this link for detailed instructions. Okay, once everything is working, we are ready to build the activity that will write data to the Realtime Database. Let's do that.

Creating the Insert Activity Layout
Let's get to the activity_insert layout file and delete the Hello World EditText. Then, switching to design mode, let's drag a Plain Text EditText from the toolbox, and drag it to the activity. As this is a constrained layout, we'll add three constraints to the top, left, and right of the activity. This EditText will contain the title of the travel deal in our app. We'll repeat the process with a second EditText that will contain the price. The top constraint will be to the first EditText. Then let's add a third EditText for the description of the deal with the same procedure. And the top constraint will be to the second EditText. Let's give this EditText an ID. The first one we'll call txtTitle, and when prompted, we'll click Yes to update the references. The second one we'll call txtPrice, and the last one txtDescription. Let's switch to the Text view. We want the controls to be as wide as the activity, so let's give each of them a width of match_parent, then let's specify a margin. We want the default margin to be 16dp. And we could specify that for each control, but it's better to specify this value only once. So let's extract the dimension, and call it text_margin_standard and click OK. We also want a bigger margin only for the top of the first EditText. So let's extract this one as well and call it text_margin_large, then let's paste the text_margin_standard dimension for the remaining margins of the textboxes. We'll do it for the Price, End, Start, and Top, and for the Description, End, Start, and Top. Now, back to the txtTitle, let's remove the inputType, text, and ems. We'll do the same for the price and the description EditText. Now let's add a hint for the txtTitle. We want the user to see Deal Title when the EditText is empty. So let's write it for the hint value, and then let's extract the value and call it title_hint. Now for the price EditText, we'll change the input type to be numberDecimal so that it will only take numbers. Let's also set the hint to Price numbers only, and then extract the string resource and name it price_hint. Let's move to the description EditText. Here the hint will be description, and the string resource, description_hint. Not very original I guess, but well, let's check how our layout looks and try the textboxes. This is probably not the fanciest app you have ever seen, but it's okay for now. You might notice that there is no way to save our deal. In order to do that, we create a menu. So back to Android Studio, let's select the res folder, right-click, and under the New menu, click on Android resource file. The Resource type will be a Menu, and as File name, we'll write save_menu. Let's click OK. Now under the Menu folder, we have a save_menu file. Let's open it, and in the Text view, we'll add a new item with an id of save_menu, and a title of save. The showAsAction app property will be always, so that the user will be able to see the save title without the need to expand a menu. Let's also extract the string resource for the title and call it save_menu. In order to see our saved menu, we need to go to the InsertActivity class and override the onCreateOptionsMenu. Let's delete the call to the super class and create an instance of the MenuInflater object, which is the object that can create menus from XML menu resources. We call it inflate method and specify the R. menu. save_menu resource as the XML resource we want to inflate. Let's return true, and try out the app. And the save menu appears as expected. Of course the menu does nothing right now, so what we are doing next is saving our deal to the Firebase Realtime Database when the user clicks on the Save button.

Writing to the Realtime Database
In order to write to our Firebase Realtime Database through the app, we need a couple of objects. The first one is a FirebaseDatabase instance. This is the entry point for the database. Then we need a FirebaseReference. This is the location in your database where you'll read or write data. So after creating the variables, we call the getInstance static method of the FirebaseDatabase class to create an instance of the database, and from it, we get a reference and call the child method, passing the path we want to reach. So in this case, we'll create a traveldeals path for all the deals of our app. Let's see that in action. Back to Android Studio, first we'll create two variables, one that will contain the FirebaseDatabase object, and we'll call it mFirebaseDatabase, and the second, DatabaseReference, that we'll call mDatabaseReference. In the onCreate method, let's call the getInstance method to create an instance of the FirebaseDatabase. Then let's also create the reference calling the getReference method in the database, and then the child method, passing the traveldeals path. To make it a little bit easier to deal with the deals, pardon the pun, let's create a new class. We'll call it TravelDeals. It will contain an id, a title, description, price. We'll declare this as a string for now to make things a little bit easier, and then imageUrl. Let's make Android Studio help us a little bit now. Let's press Alt+Enter, or Opt+Enter on a Mac, and select the Add constructor parameters command. Let's then select all the fields and press OK. This generated a constructor method that will enable us to create a new travel deal and set its values through the constructor. Okay, programmers are lazy, so let's also make Android Studio create all the getters and setters for us. So I'll select the fields and right-click, then select the Refactor, Encapsulate Fields menu. We'll select all the fields and click Refactor. As expected, we now have getters and setters in place and ready to be used. Okay, let's get back to the InsertActivity class. We'll create the variables for the EditText. Let's call them txtTitle, txtDescription, and txtPrice. Then in the onCreate method, let's create a reference to each of them. So we'll call the findViewById method for the txtTitle, txtDescription, and txtPrice. As we want to write to the database when the user clicks on the Save menu, let's override the onOptionsItemSelected method. As it often happens with menus, we'll use a switch on the id of the menu item that was clicked. And if the save_menu was clicked, we'll call a saveDeal method. Don't worry if Android Studio is giving an error, we haven't created the method, but we'll do it shortly. Okay, let's give a Toast to the user, passing this as the context, Deal saved as text, and LENGTH_LONG as duration, and we'll call the show method. We'll also create a clean method to reset the content of the added texts after the data has been sent to the database. Let's return true and set the default option of the menu to a call to the super class. Right, we need to create the two methods, saveDeal and clean. Both will be void, as we don't need to return anything right now. In the saveDeal method, we'll read the content of the three EditTexts. So we'll call the getText and the toString methods in order to populate three strings, title, description, and price. Probably TravelDeals as a plural isn't the best of the names for our class, as the object will contain a single travel deal. So let's change it to singular. We'll select Refactor, Rename, and rename it to TravelDeal. When creating a new TravelDeal, we want to pass the title, description, price, and an empty string for the URL. We will need to pass the ID, and you'll see why shortly. So let's remove the id from the constructor, and we are ready to go. In order to insert a new object into the database, we need to call the push method, and after that, we call the setValue, passing our deal object. Before trying this out, let's also complete the clean method, setting all the other texts to an empty string and giving the focus to the txtTitle EditText. Let's run the app. Okay, once it's loaded, we'll insert some data. Let's create a Caribbean Cruise that costs 800, whatever, 800 coins, and it will be a Fantastic Caribbean Cruise. Let's click on the Save button, and go to the Firebase console, and nothing happened. I guess we'll have to postpone our cruise. This happened because we haven't set the permissions for our database. In order to do that, let's get to Rules. We'll talk extensively about those later during this course, but for now you may notice that we have to set read and write permissions. In the default security rules, users must be authenticated in order to be able to read and write. This is what auth is not null means here. During development, you may find it useful to bypass authentication, and in order to do so, you'll need to set both rules to be true, and then click PUBLISH. Of course, this means that anyone could read and write to our database without being authenticated, so it's not a very good idea when your app goes to production, but for our purposes, this is what we need right now. Let's dismiss the warning and try again. So let's try to insert the cruise again, and this time as soon as you click on the Save button, a traveldeals node appears. Let's open it. There's this strange key. Let's open that one as well, and here is our data. Now you might wonder what this strange string is. It's called push ID. This is a unique key that's generated whenever you call the push method. This ID is universally unique and also progressive. We'll use it when we'll need to read and update our objects in the database, but this is the topic of later modules. Okay, let's recap what we've done so far.

Module Summary
Okay, let's recap what we've done so far. We now have a very basic app that can write to the Firebase Realtime Database. In order to make it work, we have seen how Firebase uses JSON to store data in a non-relational way. We've seen the steps required to integrate Firebase in an Android app, and how to work with the FirebaseDatabase and DatabaseReference classes. We have also learned that we need to set some authorization rules in order to be able to read and write data, and met the push ID that we'll use later in the course. Now that we have put some data in the database, we are ready to read the data and include it in our app, and that's what we're doing next.

Reading from a Firebase Database
Reading Data from a Firebase Database: Intro
Hello. This is Simone Alessandria. Welcome to this module of the course, Creating Your First Android App with Android Studio and Firebase. In this module, we'll read data from the Firebase Realtime Database. We'll see how to listen to data changes in order to show data to our users. And once we can read data, we'll use the key of each item to update and delete nodes so that at the end of this module, our app will perform all the necessary tasks you expect into an app that deals with data. So you'll be able read, insert, update, and delete nodes into the Firebase Realtime Database. Right now, our app can insert data to the Firebase Realtime Database. What we need to do now is show our users the data that was inserted into a list, and from there, we want the user to see the details and to edit and delete the deals. We'll proceed gradually. First, we'll write the data to a TextView, then we'll add a RecyclerView, and we'll tweak our RecyclerView so that it contains graphics and all the bells and whistles. Finally, we'll react to the click of our users so that they will be able to update and delete a single travel deal. Alright, let's talk briefly about what happens normally when you connect to a database. Let's say your app needs to download some data from a database to show it to your users. In this case, you make the request to a database and the database responds, sending data to your app. Now what happens when the database data changes? Well, nothing happens unless you repeat the request to the database, and the database responds again with the updated data. This process is quite different with the Firebase Realtime Database. What happens is that from your app, you add a listener to your database reference and when your data changes, the listener will react, updating the data in your app. So instead of making several requests all the time, you add your listener only once and your data gets updated. Okay, let's say that now we have a listener. What is it listening to? Well in our app, we'll use an object called ChildEventListener that listens for changes to the children of a specific database reference. So let's say that our reference is the TravelDeals node. Each time some data into the TravelDeals changes, the listener will listen. There are five events that we can use to react to data. OnChildAdded triggers when a new child is added to the location to which the listener was added. OnChildChanged is triggered when the data at a child location has changed. OnChildRemoved is triggered when a child is removed from the location we are listening to. OnChildMoved triggers when a child location changes. And onCancelled triggers when the listener fails at the server level, or when there are security issues, and we'll talk a lot about security in Firebase in the next module. Okay, we now have all the elements we need to finally show some data into our app. Let's write some code.

Showing Data into a TextView
So the first thing we'll do is create a new empty activity. We'll call it ListActivity. In our Java folder, let's click on the project then select New, Activity, Empty Activity, and call it ListActivity. Now let's get to the layout of our new activity and switch to the Design view. As a temporary solution, we'll add a Text view that will contain the data we read from the Firebase Realtime Database. Of course we'll change this later, but right now, we want to focus on the most basic way to read and show data. Let's add the constraints to the top and left of the activity, and call this tvDeals. Switching to the text view, you'll notice that there is an error here. So let's use the Android Studio quick fix, pressing Alt+Enter and adding the marginLeft property for compatibility reasons. We want the TextView to fill all the space of the activity. So let's change the width and height of the TextView to match_parent, and remove the text, which we don't need. And that's it. Our extremely basic layout is ready. Now let's switch to the ListActivity Java class. We'll begin by making a few declarations here. We need an ArrayList of TravelDeal, and we'll call this deals. Then we need a FirebaseDatabase that we can call mFirebaseDatabase. A DatabaseReference, we'll call this mDatabaseReference. You may recall from the previous lesson that when we connect to the Firebase Realtime Database, we need one more object, which is a ChildEventListener. We need to listen for every time an item is added and show the items to the user. Now in the onCreate method of our activity, let's populate the FirebaseDatabase and DatabaseReference. So we'll get an instance on the FirebaseDatabase, calling the getInstance method, and we'll add a reference to the TravelDeals node. All this should be familiar by now. Then let's create a new ChildEventListener. You can see that the five methods we've seen in the previous lesson have been added automatically. The method we need to use now is the onChildAdded method. This is because the first time the activity's loaded, every item that is in the database will trigger this event. So here we want to retrieve all the travel deals and show their title in the TextView. First, we'll include the TextView in our code, calling the findViewById method. Then let's declare a TravelDeal. Remember, this is the class we have created previously that contains the TravelDeal object, and we'll call this td. We'll populate the TravelDeal using the dataSnapshot that is passed to the method. So what is exactly a dataShapshot? A dataSnapshot instance contains data from a Firebase Database location. Any time you read database data, you receive the data as a dataSnapshot. Through the getValue method, we are serializing the data and putting it in our TravelDeal class. Finally, we'll call the setText method of the tvDeals TextView, and we will add to the existing text a new line and the title of the deal. We'll retrieve the title using the getTitle method. Finally, let's add the listener to the database reference. Now we are ready to test our app, but if we run it right now, we wouldn't be able to access this activity as the default activity of our app is the InsertActivity. So first we need to change the default activity to this one, which is the ListActivity, and then of course we'll need to make sure we can also access the InsertActivity from there. So let's get to the AndroidManifest. xml file. You'll find it in the manifests folder. Let's open it, and from there, let's move the intent-filter node with all its childs into the ListActivity activity node. Then we need to create an empty constructor to the TravelDeal class; otherwise, we would receive an error. Now let's run the app. And yes, it's working. We can see the title of the deals that are in the database right now. Of course, in this moment we see no difference from the traditional approach of connecting to a database. So let's make sure the listener is really doing its job. Let's get to the Firebase console into the travelmantics database and add a new item under the traveldeals node. Let's just put 1 as code and add a title, New Wonderful Deal. Let's save and see what happens in our app. And yes, the TextView has been updated, and that means that our listener is doing its job. Okay, let's remove the new node now. We don't need it any more. And of course our app does not update. Can you guess why? That's right, because we haven't implemented the onChildRemoved method. This is something we'll need to do later. Okay, so our app can now read data, but you can see that both our user interface and our code definitely need some improvement. So let's do that in our next lessons.

Creating the FirebaseUtil Class
You may notice that we now have some code that is repeated, both when we read and when we write to the Firebase Realtime Database. It's the part that loads the database and the database reference. Also, we might want to add new features that we want to use multiple times. So how can we solve this? Well, one of the ways to solve this issue might be creating a utility class. Let's do that and call it FirebaseUtil. At the top of the class, we declare a Firebase Database, calling it mFirebaseDatabase. And a DatabaseReference, and we'll call this mDatabaseReference. Both will be public and static. Let's also declare a private reference to the FirebaseUtil itself. You'll why we're doing this shortly. Then we'll declare an ArrayList of TravelDeals, calling it mDeals. All the members and methods of this class will be static. That means that we'll be able to call them without instantiating any object of this class. So the first thing we'll do is create a private empty constructor. This is to avoid this class being instantiated from outside of this class. Next, we'll create a generic static method that will open a reference of the child that is passed as a parameter. If this method has already been called, it will do nothing and return itself. Otherwise, it will create a single instance of itself. Get an instance of the FirebaseDatabase, and create a new empty ArrayList of deals. Now we want to open the path that was passed as a parameter. In order to do that, we call the getReference method, calling the child received by the caller of the method. Now in order to try this out, let's change our calls to the FirebaseDatabase and FirebaseReference that we've written in our ListActivity. First, we'll call the openFbReference method, passing the traveldeals string. Then we'll change the value of the mFirebaseDatabase variable to the FirebaseDatabase that we have populated in the FirebaseUtil class. And we'll do the same for the mDatabaseReference. And let's try this out, and it works exactly as before, great! Let's do the same with the insertActivity. So let's copy the code that opens the reference, and populate the FirebaseDatabase and DatabaseReference, and paste it into the InsertActivity class. Just to make sure we are on the same page, let's wrap up what we have done here. Before creating the FirebaseUtil class, we had to deal with Firebase in each activity that was using it. Now we have created a single class that deals with Firebase directly instead of having to deal with it in multiple places in our app. This will also come in handy later because every Firebase feature we'll be adding will be from this class. Okay, let's add the RecyclerView next.

Using a RecyclerView with Firebase
What we want to do now is add in a RecyclerView to our ListActivity. We'll need to remove the TextView first. I think it's always a bit sad to delete code that's working, but don't worry, it's for the best. Probably. Okay, let's do this. The sooner the better. Good. Now let's drag a RecyclerView into the activity. Let's give it a constraint to the top and to the left. Switching to Text, you'll notice that Android Studio is telling we have an error. Let's use the quick fix again with Alt+Enter. This will add the marginLeft property required for compatibility reasons. We'll give the RecyclerView an id of rvDeals. In case you haven't used a RecyclerView before, a RecyclerView is a flexible view for providing a limited window into a large data set. What this means is that a RecyclerView is a scrolling list of data that may contain different views that can have different formats and sizes. One of the interesting features of the RecyclerView, and the reason behind its name, is that it deals with memory usage very efficiently. When a RecyclerView is created, it can contain several thousands of rows. So instead of creating all of them at the same time and loading them into memory, the RecyclerView only creates the items that need to be displayed on screen, and then uses a queue. We'll see that in action shortly. Now we need to create the layout for the row. Each row in our RecyclerView is only going to have a single TextView for now. So from the layout folder, let's right-click and add a New, XML, Layout XML File, and let's call it rv_row. For now it's okay to use a linear layout. That's the simplest layout we can use right now. We'll add a TextView. Let's drag it from the Widgets. The only changes we need to make here are the id, we'll call it tvTitle. We can remove the text, and add a textSize of 20sp. Okay, now that we've dealt with the layout, let's try to put some data into them. The RecyclerView needs an adapter to populate the views in each row with your data. So let's create a new Java file. We'll call it DealAdapter. Let's removed the comments. This is how it works. The RecyclerView contains data, so it needs to connect to a data source. This can be a database or a web API. In our case, it will be the list of travel deals that we retrieve from Firebase. In order to get data from a source, we'll need an adapter. The adapter will send data to the RecyclerView through an object called ViewHolder. The ViewHolder describes an item of the RecyclerView. In our app, it will be a single row of data containing the travel deal information, and also contains information about its place within the RecyclerView. Adapter and ViewHolder work together. The Adapter should subclass the ViewHolder to load the views, and then bind data to the views. ViewHolders get cached to make scrolling smoother because the findViewById method gets called only when an item is created, and not each time it's updated. Finally, we have the LayoutManager. We can use this in order to decide how the items are displayed in a RecyclerView. Let's get back to our app and declare a new public class called DealViewHolder. This ViewHolder must extend the RecyclerView. ViewHolder abstract class. Now let's make use of Android Studio quick fix features, pressing Alt+Enter and selecting the Create constructor matching super option, and the error disappears. We'll use this class to describe how to bind the data to a single row. So the first thing we want to do is create a variable that will contain the text view, and we'll call it tvTitle. Then in the constructor, we'll put the tvTitle TextView into the variable we have just created. There is one more thing that the ViewHolder needs to do, which is binding the data that is passed to the layout of our row. In order to do that, let's create a bind method. This method will return nothing, but it will take a deal as a parameter. Then let's set the text of the tvTitle to the title of our deal. To make it simple, what this method is doing is taking a deal as a parameter and putting the title into the TextView that was set in the constructor. Okay, let's get back to the outside class. This must extend the RecyclerView. Adapter abstract class, and this requires a ViewHolder, which is the ViewHolder we have just created. As you can see, there are some requirements. Let's use the Android Studio quick fix features again with Alt+Enter and select the Implement methods menus. We leave all the methods selected and press OK. In the outside class, let's create a public constructor, and copy some code from the ListActivity. We'll take the FirebaseDatabase and DatabaseReference codes and the declarations. Let's also copy all the code related to the ChildEventListener. We don't need the textbox here, so let's remove it. Let's log the title to make sure everything's working, and add to the deals array everything the item that was passed. Here we'll add another piece of code that will help us later. We'll set the id of the deal to the pushId that was generated by Firebase so that we can read it easily later. In order to do this, we'll call the getKey method on the dataSnapshot. Let's also add the ChildEventListener to the DatabaseReference. We'll want to use a list array of deals to populate the RecyclerView. We already have them in our FirebaseUtil class, but we'll want to retrieve them here. OnCreateViewHolder is called when a RecyclerView needs a new ViewHolder. OnBindViewHolder is called to display the data. In the onCreateViewHolder method, we get the context, and we call the inflate method from our context, calling the row layout that at the moment contains a single TextView. Finally, let's return a new DealViewHolder, passing the itemView we have just created. In the onBindViewHolder, we'll just get the TravelDeal at the current position, and bind it to the holder. In the getItemCount, we'll count the items on the array list and return its size. In the onChildAdded method, one last important step is calling the notifyItemInserted method, passing the position, which is the size of the array list minus 1. This will notify the app service that the item has been inserted so that the user interface will be updated. Now getting back to the ListActivity Java file, we can comment out this code, as we have copied it in the DealAdapter and we don't need it anymore here. Or better still, we can remove this code for good. Let's create a reference to the RecyclerView calling the findViewById method in the rvDeals RecyclerView. Let's declare a DealAdapter that will be a new DealAdapter, and then set the adapter on the RecyclerView. Finally, let's declare a LinearLayoutManager and set the LinearLayoutManager on the RecyclerView. Okay, let's try this out. It seems there's only one deal visible here, but if we scroll down, we can see that the other deals were below the first one. So we have a size problem here. Let's fix it. In the rv_row, we have the layout height set to match_parent. Let's change it to wrap_content. Let's try this again, and yes, this time it's working. Okay, I guess this was quite a bit of code with very little visible change. Let's have some fun and add a few nice features that would have been impossible with a TextView. We'll do that in the next lesson.

The New Layout
First of all, let's see what we have now. In our ListView activity, we have a RecyclerView. In order to build the layout, the RecyclerView is using an XML file that we have called rv_row that now contains a single TextView. The result is what you see on the right. Now the first thing we want to do is make the layout a bit more user friendly, like this. In order to do that, instead of a single TextView, the rv_row XML file should contain an image, a TextView for the title, another one for the description, and the last one for the price. So back to our code, let's open the rv_row XML file and change the layout according to our needs. First of all, let's transform the linear layout into a ConstraintLayout. This will make it easier to use the Design View for the layout. Then let's delete the TextView so that we can design everything from scratch, and set the height of our container to match_parent. This is only a temporary solution to have more space for our design, and we'll change it back later. Now, switching to the Design view, let's add an ImageView. For now, we'll just use the predefined launcher icon just to see the layout. In one of the next modules, we'll deal with images properly. Let's add the constraints to the top and to the left, then we'll add the TextView for the title, putting a constraint to the image and to the parent layout. Let's add another TextView for the description. This will have the top constraint to the title TextView and a left constraint to the image. Finally, we need one last TextView for the price. This will have a top constraint to the description TextView and a right constraint to the parent layout. Our layout is almost ready. We only need to change a few properties, so let's switch to the TextView. First, let's set the height of the layout to wrap_content again. As you can see, Android Studio is telling us there is something wrong with our ImageView. Let's press Alt+Enter again to solve the issue. Then for the margins, let's use a value we already have in our dimension resource XML file. We'll do that for each margin in our layout. So we'll begin with the title TextView, then the description TextView. Here we'll also use the Android Studio quick fix to add the marginLeft property. We'll finish with a price TextView, and here we'll use the quick fix again. Now a few IDs to make it easier to reach our views from Java. The ImageView we'll call imageDeal. The tvTitle is the second TextView, the description we'll call tvDescription, and quite predictably, we'll call the price TextView tvPrice. We now need to fix the constraints with the new names. The imageView is now imageDeal. TextView2 is tvDescription, imageView2 is still imageDeal, and everything should be alright now. Good. Let's change the fonts a little bit, as the final result should be like this. On the tvTitle we'll add a textSize property that we'll set to 24sp. We'll also extract the resource by pressing Alt+Enter, and we'll call it title_large. On the tvPrice, the textSize will be 18sp, and the Resource name, text_price. Also, we'll change the text color to the accent color, which in this project is a beautiful pink by the way. Okay, here we have the final result. Now that the new layout is ready, we need to add data in the new TextViews. We should also deal with the image, but we'll do that in a later module. Fortunately for us, as our infrastructure is already built, this will be a very simple process. Let's get to the DealViewHolder class. First, let's declare the new TextViews at the top of the class, and we'll do that for the description and the price. Then in the constructor method, we'll call the findViewById method to find the description and the price TextViews. Let's get to the bind method in the DealViewHolder class. From there, we already set the text of the title. As the bind method already receives the full TravelDeal, we just need to add the code to fill the remaining TextViews right here. So first, we'll set the text for the description, and then for the price. Let's try this out and see if it's working. Okay, much better, isn't it? Now, from this activity, we want to be able to insert a new travel deal. We have already written the activity to do so, but right now there is no way to get to the InsertActivity, so let's create a menu that will allow the user to get to the insert activity from there. From the menu folder in our resources, let's add a new Menu resource file, and call it list_activity_menu. In the TextView of the XML file, let's add a new item with an id of insert_menu. As a title, we'll write New Travel Deal. We'll also add the showAsAction never. Okay, now we have to tell Android Studio that we want to use this menu in the ListActivity. So we'll get back to the ListActivity Java file, we'll override the onCreateOptionsMenu method. We'll get a MenuInflater object, naming it inflater, and calling the getMenuInflater function. Then we'll inflate our newly-created list_activity_menu resource file. Let's try this out. And we can see that a menu button appears. Now this does nothing, so let's fix this. We'll override the onOptionsSelected method, then we'll create a switch statement, checking the menu item that was selected. We have only one right now, and it's R. id. insert_menu. When the user clicks on that, we want to create a new intent from the current context, and we'll call the InsertActivity class. And then we want to start the activity that we have described in the intent. As the insert activity will also contain features to edit and remove travel deals, let's refactor this class, renaming it DealActivity instead of InsertActivity. Again, let's try this out. Let's open the menu, click on it, and try to insert a new travel deal. Let's say we want to go to a weekend in Paris whose price is 400 things, and as a description it's a Romantic break in Paris. Let's save it and then get back to the ListActivity, and here it is. Now we only need to add a few features to our app. From the ListActivity, it would be nice to click on a single travel deal and see its details so that we could also see how to edit and delete an existing item in the Firebase Realtime Database, and this is what we are doing in the next lesson.

Implementing Edit and Delete
So far, everything's working, but we now want to be able to edit and delete a travel deal from the database. So, first we want to be able to click on any deal in the list and understand which item was clicked. Then we want to get to an activity that will allow us to see and edit the details of a travel deal and delete it. So let's begin by enabling a click event on our RecyclerView. In the DealViewHolder, let's implement the View. OnClickListener, and using the Android Studio quick fix with Alt+Enter, let's create the onClick event. From there, first we need to get the position of the item that was clicked, and we can do this calling the getAdapterPosition method. Just to make sure it's working, let's log the position. And in the log, we'll right-click and the position. We also need to call the setOnItemClickListener on the DealViewHolder constructor. And let's try it. If you open the logcat window, you can see that the app now reacts to the click and can find the position of the deal that was clicked. Good. This is the first step. Now after clicking, we want to reach an activity that will allow us to edit the travel deal. And if you think about it, we already have an activity like that. We can actually use the DealActivity for editing purposes as well. We want to get to the deal activity when we click on an item in the RecyclerView. So in the onClick method, first we can find the TravelDeal that was selected through its position, calling the get method of the deal's array list. Then we can create a new intent, calling the DealActivity class. We need to pass the TravelDeal to the DealActivity so we can try to call the putExtra method, passing the TravelDeal, but as you can see, Android Studio is giving an error. This is because we cannot pass a complex class as an extra unless we take some action. What we need to do is implement the serializable interface on the TravelDeal class. For performance reasons, it would be better to use the parsable interface, but because a TravelDeal is really a very small object, there's no need to do it right now. Okay, now in order to start the DealActivity, we need to call the startActivity method from the context of the current view. On the other side, we need to receive the TravelDeal class and show it to the user. So let's open the DealActivity class, and then in the onCreate method, let's get the intent, retrieve the deal that was passed, if it was, calling the getSerializableExtra method. Now if the deal is null, that means that we got there clicking in the InsertDeal menu. So we need to create a new TravelDeal. Then let's put the deal variable into the deal member. And by the way, we need to create a deal member in the DealActivity class. So let's do it now and set the text for each TextView. We'll do it for the Title TextView, then for the descriptions, and the price. If the deal is a new TravelDeal, of course the TextViews will be empty. Let's try this out. And indeed, it works. Now let's see how to edit and delete items with a Firebase Realtime Database. We already know how to insert a new node into the database. On the DatabaseReference, we just need to call the push method, and this will create a new node with a push ID generated automatically by the Firebase Realtime Database engine. If we want to edit an existing item, the method to call is setValue, and this takes as a parameter the object that we want to update, but before calling the setValue method, we must find the item to edit through its ID. So we can call the child method, passing the ID, and then we can call the setValue method. The procedure to delete is almost the same. We locate the item to delete through its ID, and then we call the removeValue method. Okay, let's see this in action in our app. We already have a saveDeal method, we'll keep it. Instead of using three strings here, we'll use our TravelDeal object for the three values. So we'll call deal. setTitle, deal. setDescription, and deal. setPrice. Then we have to choose whether this deal is new or it's an existing one, and the way to do so is calling the getId method. If the ID already exists, this means that we have to update an existing deal; otherwise, it's a new one. So if deal. getId is null, then we'll call the push method; otherwise, we'll call the child node that has an ID of deal. getId, and on that, we'll call the setValue method. Let's also make a deleteDeal method. This will check if the deal exists. If it doesn't, we'll give an error message to the user, and then return; otherwise, we'll get the reference of the current deal and call its removeValue method. Let's also create a backToList method to return to the ListActivity after saving. So we'll create a new intent that from the current context called ListActivity class, and then we'll call the startActivity method, passing our intent. Now let's add to the menu a delete option. As a title, we'll write Delete Deal and extract the string resource, calling it delete_deal. For the showAsAction property, we'll set never, as we don't want this menu to be visible on the layout without pressing the menu button. Then let's add to the switch statement on the onOptionItemSelected method, the delete_menu option. From there, we'll call the deleteDeal, we'll give the user a message with a Toast telling that we have removed the deal, then we'll call the backToList method, both for the save menu option and for the delete. This is because after saving or deleting an item, we want to get back to the list activity automatically and return true. Okay, let's try this out. So we have written the code to edit and delete a TravelDeal. Let's try to delete our Weekend in Paris, and we'll receive the Toast that the deal has been deleted, but in the list there is something wrong. Not only the Weekend in Paris is still visible, but the deals seem to be duplicated. There is some good news though, if you go to the Firebase web interface or restart the app, you'll see that the deal has actually has actually been deleted. So what's happening? Well the solution is incredibly easy to implement. We know that server side everything's working, the easiest way to update our UI would be to reset the array list each time we get back to the list activity, and we can do this just getting to the FirebaseUtil class and moving the instruction that creates a new ArrayList so that it gets called every time the class is called. Let's try this out again. And yes, now it's working. Okay, let's briefly recap what we've done so far.

Summary
With this module, we have completed the reading and writing functionality of the Firebase Realtime Database. We have seen how we can use listeners to update the data in our app and seen how the listener listens for changes to the children of a specific database reference. We've seen there are five events we can use to react to data. OnChildAdded is the one that we used, but there are also onChildChanged, onChildMoved, onChildRemoved, and onCancelled. All these events receive a dataSnapshot that contains data from a Firebase Database location, then we've seen how to edit an object. This requires two steps. First, you need to find the node you want to edit, and you can do this with a child method, passing the ID of the object you want to reach, then you call the setValue method, passing the updated object. We've seen that the procedure to delete a node is similar, as you need to call the child method and after that the removeValue method. Of course, you don't need to pass any updated object. We've also seen one way to use the RecyclerView to deal with the Firebase Realtime Database. The basic functionality of our app is there. In our next module, we'll see how to deal with a little bit of security in Firebase, and you'll see how easy and efficient it is to log and set permission rules with Firebase. See you there.

Managing Authentication
Enabling Authentication in Firebase
Hello. This is Simone Alessandria. Welcome to this module of the course, Creating Your First App with Android Studio and Firebase. I don't know about you, but I find that one of the most boring features most apps must have is dealing with authentication and authorization. That means that you generally have to implement sign in and sign out, keep your users' credentials safe, check whether a user is typing a valid email and the password has the right length, implement the code to create a new username, give the user the ability to reset their password, and on and on. Okay, you know the drill. It's useful, necessary, but it's also a lot of work that users barely notice and take for granted, unless it's poorly done, then your users will certainly notice. Well, the great news is that Firebase makes dealing with authentication and authorization a very simple process, even fun, so that we can stay focused on the real features that make our app great and have Firebase lift the security heavy load. Right now, our app has no security whatsoever. Everyone can read and write data. They could even delete the whole database. This is certainly not something you'd want for your production app. So in this module, we'll add some security to our app. In order to do that, we'll have a look at Firebase authentication and see how it works. We'll see what database rules are. We'll implement log in and log out in our app using FirebaseUI. Finally, we see how to set the rules in our app so that authenticated users can read content and only the administrators will be able to write travel deals to the database. Let's get to our database in the Firebase console. From here, let's click on the RULES link. You might remember that we've already been here to set both read and write to true. Now we'll do the opposite and get back to the default. So for the read key, we'll write auth is not null as a value in quotation marks. And we'll do the same for the write key. And then we'll click on the PUBLISH button. This is telling the Firebase Database that in order to read and write data, there must be an authenticated user. Actually, there are four kinds of rules we can set in a Firebase Realtime Database,. read determines if and when data is allowed to be read by users,. write if and when data is allowed to be written,. validate specifies data types, formats child attributes,. indexOn specifies a child to index to support ordering and querying. Okay, so we've told our database that a user must be authenticated before they are allowed to read and write data. So can you guess what happened to our app? If you think our app is broken again, you are totally right. If we ran our app now, a very depressing empty activity shows up. Before we move on and fix this, let me show you a log that might point us to the right direction. Let's just write Firebase in the search box, and the first message that we get is FirebaseAuth is not linked. So, Firebase is telling us that, well, we need to implement authentication in our app. Quite helpful. Okay, let's see how to fix this next.

Using Firebase UI
The first step we need to perform is enabling authentication within Firebase. So from our console page, let's click on Authentication. Here you'll see an introductory page that tells us that we need to set up the sign-in method. Actually, this means that with Firebase, you can choose how your users will log in. So we'll be able to deal with users by email and password, or use an external provider like Google, Facebook, Twitter, GitHub, or even by phone. In our app, we'll allow authentication with email and password and Google. So let's click on the SET UP SIGN-IN METHOD button, and in the Authentication page, you'll notice that all the providers are now disabled. Let's fix that by clicking on the Email/Password and then on the Enable slider. Now let's SAVE. And we'll do the same with Google, so you'll be able to see both an internal and an outside log-in process. Server side, or better I should say Firebase side, everything is ready. Now we need to enable authentication in our app. You might think that the first thing we need to do is create a new activity for the log in, and this would certainly be possible, but there's an easier way. If you go to the Firebase guide at the link below, you'll see that there are two ways we can implement authentication in Firebase. One is using the Firebase SDK Authentication in which you design the user experience yourself, and you make the calls to the SDK from your code. And the other one is FirebaseUI, and this is what we'll use for our app. FirebaseUI is a great open-source library that deals with a sign-in process. It implements all the user interface necessary for the log-in process of our users and lets you choose the authentication provider you want to use. For example, as we've chosen to log in with email and password and Google, this UI will deal automatically with both methods. To summarize, what FirebaseUI does is having all the user interface ready for us for each provider we choose to implement. Let's see how to use FirebaseUI and FirebaseAuth in our app. Back to the Authentication Guide page, in the FirebaseUI section, let's click on the ANDROID link. Here you'll find the latest implementation guide to use FirebaseUI in your app. The first step is adding Firebase, and we've already done that. So we can skip this and get to the second step, which is adding the FirebaseUI dependency. So let's copy the code and paste it in our app build. gradle file. Okay, let's sync the project. If you are getting errors during the build, just make sure you add the required repositories, and then try again. After everything's fixed, we can move on. Let's think for a moment about what we want to achieve. When our app starts, we want to be able to check if the user is already logged in or not. There's an object called authStateListener that does exactly that. If they're not logged in, then we need to enable the sign-in flow with the providers we have chosen. After logging in, users are allowed to see the travel deals. Once logged in, we need to enable the users to log out, and there we'll need to detach from the authStateListener and clear out our RecyclerView. So, the AuthStateListener is called when there is a change in the authentication state. It executes when a user signs in or signs out, or the auth state changes, and this is attached to the FirebaseAuth class. In our app, we'll attach the listener in the onResume method, and we'll detach it in the onPause, following best practices. Okay, let's see that in action.

Demo: Implementing the Login Flow
We'll begin by implementing an AuthStateListener to determine whether the user is logged in or not. We'll write this part of the code in our FirebaseUtil class, as this is where we deal with Firebase from our app. So first, let's create a FirebaseAuth object, just under the DatabaseReference. It will be a public static FirebaseAuth, and we'll call it mFirebaseAuth. We'll also declare another variable for the AuthStateListener, and we'll call it mAuthListener. Now let's initialize the FirebaseAuth object after initializing the database in the openFbReference static method. The method to call is getInstance, just like for the database. Let's also initialize the AuthStateListener. This will create an onAuthStateChanged method. We'll deal with it shortly. Now let's create two methods to attach and detach the listener. The first one will be a public static void method called attachListener. Inside, from the mFirebaseAuth object, we'll call the addAuthStateListener method, passing our mAuthListener object, and we'll do the same with the second method that we'll call detachListener, but instead of calling the addAuthStateListener, we'll call the removeAuthStateListener. In the ListActivity, let's override the onPause and onResume methods. In the onPause method, let's call the FirebaseUtil. detachListener method. And in the onResume, the attachListener method. Now, in the onStateChanged method, we need to check whether our user is logged in or not. Let's copy some code from the FirebaseUI guide and see how to use that with some tweaks. And we'll copy the code in the onStateChanged method. Then let's use the Android Studio quick fix with Alt+Enter to import the relevant objects. Now as for the providers, we can delete all except Email and Google. Notice that the startActivityForResult is giving an error. That's because we cannot start an activity from outside an activity. A solution might be passing the callerActivity when we initialize the class. So let's create a private activity called caller, and then set it in the openFbReference method, then it will be the caller that will start the log-in activity. Now that we have a code to sign in, let's wrap it up in a new method that we'll call signIn. So we'll copy the relevant code and paste it in the signIn method. Let's move the caller initialization in the openFbReference method. Okay, let's write a welcome message with a Toast that will get the context from the callerActivity. The text will be Welcome back!, the duration will be long, and then we'll call the show method. And we'll call the signIn method from the onAuthStateChanged. Before trying this out, now that the openFbReference method takes an activity as its second argument, we must also add the activity when we call the method. Okay, now let's write this out. And as you can see, we are presented with a log-in screen that allows us to choose the provider we want to use. Okay, let's try email first. We'll insert an email and Firebase will actually realize that there is no user with that email yet. So we'll insert a name and a password, and we'll confirm. And the toast appears. Great, isn't it? But you might have noticed that, well, we still see the log-in screen. Let's see why. Whenever the state of the authorization changes, we call the signIn. So we call it every time a user is trying to log in or log out. We must add a control here to see if there is a logged user or not. The way to do this may be calling the getCurrentUser method. So if the FirebaseAuth. getCurrentUser is null, then it means that we have to log in; otherwise, we don't need to. Okay, we see the travel deals because we are still logged in. Let's uninstall the app and try to log in again. Let's put our email, FirebaseUI understands that we have already created the user, so it's just asking for a password. We'll type it in and blank screen. So now the user can log in, but the app is not showing the travel deals. Let's see why. The problem is that our dealAdapter is calling the database to retrieve data, but this happens in the onCreate method of the ListActivity. When this happens, the user has not logged in yet, so Firebase refuses the connection. To solve this issue, let's just move the code that shows the traveldeals that we now have in the onCreate method, in the onResume, and let's try again. So we'll uninstall the app again, insert our email and password, and yes, now the travel deals are showing. Well done. It would be nice if after logging in, we could also log out, right? And that's what we'll do next.

Logging out and Managing Users
We need to enable logging out from the app. We'll begin by creating a logout menu item in the ListActivity menu. We'll give it an id of logout_menu, and as for the title, we'll choose Logout. For the showAsAction property, we'll leave never. Now let's create a new case in the onOptionsItemSelected method. It will be for our R. id. logout menu, then we can have a look at the documentation again to copy the code that we need for the logout. We'll copy this logout code, and paste it in our new case, then let's use the Android Studio quick fix with Alt+Enter to import the relevant objects. Basically, we need to get an instance of AuthUI, and then call the signOut method. Then we can add a listener that will trigger when the user has completed the logOut. We'll also detach the listener, calling the FirebaseUtil. detachListener method. Here we'll just log the Logout for now. Okay, let's try this out. Let's log out. If we have a look at the logs, we can see that the event triggered correctly, but we would also like to get back to the log-in page when the user logs out, and we can do this by adding the attachListener method so that if the user is not logged this will call the log-in page. And let's try this out again. So let's log in, then log out. Okay, that's perfect. Log in and log out are working. There's one thing we haven't tried yet, and it's the Google login. Select the Google option in the log-in screen. Let's choose a Google account, or add one if you haven't yet in your emulator, then go to the next screen and, well, we receive a developer error. This is because we need to tell Firebase that our app is allowed to make authentication requests. And for that, we need our application S-H-A-1 key, or SHA-1 key. We can find it this way, let's click on Gradle on the right of Android Studio, then click on our project's name, then again on Tasks, android. Let's double-click on signingReport, and then copy the SHA1 key. Now back to the Firebase console, let's get to the Project settings, then down to the certificate fingerprints. Let's click on the ADD FINGERPRINT link and paste the code that we have copied. And now let's try Google authentication again. And it works. Very well done. Now let's try to have different rows for our users. We'll do that in the next lesson.

Differentiating User Access
In this moment, each authenticated user in our app can do anything, but let's think about it for a moment. If you were a travel agent and gave your users an app, you would not want your customers to insert, edit, or delete your travel deals, right? So what we want to achieve is having two different kind of users in our app. Simple users will have read access to the content, and administrators will have both read and write access. Before we get a bit deeper into the Firebase Database rules, let's make sure we are on the same page with an important concept when dealing with security. Actually, access to protected resources is made of two different processes, authentication and authorization. Authentication is all about answering the question who are you, and the process of proving your identity. Email and password, fingerprint, face recognition, or your paper passport are all examples of ways to verify your identity. Authorization comes after authentication and answers the question, what can you do? This means that after I know who you are, I have to decide what resources you are allowed to access and which rights you have over those resources. With data, you usually have two rights, read and write. Until now, our focus has been only over authentication. Let's see how database rules in Firebase can also help us with authorization. This is the rule we have right now in our app. Security rules are managed by a single JSON object and have a rules node as the main container. Auth is a top-level variable in Firebase that represents the authentication state of the client making the request. So, if a client is not authenticated, the auth variable will be null. In all other cases, auth will be filled with a UID, a unique identifier. Let's see a few other examples that can help us understand how to use rules in our apps. In this example, there are two different read rules, one for a top-level node of our database called traveldeals, and another for another top-level node called offers. This means that anyone can read the traveldeals, but only authenticated users can read the offers. Now, what about the write? Well, if you don't specify any value for write, it's like saying write equals false, so no one can write data in any node with this example. Also, if there was a third node called specials, for example, no one could read or write from there, as we haven't specified any rule for the specials node. Let's see another example. Here we have a $uid node; $uid is a wildcard for the user ID. That means that you make sure the authenticated user can only write to their own location. So for example, user 123 can only write inside their 123 node. One more thing I want you to notice. In the rules node, we have a write false value, and this is valid for all nodes in the database because rules cascade. Basically, this means that when you set a rule for a node, it will be valid for all its subnodes. Then we specify a different rule for the users node. Who wins? The most permissive rule always wins. In this case, the user will be able to write in their node. Let's make another example. This is the same rule as before, but it has a write true rule for the top node. What happens in this case? The second rule will be ignored because the write true is more permissive than the second rule. Please pay attention to this concept as it may have unexpected results in your app. Firebase rules cascade in such a way that granting a read or write privilege to a parent node always grants the read/write access to all child nodes. Okay, let's get to our last example. That's what we'll be using in our app. Here we're saying that authenticated users can read all data in our database. For the write rule, we're saying that from the root, we get to a child node called administrators. From there, we'll check whether a child exists that has an id of the auth user id. This means that if the current user is in a node called administrators, they will be able to write into the database. There's a lot more about Firebase database rules than we have covered here, but this is enough for our simple app. Let's see all that in action.

Demo: Implementing Administrator Rules
From our app. let's create a new user so that we can try two users, one that is an administrator, and another one that is a user. The administrator will be able to create new travel deals, and the user will only be able to read them. So let's log out and create a new user. We'll call this user Clark Kent. Well, this is definitely a superuser. Now, if we get back to the Firebase console in the Authentication page, you'll notice we now have two users. Also notice that each one has a unique identifier, or UID. Now let's say that Clark Kent will be an administrator, and Simon, that's me actually, will only be able to read data. Well in this case, let's copy the UID of the superuser, Clark Kent, and get to the database rules. As you can see in this moment, each authenticated user can write to the database. We really need to change that rule. Back to the data, let's add a new node in the travelmantics database. We'll call this administrators. Within administrators, we'll add a new node with the key we copied from the UID of Clark Kent, then let's just add a name to make it easier to recognize the admin. So what we are saying here is that there's a node that contains all the administrators of the database. Now, let's set the rule that only allows administrators to write data. Back to the rules. For the write rule, let's write root. child of administrators. hasChild auth. uid. Let's publish the rule. Now let's see what happens in our app. If we enter with our administrator login, the app works just like before. We can add, delete, and edit travel deals. Now let's log out and log in again with the normal user. We'll try to delete a travel deal, and well, nothing happens. And the same if we try to add or edit a travel deal. But this may be very unsettling for our user, as they might think they can do anything when they actually can't. So let's make the forbidden features of our app invisible to the normal user. In the FirebaseUtil class, let's create a boolean public variable called isAdmin. From the onAuthStateChanged method, let's retrieve the UID of the current user. Then we want to call a method that checks whether the user is an administrator. Now let's create the method that checks whether the logged user is an administrator. We'll call it checkAdmin. It will take a string that contains the UID as an argument. Let's set the isAdmin variable to false at the top of the method. Then, let's create a database reference to the administrator nodes, but only for childs that have the UID that was passed, then let's set a listener. And in the onChildAdded method, let's set the isAdmin variable to true and log that this user was an administrator. This is because this method will only trigger when a child with a UID of the current user has been found in the administrators node. So basically, the current user is an administrator. Finally, let's add the childEventListener to the database reference. If we try this out, we can see the message, You are an administrator. That's great. Now let's use the isAdmin variable to hide the menus a normal user would not need. We create a method called showMenu that will call the invalidateOptionsMenu method. You can use the invalidateOptionsMenu to say to Android the contents of the menu have changed and the menu should be redrawn. So when we draw the menu, let's find the insertMenu, and make sure that if the user is an administrator, the insertMenu will be visible; otherwise, it will be hidden. From the FirebaseUtil, let's call the showMenu method after making sure that the caller is a ListActivity. (Working) Now we need to do the same for the DealActivity. We don't want a normal user to edit or delete a travel deal, right? Let's change the menu in the DealActivity. If we have an administrator, we'll find the delete menu and set its visibility to true, and we'll do the same with the save_menu; otherwise, we'll set the visibility to false. One very last fix. Now, even if a user cannot save a deal, they can write in the EditTexts, and this may be a bit confusing to our users. So let's create a simple method that we'll call when we check whether the user is an administrator, and we'll call it enableEditTexts. This will take a boolean argument that we'll call isEnabled. There we'll call the setEnable method for the txtTitle, passing the isEnabled value. And we'll do the same for txtDescription and txtPrice. Then back to the onCreateOptionsMenu method. If the user is an administrator, we'll call the enableEditTexts method, passing true; otherwise, we'll call it passing false. And let's try this again. So if we enter as a simple user, we can see the add menu in the ListActivity. And if we go to the dealActivity, we cannot save or delete an item. If we enter as an administrator again, here we can do everything, exactly as before, and this is what we wanted to obtain in this part of our app. Users must be logged in to use the app, and only administrators can write. Let's recap what we've done. We've seen the difference between authentication and authorization, and that Firebase allows us to authenticate in several different ways. In our app, we used email and password and Google authentication. Then we've seen how database rules are a powerful tool that can help us dealing with authorization, granting permissions to specific nodes and users. We've seen how we can use the AuthStateListener class and seen how FirebaseUI makes the sign-in flow a breeze. Good, now our app is definitely more secure. In the next module, we'll want to deal with images to make our app a bit more beautiful. And in doing so, we'll talk about Firebase Storage. See you there.

Using Firebase Storage
Firebase Storage
Hello. This is Simone Alessandria. Welcome to this last module of the course, Creating Your First App with Android Studio and Firebase. This module is all about the Firebase Cloud Storage and its security rules. We'll talk about the Firebase Storage and see how its features make it a great tool to store data for your apps. Then we'll see how to implement storage in our app so that we'll be able to add pictures to our travel deals, and users will be able to see them in the app. Finally, just like we did with the Realtime Database, we'll add some security rules to only enable administrators to write data to the storage. At the end of this module, you'll be able to use Firebase Storage in your apps so that you'll have an extremely powerful tool in your basket. The Firebase Cloud Storage enables developers to store data with Firebase. While the Realtime database is mainly targeted at text data in JSON format, cloud storage is perfect for files, like documents, images, video, and audio. There are several features that make Firebase Storage a great tool for developers. The upload and download of files is optimized so that if your app loses and regains connectivity, the upload or download will automatically resume. This is incredibly useful when we deal with mobile apps that can have connections that aren't always that reliable. Another great feature is security. The great news is that Firebase Storage integrates with Firebase Authentication so that you can grant access to files based on user identity or properties of the file, so you can decide exactly who can access which files. And last, but not least, this is a Google Cloud service, so it's scalable to virtually any size. Of course this won't be noticeable in our very small app, but still, it's a consideration you might take into account for your future apps or for your customers. This is the app after the end of this module. Our ListActivity will show the user a small image of the travel deals they are viewing. When they select a deal, they'll be able to see a bigger image of the deal. The administrator will also be able to upload new images into the Firebase Storage and save their location into the Firebase Realtime Database. Okay, let's get to the Firebase console, and let's click on the Storage link. Once there, we can click on the GET STARTED button and accept the default Security rules. We'll talk about those shortly. There's nothing there, as we haven't uploaded anything yet, but this page already contains some very important information and features. On the left, you can see the address of your storage location. Then there's a button that allows you to upload files from here. And this other button allows you to create folders in your storage space. This is also a great feature as folders are also authorization containers. So if you have security rules in place, instead of granting access to a single file, you can grant access to a folder instead. Okay, let's create a folder. We'll call it deals_pictures. Next, we'll get back to our app and see how to interact with the Firebase Storage.

Uploading an Image to Firebase Storage
As usual, the first thing we need to do in order to use a new Firebase feature is adding a dependency in our app Gradle file. Let's add in our project the firebase-storage dependency with the same version we used above, then sync. In our app, we want to add a button to the DealActivity. This button will allow a user to upload an image to the Firebase Storage. So let's open the DealActivity layout file. In the project, this is still called activity_insert, so let's rename it immediately in order to avoid confusion. Let's right-click and choose Refactor, Rename, and we'll call it activity_deal. Okay, from this layout, we'll get to the design view. From the Widgets in the toolbox, we'll drag a button under the txtDescription EditText. Let's put a constraint to the top, the left, and the right so that the button will be centered under the added texts. From the Images, we'll choose an ImageView and place it under the button. For now, let's just select a color. We'll choose the transparent color so that before the image loads nothing will show. And here we'll put a constraint to the top, left, and right as well. Let's change a few properties. The id of the button will be btnImage, and the ImageView itself we'll just call image. For the button, we'll use the same margins we used in the text. The text of our button will be Upload Image. And for the ImageView, let's fix the error on the top constraint with the new name we have given to the button, and for the margins we'll also use the saved value. Okay, our layout is ready. Let's get to the DealActivity Java file. Here in the onCreate method, we'll create a button variable that will find the btnImage we have created, and on that, let's set an onClickListener. And in the onClickListener, we'll create a new intent. This intent will be of type ACTION_GET_CONTENT, which allows the user to select a particular kind of data and return it. Then, we'll set the type of data to jpeg images, and we'll call the putExtra method, specifying that we should receive only data that is on the device. Then, we'll call the startActivityForResult method, calling the createChooser method, passing the intent we have just created, a tag that will be Insert Picture, and we'll pass a handle, let's say 42. Let's create a constant for the number 42. This is a totally arbitrary number, more or less, that we'll use as a handle. Now we want our app to be able to connect to the storage. So let's get to the FirebaseUtil class and create a variable of type FirebaseStorage. We'll call this mStorage. Like for the database, we'll need a reference to the storage. So let's create a variable for that as well. It will be a StorageReference object that we'll call mStorageRef. Now let's create a new method that we'll call connectStorage. Inside the method, let's get an instance of the FirebaseStorage, then let's reach the folder that we have created previously that we called deals_pictures. Now in the openFbReference method, let's make a call to connectStorage. Back to the DealActivity, let's override the onActivityResult method. Inside the onActivityResult, we'll check whether the request code is our picture result constant, so the 42, and the resultCode is RESULT_OK. There are actually three steps required to upload a file to Firebase Storage. First, we need to locate the file you want to upload and put the location in a URI object. Then, you need the reference to the storage where you want to upload the data. Finally, you call the putFile method on the reference. This will return an asynchronous task called uploadTask, and you can listen to success or failure over that. Let's see that in our code. First, we'll create the URI, calling it imageUri. We received a data object from the intent, and if we call the getData method, we'll receive the URI of our image. Then, let's set the reference of the storage, calling the getLastPathSegment of our imageUri. Now let's upload the picture to the Firebase Storage, calling the putFile method. Okay, let's try this out and see what happens. We'll select a deal, then add a picture, wait for a few seconds, and then back in the Firebase console, let's see if in our storage we can see something. And yes, here is a file, and it's the file we have just uploaded. Okay, right now we can do nothing with it. So let's just delete it for now and get back to our app. Now as the putFile method returns an asynchronous upload task, we want to listen to the result of the task because we need to take action over that. So let's add an onSuccessListener, passing the activity as the first parameter, and a new onSuccessListener as a second parameter. Android Studio will create an onSuccess method for us, and as you can see, we'll get a TaskSnapshot as a parameter. This will contain the URL of the file that was successfully uploaded and will add it to the database. So let's get the URL with the getDownloadUrl method, and then transform it to a string. Now we need to add these to the deal we are viewing. We already have a deal. It can be new or not, we don't care, so let's add to the deal of the URL we have just retrieved, calling the setImageUrl method. Now we're ready to test it. The deal should now contain the URL of the image. From our app, we'll get to one of our deals. We'll click on the UPLOAD IMAGE button, and we'll select an image, then we'll SAVE. As we don't have given any feedback to the user, let's just wait a few seconds, then get back to our Firebase console. This time, let's open the database, and we can see that the image path is right there. Very well done. You now know how to upload images to Firebase Storage. Now we need a little feedback for our user. We want to show the image both in the DealActivity and in the ListActivity, and that's what we are doing next.

Showing Images with Firebase Storage
In order to show the images in our app, we'll use the Picasso library, which is an open-source project, both lightweight and incredibly easy to use. If we had to load an image writing our code from scratch, we would have to deal with a lot of issues, asynchronous loading, caching, resizing. Fortunately for us, there are a few great libraries that do all the hard lifting for us. One of those is Picasso that provides caching, a placeholder while the image is still downloading, resizing, visual effects, like cropping, centering, and scaling. But the best part is, you only need a single line of code to use it. In the slide, you can see the most basic example of using Picasso. You just need to specify the context, pass the URL to the load method, and point to the image view you want to load the image into. Let's go to the Picasso Project home page at the address above, and there we'll copy the Gradle string to compile in our project. Let's place it under the Firebase compile statements, and sync our project. In the DealActivity, first let's create a variable that will contain the ImageView, and let's call it imageView to be original. In the onCreate method, let's set it to be the imageView of our layout, which we called image. Now let's create a method that we'll call showImage. This will take a string URL as an argument. For the most basic image load, we only need one line of code, but in this case, we want to resize the image so that it takes the width of the screen horizontally, and two-thirds of it vertically. This is far from perfect, but it should work decently for most devices, as long as they are positioned vertically. So if there is a URL and this URL is not empty, we'll get the width of the screen through the resources object. This is a class for accessing an application's resources. We call the static getSystem method, and over that, the getDisplayMetrics that has a property called widthPixels, which contains the width of the screen. This value we'll pass to a width variable. Now let's use Picasso. We'll pass the context, the URL of the image, we'll call resize, passing the width, and then two-thirds of it for the vertical size, then we'll call the centerCrop method and assign the imageView to show the image. Now there are two places where we need to show the image, one is where the user adds it to the travel deal, and the other when this activity's created. So let's call the showImage method from the onSuccess, that's where the image is chosen by the user, and then from the onCreate when the user gets to this activity from the ListActivity. Okay, let's see if it's working. We'll choose a deal, then choose an image, and SAVE. Then let's get back to the deal and you can see that it's actually working. There's one more thing. We'd like to show a thumbnail of the picture in the ListActivity as well. So in the DealAdapter, let's create a variable for the ImageView, calling it ImageDeal. Then in the DealViewHolder constructor, let's retrieve it from the layout. Then let's create a showImage method here as well. So if there is a URL and this URL is not empty, we'll pass the context, the URL of the image. Here the size will be smaller, let's say 80 pixels, both in height and in width, and we'll also be using the centerCrop method here. Now let's call the showImage method from the bind method. And let's try this out. Maybe the thumbnail is a bit small. Let's change width and height to 160 instead of 80. Okay, and let's try this again. As you can see, everything's working great, except if we turn the screen, hmm, this is ugly. A very quick fix for that is making sure our users cannot change the screen orientation. It's probably not the most elegant solution, but I leave it to you to design an activity that responds to changes in the screen orientation. So, let's get to the AndroidManifest file and make sure the orientation stays vertical using the screenOrientation property and giving a value of portrait. We'll do this for both activities. If we try this now, you'll see that the orientation will stay the same, even when we rotate the device. This is what we wanted here. Next, we'll see how to delete a file with Firebase Storage.

Deleting an Image from Firebase Storage
Now we can add images to the Firebase Storage, but when we delete a deal, the image stays there. So when an administrator deletes a deal, we also want to delete the file from the storage. Deleting a file from the storage is rather straightforward with Firebase. First, you get a reference of the file you want to delete, passing the name of the file, and then you call the delete method over the reference. This will return an asynchronous task so you can add an onSuccessListener and an onFailureListener over that. The thing is, we don't have the name of the image in our deal object. We have the link of the image yes, but not the name. So first, we need to add it to the TravelDeal class. We'll begin with a private variable that we'll call imageName. Then we'll create getters and setters using the Android Studio refactoring features. And then we'll add it to the constructor, and we'll call the setter method from there. When we save the file, we'll need to add the imageName to the deal. So let's get back to our deal activity, and in the onSuccess method of the listener, let's create a string variable that we'll call pictureName. In order to get the value from the taskSnapshot, we'll call the getStorage method, and then getPath. Finally, let's also set the deal with the pictureName. Just to show the difference between the two values, pictureName and Url, let's log both of them so that we can have a look at those two strings. Now let's get to the deleteDeal method. If the deal. getImageName is not null or empty, first we'll get a storage reference that we'll call picRef that will get the picture reference with the imageName. Then let's call the delete method on the reference, and here we'll add an onSuccessListener with a new onSuccessListener, and an onFailureListener with a new onFailureListener. In the onSuccess, let's just log a success message, and in the onFailure, let's log the error message we receive. Now we are ready to try this out. And as you can see from the logs, it works.

Limiting Access to Files: Storage Rules
Just like for data, your user's file must also be kept secure. By default when you set up storage, any authenticated user can read or write in the storage space. For our travelmantics app, a malicious user could delete the beautiful pictures of our travel deals for instance. There are many cases where you'd want to limit read access as well. Imagine a user sending their ID or passport, or some other private information. Their data should be kept secure. Just like with the Firebase Realtime Database, Firebase Storage also has security rules that allow to limit access to resources for your app. The thing is, even though they work with similar concepts, the rules for Firebase Storage use a very different syntax, so we won't be able to use the same rules we used for the database for the storage. That was the bad news. The good news is that they are just as easy and powerful, even more so probably. So let's have a look at how they work. From the Firebase console, let's go to the Storage section, then let's click on the RULES link. Here we find the default rule for storage. This rule is divided in two parts. Generally speaking, you won't need to modify the first two lines of the rule. Service firebase. storage means that, well, these rules apply to the storage service, and match /b/bucket/o, the second line is your storage space. Google calls your Firebase Storage space your bucket, as here we are writing rules for the Firebase Storage and our project, well, you won't need to touch those two lines, so everything we'll write will be from the next line. The concept here is very simple. Whatever rule you want to add, it must match a path. With match, you choose the path where you want to apply the rule, and with allow, you specify which actions you want to allow in the specified path. Combining match and allow, you have a powerful tool to deal with authorization in your app. In the default security rule here, you have curly braces, allPaths= and two asterisks. The allPaths word is just a wildcard and equals two asterisks means that you allow this rule to be many levels deep. So not only this will match the first level, let's say your folder called deals images, but also any other folder inside that. Within this match, we say allow read and write if request. auth is not null. Notice that we can write both read and write in a single line, and also that auth is not a top-level variable, but it's included into the request variable that contains all the data of the request to the storage. Okay, what can you write after match? You can specify a specific file with its full path. So if we write deals_images/rome/jpg, all the rules we write inside this match will only apply to the specific image, or you can use a wildcard or variable. To specify a variable, you use curly brackets. In this case, the rule will apply to each file in the dealsImages folder, but not to any subfolder you might add after dealsImages. If you want to apply your rule to any subfolder of the dealsImages folder, you can add an =**, just like we saw before inside the curly brackets. In this case, the rule will apply to any file in the deals image folder, and any file in any subfolder you might want to create under that. Okay, now that we know how to deal with match, let's get to the second important part of the rules, which is allow. After allow, you have two actions you can specify, read and write. You can also specify both of them at once with read, write. After that, you have an if condition. If what comes after the if is true, then the action, read or write, will be allowed. If it's false, it won't. So here you'll allow read and write to anyone, both authenticated or not. And in this second example, read and write are always forbidden for anyone. So what else comes after the if condition? There are two main objects you can access, resource, that refers to the data that exists in the storage, and resource. name, resource size, resource. contentType, and request. This is very important because request also includes the auth object, which is the information about the authenticated user. Request also contains information about the resource you are trying to access. So you might wonder what is the difference between resource by itself and resource in a request object. Well, the difference is that resource by itself points to files that already exist in storage, and resource and request refer to objects you are trying to upload. Now we are ready to write the rule we need in our project. Remember, we want authenticated users to read files and administrators to be able to write. From the storage rules, we can't access the Firebase database. So what we'll do is the following, we'll create a function. We'll call it isAdmin. This is actually something you can do in the rules. This will return true if the user is an administrator. And how can we check that? Well, from the request, we get the auth object that contains the unique identifier of the user making the request, UID. If this UID is in the UID of Clark Kent that we can copy from the database, then this is an admin. Now that we have this function, we can use it in the rules. So for all the paths we will allow the read action if the user is authenticated, and we'll allow the write action only if the user if both authenticated and isAdmin returns true. And that's it. Now our security is complete for the storage as well. So before making sure the upload button gets hidden, let's see if we can upload an image without being and administrator. So let's click on the Upload button, choose an image, and if we go to the logs, we can see that we are not allowed to write. If we log out and log back in as our administrator, and repeat, this time we can actually upload the image, and this is what we wanted to achieve here. Okay, one last thing. If the user is not an administrator, let's make sure the upload button is hidden as well. And with that, our travelmantics app is now complete. Very well done. Let's briefly recap what we did in this module. We've seen that Firebase Storage is a great tool to store files for your apps, and we've seen how to create folders, upload, and delete files. Then we've seen how it's possible to implement security within the storage with rules. We've seen how to use match, allow, and the request and resource objects. Thank you for following me up to this point. I really hope you enjoyed this course. If you did, have a look at my other Android courses here on Pluralsight, and please write a comment. If not, feel free to write a comment as well. Any feedback is more than welcome. Good luck with your next great apps, and keep coding.

Course author
Author: Simone Alessandria	
Simone Alessandria
Simone Alessandria wrote his first program when he was 12: it was a text based fantasy game for Commodore 64. A few years later, he is now a trainer (MCP), author, speaker, passionate software...

Course info
Level
Beginner
Rating
4.7 stars with 19 raters(19)
My rating
null stars

Duration
2h 15m
Released
20 Apr 2018
Share course

