Exposing Data and Information Outside Your Android App
by Jim Wilson

Android allows apps to extend beyond reach of their traditional boundaries. In this course, you'll learn how to capitalize on these capabilities through the use of Content Providers, notifications, and PendingIntents.

Looking to create opportunities by expanding your Android applications and users beyond all traditional boundaries? In this course, Exposing Data and Information Outside Your Android App, you'll learn how to create opportunities for both applications and users to engage with your app's content in ways that extend beyond the traditional app experience. First, you'll explore how to centralize data management using a Content Provider and make that data available to other applications. Next, you'll discover how to access Content Provider data using a CursorLoader and content URIs. After that, you'll learn how to modify data through a Content Provider including associating URIs with individual table rows. Finally, you'll cover how to interact with users through notifications, including how to create expandable notifications that provide comprehensive display information, and allow users to launch app activities directly from the notification through the use of PendingIntents. By the end of this course, you'll have the skills and knowledge to create your own Android applications that provide rich data and user experiences that extend beyond the traditional reach of applications.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Intermediate
Rating
4.9 stars with 14 raters(14)
My rating
null stars

Duration
2h 56m
Released
5 Oct 2017
Share course

Creating a Content Provider
Introduction
Welcome to the Pluralsight course, Exposing Data and Information Outside Your App. This is our first module, Creating a Content provider. My name is Jim Wilson. Throughout this course, we're going to learn how to create opportunities with applications and users to engage our app's content and ways to fall outside of the traditional app experience. Now the traditional app experience users directly interacts with our app. A user can see an user app activities, and through the user experience provided by the app's activities, the user can view and interact with our app's data. So conceptually, I have to think of this direct app interaction as a user working within our app's bubble. Now generally speaking, this direct interaction is the primary way that users experience an app's content, but there are many scenarios where it's used to make some of part of the app's content available even when a user is not directly interacting with the app. In other words, it's sometimes useful to make our app content available outside of that bubble. Well throughout this course, we'll see some of the ways that Android allows us to do that. The first solution we'll look at in this course is something known as a content provider. Now we sometimes use content providers within our apps to centralize data management and data storage details. The content provider interacts directly with the data store and then other parts of our app can access data through the content provider, which then shields those parts of the app from the details of data storage and management. But in addition, a content provider can be exported. Now once exported, our app's data can then be accessed from other applications. So with a content provider, other applications can read and modify our app's data in a way that's controlled and secure. And then once we finish up with content providers, we'll look at another way our app can expose content outside of the traditional app experience and this is one you're likely familiar with, user notifications. User notifications are the way the application display messages or alerts. They're a great way to provide the user with information, even when the user is not directly interacting with your app. For example, Gmail uses notifications to indicate when a new message has arrived. And then we'll finish up the course with something called pending intents. Pending intents allow our applications to delegate actions. For example, we can create a pending intent that contains information about displaying our app's main activity. We can then pass that pending intent outside of our app, for example, we can pass it out to the notification system, and then in response to a user action, a notification system could then use that pending intent to start our app's main activity. Alright, so as you can see, we have a lot of great stuff ahead. So to get us started, in this module, we'll get content providers. So we'll first look a bit closer at just what a content provider is, we'll then see how to implement a content provider, we'll see how to request data from a content provider, and then we'll finish up with a look at how we can use our content provider to share data between apps.

Content Provider Overview
To get us started, we'll first look at a definition of a content provider and then we'll break down what that definition means. So a content provider is an Android component that encapsulate data, exposes that data to a standard interface, and optionally, makes that data available to multiple programs. So let's look at what that actually means. Well fundamentally, a content provider is a way to expose data. The key is, though, it's a standardized way to expose data, and so it gives us a standard way to expose data, but gives us a lot of control over the visibility. So we create a content provider, we can limit its visibility to only the application that implements that content provider, or you can actually make the content provider visible to other applications, so it's a way for one application to share data with other applications. Now something that's very important to remember is that the concept of content providers is independent of data storage. So content providers have nothing to do with data storage. So a content provider might serve up data that's stored locally, another content provider might serve up data that's stored remotely like off in web service, yet another content provider might take some local data and some remote data, merge them together, and then serve that up. Now many content providers will serve up data that's statically stored, but some content providers will actually dynamically produce that data. So when a request for data comes in, it might actually programmatically put together things and then serve up the results of that programmatic action. The key is that content providers encapsulate those details, so we just serve them up as a content provider and the consumer of that content provider is not at all concerned with how that data was stored or produced. Now a question that likely comes to mind is well how do content providers and SQLite compare to one another because we spent that whole last course talking about SQLite and that was a data solution. And now we're choosing content providers and that's a data solution. And so, it's important to understand that they actually do kind of two distinctly separate things. Alright, if we look at SQLite, SQLite is a data storage and management solution. Alright, so it actually identified how we store our data and we want it to gather the data in a SQLite database, we actually use the SQLite library or a library specific to SQLite to access that data, and that data was accessible by our own application. So our application created that database for our own purposes. Now a content provider, again, has nothing to do with storage. Content providers are a data access solution, they're a way to expose data and a way to expose that data in a standard way, and using content providers, our application can actually expose that data, not only to our own application, but can also make it available to other applications. Alright, so now in our next clip, let's take a look at a way content providers are most commonly implemented.

Content Provider Common Implementation
As we mentioned, content providers are independent of any specific type of data storage. They can serve up whatever kind of data you need to serve up. But when we implement content providers in our own applications, most commonly we implement them in conjunction with SQLite. Because remember that content providers in SQLite do distinctly separate jobs. SQLite is about data storage, so we use SQLite to provide our backing store. Remember that content providers are about data access. They allow us to encapsulate the storage details of that data and they allow us to share data with other applications if that's what we'd like to do. So let's take a look at the application we've been building throughout this course series. Remember, in the previous course, we've updated our application, now I'll work with a SQLite database. It has two tables in it, a note_info table that contains our note information, and our course_info table that contains our course information. If we look at our note activity, which we used to display a single note, well I got that note from the note_info table. Remember, that activity also has a spinner that shows a list of courses and it gets that list of courses from our course_info table. So then we have our main activity. Remember our main activity got the list of nodes from the note_info table. Remember that our note_info table didn't contain the title of the course, so we actually had to do a join against the course_info table to be able to display the title of the course that's associated with a note. So what that means now is that both our note activity and our main activity is directly dependent on the current structure of this database. If we were to start making significant changes to the structure of that database it would affect the note activity and it would also affect the main activity because they're querying directly against the currently stored format of that database. Now in addition, remember that our database file is private to our application, so activities belonging to other applications can't access that database. Now that's good from a security standpoint, but it does create some challenges of when to share data from our database with other applications. So let's look at how content providers affect this. So what we'll do now is rather than have our activities go directly to the database, I want you to use a content provider. The content provider will actually be the one that directly accesses the database and then we'll make data from that database available to our activities. So our note activity will get its data from the content provider and the main activity will get its data from the content provider. So now with this model, the content provider is shielding the activities and the storage details of the database. So now if we make changes to our database, and even if we significantly restructure those tables, as long as we update the content provider to understand that new structure and it keeps presenting that data in a consistent fashion, the activities are fully shielded from those details, so we don't have to make any changes to the activities. In addition, content providers can be exported, which means they can become visible to other applications. So data from our database can now be shared with activities in other applications. Now all of their access will still pass through a content provider, so they're not directly accessing our database, so we still have a lot of control over what they can do, but allows the shared data from our application with other applications. Alright, so now in our next clip, let's take a look at what's involved in creating a content provider.

Creating a Content Provider
When we want to implement a content provider, what we're going to do is extend the Android class named ContentProvider. Now it's important to understand that content providers are components much like activities are components, so content provider actually has a lifecycle to it. So when we implement our class, we're going to have to implement our lifecycle methods like onCreate. Now content providers support data lookup, so we'll need to implement the data lookup method. And content providers allow modification, so we'll need to implement our data modification methods. When the really important aspects of creating a content provider is the content provider's identification. Remember the content provider may be visible throughout the device and you can never know what other applications might be on a user's device. So what that means is that the identification for our content provider must be globally unique, so it must be identified in a way that will not collide with anyone else's content providers. So the way we do that is by associating an authority with our content provider. Now authority uniquely identifies our content provider and the way we specify an authority is by using reverse domain name format. And as you may recall, reverse domain name format is the same way we name Java packages. So normally what we'll do is we create a content provider, the authority for our content provider will be whatever our package name is followed by. provider. So if we look at the application I've been working on throughout this course series, the packaging for my application is com. jwhh. jim. notekeeper. So the authority for my content provider will be com. jwhh. jim. notekeeper. provider, so that's the authority we'll associate with my content provider. Now a key decision we need to make about our content provider is the visibility to other applications and you want to be explicit about this decision because the visibility defaults to different values depending on the version of Android you're on. On older versions of Android, content providers default to being visible to other apps. On newer versions of Android, they default to being not visible to other apps. So what we want to do is set the exported value for our content provider. We say is exported is true, then our content provider is visible to other applications. If exported is false, our content provider is not visible to other applications. So now in our next clip, we'll create a content provider for our application.

Adding a Content Provider to Your App
Here we are in Android Studio and we have our NoteKeeper project open. Now this is the same project we've been working on throughout this course series and the project is exactly the way we left it at the end of the previous course. So what we want to do now is add a content provider to our project. So to do that, we'll go to our File menu, we'll choose New, and then option we want is way down there towards the bottom, it's Other. So here in Other, now we want Content Provider, so we'll choose that. So now the first thing we need to do is provide the name for our ContentProvider class and let's call ours NoteKeeperprovider. Now we need to associate an authority with our provider. Since our app's package name is com. jwhh. jim. notekeeper, we'll use that as the start of the authority, and then we'll add. provider to the end of it. We want other apps to be able to use our provider, so leave both exported and enabled checked. Exported means that our content provider is visible to other apps. Enabled simply means that the system can start our content provider if it needs to. Alright, so that's all the information we need to provide. So let's go ahead and click Finish, and as you can see, it created our NoteKeeperProvider class. And since our class implements a content provider, it extends the entry framework class, ContentProvider. Alright, now with that, we have our ContentProvider class in place. In our next clip, we'll start doing the implementation.

Implementing a Content Provider Over SQLite
As we talked about, we create a content provider, we must commonly implement that over top of SQLite and that's exactly what we're doing with our content provider. Now when we're creating our content provider, there is a few things we want to keep in mind. Remember that the content provider should encapsulate all database related details. So the content provider is responsible to handle the details of connecting up to the database and it's going to perform all database related interactions. Now when we're implementing our content provider, the methods that we expose from our content provider are very similar to the methods that are exposed by the SQLite API. For example, when you want data from SQLite, you call the SQLite query method. When we want to provide data from our content provider, we implement the content provider's query method and the content provider query method and the SQLite query method are very, very similar. So in general, what we'll do inside of our query method implementation for our content provider is delegate the bulk of the work down to SQLite. To give us a better understanding of how all this works, in our next clip, we'll start implementing our content provider's query method.

Adding Simple Query Support to Your Provider
Here we are back in Android Studio. We're currently looking at our NoteKeeperprovider class. Remember that this class serves as our application's content provider. What we want to do now is add the code necessary to allow our content provider to handle a simple query. As we talked about, the content provider is going to handle all the direct interaction with the database. So to interact with the database we'll, of course, need to connect to the database. So just as we did in our activities, we'll use our OpenHelper class to handle the details of connecting to the database. So the first thing we'll do is add a NoteKeeper open helper field to our content provider and we'll name it mDbOpenHelper. That gives us our open helper field. Let's scroll down now to our onCreate method. So here we are on the onCreate method. So the first thing we'll do is just get rid of this comment here. Now here in the onCreate is where we want to go ahead and create that instance of our open helper. Now as you recall, when we're using our open helper with activities, we created the instance of the OpenHelper and the activities onCreate method. We're going to do the same thing for our content provider. So we'll say mDbOpenHelper = new NoteKeeperOpenHelper. Now remember that our open helper constructor accepts a context reference. Now unlike with an activity, we can't pass a content provider's disk reference as a context. Instead, we access the context for a content provider by calling its getContext method. With that, now our open helper is all set, but we do have one more issue to address before we leave the onCreate method. Now this is the onCreate method currently returns false. The onCreate return value indicates whether the content provider was successfully created. We want to indicate that our content provider has been successfully created. So instead of returning false, we'll return true. And now that takes of creating our content provider. Next thing we need to look at is how to implement a simple query. So when data is requested from our content provider, that request is going to be handled by our query method. You can see our query method here just below onCreate, and if you take a look at the parameters, notice that most of them are very similar to parameters we passed at the SQLite query method. Let's skip over the first parameter for now. We'll come back to that one a little bit later in the course. But now notice the second parameter, the one named projection. That one is a String array. Now as you recall, a String array is how we pass the list of columns to the SQLite query method. Well that's exactly what the projection parameter is for, it receives the array of column names that we need to return. Now the next two parameters, selection and selectionArgs, those contain our selection criteria. And then finally, the last parameter contains the sortOrder. Notice also that the content provider query method contains a Cursor and that's the same type of return by a SQLite query method. So ultimately, what all this means is that the bulk of the work of our content provider's query method can be delegated down to the SQLite query method. So the first thing we'll do is get rid of the code that's currently inside of the query method. Since our query method returns a cursor, let's declare a local variable name Cursor of type cursor and we'll initialize it to null, and then we'll just go ahead and return back that cursor variable from our query method. Now in order to query our database, we'll need a SQLite database reference. So let's call our OpenHelper's getReadableDatabase method and we'll assign it to a local variable. So that gives us a reference to a SQLiteDatabase, our local variable db. So now let's call our db. query method and let's assign its result back to our cursor variable. And from this point, we're just querying the database as we normally would. Since we're starting out by having our content provider queries all query our course event table in our database, the first thing we'll pass to the database query method is the table named constant from our CourseInfoEntry class. The rest of the parameters that we passed at the database query method will all come from parameters passed to our content provider's query method. So for the list of columns, we'll pass in the projection parameter, then for the selection criteria, we'll pass in selection and selectionargs, we'll pass null for next two parameters, and then we'll pass in sortOrder as the final parameter. And with that, our content provider can now handle queries. Return back a cursor from our CourseInfo table containing the list of request to columns. The cursor will contain only those rows that meet the past selection criteria and the rows will be ordered in the requested order. So we're off to a great start, but now the question is, how do you issue a query to this content provider and that's what we'll look at in out next clip.

Requesting Data from a Content Provider
Now we're ready to start requesting data from our content provider. Requesting data from the content provider is very similar to querying SQLite directly, like we're going to follow all the same general guidelines. So one of the things we want to really remember, so we never want to issue those queries directly from our application's main thread. Instead, we're going to continue to use the CursorLoader class because remember that the CursorLoader class knows how to run queries on a background thread for us and it knows how to cooperate with a lifecycle of our activities. And we're going to continue to initiate the query process using a LoaderManager because remember that the LoaderManager knows how to coordinate what goes on inside the loader with the lifecycle of our activity. Now when using the CursorLoader class with a content provider, our job actually gets a little bit easier because the CursorLoader class actually understands how to query content providers. So what that means is that we'll no longer need to overload the loadInBackground method. Instead, all we have to do is construct the CursorLoader and pass in the identifier for our content provider. And then the CursorLoader will take care of the details of locating the content provider and issuing the query. The way we identify our content providers is by using something known as a universal resource identifier, and more commonly what's known as a URI. And URIs look very much like URLs. URIs start with a scheme and in the case of content providers, that scheme is content. So our URI will begin with content:// and then it needs to include the authority of the content provider. So in our case, our URIs will be content:// then com. jwhh. jim. notekeeper. provider, and then constructing a CursorLoader with that identifier allows it to find our content provider. So now in our next clip, let's modify our application, start using data returned from the content provider.

Loading Course Spinner from Content Provider
Here we are back in Android Studio. We're currently looking at the query method of our NoteKeeperProvider class. Now as you recall, the way we currently have the query method implemented, it always queries our SQLite database's CourseInfo table. With that being the case, we can use this content provider anytime we want content from that table. Now one case where app uses the CourseInfo table is when populating the course selection spinner in our node activity. So let's head over to our NoteActivity class and start making the appropriate changes to populate the spinner from our content provider. Here we are over in the NoteActivity class. We're currently looking at its onCreate method. In our previous course, we did the work to populate the course selection spinner directly from the SQLite database and we did that using the LoaderManager and a CursorLoader, although the same things we need to populate the spinner for our content provider. So with that being the case, all we need to do is make a few adjustments to our existing code, we can then populate the spinner from the content provider. So you can see that in the onCreate method, we get a reference to the LoaderManager and calling it Loader passing in the LOADER_COURSES constant. So that call to initLoader will trigger a callback to our onCreateLoader method, so let's scroll down there. So here's our onCreateLoader method and you can see where I receive the constant for Loader_Courses, we then call our method createLoaderCourses. So scroll down just a bit so we can see all of that method. So here in our CreateLoaderCourses method, the way it's currently implemented is we extend the CursorLoader class and overrides its loadInBackground method. Then inside of there, we directly query the database. Alright, so that's where we query our CourseInfo table, we specify a list of columns, and we don't provide any selection criteria, but we do indicate that we want it ordered by the course title. So what we want to do now is issue that same sort of query, but do it using the content provider. So now, to make the query to the content provider, the first thing we need is a URI for our provider and we'll do that with the URI class. So let's declare our local variable named Uri of type uri. So as you might expect, the URI class represents a universal resource identifier. Now we want to provide our URI value with a string. So the URI class has a static method named parse, so let's call uri. parse. Remember that the identifier for our content provider starts with a scheme content, so we'll start this out with content:// and then we provide the authority for our content provider. So now with that, we have the Uri that corresponds to our content provider. So now the next we need to do is identify the columns we want back from the content provider and those are going to be the same columns we used when we query the table directly. So we'll go ahead and highlight the courseColumn string array that we used earlier, so we'll copy that and then we'll paste it in directly below the variable for our URI. So once we have the URI in our columns, we can now just go ahead and create a new instance of a CursorLoader because the CursorLoader class has a constructor that accepts parameters for everything we need to provide. So we'll say here is returned new CursorLoader, we need to provide it with a context, so we'll pass in this, we then pass in the identifier for the content provider, we pass in our list of columns, if we wanted to specify selection criteria, we'd pass in the selection clause and the selection arguments, but since we don't have a selection criteria, we'll just pass in two nulls. Then the last thing that we need to provide is the sortOrder and that's going to a column course title constant from our CourseInfoEntry class. Alright, so let's get rid of the old code we had here and now our createLoaderCourses method is all set. We've identified the content provider that we want, we have our list of columns, and we specified the sortOrder. The CursorLoader class will take care of all the rest of the details of locating our content provider initiating the query. So let's go ahead and run this guy and see what it looks like. Here we are now with our application running in emulator. Now I've added some breakpoints to our code so we can see what happens as we go through this process of querying for the data. I'm going to go ahead and click on our new note button, which will start our note activity. So you can see we've hit a breakpoint back in Android Studio, so let's switch back there. So you can see here, we're in the note activities createLoaderCourses method. First of all, we're creating the uri instance that identifies our content provider. Let's go ahead and step, we get our list columns, so we'll step again, and now we're about to create our CursorLoader. So let's go ahead and release this. Now you can see here as soon as I released it, it went back to our content provider's query method. So creating the CursorLoader took care of the details of beginning this process administrating the query on a background thread, identifying our content provider, then calling into our query method. So if I step now, the content provider is connected to the database, step again, it issues the actual query against the database and it's about to return the cursor that came back from that query against the database, so let's go ahead and release it, and you can see here, when I released it, we're now back in our NoteActivity and were in the onLoadFinished method. Remember that this is the method called by the LoaderManager when the cursor is available. A Cursor is passed in as the second parameter, the one named data. So let's go ahead and step, we check the id, it shows us the one that goes with our courses, so we'll step again. You can see now that we're about to associate the cursor that came back from our content provider with the adapter associated with our spinner. So let's go ahead and release this. So now we're back in our emulator looking at our note activity, and if I expand the spinner, you can see it's fully populated with a list of courses. So our spinner has now been populated with data that came back from our content provider. So the note activity requested data from the content provider, the content provider got that data, returned it back to the note activity, and note activity successfully populated the spinner. Alright, so now the basics of our content provider are now working just fine in our own application. So now in our next clip, let's see how we can use the same content provider to take data from our NoteKeeper application and make that available to another application.

Loading Course Data from Another App
Here we are back in Android Studio and what we want to do now is use our content provider to share data from our NoteKeeper application with a separate application. Now as we'll see, because we have a content provider in place, accessing our NoteKeeper data from this other application is just as easy as it was when we were accessing that data from within the NoteKeeper application. Now as you look at Android Studio, you'll notice that this is not our NoteKeeper application. This is a very simple application that I've created that we'll use throughout this demo. This application has a single activity. As you look at the layout resource, you can see it contains a ListView. So what we want to do is go through our NoteKeeper's content provider to populate this ListView in this application with a list of courses. So let's go ahead and close the Project view so we have some more room to work and let's switch over to our main activities, so we'll switch over to the source code to populate this activity. So remember now in order to access our content provider, we're going to have to use the LoaderManager and we're going to use a CursorLoader. So I've done some initial work in our main activity class in this application to get us ready to do that work. So you notice that our main activity class implements the LoaderCallbacks interface, so that means we'll have all the methods we need to get callbacks from the LoaderManager. Notice I've defined a constant here that will identify when we're issuing a query for the courses from our NoteKeeper application, and I've also got a feel for a SimpleCursorAdapter. Now let's scroll down here just a little bit. So here we are on the activities onCreate method and notice here towards the bottom, we go ahead and create an instance of the SimpleCursorAdapter, we're using one of the built-in Android layouts, and I've provided the information necessary to populate the ListView. We then get a reference to the ListView and associate the adapter with it. So now what we want to do is add the code onCreate to initialize the process of issuing the query. So we'll call getLoaderManager initLoader, we'll pass in the constant for our query, we'll pass in null for the second parameter and then this. So now we're simply saying that we want to initialize the loader that corresponds to that constant, I want the callbacks to come back to our current activity. So now remember that the first callback that gets called is onCreateLoader, so let's scroll down to that. So here we are in the onCreateLoader method and what we need to do in here is create our CursorLoader. But now remember that we're getting our data from a content provider, so we need the URI of that content provider. So let's declare a local variable named Uri of type uri, we'll use the URI classes static method parse. So this is going to be the URI of our NoteKeeper Application's content provider and the URI for that content provider is the same whether accessing it from within the application or from another application. So we'll start out with the scheme content and then we'll provide the authority for our NoteKeeper content provider. Red tag gives us a URI for the content provider. The next thing we need is the list of columns, so let's create a string array named columns. So now we want to provide the names of each of the columns we want back. Now remember that we're in a separate application from our NoteKeeper class, so this application can't see the Contract class we created over in our NoteKeeper application. So what we'll need to do for now is just provide the literal column names. We'll talk a little bit later in this course about how we can address that in a better way. So now remember that we're using our cursor adapter, want to be sure to get the _id column, and then we'll go ahead and get back the course_title and the course_id. Alright, so we've identified the content provider and we have a list of columns. So now, we can just return back a new CursorLoader instance. It needs a context, so we'll pass in this reference. We'll pass in our identifier and our columns. We want to get all the rows back, so we'll pass in null for the selection clause and the selection arguments and we want the rows to come back in alphabetical order by title, so we'll pass the literal name of the course_title column. And that's all we need to do in our onCreateLoader method and you'll notice that I didn't have to provide the literal column names. The code to get back the data from our content provider in this application is exactly as it was in our NoteKeeper application. Android takes care of all the details of connecting up our content provider with our CursorLoader and it manages any differences from doing it within the application or from another application. So when we get the data back from our content provider, the LoaderManager will then call our onLoadFinished method and what we need to do in there is associate the cursor with the adapter that populates our ListView. So we'll say mCoursesAdapter. changeCursor. Our onLoadFinished method receives a reference to the cursor and its data parameter, so we'll just pass data to changeCursor, so that'll associate the return data with the adapter, which in turn will then populate the ListView. Then the last thing we need to do is go to our onLoaderReset and then call changeCursor for our adapter passing in null so it closes up the cursor. Alright, so that takes care of all the work we had to do to issue the query to our content provider to get back the list of courses and display them in the ListView. So now in our next clip, let's test all this out.

Verifying Data Interaction from Another App
Here we are back in Android Studio, and what we want to do now is test out the code we added in the last clip. Remember that we have this new application, application named OtherApp that wants to request data from our NoteKeeper application. So here in our OtherApp application, I've added some breakpoints so we can see what happens during the requesting of the data, but before we start this running, let's switch over to the Android Studio with our NoteKeeper application. So here we are in a separate instance of Android Studio where I have our NoteKeeper application and in this instance of Android Studio, I have a breakpoint inside of our content provider's query method. So let's go ahead and start our NoteKeeper application running. So our NoteKeeper application is now up and running in the emulator. Let's switch back to the Android Studio that has OtherApp open. So now, let's go ahead and launch OtherApp. So now as soon as I launch OtherApp, we have the breakpoint I put into the onCreate method where we call initLoader, so let's go ahead and release this, that then takes us into our onCreateLoader method, we've hit the breakpoint, we're going to create our CursorLoader, then go ahead and release it again. So now when I release that, we then need a breakpoint, but that breakpoint is now over in the Android Studio instance as our NoteKeeper application open, and it's inside of our NoteKeeper provider. So what's actually happened is that Android has done all the work to communicate between these two separate applications and we launched the cursor loader in OtherApp, Android took care of the details of a locating the content provider that was identified by that URI, it routed the request to the content provider in our application. Now in this case, our application was already running, but if it wasn't already running, Android would have done the work to launch your application so the content provider could be available. So that request has now come into our query method within our content provider, so let's go ahead and step through here. So we'll go through and step through, that connects to the database, we do the query, and now we have our cursor, so I go ahead and release this. So now as soon as I release the NoteKeeper application, we then hit the breakpoint in our OtherApp application and this is our onLoadFinished method. So the activity in OtherApp just received back a cursor that was created by the content provider in our NoteKeeper application. So our NoteKeeper application is passing data back to our OtherApp application. Now I'm going to go ahead and release this. So here we are on the emulator and you can see that Other App is running and it's showing the course information in its ListView, so it's showing course information that came from our NoteKeeper application. One thing that's important to understand, even though in this demonstration, I manually launched NoteKeeper and then we went over and launched OtherApp, even if NoteKeeper had not been running, Android would have taken care of starting that process for us so it could get access to the content provider. So a question that comes to mind is how is Android able to locate the content provider in our NoteKeeper application. So let's switch back to Android Studio and take a look at something. So here we are on the Android Studio instance for our NoteKeeper application. Now let's go over here in the Project window. Now notice in the Project window of the Android you selected, let's go ahead and expand the entry here which says manifests and let's choose our AndroidManifest. xml. Alright, that opens up our manifest and let's scroll down towards the bottom, and you'll notice here down towards the bottom, there's a provider element that identifies that it's a content provider that implemented in our class NoteKeeper provider and notice that it has the authorities entry and it has that com. jwhh. jim. notekeeperprovider. And so that identifies that our class NoteKeeperProvider is the content provider for that authority. And remember that we marked this content provider as exported and exported meant that it was accessible to other applications and if you think way back to our very first course in the series and we talked a little bit about the manifest, remember we said that the manifest is how an application tells Android what it knows how to do. Now back in the first course in the series, we talked about that with regard to activities, but the information the manifest identifies capabilities of various components in an application. So what happens is because this entry is in our manifest, when our application is installed, Android takes note of that provider entry and says oh, there's a provider here that knows how to handle content requests for that authority, and whenever there is requests come through, Android looks at that and says that's the class that knows how to handle these requests and it takes care of routing the request into that class so that class can then return back the necessary data. Alright, and that's a very powerful concept in Android, the ability to use these content providers, not only provide data to your own application, but to allow your application to provide data to other applications.

Summary
To wrap up, here is some of the key things we want to remember from this module. Remember that a content provider is a standardize way to expose data and allows us to expose that data within our application, but it also allows us to expose that data across applications. Remember then when we think about content providers and data storage, content providers are independent of the specific way the data is stored. The idea is the content provider simply focuses on exposing the data and any implementation details like the way the data is stored is encapsulated within the content provider. So now when it comes to creating our content providers, we extend the ContentProvider class and we have to be sure to associate the authority with the content provider. That authority is usually based on the package that contains the content provider implementation. And then we want to explicitly decide whether we want our content provider to be available across applications because remember that the default for cross-application accessibility for a content provider varies depending on the Android version, and although a content provider can be used with any backing store we'd like to, we most commonly use them with SQLite. The content provider is responsible for making the data available, SQLite then provides the backing store, and by using SQLite as our backing store, SQLite will handle the query details, so we'll take care of the details of filtering and ordering the data. So now when it comes to requesting data from our content provider, it's very much like requesting data from SQLite. We rely on the loader manager to coordinate the access to the data and the lifecycle of our activity, then the actual query is issued with our CursorLoader, but when we use the CursorLoader with the content provider, it's actually easier than using a CursorLoader to access SQLite because all we have to do is create an instance of the CursorLoader passing in the URI for the data and then specify the specific columns, selection criteria, and return order that we want, and the CursorLoader class takes care of the details from there. Alright, so in our next module, we'll dig deeper into the user of URIs to identify and access content from our content provider.

Identifying Content Provider Content
Introduction
Welcome to the next module of the Pluralsight course, Exposing Data and Information Outside your Android App. In this module, we'll talk about identifying content provider content. My name is Jim Wilson. As our content provider is currently implemented, it always returns back the same table, which is our courses table. Now most content providers support returning multiple tables. So to do that, we have to have a way of identifying individual tables and then hit a request for those tables. So in this module, we'll see how to do all that. So we'll start out with a look at how content providers are organized, we'll then see how to create a Contract class for content provider, we'll see how to create URIs for individual tables, we'll then see how to handle matching those URIs, then we'll look at the details of URI request handling, and then we'll finish up with a look at how to add a table to our content provider that's actually an abstraction over the join of two tables from our database.

Content Provider Organization and Contract Class
Now as we've seen, content providers expose tables. Now normally though a content provider will not just expose a single table, it will generally expose multiple tables, and when you use the term table with a content provider, very often, that will correspond to an underlying database table, but remember that content providers are about data access, not storage structure. So a content provider can expose a table, which may not directly match the physical structure of the underlying tables. Now as you recall, when we work with our database we're focused on the structure of our data and we had to use a contract class to describe the structure of our data in the database, our content providers are about data access. So what we need is a way to describe the way data is exposed by the content provider. We need to identify what tables are available from the content provider and we have to identify what columns are available in each of those tables. So our content provider is also going to have a Contract class, but in the case of our content provider, the Contract class is focused on the public appearance of the data. We want to avoid any issue tied to physical structure. Remember that content providers focus on data access, so our Contract class is going to focus on data access. Now of course, one of the key aspects of data access with a content provider is the base URI for that content provider. Remember that base URI is our content provider's authority together with the scheme content. So within our Contract class, we're going to have each of our tables described in a nested class. So I'll have a separate class for each table, and again, this is focused on the public concept of a table. Again, it may tie to a physical structure of a database table or it may be some abstraction of a table that's presented by the content provider. So each of these classes will describe how to access a particular table, and of course, we'll include the column names that are available from that table, but also it needs to include the URI to access that individual table. So now we get into our table URIs, we're just building on the same concept of URIs we talked about earlier with regard to content providers. So it's going to start out with that scheme content, it will have our content provider's authority, right that's what we were talking about as our base URI for our content provider, and then we're going to append some path specific to the table. So in order to expose our course's table, we could support a path that ended in /courses. So when it comes to programmatically constructing these URIs, generally what I do is use the URI classes method, withAppendedPath, that makes it very easy for us to append a path for a table to the base URI that we already have for our content provider. Alright, so now in our next clip, let's start implementing the Contract class for our content provider.

Implementing the Contract Class
Here we are in Android Studio. We currently have our NoteKeeper project open. What we want to do now is set a Contract class for our NoteKeeper content provider. Now just like with a database Contract class, we'll create our content provider's Contract class a regular Java class. So to get us started, we'll go over here to the Project window, we'll find our package name, then we'll right-click on that, we'll choose New, and then we'll choose Java Class. Let's name our class NoteKeeperProviderContract, we'll mark it as final, then we'll click OK. Now to make sure that no one can create an instance of this class, let's go ahead and give it a private constructor. So now there are a couple of constants we want to include directly within our Contract class. Now the first one is going to be for the con provider authority. So let's create a string constant named authority containing our provider's authority. So that gives us the constant for our authority. So let's go ahead and add another constant now. This constant will be for the content provider's base URI and the base URI is simply the content provider's authority preceded by the scheme content. So we'll name this constant AUTHORITY_URI, we'll make it of type Uri. So now we'll assign the method as constant. Let's start with the URI class's parse method, we'll pass in the literal string content:// and then we'll concatenate our authority constant onto the end of that. So our Contract class now has one constant, which has the authority value in it and has another constant that includes the part of the URI that we'll use to create the specific URIs for individual tables. So now let's create nested classes for each of the tables that we expose with this content provider. Now for now, each of the tables that we expose will directly correspond to tables from within our database. So the first class we'll put inside of here will be for our course's table, so we'll make this a public static final class and we'll name it Courses. So now we want the data from this table to be available from our provider with the URI that includes the path, Courses. So let's go ahead and add a constant to this of type string and let's name it PATH and we'll give the constant a value of courses. So now the URI for this table will be a combination of the content provider's AUTHORITY_URI and the path courses. So let's add a comment to show what the full URI should look like. It'll start with our content scheme followed by our provider's authority and then we'll follow that with the path courses. So now let's go ahead and add a constant for this URI and it'll be of type URI and we'll name it CONTENT_URI. To provide the value, we use the URI classes with appended path method. So now for the first part of the URI, we want the scheme and our content provider's authority. Now as we mentioned, we already have that in our contract classes AUTHORITY_URI constant, so let's pass that as the first parameter to this method, withAppendedPath. And then for our second parameter, we'll pass our Courses classes PATH constant. With that, the CONTENT_URI constant from our Courses class can now be used to access our content provider's courses table. So now, let's do the same thing for our notes table. So let's go ahead and create a class called Notes. We'll provide a string constant named PATH of the value of notes and then we'll include a constant name CONTENT_URI and we'll set its value exactly as we did in the Courses class. Alright, so that gives us a contract class for our content provider and our contract class contains classes for the tables exposed by the provider and those classes each contain a constant containing the URI to access that table. So what we need to do now is identify which columns are exposed by each table and we'll look at how to do that in our next clip.

Describing Table Columns
Now as we talked about, each of the tables exposed by our content provider has a corresponding class in the Contract class and that class provides access information for that table, so it has the URI for that table and we said it also needs to have the names of the columns that are available through that table. So now what that means is that we need to define constants for each of those column names. Now one solution to that could be to actually define those constants directly inside of the table classes, but there is a bit more to consider here. The tables in our content providers will often have duplicated columns, and when I refer to duplicated columns, what I mean is that there is a column that has the same name and the same meaning and appears in more than one of the tables exposed by the content provider. So if we actually defined those constants directly in the table classes, that means we could end up with redundant constants, identical constants appearing across multiple table classes. It would be better to manage those column constants separate from the table classes themselves. So to address this issue, when we're working with our content provider contract class, we tend to put our column constants in interfaces and these interfaces group related columns together, and by putting these column constants in interfaces, it simplifies our organization and maintenance of these constants. It constantly refers to a column with a particular name that has a particular meaning only appears in one place. These interfaces are nested within our contract class, but the interfaces are not intended to be used directly outside of the provider, so we tend to mark them as protected. So now those constants are managed separately from the table classes, how do we associate the constants with the table classes. Well all we have to do is have each of the table classes implement the appropriate interfaces that contain the constants that correspond to columns that they expose. So to help us get a better understanding of how all this works, in our next clip, we'll start adding our column constants to our content provider contract class.

Adding Table Columns to Your Contract Class
Here we're back in Android Studio and what we want to do now is add column constants to our content provider contract class. And we've already created table classes within the contract class for both our courses and notes tables. And as we talked about in the previous clip, rather than add column constants directly to the table classes, when instead group those constants within interfaces. So to get us started, we'll add a nested interface to our contract class, we'll name the interface CoursesColumns, and we'll mark it as protected. Now as we mentioned earlier, we've marked this interface as protected because the only place the interface itself should be used directly is within our content provider implementation. So now let's add some string constants to the interface for the columns that are available from the courses table and we can use the same constant names we did in our database contract class, which were COLUMN_COURSE_ID and COLUMN_COURSE_TITLE. So that gives us our column constants for our courses table. So now let's do the same thing for our notes columns. So we'll declare protected interface name NotesColumns, then we'll go ahead and add the constants for the COLUMNS_NOTE_TITLE, note_text, and course_id. So with that, we have our notes related columns and our notes columns interface, we have our courses related columns and our CoursesColumns interface. So now we'll have our courses class implement the CoursesColumns interface. By implementing that interface, the Courses class now exposes the constants from the interface. So for example, if we wanted to access the course title column, we could simply type Courses. COLUMN_COURSE_TITLE. Alright so let's scroll down here a little bit so we can see our Notes class. So here we are at our Notes class. Let's go ahead and have it implement the NotesColumns interface. So now with that, our notes class now exposes the constants from the NotesColumns interface. So by implementing those interfaces, our Courses class exposes the constants for all the columns within the courses database table and our Notes class exposes constants for all the columns in our notes database table or do they. There is actually something missing from both of those classes. Remember that the courses database table and the notes database table each include the _ID column. Now the _ID column provides row identity, and as we know from our cursor discussions in the SQLite course, having the _ID column be available within a cursor is often very important. So we want to be sure that the courses class and the notes class both expose a constant for the _ID column. Now we could add a constant for the _ID column to the CoursesColumns interface, then add a separate constant for the _ID column to the notes column interface, but we don't need to do that. You remember from our discussions in the SQLite course that there is already an interface available that has a constant for the _ID column. That's the Android frameworks BaseColumns interface. So let's go ahead and implement the BaseColumns interface on the Courses class. So now, in addition to exposing constants for the course ID and course title columns, the Courses class also exposes a constant for the _ID column. The course id and course title constants come from the CoursesColumns interface, the _ID constant comes from the BaseColumns interface. So now let's add the BaseColumns interface to the Notes class. And with that, the Notes class will expose constants for the _ID column, the Note_Title column, the Note_Text column, and the Course_id column. Again, the constant for the _ID column comes from the BaseColumns interface, the constants for the other columns come from the NotesColumns interface. Using the BaseColumns interface here demonstrates a really important point. The interface has each created a logical grouping of column constants. The BaseColumns interface contains the _ID constant, which is the name of the column that provides row identity. When I implement that interface on the Courses class and the Notes class because the tables they correspond to each contain a column named _ID. Well with that our in mind, our CourseColumns interface, our NotesColumns interface have an issue. They both include a course_ID column and that column means the same thing in both cases, it identifies a course. So rather than redundantly declare the column constant in each of the interfaces, we should instead bring the course_ID column constant out into a separate interface. So let's scroll up here a little bit. So that we can separate that constant out, let's create a new interface and we'll call it CoursesIdColumns, and then within this interface, we'll declare a constant for the course_id column. So now that we have a course_id constant and the CoursesIDColumns interface, we can remove that constant from the other interfaces. So let's first remove it from the CoursesColumns interface and then we'll remove it from our NotesColumns interface. So now we have our column constants grouped into the appropriate interfaces. The courses_id columns interface contains the constant for the column that identifies a course. The CoursesColumns interface contains the constant for the columns to describe a course, the NotesColumns interface contains the constants for the columns that describe a note. So now at this point, either the Courses class or the Notes class expose the constant for the course_id column. So let's scroll down here a little bit. So now let's go ahead and add our courses _id columns interface to our Courses class and let's add it to our Notes class. So now the Courses and Notes classes both expose the appropriate constants for the columns contained in each of the corresponding tables. Alright, so now our Contract class is in good shape. In our next clip, we'll look at what our content provider needs in order to effectively handle requests to a specific URI.

Matching Content URIs
When we created our content provider in the previous module, we never looked at the specific URI that was passed into our content provider. Anytime Android routed a request to our content provider, we always returned back the same data, our courses data. Well now we want to look at the idea of actually adding proper URI handling to our content provider because content providers normally have to handle multiple URIs, such as in our case. There is one URI that requests courses data and there is another URI to request notes data. So we need to interpret those URIs, but interpreting URIs can be challenging because as we'll see throughout this module, specific URI patterns can actually become quite complex. To help us with the job of translating URIs, Android has a class called the UriMatcher class and it handles the details of interpreting URIs, so it'll actually translate a URI or a URI pattern to a specific integer. Now in order to use the UriMatcher class in our content provider, the first thing we have to do is prepare the UriMatcher. And what we'll do is we'll have our content provider provide the static field for the UriMatcher and then our content provider will have a static initializer and in that static initializer will then add the list of valid URIs for our content provider to the UriMatcher instance. We'll do that using the UriMatcher classes addURI method. What we'll do is at each time we add a URI to the UriMatcher, we will map that to a specific integer constant. So then what happens is that as requests come into our content provider, we'll use the UriMatcher class' match method. We will then pass in the URI that we received. The match method will then do the work of mapping that URI to the appropriate constant and then our content provider will simply get back to the constant to correspond to the URI I received and we can then do the appropriate work based simply on that integer constant. Alright, so in our next clip, we'll use the UriMatcher class to add appropriate URI handling to our content provider.

Implementing URI Request Handling
Here we are back in Android Studio and what we want to do now is update our content provider to handle queries issued for the URIs of our courses and notes tables. Now as a reminder, let's take a quick look at the URI related constants and the Contract class that we created earlier. Now I have the Contract class open here in Android Studio and I've collapsed the bodies of the interfaces within Contract class just so that we can see the Contract class' constants, along with the constants within our table classes all at one time. Now within the Contract class, we have two constants. The AUTHORITY constant is a string as our content provider authority. The AUTHORITY_URI constant is a URI that includes the content scheme, along with our content provider authority. The URIs of our individual tables will all be based off of the URI in this constant. Then here in our courses class, we again have two constants. There is the PATH constant, which is a string containing the path value we add to the content providers URI to indicate that we want the courses table, the content URI constant is the actual URI used to access the courses table. And finally, in our notes class, we have those same two constants. The PATH constant contains a string path for our notes table. The CONTENT_ URI constant contains the actual URI to access the notes table. So that covers all of our URI constants. Let's head over to our ContentProvider class and start adding the code to handle those URIs. Here we are at our NoteKeeperProvider class. The first thing we need to add to this class is a UriMatcher field. So let's create a new instance of UriMatcher and we'll assign it to the static field named sUriMatcher. When constructing the instance of the UriMatcher class, we usually pass in the UriMatcher class' NO_MATCH constant. Let's go ahead and pass that in. The NO_MATCH constant simply indicates that any attempt to match a URI that doesn't contain an authority or a path to return back the value NO_MATCH. So now that we have our UriMatcher field, I'm going to start adding the list of valid URIs to it. We'll do that in a static initializer. Now if you're not familiar with initializers, I'd encourage you to check out the discussion of them over in our Java course. Basically, a static initializer allows us to run some code when a type is initially loaded. We often use them as we are here to initialize a static field. So we'll go ahead and add our static initializer. Now the first URI we'll add to our UriMatcher is the one for the courses table, so we'll call the addURI method on our sUriMatcher field. The first parameter of the addURI method is a string containing the URI authority. So we'll pass our Contract class' AUTHORITY constant. The next parameter we pass is a string for the path portion of the URI. So we'll pass in the PATH constant from our Courses class. And the last parameter is the integer value we want returned when the UriMatcher matches this URI. Now this could be any integer value we'd like. So let's pass in the literal value of 0. Now let's make this literal 0 a constant, so we'll press Ctrl+Alt+C, and we'll name the constant COURSES, and we'll hit Enter. So that takes care of the URI for our courses table. Now let's add the URI for our Notes table. So we'll again call the addURI method on our sUriMatcher field, we'll pass in the Contract class' AUTHORITY constant, we'll pass in the PATH constant from our Notes class, and for the integer value, we'll pass in the literal value 1 and let's go ahead and make that 1 the constant notes. So that takes care of all the URIs we need to add for now. So that means we're ready to add the code to our query method, to handle each of these URIs. So let's scroll down to our query method. Here we are at our query method. Now the way our query method is currently implemented, we always return rows from our courses table. Well now that we have our UriMatcher, we can return back rows from either the courses table or the notes table depending on the URI used to access our content provider. Now the value of the URI used to access our content provider is passed in as the first parameter of our query method. We can determine whether that URI is for the courses table using the match method of our UriMatcher field. So we'll add a call to sUriMatcher. match, then we'll pass in the URI parameter that our query method received, the match method will return back an appropriate integer value for that URI. So let's assign a returned value to a local variable named UriMatch of type int. So at this point, assuming that our content provider has access with one of our supported URIs, the UriMatch variable will now contain either the constant courses or the constant notes, so let's add a switch statement to check it. So now within our switch statement, let's add a case for COURSES. So now here what we want to do is actually issue the query for our CourseInfo table. So let's take our existing query statement there, move it up inside of our switch statement. So now when the URI for our courses table comes into our content provider, we'll query our CourseInfo table, assign it to our local variable named cursor, which will then be returned back from our content provider's query method. So let's go ahead and add a break here after we do the query. Let's go ahead and add a case for our notes constant. And then in this case, we're going to go ahead and issue a query for our NoteInfo table, and you can see when we query our NoteInfo table, it's exactly the same as when we queried the Courseinfo table. The only difference is we're passing it the NoteInfo table name, rather than the CourseInfo table name. So now with all that code in place, our content provider can now properly handle requests to both the courses URI and the notes URI. So in our next clip, we'll update our note activity to use the appropriate URI and then we'll test all this out.

Using Your Contract Class and URI Handling
Here we are back in Android Studio. What I want to do now is update our note activity to use our Contract class and access our content provider using the courses table URI. And then once we've done all that, we'll test it out. So now we're currently looking at our note activity classes, createLoaderCourses method. This is where our app requests the courses data from our content provider. Now right now, the URI used to access the content provider consists only the content scheme and our content provider authority. So the first thing we'll need to do is change the code to use our CONTENT_URI constant and the Contract class' Courses class. Now initially, when we use the Courses class, it's got to be qualified by the Contract class itself, but let's do an Alt+Enter, we'll go ahead and add the import, and now we can just use it as Courses, we don't have to qualify it inside the Contract class anymore. Now another change I want to make to this code is related to the column name constants. You'll see here where we add the columns to our courseColumns array that we're using constants from our database contract class. Let's switch all of those, use the constants from our content provider's Contract class instead. So instead of saying CourseInfoEntry on each of those, we'll simply say Courses. So that takes care of the list of columns we're requesting, but we also want to use the constants from our content provider's Contract class and specifying and the order we want the rows returned. So here we construct a CursorLoader and we specify COLUMN_COURSE_TITLE as our order, instead of saying CourseInfoEntry, again, we want to say Courses. That takes care of all of our column references in this method. We want to be sure to do the same thing anywhere we reference column names related to the content provider. Remember that anytime we're interacting with the content provider or cursor return from a content provider, we want to be sure to use the constants from the content provider's Contract class. So now we're just about ready to test things out, but before we do that, let's add some breakpoints. First, we'll have one right here where we construct our CursorLoader. Let's head over to our NoteKeeper provider class. So here in our NoteKeeper provider class, let's add a breakpoint to our initializer, then we'll scroll down to our query method, and then here in our query method, let's add a breakpoint to where we call our matchers match method. And so now, we'll go ahead and launch it in a debugger. So you can see here, as soon as we launch it, we hit the breakpoint inside of our static initializer and that's because the static initializer is run when the type is loaded, so this assures that we get all of our URIs into our matcher before any requests come to our content provider. So let's go ahead and release this. So your application is running in the emulator and what we'll do is with the new button to take us to our node activity, and of course, when we do that, we hit the breakpoint to where we construct our CursorLoader. So let's switch back to Android Studio. So you can see here in the Variables window as we're constructing our CursorLoader, we're now passing in the URI that we've set up specifically for our courses table, so let's go ahead and release this, and you see as soon as we release it, we get into our query method. So you can see here in the Variables window that we've gotten the URI for our courses table, so I'm going to go ahead and step. You can see when I step we now have the value for uriMatch, and uriMatch is 0 because that's the constant we associated with that URI. And so, if I step again, I get into the body of my switch statement, we go into the query for our courses table, step again, so we now have the Cursor for our courses table. So now if I go ahead and release this, the activity continues running. If I click on the drop-down here for our spinner, you can see that we're now populated with a list of courses and that shows us that everything worked just as we expect it to. Our contract class is specifying the columns correctly, it's providing the URI correctly, and our content provider handled the URI correctly. So now in our next clip, we'll look at how we can expose a table from a content provider that doesn't directly correspond to a physical table in the database.

Table Abstraction
Let's take a look now at the way our main activity displays note information. Now as you recall from the work we did in the previous course, the main activity is currently reading that data directly from the database. Now the way it displays the notes is by querying the note_info table, but because the note_info table doesn't include the titles of the courses that correspond to the notes, the main activity has to join the note_info table to the course_info table. So of course, that's putting a burden of understanding the database structure on the activity and we want to start moving away from that. Instead, we'll want to encapsulate the details about storage structure within our content provider and have all the interaction with data from our activities occur through the content provider. Now if we look at what our content provider can currently do, our content provider currently understands a URI that has the authority followed by the path notes and that gives us access to the note_info table. So that would allow the main activity to get access to the list of notes, but again, we wouldn't have access to the course titles that correspond to those notes. Now another URI we understand is our authority followed by the path courses and that gives us access to the information from the course_info table in the database. Now that will give us access to the course information, but now we're losing the note information. So the question is, do we do? Now remember that our content providers can abstract the storage details and present whatever tables they would like to present even if they're not exactly like the way the data is stored. So what we could do is have our content provider, add support for another URI and this would be our provider authority, followed by the path, notes_expanded, and what we could say is that this is the notes information expanded to include the course information. And so, what we'd do inside the content provider, the content provider would query the note_info table and the content provider would then take care of joining that against the course_info table. So we're still producing a result by joining the tables together, but that detail is encapsulated inside the content provider. As far as the main activity is concerned, it simply accesses the URI that ends in the path notes_expanded and it receives back the list of notes including the corresponding course information. Alright, so in our next clip, let's start adding support for this notes_expanded URI to our content provider.

Adding the Table Abstraction to the Contract Class
Here we are back in Android Studio and what we want to do now is add the ability for our content provider to expose a table that's actually the result of a join of two database tables. Now this new content provider table will provide the list of notes, along with each notes corresponding course information by joining the note_info database table to the course_info database table. So the first thing we'll need to do is update our content provider's Contract class to include the URI constants for this new table. Now we could add a whole new table class, but in this case, we don't need to do that. Conceptually, this new table is really an expanded version of our existing notes table. So with that being the case, we can add the new constants to our existing notes table class. So let's go now to string constant and we'll call it PATH_EXPANDED and we'll set its value to notes_expanded. So that'll be the path portion of our new URI, but now we also need an actual URI constant. So let's create a new URI constant and we'll call it content_expanded_uri. So to set the value of the constant, use the URI classes withAppendedPath method. The first parameter will be the authority_uri constant and the second parameter will be our new constant PATH_EXPANDED. So now our notes class exposes a URI for a content provider table that includes course information. So now that our notes class exposes a URI for a content provider table that includes course information, we need to include the appropriate column constants for this additional data and those are the column constants related to describing a course and they're in our CoursesColumns interface. So let's go now to our CoursesColumns interface to our Notes class. So by implementing that interface, the notes class now exposes the constant COLUMN_COURSE_TITLE. So this additional column for the course constant is only available for the notes when accessing those with the expanded URI. So if we're building this app in real life, we would include documentation by getting a clear that the course related columns are only available for a specific URI. The key point exposed in the two separate URIs in the Notes class is that both the content_uri constant and the content_expanded_uri constant refer to notes related content provider tables. It's just that the content_expanded_uri exposes the notes with some additional information, which is each notes course title. Alright, so that takes care of all the changes we need to make in our Contract class. In our next clip, we'll add support for this new URI to our ContentProvider class.

Implementing a Database Join as a Table Abstraction
Here we are back in Android Studio and we're continuing our work of adding a new content provider table, but this content provider table is actually produced by joining together two database tables and we've already made the changes we need to our Contract class to include the new URI. What I'm going to do now is actually add support for that URI to our ContentProvider class. So now the first thing we'll need to do is add this new URI to our UriMatcher instance. So again, we'll do that in our static initializer, so we'll start by calling our UriMatcher's instance. addURI method. We'll pass in our content provider's authority. We'll then pass in the path for this new URI, which is the path_expanded constant from the Notes class. We'll associate an integer constant, in this case, we'll make that constant the integer 2 and then we'll associate that integer with the constant name NOTES_EXPANDED. Alright so now our URI is added to our UriMatcher, so now let's scroll down to our query method. So here we are in our query method and what I do now is in switch statement add a case for that new constant NOTES_EXPANDED. So now within this part of the case, we want to do the appropriate query for this URI. Now in this case, querying the table is a little bit more involved than a simple single table query. So what we'll do is assign our cursor variable, result of a method we'll create called notesExpandedQuery. Now let's go ahead and pass our database reference to that method. We'll need to know what columns to return, so I'll pass in our projection. We'll need to know the selection criteria, so we'll pass in the selection and selectionargs. And then finally, we'll pass in the sortOrder. So all we've done there is pass in the database reference we got back when we opened the database and then all the relevant parameters that we received into the query method. So now we need to create the methods, we'll do Alt+Enter, I'll hit Enter, we'll accept the return type along with all the parameter information, I'll go ahead and add a line break to the list of parameters just so we can see all the parameters on screen at once. Alright, so now what we want to do in our notesExpandedQuery method is the query it takes to produce this NOTES_EXPANDED table, and as you recall, we return this information by joining the note_info table to the course_info table and we're going to do that exactly as we did when querying the database directly from our main activity. Alright, so let's go ahead and declare our local string variable, we'll call it tablesWithJoin. So now we know we want the note_info table, so we'll provide the constant for its table name. We'll concatenate the literal string JOIN, then we'll go ahead and concatenate the table named constant for the course_info table, we'll concatenate the literal string ON. Next one you concatenate on are JOIN condition. So our join condition is going to be the course_id column from our note_info table. We'll concatenate on an equal sign, and then we'll concatenate on Course_ID column from our CourseInfo table. So basically, all we're saying is that we want to take our note_info table, join it to our course_info table, we want to join them on the Course_ID values being equal in the two tables. And so, now we have our tables with join, we can go ahead and do our query, and since our notesExpandedQuery method returns back a cursor, we can simply return back the cursor that's returned back to the called query. So we'll say return db. query, we'll pass in our tablesWithJoin variable, pass in our projection, pass in selection and selectionargs, we'll pass in null for the next two parameters, and then finally, our sortOrder. Alright, so now we have support for the NOTES_EXPANDED URI, in our content provider, and in our Contract class. So in our next clip, we'll modify our MainActivity class to use the content provider to populate the notes list using this new URI.

Accessing the Table Abstraction
Here we are back in Android Studio. What we want to do now is modify our MainActivity class to request a list of notes from the content provider and we'll do this using the notes_expanded URI that we added in the previous clips because we want the notes to each include their corresponding course titles. Now we're currently looking at the MainActivity class' onCreateLoader method, and as you can see, we have an is statement where we check to see if the ID value passed to onCreateLoader is the LOADER_NOTES. And since I had this if block where we handle creating the CursorLoader, they request the notes information. So let's scroll down here so we can see the entire if block. And as you recall, we added all this code in the previous course. And this code as it's currently written requires that we handle a lot of details of interacting with the database right here within the MainActivity class. So you can see here where we create the anonymous class that derives from the CursorLoader class. It's within that class we then override the loadInBackground method, then inside of loadInBackground, we have to connect up to the database, then we provide the return columns and the sortOrder, and then we do the work to do the actual query of the table using the join. So now we already know the issue of query using a content provider simplifies all of this. So let's get rid of what we don't need. So first, we'll remove the code that creates the join clause and then issues a query, and then we'll remove the line that requests the database connection, and finally, we'll get rid of everything related to creating and extending the CursorLoader class. And so now with that, the only thing left within the if block is a list of columns and the sortOrder. So now we're ready to create a CursorLoader that accesses our notes_expanded URI. So the first thing we'll do is create a new CursorLoader instance and assign it to our local variable named loader, we'll pass in this for the context, then for the URI, we'll pass in the CONTENT_EXPANDED_URI constant from our Notes class, we'll pass in the list of columns, we'll then pass null for both the selection and the selectionargs, and then finally, we'll pass the sortOrder. So that takes care of creating our CursorLoader instance, but we still have just a little bit more work to do. Now all the code here within this if block still uses column constants from the database's contract class, so we want to switch those to use the constants from our content provider's Contract class instead. If we look here where we specify the sortOrder, you can see the COURSE_TITLE column constant comes from CourseInfo database table class. The NOTE_TITLE constant come from the NoteInfo database table class. Both of those should be switched to come from our content provider's Notes class. Okay, so that takes care of our sortOrder. Now let's look at our columns array. So now if we look at the last two columns in the array, again, we have the Note_Title and the Course_Title, so again we want to switch those to use the Notes class. So now that leaves us one more column to deal with and that's the _ID column and the _ID column creates a bit of a challenge. We know that when we created the database using this join of the note_info and course_info tables, we have to table qualify the _ID column because it appears in both of those tables, but table qualify in the column name is really an implementation detail that's the responsibility of the content provider. So the question is, what do we do here and that's what we'll look at in our next clip.

Handling Column Names in the Table Abstraction
Here we are back in Android Studio and we're continuing the work required to allow the MainActivity class to request the list of notes from our content provider. Now we're almost done with the work that we need to do in our MainActivity class. So here in our MainActivity class, we're currently looking at the onCreateLoader method, and you can see here where we create the CursorLoader instance that we're using the CONTENT_EXPANDED_URI constant in the Notes Contract class. Now remember that this content provider table notes_expanded is actually produced by joining the note_info and course_info database tables. The fact that we're joining two database tables is implementation detail encapsulated within the content provider, it's never really the concern of our MainActivity class, but you can see here where we provide our list of columns that for the Note_Title and Course_Title columns, we're already using the constants from our notes content provider Contract class, but here where it comes to the _ID column, we haven't yet changed the way we reference that column constant. Now as we're currently referencing the _ID column, we're calling this method on our NoteInfoEntry class we wrote in the previous course called getQName. This method returns the column name, table qualified. The reason we have to do that is because the database query is joining two tables, note_info and course_info, and both of those tables contain a column named _ID, so we had to specify which tables _ID column we wanted. Well now that the MainActivity class is accessing the data through the content provider, the need for this column to be table qualified is no longer the MainActivity class' concern. So here in the MainActivity class, we can go ahead and just pass the _ID constant from the Notes class. So what this means now is that the provider class will have to take care of adding any required table qualifiers. So let's head over to our ContentProvider class. So here we are in the NoteKeeperProvider class' notesExpandedQuery method. This is a method that takes care of issuing the query for our notes_expanded URI. So what we need to do is add the code to this method to table qualify any columns that are requested that are part of both the node_info and course_info database tables. We received the list of desired columns from our parameter named projection and we received them as a String array. So let's create a local variable named columns of type String array and let's assign it a string array that is the same size as the projection array. And now, let's create a for loop that loops once for each member of the projection array. So now here within our loop, let's go ahead and assign a value to the current element of the columns array. And now the specific value we assigned depends on the corresponding element of the projection array. So let's check the current value of the projection array and let's see if it equals the value of the BaseColumns_ID constant. So now if it does, we need to table qualify the column name and we can use our NoteInfoEntry classes getQName method to do that. Now otherwise, we can simply assign the value from the projection array. This code will assure that when the _ID column is requested that we issue the database query with the column name qualified by the note_info table. In all the other cases, we simply use the column name as it was passed to us. So now we need to do this same thing for any other columns that appear in both the note_info and course_info database tables. Well since we join these two tables using the course_ID column, we know that column is in both tables as well. So let's go ahead and add an or condition here and then we'll add a check to see if the column is the course_ID column. So now with this code in place, the column that's being requested is equal to the _ID column constant from our BaseColumns interface or it's equal to our COLUMN_COURSE_ID constant from our coursesIdColumns interface and both of those cases, we will table qualify the column name. Otherwise, we just use the column name as it was passed in. So now our columns array has all of our column names in a way that we can actually use with the database. So what we'll do is we'll go down to where we call the query method, and instead of passing the projection array, we'll pass the columns array. Alright, so with that, we should be all set. So let's go ahead and test this guy out. Alright, so our application is up and running and I've added some breakpoints so we can see what's happening. So here we are currently in our MainActivity class' onCreateLoader method and we're about to create our CursorLoader instance that references our Notes_Expanded URI, so let' me go ahead and release this. Then as soon as I release it, we find ourselves in our content providers notes_expanded query method. So now remember that we receive the list of columns in our projection array. So we look down here in the Variables window, you can see the projection array there, we get on here and expand it, and you can see once I expand it, you can see that each of the columns appear there without being table qualified and we have the _ID column, the note_title column, and the course_title column, so now I'm going to go ahead and release this. So now we're at the breakpoint where we actually issue the query. Now of course, as you can see in the Variables window, the projection array is unchanged. Let me go ahead and collapse that guy, let me head down here to our columns array and expand that. You can see in our columns array the course_title and note_title values are unchanged, but for the _ID column, it's now table qualified with the note_info table. So our code to receive in the column names and table qualify the ones that are necessary is working just fine. So let's go ahead and release this guy. You can see here now that the application is running inside the emulator and our MainActivity's recycler view is populated with our list of notes and all of their corresponding course title information. Alrighty, so all the work we've been doing with the content provider throughout this module is going really well. Our content provider now understands URIs that include specific paths on them and the content provider is able to expose tables that both correspond directly to physical database tables, as well as provide back a table as an abstraction of the physical database tables.

Summary
To wrap up, here is some of the key things you want to remember from this module. Remember that content providers expose tables and most content providers will actually expose multiple tables. Now those tables will often correspond to actual database tables, but they don't have to. We can present content provider tables that are actually abstractions over the actual database tables. And then each of the tables exposed by the content provider is identified by an individual URI. Now normally a content provider will have a Contract class. That Contract class presents the public appearance of that content provider and that Contract class will contain classes for the tables that are exposed by the content provider. Now those table classes are nested classes within our Contract class and it'll contain the URI for the table, as well as the column names that are exposed by that table. But the way we define those constants for the column names is not normally directly inside a table. Instead, we'll generally put them within interfaces. Those interfaces are also nested within the contract class. And by putting the constants in the interfaces, that gives us a central place to manage those constants and then the individual tables can then implement the appropriate interfaces so that the classes then expose the appropriate column constants. So now the URIs for our tables are extensions of our content provider's URI. So we'll still have the content scheme, we'll still have the provider's authority, but then each individual table can then have a path, but then we identify the individual table by including a path in the URI. And then within our ContentProvider class, we handle the URIs using the UriMatcher class because the UriMatcher class allows us to take a URI and then translate it into an integer constant, and then within our content provider we can take the appropriate action based on that constant. So now in our next module, we'll wrap up our discussion of content providers by looking at how we can move beyond simple queries to start fully interacting with the data exposed by a content provider.

Interacting with Content Provider Content
Introduction
Welcome to the Interacting with Content Provider Content module of the Pluralsight course, Exposing Data and Information Outside your App. My name is Jim Wilson. In this module, we'll complete our discussion of content providers by learning how to implement full data interactivity. Now the first thing we'll look at is how we can gain access to our content provider using something called a ContentResolver. We'll then see how to insert new data into our content provider tables. We'll see how to identify individual rows in a table using row URIs. We'll learn how to make our content provider work more effectively with other applications, and then we'll finish up with a look at how to provide mime types for the URI supported by our content provider.

Accessing Content Provider with Content Resolver
Throughout this module, we'll continue the process of transitioning our application using a content provider rather than interacting with the database directly. So now we've already transitioned our main activity, so we can actually query the list of notes from the content provider, but now we'll start looking more at the note activity. For example, when a user selects a note wanting to display an individual note in our note activity, we want to get that note back from the content provider, which means we're going to want to query the content provider for an individual note. Now in addition, we want to do the work so that when the user hits the back button, we want to save the changes the user made to that note, which means we want to do an update. So we want to do the update through the content provider, rather than doing the update directly against the database. Then as we get into creating a new note, we have to provide support for a full cycle of operations. When the user first hits the button to create a note, we have to insert a row into the table, which will be a placeholder for the actual data for that note, and then when the user hits the back button, we go ahead and update that row that we just inserted. But in addition, we have the issue that when a user says I want to create a new note and we insert that new row into the table, the user may decide that they don't want to actually save the changes, which means when they hit the back button, we actually have to delete out that note that we just created with the insert. So that means that our content provider now needs to support a full range of data operations. And the good news is content providers are actually designed to do the full range of data operations. So now we've already seen our content provider do queries, but we can also do the inserts, updates, and deletes. Now in order to perform these operations, we have to access the content provider and up until now, we were doing our queries, we used a CursorLoader and the CursorLoader took care of the details of actually accessing the content provider. But for the other operations, insert, update, and delete, we need a way to get an access to the content provider without using the CursorLoader. So the way we've been working in our application is we have our content provider and then we created an instance of CursorLoader and that would handle reaching out and interacting with the content provider. Now remember that CursorLoaders actually do a number of things, right to design and cooperate with a loader manager, the design to do the work on a background thread, and they're actually not focused directly on accessing the content provider. The CursorLoader actually uses another type called a content resolver that access the content provider. So when a CursorLoader wants to interact with a content provider, it actually calls out to the content resolver. The content resolver then does the work to get out to the content provider. Well it turns out that we can actually access that content resolver ourselves. So anytime we want to actually interact with the content provider, we can simply get a reference to the content resolver and then perform the operations. A content resolver is available from our current context. So if we're working in our activity, that's simply using our this reference and we can call the method, getContentResolver, and it'll give us back a reference to a content resolver. Now the content resolver serves as an intermediary, so it exposes methods for each operation. So content resolvers have an insert method or an update method and these methods accept a URI. And then the content resolver will go out and find the content provider and then delegate the actual operation out to the content provider so the content provider can do the work. So now in our next clip, let's see what it's like to see use the content resolver to perform an insert operation and how we have to implement that insert operation inside of our content provider.

Inserting a Row into a Table
So now we're ready to insert a new row into a table. We're going to use the ContentResolver's insert method and we call the insert method, we pass in the URI of the table that we want to insert the new row into and then we pass the values using the ContentValues type just as we did when we were interacting with SQLite directly. So ContentValues allows us to identify each column and the value we want to set for that column. And then the insert method will return back a URI that identifies that individual row and we'll talk more about that in just a moment. When the user calls the insert method on the ContentResolver, we'll then receive a call to the insert method of our ContentProvider. We'll receive the URI and ContentValues that they passed. So the first thing we have to do is determine which table we need to insert the row into and we're going to do that just like we did with the query method. We're going to call the UriMatcher classes match method to identify what table this URI corresponds to. And then from there, we simply use SQLite to insert that row into the database. When we do the insert into the database, SQLite insert method will return back a row id and we're responsible then take that row id and return back a URI that corresponds to that row id. So the way that we create the row URI is by starting out with a table URI and then we take the row id that we received back from the database's insert method and we append that as a path onto the end of the table URI. Now doing that is really simple because there is a class called ContentUris that has some helper methods and we can use the helper method withAppendedid to create the URI for our row. To give us a better sense of how all this works, in our next clip, we'll start making the changes to our application to insert a new note using a ContentResolver and our content provider.

Inserting a New Note
Here we are in Android Studio and what we want to do now is begin the process of changing our app to allow the NoteActivity class to use our content provider rather than interacting directly with the database. We're currently looking at the NoteActivity class' createNewNote method, and as its name implies, this method is called when a user is creating a brand-new note. Now this method is currently implemented, it's inserting the row directly into the database. If we look right at the code, the first thing the method does is create an instance of the ContentValue's class and it sets the values for each column. Now we're setting all the values to blanks because the row that we create here is just the initial backing store for the note. We'll update the row with the actual user entered values when the user leaves the activity. So once we have the column values, we get a writable reference to the database, then insert the row directly into the database. So let's go ahead and change this code to perform the insert using our content provider rather than interacting directly with the database. So the first thing we'll do is get rid of the two lines that interact directly with the database, the one line that connects the database, and the one that performs the insert into the database. So now with those lines gone, we can start to do the work to do the insert through the content provider. So in order to insert using our content provider, we'll first need to get a reference to a content resolver. To do that, we'll call the getContentResolver method, we'll then call the content resolver's insert method. Now we need to identify which table we want to insert the row into. In this case, we want to insert the row into our content provider's notes table. So we'll pass the content URI constant from a content provider's contract classes Notes class. And then for our second parameter, we need to provide the list of columns and our corresponding values and we can use the same content values variable we we're using when we were interacting directly with the database. So now once we do the insert, the insert method returns back a URI for our new row, and we'll talk about the importance of the value of that URI just a little bit later in this module. For now, let's just go ahead and store the URI and local variable. We'll name the variable URI and it'll be of type URI. So that takes care of the insert method. We have one last thing we need to address. You can see here where we specify the column names in our ContentValues instance. Those column names are all still using the NoteInfo database table constants. These need to be changed to use the constants for our content provider's notes table instead. And with that, we have the code in place to initiate the insert into our content provider's notes table. Now keep in mind, the performing content provider operations on the main UI thread can have the same negative UI effects that we talked about in the interact with SQLite data module of the previous course. So you can avoid those issues by performing the content provider operations on a non-UI thread using the same techniques we talked about in that module. So just be sure to keep that in mind when you're interacting with a content provider in your application code. Alright, so now we have the code in place to initiate the insert of the new note using the content provider. The next thing we need to do is add the code to the content provider to insert the row into the database and we'll see how to do that in our next clip.

Adding Insert Support to Content Provider
Here we are back in Android Studio and what we want to do now is add the code to our content provider to handle inserts. Now we're currently looking at our content provider's insert method and this method receives the URI and the content values that were passed into the ContentResolver's insert method. Now since our content provider insert method is going to insert a row into our database, we know there are a few things we'll need. Well to do the insert, we'll need a database reference, so let's call our OpenHelper's getReadableDatabase method and we'll assign a result into a local variable of type SQLite database. We know that the database insert method returns back the row id of the new row, so let's declare a local variable named row id of type int and we'll initialize it to -1. Now the content provider insert method needs to return back a URI and that URI identifies the newly inserted row. So we'll declare a local variable named row Uri of type uri, we'll initialize it to null, and then we'll return it back that variable from our insert method. Alright, so we have those things in place. So now if I look at our content provider insert method, you can see that it receives the URI of the target of the insert as its first parameter. We'll translate that URI into one of our table constants using our UriMatchers match method just as we did in the query method. So with that, we'll have the constant for the table that corresponds the URI and our local variable UriMatch. So let's go ahead and do a switch on uriMatch. So the inside of our switch statement, we want to go ahead and put a case for each of the tables. So the first case we'll need is one for notes. So now inside of here, we'll do the actual insert. So we'll call db. insert and we'll pass in our NoteInfoEntries table name constant, so then we'll pass null, and then we'll pass in the values parameter that our content provider's insert method received and remember that the database insert method returns back the id of the row that was just inserted, so we'll assign the result of our insert method into our local variable named row id. So now you see here when I assign the result of insert to rowId, it's underlined in red and the issue here is that the insert method returns back a type long, which is a 64-bit integer, and I've declared rowId as an int, which is a 32-bit integer. Now I could just go ahead and cast the result of insert to be an int, rather than a long, but why don't we just go ahead and change rowId to be a long instead of an int and we can actually do that right here using Android Studio. So let me do an Alt+Enter and you can see it gives me some options here. The first option is cast to int, the second option is actually change rowId to a long and let's just go ahead and do that. So I'll hit Enter and you can see now that rowId is now declared as a long. So now by changing rowId to a long, all that does is allow us to safely insert a much larger number of rows into a single table. Now for most applications, it's not really going to matter, an int is going to be large enough for most of those scenarios, but since the insert method returns back a long, we'll just go ahead and make our rowId a long as well. So now that we've inserted the row into the table, we need to put together the URI for that row and the URI for the row is actually based on a combination of the URI for the table and that row's rowId. So let's go ahead and add a common here that shows what the URI should look like. We'll start out with our notes tables URI, so that's simply our content scheme, the authority for our provider, and then a path for a notes table. And then what we want to do is take the rowId and add that as a path onto this URI. So if the value and rowId were 1, we'd have a path on the end of this of 1. So that shows us what the URI should look like. Now in order to create that URI, we can use a helper class called ContentUris and it has a method called withAppendedId. So let's call ContentUris withAppendedId. For the first parameter, we'll pass the CONTENT_URI constant from our Notes class, and then for our second parameter, we'll pass in the rowId. So that creates the URI that identifies this new row, so we'll assign this result to our local variable rowUri. So that takes care of our notes table. We insert the new row and then we create the URI that identifies the new row. So now we want to go ahead and do the same thing for our courses table. So we'll put a case for courses, we'll do the insert into our CourseInfo table and assign the result to our rowId variable, and then we'll create the URI for the new row. And so, as you can see there, do an insert into our courses table is exactly like doing it into our notes table, the only difference is we use the CourseInfo table named constant and we use the Courses. CONTENT_URI constant. So that takes care of our two content provider tables that correspond to database tables, but we know that we also support one more table and that's our notes_expanded table. So let's go ahead and add a case for that. So now remember, we add a support for this Notes_Expanded table as a convenience to make it easier to display notes with their accompanying course information, but it's actually a join of two database tables, NoteInfo and CourseInfo. Now this means that we don't really have a concept of inserting into our Notes_Expanded table. We provided it just as a way to make displaying notes information easier and that's okay because every table we expose from our content provider doesn't have to support every operation. So what we might do here is just throw an exception indicating that the Notes_Expanded table is a read-only table. Alright, so now with that, our content provider's insert method is just about ready to go. Let's just do one quick little thing here. Let's just go ahead and indent each of these break statements so they line up with the code above them. Alright, so now our content provider's insert method is ready to go. We support inserts into our notes and our courses tables, and if someone were to try and insert into our Notes_Expanded table, we indicate that the Notes_Expanded table is read-only. So now in our next clip, let's test out our content provider's insert behavior.

Verifying Note Insert Behavior
Here we are back in Android Studio and we're just about ready to test our content provider insert behavior, but before we do that, let's do one quick thing. We're currently looking at our NoteActivity class' createNewNote method. This is the method they use the ContentResolver to initiate the insert of a new note. Here, we call the ContentResolver insert method, we're storing the URI we receive back as a local variable. Since this URI identifies the row of the newly inserted note, we'll probably need that URI later on when it comes time to interact with the note. So instead of this being a local variable, let's make it a class level field, and we'll name it mNoteUri. And with that, we're all set. So let's go ahead and run it. So here we are with our program running in the emulator. I've added some breakpoints to the code so we can see what happens. So let's go ahead and click on the new note button, and when we do that, we can see it breaks in our note activity, so let's switch over to Android Studio. So here we are in Android Studio. We're currently at a breakpoint inside of our NoteActivity's createNewNote method. This is where you use the ContentResolver to insert the new note into our content provider. So we go ahead and release this. So as soon as I release this, we're at a breakpoint inside of our content provider's insert method. So we're at the point where we're going to match the URI, so I'll go ahead and do a step. We'll step again, and we can see the URI matched our notes table. So now we're going to go ahead and do the insert into the database, so I'll step and you can see when I step, the insert succeeded and our rowId variable now has a value of 17, which is the Id of the newly inserted row. Let's go ahead and step again. When we step again, we've now built the URI for this row. You'll notice that it's the URI for our notes table and then the rowId, in this case 17, is appended as a path onto the end of our table URI. So let's go ahead and release this guy. So now when we release it, I hit the breakpoint that that's the end of our NoteActivity's createNewNote method. If you look there in the Variables window, you can see our field, mNoteUri, now has the URI of the newly inserted note in it. And so with that, the process of creating a new note looks to be working perfectly. We're able to use our content provider to insert the newly created note and then we've stored the URI for the road that corresponds to that new note in our NoteActivity's mNoteUri field. So now in our next clip, we'll take a closer look at row specific URIs and we'll see the appropriate way to handle them in our content provider.

Data Interaction and Row URIs
As we saw, when we insert a new row into our content provider table, we get back a row URI. Remember that row URI is based on the table URI, we just append a path to the end of it, which is the rowId for the newly added row. Well it turns out that row URIs are the primary way that we interact with a specific row in content provider tables, so we tend to use these row URIs when we're querying for a specific row or when we're doing an update or a delete to a specific row. But now these row URIs are used primarily for consistency and convenience because the row URI behaves exactly the same as if we were to use the table URI, but then include an explicit selection criteria that matched on the id value. But now what this means is that our content provider has to expand its URI handling. So in addition to handling table URIs as we already do, we also need to add support for row URIs. As we add handling for our row URIs, we're going to continue to use the UriMatcher class and our matcher class knows how to match row URIs separate from the table URIs and what it does is it supports wildcarding to match on the rowId value. So what it allows us to do is use the table URI, and at the end of it, add a hashtag, and that hashtag indicates we want to match any ID value. So for example, in order to match row URIs for our notes table, we would add a URI to our UriMatcher that started with our content scheme and our content provider authority. We would add the path for the notes table, but then we would add a hashtag to the end of the URI and that indicates that the UriMatcher, we want to match any row URIs for our notes table. So now once we know we've received a row URI, we now need to do the actual work for that URI, which means we need to interact with the database. So we need to do a query of the database, an update, or a delete to the database. The thing is, the database needs explicit selection criteria. So if we're going to interact with a specific row, the database needs that _id selection criteria, which means that we'll need to extract the rowId from the row URI and we can do that using the ContentUris class and it provides a method parseId. We can pass it in that row URI and it'll pass us back the id value that's contained in that URI. To help us understand how all this works, in our next clip, we'll start adding row URI support to our content provider.

Adding Row URI Support to Query
Here we are back in Android Studio and what we want to do now is that support for row URIs to our content provider. Now in this clip, we'll be focusing specifically on adding the ability to query for a note using a row URI. To support URIs that reference specific rows in our notes table, we'll need to add the appropriate pattern to our sUriMatcher field and we'll do that here in our static initializer. So we'll start by calling the addURI method. For the first parameter, we'll pass in our content provider's authority. For the second parameter, we'll pass in the path constant from our Notes class and then we'll concatenate a / and a # symbol to it. This indicates that we want to match URIs that end in the Notes. PATH followed by a path containing an integer value. This is how we indicate that we want to handle a row URI that references a rowId within our notes table. So now for our last parameter, we'll just pass the literal value 3 and then we'll change that literal value to a constant name Notes_Row. So with this call to addURI in place, anytime we receive a row URI referencing a rowId in our notes table, a call to the UriMatcher class's match method will return back the constant Notes_Row. So now let's scroll down to our query method so we can add the code to handle this type of URI. Here we are on a query method, and as you recall, our query method already supports table queries of courses, notes, and notes_expanded. So what we want to do now is add support for row URIs that reference rows within our notes table. Now the call we have here to our sUriMatcher. match method will take care of matching the notes table row URIs. So all we need to do is add another case condition to our switch statement to handle the NOTES_ROW constant. Let's scroll down here a bit and give ourselves some room to work. So here in our Notes_Row case condition is where we'll actually do the database query. But in order to create the database's NoteInfo table for a specific row, we'll need to specify a selection criteria that includes the rowId value that's contained in our URI. Now we can extract that rowId value from the URI using the content URI classes ParseId method. So we'll call ContentUris. parseId and then we'll pass in the URI. The ParseId method will return back the rowId value that was contained in the URI. So we'll assign that value to a local variable, we'll name the variable rowId, and we'll make it of type long. Now that we have the rowId value, we'll declare a string variable to hold the selection clause and we'll name it rowSelection. In our selection clause, we use our NoteInfo tables _ID column, and then we'll declare a string array variable named rowSelectionArgs, and then we'll assign it an array containing our rowId. Now we're ready to do the query. So let's assign the cursor variable the result of a call to the db. query method. We'll pass in the table name and constant for our NoteInfo table along with the requested list of columns. For the selection clause, we'll pass in the rowSelection variable. And then for the selection arguments, we'll pass in the rowSelectionArgs variable. We'll pass in null for the next two parameters and we can also pass in null for the sort since we know we're querying for one specific row. And with that, our content provider now supports queries that use row URIs referencing a row within the notes table. But now notice the key difference between handling table URIs and row URIs. If you look here where we handle the notes table URI, we use a selection criteria that was passed into our content provider's query method. But when we handle the row URI, we're taking control over the selection criteria. We extract a rowId from the URI and then we build our selection criteria based on that rowId and that's the selection criteria we use in doing the actual query. Alright, now that our content provider supports queries that use row URIs, referencing a row within our notes table, in our next clip, we'll change our NoteActivity class to use a row URI to request a note.

Displaying a Note Using the Content Provider
Here we are back in Android Studio and what we want to do now is change our NoteActivity class to request a specific note using that note URI rather than querying the database directly. Now we're currently looking at our NoteActivity class' createLoaderNotes method and this is the method that's responsible for initiating the retrieval of the note to be displayed. Now as you can see, it still has all the code to extend the CursorLoader class so that we can directly query the database. Now as part of that work of directly creating the database, we're explicitly creating a selection criteria that selects a row based on our mNoteId field. That mNoteId field contains the notes rowId. Well now our content provider supports row URIs, we can rid of all this code related to extending the CursorLoader class and querying the database directly, so let's get that code out of there. So we've gotten rid of all that code we don't need, but we do, of course, still need a list of columns, so let's go and move that list of columns up a bit. So now we also want to make a change to our list of columns. Currently, the list of columns is using our database constants. Let's change that to use our content provider constants. So all the places we use NoteInfoEntry, we'll change that to Notes. And now we're ready to query the content provider. Now to do that, we'll need to create the URI that references the rowId of that note in our notes table. Now the easiest way to create that URI is to use the ContentUri classes withAppendedId method. The withAppendedId method is the same method we used to construct the row URI when we implement the insert method earlier in this module. Just as we did then, we'll construct the URI by passing the table URI as the first parameter, and then we'll pass the rowId as the second parameter, and then we'll assign the result to the mNoteUri field we created earlier. Now that we have the row URI, the rest is easy. So we'll start up by returning a new CursorLoader instance. The first parameter is the context, so we'll pass this. For our next parameter, we'll pass the notes URI followed by the list of columns, and then for the rest of the parameters, we can simply pass null. And that easily, we're now querying our content provider for that specific note. So let's go ahead now and clean up the blank lines at the end of our createLoaderNotes method, as well as a few extra ending brackets we have in there. Alright, so now we should be all set. So to verify that everything works as we expect, let's go ahead and run it. Here we are with the application running in the emulator and I've added some breakpoints to our code so we can see what happens when we query for the note. So I'll go ahead and choose one of our notes here. You can see it had a breakpoint back in Android Studio, so let's switch back there. So you can see here, we hit a breakpoint inside of our createLoaderNotes method, so we're about to request a note. If you look down here in the Variables window, we'll see our mNoteUri field has the URI for this specific note, it's the URI for our notes table followed by a path for that notes rowId. So let's go ahead and release this guy and now we're at our breakpoint in our NoteKeeperProvider class' query method and we're about to do the match on the URI. If we look down at our Variables window, you can see that's a uri for our note, so let's go ahead and step, into our switch statement, step again, now we get to our case condition for Notes_Row, so we go ahead and step. You can see there in our Variables window that our rowId is 8, step again, that builds our Selection clause, step again, that builds our SelectionArgs. So we look down there in our Variables window, our rowSelection has a Selection clause of _id =?, which is what we want, and our rowSelectionArgs is an array, so let me go ahead and expand that. And you can see our rowSelectionArgs has one value, which is 8, and that's the rowId for our note. So I'll go ahead and release this now. And now with our application running back in the emulator, we can see that our note activity is displaying the correct note. So as you can see, the row URIs allow us to easily interact with a specific row of a content provider table. And the work we did earlier in this module made inserting a new row into a table easy as well. Now implementing the content provider's update and delete methods is just a continuation of the same work we've been doing throughout this module. Because implementing those methods doesn't involve anything we haven't already covered, we're not going to walk through the details of their implementation as part of the video, but you will find the full implementation of those methods in the exercise files for this module. So I'm going to go to the exercise files After folder, open up the NoteKeeper project, and you'll find a complete implementation of our content provider in the NoteKeeperProvider class. Alright, so now in our next clip, we're going to look at a couple of important items related to allowing other applications to more effectively interact with our content provider.

Interacting with Other Applications
When we started our discussion of content providers, we say one of the real powers of content providers is that they're accessible to other applications, and so that allows other applications to interact with the data exposed by our content provider, but simply making the content provider available may not be enough because the other application may not know much about the data exposed by our content provider. So we can actually make more information available and there is two key things we can do. One key thing we can do is make our content provider's contract class available to other applications and we can also identify the mime type of the data returned by each URI that our content provider handles. So let's look first at this idea of making our contract class available to other applications. Now the way we do that is by either building a jar file or an Android library that contains only our contract class. Now the process of building the jar file or an Android library with Android Studio is pretty straightforward. So I've got a URL there that will actually walk you through how to do that. Now once we build a jar file or the Android library, other applications can then reference that jar file or library, and the key thing about it, we then allow that application to take advantage of all the constants that we have inside of our contract class. Now as you recall, we first started working with our content provider, we built another application named OtherApp that requested data from our content provider, and of course, it did that using a Loader. So now in order to access our content provider, it had to have the literal string of the URI that our content provider exposed the courses data through and then it had to have the literal names of all the columns and then when it actually constructed the CursorLoader because it wanted the rows returned back in order by course_title, I had to put the literal for that column name as well. Well by making our contract class available as a jar file or an Android library, OtherApp could then import the classes contained inside of our contract class and that would simplify coding against our content provider a great deal. So with the contract class in place, instead of having to put the literal for the URI, it could actually use the URI constant exposed by our Courses class. And then when identifying the columns, it could also take advantage of all those constants we have inside of our contract class. So if you expect other applications to frequently interact with your content provider, it's worth exporting your contract class out into a jar or an Android library. Alright, so now in our next clip, let's look at what's involved in identifying our URI mime types.

Identify Each URI Mime Type
When we create a content provider, we normally want to provide the mime types of each of the URIs we support. Now all a mime type is a way to describe data and there are many common mime types available. The thing is, our data doesn't fit any of the common mime types because as opposed to being something like an image file or an XML file, our data is cursor based and the actually structure of it is defined by our application. So what we need to do is construct our own mime type. Now when it comes to constructing our own mime type, Android tells us how we should do it. Basically, it should include our table name, our content provider's authority, a value that indicates that it's a vendor mime type, which basically means that the mime type created by a specific application. And then one of the key things we need to include in the mime type is whether that URI returns back a single row or could return back multiple rows. So let's look at how we would construct a mime type that corresponds to a URI to reference our courses table. Well it would include a name courses, we would precede it by our content provider's authority, and then we start it out with this vnd. and that indicates that it's a vendor mime type, other words, an application defined mime type. And then we need the prefix for our mime type. So if the URI returns only a single item, then we prefixed in mime type with vnd. android. cursor. item, but if that URI could return back multiple rows, then we prefix the mime type with vnd. android. cursor. dir. So let's look at a couple of examples. So the URI to access our courses table. Right, we know that could return back multiple rows. So the mime type for this guy starts out with that vnd. android. cursor. dir and then it's followed by the identifier we've created for our courses table. But if instead that URI corresponds to a specific row in our courses table, we're going to prefix our mime type with a vnd. android. cursor. item followed by the mime type identifier we've created for our courses table. Now it sounds like there is a lot going on here, but in practice, identifying the mime types for our URIs is actually pretty straightforward. All we have to do is implement our content provider's getType method. The getType method receives a URI as a parameter and all we have to do is return the appropriate mime type for that URI and we create these mime types by simply concatenating the appropriate strings together. Now the ContentResolver class has a couple of helpful constants. When we're constructing a mime type for our URI that can return back multiple rows, we can prefix our mime type with a constant cursor_dir_base_type and we're constructing a mime type for a URI that returns back a single row, we can prefix our URI with cursor_item_base_type. Alright, so to get a better sense of how all this works, in our next clip, we'll actually implement our content provider's getType method.

Returning the Appropriate Mime Type
Here we are back in Android Studio and we're currently looking at our content provider's getType method. And what we want to do now is implement our getType method to return back the mime type for each of the URIs supported by our content provider. Now to get us started, let's declare a string variable to hold the mime type. We'll name the variable mime type and we'll have our getType method return that variable. The getType method receives a URI as a parameter. So just as with the other content provider methods, we'll call the UriMatcher classes match method to identify what URI we've received and then we'll assign it's returned value to the local variable we'll name uriMatch. So let's go ahead and add a switch statement for the value of uriMatch. And now we need to handle each of our URIs. So the first URI we'll handle is for our courses table, so let's add a case condition for that. So what we want to do in this case condition is construct the mime type that corresponds to this URI. Now before we actually construct the mime type, why don't we go ahead and show what the mime type should look like in a comment. Remember that the first part of the mime type indicates whether URI returns back a single item or it might return back multiple rows, well in this case, it might return back multiple rows, and since it might return back multiple rows, the mime type starts out with a value, vnd. android. cursor. dir, then that's followed by a /, the only constructed part of the mime type that's specific to our table. Now remember that this in an application defined mime type, so it starts out with a vnd value that indicates that it's a vendor specific mime type, then we follow that with the authority for our content provider, and then we'll follow that by a value that's specific to our courses table, so we'll just put. courses. So that's the value we want to assign to our mime type variable, but there is actually a number of constants available that can help us build that mime type. So start out by assigning to our mime type variable. So for the first part of our mime type, the ContentResolver class has a constant we can use. So that constant CURSOR_DIR_BASE_TYPE contains that value vnd. android. cursor. dir. So that takes care of the start of our mime type, so let's go ahead and add a / to the end of that, and then we'll start constructing our specific part of the mime type. So we'll start with a string literal containing vnd. The next thing we want to add is our content provider's authority, so we'll use the authority constant from our contract class, and then we'll add a period, and then we'll add the part that's specific to our courses table. So we'll actually use the path constant from our Courses contract class. So that takes care of creating the mime type for our content provider's courses table. Now as we go to construct the other mime types, a big part of this is going to be the same for each one. That vnd. followed by the authority followed by another period is going to be the same for each one, so let's go ahead and highlight those. And what we can do is make those a constant within our provider class. So let's do a Ctrl+Alt+C, that brings up a dialog to create our constant. Let's name our constant MIME_VENDOR_TYPE, then we'll go ahead and hit Enter. And so now for the remainder of our mime types, we can just use that constant, instead of having to spell out all those parts. So that's our courses table. Now let's do the same thing for our notes table. So let's go ahead and add a case for that. So we're going to build this one pretty much the same. So we'll assign the mime type, again, we'll use that same constant from the ContentResolver class, we'll add on the / in our MIME_VENDOR_TYPE constant, then we'll add on the path constant from our Notes contract class. So that takes care of our notes table URI. Now let's do the same thing for our NOTES_EXPANDED table URI. And again, we build that mime type exactly the same, except we use our Path_Expanded constant in this case. And that takes care of all the table URIs that our content provider supports. Now before we go on, let's just go in and indent each of these break statements so they line up with the code above them. There, that looks a little better. So now in addition to these three table URIs, we know we also support a row URI, so let's go ahead and add a case condition for our NOTES_ROW constant. Now when we build this mime type, the initial part of the mime type is going to be a little different because this URI returns back a single item. So now in this case, using the CURSOR_ITEM_BASE_TYPE constant, rather than the cursor. dir base type constant and this CURSOR_ITEM_BASE_TYPE constant indicates this is a mime type for a URI returns back a single row. So let's go ahead and add the rest of the mime type to the end here. And you'll notice that the latter portion of the mime type for our NOTES_ROW URI is the same as the latter portion of the mime type for our notes table URI and that's because the structure of the data returned is the same in both cases. In both cases, we're returning back data from our notes table. The difference in the two mime types is only in the beginning part because the notes URI can return back multiple rows, whereas the notes URI returns back a single row. And with that, our getType method is all set, as is our content provider. Our content provider now provides access to our course and notes data in a way that makes that data easily accessible from both our own application, as well as others. And remember, if you want to take a closer look at any aspect of our content provider, the full code for our content provider is available in the after folder of the exercise files for this module.

Summary
To wrap up, here is some of the key things you want to remember from this module. Remember that we use a ContentResolver to get access to a ContentProvider. The ContentResolver exposes methods for each of the available operations and those methods all accept a URI. Then the ContentResolver uses that URI to identify the appropriate content provider and then delegates the operation to that ContentProvider. But now we know that content providers support the full set of data operations. So in addition to supporting query, they also support insert, update, and delete. But each of those operations are still generally backed by SQLite operation, so we still rely on SQLite as the data store behind each of those operations. Now each of our content provider operations receive a URI. We know that we can receive table URIs, but in some cases, we can also receive row URIs. So now row URI as its name implies is a URI that identifies a specific row in a table that's composed of the table's URI followed by a path containing the row id of that specific row. So when we insert a new row into a content provider table, it returns back the row URI of that newly inserted row. But now the other operations, in addition to handling table URIs, also need to be prepared to handle row URIs. Now we can still do that using the UriMatcher class, but what we do is we use a hash symbol in the matcher pattern to identify that we want a row URI, and then we perform the database operation, we extract the row id from that URI, and then we construct a selection criteria based on the _id column of the database table. And we know that content providers allow our application to expose data to other applications, but there are things that we can do to improve that interaction. One thing we can do is take our content provider's contract class and put it into either a jar file or an Android library and that allows the other application to use the constants contained in our contract class. In addition, we can implement our content provider's getType method provide mime types for each of our supported URIs. Alright, that wraps up this module and it also wraps up our discussion of content providers. In our next module, we'll learn how to use Android notifications to interact with a user even when that user is not actively using our application.

Working with Notifications
Introduction
Welcome to our next module, Working with Notifications. This is the Pluralsight course, Exposing Data and Information outside your Android app. My name is Jim Wilson. In this module, we'll look at how we can use notifications to interact with a user even when that user is not actively using our application. We'll start out with an overview of notifications, we'll then see how we can create display notifications, we'll then look at the important role of the Android Studio generated helper class and how we can customize our notifications within that helper class, we'll see how to provide expanded notification information using notification styles, we'll see how to launch an activity when a user taps on a notification, and then we'll finish up, we'll look at how to provide additional user actions directly from our notifications.

Notification Overview
Notifications are an aspect of the Android platform that allow our application to provide a user experience that actually runs outside of the application itself because notifications are actually displayed by system and notifications are initially displayed as an icon in the notification area located at the top of the screen, but then a user can swipe down from the top of the screen to open up the notification drawer and then they can view the full notification. Now this is likely an experience you're familiar with. We'll look at the Android screen on pretty much any Android device, you'll see icons at the top of the screen. So the icon we have there might be an icon we display for a note notification from our application. Then if the user swipes down from the top of the screen then a notification drawer opens up and they can see the more complete information from our notification. Now there is a number of pieces of information we can control in our notification, the basic ones are small icon, that's the icon in the top-left corner here of our expanded notification, that's the same icon that shows up in the notification area at the top of the screen. We've got what's called our content title, which will be a title for a notification along with the content text. And on most version of Android, you can also include a large icon as we show here. Now it's important to understand though that specific features of Android notifications vary based on the Android version because the notification system is actually an area of Android that's evolved a great deal over time, a number of features have been added and a few have even been removed and managing all those differences manually would be very cumbersome. So notifications are an area we're almost always going to use to compatibility class, so we're going to use a NotificationCompat class, rather than a Notification class because it provides methods for all the features that may be potentially available, but then its behavior actually adjusts based on the version of Android your application is currently running on. And in our next clip, let's look at what's involved in actually creating a notification.

Creating and Displaying Notifications
We create notifications by following the builder pattern. So rather than create our NotificationsCompat instance directly, we instead use the Builder class that's nested within our NotificationCompat class. Now Builder class exposes set methods, and if we use those set methods to specify all the features that we want the actual notification to have. And then when we're all done, we call the Builder class' build method and that takes care of creating a NotificationCompat instance with all the features that we've set. Now creating a notification doesn't actually display it. That's where the NotificationManager class comes in. NotificationManager class is responsible for all display management and it actually exposes an Android system service so we get access to it through the Context. getSystemService method, but we generally don't have to write our own code against the NotificationManager because Android Studio actually generates a helper class for us that simplifies a lot of the aspects of working with notifications. It allows us to centralize all of notification code within the generated class and it handles all the interaction with the NotificationManager. This generated class will include two public static methods, notify and cancel. So we display a notification using the generated classes notify method and it's that notify method that contains the code to create the actual notification, so that's the code we're going to customize to present the notification the way we want to present it. Now when we call notify to display notification, if we then call notify again why the old notification is still visible, the new notification automatically replaces the existing notification and that just assures that our application is always showing the latest notification information. But if we do need to remove a notification, the generate a class' cancel method will allow us to explicitly remove the notification, but this cancel method is not a method we use a lot because generally when we create a notification, we create the notification to automatically be removed when the user taps on it, so the user's interaction will remove the notification, as well as displaying a notification will replace any existing notifications that are out there. Alright, so now in our next clip, let's start adding the code to our application to display notification.

Adding a Notification Helper Class
Here we are with our app running in the emulator and what we want to do now is add the code to app to display notification. For now, let's do something simple. Let's allow the user to select a note, and then once I select that note, let's allow them to choose a menu option to just create the notification to remind them to review the note later. Now to allow the user to create the notification, I've added another option to the Options menu. So let's head up to our Options menu. If I choose the Options menu, you see we now have an option here, Set reminder. So the behavior we want is that when a user selects that reminder, we'll create the notification that reminds them to review this note. Now let's switch over to Android Studio. So here we are in Android Studio. We're looking at the NoteActivity classes onOptionsItemSelected method. Remember that this is the method that gets called when a user makes a selection from the Options menu. Now within the method, I've added the code to handle when a user makes a selection of this set_reminder option, and notice that code there calls a method showReminderNotification, and just below there, we have our showReminderNotification method, as you can see, it's just a stub. So it's from within that method we'll actually call the code that displays a notification. So with all that code in place, we're ready to do the actual work of displaying a notification. To help us out with displaying a notification, we use a helper class that Android Studio generates for us. So we'll go up here to the Android Studio File menu, we'll choose New, and if you look at the menu there all the way towards the bottom, you'll see there is an option UI Component, let's go down and select that. And you see when we select UI Component, it gives us a couple of options and one of those options is Notification, let's go ahead and choose that. So this dialog that opens up will walk us through generating a helper class to display a notification. So let's go ahead and give it a class name of NoteReminderNotification. So now for our Style when Expanded option, let's go ahead and change that to none for right now. And for Show Additional Actions, let's go ahead and uncheck that. Now we're going to dig into both of those a little bit later in this module, but for now, let's just focus on the very basic aspects of displaying a notification. So we'll go ahead and click Next. So the next thing we need to do is choose the icon we want to use as our small icon. Now remember that the small icon is the one that appears up in the notification area at the top of the screen. By selecting the image here, Android Studio will take care of creating a number of different renderings of the icon so the icon displays correctly across the various versions. So let's go up here where it says Clip Art, we'll click on that button. So let's go ahead and select this icon here that looks like a clipboard that has an exclamation point on it and that's a good choice for our app because we're going to use the clipboard to represent notes. So we'll go ahead and say OK. So now we have our icon selected, let's go down here to Finish, and you can see here that it's created our NoteNotificationReminder class. If we scroll down a little bit, you can also see that it's created our notify method. Now this is a static method, and as you recall, it's this notify method that handles displaying the notification. We'll look at the details of the notify method shortly, but first, let's give it a try. So we see it has three parameters, a context, a string, and an int. So let's head over to our NoteActivity class and we'll call this with some dummy values. So we're over here in our NoteActivity class and we're inside of our showReminderNotification method, so let's call NoteReminderNotification. notify, the first parameter is a context, so we'll pass this, second parameter is a string, so we'll just pass in a string that says this is dummy text, and our last parameter is an int, so let's just pass in 0. So with that call in place, we should now be able to display our notification. So let's go ahead and run our app. Here we are with our app running in the emulator. Let's go ahead and choose a note, let's go up to our Options menu, we'll choose Set Reminder, and you can see as soon as I chose set reminder, you can see the clipboard with exclamation point showed up in the notification area at the top of the screen. So let's go ahead and pull the top of the screen down, and you can see there now that there is a notification that comes from our NoteKeeper app, you can see our clipboard icon there in the top left, you see that it has a title, it says note reminder and this is dummy text or that this is dummy text is the string value we passed in, it's got some content text, and it even includes a large icon. So our code is successfully displaying a notification. So now we're off to a good start. So in our next clip, let's modify the NoteNotificationReminder class to display a notification of the appropriate information for a note.

Customizing a Notification Helper Class
Here we are back in Android Studio and what we want to do now is notify our notification helper class so it displays a notification that's appropriate for our app. Since our notification is a reminder to review a note, we'll make the notification title something like review note, and we'll include the note text as a notification's content text. And while we're at it, we'll look for opportunities to include a bit of that branding within the notification. So now we're currently looking at the notify method of our NoteReminderNotification class. Remember that the notify method is responsible for creating and displaying the notification. To display the note text in our notification, we'll need a note text as a parameter. So first, let's remove the notify methods number parameter and then we'll change the name of the example string parameter to noteText. Now you'll notice here just inside of the notify method, we have three local variables that all depend on that exampleString parameter. Now since we don't have that parameter anymore and we don't need these local variables, let's just go ahead and delete them. Okay, now that we have those gone, let's just scroll down here a little bit. Now we're ready to start creating our notification. Remember that the way we create a notification is by using the Builder class that's nested inside of the NotificationCompat class. So you can see here we create a new instance of NotificationCompat. Builder and we assign it to a local variable named builder. Now once we create the builder instance, we can start calling the various set methods to customize the appearance of our notification, and you can see here, just below where we create the builder instance some of the set methods that are currently being called. Now notice that none of those method calls are using our builder variable. Rather, each call simply begins with a dot. What we're doing here is chaining the calls together. Notice that the line that creates a new builder instance does not end in a semicolon, and because of that, we can use the reference to the newly created builder instance. So using that reference, we can then call the setDefaults method. If we were to take a look at the documentation for the setDefaults method, we would see that its return value is a builder reference. Well, since setDefaults returns a builder reference, we can then call the next method, which in this case, is setSmallIcon. SetSmallIcon also returns a builder reference, so we can then call the next set method, and this behavior continues with each of the set methods. Now this behavior of each set method returning the builder reference is common when working with most types that are constructed using the builder pattern and we do this for the simple reason that it reduces typing because it allows us to chain each of the set calls together. So now, let's walk through the specific notification features that are set here in our helper class. And you'll see, in addition to those core features of the notification that we looked at in the slides such as icons, title, and text, notifications actually provide a very fine level of control over a number of notification features. So now the first set method we have here is setDefaults, and calling setDefaults with DEFAULT_ALL simply says that we want the notification indicators, such as lights, sound, and vibration, to simply user default behaviors. Now next after that, we set the small icon. Remember that this is the icon that appears in the notification area at the top of the screen. The next two calls set the content area of the notification, and for the content title, we generally want this to indicate the purpose of the notification. So let's set our notification title to literal text, Review note. So that's our ContentTitle. The ContentText is really the body of the notification, so let's set that to the value of our note text parameter. So that sets our notification's ContentText. Next, we set the priority. Now changing the priority affects where in the notification drawer the notification is positioned. If you're ever wanting the majority of the time you just want to go with PRIORITY_DEFAULT as we have it here. Now next, we set the large icon, which is that large image that appears within the notification. Now notice we're passing in a variable named picture. If we look up towards the top of the screen, we can see the picture variable is of type Bitmap. Now the way we normally create the Bitmap is by expanding one of our drawable resources into a Bitmap using the Bitmap factory class as shown here. Now let's change from the example picture resource to something that's more appropriate for the branding of our app. If we look over here in the Project window, we'll see that I've added a drawable named Logo. This is a drawable resource that contains the Pluralsight logo. Now let's change from the example picture resource to our logo resource. With that, our notification will now include the Pluralsight logo in it. Now let's scroll down here just a little bit. So now you can see here that our next two set methods are setTicker and setNumber and these are two methods whose purpose has changed a bit over time. On older versions of Android, setTicker is used to display a bit of scrolling text across the notification area and the notification is first displayed and most devices no longer run these versions of Android. On newer versions of Android, the main purpose of setTicker is to provide information to users who rely on accessibility systems features such as screen readers. For example, users who have low vision, utilize tools that will cause the text we pass the setTicker to be read aloud to them when the notification is displayed. Now I generally pass the same value to setTicker that I pass for the ContentTitle. So let's go ahead and pass in that little string, Review note. So that sets our ticker. Now we have our setNumber method. Now the exact behavior of setNumber has also changed over time. Its primary purpose is to indicate that a particular notification relates to multiple items. For example, an email app might pass the number 2 to setNumber to indicate that there are 2 email messages. Well on some Android versions, the value passed here appears directly in the notification, but starting in Android 8, the value passed the setNumber is actually part of the batch system and the batch system allows notification related information, such as the notification count to be viewed from the launcher screen. But now in our case, we're always displaying a notification for just a single note, so we can just go ahead and remove that call to setNumber. Alright, so now with that, we have all the initial settings for our notification in place. In our next clip, we'll add the code to callerNotify method and we'll verify that everything works as expected.

Using a Notification Helper Class
Here we are back in the Android Studio and we're continuing our work in displaying a notification that's appropriate for our app. Now we're currently looking at the notify method of our NoteReminderNotification class, and as you recall, in the previous clip, we change the notify method to accept noteText as a parameter and that allows us to display the noteText within a notification and we also configure the NotificationCompat. Builder class to construct a notification to appear as we'd like it to. Let's take a quick look now at just how the note reminder notification class displays the notification. So let's scroll down to the end of the notify method. Now here we are at the very end of our NoteReminderNotification class' public notify method and notice that the last thing that this notify method does is call another notify method and once of the things that we pass to that notify method is return value of our builder's build method. So what that means is that it's building a notification composed of the features that we've set on the builder. Now we can see the other notify method just below where we call it. Notice that this method is marked as private static. It's this private static notify method that handles the actual details of displaying the notification. Now we rarely have to make any modifications to the code in this method, but I just wanted us to take a quick look at it so we can see how the notification is displayed. Now notice that the first thing this method does is call getSystemService to retrieve the NotificationManager. Now once it has a reference to the NotificationManager, it calls the NotificationManager's notify method passing in our notification and it's this call to the NotificationManager's notify method that actually causes the notification to display. So now all this code here with the versions checks in it, that's all there to simply deal with the change in the signature of the NotificationManager's notify method that actually happened many years ago. So in practice, it's this first call to the NotificationManager's notify method that's used in virtually all cases. Alright, now that we have a sense of how our notification gets displayed, we're almost ready to try out our application. Now before we do that, we need to make a quick change to the way the NoteActivity class calls the NoteReminderNotification class' public notify method. So let's head over to the NoteActivity class. So we're over here in our NoteActivity class' showReminderNotification method. It's this method that calls the NoteReminderNotification class' public notify method. Now since we want the Notification class to display the current note's text, let's declare a string variable named noteText. We'll then use the field that references the text view for the noteText to get the current noteText. So that'll put the noteText in our variable named noteText, so let's go ahead and pass that variable to our call to the notify method. Alright, so now with that, we should be all set. Let's go ahead and run our program and let's see what the notification looks like. So here we are with our app running in the emulator. So let's go ahead and choose a note. Now when that note opens, let's go up to our Options menu and we'll choose Set reminder. You can see as soon as we choose Set reminder, we can still see the small icon for our notification up there. Let me head up here and just pull the notification drawer down, and now we can see that we have a notification that's more appropriate for our application. Now, of course, the first thing that jumps out at us is the Pluralsight logo, so our notification's appearance includes proper branding. Notice also that our content title indicates the purpose of the notification, we want to review a note. Now we can see the beginning part of our note text, so we get a sense of the specific content of the note. So with that, our notification is off to a great start. In our next clip, we'll look at how we can use notification styles provide more detail within our notification.

Notification Styles
Let's look now at notification styles and notification styles allows us to specialize the appearance of a notification because they allow us to create an expandable notification and that expandable notification can have more information in it than a standard notification can. Now each of the different styles provide a different expanded appearance. Now the way we apply a style is to first create an instance of a particular style type, and the NotificationCompat class has a number of different style types within it, and then on that style, we set the features that we want and then we associate the style with a notification builder by calling the builder's setStyle method. Now we can associate a style with a notification as part of the process of generating our notification helper class. Now you'll remember when we generated the notification helper class, in this section here Style when expanded, I chose None, which meant I wanted a notification that had no style associated with it. But you notice there is also three other options there, more text, picture, and list, and each of those options are associated with a particular notification style. So more text is associated with a style called BigTextStyle. Picture is associated with a style called BigPictureStyle. And list is associated with a style called InboxStyle. Now those are the only style types available, but those three are the ones we most commonly use. Now although each style has its own particular appearance, some aspects of them are the same. For example, one thing we can do with all the styles is add text to the summary line and the summary line is that area of text at the very top of the notification when its displayed within a notification drawer. Another thing they have in common is the ability to provide a different title from the regular content title. So what that means is that the notification can have one title with its expanded appearance and a different title in its standard appearance. Now although each of these styles have some aspects of their appearance in common, the reason we have the different style types is each provide their own individual capabilities. So for example, if we look at the BigTextStyle, that allows us to display a larger amount of text than we can in a standard notification and BigTextStyle is far and away the most common notification style that we'll use. And then we also have BigPictureStyle, and as its name implies, it allows us to display a relatively large image as part of the notification. And BigPictureStyle might be useful in a case where you're building something like a social application and you want to display the user and notification that draws attention to an image that's been received. And then we have our InboxStyle and this provides the ability to display a list of up to five items within the notification. Now one obvious place we might use a style like this is with an email application that shows some recent emails, but honestly, it's useful anytime we need to display a short list as part of the notification. For example, showing some recent status updates or something like that. Alright, so now in our next clip, we use the BigTextStyle to provide additional note information in our application's notification.

Displaying a Notification with BigTextStyle
Here we are with our app running in the emulator and we're looking at our app's notification as we currently have it configured to display. Now you'll notice that as our notification currently appears, we're only able to see a portion of the note text. In addition, we're not able to see the note title because we're using the text review note as our notification's content title. Now these are exactly the sort of things the BigTextStyle can help us with. So let's head over to Android Studio and we'll add the BigTextStyle to our notification. Here we are back in Android Studio and we're currently looking at the notify method of our NoteReminderNotification class. Now currently, the only note related parameter our notify method accepts is the note text. Since the BigTextStyle allows us a bit more options for content display, let's go ahead and add noteTitle as a string parameter as well. So now with that, we can pass in the noteTitle and the noteText to our notify method. So let's scroll down a bit to where we make the various set calls on our notification builder. So here we are where we set the various notification features on the builder. We'll go ahead and add our code to set the style just after the call to setTicker. Now it doesn't matter what order we call the various set methods on the builder, but I'm adding the call to setStyle in roughly the same point in the code that it would've been added had we chosen the more textStyle option when generating the helper class. So we'll go ahead and add the call to setStyle. Now here in the call to setStyle, we'll go ahead and create the new instance of BigTextStyle. Remember, the BigTextStyle is a nested type inside of the NotificationCompat class. Once we have the instance of BigTextStyle, we can start calling in methods that will set the features on that style. Now the first thing I want to do is associate the text that we want displayed in the body of the expanded notification and we do that with a method called bigText. And so what we'll do is we'll make our bigText the noteText. Now by associating the noteText with bigText, we'll be able to show more of the notes text within the body of the notification. Now remember that these styles also provide an alternate title, so we can set a different title on a styled version of the notification than we initially set on the notification. So what we'll do is we'll call a method called setBigContentTitle and we'll make that the noteTitle. So now the noteTitle will show up in the body of the notification, but we'd still like to tell the user that the purpose of this notification is to review a note. So what we'll do is we'll set the text Review note as the summary text on the notification. Now that takes care of associating the BigTextStyle with our notification. So with that in place, the expanding view notification will include the noteText in the body of the notification, the noteTitle in the body of the notification, and the text Review note will appear in the notification summary. Let's head over to the NoteActivity class now. So here we are in the showReminderNotification method of the NoteActivity class. Remember that this is the method that calls the notify method on our NoteReminderNotification class and we just modified the notify method to accept the note title in addition to the noteText. So let's go ahead and declare our local variable here of type string called noteTitle and then we'll get the notes current title by using a member field for the noteTitle text view. And then once we do that, we can pass our note title variable as a parameter to the notify method. Alright, so now that we have that done, let's go ahead and run our application and let's see what the notification now looks like. So here we are with our application running in the emulator. So let's go ahead and choose our Options menu. We'll choose Set reminder, that adds our notification, so let's go ahead and pull the notification drawer down. And now you can see our notification looks a bit different. Notice that in the body of the notification we now have the full text for our note. In addition, we have our notes title here, but if we look up on the summary line, the text review note now appears up in that summary line. So our BigTextStyle allows to put more information in the notification. But one of the things that's important to understand, just because we associate a style like BigTextStyle with a notification, the notification will not always be viewed using that style. Let's see what happens if another notification comes into the device. So here in my emulator, I'm going to go over here to the control bar, we have these dots down here on the bottom, I'm going to choose those, and that opens up the extended controls dialog. And the extended controls dialog allows me to interact with the emulator and simulate certain events coming in. So over here on the left, I'm going to choose phone. From here, I can simulate a call coming in or I can simulate a text message coming in. So let's get go down to the button where it says Send Message, I'll click that, and let's go ahead and close the dialog, and you'll notice here that there is now a notification at the top of the notification drawer indicating that a text came in, and when that came in, it changed the appearance of our notification. Notice that our notification has now gone back to its standard appearance. The title is review note and we only see a limited amount of note text. So a notification is only automatically expanded when it's the top notification in the notification drawer. Now we can manually expand it, if I go up here and just grab the bottom edge, I can pull it down, and notice this switch is now back to our expanded view, I can slide it back up, and it'll go back to its standard view. So it's important to understand that even when we associate something like a big textile with our notification, the notification may still be viewed in its standard style. Alright, so now that we have a good amount of information in our notification, in our next clip, we'll start looking at how we can allow the user to access an activity within our application by tapping on the notification.

Launching an Activity from a Notification
Now that we have our notification in place to remind the user to review a note, what we want to do now is make it very easy for that user to get to that note within our application. So what we'll do is we'll add the capability to our notification so that when the user taps on the notification, we'll have the notification launch our note activity displaying the note that was actually shown in the notification. Now to understand how to launch an activity from our notification, we just need to quickly review the steps involved in launching an activity from within our application. Remember that the way we launch an activity is we first create an intent, we associate whatever extras we need with that intent, and then we actually show the activity by calling the startActivity method passing in the intent we've created. To launch an activity from a notification, we can't do it exactly the same way that we do it within our application because remember that notifications are displayed by the system, so the notification that the user is interacting with actually exists outside of our app. That notification is actually part of the Android system. So what we need to do is have our app delegate the launch instructions for that activity to the notification. So we'll need to create the intent as we normally do, we'll want to associate any needed extras, but then somehow, we need to wrap up the active launching that activity with the intent that we've created. And this is where the type PendingIntent comes in. What a PendingIntent does is it wraps up an intent along with the action to perform with that intent. And then once we create a PendingIntent, we can pass that PendingIntent outside of our app and the receiver of that PendingIntent can then perform the action contained in the PendingIntent. Now the way we created a PendingIntent is we start out by creating our intent along with any needed extras as we normally do and then the PendingIntent class has a static method called getActivity. We pass that intent to this get activity method and now we'll return back a PendingIntent instance that wraps up that intent along with its start activity action. So with our PendingIntent created, we can then associate that PendingIntent with a notification and we do that as part of the work we're doing with the builder to set our features on the notification. So our notification builder class has a setContentIntent method, we pass the PendingIntent to that method, and then once we display the notification and respond to the user tapping on the notification, the notification will then use that PendingIntent to display our activity. So in our next clip, we'll create a PendingIntent to display our note activity and associate that PendingIntent with our notification.

Launching NoteActivity from the Notification
Here we are back in Android Studio and what we want to do now is add the ability to launch our note activity and respond to the user tapping on our notification. Now to get us started, let's quickly review the code that displays our note activity when the user selects a note in the Recycler view. So we're currently looking at our NoteRecyclerAdapter's ViewHolder class. Now as you recall, each ViewHolder instance is associated with a note and it has the idea of that note contained in the Int field named mId. Now down here, we have the code that displays the note in the note activity when the user selects that note in the Recycler view. Now we do that by first creating an intent that contains the NoteActivity's class information and then we associate the mId field with the intent as an extra. We name that extra by the NoteActivity class' NOTE_ID constant. We then pass the intent to the startActivity method to launch the note activity. So what we're basically doing here is performing an action on a target. The startActivity method performs the action of launching an activity. The intent describes a target of that action. But now when it comes to displaying the note activity from our notification, we don't want our app to perform the action. Rather, our app needs to describe the action. So let's head over to our NoteReminderNotification class and see how we can describe an action with a PendingIntent. Here we are in the notify method of our NoteReminderNotification class. Now since displaying a note in the NoteActivity requires that we have the notes id, let's add an int parameter named noteId to our notify method. Now that we have the noteId, we can create an intent for the note activity. So let's declare a local variable of type intent and we'll name it noteActivityIntent and then we'll create a new intent instance passing in the context and the class information for our noteActivity. We'll then put in extra on the intent, we'll pass in the extra's name using the noteActivity class' NOTE_ID constant, and then as the value of the extra, we'll pass in our noteId parameter. So as you can see, we create the intent that we want to associate with our notification exactly the way we created the intent inside the click handler of our RecyclerAdapter's ViewHolder and that's because the target is the same in both cases. In both cases, the target is the NoteActivity class and we want to pass the NoteActivity class the noteId. Alright, so now that we have our intent, let's just scroll down here a bit. Here we are where we set the features on our NotificationCompat Builder class and you can see that the code that Android Studio generated contains a call to the builder's setContentIntent method. Now that method accepts a PendingIntent instance as a parameter. To create that instance, the code calls the PendingIntent class' static method named getActivity and what we're doing here is associating a description of an action we want to perform when the user taps on a notification. Now the PendingIntent describes the action and creating the PendingIntent with getActivity indicates that we're describing the action of launching an activity. So what we need now is the intent that provides a description of the action's target. Now the generated code includes an intent that says we want to launch an activity to view Google. com, which on most devices would open Google. com in a web browser, so let's get rid of that intent and let's replace it with our noteActivityIntent. And so now, that makes the target of that action the activity described in our noteActivityIntent. So when the user taps on a notification, the notification will now launch our NoteActivity class, and since we passed a noteId, it'll display the corresponding note. And now in most cases, once the user taps on a notification, we want that notification to go away. Now the way we cause that to happen is by calling the builder class' setAutoCancel method with the value of true and you can see we're doing that here. So now this way, when the user taps on the note, the notification will go away and our noteActivity will appear. Alright, so we're all set here. Let's head over to our NoteActivity class and add the code to pass the noteId to our notify method. So now we're looking at the showReminderNotification method of our NoteActivity class and we need the id of the note that's currently being displayed so we can pass it to our notify method. So as you may recall from earlier in the course, the NoteActivity class now uses our content provider to interact with a note. So we keep the row URI for that note and a field named mNoteUri and we can extract the row id from the URI using the parseId method from the ContentUris class. ParseId returns a long, so we'll cast its return value to an int, we'll sort a local variable named noteId and then we can pass noteId to our notify method. And so now with that, we're all set. So let's go ahead and run our program now and verify that everything works as we expect. So here we are with our app running in the emulator. We've got a note open in our note activity, so note with a title Delegating intents. So let's go hit our Options menu, let's choose Set reminder, and when we do that, we see our notification icon appear up top there in the notification area, so let's go ahead and leave this activity. Let's even minimize all of our activities. So now we have those activities out of the way, let's head up top here to the notifications area, let's go ahead and pull the notification drawer open so we see our notification there, let's go ahead and tap on our notification. And when we do that, we now see our note activity open and it's displaying that same note, the note with the title, Delegating intents. So all that behavior worked. We can now display our notification, and when the user taps on it, we open up our activity showing that note, and if you look up top there, our icons are no longer in the notification area, which means that the notification automatically cancelled just like we want it to. But now in some cases, we may wish to allow the user to perform additional actions directly from that notification, so in our next clip, we'll see how we can do that.

Additional Actions
Let's look now at a feature of notifications known as additional actions. Now you recall, when we generated our helper class for our notification, there was an option Show Additional Actions and I had unchecked that option when we generated our helper class. Now with that option checked, the code that's generated by Android Studio creates a notification that includes a section at the bottom, which is the additional action section and the code generated by Android Studio includes two additional actions and the idea here is that the notification we currently have on screen has three actions associated with it. When we called setContentIntent, we associated the primary action of tapping on the notification. As our name implies, these additional actions are actions that can be performed beyond the primary action. Now the way we add additional actions is through the Builder class' addAction method, and when we add these actions, we can pass in a resource id for an icon we want associated with the action, the display text for the action, and then we have to indicate what actually happens when the user taps on that action and we're going to do that just as we did with setContentIntent. So we're going to provide the PendingIntent that describes the action we want performed. Now remember, the primary action of interacting with a notification is provided through setContentIntent. These additional actions, as their name implies, are added actions, and the added actions are not always visible, they're only visible when the notification is in its expanded view. Now our autocancel setting does not apply to these added actions. Interacting with any of these added actions will not automatically remove the notification. If we want to remove the notification, our app is responsible to actually explicitly call cancel in response to the user performing that action. So let's take advantage of these additional actions in our application's notification. Let's go ahead and add an additional action called View All Notes and what will happen is that if the user chooses this View All Notes additional action, what we'll do is go ahead and display our main activity and the full list of notes, so this will give our users two options. Tapping on the notification itself will display the note in our note activity, but tapping on this View all notes action allows them to see the list of notes in our main activity. And so, in our next clip, let's go ahead and implement this behavior.

Launching the Notes List as an Additional Action
Here we are back in Android Studio and what we want to do now is add an action to our notification to allow the user to view the list of notes contained in our main activity. So we're here inside of the notify method of our NoteReminderNotification class. And what we'll do is add the code for this additional action just below where we call setContentIntent. So now to add this additional action, we'll call the Builder class' addAction method. So now its first parameter is the resource id of the icon we'd like to associate with the action. In our case, we don't want an icon, so we'll just pass 0. The next parameter is the display text for the action, we'll make that View all notes. Then next, we need to associate the PendingIntent for this action. So we'll call the PendingIntent class' getActivity method just as we did when we called setContentIntent. Now remember that the PendingIntent's getActivity method returns back an instance of a PendingIntent that knows how to perform the action of starting an activity and we need to give it the intent that describes a target of that action. So here in our call to getActivity, let's go ahead and create a new Intent, we'll pass in the context, and the activity we want to start is MainActivity, so we'll pass in MainActivity. class. And so now with that, we should be all set. We've added an action to our notification, the actions label is View all notes, and when the user taps on View all notes, we'll launch our application's MainActivity. So let's go ahead and run our app. So our app is up and running now, we'll go ahead and choose a note, we'll go up to our Options menu, we'll choose Set reminder, we can see that our notification icon shows up there. Let's go ahead and leave this activity. Let's go ahead and minimize everything. We'll head up to the Notification area. Let's expand the notification drawer. You can see there is our notification. Our notification now has a View all notes at the bottom. Let's go ahead and choose View all notes, and when we chose View all notes, it launched our main activity. So our View all notes actually worked correctly or as we mentioned the additional actions don't automatically cancel notification, so our notification icon is still up here. If I pull down the notification drawer and I tap on the body of the notification, it launches my note activity displaying that note. And with that, our notification behaves just as we want it to. So our application is now able to display a rich and interactive notification. That notification provides the user with detailed information about a note. The notification allows the user to jump directly to our note activity, and if the user prefers, they can use that additional action to view the full list of notes in our main activity.

Summary
To wrap up, here is some of the key things you want to remember from this module. Remember that notifications are displayed by the system, they're not displayed by our application, so it gives us the ability to provide a user experience that actually runs outside of our application. And when we first display a notification, it appears as an icon up in the notification area. But when the user pulls down a notification drawer, they can see more detailed information. They can see that same small icon, they can also see a content title, some content text, and on most versions of Android you're likely to encounter, you can also display a larger icon within a notification. A key part of displaying our notifications is the Android Studio generated helper class because it centralizes our notification creation code and it handles the details of displaying a notification or removing a notification. And we're working on the code to create our notification, we're going to be working on the Builder class that's within our NotificationCompat class. Now the power of this class allows us to set all the desired features we might want, but because there is so many differences across Android versions, this class takes care of adjusting the actual behavior to work correctly on whatever version of Android the app is currently running on. Remember that we also have notification styles and they allow us to specialize the appearance of our notifications when that notification is expanded, so allows us to provide things like an alternate title, alternate text, and even add text to the summary line. Now there are a number of these different notification styles and there are three that we commonly interact with, the BigTextStyle allows us to include a large text area in the notification, the BigPictureStyle allows us to include a large image in the notification, and the InboxStyle allows us to include a list in the notification. Remember though that the content associated with the style is only visible when the notification is expanded. If the notification is not expanded, it'll still display in the Standard view, so you want to be sure that you provide adequate information in the Standard view, not rely entirely on the view as it appears when the styles apply. Now remember the important role of PendingIntents. Remember the PendingIntents allow us to create an intent and then wrap it up in an action and then pass that outside of our application. So using PendingIntents, we can associate a default action with our notification. We create that PendingIntent and then pass it into the setContentIntent method of our Builder class, and then when the user taps on the notification, whatever action is wrapped up in that PendingIntent will then be performed. In most cases, we use that to display an activity. Now when we create our notification, we can set auto cancel to true, and by doing that, when the user taps on the notification, the notification is automatically removed. But now remember, we're not limited to the default action. We can also provide additional actions and these normally appear along the bottom of the notification. We add those using the addAction method. We still rely on PendingIntents to provide the actual behavior. But now remember, the one key difference between additional actions from the default action is that even if you set auto cancel to true, it doesn't apply to these additional actions. You must explicitly cancel the notification if you want it removed and respond to the user selecting one of the additional actions. Alright, that wraps up this module and it wraps up this course. In our next course, we'll start digging into the powerful platform capabilities of Android, things like handlers, services, broadcast receivers, alarms, and even more.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Intermediate
Rating
4.9 stars with 14 raters(14)
My rating
null stars

Duration
2h 56m
Released
5 Oct 2017
Share course
