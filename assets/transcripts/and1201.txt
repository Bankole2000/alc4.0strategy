Android Fundamentals: Implementing Effective Navigation
by Mitch Tabian

This course focuses on navigation with Android. By the end of the course you’ll understand how to implement effective navigation using activities, fragments, alert dialogs, bottom navigation views, navigation drawers, and tabs.

At the core of every great Android application is an excellent navigation system. In this course, Android Fundamentals: Implementing Effective Navigation, you will learn how to provide a seamless user experience by implementing the various navigation methods in Android. You will take a close look at activities and fragments. You will see how to use alert dialogs. You will also explore bottom navigation views, navigation drawers, and tabs. When you’re finished with this course, you will have a foundational knowledge on navigating Android applications that will help you as you move forward to develop mobile applications.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Beginner
Rating
4.7 stars with 27 raters(27)
My rating
null stars

Duration
2h 42m
Released
16 Feb 2018
Share course

Course Overview
Course Overview
Hello. My name is Mitch Tabian, and welcome to my course, Android Fundamentals: Implementing Effective Navigation. I'm a self-employed Android developer, and I'm here to teach you about implementing effective navigation with Android. Effective navigation is absolutely fundamental to every Android application. The way a user navigates the app will have a huge impact on the overall user experience. As you'll see in the course, back navigation is especially difficult to master. Back navigation refers to the way users travel through the app when pressing the back button or navigating backwards. Some of the major topics we'll cover include navigating with activities and fragments. Having a little bit of both is key to providing a great user experience, and you'll see why. We'll be using a bottom navigation view as the primary method of traversing the app. Personally, I love bottom navigation bars because they provide a very clear method of navigation. A navigation drawer will be used to supplement the app's navigation. Navigation drawers are great for providing a way to centralize or reset a user's location in the app. Tabs are used in almost every app, and it's for good reason. Tabs provide an easy way to swipe through content that's usually static in nature. By the end of the course, you'll have an excellent understanding of the most important concepts when it comes to navigating an app. Effective navigation is absolutely fundamental to providing a great user experience. Before beginning the course, you should be familiar with Android Studio and know how to run applications using the Android emulator or a real device. I hope you'll join me on this journey to learn about navigation with the Implementing Effective Navigation course at Pluralsight.

Getting Started
Introduction
My name is Mitch Tabian, and welcome to my course, Android Fundamentals: Implementing Effective Navigation. In this course, you'll learn how to build an Android application that uses a number of different navigation methods. If you're familiar with Android, you already know there's many different ways to handle navigation. You can use activities, fragments, dialogs, and various types of views. Then to improve the user experience, Android offers a number of features to enhance navigation. There's tabs, navigation views otherwise known as navigation bars, navigation drawers, floating action buttons, menus, and all the adapter classes that come with them. I don't think I stand alone when I say this can be very confusing, especially if you're new to Android. In this course, we're going to build what I like to call a skeleton of an actual app, so you can see some real examples of when to use activities, when to use fragments, and to enhance the navigation features, like using tabs, navigation views, and navigation drawers. What do I mean by a skeleton? I mean basically the app will have everything a real app will have except real data. To mimic the feel of having real data, we're going to add some dummy data and save it in resource classes and use SharedPreferences. Other than that, the app will essentially be fully functional in that all the navigation and navigation features will be implemented. By the end of the course, my goal is you'll be able to easily implement and determine when to use activities, when to use fragments, when to use alert dialogs, when to use navigation views, when to use tabs, and when to use navigation drawers, and of course how to communicate between all these components because communication is a key part of navigation.

Prerequisites
This course is meant for complete beginners when it comes to effective navigation. However, I want students to get the most value possible, so I've included a lot of, for a lack of a better word, extras that even more advanced users will find useful. That being said, I do expect you to have some knowledge of Android Studio and how to test apps and use the Android Emulator or a real device. Additionally, even if you're a beginner now, you might significantly increase your skill in the near future. I want you to be able to come back to this course or take a second look at the source code files and still pick up new things that maybe you didn't see before. So as kind of a warning to those of you who are fairly new, there's going to be some things that I glaze over in this course that you're likely not going to understand 100% yet. Just to be clear, everything to do with navigation is going to be very clearly explained, but some of the other concepts like recycler views, recycler view adaptors, building layouts, material design, won't really be looked at in detail. I have to keep in mind that this course is on effective navigation, not on those other topics I just mentioned. But because I want to provide the closest possible example to a real functional app, I need to include those things, so you can see the big picture and how everything comes together. So if you find yourself confused, and want more information on things like RecyclerViews, material design, and building layouts, I suggest checking out the Pluralsight course library for those topics. There's a ton of great resources there. Okay, now let's talk about the dependencies we'll be using in the course. Keep in mind that these libraries will already be included in the source code files, so there's no need for you to add them yourself. We'll be using the RecyclerView support library for implementing recycler views, the Design support library for using CoordinatorLayouts layouts and consequently toolbars and other widgets it supports, the support CardView library, an open-source library for displaying circular ImageView widgets, an open-source library that allows easyvintegration of a heart-shaped Like button just like Twitter uses, the Glide library for setting image resources to widgets, and an open-source library for a NavigationView. If you want a closer look at those libraries, just open the app level Build. Gradle file and take a look. Just copy the dependency and paste in a Google search. It'll direct you to GitHub where you can get more more information on that library. I'll be using Android Studio version 3. 0. 1 and compiling and targeting an SDK version of 27. As I mentioned, I won't be covering how to set up the Android Emulator or how to enable developer mode and run apps on a real device. I'm assuming you've learned that on your own. So if you're completely new and never used Android Studio before, you'll need to do some minor research and get apps running on a virtual device or on a real device that you have.

The Story Behind the App
For the duration of the project, we'll be approaching app development from a perspective of an imaginary company, Tabian Dating. Imagine you're an employee of Tabian Dating, and you've been given the task of building a skeleton prototype of a new Android application they're developing. Your primary objective is to get an overall feel for what the user experience will be when navigating the application. You need to figure out when to use activities, fragments, or any of the advanced navigation features like tabs, navigation views, and navigation drawers. You want to make it as real as possible, so adding dummy data and allowing for some minor customization is key. It's just a project skeleton, so you don't want to integrate an authentication system, a database, or a file storage system, but you do want the ability to save some preferences. Making use of Android SharedPreferences functionality should be enough.

App Demo
Let's take a look at the app we'll be building in the course. Here is a Login screen. As I said earlier, the app won't have an authentication system, so there's just a simple button labeled Login and the Tabian Dating logo. The Login screen is an activity. When the user clicks the Login button, an intent is created, and the app navigates to another activity called MainActivity. When the app opens, the user will be greeted with an alert dialog. The dialog greets them with a message, recognizing that it's their first time logging in. When the user presses OK, a variable will be saved in SharedPreferences, and it will not open again. MainActivity is the core of the app. What do I mean by the core? I mean it's a central location when it comes to navigating the app. There's a navigation bar anchored to the bottom of the screen, and each navigation item inflates a different fragment. Before we explore the different fragments anchored to the navigation bar, let's take a look at the navigation drawer. To access the navigation drawer, the user must swipe from the left side of the screen to the right side. Now they see three options, Home, which navigates the user back to the core location we just talked about, Settings, which takes the user to a personalized settings screen, and Agreement, which just displays a user agreement page with some randomly generated text. Each of these options inflates a different fragment. Let's take a look at Settings. Here is where the user can make some minor customizations to their profile. They have the ability to change their profile picture, and as you can see because of that, the app is asking for permission to access the phone's memory and also access the camera. I'll press Allow and Allow. Change their name, select a gender, select the gender their interested in, and set their relationship status. All these properties will be saved in SharedPreferences and used to determine what's displayed on the main feed. For example, if a user selects a preference of females, then navigates back to the main screen and refreshes the feed by dragging downwards, you can see the list changes. Now there's only females being displayed. This is one of the things that we'll be doing to give an illusion of a real app. But of course, all this data is stored locally in the source code files and does not use a database. Let's head back to the Settings screen and choose a new profile picture. To choose a new profile picture, click on the circular ImageView widget, and the user is navigated to a new activity. Now you're probably wondering why I chose to use an activity here and not a fragment. That will become very clear in the module when we integrate tabs. And if you didn't notice, yes, there's tabs down here at the bottom. One tab is for selecting an image from the phones memory and another is for taking a new photo using the phone's camera. Another question you likely have at this point is why did I add a button to open the camera and not just open directly to a camera preview on the tab? I understand your concern completely. All apps do this. Pretty much no application would have a button to open a camera like this. If we take Instagram, for example, and navigate to the middle item on the bottom navigation, we see them doing exactly that. They have a tab for selecting an image and a tab for taking a new photo or video. The reason I didn't implement a system like this is it's extremely complicated. There's already a number of advanced topics that I'm glazing over, and I didn't want to add another level of depth. Building a custom camera screen could've probably doubled the length of this course and is a very advanced concept. Doing it this way is simple and gets the job done. Remember, the course topic is on effective navigation, so my goal is to effectively show you how to use tabs, not effectively use a camera. Let's head back to our demo app. So moving onto the next part, let's navigate back to the main feed by pressing Home on the navigation drawer. Now that we have some preference selected, click on the list item in the RecyclerView and take a look at this new screen. Here's another new fragment that displays the profile of other users, and it gives some basic information about them, and the user has the ability to like them by clicking this heart. This heart animation is the same one used by Twitter and is easily integrated with the library that I've included in the Build. Gradle app file. If like the user, they get added to a personalized list of saved connections. The list of saved connections can be accessed from the main feed and clicking on the middle of the bottom navigation bar. If I refresh this screen, I see that user I just liked. Once again, if I click on them, it brings me back to their profile. Now I'll press the back button, and let's view the final item on the bottom navigation. This fragment is for displaying messages from other users. I've added some simple logic so that when I like a user, a default message will be generated and posted to the message's fragment list. Let me explain a little better. You probably noticed that the user we just liked is appearing in the messages list. If I go back to the main feed, choose another user, like them, then navigate back to the message's fragment and refresh, you can see another message has been added. This is just another feature I added so the application appears more real, and therefore the navigation feels more real. You can filter the users by clicking on this magnifying glass up here and typing some characters. You can see it's filtering the username dependent on what I type. Let's click this user. This is another fragment for displaying a chat feed. You can see the default message here, and I have the ability to add another message by typing some text in the edit text widget down here. If I click Send, the message is added to the recycler view. The messages aren't saved, so if I navigate away from the chat and then back, you can see that the message is gone. Because we're not using a database, it's pointless to save messages. We only want to get a feel for the app. Also notice if I click on the user's image in the toolbar, I'm sent to their profile. That's the entire application. So as you can see, we'll be making use of activities, fragments, the navigation drawer, the navigation bar, tabs, and an alert dialog when the user first opens the app. In the next module, we'll get started building the Tabian Dating application.

Navigating with Activities
Introduction
In this module, we'll be focusing on implementing navigation with activities and using alert dialogs. For the duration of the module, we'll be working with the source code files in the directory Module_2/start/TabianDating. You can download the source code files by navigating to the course on Pluralsight and clicking on the tab labeled Exercise Files. This module is going to serve as more of an introduction than anything else. Because I want to build the application just as I would if I was building a real app, we're going to start with implementing some minor navigation with activities and then move onto fragments, which occupies a much larger portion of the course. This isn't because activities aren't important. It's just because at this stage in development, there isn't much activity navigation to be done. So in the sections to come, we'll talk more about implement an alert dialog, using an intent to navigate from the login screen to MainActivity, and using some activity animations to make the transition appear smoother.

Dependencies
Let's review the external dependencies used in the course and get a general process of how to import dependencies into Android Studio. Open the source code files I provided and navigate to the build. gradle app file. You can find the build. gradle app file by searching in the Android directory, then expanding Gradle Scripts, and opening the build. gradle file labeled app right here. Because this is a beginner course, before we start writing code, I want to quickly review the dependencies I've included in the build. gradle app file because some people might not be familiar with this process and how to import them. Down here in the dependencies section is all the external libraries I've included. We have one for using recycler views, one for using the design support library, which includes widgets like tabs, navigation bars, floating action buttons, and so, the Android support cardview library, this is required for using cardviews, an open-source external library for using circle image view widgets, a LikeButton library for using really great like buttons, the glide library for setting images to widgets, and an open-source library for a highly customizable bottom navigation view. I find this library is superior in pretty much every way compared to the bottom navigation view from the Android support library. By including all these references, we gain access to classes that wouldn't have otherwise been available with the standard Android SDK. If you want more information on these libraries and what they're capable of, I encourage you to Google them and read their documentation. One last thing I want to mention is a reference to the jitpack. io repository in the build. gradle project file. So if you open your build. gradle project file, this reference is needed for the LikeButton library and the BottomNavigationViewEx library that I just talked about in the build. gradle app file. These repositories are hosted on jitpack. io, so we need to reference it so Android Studio knows where to look. You can see that if I comment this out and press Sync, Android Studio gives me an error saying it doesn't know what these two libraries are. I'll uncomment it, press Sync again, and there we go, the error goes away. Now that we have everything we need and you have an understanding of where things are coming from, we can start writing some code.

Navigating to a New Activity
We're going to implement the first navigation method by sending the user to MainActivity from LoginActivity when they click on the Login button. Open up LoginActivity, and we'll start writing some code. The first object I want to create is an activity tag. To instantiate the activity tag, just start typing logt, and you'll see an autosuggestion pop up. Tags are used for debugging. It'll help identify where errors are occurring if we run into problems in the future. I'll show you what I mean. After the setContentView method, start typing Log. d, and select what Android Studio is suggesting. Any Log. d method calls designate a point in your code where a message will be printed to the Logcat. You can write a custom message in here. I'll just write started, so we'll get a log output where the onCreate method is called. I'll demonstrate. Run the app and open the Logcat down here. To filter some of the noise, copy the package name from the top of the file. Now click here and select Edit Filter Configuration. Type in anything for the filter name. All this is is a label. It doesn't matter. Now paste in the package in the Package Name field. Notice the Logcat has cleared. Now it's only showing log output from the TabianDating package, or in other words, it's only showing log output for the Tabian Dating app. Everything else is filtered out. Now let's examine the log. Here is the log output from onCreate. These kinds of logs can help you identify where issues are coming from if your app is crashing. Debugging is a huge part of programming, so I wanted to make sure you knew how to do this. I'll also be inserting logs in the source code and wanted you to understand why. Let's take a look at the activity_login layout file and check out what widgets are in there. This is pretty basic. There is just a widget for setting the background image, the Tabian Dating header, and the Tabian Dating logo, and a button. Pretty simple stuff. The only thing to note here is the ID of the background ImageView widget and the ID of the Button widget because we'll be referencing them in LoginActivity. Go back to LoginActivity and declare a new Button widget named mLogin. Now in onCreate, attach the button to its ID, so mLogin = findViewById R. id. btn_login. Remember, this is the ID from the Button widget in activity_login. So if we go back to activity_login, it's this ID right here. Now back to LoginActivity. Now we need to attach an onClickListener to the Login button so we can take an action when the user clicks it. There's a number of ways to do this, and there's no right or wrong way. But I prefer to do it this way. Write mLogin. setOnClickListener, then pass this. Notice this is highlighted in red. That's because we're referencing an interface that's not currently being implemented. To implement the OnClickListener interface, go up here and write implements View. OnClickListener. Now the red disappears, and Android Studio knows what interface you're referencing. But we have some new red here. The OnClickListener interface is telling us we need to implement the interface methods or else. Or else what? Or else it will continue to be angry, I guess. The easiest way to implement the required methods is to click on this little red light bulb right here. Select implement methods and choose the onClick method. Now the red goes away because we've implemented the required methods for this interface. In the onClick override method, we can write logic to handle what happens when the user clicks the button. This activity only has a single OnClickListener, but we should still write logic to identify which OnClickListener we're talking about. That probably sounded confusing, so let me show you what I mean. Write if(view. getId()) == R. id. btn_Login. If this is true, then we know the OnClickListener we're referencing is the one of our Login button. Like I said, there's only a single OnClickListener in this activity, but if you had a bunch, this is what you'd do to discriminate between which widgets were being clicked. Now inside this if statement, we can take an action and navigate to MainActivity. I'll start by writing a log output so we can identify in the log that this button was clicked. So we write Log. d, then just type logging in the user. To navigate to a new activity, we use something called an intent. To create a new Intent object, we just write Intent_intent = new Intent, then pass LoginActivity. this, which is the context of this activity and then comma MainActivity. class, which is the class that we want to navigate to. The first input parameter defines the context of where you're navigating from. And the second input parameter defines the context of where you're navigating to. I know that we want to go to MainActivity, but you'll notice it's telling me the MainActivity class does not exist, which is true, because we haven't created it, so let's make it. Right-click on the main package directory, select New, then go down to Activity, and select Empty Activity. Give it a name of MainActivity and click Finish. Android Studio will now generate a new activity file and also a layout file with the ContentView set to it. We could've done this manually by clicking the main package directory, clicking New and then Java Class, but it wouldn't have autogenerated the layout file and added it to the onCreate method. So it's faster to let Android Studio do some work for you. Android Studio also adds the new activity to the manifests, which it wouldn't have done if you just created a new Java class. Remember that every new activity needs to be added to the manifests like this. If it's not, the app will crash when you try to open that new activity. Navigate back to LoginActivity. Great. So now the warning's gone away. Now to finalize the navigation to the new activity, we just write startActivity and then pass the intent. That's it. That'll bring us to our new activity. Let's test it. Okay now click the Login button. Cool. It's navigating to the new activity. But there's a problem. Watch what happens when I click the back button. It takes us back to the Login screen. This is a problem. No application should allow users to navigate back to the Login screen once they've been authenticated. The only way users should be able to get back to the Login screen is if they sign out of the app. I realize our app is a skeleton, but it's still important to make sure the Login screen is not accessible after they've logged in. This is surprisingly easy, and it can be done with just a single line of code. Just go down below startActivity and write finish. That will remove the activity from the activity stack as soon as the new activity is started. Let's try it out. Okay now press Login and navigate to MainActivity. Now press the back button. Cool. The app closes. We're just going to do one last thing before moving on. For lack of a better word, activities make ugly animations when they're created, and there's a relatively simple way to make them look a lot better. Below the startActivity method call, write overridePendingTransition, then do android. R. anim. fade_in to reference the fade_in animation, then comma android. R. anim. fade_out. This will override the default activity animation for when the activity is brought onto the screen. There's all kinds of custom animations you can create for activities. These are just two default ones that come standard with the Android SDK, fade_in and fade_out. I encourage you to do some research on activity animations if you want to explore that further. Pluralsight has a great course called Android Animations with great ratings that I recommend checking out. Let's test our new animation. So I'll click the Login button, and there we go. You can see a much nicer transition to the new activity.

Implementing an Alert Dialog
Building an alert dialog is relatively straightforward, and it's an effective way to convey messages to users. Open up MainActivity, and let's build a method for displaying one. We'll name the method isFirstLogin and quickly write a log for debugging, checking if this is the first login. To determine if this is the first time the user's logging in, we'll save a parameter in SharedPreferences. There's going to be a handful of parameters we'll be saving in SharedPreferences, so I've included a class for managing them all. It's right here in the utility package. Open it up and take a look. Here's all the SharedPreferences keys we'll be using in the course. If you're unfamiliar with SharedPreferences, this will become clear in a few minutes. Go back to MainActivity. Start by creating a SharedPreferences object by writing final SharedPreferences preferences = PreferenceManager. getDefaultSharedPreferences, and then pass the context, which is just this. We need to make it final because it's going to be used in the interface method in a moment. Now get the Boolean associated with the first time login, so write boolean isFirstLogin, then = preferences. getBoolean, then reference the preference key by going PreferenceKeys. FIRST_TIME_LOGIN, and then pass a default value of true. SharedPreferences is just a bunch of key values pairs saved locally on the Android device. You can access the values by references the unique key. I've defined the keys we'll be using in the PreferenceKeys class, so they'll be easy to reference. So you can see here, I'm referencing the key FIRST_TIME_LOGIN. Now we check the Boolean to see if it's true or false by writing if(isFirstLogin) and write a quick log, launching alert dialog. If this Boolean is true, it means this is the first time the user is logging in, and we want to build a dialog. To build an alert dialog, we use an AlertDialog builder object, so write AlertDialog. Builder alertDialogBuilder = new AlertDialog. Builder and then pass this. And if you're not familiar with builder classes in Android, let me give you a brief description. Builder classes are identifiable with the. builderMethod call on an object like we see here. It gives you the ability to chain method calls on an object and set a bunch of properties to it. So, for example, I could write alertDialogBuilder. setMessage, then getString(R. string. first_time_user_message). And if I wanted, I could continue chaining more method calls to the end of that one. So I could write. setPositiveButton, but I'm going to put them on separate lines like this, so alertDialogBuilder. setPositiveButton, then pass OK. The setMessageButton obviously sets the message contained in the dialog, and the setPositiveButton method sets a positive or a successful result button. You can also set negative buttons, but we don't need one for what we're doing. We just want to display the dialog and get the user to press OK. Now we want to apply an OnClickListener to the positive button, so we write new DialogInterferface. OnClickListener and then implement the interface and write a quick log output inside that signifying the closing of the dialog since that's what we want to happen when they click OK. When the user clicks the OK button, we want to set the SharedPreferences Boolean to true, so the dialog won't pop up in the future. To do that, we can write SharedPreferences. Editor editor = preferences. edit, which will then get the SharedPreferences. Editor object. The Editor object is needed to set values to SharedPreferences. Then write editor. putBoolean(PreferencesKeys. FIRST_TIME_LOGIN), and then pass false, then editor. commit, and finally dismiss the dialog, so write dialogInterface. dismiss. Now outside of the OnClickListener interface, we can set a few more properties. Set the icon by writing alertDialogBuilder. setIcon, then R. drawable. tabian_dating. And we need to set a blank title or the icon won't show. This is something that's not obvious. This isn't even mentioned in the Android documentation. You need to write alertDialogBuilder. setTitle and then pass a blank space. If we didn't include that blank space for the title, the icon wouldn't show on the dialog. Now create an AlertDialog object, so write AlertDialog_alertDialog = alertDialogBuilder. create. And finally, show the dialog by writing alertDialog. show. Alright now call the method inside of onCreate, and let's test it. Navigate to MainActivity, and there's our dialog. Press OK. Now run the app again. And notice the dialog does not show up this time.

Module Review
Let's quickly review everything covered in the module. We began the module by reviewing the external dependencies required for using some of the special application functionalities. The dependencies were the RecyclerView support dependency, the Design support dependency, CardView support dependency, a circle ImageView library, a custom LikeButton library, the Glide library, and a highly customizable BottomNavigationView library. And remember, we needed to add a reference to the jitpack. io repository in the build. gradle project file, so Android Studio knows where to find the dependencies for the LikeButton and the BottomNavigationViewEx library. Next, we worked on navigating from LoginActivity to MainActivity. We used the OnClickListener interface to capture the event of a button click and then used an intent to navigate to MainActivity. We made sure to call finish after StartActivity so the user will not be able to navigate back to the Login screen after entering the application. The standard animation for opening a new activity isn't very esthetically pleasing, so we used an activity transition animation to fade in the new activity. Doing this is very simple and requires a single line of code that says overridePendingTransition, then reference the fade_in animation, and reference the fade_out animation. Remember there's a ton of activity animations, and I encourage you to explore them and improve the look of your activity transitions. Before we move onto the next modules, I want to take a second and mention that after we cover the module on fragments, I'm going to speed things up quite a bit. I took it nice and slow in this module, and I'll take it nice and slow in the fragments module, because I suspect some of you are completely beginners, and I want to make sure that you understand the core concepts. The core concepts include getting dependencies, creating activities, creating layouts, attaching widgets to IDs, using shared preferences, navigating using activities, navigating using fragments, building fragment classes, and fragment containers. I'll still explain things in the following modules, but I won't be explaining the same things over again, so just keep that in mind. In the next module, we'll start using fragments to navigate the app.

Navigating with Fragments
Introduction
In this module, we'll work on implementing navigation using fragments. For the duration of the module, we'll be working with the source code files in the directory Module_3/start/TabianDating. You can download the source code files by navigating to the course on Pluralsight and clicking on the tab labeled Exercise Files. Let's start with what's probably the most common question I get asked about fragments, and that's how is a fragment different from an activity? I'll try to explain using analogies and examples because if you just wanted a straight up definition, you could've easily typed that question into Google and got an answer. Here's the way I think of activities. They're like a main container, like an anchor for content, like a streamline for a specific action or process. They're essential to the app, and you can't do anything without at least one activity. Even if you wanted to build an app made up of 99. 9% of fragments, you'd still need at least a single activity to host them. A single activity can host many fragments. You can add them to the activity in many different ways. You can have a fragment to occupy the entire view of the activity, which is the most common, you can have fragments stack on top of one another like a stack of pancakes, or you can arrange a bunch of fragments in an activity view. Imagine a single service like a Rubik's cube. Each little color on the block can be a different fragment all arranged right next to one another on the activity view, pretty much anything you can think of. As another example, suppose you were building a stock analysis app and you wanted to have some numbers and calculations displayed on the bottom of the screen and a graph displayed on the top of the screen. You could add a fragment view on the top half and a fragment view on the bottom half, then write code in each independent fragment class, and get it to do what you want. If the fragments need to communicate with one another, they could do so through the activity. It would act as a sort of relay center for the messages. Communication is usually done through an interface, and we'll take a look at how this is done in detail later in the course. Let's compare some more properties. A fragment cannot host an activity. Fragments are just views. Fragments define containers that can facilitate actions. There cannot be more than one activity in view at a given time. Activities are, by definition, an activity. Their name defines what they are. And activities define actions. So that explanation probably either opened your eyes or made you incredibly confused. If you have even a little experience with fragments, I'm guessing it was very helpful. But if you're fairly new, you're likely very, very confused. So stick with the course, and I promise everything will become very clear by the end. The next most common question I get asked about fragments and activities is when should I use a fragment and when should I use an activity? The answer will probably surprise you. Basically, I suggest using either of them whenever you want. I really think it comes down to the design preference of the developer, and using whatever will yield the best user experience is what you should do. That's it. Of course there are some exceptions when you absolutely need to use fragments, like with tabs, but there are very exceptions like those. The main complaint I hear is that activities don't look as good when they're brought into view, and I would agree. That's true. By default they don't, but you can use activity animations to make them look exactly like fragments. If you have any more questions or comments on this topic, make sure to post them in the discussion section of the course. I'm pretty good at checking regularly, so me or someone else will probably give you a great answer. And without further ado, let's move onto the next clip and get started using fragments.

Building and Inflating Fragments
As I stated in previous clips, fragments are just views, and each fragment view requires a container. It's not enough that fragments have an activity to host them in and a layout to inflate. They also need a container to live in. So that's where we're going to start. Open up activity_main and first change this ConstraintLayout to a RelativeLayout. There's no particular reason for this. I just prefer RelativeLayouts because I find them easier to work with. We're going to create a new layout file that's going to seem counterproductive right now, but it'll make sense later when we implement the navigation view. Right-click on the layout folder, go to New, Layout resource file, and we're going to call this layout_main_content. And then, once again, change this to a RelativeLayout. Inside the layout, we're going to add a single FrameLayout. So open a tag, start typing Frame, and select the container. This is one type of fragment container. There are a few different types of fragment containers, and we'll take a look at more later in the course. Basically, this is just a place for a fragment to live. You can add this to your layouts, and you can inflate fragments inside them. We'll give this one an ID of main_content_frame. Now go back to activity_main. Inside the RelativeLayout, write include layout=@layout then layout_main_content. And now that layout we just made will be included in here in activity_main. As I said, this seems counterproductive right now, but it'll make sense later. Now that we have a place for our fragment to live, let's build our fragment class. The first fragment we'll build is called HomeFragment. Right-click on the main package directory, select Fragment, select Blank, type the name HomeFragment, and click Finish. There's a lot of stuff we don't want here. I only use the builder in Android Studio because it conveniently creates the layout for you. But pretty much everything inside this class we don't need. We're going to be implementing everything we need manually. So delete everything except the onCreateView method. And even inside onCreateView, we're going to change the view return statement. We'll write View view = inflater. inflate(R. layout. fragment_home then container and false), and then return the view. This will make it easier to attach widgets to their IDs. The first thing I want you to notice here is the reference to the v4 support library. This isn't the only option when it comes to fragments. Watch what happens when I delete it. Now there's two options for the import. There's a standard fragment library and a v4 support version library. The standard fragment library is the native one introduced in API 11. The support libraries were introduced to make newer features backwards compatible to earlier versions of Android. So in general, it's likely better to use the support version since it will work with more Android versions. There's no advantage of using the standard fragment library that I know of, so in general I'd say just use the v4 support version. All I want to do is put a tag in our new fragment class, so type logt, and then write a log output saying started in onCreateView. Now go back to MainActivity, and let's inflate the fragment. Start by creating an init method, private void init. Now create the homeFragment object by writing HomeFragment homefragment = new HomeFragment. To inflate the fragment, we're going to do what's called a fragment transaction. Create a FragmentTransaction object by writing FragmentTransaction transaction = getSupportFragmentManager. beginTransaction. And we use the FragmentTransaction object to add the fragment to the container. Write transaction. replace R. id. main_content_frame, homeFragment, and then reference the tag, so getString(r. string. tag_fragment_home). Notice I'm referring to the ID of the fragment container we defined in layout_main_content. Take a look. Open layout_main_content. The ID is main_content_frame right here. Now go back to MainActivity, and the ID is the same as main_content_frame right here. Then you pass the fragment, and then you pass the tag as I just mentioned. I built this application ahead of time, so obviously I already know what all the fragment tags are going to be. They've already been included in the strings. xml file. See here are all the fragment tags we'll be using in the course. They're just names given to each fragment so we can differentiate between them easily. Back to MainActivity. By setting the tag here, the fragment transaction is labeled, so then we can easily identify the fragment. Replace will replace the new fragment with whatever was in the container previously. Next we need to add this fragment transaction to the backstack. Write transaction. addToBackStack, and then reference the tag, so getString(R. string. tag_fragment_home). So what is a backstack you might ask? It refers to the implementation of back navigation, so like when a user clicks on the back button. Let's take a look at some slides to better illustrate this. With fragments, you have to manage the backstack manually because you can theoretically have over 100 fragments in a single activity. There's no easy way to determine when to navigate back and when to not. Activities are easy. There's only one allowed to be in view at a given time, so pressing the back button means navigating back. It's simple. In our situation right now, there's only a single fragment consuming the entire view, so pressing the back button would work if it was managed like an activity. But what if there was 10 fragments added to this view? Then it becomes a lot trickier for the app to determine when to go back and when to not. So one way to semi-manually manage the backstack is to use this addToBackStack method call on the fragment transaction. I say semi-manually because it's less than ideal in most situations. We'll talk more about that later. But basically what it does is it adds to a stack that intercepts the back button when it's pressed. I don't even have to enter a fragment tag here. I could just enter null, and it would do the same thing. Think of it as a stack of Lego blocks. Every time I write addToBackStack, it adds another block. Also, every time I open a new activity, it adds another block. Then every time I click the back button, a block is removed. When all the blocks are gone, the app will close. Here's a demonstration of what we want to do with our backstack. Suppose you navigate from fragment A to fragment B to fragment C and then back to fragment A again. Because we've already visited fragment A, we want to remove it from the backstack. There's no need to visit it twice when navigating back. Suppose you navigated from A to B to C and then to B again for the second time. We want to remove that earlier visit to B from the backstack. Then we want to compress the stack to this new orientation. This is going to be our goal when constructing a backstack and custom back navigation system. Okay, let's go back to Android Studio. Lastly, we need to commit the transaction. Just write transaction. commit. That's all we need to do to inflate a new fragment. Make sure to call init inside onCreateView, and let's run the app. Press Login. Cool. There's our new fragment being inflated inside the container in MainActivity. Go back to Android Studio, and I just want to do one small thing before we move on. Let's remove that action bar. We don't need it for this app. Go to values, open styles, and change this to NoActionBar. Also while we're here, change the primary color to blue4 and the primary dark color to blue5. Now run the app again. Click Login, and there we go. No more action bar at the top.

Adding a RecyclerView to a Fragment
Before we start this clip, let's preview the changes we'll be making. Click Login. As you can see now, HomeFragment is displaying a staggered recycler view containing all the users of the app. Here we're making use of the RecyclerView support library to build the recycler view list and the CardView support library to build these cards. Of course, this is just some dummy data that I've added, but it still gives you a better feel for what the app is going to look like. Okay open Android Studio, and let's look at the code changes. The first thing I want you to notice is the models package I've added. I like to create a separate package for any special data model classes that I create. Since this app will contain users, I've created a separate user class. Let's take a look at it. This is just a simple class containing five parameters that define what it means to be a user. Each user will have a profile image, a name, a gender, a gender preference, and a relationship status. Below is the default constructor, parcelable implementation, and getter and setter methods. The reason we need to implement parcelable is because these User objects are going to be sent through bundles later in the course. If you don't know what a bundle is, it's a way to send data from an activity or fragment to another activity or fragment. So in other words, we need to implement parcelable so these User objects can be sent to other activities or fragments via a bundle. I suspect some of you have not done a parcelable implementation before, so let me demonstrate. It's very simple. I'll delete the implementation up here and now delete all the methods related to the implementation. Now all that remains is the constructor and the getter and setter methods. Now write implements_Parcelable. Click on the red light bulb and select Implement methods. Now click on the user highlighted in red. Click the red light bulb once more and select Add parcelable implementation. So what exactly is a parcelable implementation? It specifies a way of packaging objects so that when they're added to a bundle, they can be processed efficiently. For primitive data types, you don't need to implement parcelable, things like strings, Booleans, integers, etc. But for a custom data class like this, you need to. Let's take a look at the next class I've added. It's in the util package right here. It's called Users. This class is a resource class that contains all the dummy data users that we'll be using in the app. Each user contains all the parameters we outlined in the user class. They have a profile image, a name, a gender, a gender preference, and a relationship status. The profile images point to drawable resources that I've added. Then at the top, there's an array of User objects. This will make it easier to retrieve all the users when we want to display them in a list. Okay, let's check out the next class I've added, MainRecyclerViewAdapter. This is a recycler view adapter class. If you're familiar with RecyclerViews, they work very similar to the way a list view works in a list adapter class. They save the ListItem widgets in memory using a ViewHolder and then add the views one by one as the user scrolls the list. As I said before, I won't be getting into detail, but this is just to give you a kind of overview of how they work. Here's the ViewHolder class that saves the individual ListItem widgets in memory. The layout here refers to the individual layout of each of those little cards. Its name is layout_main_feed, and I've also added that to the source code as you can see here in the layout files. Here's the onBindViewHolder method that adds the data to the ListItem widgets. So if we open the log, when I run the app, we're going to see onBindViewHolder called. That log output printed to the Logcat is going to show each time a new item is added to the RecyclerView. We use the Glide library to set the image to the ImageView widget, and I've added an OnClickListener to the CardView widget because later in the course, we'll add the ability to navigate to a user's profile by clicking on the list items. If you want a more detailed description of recycler views and their adapters, check out the Enhancing the Android Experience course on Pluralsight. Now let's take a look at the changes I made in HomeFragment. The first object is a constant that will define the number of columns in our RecyclerView. Then we have our RecyclerView widget. Then we have the variable section with an array list of users that I've called mMatches. A staggered recycler view layoutManager object, which we need to build a staggered recycler view, and of course, our MainRecyclerViewAdapter that we just looked at. The first thing we need to do is attach the recyclerView object to the ID of its widget. Can you see anything different about this as compared to when you're in an activity? Notice that I'm writing view. findViewById(R. id. recycler_view). Remember that fragments don't have their own context. They inherit the context from the activity their hosted in. So to instantiate widgets, we need to reference the view that the widget is located in. Views contain context, so that's solves the context problem. I didn't point it out earlier, so quickly open fragment_home. xml. Notice that I've added a RecyclerView widget to the layout, and the ID matches the one that we just referenced in HomeFragment. Back to HomeFragment, The next action we take is calling the method findMatches. All this method does right now is retrieve a list of users by referencing the users class we went through earlier. There's a loop that iterates through the users array and then adds them to the array list, mMatches. It then proceeds to initialize the RecyclerView. Let's run it and take a look. Click Login. Cool. Our User objects are coming through and being added to our RecyclerView.

Sending Parcelables Through a Bundle
Now that we have some dummy data users populating our RecyclerView, we need to add functionality for navigating to a user's individual profile. I've added two new files for this section, ViewProfileFragment. java and its corresponding layout file, fragment_view_profile. xml. Let's take a quick look at the layout. It contains a circle ImageView widget for user's profile image and then a bunch of TextViews for their name, the gender, the gender interest, and a relationship status, a very basic layout to display some very basic user information. Now take a look at ViewProfileFragment. There is basically nothing here, just the onCreateView method and the view declaration. Nothing we haven't seen before. Before we start, let's define what we want to accomplish. We need a way to open this new fragment after clicking on an item in the RecyclerView, and we need the new fragment to display what user we clicked on. For some of you, this might seem relatively straightforward. Do a fragment transaction and attach the User object to a bundle. Then attach the bundle as an argument to the fragment, and that would definitely work. But if that was your approach, you'd be directly communicating between two fragments, HomeFragment and ViewProfileFragment, which is generally a no-no when it comes to best practices. You can actually read that directly from the Android Developer documentation. Take a look. It says, Often you will want one Fragment to communicate with another, for example to change the content based on a user event. All Fragment-to-Fragment communication is done through the associated Activity. Two Fragments should never communicate directly. And in general, I agree with that. Probably 95% of the time, a fragment is better off communicating with its host activity, which can then relay the messages to the other fragments. The activity acts as a sort of communication hub. The main reason for this is fragments are not static. As we've talked about before, they don't even have their own context. They come into view and go out of view at various times, so issues can definitely arise if one fragment tries to communicate with another and it's left to view. However, I don't think this rule should be strictly followed. I'd call it more of a guideline. If you manage your fragments well, you shouldn't run into problems when communicating directly. That being said, in this course, I'll only be showing you the best practice way. So it's up to you if you want to figure out how to communicate directly between fragments. Okay, let's head back to Android Studio. So our first step is communicating from HomeFragment to MainActivity so that MainActivity can relay the message. For that, we're going to use what's called an interface. So right-click on the main package directory, go to New, Java Class, and make sure to change this to an interface. We'll call it IMainActivity for interface main activity. And since we're inflating the ViewProfileFragment, we'll write void inflateViewProfileFragment and then pass a User object. Now open MainRecyclerViewAdapter since that's what we're going to be detecting the click. First we need to declare the interface as a global variable, so write private IMainActivity mInterface. Now we need to instantiate the interface. You always want to instantiate the interface in the onAttachOverride method. Scroll down and we'll insert it. You can insert the onAttachOverride method by pressing Ctrl+O on Windows or Cmd+O on Mac. Start typing onAttach, and because we're inside of a RecyclerViewAdapter class, it's called onAttachedToRecyclerView. Now write mInterface = (IMainActivity) and then the context. Now we just need to call the method we define in the interface when the user clicks on the item. So inside the OnClickListener on the CardView, write mInterface. inflateViewProfileFragment, and then pass in the User object by writing mUsers. get(position). Now the interface will be triggered when a click is detected, but we're not done yet. We need to capture the interface method call in MainActivity, so open MainActivity. To capture the interface methods, we need to implement the interface, so write implements IMainActivity. Now click the red light bulb and implement the methods. There's our inflateViewProfile method that we just defined in our interface. Now inside here, we can get the User object that was selected, and then we can do the fragment transaction. So at this point, we've effectively added functionality to communicate from HomeFragment to MainActivity, and now the next part is communicating from MainActivity to viewProfileFragment. Scroll up to the init method and copy the FragmentTransaction code. Paste it in inflateViewProfile and make the necessary changes. HomeFragment changes to viewProfileFragment. Then we can just change the name to fragment. The container's the same and change the tag to view profile fragment's tag. That will inflate the new fragment, but we still need to attach the User object as a fragment argument, so the new fragment is able to retrieve it. To do that, we need to create a Bundle object by writing Bundle args = new Bundle. Then add the User object to the bundle by writing args. putParcelable, then getString(R. string. intent_user), and then pass the User object. Then set the arguments to the fragment, so fragment. setArguments, pass the arguments. Note that if we didn't implement parcelable in the user class, we'd be getting an error here and would not be able to attach the User object. That's it, we're done. Open up viewProfileFragment, and let's retrieve that User object from the bundle. Start by creating a global User object, so private User mUser. Now we're going to insert the onCreateOverride method. I'll explain why in a moment. Press Ctrl+O Windows or Cmd+O on Mac. Start typing onCreate and select the method. I'm guessing there's a lot of you who are very confused by this. Why would we insert onCreate when we already have onCreateView inflating the view? Let's take a look at the fragment lifecycle. As you can see here, onCreate is actually called before onCreateView in the fragment lifecycle. So onCreate is actually a better place to retrieve our arguments since it definitely will be called before we set any widgets to the view, so that's what we'll do. Start by creating a bundle object and call this. getArguments. Now make sure the bundle is null, so if(bundle! = null). And finally, retrieve our User object, so write mUser = bundle. getparcelable(getString(R. string. intent_user). Then write a log so we know it was successful, got incoming bundle, and then we'll just print the user's name. Let's run it and watch the Logcat to see if the User object was retrieved in the new fragment. Remember to filter on the application package by selecting it up here. Click Login. I'll just select this list item with the name Carol. Cool. We can see the log output prints with the name Carol to the log. So everything is working as we expect. I want to take a moment and talk about what happens when we press the back button at this point. Notice the RecyclerView doesn't load the list items. This is a prime example of one of the flaws of back navigation when using the replace method on a FragmentTransaction. When you use replace, it destroys the fragment that was previously in the container. So when you do the reverse action, in other words pressing the back button, the previous fragment is not inflated properly. In the log, you can see the onCreateView method called, but nothing happens. When we build our custom back-stack management system, this problem will be resolved.

Module Review
Let's review everything we covered in the module. We started by inflating our first fragment using a FragmentTransaction. We used the replace method to replace the fragment that was currently in the container. Of course there wasn't one yet, but it works just the same. When using fragments, we have to manage the backstack manually. We used the addToBackStack method on the fragment transaction to take care of that. As we saw, there are some shortcomings with that method. We'll be resolving all the issues later in the course by building a custom backstack. Next we worked on a way to inflate in ViewProfileFragment when a user selects an item from the RecyclerView in HomeFragment. Remember, two fragments should never communicate directly. All communication needs to be done through the host activity. We built an interface class to facilitate fragment communication. The interface is called IMainActivity and has a single method named inflateViewProfile that takes a User object as input. We implemented the interface in MainActivity and inflated ViewProfileFragment using a fragment transaction. The User object was added to a bundle, and the bundle arguments were set to the new fragment. Other than that, the fragment transaction was the same. We just had to attach the new arguments. The bundle retrieved in ViewProfileFragment's onCreate method. We retrieved the User object in the onCreate method because it comes before onCreateView in the fragment lifecycle. In the next module, we'll implement a bottom navigation view and enhance the navigation experience.

Implementing a Bottom Navigation View
Introduction
In this module, we'll be focusing on implementing effective navigation using a NavigationView widget, otherwise known as a navigation bar. For the duration of the module, we'll be working with the source code files in the directory Module_4/start/TabianDating. You can download the source code files by navigating to the course on Pluralsight and clicking on the tab labeled Exercise Files. Much like fragments, I think implementing navigation properly using a navigation bar isn't that intuitive. If a developer doesn't have much Android experience, there's a lot of questions that arise. Should you use a navigation bar on the bottom? Should you use it on the top? Should the navigation items open to activities or fragments? Should you be able to swipe through the navigation items? How do you customize a navigation bar, things like setting images and text? Should you save the state of activities or fragments on the navigation bar? The list goes on and on. My aim is to clear up all these questions and hopefully more and give you a general template on how to set up an effective navigation bar.

Setting up a Bottom Navigation View
The BottomNavigationView widget that comes standard with the Android Support Design library is more difficult to customize than I'd like. Because of this, we're going to be using an open-source library for the BottomNavigationView widget. Open up your build. gradle app file, and I'll remind you which dependency it is. It's this one right here that says BottomNavigationViewEx. The GitHub page for this library is very helpful, so I encourage you to check it out if what I show you in the course doesn't fit the needs of your projects in the future. There's a ton of customizability with this library, and it's really, really great. We'll start by adding the BottomNavigationView widget into our layout. Open layout_main_content. We're going to put it below the FrameLayout. Open a tag and start typing BottomNavigation. There's the one we want. Give it a width of match_parent, so it occupies the entire width. And for the height, type? attr, then /actionBarSize. This references the standard action bar height for Android. Now give it an ID of bottom_nav_view. Align it to the bottom by writing layout ParentBottom = true, and now we need to add a menu to it. To do that, we need to create a menu folder. Right-click on the res folder, select Directory, and we're going to give it a name of menu. Now inside the menu folder, we'll right-click again, go to New, Menu resource file, and name it bottom_navigation_menu. Inside the file, we need to create menu items. Open up a tag and type item and close the tag. Now inside, we'll write some properties for the item. Give it an ID of bottom_nav_home. Give it an icon of ic_home_gray. I've included all the icons already in the droplist folder, but let me show you how to make them quickly, so you know for your future projects. Right-click on drawable, select Image Asset, select Action Bar and Tab Icons. Give it a name. I'll just call it ic_phone. Clip Art is what we want. That lets you select from the library of icons in the Android SDK. You can search through the categories or start typing what you're looking for to see if they have something. I want a phone icon, so in this case I'll just type phone, and I'll choose this one. Now you can choose the padding for the icon and the color. To choose a custom color, click on this pulldown, select CUSTOM, and then click here. Now you can choose a custom hex color. You can type that hex code if you know it or just move the pointer around. I'm just going to make this one black. Now click Next and Finish. Now we could assign our new icon like this, and it would show on the menu. But we don't want a phone, so I'm just going to change it back. We need to make sure the icons are centered vertically in the nav bar, so write centerVertical and set it equal to true. The autocompletion sometimes doesn't work on menus, so you might need to type this whole thing. Now just set the title to blank, and this item is done. Okay, now let's copy the item and paste it two more times since we're going to have a total of three items in our bottom navigation. Change the ID to bottom_nav_connections. Change the icon to vector_heart_gray. Now move to the next one. Change the ID to bottom_nav_messages, the icon to ic_messages, and that's all for our menu. Now go back to the layout_main_content. And inside the properties for the BottomNavigationView, start typing menu and reference the new menu that we just created. Now inside the FrameLayout widget, write layout_above bottom_nav_view, and that's going to ensure that our BottomNavigationView is always going to be displayed on the screen, and everything inside of our FrameLayout container will be above that. If the preview doesn't come out quite right, don't worry. These previews often don't work properly when displaying menus. Next open up MainActivity, and let's add the bottom navigation. First we need to declare the object as a global variable. Write private BottomNavigationViewEx, and we'll call it mBottomNavigationViewEx. Now attach the object to its widget ID, BottomNavigationViewEx = findViewById(R. id. bottom_nav_view). Next is a design preference of mine. I like to create a separate method just for initializing the BottomNavigationView. Private void initBottomNavigationView. Write a log for debugging, initializing the bottom navigation view. Now let's set some properties for the bottom navigation. Once again, I want to mention that the documentation for this library is really great. So if you want to explore other options, I encourage you to check out the GitHub page. Call the init method in onCreate, and let's actually run it at this point so I can show you want I want to disable. Click Login. Notice if I click on the icons, there's this kind of shifting animation happening. I don't like that, and I want to disable it. Disabling it is easy. All we need to do is write BottomNavigationViewEx. enableAnimation(false). Now run it again, and there we go. No more animation when we click on the bar. That's actually the only property I want to set. The only other thing I want to do is attach an onNavigationItemSelectedListener. So write mBottomNavigationViewEx. setOnNavigationItemSelectedListener, and then pass this. And this is giving us an error because we haven't implemented the interface. Just write BottomNavigationViewEx. OnNavigationItemSelectedListener. And now if you scroll down, you'll notice this is no longer giving a warning. But now we have a warning at the top because we need to implement the interface methods. So click on the red light bulb, select Implement methods, and choose onNavigationItemSelected. This is just a preference of mine, but I like to move navigation-related interfaces to the top of the class. So I'm going to highlight this, cut it, scroll to the top, and then paste it just below the tag. There's no reason for this. it's just a preference of mine. So now every time the user clicks on an icon on the bottom navigation, this method will be triggered. But we still need to write some logic to determine which icon was clicked. We're going to use a switch statement for this. So write switch(item. getItemId) and then the first case, which is R. id. bottom_nav_home. The second case is R. id. bottom_nav_connections. And the third case is R. id. bottom_nav_messages. Then to highlight the correct icon after they're clicked, just write item. setChecked(true). So copy that, paste it into the second one and the third one. We don't have any other fragments except HomeFragment yet, so let's write some log outputs to test it and make sure it's working. Write HomeFragment here, and I'm going to copy that and paste it, change it ConnectionsFragment. Once again paste, and then change it to MessagesFragment. Okay, let's test. Open the Logcat, click Login, press the Home icon first. Cool. There's the log output for the Home icon. Now press Connections. That's good too. Messages, and that's good. So everything is working as we expect at this point.

Fragments and Bottom Navigation Views
As I stated in previous modules, there's no definitive best way to use navigation views. But definitely in this situation, it's going to be more optimal to use fragments rather than activities. The reason might not be clear right now, but it'll become clear later as we approach a more complete version of our app. But to give you a kind of general answer right now so you know what to think about, using fragments is going to be better because we want to save the state of each item on the BottomNavigationView. That is, when navigating around the bar, we don't want to lose the position of the RecyclerView or have anything change unless the user refreshes the view and wants to update it. There's also going to be some communication between each fragment on the bottom navigation, which is much easier to manage using an interface routed through a single activity. I've added a lot of new files for this clip to save time. It's just repetitions of what we've already done. To update your files, go to the directory Module4/n/TabianDating. The files I've added to this clip are SavedConnectionsFragment, MessagesFragment, MessagesRecyclerViewAdapter, Messages, layout_messages_listitem, fragment_messages, and fragment_saved_connections. Let's quickly run through those new files before we start anything new. First open up SavedConnectionsFragment. A lot of what you see in this class is basically the same as HomeFragment. The only real difference is the data that's going to be displayed. If we scroll down, there's a method named getConnections. As compared to HomeFragment, there's a method named findMatches. GetConnections gets all the saved connections that the user has made. To save a connection, you need to visit their profile and press the Like button. The matches are saved in SharedPreferences as a set, and the getConnections method retrieves that set. It even uses the same RecyclerViewAdapter that we use in HomeFragment to adapt the list. Now let's take a look at MessagesFragment. Once again, the class is very similar to HomeFragment and SavedConnectionsFragment. Scroll down, and just like SavedConnectionsFragment, you see a method named getConnections. It does exactly the same thing as in SavedConnectionsFragment. The only real difference here is the initRecyclerView method. Here we use a different recycler view adapter named MessagesRecyclerViewAdapter, and we don't use the StaggeredGridLayoutManager because the list is just a regular vertical RecyclerView. Remember in MessagesFragment, it looks like this, just a regular old Recyclerview. As I mentioned, MessagesFragment has a different RecyclerViewAdapter than the other two fragments, and it's called MessagesRecyclerViewAdapter. Let's take a quick look at it. This adapter class follows the same general structure as any adapter class. It has onCreateViewHolder, onBindViewHolder, getItemCount, and a ViewHolder class with all the widget declarations. But this adapter class has an extra override method called getFilter. We're not going to use this for anything yet, but later this is going to be used to filter the RecyclerViewListResults as I showed in the application demo. And lastly, we have three new XML files, layout_messages_listitem, which defines the layout for the message's list items, fragment_messages for MessagesFragment, fragment_saved_connections for SavedConnectionsFragment. Open up fragment_messages. Fragment_messages and fragment_saved_connections just have a single RecyclerView widget in each of them. Nothing special here. Now that you know what changes I've made, let's open MainActivity and implement the navigation to these new fragments. Scroll down to the init method and copy everything related to the fragment transaction to HomeFragment. Now scroll up and paste it inside each of our switch statements. The first one isn't going to change since it's going into HomeFragment anyway. So alternatively, we could've just called init, but we'll leave it as it is for now. Now change the next one to fit SavedConnectionsFragment. Change the Fragment object and change the tag to saved_connections_fragment. Now change the MessagesFragment case. First change the Fragment object, change the tag on the replace method, and call addToBackStack, and we're done. Run it, and let's take a look. Click Login, click on the heart to inflate SavedConnectionsFragment. That looks like it's supposed to. Remember, we haven't added functionality to SavedConnections yet or displaySavedConnection, so we expect this to be blank. Now click Messages. This also looks like it's supposed to. So the app is successfully inflating the new fragments. Now let's explore this a bit. Click SavedConnections, click Home. So now we've navigated from Home to SavedConnections to Messages and then back to SavedConnections and then Home. We traveled to the end and then back, and we haven't pressed the back button at all yet. In an ideal situation, the backstack would be reset at this point, and the back navigation would go SavedConnections, Messages, and then close. To demonstrate what I mean, consider the app named Instagram. I'll go from Home to Search to Likes to Profile and then the same path back to Home. The back navigation will now go Search, Likes, Profile, then Close. That's ideal back navigation. Let's take a look at what ours looks like. Now the icons aren't being highlighted yet, but you can tell from the log what's happening. So pressing back, we go to SavedConnections, back again takes us to Messages, back again takes us to SavedConnections, and then back again takes us to Home. So the navigation is wrong, and the fragments are not being inflated properly, as you can see, because there's nothing on the screen, and the error's showing in the log. Overall, this is very far from an ideal situation. So what can we do? This course has an entire module dedicated to building a custom back navigation system. So keep watching, and we'll solve this problem shortly.

Setting Widgets with Data from a Bundle
Earlier we sent user data from the RecyclerView in HomeFragment to ViewProfileFragment using a bundle. Now let's revisit ViewProfileFragment and set all the widgets for displaying the user data. In the process, we'll also enable the use of a Like button and give users the ability to save connections. So here we are in ViewProfileFragment. As you can see, I've added all the widget declarations and attached them to their respective IDs already to save time. I encourage you to get the source code files in the directory Module4/n/TabianDating and do the same. Let's start by creating an init method that assigns all the widgets to their respective values. Remember we already have the User object from the bundle because onCreate is called before onCreateView in the fragment lifecycle. So we'll write private void init, and then write a log for debugging. I'll just say initializing and printout the fragment name. Now we need to be careful here. Before we try to set data to the widgets, I high recommend checking to make sure that data is even there. You can do this by writing a simple if statement like this. So if user does not equal null. Then we know we're good. Next, let's set the profile image using Glide. Just write Glide. with, then pass the context, with(getActivity), then load(mUser. getProfile_image), and then the widget you want to put it into, so. into(mProfileImage). GetActivity is how you reference the context when you're in a fragment. It will return the host activity's context. Now set the name, so mName. setText(mUser. getName), the gender, mGender. setText(mUser. getGender), the gender preference, mInterestedIn. setText(mUser. getInterested_in), and the relationship status, mStatus. setText(mUser. getStatus). That's all of our widgets. This is a good time to test before we move on. Let's run it. Login, now choose a random user, and there we go. We can see that correct data is being displayed. Unfortunately, we can't test another because our back navigation still isn't fixed, but it's safe to say the user data is being correctly set right now. Next, let's set the background image using Glide. As you can see, the background is just white, and we want to make it look a little better. Create another method named setBackgroundImage, so private void setBackgroundImage, and then pass the view. It's going to take the view as an input parameter because we'll need to declare the widget we're setting in the background. So declare that ImageView widget by writing ImageView backgroundImage = view. findViewById(R. id. background). Remember, we need to use the view when we attach widgets to their IDs when we're in a fragment. Now copy the Glide code from above and paste it in the setBackgroundImage method. Change the load input to Resources. BACKGROUND_HEARTS, which just points to a resource we have in the resources class in the util package. Then change the into input to the ImageView widget we just declared. I'm sure you're wondering why I didn't just set the source like I did on the Login screen. If you've forgotten, take a look at activity_login. Remember, here we set the source to the heart_background drawable file. We could've done the exact same thing in FragmentViewProfile, but performance-wise, it's better to use Glide to set images. Glide has a built-in cache, so every time the fragment is loaded after the first time, the image will be set from the cache. And let's call the method in onCreateView, so setBackgroundImage, and then pass the view. Next, we're going to set up the Like button. Scroll up to the top and implement the onLikeListener interface, implements_OnLikelistener. Now click the red light bulb and implement the interface methods. Inside the liked interface method, write a log output for debugging. Just write liked. And in the unLiked method, insert a log for debugging. Just write unliked. Now scroll up to the onCreateView method and write mLikeButton. setOnLikeListener and pass this. Now the Like button is associated with the onLikeListener interface, and these Override methods will trigger when the heart is liked or unliked. We just need to save the likes in SharedPreferences. We'll start with the Liked method. Get the SharedPreferences object, SharedPreferences preferences = PreferenceManager. getDefaultSharedPreferences and then pass in the context. Get the Editor object because we're going to be saving something, so SharedPreferences. Editor editor = preferences. edit. SharedPreferences can't save regular arrays or array lists, but they can save sets. So create a Set object of type String and get a list of all the SavedConnections for this user, preferences. getStringSet, then reference the key, so PreferenceKeys. SAVED_CONNECTIONS, and then new HashSet. If you're unfamiliar with a set data structure, it's basically the same as an array, but the values are unique. For example, if the name Mitch already exists in the set and then I try to add Mitch to the set, the set will be unchanged. It will remain exactly the same. So now that we have our set, we can add the user by writing savedNames. add(mUser. getName). And we don't have to worry about whether or not it's already there or getting duplicates because the set data structure handles all that. Now add the altered set to the editor, so we write editor. putStringSet, reference the key, and then pass the savedNames set, and commit the changes to the editor. Now let's work on the Unliked method. Copy everything in the Liked method and paste it here. Now everything is the same, except we need to change the Add method call to remove and add one extra commit. We need that extra commit to remove the previous list and then add the set. That will save the likes or remove the likes, but we don't have a view to set the LikeButton widget when the fragment is first inflated. In other words, we need to check if the user has already liked that user and then set the button accordingly when the fragment first inflates. So create one more method and call it checkIfConnected, private void checkIfConnected. Once again, we need to get the SharedPreferences object and get a set of savedNames. So copy that from the Liked method below and delete the editor because we don't need it here. The editor is only for committing new data. It's not needed for retrieving it. Now write some simple logic to set the Like button is the user's name already exists in the set. So we can just write if savedNames. contains(mUser. getName). Then we set the Like button to true, so mLikeButton. setLiked(true). Else, set the Liked button to false. Now call checkIfConnected inside the onCreateView method, and let's run it. Login, choose a random user. I'll choose Carol. Now press the Like button. Carol is now saved to SharedPreferences. We can't navigate back and then revisit the fragment because the back navigation isn't correct yet. So rerun the app to test if the like was saved. Login once again, select Carol, and there's the like. We'll try the opposite. Unlike Carol, now rerun the app, click Login, select Carol, and, as you can see, the like has been removed. Now that we have a way to save connections, there should be data populating in the SavedConnections fragment. Like Carol again, and let's take a look. Click on SavedConnections fragment in the bottom navigation view. Cool. There's a liked user being displayed in our list. Now check MessagesFragment, and we see a new message from Carol.

Navigating to a Private Chatroom
Currently when we click on a user in MessagesFragment, nothing happens. Now it's time to add a new fragment for viewing a chatroom. I've made a lot of changes in this clip, so I suggest getting the source code from the folder Module_4/n/TabianDating. Let's quickly go over the changes and then work on inflating our new chatroom fragment. Open up MessagesFragment. Notice here in the global widget declarations, I've added a new widget called SearchView. I've also added this widget to the layout file. And down below onCreate, there's a new method called initSearchView that's responsible for initializing the SearchView widget. This is the search functionality that I mentioned earlier in this course. After this clip, users will have the ability to filter the messages in MessagesFragment by the user names. The filter's triggered here in MessagesFragment, and the results are updated in MessagesRecyclerViewAdapter. Open it, and let's take a look. Remember here, the getFilter method. This will now take the search query from the SearchView widget and return a list of filtered results to the RecyclerView. I'm not going to get into detail on this because it doesn't pertain to the course topic of effective navigation. This is just an added bonus so you get some more value from the course. Now let's take a look at the new fragment class called ChatFragment. Here's what the class will look like. It's going to display the name of the user you're chatting with and then a RecyclerView full of any messages you've sent. Taking a look at onCreate, we see once again we're retrieving some incoming data from a bundle. But this time the bundle contains a Message object. The Message object class is very simple. It just contains a User object and a message. It's a class that I created, and it's here in the models package. Once again, we made sure to implement parcelable because the message is going to be sent through a bundle. We need a new data structure since when we click on a message, the user needs to be sent to the chatroom and also the message that the user wrote. The getSavedPreferences method won't actually do anything right now because it requires us to save some actual account details, but we won't be building that functionality until the module on implementing a navigation drawer. Everything else here is just more of what we've already seen. We're setting the background image, initializing the RecyclerView, and capturing click events on the various widgets in the fragment. The one difference is this initToolbar method. But all that's happening here is it's setting the ProfileImage of the dummy user and setting their name in the toolbar. Then it attaches an OnClickListener to the back arrow, but we won't be working with that yet. Just to be clear, if you post new messages to this fragment, they won't be saved anywhere. They'll just be added to the list of messages and displayed on the screen. As soon as you leave the fragment, the messages will be lost. Here is where the messages are added to the list, and here is where you notify the adapter of a change to the data set. Now that we've run through the new fragment, let's implement the navigation. If you recall from MessagesFragment, we have an OnClickListener attached to the ListItems in the RecyclerViewAdapter class, MessagesRecyclerViewAdapter. Open it up. Down here is the OnClickListener, but it's not currently doing anything. We want to do the same thing we did in MainRecyclerViewAdapter and use an interface to send the click event to MainActivity. We can then detect the click event and inflate ChatFragment. Let's review the process. Open up MainRecyclerViewAdapter, scroll down to the OnClickListener. There's our interface and the inflateViewProfileFragment method call. Now open up MainActivity, scroll down to inflateViewProfileFragment. Here is the ViewProfileFragment declaration and the data added to a bundle. This is the exact same general process we want to follow, but we'll need to create a new interface method because we'll be inflating a different fragment and sending a Message object instead of a User object. Open up IMainActivity. Write void onMessageSelected and then have an input parameter of a Message object. Now go back to MainActivity. You can see there's a warning. It's because we've added a new interface method, and MainActivity isn't currently implementing it. So click the red light bulb, implement the method, and there we go. This is going to be pretty similar to InflateViewProfile, so let's copy everything. Paste it in here, and now make the changes. Change to ChatFragment. Then change the intent key to intent_message and pass the new argument of type message. Set arguments as the same and set the tag to tag_fragment_chat. Now open MessagesRecyclerViewAdapter, scroll down to the OnClickListener, and write mInterface. onMessageSelected. Then create a new Message object inside the method by writing new Message, pass the user, and then pass the random message because, remember, the Message object requires a User object and a message as an input. We should be good to go. Let's test it. Login, make sure we have a user liked. I'll choose just one at random. Now navigate to MessagesFragment, click the message. Great, we have successfully inflated ChatFragment, and we've passed the relative data through a bundle, but notice there's a problem. The bottom navigation should not be showing in this fragment, just like it shouldn't be showing when viewing a profile. And if I go back to HomeFragment, then click another user, notice it's also showing here. We don't want that. That's another thing we're going to fix in the module on implementing a custom backstack. Before we move on, there's one last thing I want to do. Navigate back to MessagesFragment and select the message again. Currently if I click on the user's picture in the toolbar, nothing happens. We want to have the ability to navigate to their profile from here, so let's implement that. Open ChatFragment, scroll up to the top and declare the IMainActivity interface. Now we need to instantiate the interface. Remember you need to instantiate interfaces in the onAttachOverride method. So scroll down, press Ctrl+O on Windows or Cmd+O on Mac, type onAttach, and write mInterface = (IMainActivity) getActivity. When the user clicks on this RelativeLayout widget, write mInterface. inflateViewProfileFragment, and then pass message. getUser because, remember, we want to pass a User object. Now run it. Login, make sure to like someone, navigate to Messages, select the message. Now click on their profile picture in the toolbar. Great. It took us to ViewProfileFragment. So everything is working as we expect at this point.

Module Review
This module was all about implementing a bottom navigation view. We started by talking about the best practice way to set up a bottom navigation view and whether it's best to use activities or fragments. Remember there's no official best way to do this. The decision remains on the developer to provide the best user experience possible. That being said, for this project, we'll be inflating fragments when clicking on the bottom navigation view. We're using fragments because we want to save the state of each navigation item, and there's going to be some communication between them, so it's easy to use an interface implemented in MainActivity to manage those communications. Also, the animations fragments make when they come into view look much smoother than that of an activity. We could've used activity animations to improve that, but it requires a little more work. We used an external library for the BottomNavigationView widget. The widget is called the BottomNavigationViewEX. We used that instead of the standard Android navigation view because it's much easier to customize, and it will save us some time. Remember to add items to the BottomNavigationView, we created a menu directory in the res folder, then created a menu resource file name bottom_navigation_view. xml. The menu had three items in it. Each item has an ID, an icon, and a name, which we left blank because we don't want any text in our bottom navigation view. Next, we build two new fragment classes, SavedConnectionsFragment and MessagesFragment. These two fragment classes inflate when you just click on the respective items on the BottomNavigationView. Next, we set the widgets in ViewProfileFragment. Remember this fragment displays the specific user information of the user that was selected from the RecyclerView. In the RecyclerViewAdapter, we used the IMainActivity interface to capture the user that's selected. The interface method is implemented in MainActivity, which then adds the user object to a bundle and inflates ViewProfileFragment. In ViewProfileFragment in the onCreate method, not the onCreateView method, we retrieved the contents of the bundle. We also set up the Like button by implementing the OnLikeListener interface. And finally, we gave users the ability to inflate ChatFragment, a private chatroom fragment where users can send messages to one another. Once again, we used an interface to capture the selection of a message. Then MainActivity inflated the fragment and passed the message data to ChatFragment using a bundle. In the next module, we'll work on implementing a navigation drawer and setting up a fragment where users can select some basic profile preferences.

Implementing a Navigation Drawer
Introduction
Probably the most common question I get asked about navigation drawers is when to use them. And once again, I have to give this same old answer of it depends. For the duration of the module, we'll be working with the source code files in the directory Module_5/start/TabianDating. You can download the source code files by navigating to the course on Pluralsight and clicking on the tab labeled Exercise Files. So when is the best time to use a navigation drawer? I believe in best practices and proper design patterns, but the thing I most believe in that trumps everything else is providing a great user experience. If you're faced with a choice of following a best practice way of doing something or making users happy, I'd go with making users happy every time because remember if user == happy developer = happy. Else if user == angry developer = sad. All jokes aside, coming back to the original question, when do you want to use a navigation drawer? Most of the time I think it should be used to provide a sort of resetting of the navigation or to bring a user back to a central point in your app. This is going to be especially useful to users when navigating a large app with lots of different screens. They can easily get lost in it, and having a simple way to reset without closing the app is going to make them happy. But of course, if you can think of another way to make use of a navigation drawer, one that makes users happier, by all means give it a try. In this course, we're going to be using it as a means to reset back to HomeFragment, access some personalized account settings, and view the app's user agreement. We'll also cover some minor material design concepts that you can use to make your navigation drawer look a little better. They'll be things like setting a header image, setting a header title, adding new items to the navigation drawer, and separating navigation drawer items into groups.

Setting up a Navigation Drawer
Just like when we set up the BottomNavigationView, we're going to start by adding the needed widgets to their respective layouts. Open acivity_main, and let's add a widget for the navigation drawer. Currently all we have is a plain old RelativeLayout and a reference to our main content layout file. We need to add a drawer layout, but it needs to be added in a specific way. Start by changing this RelativeLayout to a DrawerLayout. Highlight it and start typing Drawer. Select the v4 DrawerLayout. Now give it an ID of drawer_layout. Next we need to add a FrameLayout for our main content container. Now copy the include tag into FrameLayout. You need to structure it this way for the navigation drawer to work properly. Below the FrameLayout, open a new tag and start typing NavigationView. Select the SupportDesign NavigationView widget. This is the widget that will be the actual drawer. Do wrap_content for the width and match_parent for the height. Give it an ID of navigation_view. Set the layout_gravity to start, so it's on the left-hand side, and give it a background color of white. So that's going to give you the most basic form of a navigation drawer. It will slide in and out of view from the left, but currently there's no menu items or a header image. First let's work on the menu. This is going to be a very similar process to what we did with the bottom navigation view menu previously. So just copy that. Now paste it in the menu folder and rename it to navigation_drawer_items. Now we just need to change it to fit our needs. If we take a look at the test application, we need to have an item to navigate to the Home screen, an item to navigate to the Settings screen, and an item in a separate group to navigate to the Agreement screen. Start by opening a tag and typing group. Now close it. If we take a look at the test app again, these group tags are how we're going to add this little separation line. We need to get the group an ID or the line won't appear. So type ID and then just give it an ID of group1. It doesn't matter what the ID is. It just needs to be there. Now copy these two items and paste it into group1. Change the first one's ID to home, the title to @string/home, and then change the icon to ic_home. Now do the second one. Change the ID to settings. We can change the title to @string/settings and change the icon to ic_settings. So that's our first group all done. Now copy the first group and paste it below. Change the ID to group2. Remember, these have to be different or the line won't appear. And then just paste that last item inside. Change the ID to agreement. Change the title to @string/agreement and then change the icon to ic_agreement. There's our menu. Now go back to activity_main, and inside the NavigationView widget, start typing menu and then choose our navigation_drawer_items menu. Let's take a quick look at it to make it's working before we move on. Now slide from the left to the right side of the screen, and there's our menu. It's working. It's pretty ugly, so let's work on adding a header to the drawer. If you take a look in the layout folder, you should see a new layout file names layout_nav_header. I've added it to the source code files ahead of time. If you're looking at the code from Module_5/start/TabianDating, it'll be in there. This is just a basic RelativeLayout with a background image and an ID of header_image, then another RelativeLayout with an ImageView and the ID of header_icon, and then there's a TextView displaying the name of the app. Now we need to set this layout to the navigation drawer. Go back to activity_main, select the navigation view, and start typing header. A headerLayout option will pop up. Select it and reference our layout_nav_header file, but we're not quite done. You might have noticed in layout_nav_header, we didn't set the background image. That's because we're going to do that using the Glide library in MainActivity. So open up MainActivity, scroll down to the widget declaration section, now write private ImageView mHeaderImage. Usually what we do next is attach the header ImageView widget to its ID, but it's not that straightforward since the widget is not technically added to activity_main. Go back to activity_main and take a look. Remember we set the HeaderLayout like this. So we actually need to reference the view before we can assign it to its ID. Go back to MainActivity, and I'll show you what I mean. So first write NavigationView navigationView = findViewById(R. id. navigation_view). Then get the view of the header, so View headerView = navigationView. getHeaderView 0. Now attach the HeaderImage to its ID by referencing the view just like you would do with a fragment, so HeaderImage = headerView. findViewById(R. id. header_image). Now we can set the background image using Glide. Scroll down below init and write private void setHeaderImage. Write a log for debugging, setting header image for navigation drawer. Now set the image with Glide, so Glide. with(this) for the context and then load(R. drawable. couple) and then into the HeaderImage. And then call the method in onCreate. And we should be good. Run it, and let's take a look. Click Login, slide from the left. Great. Everything is working as we expect.

Inflating Fragments from a Navigation Drawer
Now that we have our navigation drawer working, we can start implementing the navigation functions. I've added some more files to the source code in the directory Module_5/start/TabianDating. Take a look at the test application. As you can see from the demo app, there's nothing pertaining to navigation in these fragments except a TabLayout when you choose a new profile image. We're going to be looking at that later in the course. Because there's no new navigation features, I'm not going to talk about these fragments in detail. We're going to start working on implementing navigation to these fragments from the navigation drawer in MainActivity. So open up MainActivity. First, we need to implement a new type of navigation listener for the drawer. The widget in the drawer is a NavigationView widget, so it makes logical sense that the new listener is likely called onNavigationViewListener or something like that. Start typing OnNavigation. As you can see, there's two options. One is for the navigation view in the drawer, and one is for the bottom navigation view that we've already implemented. Select one and make sure it's the right one. I'm going to select the second one. Great, that was the right one. You can tell because this one says NavigationView. OnNavigationItemSelectedListener. If it were for the bottom navigation, it would've said BottomNavigationViewEx. OnNavigationItemSelectedListener. Notice it's not giving me any errors. In this past when we've implemented a new interface, Android Studio gives us a warning and tells us to implement the required methods. It's not giving us an error here because the interface method is the same for navigation views as for bottom navigation views. We've already implemented the correct method right here, so all we need to do is add a couple more cases to our switch statement. So we'll add one from home doing case R. id. home. Then copy that case and change home to settings and just change home to agreement. Remember these are the IDs from our menu. Open up navigation_drawer_items. xml. See here they are right here, home, settings, and agreement. Now let's do the fragment transactions. Copy the code from this case and paste it into agreement. You don't need item. setChecked since we don't want to highlight anything in the navigation drawer. Change the log to say agreement. Change the fragment to represent the one for agreement. Change the tags for agreement. Now copy that, paste it into settings. Change it to SettingsFragment. Change the tags. For this last one, we're just going to call init. Since all we want to do is actually reload HomeFragment anyway, there's no need to write another fragment transaction here. Keep in mind, this isn't perfect. The back navigation and a number of other things aren't going to be working quite right until we build a custom navigation management system later in the course. Right now if you click on an item in the drawer, it's going to open, but the drawer is not going to close afterwards. Scroll down to the widget section and write private DrawerLayout mDrawerLayout. Now attach the DrawerLayout to its ID, so findViewById(R. id. drawer_layout). And then to make the drawer close after an item is selected, we need to call DrawerLayout. closeDrawer and then GravityCompat. START. We just need to do one more thing before we test. Currently the navigation drawer doesn't have a listener set to it. Scroll down below onCreate, create a new method, private void setNavigationViewListener. Write a log for debugging, initializing the navigation drawer listener. Create the NavigationView object and reference the ID, so NavigationView navigationView = findViewById(R. id. navigationview) and then set the listener, so navigationView. set on NavigationItemSelectedListener. Then pass this. And then call the method in onCreate, so setNavigationViewListener. Okay, let's run it and take a look. Click Login, open the drawer, click Settings. Great, that one works. Now open the drawer again, click Agreement, and that one works too. Open the drawer one more time, click Home. Cool. So everything is working as we expect.

Module Review
Let's do a quick review of everything covered in this module. We started by adding a DrawerLayout to activity_main. A DrawerLayout is required to use the navigation drawer, but it's not the only thing that's required. You also need to structure your layout file like this. Have a DrawerLayout, then a FrameLayout containing the main content, and a navigation view that actually shows the Drawer widget. We built a menu for the navigation view that contained three items. Two of the items were added to group1, and the last item was added to group2. We broke the menu into groups so there would be a dividing line in the navigation drawer separating them. At this point, the drawer was working, but it wasn't very esthetically pleasing. So we added a HeaderLayout to the NavigationView widget to make it look better. The HeaderLayout contained a large background image, an icon displaying the Tabian Dating logo, and a title that said Tabian Dating. Next we added an OnNavigationItemSelectedListener to MainActivity and added the fragment transactions for settings fragment and Agreement fragment. To close a drawer after a navigation item is selected, we called closeDrawer(GravityCompat. START) on the DrawerLayout object. In the next module, we'll build a custom navigation management system so we don't have to rely on any fragment transactions to the backstack and having our fragments destroyed after each transaction.

Implementing a Custom Back Stack
Introduction
Having proper back navigation is hard to come by. As I've demonstrated many times in the course, the default back behavior is far from ideal. For the duration of the module, we'll be working with the source code files in the directory Module_6/start/TabianDating. You can download the source code files by navigating to the course on Pluralsight and clicking on the tab labeled Exercise Files. When we navigate to a new fragment, the previous ones are destroyed, and therefore the state is lost. So when we press the back button, the fragments appear empty or not right to say the least. The back navigation also follows a perfectly linear path. For example, if I navigate to fragment A, then fragment B, then C, then to B again, and then if I navigate back, it goes B, C, B, A. Obviously that doesn't really make sense. You shouldn't have to revisit B. It should go like this, B, C, A. So really what we need is a system that removes the fragments from the bottom of the stack if they're revisited again. For example, if we visited A, then B, then C, then B again, the first fragment B would be removed from the bottom middle. Then if we navigated back, it would go C, then A since we were already viewing B. If you take a look at any of the most popular apps right now, that's how they manage their back navigation. Let's take a look at Instagram. Click Home, then Search, then Likes, then Profile. Now go back to Likes. So we expect it to go Profile, Search, and then Home. Let's try. Press back, there's Profile. Back again, there's Search. Back again, there's Home. So they're doing exactly what we just talked about. They're removing the fragments that are revisited from the middle of the stack. Additionally, if I scroll to a random position in the feed, then navigate away from the feed and then go back to it, it saves that position. So in other words, the fragment state is maintained, and the fragment is not destroyed when you navigate away from it. We're going to model our back navigation exactly like this.

Building a Custom Back Stack
Almost all the code in this module is going to be written in MainActivity. This is because MainActivity is central to the navigation of the app. If we want to inflate a new fragment or navigate back to one, we'll be routing the method calls through MainActivity. Open MainActivity and scroll down to the Fragments heading. As you can see, I've created another heading named Fragments. Under this heading is where we're going to put all the fragment objects that are routed through MainActivity. We're going to be making the fragments global because they aren't going to be destroyed when the user navigates away from them. If you scroll up, you'll also notice that I've changed the previous fragment declarations to the global versions as you can see here in the navigation view. If you scroll down to the bottom, you'll notice I've also changed the fragments in the Override methods from the interface. There's mProfileFragment and mChatFragment. But this alone isn't enough to keep the fragments from being destroyed. Scroll up to the first switch case. We need to get rid of the replace method call and use the add method call. So we have transaction. add instead of transaction. replace on each of these fragment transactions. Replace will take whatever was previously in the fragment container and replace it with the new fragment in the transaction. The add method will just add the new fragment to the view. So essentially the fragments will stack on top of one another and then both will be visible to the user. I'll demonstrate. Press Ctrl+R and replace the replace method call with add. Now click Replace all. Run the app, and let's see what happens. Login. Now click on a user from the list. As you can see now, both fragments are in view simultaneously. Obviously this isn't what we want, but we did solve one problem. The fragments are no longer being destroyed. The new problem we need to solve is how do we make only the newest fragment visible or, in other words, the fragment on top of the stack? First we need to make our own stack and get rid of the default one we're currently using with the addToBackStack method calls. Scroll through your code and delete all the addToBackStack method calls. I'm just going to click on addToBackStack, now press Ctrl+F, and now I'm going to scroll through them and delete them all. Two, three, four, five, six, seven, eight. Okay that should be all of them. Now scroll up to the vars heading above onCreate. The first variable we'll use is an array list of fragment tags, so write private ArrayList of type String, then mFragmentTags = new ArrayList. Next we need another list that holds our global fragments in MainActivity. Write private ArrayList, pass an object type of FragmentTag, call it mFragments = new ArrayList. Don't panic. The fragment in that class is one that I made, so you can find it in the models package. Take a look. It's just a data structure that holds a Fragment object and a String that I called tag. So it's going to hold a fragment and the tag associated with it. How it'll make our lives easier will become apparent shortly. Back to MainActivity. Now for one last variable, write private int mExitCount = 0. This variable is going to be responsible for letting the application close if the backstack is empty. Scroll up to the first item in our switch statement. Since we aren't going to be using the addToBackStack method calls for the fragment transactions anymore, we're going to replace it with our new backstack list. So after the transaction is committed, write mFragmentTags. add, then getString(R. string. tag_fragment_settings), and then Fragments. add(new FragmentTag), pass the fragment, and then pass the tag. But this isn't quite right yet. We don't need to create a new fragment if it's already built. So we'll write some simple logic to check if the fragment has already been instantiated. Write if(mSettingsFragment == null), then we want to create a new one. But what if it's not null? In that case, we want to remove the lower entry of this fragment in the stack and then move it to the top. Take a look at this demonstration again. Remember if a fragment is revisited, we don't need to visit it more than once when navigating backwards. So we need to remove the previous stack entry. So if we went A, then to B, then C, then back to B again, we would want to remove that previous entry of B from the stack. So at the end of this if statement, we can write else FragmentTags. remove, then pass the tag, and then add it back in, so FragmentTags. add and then a tag. If you're not familiar with the ArrayList data structure, this might seem counterproductive to you. But actually when you use the remove method, it will remove that object from the list and then will squish down the list. That is essentially exactly what we want to do. Remember if we compare to our demo, before we add B to the top of the stack, we would actually want to remove B from the middle of the stack. So that's what we're doing with this Remove method call. This is exactly the behavior that we need. Now let's do the same thing for every fragment transaction. So we'll just copy this logic, paste it. Now copy the transaction and paste it and make the changes. Now for Home Fragment, once again copy the logic, paste it, cut the transaction, paste that in, one, two changes, tag home, tag home, tag home, tag home, tag home. Now do SavedConnectionsFragment, copy the logic, paste it in, cut the transaction, SavedConnections, SavedConnections, five tag connections, now messages. Copy the logic, paste that in, cut the transaction, paste it in, one, two changes, so five tag messages. Copy the logic and scroll down to init. Now paste that in. Remove the setChecked call, cut the transaction, one and two changes. Then do the tags, one, two, three, four, five. Copy the logic. Scroll down to InflateViewProfile. This is going to be a little bit different. Unlike the other fragments, we actually want to destroy and recreate this one. If we don't, it won't receive the new data from the bundle. So paste the logic, but all we actually need is the code where we add the fragment and the tag to the array lists. Now write if(mViewProfileFragment! = null) getSupportFragmentManager. beginTransaction. remove, pass the fragment, and then commitAllowingStateLoss. This will remove the previous fragment if there was one. Now copy the two array lists and do the same thing for ChatFragment. Now write if ChatFragment! = null getSupportFragmentManager. beginTransaction. remove ChatFragment and commitAllowingStateLoss. That's it, we're done. I wish there was a faster way to do that, but there isn't. So that's all great. We now have our own backstack. If you recall the next problem we had to solve, we needed a way to hide all the fragments that aren't on the top of the backstack or, in other words, only show the fragment that's at the top of the stack. This is surprisingly simple now that we have our own backstack. Scroll up to just below the init method. We're going to create a new method that loops through our backstack and hides every fragment except the one that we tell it not to. So write private void setFragmentVisibilities and then pass a String input of tagname. Now loop through the fragments in the stack, so for int i, i is less than Fragments. size, i++. Now if tagname. equals Fragments. get(i). getTag, then we want it to show. That would mean that we're in the loop entry of the tag that we passed to the method. Otherwise, we don't want it to show. So if it's the tag we passed to the method, we can do a fragment transaction and use the show method. Copy the transaction in the init method, paste it here. Get rid of the add method call and instead write transaction. show, then Fragments. get(i). getFragment. Now copy that and paste it into the else statement and change it to hide. An alternative way to write this method would've been to loop through every fragment in our stack and then hide every one except for the last one, and you wouldn't need to pass a tag name to the method. I'm going to leave it as is, but feel free to do whatever you like. Now each time there's a fragment transaction, we just need to call this method and pass the tag of the new top fragment. Let's start at the bottom. Here's inflatViewProfile and onMessageSelected. Just call setFragmentVisibilities, then pass the new top tag, so in this case it's tag_view_profile. Now copy that, paste it below, and then change the tag. Oh but wait, looks like there's an issue here. We forgot to insert ViewProfileFragment here where it says HomeFragment. And then down below here, we forgot to insert ChatFragment where it says HomeFragment. Just quickly make those corrections. Now copy the method again. Scroll up to the very top of the file, paste it in settings, paste it in agreement, paste it in home, paste it in connections, and then paste it in messages. Head back to the top, get the settings tag, add the agreement tag, the home tag, and get the messages tag. We've got one more. Copy the method, scroll down to init, paste it in, and change the tag. We're almost done. Scroll up to the very first switch case. Here we need to clear the tag stack, so write FragmentTags. clear and then FragmentTags = new ArrayList. We're doing this because when we click on the Home item in the navigation drawer, we want everything to be reset. We want to remove everything from the backstack. Run it, and let's take a look. Okay, Login. Keep in mind, all we're testing here is to see if the fragments are inflating properly and the ones that aren't on the top of the stack are being hidden. Click on a user, like them, now check connections. Okay, go to messages, click a message, go to their profile. Everything looks good except one thing. Notice what happens when I click home on the navigation bar. The icon doesn't highlight. Let's fix that. The item. setChecked method calls need to be put outside the if else logic. So move the one for home and move the one for connections and messages. So everything's working as we expect to this point, and the fragments are being hidden or shown relative to whatever one is on the top of the stack.

Overriding the Back Button
Now that we have a way of manually managing the backstack, we need to override the default back behavior for when a user presses on the back button. In MainActivity, scroll down just below the init method. Now press Ctrl+O on Windows or Cmd+O on Mac. Select the onBackPressed method. Comment out the super so the default back behavior won't work anymore. By doing that, we effectively disable the back button. Run the app and take a look for yourself. Login, click on a user. Now try pressing the back button. Notice it doesn't do anything. So by overriding the back button and commenting out the super, we basically disabled the default back behavior in MainActivity and, consequently, all the fragments that are hosted in it. Now let's work on our custom back navigation. But before we write anything, let's define the problem we're trying to solve. If the back button is pressed, we want to remove the fragment that's currently at the top of the stack. Then we want to show the fragment that is second to the top. This should be pretty straightforward. The only thing we need to watch out for is making sure there's a fragment second from the top or, in other words, if the fragment stack is larger than 1. So that's really our only condition. We need to make sure the fragment stack is larger than 1. So a good starting point is getting the size of the stack. So write int backStackCount = mFragmentTags. size. Now if the backStackCount is greater than 1, we know we can navigate backwards. Okay, so what's the next problem? If we're inside this if statement, we know there's more than one fragment in the stack, so we need to remove the one at the top and then show the one second from the top. Write String topFragmentTag = mFragmentTags. get(backStackCount -1). Then get the tag of the second one from the top, so String newTopFragmentTag = FragmentTags. get(backStackCount - 2). Set the new one visible and hide the old one. So we can call our setFragmentVisibilities method and then pass the newTopFragmentTag and finally remove the old one from the top, so FragmentTags. remove(topFragmentTag). And that'll do it. That handles the case when there's more than one fragment in the stack. But what if there isn't? So next write else if(backStackCount == 1). So if the backstack only has a single fragment left in it, then we need to get ready to close the app. And remember, we're using the mExitCount variable for that. So write mExitCount++, then print a Toast, letting the user know that if they click 1 more time, the app will close, and then just say 1 more click to exit. Then to actually close it, we need to write some more logic outside this if else chain. Write if ExitCount is greater than or equal to 2, super. onBackPressed. So now if the ExitCount becomes greater than or equal to 2, the default back behavior will automatically be used, and the app will close. So now let's test it. Click Login, click a user from the list. Now press back. Okay, great. That works. Now press the middle nav item, now the messages nav item, and once again the middle. So when we navigate back, we expect it to go messages, then home, then close. Let's try it. There's messages, but wait. Notice the icon isn't being highlighted, so that's a new problem. When navigating back, the proper icons aren't being highlighted, so we'll have to fix that. Now press back again. There's home, so that's good. Press back again, and there's our exit message. One more time, and it closes. Good. So the actual back navigation is doing what we want, but the icons aren't being highlighted. To fix that, we need to create a new method. Below the onBackPressed method, write private void setNavigationIcon and then do String tagname as an input, then Menu menu = BottomNavViewEx. getMenu, then MenuItem menuItem = null. Now we'll write logic to set the proper icon depending on what tag is passed to the method. So if tagname. equals(getString(R. string. tag_fragment_home), write a log for debugging, home fragment is visible. Get the menu item number by writing menuItem = menu. getItem 0. Then set it to checked, so menuItem. setChecked(true). Notice that I passed a 0 here for getItem. That's because HomeFragment is in the 0th position on our bottom navigation view. We can create some constants for this so it's more obvious. Scroll up to above onCreate, write a short heading that says constants, then private static final int HOME_FRAGMENT = 0. Copy that and paste it two more times. Change this one to CONNECTIONS and this one to MESSAGES. Now change this one to 1 and this one to a 2. Now scroll back down to the setNavigationIcon method and pass in HOME_FRAGMENT instead of this 0. Now copy that if statement, and let's do the same thing for connections. Change the tag, change the log, and change the item. Now copy it again, paste it, change the tag, change the log, and change the item. Scroll to setFragmentVisibilities, call the setNavigationIcon method at the bottom, and pass the tagname. Now inside onBackPressed, we need to reset the ExitCount if the backstack is greater than 1, so just write mExitCount = 0. Now it's time to run it and take a look. Login, go to connections, then messages, then connections again. Now press back, back, and back. Great. That is exactly what we want. I want to do one more thing to the back navigation. If the user is scrolling through the feed and they're not at the top of the list, I want the list to scroll to the top when they press the back button. To do that, we just need to change the logic a bit. First, determine if the top fragment is HomeFragment, so String topFragmentTag = FragmentTags backStackCount - 1. Then if topFragmentTag. equals fragment_home, then just do what we were doing before. Copy the ExitCount and the Toast, paste that into the if, else, and paste it into the else, but we'll also need to add the scrolling method in there, so we need to build that. Open HomeFragment, scroll down to the bottom, write public void scrollToTop. Then just write mRecyclerView. smoothScrollToPosition and 0. Make sure this method is public. Now go back to MainActivity. And inside our if statement, write mHomeFragment. scrollToTop. This is another advantage of saving all the fragments as globals. You can easily communicate with them by calling methods on the fragment instance. If we didn't save the fragments as globals, we'd have to find the fragment by searching for its ID or its tag. It would look something like this, HomeFragment fragment = HomeFragment getSupportFragmentManager findFragmentByTag and then reference the tag. The app would search for any active fragment instances with that identifier tag, but I think it's pretty easy to see it's much simpler to use a global fragment definition. We still have a few more problems to solve. Run the app, and let's take a look. Login. Notice if I click on a profile, the bottom navigation is still showing. The same goes when I navigate to Settings, navigate to Agreement, and also the chatroom. We don't want this. We don't want to show the nav bar on any fragments with a toolbar and a back arrow. We want to give the illusion that we're traveling into the app, and the only way to get back is by pressing the back button or the back arrow. That being said, do you see another problem? We haven't set up any methods for pressing the back arrows. So we have two more problems to solve, hiding the navigation on certain fragments and enabling proper back navigation when clicking on the back arrows. Enabling proper back navigation when clicking on the back arrows is actually very simple. Let's take a look at that first. Open IMainActivity. We're going to create another interface method that points to the onBackPressedOverride method in MainActivity. So write void onBackPressed, open MainActivity, and scroll to the onBackPressed method. Notice Android Studio isn't giving us an error like every other time we added a new override method. That's because our new interface method matches that of the name of onBackPressed. So our new interface method is automatically routed through this onBackPressedOverride method. That's great. That makes our lives way easier. And if you don't know what I mean, open up IMainActivity. Now write some random new interface method. I'm just going to write void someRandomMethod. Now go back to MainActivity, and you can see Android Studio is giving us an error. That's because we haven't added an interface method for someRandomMethod. Back to IMainActivity. Just delete that. Now we need to call our new onBackPressed method in every fragment with a back arrow. So open SettingsFragment, ChatFragment, ViewProfileFragment, and AgreementFragment. We'll start with SettingsFragment. Scroll down to the onClick override method. Inside the if statement that detects the back arrow click, write mInterface. onBackPressed. Copy that and go to the next one. Same thing. Scroll down to onClick. Next one, scroll down, paste in the method call. And last one, scroll down, paste in the method. Now these fragments will follow the same back navigation logic as everything else. Okay, so we have one problem left. We need to hide the bottom navigation bar in these four fragments that have back arrows. Open MainActivity. To save some time, I've added two new methods to the source code. Scroll down below the setHeaderImage method. You'll see hideBottomNavigation and showBottomNavigation. These methods just set the visibility of the BottomNavigation widget. Scroll up to the setFragmentVisibilities method. Now let's write the logic. So if tagname. equals fragment_home showBottomNavigation. Now copy that logic, paste it twice, then just change the tag to SavedConnections and change this tag to messages. Write else and else. Now paste it once more. Change the method to hideBottomNavigation and then change the tag to settings. Now copy that logic and paste it three more times. This tag goes to view_profile and this tag to chat and this tag to agreement. Now anytime a change is made to the fragments, this method will check and show or hide the bottom navigation. Let's test it. Click Login, click a user. Great, that's hidden. Go back. Now go to Settings, hidden. Go to Agreement, hidden. Go to Messages, choose a chat, and that's hidden. Go to the user's profile, that's hidden. Great. So everything is working as we expect.

Refreshing a RecyclerView
You might have noticed that if we like a new user, then navigate to SavedConnections fragment, the RecyclerView does not show the newly liked user. That's an obvious problem, so let's fix it. We'll be making use of Android's SwipeRefreshLayout that was introduced in their support v4 libraries. The implementation is very simple. All we need to do is add a SwipeRefreshLayout to each layout file that has a RecyclerView. Then we just implement the interface in the corresponding fragment. Pretty simple. We'll start with HomeFragment. Open a new tag, start typing SwipeRefresh. Select the layout. Do match_parent and match_parent and then give it an ID of swipe_refresh_layout. Now cut the RecyclerView and paste it inside the swipe_refresh_layout, open HomeFragment, and at the top- right, implements SwipeRefreshLayout. OnRefreshListener. Click the red light bulb, implement the methods. Now scroll up, and let's declare the layout. Under the widgets heading, write private SwipeRefreshLayout mSwipeRefreshLayout. Inside onCreateView attach it to its ID and attach an OnRefreshListener to the layout. Scroll down to the onRefresh method. The onRefresh method will be called when the user drags their finger from the top of the screen and then lets go. So in here, we need to update the list, so call findMatches. Then we need a way to tell the layout to stop refreshing. So write a new method, void onItemsLoadComplete. Inside we just want to notify the adapter that the data sent might have changed, so write mRecyclerViewAdapter. notifyDataSetChanged. Then we just tell the SwipeRefreshLayout to stop refreshing, so SwipeRefreshLayout. setRefreshing(false). Now call the method after findMatches. That's it, we're done. Run it, and let's test HomeFragment. Login, navigate to Settings. Change the preference to something else. Click Save. Now go back, refresh, and you can see the list has been updated. I really love SwipeRefreshLayouts. They're just so easy to use, they look great, and they're effective. To implement the SwipeRefreshLayout in SavedConnectionsFragment and MessagesFragment, follow the exact same process. I'm not going to do it on video since it's exactly the same as we just did. If you don't want to do it, just get the source code files from the directory Module_6/n/TabianDating. Or like I said, implement it yourself, and I'll leave that up to you as an exercise.

Module Review
The default back navigation behavior is less than ideal when using the addToBackStack method on fragment transactions. To improve the user experience, we built a custom backstack and implemented the means to use it. The first step in solving our problem was creating data structures to save the backstack entries. We declared two array lists. One saved the fragment tags and was named mFragmentTags, and the other saved a custom data structure called FragmentTag that holds a Fragment object and the tag associate with it. The array list that holds the FragmentTag data structure is named mFragments. Next we went through the code in MainActivity and removed the addToBackStack method calls in the fragment transactions. We needed to add the fragments and the fragment tags to our new array lists, mFragmentTags and mFragments. For example, if we were inflating MessagesFragment, we would write mFragmentTags. add, then the tag, and also Fragments. addnew FragmentTag, then pass the fragment and pass the tag. And we did this exactly the same for each fragment transaction in the class. We changed the replace method calls on the fragment transactions to add. We changed them because replace will destroy the previous fragment. We want to save the fragment states, and we don't want to destroy them. Now that we had a way to save fragments in our custom-built backstack, we needed to override the default back button behavior. As it stood, pressing the back button would tell the app to check the standard backstack, but we needed it to look in our custom one. Overriding the back button is simple. We just inserted the onBackPressed override method and removed the super. onBackPressed method call. That effectively disabled back navigation in MainActivity. In the onBackPressed method, we wrote logic to incorporate our new backstack. If the backstack had more than one entry, we removed what was at the top of the stack and then displayed the fragment that was second from the top. If the backstack only had one entry, we displayed a message saying one more click to exit. This would increment the mExitCount variable. Once the ExitCount reached 2 or higher, the app would close. Because the fragments aren't being destroyed, we needed a way to hide the fragments that weren't at the top of the stack and only show the one at the top. To solve that problem, we created a method named setFragmentVisibilities. SetFragmentVisibilities had three major functions, hide the fragments not at the top of the stack, show the fragment at the top of the stack, then hide or show the bottom navigation view depending on what fragment was being viewed. Any fragment with a back arrow and a toolbar would not show the bottom navigation. That brings us to our last problem. The fragments with back arrows needed a way to use our custom back navigation. This posed an issue because pressing the back arrow is not the same as pressing the back button. We couldn't rely on the onBackPressed method to trigger in MainActivity. Solving this problem was simple. We created a new interface method IMainActivity called onBackPressed. The onBackPressed interface method would trigger the onBackPressed override method in MainActivity. Then we just called the method in an OnClickListener for the back arrow in each fragment, so it looked like Interface. onBackPressed. Lastly, we implemented the SwipeRefresh functionality on the RecyclerViews so that when a user drags down without list, it gets refreshed with a nice, loading animation. In the next module, we'll work on implementing tabs and giving users the ability to select a new profile image.

Implementing Tabs
Introduction
Most mobile applications implement some kind of a TabLayout, and it's for good reason. Tabs provide a convenient way of viewing content by swiping left or swiping right. For the duration of the module, we'll be working with the source code files in the directory Module_7/start/TabianDating. You can download the source code files by navigating to the course on Pluralsight and clicking on the tab labeled Exercise Files. Tabs are one of the few cases when you absolutely need to use fragments. Activities are not an option. Tabs are fragments, but they're a unique type of fragment. To implement tabs effectively, you need to build an adapter class that extents FragmentPagerAdapter. The FragmentPagerAdapter class was designed specifically with tabs in mind and enables tabs to be saved in memory. So as you swipe through them, the contents are not reloaded, and the fragments are not destroyed. Basically, the FragmentPagerAdapter class prevents the fragments from being destroyed and provides a means of organizing them, sort of similar to how we organized our fragments in the custom backstack. If you search the Android documentation for FragmentPagerAdapter, you'll find two classes that are very similar. There's a FragmentPagerAdapter class and a FragmentStatePagerAdapter class. Do not confuse the two. The FragmentPagerAdapter is meant for tabs, and the FragmentStatePagerAdapter is made for when you have many fragments that you want to swipe through. As a rule, the FragmentPagerAdapter should be used if you want to swipe through five fragments or less. The FragmentStatePagerAdapter should be used if you have more. And in that case, you should not use tabs. Setting up tabs is similar to what we've been doing already in the course with a few small differences. We're going to examine the similarities and the differences in the upcoming clips.

Using the ViewPager Widget and TabLayout Widget
Before we get started with the TabLayout, let's go over the code changes I made for this module. If you didn't get the source code in the directory Module_7/start/TabianDating, I high suggest doing so. Open Android Studio and expand the settings package. I've added a lot of new files here. Start with ChoosePhotoActivity. To implement tabs, we need another activity to host the new fragments. That new activity is ChoosePhotoActivity. There's nothing here yet, but this is where we're going to manage everything to do with tabs. Next, open GalleryFragment. GalleryFragment is one of the new tabs. This is the fragment users will be able to choose a photo from memory with. If you don't remember, it'll be this tab right here. Next, we have the GridImageAdapter class. This is the adapter responsible for displaying the images from the phone's memory. Next is PhotoFragment. PhotoFragment is the one responsible for launching the camera intent. It's the fragment right here. Now open the SquareImageView class. This class is for building SquareImageView widgets. As you can see, it extends the ImageView class. In its onMeasure method, I've passed the width to both the width and the height. So it guarantees the images set to this widget will be square. These are used by the GridImageAdapter class to make sure the images are square. And last, but definitely not least, is FileSearch. FileSearch is in the util package. This class is responsible for getting a list of directory paths from the path that you send it. It's also used to get the file paths from within the directories using the getFilePaths method down here. We use this in GalleryFragment to return the directories where the images might be on the device. I won't be covering any of these classes in detail since their contents don't pertain to effective navigation, but I definitely encourage you to take a closer look and figure out how they work. Open SettingsFragment, and let's talk about the changes in there. Scroll down to the method checkPermissions. As of Android version 23, otherwise known as Marshmallow, some permissions need to be explicitly confirmed by the user. Among them is permissions to write to external storage and also permission to use the camera. That's what this method takes care of. It checks to see if these permissions have been explicitly confirmed by the user. If they haven't, then a dialog pops up and asks them if they have. If they already have, then nothing happens. We're calling the checkPermissions method up here in the OnClickListener interface. It's also being checked in the onCreateView method up here. Scroll back down to the OnClickListener interface. So it checks to see if the mPermissionsCheck Boolean is true or false. If it's true, it opens ChoosePhotoActivity, but you'll notice something different about how we open this activity. Previously we used the StartActivity method, but here we're using StartActivityForResult and also passing a result code. This result code, NEW_PHOTO_REQUEST, is a just a random integer constant that I defined at the top of the class. Basically, we're using the result code to mark this intent, so we can detect it later. If that confuses you, let me give you an analogy. Imagine you have a fish tank in your home and it contains 100 fish that look exactly the same. Suppose you want to track the movements of a specific fish. One way you could do that would be to mark it somehow, maybe put a tiny, little tag on its fin so you could pick it out from the rest. That's basically the same principle. We're marking the intent so we can look at it later. We'll talk more about this later in the section on retrieving an image using onActivityResult, but I want you to notice that this is different. Next, open your manifests file. I've already told you about the explicit permissions check we need to do for the camera and writing to external storage, but asking explicitly is only part of it. We also need to write those permissions in the app's manifests file. Here's the one for writing to external storage, and here's the one for using the camera. Alright, we're ready to get started with our tabs. Open activity_choose_photo. Notice the parent layout is a CoordinatorLayout. Tabs must be contained in a CoordinatorLayout. And also I've got two RelativeLayouts inside. One is occupying the entire layout, and the other one is anchored to the bottom of the view. Inside the top RelativeLayout is where we're going to put our ViewPager widget. Open a new tag, start typing ViewPager, match_parent and match_parent, and give it an ID of viewpager_container. A ViewPager is similar to a FrameLayout because it's also a container for fragments. The main difference is a ViewPager can swipe. The ViewPager is what's going to hold our fragment tabs. Okay, now we need our TabLyout. Scroll down to inside this AppBarLayout, open a new tag, start typing TabLayout. Make sure to get this SupportDesign widget. I've accidentally selected TableLayout way too many times. Width is match_parent, and then the height is? attr/actionBarSize. Give it an ID of tabs_bottom and set a background color white. Notice in relLayout1, I've added a property that sets it above relLayout2, so the ViewPager will always be above the tabs. We're done in activity_choose_photo. Now we have all the widgets we need to start setting up our tabs.

Implementing Tabs and the ViewPager Adapter
Now that we have all the required widgets added to our layout, let's build the ViewPagerAdapter. Right-click on the settings package. Go to New, Java Class, and name is MyPagerAdapter. As we talked about in the intro, we're going to extend this class using FragmentPagerAdapter. So write extends_FragmentPagerAdapter. Notice I could also write FragmentStatePagerAdapter, but the StatePagerAdapter is not used for tabs. Tabs are kept in memory and not destroyed. For that, we need to use FragmentPagerAdapter class. Now right-click on the red light bulb and implement the methods. There's two required methods for this class, getItem and getCount. GetCount defines the number of tabs you'll have, and getItem will set each fragment to their designated position. Now insert the constructor. Now we need a data structure to save our fragments. We're going to do something similar to how we saved our fragments in the backstack. Write private final List Fragment mFragmentList = new ArrayList. This ArrayList will store our tab fragments. Then in the getItem method write mFragmentList. get(position), and in the getCount method, write mFragmentList. size. So that's all great, but currently there's no way to actually add the fragments to our PagerAdapter, so let's build a method for that. Write public void addFragment and take a Fragment as an input, then FragmentList. add(fragment). That's it. Our PagerAdapter is complete. Let's go back to ChoosePhotoActivity and finish up. First declare the ViewPager widget, so private ViewPager ViewPager. Attach it to its ID, ViewPager = findViewById(R. id. viewpager_container). Now build a new method for setting everything up. Write private void setupViewPager. Declare the MyPagerAdapter object, so MyPagerAdapter adapter = MyPagerAdapter. Then pass the SupportFragmentManager. Instantiate the fragments, so GalleryFragment = new fragment, PhotoFragment = new fragment, and then add the fragments to the adapter using the addFragment method that we created in our adapter class, so adapter. addFragment GalleryFragment and adapter. addFragment PhotoFragment. Taking a look at our test application, keep in mind that where you add these in matters. Because we added GalleryFragment first, it will occupy the leftmost tab, and PhotoFragment will be on the right. Now set our adapter to the ViewPager widget, mViewPager. setAdapter and pass our adapter, and that's it for the ViewPager. Now we just need to set up our tabs. Start by declaring a TabLayout object and then attaching to it to its ID, so TabLayout tabLayout = findViewById(R. id. tabs_bottom). Then write tabLayout. setupWithViewPager and pass our ViewPager. And that associates the TabLayout with our ViewPager. Now we're going to do some minor customization to the tabs. We just want to display some text on them, so write tabLayout. getTabAt, pass the constant GALLERY_FRAGMENT, which is just 0. Then setText to the fragment name. Then for PhotoFragment, copy that line. Replace the constant, which is just 1 and then set the text to that fragment tag. Let's test it. Login, go to Settings. There's our permissions check, so press Allow and Allow. We can browse the directories by clicking up here. And then on this tab, we can open the camera. If I select a photo from the gallery and then click Choose, notice that nothing is set. That's because we have no way of retrieving the data yet. We still need to retrieve the newly selected image or the one taken with the camera. That's what we'll work on next.

Using OnActivityResult to Retrieve Images
We have a way to select images from the phone's memory, and we have a way to take a new photo using the phone's camera. Now we need to retrieve the new images and save it in SharedPreferences. We'll start in GalleryFragment and retrieve the new image from memory. Scroll down to the method named setUpGridView. Here is an OnClickListener attached to the grid items. This will trigger when a user clicks on an item in the grid. Then the image is set to the ImageView widget with setImage, and the image URL is saved as a variable named mSelectedImage. mSelectedImage is what we need to send back to SettingsFragment and save in SharedPreferences. If the user doesn't click anything on the grid, mSelectedImage is set to the first image in the directory. You can see it being assigned right here in the tryCatchBlock. Scroll up to onCreateView. We need to close the window when the user clicks on the TextView widget named Choose. When they click Choose, we need to finish the activity and send a result back to SettingsFragment. We don't want to send back a null result, so first check to see if mSelectedImage has been set. Then to finish the activity and send the result, we write getActivity. setResult, pass the NEW_PHOTO_REQUEST, then getActivity getIntent putExtra. Reference the intent from gallery new photo and then pass the new SelectedImage. Then call getActivity. finish to finish the activity. Notice the result code we're using, NEW_PHOTO_REQUEST. That's the result code we used to start the activity in SettingsFragment. Open up SettingsFragment and take a look. Scroll down to the onClick interface method. Remember right here. Now back to GalleryFragment. Because GalleryFragment is hosted in ChoosePhotoActivity, this will finish ChoosePhotoActivity and consequently destroy GalleryFragment. Go back to SettingsFragment. Now in here, we need a way to retrieve the result. We can get the result with an override method named onActivityResult. Click below the onClick interface and press Ctrl+O on Windows or Cmd+O on Mac. Start typing onActivityResult, select that. This method will intercept any results coming in when an activity is finished. We just finished ChoosePhotoActivity, so let's get the result. First write a log for debugging. I'll just write called. I highly recommend writing logs in methods like this. That way you know when something has been received when you're debugging. Now check for our result code, so just write if resultCode == NEW_PHOTO_REQUEST. If that's true, we know we have something coming in from ChoosePhotoActivity. Write another log for debugging, received an activity result from photo request. Now check if that incoming data is null. This is very important. If you try to get objects from null data, the app will crash. So if data! = null, then we'll proceed. But we still need to check if it's a new image from the camera or a new image from the phone's memory. So if data. hasExtra, then intent_new_gallery_photo. If we have a new photo from the gallery, let's set it using Glide, so Glide. with this and then load the image URL using data. getStringExtra and then reference intent_new_gallery_photo. And then you want to put that into mProfileImage. We're going to want to save the URL in a global variable, so we can save it in SharedPreferences when the user clicks Save. So write mSelectedImageUrl = data. getStringExtra and then intent_new_gallery_photo. Okay, that's all we need to do. Let's test it. Login, go to Settings, click the camera. Oh, just as kind of a side note, these directories are going to be different depending on what directories you have in your phone. These are just the directories that I have in the device that I'm testing with. Okay, now choose a photo. Cool, it's being set. And if we open the Logcat, we can see onActivityResult is called, then received an activity result from photo request. So if there was something wrong, that's where you'd start. You'd make sure you were received the incoming intent and then go from there. Now let's click Save. Now rerun the app to make sure that it's saved. Click Login, go to Settings, and there is our image. Now let's work on getting an image from the camera. Open PhotoFragment and scroll down to the openCamera method. Here we're using another intent to start the camera, but notice we specify an output Uri on the intent before we start it. This will be the OutputUri of the new image after it's captured. Then we use startActivityForResult. Scroll down to onActivityForResult. This method will trigger when a new image is captured from the camera. We then use the same process as in GalleryFragment to set the result and then finish the activity. The only difference here is we attach a different intent extra key. This one is named intent_new_camera_photo. Then finish. Now go back to SettingsFragment. We need to do the exact same thing as when we're retrieving an image from the phone's memory, but reference a different intent extra key. So copy the logic and then add an else and paste. Then change the intent name to the correct one, intent_new_camera_photo. Copy that and paste it here and there. That's it. Let's test. Login, go to Settings, click the image, open the camera, take a photo. This UI might be different on your camera. But for me, all I need to do is click the checkmark now. And then we can see that the image is set. Now click Save. Rerun the app to make sure that it saved. Login, go to Settings, and there is our image. So everything is working as we expect.

Module Review
Let's quickly review everything covered in the module. We started by taking a look at the layout and widgets involved in implementing tabs. We had the ViewPager widget acting as a container for the tabs and a TabLayout for actually holding the tabs themselves. Remember the tabs are fragments hosted on ChoosePhotoActivity, and to use the fragments, we need a fragment container. To manage the tabs, we created a new class named MyPagerAdapter. MyPagerAdapter extends the FragmentPagerAdapter class. Don't get this confused with the FragmentStatePagerAdapter class. The StatePagerAdapter is used when you have a lot of fragments to manage. The PagerAdapter is used when you have five or less fragments to manage. It's best to use for things like tabs because the fragments will not be destroyed. In ChoosePhotoActivity, we created the MyPagerAdapter class, then added GalleryFragment and PhotoFragment to the adapter. We then set the adapter to the ViewPager and then finally set up the TabLayout. At that point, the tabs are ready to go and we could use them, but we had no way of retrieving the new image selected from a gallery or taken using the camera. For that we used setResult and passed the image URLs as intent extras. The image selected from the gallery had a result that looked like this, getActivity. setResult NEW_PHOTO_REQUEST, then getActivity. getIntent putExtra and then reference the intent_new_gallery_photo and then pass the SelectedImage, then getActivity and finish to finish the activity. And the image taken from the camera had a result that looked like this. The same thing, except the intent was changed to intent_new_camera_photo, and the image URL variable was saved as mOutputUri. Then the same thing, getActivity and finish the activity. The only real difference here is the intent extra key. One says intent_new_gallery_photo, and the other one says intent_new_camera_photo. That's how we differentiate between which one we're receiving in the onActivityResult method in SettingsFragment. In SettingsFragment, the onActivityResult method looked like this. First, we checked to make sure the requestCode matches the NEW_PHOTO_REQUEST, then make sure the incoming data is not null, then check to see if the data hasExtras. So all we need to do is check for the individual intent keys. It's either intent_new_gallery_photo or intent_new_camera_photo. Then we set the image for either situation. And of course, we need to save a pointer to the image so it can be saved in SharedPreferences. Here's a map of the entire process. The user has a choice of either taking a new photo with the phone's camera using PhotoFragment or choosing one from the phone's memory using GalleryFragment. Once they have the new image, the image URL is set to an intent extra using the setResult method. The intent key for the image from the gallery is intent_new_gallery_photo, and the intent key for the image from the camera is intent_new_camera_photo. ChoosePhotoActivity is finished, and the intent extra is sent to SettingsFragment. The OnActivityResult method in SettingsFragment captures the new image URL and takes the necessary actions. That's it. In the next module, we're going to do a quick review of everything covered in the course.

Tying It All Together
Tying It All Together
You reached the end. Hopefully this course was as much fun for you to watch as it was for me to make. Let's quickly talk about everything we covered in each module to help give you a birds eye view of everything. First, we talked about all the different types of navigation we'd be covering in the course. There's activity navigation, fragment navigation, alert dialogs, navigation views like the bottom navigation bar, tabs, and navigation drawers. In the prerequisites clip, I mentioned the course will have a ton of bonus content and will absolutely packed with value. I talked about my goals and how you'll be able to come back to this course and still learn things later on. Hopefully I delivered on that, and you feel like this course was valuable. I mentioned the extra dependencies we'd need for the course. They were the RecyclerView support library for implementing recycler views, the Design support library for CoordinatorLayouts and consequent toolbars and other widgets it supports, the support CardView library, an open-source library for displaying circular ImageView widgets, an open-source library that allows each integration of a heart-shaped Like button just like Twitter uses, the Glide library for setting image resources to widgets, and an open-source library for a NavigationView. Remember if you want to dig deeper into these libraries, just Google them and take a look at their documentation. The first type of navigation we looked at was navigating with activities. Activity navigation is the simplest, but it's also the most limited. All we need to do to navigate to a new active is create an intent object and then you startActivity to pass the intent. Unlike fragments, there can only be one activity open at a time. Next we talked about alert dialogs. Alert dialogs aren't exactly a type of navigation. I'd call them more of a pseudo-navigation. We used an alert dialog to display a message to the user when they open the app for the first time. Making alert dialogs are relatively straightforward. You just declare an AlertDialog. Builder object, set some properties, and then set the Builder to an AlertDialog object and show it. The next type of navigation we looked at was navigating using fragments. There are many ways to navigate with fragments, but at the core they all share similarities. For example, all fragments must have a container and a host activity. Fragments can't stand alone. They don't even have their own context. They inherit their context from their host activity. So the first step in using fragments to navigate your app is to define a container for them to live in. There's a few different types of containers, but in this part of the course, we looked at FrameLayouts. Once a container was defined in a host activity, we could start doing fragment transactions and inflating our fragments. At this point in the course, we hadn't implemented our custom backstack yet, so the transactions looked like this. We would declare the fragment, declare the fragment transaction, replace it with the previous container, then pass the fragment and the fragment tag, and then add it to the backstack and commit the transaction. We were using the replace method to swap out the respective fragments and then into the container. As you now know, this method of transacting fragments has many flaws. The backstack is far from ideal, and the fragments are destroyed when they're replaced in the container. Later in this course, we worked on resolving these shortcomings by managing our own backstack and creating global fragments that are not destroyed. In this part of the course, we also talked about sending data to fragments. You need to build a bundle object and set arguments to it. Remember if you want to attach custom-built data structures like we did, we need to implement parcelable on your object class and then use the putParcelable method call on the bundle arguments. All fragment-to-fragment communication is done through the host activity and almost never done between fragments. We implemented an interface class called IMainActivity that handled all our fragment communication. The interface was implemented in MainActivity. We used it to send user objects to the ViewProfileFragment, we used it used it to send message objects to MessageFragment, and we used it to implement the back navigation on the back arrows in some of our fragments. Next we worked on implementing a navigation view. Instead of using the default NavigationView support library, we used an open-source library called BottomNavigationViewEX. The library makes it easy to customize a bottom navigation view, and although we didn't explore its functionality very much in the course, I encourage you to take a look at the GitHub page and explore the different features. Much like anything else, using a navigation view starts with adding a widget to the layout. Then to define items in the view, you need to build a custom menu. Our menu looked like this. We had three items, each with an individual ID and an icon. Then you set the menu to the bottom_navigation_view like this. To capture when the user clicks on the navigation, we implemented the BottomNavigationViewEX. onNavigationItemSelectedListener interface. Then we wrote a switch statement in MainActivity to take action when the items were clicked. At this point, we added SavedConnections fragment and MessagesFragment and wrote fragment transactions for them in the NavigationView interface. Next we worked on setting up the navigation drawer. Like the NavigationView, this process started with adding the proper layouts and widgets to activity_main. By the time we added everything, activity_main looked like this. There's a DrawerLayout and a NavigationView that implements the actual drawer function of the layout. We built a custom layout for the drawer and named it layout_nav_header and of course a menu to define the items in the drawer. It was named navigation_drawer_items. Inflating fragments from the drawer is very similar to inflating fragments using the bottom navigation view. The override method is the same, but the interface is different. The interface is named NavigationView onNavigationItemSelectedListener. We implemented that in MainActivity and added three new cases to the switch statement, home, settings, and agreement. Fragments are great. And for the most part, they're my favorite way to navigate an app, but there are many shortcomings. For example, default backstack navigation system is far from perfect. In the course, I showed you many examples of why. As the course went on, we addressed those shortcomings and implemented our own backstack. The first problem was that fragments were being destroyed. That was solved by defining the fragments in MainActivity as global and saving them in an ArrayList named mFragments. The next problem was that fragment back navigation was not following an ideal path. For example, if you had three fragments, fragment A, fragment B, and fragment C, and those fragments were on the bottom navigation bar, if you navigated from A to B to C and then to B again, then pressed back four times, the back navigation would follow that exact same path. That obviously doesn't make much sense and yields a poor user experience. They shouldn't see fragment B twice when navigating back. It should go like this, B, C, A. The second visit to B should be removed. This was actually a really easy fix. Every time we navigated forward, if the fragment was already in the backstack, we removed the old one and then put the new one on top. And thanks to how the methods work in the ArrayList data structure, that was easily accomplished with using. remove and. add. So at that point, our data structure was correct, that is our back navigation data structure was right and our backstack was right, but the back button needed to be overridden so we could write custom logic to use our custom backstack. So we overrode the back button, disabled the default behavior, and wrote logic to fit our needs. If the backstack had more than one entry, we removed the current entry on the top and then set the fragment second from the top as visible. To set the fragment visibilities, we built a method that loops through all fragments in the stack and then hides every one that isn't on the top. The fragment at the top is set to visible. The final module was all about the implementation of tabs. Implementing tabs is a pretty straightforward process. We just needed to add a ViewPager widget to the host activity and a TabLayout. Like all fragments, fragments used for tabs must live in a container. In this case, the ViewPager is the container. But unlike most fragments, tabs require a special adapter class to manage them. We built a class named MyPagerAdapter that did just that. We extended the class with FragmentPagerAdapter, making sure to not confuse is with FragmentStatePagerAdapter, which is not for tabs. Tab fragments are kept in memory, and the StatePagerAdapter will destory fragments when they're not in view. MyPagerAdapter is very simple. It had a method for holding a list of fragments, a method for retrieving the fragment items, a method for getting the number of fragments saved in a list, a method for adding fragments to the list, and a default constructor. We finalized the tab setup by building a method named setupViewPager. Inside, we instantiated the Fragment objects, added them to the adapter, set the adapter to the ViewPager, then set up the TabLayout. The last thing we did was retrieve the image URLs from the Gallery and PhotoFragment. We retrieved them using the onActivityResult override method in SettingsActivity. When the images were retrieved, we used Glide to set them and saved the URL to SharedPreferences. Effective navigation is absolutely fundamental to every Android application. Back navigation is especially difficult to master because, as you've seen, the default methods are often not enough to provide a seamless user experience. Now that we've taken a closer look at some real situations and examples, you have all the necessary tools to tackle any new problems you're likely to encounter. I hope this course you helped you develop a superior understanding of effective navigation with Android. If you enjoyed the course and thought it provided a lot of value, please leave a rating on Pluralsight. I would really appreciate that from you. And don't forget to send me a tweet and say hi afterwards so I can thank you. My name is Mitch Tabian, and thanks for watching.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Beginner
Rating
4.7 stars with 27 raters(27)
My rating
null stars

Duration
2h 42m
Released
16 Feb 2018
Share course