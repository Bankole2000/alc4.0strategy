Android Security: Effective Permission Handling
by Nitin Singh

Permissions play a key role in guarding user privacy and data for Android apps. This course will give you a deep understanding of how permissions work, how to request permissions, and how to avoid accidental data leaks when using permissions.

All Android apps need access to user data and device features that are protected by permissions. Having a good understanding of Android's permission model can be the difference between creating an app that users can trust and one which they consider malicious and uninstall. In this course, Android Security: Effective Permission Handling, you will gain an in-depth understanding of Android's permission model, allowing you to create permission experiences that ensure your app gets access to all the data and device features it needs. First, you will learn the internal workings of Android's permission model and some of the key attributes of a permission. Next, you will explore how to create great user experiences while requesting the system for a permission, ensuring the user can make an informed decision. Finally, you will discover how to guard your app's data and features when exposing them to other apps so as to prevent accidental data leaks. When you are finished with this course, you will have a well-rounded understanding of how permissions work on Android.

Course author
Author: Nitin Singh	
Nitin Singh
Nitin is an Android / iOS developer with over 6 years of experience developing world class apps and SDKs that are used and loved by millions of users. He currently leads the Mobile team at Razorpay...

Course info
Level
Intermediate
Rating
0 stars with 3 raters
My rating
null stars

Duration
0h 59m
Released
18 Oct 2018
Share course

Course Overview
Course Overview
Hi everyone. My name is Nitin, and welcome to my course, Android Security: Effective Permission Handling. I'm an Android tech lead at Razorpay. Permission model is the primary mechanism which guards user data and key device sensors from apps on Android devices. Needless to say, virtually all apps need to interact with it. In this course, we are going to learn how permissions work, how to request for permissions, and how to avoid accidental data leaks when using permissions. Some of the major topics that we will cover include how to specify a permission and the key attributes of a permission, creating great user experiences while requesting the system for a permission, how to create custom permissions, and guarding your app's data and features exposed to other apps using permissions. By the end of this course, you will have a very well-rounded understanding of how permissions work and the techniques you can use to significantly boost user trust in your app, thus increasing your app's chances of getting a permission from the user. I hope you will join me on this journey to learn Android security with the Android Security: Effective Permission Handling course, at Pluralsight.

Understanding Androidâ€™s Permission Model
Overview
Hey guys. This is Nitin. Welcome to Android Security course on the effective permission handling. This is the first module, Understanding Android's Permission Model. We will begin by understanding why platforms like Android need a robust permission model in place. After that, we'll jump straight into implementation so that you can start adding permissions in a correct manner to your app. We will take each of these permissions and analyze which protection level they belong to and how that impacts the permission's behavior. Then we will understand what different type of permission requests are and how they are presented to users. Also, we will see how concepts like permission groups impact the user behavior when interacting with a permission. And finally, we will see which use cases in your app absolutely require you to ask users for permissions and which can be fulfilled by alternating means like finding intents.

The Need for a Robust Permission Model
To understand why Android needs a robust permission model, let's first see what does the permission model exactly protect. The permission model essentially protects two type of data, one is users stored data like contacts and pictures and second is access to device features like GPS and camera, which can generate sensitive user data. With that in mind, let's try to understand the goals of android's permission model. The first and foremost goal of Android's permission model is to protect the privacy of the user. It does so by putting users in control of the data and devices such that the users have absolute control over what data can be accessed by each app. At the same time, it enabled valid use cases for applications by showing a system controlled consistent UI so that users feel confident while providing apps access to their data. Now that we understand the why, what, and how of Android's permission model, let's go over some key concepts that we will be learning over this module, which are absolutely required to gain an in-depth understanding of Android's permission model. They are specifying permissions correctly, understanding permission protection levels and their behavior, different ways of presenting permissions to users, understanding permission groups and their behavior, and last, but not the least, identifying necessary permissions for your application's specific use cases. To solidify our understanding of these concepts, we will be developing a chat application over the course of this module. To begin with, it will be a text-only chat application, which by the end of this course will be converted into a full-fledge modern multimedia chat application. This will obviously require a lot of interaction with the permission model as a lot of sensitive user data will be accessed. This is the project that I've created for our chat application called Pluralchat. Let's run and see what it currently looks like. This is what the chat application currently looks like. Here is a screen listing your recent chats, and if you tap on one of them, it will show the messages exchanged. As told earlier, it currently only supports exchange of text messages. Over the period of this course, we'll be adding multimedia capability to this app while exploring Android's permission model. In the next clip, we'll learn how to add the camera permission to this app.

How to Specify Permissions Correctly
Now that we have an in-depth understanding of why the permission model is needed from the previous section, let's see how we can specify permissions that our app needs. Permissions are added to an app by specifying the user's permission tag in the application's manifest file. This should be added directly under the manifest tag. This is the only way to specify permissions and new permissions can be added programmatically. The users permission tag has two attributes. The name attribute is mandatory and it is a string representing the permission name either specified by Android or an application in case of custom permissions. The maxSdkVersion attribute is optional and it is used when a permission that your app request is no longer needed beginning at a certain API level. By specifying this attribute, you tell the system, do not go until you have the permission when turning on a device about the max is the conversion. Now that we understand how to use the users permission tag, there are two major caveats that you should be aware of. The first one is an Android optimization called Automatic Permission Adjustments. The way it works is that whenever a newer version of Android adds permission restrictions around a feature that previously didn't need it, Android auto-adds the new permission to apps using that feature so that they don't start breaking on newer devices. Now this is good, but Google Play filters apps based on what permissions they need. So your app might get filtered out on devices running the newer Android version because of a permission that you didn't even specify. The solution is simple, always keep your apps targetSdkVersion as the latest table Android API level and this target instead. The second caveat becomes evident when your app uses permissions that need hardware features which might not be present on all Android devices. The problem is that Google Play assumes that since your app has a permission that needs a hardware feature, it should filter it out on devices that does not have that feature. Now this might not be the case for your app. To avoid this behavior, you should use the users-feature tag to specify whether the presence of a hardware feature is mandatory for your app or not, and if it is not, then you should handle the feature absence gracefully in code. With these things in mind, we can begin adding permissions in our app, but if you ever have to check what permissions an app needs, there are two other ways to it if you don't have access to its manifest file. The first one is straightforward and does not require any tools. You just find the app in the settings app and all permissions specified in the manifest will be listed here. The second way is to use the ADB command-line tool proved with Android SDK and fire the ADB dumpsys command. This will print out all the permissions specified in the manifest and whether they're currently granted or not. Now, let's go back to our chat application and give it the capability to access device camera by adding the camera permission. Post that, we will see all available permissions for our chat application using the command-line ADB tool. To add the camera permission, we would first go to the apps manifest file in our project. As you can see over here, the manifest already has the permission for internet connectivity, so let's add the camera permission below it like this. We will assume that having access to camera is optional feature for our app, and to indicate that, we will add the users feature tag for camera with required attribute set as false like this. This will ensure that our app runs just fine on devices which don't have a camera and won't be filtered out by Google Play. Now let's open the command line to see how we can use the ADB command to list all the permissions for our app. Here is what the command looks like, and on running it, you can see it lists all the permissions specified in our manifest in the requested permissions section. In the next section, we will see how permission protection level works and how they behave.

Permission Protection Levels
Android segregates permissions into different protection levels and each protection level behaves differently. A permission's protection level determines whether an explicit user consent is required or not. There are four permission protection levels specified, normal permissions, dangerous permissions, signature permissions, and special permission. Let's go over them one by one to understand the differences between them. Normal permissions are for accessing device features that have low risk to user's privacy in other apps. As these are low risk, they are auto-granted at install time and no user interaction is needed. For instance, permission to access internet is a normal permission as it doesn't access any user data stored on device or any sensitive device features. The second permission type is dangerous permissions. These are used for accessing user's data or sensitive device features. Granting these permissions require explicit consent from user for each permission. To get consent, the system shows a dialog either at install or runtime depending on Android version where the user has the option to grant or deny the permission. A good example of this is the camera permission. Normal permissions and dangerous permissions are the ones most commonly used by apps. The third permission type is signature permissions. These are only used for custom permissions defined by a developer who has multiple apps and need to share data between them. If a device already has an app installed from a developer and another app from the same developer it installed that requires a signature permission, the permission gets auto-granted at install time without user interaction, but this will only be done if both the apps are signed using the same certificate. The fourth and least commonly used permission type is special permission. These should rarely be used by apps and mostly they're to be used by system maps. These permissions protect features that can impact the user's entire experience across apps on a device. These are accessed by finding predefined system intents and the system shows a detailed feature management screen to the user to ensure the user understands what the app is asking for. An example of this is the WRITE_SETTINGS permission that can be used to change the device settings. Let's now jump back to our demo chat application and add a normal and a dangerous permission to see how they behave when we try to access features that are protected by them. Let's go to the manifest file and here you can see that the internet permission, which is a normal permission, has already been added earlier. Now let's add a dangerous permission for reading SMS like so. As you can see, there is no difference in the way a normal and dangerous permission is listed in the manifest. The real difference is in the way those permissions are presented to the users. This is what we will be covering in the next section.

How Permissions Are Presented to Users
There are different ways in which permissions are presented to users for interacting with the permission model. As you might remember from the last section, only dangerous permissions like accessing camera need user interaction. Now the way permission requests behave was changed drastically in Android 6. 0. Before Android 6. 0, we had something called install-time requests, and on Android 6. 0 and above, we have runtime requests. Let's understand the differences between them and explore why such a drastic change was made to the permission model in Android 6. 0. Install-time requests were used below Android 6. 0 that is below API level 23. The way they worked were that the system would show a prompt as shown in the screenshot here. At the time of installation of the app, this prompt would list all the permissions that the app needs and their descriptions and the user could choose to accept or deny. If the user chooses the deny option, the app does not get installed. Also, if a later app update adds extra permissions, the same prompt listing the additional permissions is shown during the app update. Now there are some obvious problems with this model. The biggest one is user doesn't have any situational context as to why the app might be asking for a particular permission that does not immediately make sense. Also, the user does not have any flexibility as its options are binary, accept, or deny. What if the user is okay giving some of the permissions, but not all. What this led to was like the infamous terms and agreement checkbox on websites where people started blindly accepting install-time requests as the only alternative was not being able to use the app at all. This was obviously not a good situation. To solve this, Android 6. 0, that is API level 23, introduced runtime permission requests. The way they worked was that the users don't get any permission-related prompt at install time, but as and when an app tries to access an android API that is protected by a permission, the app can request a system for that permission and the system will show a prompt similar to the one shown in the screenshot here asking the user for consent for that specific permission. The user has the option to allow or deny the request and the app can handle the lack of the permission gracefully. If an app asks for a permission for a second time, then a never show again option is also shown by the system for all future requests so that users can prevent apps from nagging them for permissions. This model solves the context problem as the app gets a chance to provide the context to the user before asking for permission. Also, the user gets to use an app even if he wants to grant at least some permissions and not all. Now, let's go back to our chat application and add another dangerous permission and see how the behavior differs on below Android 6. 0 and above. Let's add the READ_CONTACTS permission to our app's manifest and change the targetSdkVersion to 22. Now we'll run the app, and after installation on the emulator, we'll run our ADB command to see the status of permissions. The installation for the app is done. Now let's run our ADB command to see what the status of permissions is. As you can see, all the permissions that are listed in the manifest have been granted to the app. This is because we were running on targetSdkVersion below 23, which means all permissions are granted at install time itself. Now let's change the targetSdkVersion to 26 and run the app again. Let's run the ADB command again to see the status of the permissions. As you can see, only the internet permission, which is a normal permission, has been granted. To get the dangerous permissions, we would have to ask the system specifically for it. Let's do that in the onResume of the ChatListActivity. Here we are adding a function that requests the system for the contacts permission. We will call this function from the onResume of the ChatListActivity. Now let's run and see the output. As you can see here, the system shows a prompt asking for users consent for the contacts permission. The user can either allow or deny. Let's deny it this time. As you can see here, the next time the don't ask again option is made available so that apps cannot nag users for permissions. This time, let's allow it. Now let's run the ADB command to see the status of permissions for our app. As you can see here, now our app has the READ_CONTACTS permission. In the next section, we'll see how the permission grouping impacts handling of permission requests.

Permission Groups
Now that we understand how runtime permission requests work from the previous section, let's see how permission groups affect user interaction with permission requests. Before we get to that, we need to first understand why and how permissions are grouped. Multiple permissions are grouped under a single permission group to allow users to make more meaningful choices. For instance, the permission group for SMS has read and receive SMS permissions among others. It's easier for a user to make decision when an app asks permission for its SMS data as compared to an app asking for receive or read SMS permission, not to mention, asking user individually for each permission in a group can overwhelm the user. So Android groups multiple permissions into one group based on device features and capabilities. While requesting user for permission, the system dialog always shows the permission group rather than the individual permission to make it easy for users to come to a decision, but be careful, as this does not mean that requesting for a permission in a group grants your app permission to the whole group. The system always grants individual permission and never the whole group. A good example of a permission group is the SMS permission group which contains READ_SMS, RECEIVE_SMS, SEND_SMS, among other permissions. Now let's understand how this grouping of permissions impact how permission requests are handled by the system. So when your app fires a request for a permission, the system checks whether your app has any permission from the group already granted. If no permission from the group is already granted, the system shows a dialog asking the user to grant permission mentioning the permission group, but granting only the permission requested for if the user chooses to accept the permission request. On the other hand, if your app already has a permission from the group granted earlier, the system immediately grants the current permission request without asking the user. Even though this behavior might make you think that once you get one permission in a group, you can assume you will always automatically get the rest of them be one as future versions of Android can change this grouping any time. So you shouldn't base your app's logic on the structure of the permission groups. Now in going back to our demo chat application, we will see this behavior in action by adding and granting the READ_SMS permission to our app and see how the subsequent RECEIVE_SMS permission request is impacted by this. As you can see, the READ_SMS permission is already present in our app's manifest. Let's use the ADB command line tool to see if the permission is granted or not. As you can see, the read SMS position is already granted to our app. Now let's try to add the RECEIVE_SMS permission to our app too and see if the fact that our app has already the READ_SMS permission and that READ_SMS and RECEIVE_SMS belong to the same group has any impact on the RECEIVE_SMS permission. The behavior expected is that RECEIVE_SMS permission will not be granted as permissions are always granted on a per permission basis and not for the whole group. The app has finished installation and let's run the command. As you can see, only the READ_SMS permission is granted and not the RECEIVE_SMS, even though they belong to the same group. This was the expected behavior. In the next section, we'll learn how to identify permissions that your app absolutely needs from the ones that it can substitute with alternative mechanisms like finding intents.

Identifying Necessary Permissions
Before integrating a permission into your app, it is always a good idea to think whether your app needs the permission at all or can you complete the use case in some other way, thus side-stepping, asking permissions completely. Let's see what are our options when trying to perform a task that's guarded by permissions. The first option should always be to delegate the task to another app which is better suited to do the job using an intent. If that's not optimal for your app's use case, then you should consider adding a permission to your app and integrating with the permission model. Here is the comparison of both the approaches and when to use which. If you choose to use intents, you don't have to design the UI for the operations as opposed to using permission requests. This saves a lot of time spent coding a task that would have been easier to delegate to another app. Also, if you choose to delegate it, then the user is free to choose the app of his choice to perform the task, as well as being limited by your app's UI. However, if you need absolute control over the UX for the feature of showing the dialog every time the user wants to use the feature is not ideal, then you might want to consider permission requests. So intent is ideal in the case where the task can be performed where widely used are system apps that are specialized in that particular operation and the task is not central to your app's experience, however, if what the task achieves is critical for your app and you need full control, use permission requests. The whole idea is to ask as few permissions as possible so as not to overwhelm the user while at the same time not compromising on the user experience in your app. To solidify an understanding, here are two use cases. The first use case is that a chat application needs access to camera to click a picture. Now integrating camera functionality in your app is non-trivial and taking pictures is something that more specialized apps like the default camera app can do much better. So intent should be the tool of choice here. Whereas, if you're creating a photo editing app, then having access to camera is so critical to your app that you would want absolute control over the experience. Here, asking user for permission for camera makes a lot more sense and the user is much more inclined to provide your app the permission as the use case is very clear. So let's go back to our chat application demo and replace the camera permission added earlier with an intent to take picture. Let's remove the camera permission from our app and replace it with a take picture intent for that will go to the manifest and remove the camera permission from there. Also, we'll go to the message list activity and add a function there which can fire the action image capture intent. This will be called from the onClick of a button that we have added to the MessageListActivity. Let's run and see what it looks like. This is what the MessageListActivity looks like and this is the button next to the send button, which is for taking pictures. Let's click on it and see what happens. It takes us to the default camera app by firing the intent, and since this is the only app installed on the phone, it directly opens. As you can see, we have replaced the need for the camera permission completely with an intent and the experience is seamless for the user. This is the perfect example of a permission that could be replaced with an intent. So with that, we have covered all the key concepts relating to Android's permission model. Let's do a quick recap. We now understand what the permission model protects and why it's so important for data and user security on android. We also know how to add permissions to our app correctly, the different protection levels those permissions belong to, and how each of those impact user experience. We understand the major shift in Android permission model that happened with Android 6. 0 and how permission request interaction changed because of that in permission groups. Last, but not the least, we now have a framework to figure out when to ask a user for permissions and when to use intent to achieve the same goal without degrading user experience. With this understanding of Android's permission model, in the next module, we will learn how to build great user experiences when asking for user permissions so that your users have complete confidence in your app and your app always gets the permissions it needs. See you there. Thank you.

Building Great Experiences When Asking for User Permissions
Overview
Hey guys. This is Nitin. Welcome to Android Security course on effective permission handling. This module is about building great experiences when asking for permissions. We will start off by understanding why we need to build great permission experiences and some best practices around permission request handling where we'll then start understanding the mechanics of how to check the status of a permission to determine if a permission prompt needs to be shown to the user, and if so, how to prompt the user correctly for permission. We will finish off this module by learning how to provide explanation when showing a permission request to boost user confidence in your app.

Importance of Building Great Permission Experiences
Let's start by understanding why building great permission experiences is so important for your app. We will only be focusing on runtime permission requests and not install-time permission requests in this module as install-time requests are shown by the system and your app has absolutely no control over their user experience. Also, this affects only apps targeting Android 6. 0 and above as runtime permission requests are only available from that version onwards and the only way to ask permissions for apps targeting those devices is runtime requests and it has to be done for every permission that your app needs. This change from install time to runtime permission requests has huge impacts on user behavior. The user expects permissions to be asked in the right context, and if not, they can deny it, which means your app can no longer provide the functionality that needs the permission. Also, since runtime requests are made for each individual permission, the user can choose to deny some permissions and grant some. This flexibility for the user means your app can't assume that it will get all permissions once installed. Moreover, since your app needs to request and hence show a prompt to the user for each permission, it increases the transactional burden for the user and they might get annoyed if these prompts are not tied into the user experience for your app correctly. Not only users have more control over what permissions to grant in app, they're more cautious too as there is very sensitive user data present on more than smartphones like contacts, messages, photos, emails, and some of the sensors like microphone and GPS capture, even more sensitive data. The consequences of handling permission requests poorly are huge for your app. At best, the user can deny the permission if it's presented in the wrong context or if your app is asking too many permissions, which mean you can no longer provide user with the functionality that's guarded by the permission and you could lose your competitive edge. At worst, the user will simply uninstall an app if he's annoyed by poorly-handled permission requests and assumes that your app is malicious and is stealing their data. Let's go back to our chat application demo where we will introduce a new permission for location access and we will be using this permission as an example of how to build great experiences around permission requests in this module. So here is the project for our chat application. The functionality that we want to add to a chat application is to enable a user to send his location. For that, we'll go to the Android manifest and add the entry for find location permission. After this, we'll go to the ChatListActivity class and add a function which requests the system for the fine location permission. We'll call this function from the onResume of ChatListActivity. Now let's run and see what the screen looks like. This is what the ChatListActivity currently looks like. As you can see, the ChatListActivity is asking the system for the location permission for our app. Let's allow it for now. In the next clip, we'll learn the best practices we should keep in mind when designing user experience for permission requests.

App Permission Best Practices
Let's explore the best practices around app permissions so that your app has a high chance of getting the permission it needs granted by the user. This is what a typical flow for adding a permission to your app looks like. You determine whether or not your app needs a permission. If it's needed, you declare the permission by listing it in the manifest. And finally, you ask the user for the permission at runtime. This last step is where we will mostly focus as this is the tricky bit and has many open questions around it like how do you correctly prompt the user for permission and when should we prompt. The goal of these best practices is to ensure that you implement the permission experience in a way that builds user confidence so that your app gets the permissions it requests for. Here are the six best practices for permission requests, avoid unnecessary permissions, make permission access explicit, know permissions needed by the libraries that your app is using, don't overwhelm the user with permissions, be transparent with the users, and use the support library for backward compatibility. Let's now explore these one by one to understand what they really mean. Avoid unnecessary permissions by using mechanisms like intent wherever possible to minimize the number of permissions needed by your app. If your app asks for fewer permissions, users are more likely to grant them. Know the permissions needed by libraries that your app is using as their permissions are now part of your app's permissions and this can quickly bloat up the number of permissions needed by your app. As a rule of thumb, select libraries that need minimum permissions. Be transparent with the users and always provide an explanation of why a permission is needed before asking for it does help the user make a more informed decision. This is especially helpful if you think the purpose of a permission might not be immediately obvious to the user. Make permission access explicit and provide continuous indications like persistent notifications when continually accessing features like microphone. This will boost user confidence in your app. Don't overwhelm the user by asking multiple permissions one after the other. This will most likely result in an app uninstall as the user would get annoyed. Always ask permissions in the right context. Let's go back to a chat application demo now to see which of these permission-based practices are we violating and to see if we are using the support library for permissions specific calls. Earlier, we had added the capability to request for location from our ChatListActivity. Let's run it again and see which of the best practices is the current experience for the location permission while waiting. As you can see, this is a pretty jarring experience for the user as it's not immediately obvious to him why a chat app would need location permission. Also, we are not providing any explanation to the user and we are asking for the permission outside of any relevant context. One good thing though, is, as you can see, we are using the support library and using ActivityCompat instead of activity to request the permission. This ensures backward compatibility. Over the course of this module, we will fix this user experience issues with the location permission. In the next clip, we will first see how to check for the current stages of a permission before prompting the user for it.

How to Check a Permission's Status
Before your app prompts the user for permission, it needs to check the current status of the permission. Your app should do this check every single time it tries to access a functionality guarded by the permission as the user can revoke a permission that was granted earlier by going to app Settings. It's important to understand that just because your app was granted permission, you cannot assume it will always have that permission from that point onwards. To check for the current status of a permission, you use the checkSelfPermission method defined in the Context class. It returns immediately with the status of the permission and it can be one of PERMISSION_GRANTED or PERMISSION_DENIED. This is what a code snippet that checks for the status of the location permission looks like. If the status returned is not equal to permission granted, an app doesn't have the permission, else it does. Let's go to our chat application demo and add a proper status check for the location permission that we added earlier. Let's go to the ChatListActivity to see how the location permission request is being invoked. As you can see, we are not checking for the current status of the location permission before prompting the user for it. Let's add a check here to ensure we are invoking the permission request only when the permission is in the denied state. After adding this check, there won't be any unnecessary invocations for the permission request if the user has already granted the permission to our app. In the next clip, we will see how to receive the user selection in a callback from the prompt shown for a permission.

How to Prompt for a Permission
Once you determine that your app does not have the permission granted, you need to prompt the user for the permission. To request a permission from the user, first determine the appropriate interaction point at which you would like to show the prompt to the user. The prompt can be shown using the requestPermission method on Activity class. The result of the user selection is delivered in the origin onRequestPermissionResult method in the activity. Let's see what the flow for a permission prompt looks like for different situations. First, you check if your app already has the permission granted. If yes, then proceed ahead with the operation. If no, then request for the permission by calling requestPermission method. If your app has previously asked the user for the permission and the user has selected the never ask again option, while denying it, your app will immediately receive the denied status in the onRequestPermissionResult callback. Otherwise, the system shows the prompt to the user and the user selection is returned in the onRequestPermissionResult callback later. Here is a code snippet that shows how to prompt the user for permission using the ActivityCompat. requestPermission method. This method needs three parameters, the context of the current activity, a string array representing the permissions being requested, and the request code which will be returned in the callback. The purpose of the request code is to identify for which permission request the callback is being thrown. And here is a code snippet that shows how to listen for the user selection result in the onRequestPermissionResult callback. The callback provides three parameters, the requestCode which was supplied during the requestPermission method call, the permissions for which the result is being delivered, and the grantResults array carrying the granted denied status for each permission as selected by the user. If the grantResults array has 0 length, it means the user cancelled the request by pressing back on the prompt. Let's go back to a chat application demo and move the prompt for location permission to a better context and implement the callback for handling user selection on the prompt. As discussed earlier, the way the app is currently prompting for the location permission does not provide the user any context on why it's asking for it. To fix it, we will remove the location permission request from the onResume of the ChatListActivity and we will move it into the onClick of the sendLocation button inside the MessageListActivity. Let's run and see how the message screen activity looks like. This is what the screen looks like, and when the user tries to send his location, and if the app does not have the permission for location, it prompts the user in the right context. Now let's add the callback where the MessageListActivity we will receive on user selection on the location permission dialog. That's it. With this change, the MessageListActivity will be notified whenever the user makes a selection for the location prompt. In the next clip, we will see how we can further enhance the experience around the location permission so that the user can make a fully informed decision for the location permission.

Providing an Explanation for a Permission Request
One of the most important best practice for handling permissions is to provide an explanation for the permission to the user before asking for it. So when should you provide explanation to the user? Providing the explanation for a permission is always a good idea if the use case for a permission is not immediately obvious like a chat application asking for the location permission. An explanation should also be shown if the use case is obvious, but the user has denied an earlier permission request. One obvious solution to provide an explanation for a permission is to always show a dialog explaining why a permission is needed before prompting the user for it. The advantage of that is that the user will understand the context for each permission, but on the downside, this might lead to too many dialogs being shown to the user which can get annoying pretty fast. The recommended solution is to explain a permission to the user only if the user has already denied it once. To help with this, Android provides a helper method called shouldShowRequestPermissionRationale on the Activity class. You can call this helper method to determine if an explanation should be shown to the user or not and it returns a Boolean indicating the same. This is how the helper method behaves. If the user has never denied the permission in the past, it returns false. If the user has denied the permission in the past, it checks whether the user had selected never ask again while denying the permission, if yes, false is returned, if no, it returns true. Whenever true is returned, we can show the explanation, and when false is returned, we should not show the explanation. Here is the final code snippet for the location permission that shows all the steps that should be done when dealing with a permission. First, check the status of the permission. If not granted, see if an explanation should be shown to the user. If needed, show the explanation. If the explanation is not needed, show the permission prompt. Finally, if the permission is already granted, just proceed with the operation. Let's head back to a chat application and add an explanation for the location permission. To add an explanation for the location permission, we will modify the requestLocationPermission method inside the MessageListActivity. We don't do anything if the location permission is already granted. If not, we check whether the user should be shown the permission explanation by using the shouldShowRequestPermissionRationale method. If it returns true, we should show the permission explanation in a dialog, and if not, we just ask the system for the location permission. Let's run and see how the app behaves. When we click the sendLocation button for the first time, the app shows no explanation dialog and the location prompt is directly displayed. However, if we deny it the first time and try clicking on send location again, you can see that the shouldShowRequestPermissionRationale method returns true and we are presented with the explanation dialog. If the user chooses OK on the explanation dialog, only then we'll request the system for the location permission. As you can see, our send location feature has come very far from the initial version and it has a much better user experience allowing the user to take a completely informed decision on whether or not to provide our app with location permission. Needless to say, with this flow, the likelihood of a user granting the permission is very high. With this, we have covered all the topics on how to build great experiences when asking for user permissions. Let's do a quick recap. We learned how the new runtime permission request model impact user behavior and how serious the consequences of poorly-handled permission requests can be. We learned the best practices for handling permissions and then used those to check for a permission status, to show a permission prompt to the user, and to provide an explanation before asking a permission from the user. Be careful with these. You can be confident that your app will get all the permissions it needs granted by the user. In the next module, we will learn how to implement robust permission enforcement when interacting with other apps so that your app doesn't accidentally leak data to other apps. See you there. Thank you.

Robust Permission Enforcement When Interacting with Other Apps
Overview
Hey guys. This is Nitin. Welcome to Android Security course on effective permission handling. This module is about Robust Permission Enforcement when Interacting with Other Apps. To understand how to build robust permission enforcement for your app, we would first need to understand how to define custom permissions. We will then see how permissions can be used to protect the functionality and data provided by activity, service, broadcast, and content provider competence of your app. Finally, we'll explore the different ways of checking what permissions are granted to an app by using its package name and process id. Understanding these concepts will enable you to correctly guard the features and data owned by your app when your app is interacting with other apps and avoid any accidental data leaks.

Defining Custom App Permissions
Let's first understand when and how to define custom permissions that are specific to your app. Permissions in Android are not only for requesting system functionality or guarding resources owned by the system, but the system also allows apps to define custom permissions that the app can enforce while sharing its resources and capabilities with other apps. This way, third-party apps can leverage the checks and balances built into the Android permission model for their specific use cases. To declare a custom permission, you add a permission tag in the manifest file for the app as shown here. There are various attributes that are to be defined with the permission tag. We will explore these one by one so that when you define a custom permission, you know exactly what you're doing. The name attribute specifies the name of the permission. This is the name that other apps will include in the user's permission tag when they want to access a permission guarded functionality in your app. Be careful while picking this name as it should not collide with the permission name defined by other apps. To avoid collision with custom permissions defined by other apps, prefix the name with reverse domain name for your app. In case of a permission name collision, the system disallows installation of subsequent packages unless they are signed by the same certificate. Permission label attribute specifies the name of the permission as shown to the end user by the system in the app settings or in the permission prompt dialog in case of dangerous permissions. Though the system allows this to be an in-place hardcoded string, it's best to put this in the strings. xml file and support localization for this. Permission description attribute specifies the description for the permission that is to be shown to the end user. It's usually longer and more detailed than the label attribute. Also, the system does not allow this to be hardcoded and it must be a string resource with support for localization. The permissionGroup attribute declares the permission group in which your custom permission belongs and you can define a custom permission group for your app by using the permission-group tag. If this is not set, the permission does not belong to any group. And finally, the permission protectionLevel attribute declares what protection level to assign the permission. It can be one of normal, dangerous, or signature depending on sensitivity of the data or functionality that this permission will be guarding. This indicates the sensitivity of resources protected and how the system should handle the permission request. Here are some best practices around custom permissions when you have multiple apps that might be installed on a device. Declare a permission only once even if all the apps in the suite that you are deploying use the same signature. Although, for apps, I'm using the same certificate, the system won't have issues with permission name conflicts, it's still a best practice to declare it only once. Also, if all the apps in your app suite will be signed using the same certificate, it's better to use signature checks when making interapp calls rather than defining custom permissions. As the app being called can always verify that the caller is a trusted app based on its signature and defining of permission is redundant in this case. These are some of the components in your app that can be protected using custom permissions, activity, service, broadcast, content provider, and IPC communication. Now let's go back to a chat application and define a custom permission to launch messaging screen for a user directly. This is our chat application project. Let's go to the manifest and define a custom permission called MESSAGE_USER. This permission will be needed by other apps when they want to send a message to a user via our chat app. For this, we will have to add the permission to the manifest file under a permission tag. This is what the tag looks like. As you can see, both the label and description are string resources and the protection level for the permission is normal. In the next clip, we will see how we can enforce this custom permission for other apps who want to open the message activity of our app.

Activity and Service Permission Enforcement
Let's explore how to enforce permissions for interacting with an activity or a service in an app. The goal of permission enforcement for an activity is to prevent the activity from being open by other apps that don't have the permissions mandated by the activity. The required permission is declared by using the android:permission attribute on the activity tag manifest. The check of the permission is performed by the system during startActivity and startActivityForResult calls and if the caller is missing the permission, a security exception is thrown instead of starting the activity. Here is a code snippet that shows how a custom permission is associated with an activity in manifest. Similarly, permission enforcement for a service protects the service from being used by apps that don't have the permissions mandated by the service. The required permission is again defined by using the android:permission attribute on the service tag in manifest. The checks for the permission are performed by the system during startService, stopService, and bindService calls and not having the required permission results in the security exception. Here is a code snippet that shows how a custom permission is attached to a service and manifest. Now let's go back to a chat application and infuse the custom permission we defined earlier for the message activity and see the change in behavior of the startActivity method when called for the message activity. Let's go ahead and add the permission attribute for the MESSAGE_USER permission to the MessageListActivity in the manifest. This is what the activity tag with the permission looks like. Now we are in another app which as you can see does not have the message_user permission in its manifest. Let's see what happens when we try to fire up the message screen from this app. Let's try clicking on this button and see what happens. As you can see, the message screen is not displayed. Now let's add the message_user permission to this app and see how the behavior changes. Let's try clicking the button again and see what happens. As you can see, on clicking the button, the message screen opens up. In the next clip, we will see how permissions can be enforced for broadcasts.

Broadcast Permission Enforcement
Broadcasts carry sensitive information in a lot of cases, so let's see how permission enforcement can be done for broadcasts. Broadcasts can be restricted by specifying a permission while sending or receiving the broadcast. You can send a broadcast with certain permissions required by the receiver or receive a broadcast only if the sender had certain permissions. Both sending and receiving restrictions can be applied too, in which case, both of the checks should pass for a broadcast to be successfully received. To send a broadcast with permission, you specify the permission as a string parameter in the sendBroadcast method. To receive such a broadcast, the receiving app must have declared the permission in its manifest and it should have been granted the permission by the user if it's a dangerous permission. Both system and custom permissions can be used while sending broadcasts. Here is a code snippet that shows this in action where a broadcast is being sent such that only apps that have the SEND_SMS permission can receive it. To receive a broadcast with permissions, you can either specify the permission to be enforced in registerReceiver call, or if the permission is declared in manifest, the permission attribute can be used. If the sending app does not have the permission required by the receiver, the intent won't be delivered. Here is a code snippet showing a receiver tag and manifest with a SEND_SMS permission required and here is the same thing being accomplished using the registerReceiver programmatic method. Since the purpose of broadcast usually is to pass around data, here are some security best practices around broadcasts. Use LocalBroadcast whenever possible to avoid other apps from listening to the broadcast in the first place. If you have to send a normal broadcast, protect them by specifying permissions correctly. Also, while the distributing broadcast receivers limit your apps exposure by specifying necessary permissions for your app to be able to receive only the broadcasts that it cares for. Let's go back to a chat application demo and add a broadcast sender and receiver and observe change in their behavior when they are guarded by a permission. We have defined a broadcast receiver in our app that allows other apps to update a user status and which enforces the MESSAGE_USER permission. On receiving the broadcast, it displays it to us saying the user status update is received. Let's fire up our broadcast for the receiver defined in our chat app from another app, which does not have this permission and see what happens. As you can see, on clicking the button, no toast is displayed. Now let's add the MESSAGE_USER permission to this other app. Let's try clicking the button again, and as you can see, the status update toast is displayed, which means the receiver got the broadcast this time. In the next clip, we will see how to protect a content provider with permissions.

Content Provider Permission Enforcement
The whole idea of a content provider is to act as a data store that's usually exposed to all apps. Hence, permission enforcement for a content provider is almost always mandatory. Permissions protect the retrieval of the content provider itself and also both the read and write operations on the content provider. The goal of defining permissions on a content provider is to prevent it from being accessed by apps which don't have the permissions mandated by the content provider. If you want to protect both the read and write operations on a content provider using a permission, define it using the android:permission attribute on the provider tag on the manifest. If you just want to guard the read operations, use the android:readPermission attribute, and if you just want to guard the write operations, use the android:writePermission attribute. The following functions are protected by permissions on the content provider. The query method is protected by the read permission and the update and delete methods are protected by the write permission. Let's go back to our chat application once again and see how the contacts content provider, which holds the contact list of our chat app, can be protected using custom permissions. We have a chat contacts provider defined in our app, but currently, it's not being protected by permissions. To enforce permissions for it, we will define two permissions, one for reading and one for writing. Now let's associate these with the content provider. As you can see now, the content provider is enforcing these permissions and anyone who wishes to access the content provider would need the relevant permission. In the next clip, we will learn how to check whether or not another app that's interacting with that app has a specific permission granted to it or not.

Checking Permissions for a Process
Checking for permissions for a process is a key step in guiding your app against unauthorized access. Let's see what are some of the use cases when you need to do these checks. In case of inter-process communication using say bound services, you need to check whether the process from which the method is being called has a specific permission needed for the method or not. Similarly, you might need to check if another app has a permission based on its package name in certain use cases. And finally, you might need to check permissions for your own app from outside activity contacts say from a service. Here are the different ways in which these tasks can be performed. Context. checkCalling Permission method is used in case of inter-process communication to determine whether the calling app has a specific permission granted or not. Context. checkPermission method can be used by your app to determine status of a permission outside an activity, and if you want to check the status of a permission for any app given its package name, you can use the PackageManager's checkPermission method. Of all these methods, it's important to understand the checkCallingPermission method, which is used when dealing with inter-process communication between apps as the usual security of Android's permission model is not available during inter-process communication and it's your app's responsibility to correctly check the permission for the process from which your app's methods are being called. This method is only meant for inter-process communication and will fail if used outside an inter-process call. Always use this method instead of checkCallingOrSelfPermission method as the checkCallingOrSelfPermission method returns true for a permission. If your app has the permission, but the app calling your inter-process method doesn't, this will lead to your app accidentally leaking user data to another app which didn't have the permission for it. Let's go back to our chat application to see how we can leverage these permission check methods to prevent accidental data leaks. Let's go back to our BroadcastReceiver, and as you can see, any app that has the permission for the broadcast can update the user status. What if we want to enforce that the app should not only have the permission to fire the broadcast, but also say the WRITE_CHAT_CONTACTS permission for this. To do this, we will use the PackageManager's checkPermission method and check the permission status for the WRITE_CHAT_CONTACTS permission for the app fighting the broadcast. If it has the permission, a toast with true will be displayed, else a toast with message false will be displayed. Now let's go back to the app fighting the broadcast and see what happens when the broadcast is fired. As you can see, a toast with false is being displayed as the app does not have the WRITE_CHAT_CONTACTS permission. Let's add the permission to the app and now try again. Let's try clicking the button again and see what happens. As you can see on fighting the broadcast, true is now being displayed, which means our receiver is checking correctly for the status of the WRITE_CHAT_CONTACTS permission for this app. Without this check, any app could have updated the user's contact status without even having the WRITE_CHAT_CONTACTS permission. With this, we have covered all the concepts you need to understand to enforce permissions properly for your app so that you can be sure that your app's functionalities and data are secure, even when it's interacting with other apps. Let's do a quick recap so that the concepts really stick. We learned how to define a custom permission, and then using that permission to guard components like activity, service, broadcast, and content provider in our app. We also learned how to check permissions for any process in different scenarios and how to prevent accidental data leaks during inter-process communication. Our chat application has come a long way from its humble beginnings and it now has a rock-solid integration with Android's permission model. Using the learnings in this course, I hope that you can boost user confidence in your app by applying the best practices for both UX and security around permissions, which will make your users love your app even more. Hope you enjoyed learning from this course as much as I did in creating it. Thank you.

Course author
Author: Nitin Singh	
Nitin Singh
Nitin is an Android / iOS developer with over 6 years of experience developing world class apps and SDKs that are used and loved by millions of users. He currently leads the Mobile team at Razorpay...

Course info
Level
Intermediate
Rating
0 stars with 3 raters
My rating
null stars

Duration
0h 59m
Released
18 Oct 2018
Share course

