Android Apps with Kotlin: Notifications and App Widgets
by Brendan Wanlass

Notifications and app widgets are the best ways to present timely information to your users. This course will teach you how to build notifications in a variety of styles and train you how to build app widgets that communicate with your app.

Surfacing important data to your users is critical for a user-friendly app. In this course, Android Apps with Kotlin: Notifications and App Widgets, you will learn the essential skills needed to create Android notifications and home screen app widgets. First, you will learn how to create a basic notification using Android Studio and Android's notification framework. Next, you will discover how to launch your app from a notification and present the users with a specific activity. Then, you will explore a variety of notification styles suitable for many different use cases. Finally, you will see how to provide your users with convenient data and controls right on the Android home screen with home screen app widgets. When you're finished with this course, you will have the skills and knowledge required to keep your users up to date and engaged with timely notifications and convenient app widgets.

Course author
Author: Brendan Wanlass	
Brendan Wanlass
Brendan is an Android and game developer. He has a passion for well designed, engaging software. He was a designer and engineer for the game Magnetic by Nature...

Course info
Level
Beginner
Rating
0 stars with 3 raters
My rating
null stars

Duration
1h 28m
Released
11 Oct 2018
Share course

Course Overview
Course Overview
Hi everyone, my name is Brendan Wanlass, and welcome to my course: Android Apps with Kotlin: Notifications and App Widgets. I'm the Android architect at SoFi, a finance tech company. I've worked as a professional Android developer at small startups and large multi-national corporations. I have a passion for Android development and love helping others to explore the exciting platform. Notifications and app widgets are essential parts of today's best apps. This course is part of the Android Apps with Kotlin learning path, and we'll cover everything you need to know to get started with notifications and home screen widgets. Some of the major topics that we will cover include Android notifications with Kotlin, starting activities with notifications, styling notifications, and home screen widgets with Kotlin. By the end of this course, you'll know how to take your app's functionality outside the normal app confines and into the Android home screen and status bar with engaging notifications and home screen widgets. From here, continue your learning by completing the Android Apps with Kotlin learning path, and check out courses on cloud messaging with Firebase. I hope you'll join me on this journey to learn how to create notifications and widgets with my course: Android Apps with Kotlin: Notifications and App Widgets, at Pluralsight.

Getting Started
Getting Started
Hi, I'm Brendan Wanlass, and welcome to my course: Android Apps with Kotlin: Notifications and App Widgets. Android provides some great ways for you to keep your users informed about important events and communications. You can provide convenient actions outside of the normal app flow with notifications and app widgets. In this course, we'll explore the basics, and learn how to add these important features to your app. Notifications are the premier way to communicate important events or alerts to your users. A notification is a message that the Android OS can display outside of your app's normal UI flow. Users can tap on a notification to open your app, or reply to messages directly from the notification. By providing timely information to your users, they will stay up to date and engaged with your app. Notifications are supported on phones, tablets, and wear devices, such as smart watches. After completing this course, you'll be able to present users with notifications and all of their favorite devices. Notifications can go beyond simple text messages. You can enhance your user's experience by supporting text messaging with direct reply functionality. Sharing and receiving images can be more comfortable with image previews. Managing emails can be less burdensome by providing a snapshot of the user's inbox, and controlling media right from a notification, even on the lock screen, is what users look for in great media apps. We'll cover how notifications have evolved across various versions of Android, enabling you to make informed decisions about your designs. We'll learn about notification channels, and how to support users in defining how their notifications should behave. We'll learn how to start your app when a user taps on a notification, and how to deep link into a specific activity within your app so that users get a comfortable and convenient navigation experience. In order to learn the basics of Android notifications, we'll be adding some new functionality to the NoteKeeper app that we've been building throughout the Android apps with Kotlin learning path. We'll add a reminder notification to the NoteKeeper app that users can utilize to send themselves a notification reminding them to review a particular note. We will then take the basic notification and change it to use different notification styles. We'll cover styles such as big picture style for showing image previews right in the notification, and messaging style, for showing a conversation and direct replay field. We'll see how these styles behave and look across various versions of Android. By the end of the course, you'll have a variety of tools to create the perfect notification for your app. This course will set you up to be successful with larger tasks, such as implementing a push notification feature into your app. After gaining a good foundational knowledge of Android notifications, you'll be ready to incorporate cloud messaging services such as Firebase to add communication functionality to your project. Android home screen widgets are a great feature for taking some of your app's functionality and putting it right at a user's fingertips. Many of the best apps have companion home screen widgets that can be placed on the home screen and resized to suit the user's preference. By placing your apps widget on the home screen, users will have a constant view into your app's most important data, and be able to interact with the key features seamlessly. We will create an app widget for the NoteKeeper app that will allow users to see their list of notes right from the home screen. They will be able to jump directly to the desired note, and if they add a new note, the list will update immediately. In this course, we will cover Android notifications with Kotlin. We will learn how to keep users engaged and informed by showing helpful notifications. We will use Android Studio on Kotlin to create notifications that are supported across various versions of Android. We'll learn how to start activities with notifications. We will learn how to bring users back into the app with a smooth navigation experience by deep linking to specific activities with synthetic back stacks. We will learn how to use pending intents to delay actions for a later time. We'll learn how to style notifications. We'll explore various notification styles that can be used to meet the different needs of your apps. We will learn how to display long text, image previews, and message inboxes. We will discover how the direct reply action can let users respond to messages right from a notification for a less intrusive and more convenient experience. We'll learn how to create home screen widgets with Kotlin. We'll learn how to create robust home screen widgets that can display app data, stay fresh and up to date, and even get users back into the app with deep linking. To succeed in this course, I recommend having a basic knowledge of developing apps in Android Studio with Kotlin. If you've already built apps before, you'll be fine to jump right into this course. If not, I recommend completing all the courses in the Android Apps with Kotlin learning path leading up to this one, or at the very least completing Android Apps with Kotlin: Building Your First App, Android Apps with Kotlin: Tools and Testing, Android Apps with Kotlin: Resources, Styles, and Themes; and Android Apps with Kotlin: RecyclerView and Navigation Drawer. These courses will give you a foundational knowledge required to learn the concepts in this course. The tools we'll be using in this course include Android Studio. You'll be okay with Android Studio 3. 1 or newer, but I recommend Android Studio 3. 2 or newer. That way you'll have full support for Android Pie. We'll be using Kotlin 1. 2 or newer, and we'll be targeting API 21 or newer. By the end of this course, you'll be able to bring your app outside the normal app UI confines. You'll be able to engage users with notifications and widgets that have slick controls and provide convenient and timely communication, so let's get started.

Android Notifications with Kotlin
Android Notifications with Kotlin
Hi, I'm Brendan Wanlass, and welcome to Android Notifications with Kotlin, where we'll learn about Android's powerful notification framework. By the end of this module, you'll have a good understanding of what the notification framework can do, and you'll e able to implement a simple notification using Kotlin. First, we'll get an introduction to notifications. We'll talk about their basic functionality and why they're useful. Then, we'll jump into Android Studio and add a reminder notification to our NoteKeeper app. We'll see how Android Studio can help us to quickly set up the scaffolding for creating simple notifications. We'll break down the various parts of a basic notification and learn how to use them correctly. We'll explore a newer feature on Android, notification actions. We'll learn how to use these convenient controls to make your app more engaging. We'll learn about a new feature in Android 8, notification channels. We'll discover how this feature can give users great control of how notifications are presented. Finally, we'll learn how to start up the app when a user taps on a notification. Let's get started. Notifications are an important part of app development and the user's experience. Notifications are a fantastic way to keep users engaged and up to date. As you become comfortable using Android's powerful notification framework, you'll discover all kinds of great users for notifications. So let's get started with the basics. Here we have the Android home screen on an Android 8 or Oreo device. At the very top of the screen, we have a section with many small icons. This is called the status bar. The icons on the left hand side of the status bar are notification icons. They represent various notifications that we've received for different apps on the device. If we swipe down from the top of the screen, we'll open the notification drawer. This drawer provides a convenient way to view and interact with notifications. Here we have a basic text message notification. We can expand or collapse the text message. We can slide it slightly to the side to get additional options. If we click the Settings button, we can enable or disable notifications from this channel, as well as navigate to more settings. We can snooze this notification so that we can come back to it later, and it won't clutter up our drawer in the meantime. We can reply to the message right here from the notification drawer, and we can dismiss the notification. Starting in Android 8, app icons can have an additional badge which represents the presence of a notification. This is a great visual way to tell users that something needs their attention without being too invasive. Also new in Android 8, users can long press an app icon and see the notifications for that app. Users can dismiss or act on notifications from that menu similar to the notification drawer. Beginning in Android 5, notifications can briefly appear in a floating window called a heads up notification. This behavior is normally for important notifications that the user should know about immediately, and will only appear if the device is unlocked. This notification will disappear after a moment, but will remain in the notification drawer as usual. This notification type became especially useful in Android 7 with the addition of quick reply action, allowing the users to reply to a message or enter a text directly in a notification. Notifications have evolved quite a bit over the years with each new release of the Android OS. Look at the text message from Android 5 compared to the text message from Android 7. Notice how the text message from Android 7 provides additional information, as well as some quick actions. Notice how the CLEAR ALL button used to be an icon and now it has text. It may seem daunting to support all these different iterations on notifications across versions of Android, but luckily the notification framework makes it easy. Later on, we'll dive into exactly what you need to do to support older versions of Android, while still taking advantage of the latest and greatest for newer devices. Notifications are useful in many ways. Some of which include calls to action. You may have an app that notifies you a bill is due or that something is on sale. Status updates. If you purchase something online, an app can let you know that your package has shipped. Communication. Perhaps the most common use, you can get notifications when friends and family send you messages. Alerts. You can get a notification that someone is at your door, or that your device is low on battery. App controls. It has become common to use the notification drawer as a way to surface controls for apps. Think of your favorite music or audio player. Oftentimes the app will show pause, play, and volume buttons as a persistent notification. With the advent of smart home devices and advanced web services, notifications have become more useful and timely than ever before. Consider a smart doorbell. When someone is at your door, a smart device can trigger a notification right on your phone. This is convenient and provides more safety to your home. Next let's jump into Android Studio and create our very first notification.

Creating a Notification
Android has a robust notification framework that helps us display notifications in a non-intrusive and convenient way. It is important to learn the capabilities of the framework so that you know what tools you have at your disposal when building your app. Let's jump into Android Studio and add a notification to our NoteKeeper app. If you haven't already, go ahead and download the project from the exercise file section for this course. Open up the project in Android Studio and follow along. Here we are in Android Studio. I'm going to go ahead and fire up the app. As you follow along, use an emulator with Android 7. Later we'll talk about how we can support Android 8 and higher versions. Now this is the NoteKeeper app that we've been building throughout this learn path. It's a simple app for taking notes. You could put in a couple of data fields and save them to the device. What we want to do is create a reminder functionality so that you can set yourself a reminder to review the note. Going to the top menu bar in Android Studio, go ahead and click File, New, and scroll down to UI Component, and click Notification. This will bring up a new dialog in Android Studio with a few fields. This tool will create a basic notification builder class for us. For Class Name, let's use ReminderNotification. Select None for Style when Expanded. We just want a basic notification for now. Deselect Show Additional Actions, and click Next. Here we can choose the icon that will appear for our notification. Go ahead and choose this clipboard. This looks like a suitable icon for our notification, and click Finish. Android Studio will then create a Java file called ReminderNotification. java, and then it will convert that Java file to Kotlin, since we chose Kotlin as our language. This file will contain all the methods and code we need to start creating basic notifications. Android Studio might then ask you what to do with some variables as part of that conversion process. You can go ahead and click Refactor, and here we see our ReminderNotification class that was generated by Android Studio. If you scroll down a little bit, you'll find a method called notify. We can call this method to fire off a notification. Scrolling down near the bottom of the file, you'll see another notify method that's private. The other notify method calls this private notify method to actually fire off the notification using NotificationManager. Android Studio lays these methods out like this so that we can use this annotation here. We'll talk more about that later, but for now, let's try calling the notify method and see what happens. To do that, we need to wire up a button in our app. Open up your project explorer, and go to the resources folder, Go to menu, and open up menu_note. xml. This menu file declares the menu items and our note activity. Let's add another menu item that will fire off a notification. First, let's pick an icon for our new menu item. In the resources folder, right-click on the drawables folder and select New, Vector Asset, click the Clip Art button, and begin searching for notification. This bell icon will do nicely. Select that, and change the color to white. Change the name of the icon accordingly, and click Next, then Finish. Now that we have our notification icon, we can add our menu item. It's good practice to provide a proper title whenever you have a button in your app. That way, accessibility tools can know what your button is called. Now that we have our new menu item, go to the NoteActivity class, and find the onOptionsItemSelected method. We will add an action for when our new menu item is clicked. We can reference our ReminderNotification class, and call the notify method. We'll talk more about the parameters shortly, so for now, just pass Reminder as the string and notePosition for the number. Let's launch the app and try this out. We can navigate to a note, and we see our new notification menu item. When we click on it, we see a notification pops into the status bar. When we open the notification drawer, we can see our new notification. This notification has placeholder icons and text. Next, let's break down each part of a basic notification and learn how to set its values to something more suitable for our app.

Notification Anatomy
We're going to break down the anatomy of a notification. Understanding what each part does and how you can change it will help you make appropriate notifications for your app. Here we see we've received a text message in our notification drawer. Taking a closer look, first we have the small icon. This is the same icon that appears in the status bar, although it may be a different color. This is the icon that identifies your app. You want to make sure it follows material design guidelines for clarity and legibility. Users should be able to identify your app with just a glance. This element is required and can be set in code with setSmallIcon. Next, we have the app name element. This name is populated automatically by the system, and is pulled right from your app, so you don't need to worry about setting it. Next, we have the time stamp. This is typically provided by the system so that users know when this notification was received. You can override the default value with your own time stamp using setWhen. You can also hide the time stamp with setShowWhen(false). Next we have the large icon. This element is most commonly used to display a context, profile picture, and a messaging notification. Google has informed developers that it is inappropriate to use your app logo or icon in this element. This element should be used only to provide additional info or context for a notification. This element is optional, and can be set with setLargeIcon. Next, we have the Title element. This element can be useful to give users a quick idea of what the notification is about, or who the notification is from. This element is optional and can be set with setContentTitle. Next, we have the Text element. This is typically where you put the main body text of the notification. This optional and can be set with setContentText. Finally, we have Notification actions. These are meant to be used as quick, convenient actions that provide concise functionality. We'll learn more about action buttons later in this module. So now that we've seen the basic anatomy of a notification, let's jump back into Android Studio and update our app to use more appropriate values. This is the class we created with the Android Studio and new component tool. This is the class that we used to create notifications. Looking at the top, we see object ReminderNotification. You might have expected this to be a class ReminderNotification, but in this case, we want it to be an object. An object is a type of class that has some special functionality. It's a kind of singleton or static object, which means that there is only one instance of ReminderNotification in the project at any given time, and we can reference it from anywhere in the project. This kind of a class will be perfect for creating notifications from anywhere in the app. Moving down a little bit, we have private val NOTIFICATION_TAG, with a value of Reminder. This unique identifier is used by the notification framework to keep track of our notification. If we want to update or cancel our notification later, we'll need to reference it using this tag. You'll notice a squiggly line under NOTIFICATION_TAG. If we mouse over it, it says Might be 'const. ' This is just a suggestion from the linter in Android Studio. If you click on this field, and then press Alt+Enter on your keyboard, a little menu with some recommended actions will appear. Let's select the top action, which recommends that we make this field a constant. This is correct because this field isn't going to be changing. Scrolling down a little more, we see some comments with suggestions for things that we can update or change. Let's go ahead and delete those. In here we see the notify method. This is the method we call whenever we want to create a notification. It has a few parameters here. Let's update them to match our needs. First, let's add an additional string called titleText. This way, we can define the titleText for our notification. Next, let's change the example string to noteText. This will be the body text of our notification. We could remove this code that's grabbing a picture resource, because we're not going to be setting a large icon for now. We can also remove these default strings because we'll be passing in our own strings whenever we create a notification; and finally, let's get rid of this reference to resources. Moving on, we see several more methods as a part of this builder. We'll leave the default value for notification light, sound, and vibration. We already chose a small icon so we can leave that as it is, and here we can update the title and body text with the values we're passing. We'll leave the notification priority to default, let's delete the method for setting the large icons, as we won't be using it, setTicker was used in older versions of Android to display some marquee text, but it is now used for accessibility. So let's populate it with our title string so that accessibility readers can know what our notification is about. We're not going to be stacking this notification, so let's remove setNumber. We could remove this block of comments that talks about setting the timestamp. Next, we see setContentIntent. This tells the notification builder what intent we want to start when a user taps on the notification. Let's leave it for now, but we'll come back to it later. Finally, we see setAutoCancel with true. This tells the builder that when a user taps the notification, it will automatically be dismissed. Now that we've set up our notification to use appropriate values, let's go to our note activity. Let's update our method call to provide both Reminder as the title, and the title of the note for the notification body text. Let's use a string resource to append the word, review, in front of the notes title. Jump to the strings. xml, delete the placeholder text that was generated when we created our notification reminder class, and add our string resource with the word Review, followed by %1$s. Back in our note activity, we can call getString, referencing our reminder_body string resource, and we can pass the title of the note as a second parameter. This will replace that %1$s with a note title, and concatenate it with the rest of our string resource. Let's launch the app and try this out. We can go to a note and tap the reminder icon. This creates a notification, and looking at the notification, we can see the title, Reminder, and the body, review, with the notes title. So we've learned that based on our app's needs, we can customize the simple notification to display relevant text and icons. Next, let's take a look at how we can add a useful action to our notification.

Notification Actions
Notification actions provide a convenient way for users to complete quick tasks right from a notification. Here we see a text message where we can mark the notification as read, and starting in Android 7, replay to the message inline directly from the notification itself. If we tap the Replay button, a text message field appears, along with a Send button. We can type in our response and send it here. If we tap the main body of the notification, we're taken to a messaging app, and we can see that our response was sent. Now let's jump into Android Studio and add a notification action to our NoteKeeper app. Remember that our NoteKeeper app can create a notification reminder that we can see on our device. But what if we want to share that reminder with a friend? A notification action will be a great place for that functionality. In the reminder notification class, we can continue adding to our notification builder. We can use the addAction method to add an action to our notifications. The addAction method takes in a drawable as an action icon. In Android 7, the displaying of these icons was discontinued; however, you should still provide an icon, as it will be used in older versions of Android, as well as on wearable devices. We can also use icons in media style notifications, which we'll talk about more later. Next, we provide a string. This is the string that will be displayed to the user on the notification. The last parameter is an intent. Let's create an intent that will let the user choose an app to share the reminder. Scroll up above our notification builder, and create a pending intent. We will go into more detail about pending intents in the next module, but for now just know that it's a special intent that can be fired off at a later time. Call PendingIntent. getActivity, provide a context, and for request code you can just use a 0 for now. Next, we will create the intent that we want to launch when a user taps the share button. Use Intent. createChooser. This will allow the user to select a suitable app for sharing a text message. Then pass an intent with ACTION_SEND as the action. Set the type to plain text, and add an extra, which will contain our reminder. Provide a reasonable title so the user knows what they're sharing, and finally, pass PendingIntent. FLAG_UPDATE_CURRENT. We'll go more into detail on what this flag does in the next module. Now that we have an intent, let's pass it to the notification builder's addAction method, launch the app, create a notification reminder, and there we'll see our new notification action. When we tap the action button, an app chooser dialog appears. We can choose a messaging app, and our message is populated with the reminder text. We've been running our app on an Android 7 emulator. If we launch our app from an Android 8 emulator and try to create a notification reminder, nothing happens. This is because of a new feature in Android 8 called notification channels. Next, we'll learn about this new feature, and how to make sure your notifications display correctly, as well as provide some great functionality to users.

Notification Channels
Notification channels are a brand new feature in Android 8. This feature provides a way for the app developer and the user to come to a compromise on how invasive notifications should be. The notification framework has evolved over time, and as a result, the appearance and functionality of notifications has changed as well. Later on, we'll look at how specific notification types have changed, and how to support newer notification types on older Android versions. Notification channels being added in Android 8 is an example of an impactful change to this framework. It is important to keep in mind that the landscape for Android development has changed a lot over the years. When you search on the internet for information about a specific Android topic, try limiting your search range to the last year or two. This will typically give you more relevant search results that will help you to develop your app using the most modern techniques and APIs. If you want to get an idea of how notifications have changed over the years, the Google developer page is a great resource. It will break down exactly when certain features were added or changed over the various Android versions. Notification channels were introduced in Android 8. If your app is targeting SDK 26 or higher, you must set one or more notification channels in your app. Otherwise, you notifications will not appear and an error will be logged. If your app is targeting an SDK prior to 26, you don't need to set a notification channel. Your notifications will behave as they did prior to Android 8. The notification channel essentially groups notifications from a given app so that they can be given individual specific settings. These channel settings can be set by the app, but are user-managed after that point. A user can go in and change specific channel settings to their liking. Let's jump into Android Studio, and add notification channel support to our NoteKeeper app. Navigate to the app's build. gradle file. In the default config section, we see our targetSdkVersion as 27. We are targeting Android O, so our notifications won't appear on an Android O, or 8 device, because we haven't registered a notification channel yet. We see that our minSdkVersion is 25. That's why we've been able to run our app on an Android 7 emulator. The notifications show up fine on the Android 7 device, because channels didn't exist yet for that SDK, so they're simply ignored. If we launch our app on an Android 8 device without registering a notification channel, when we try to create a notification, it does not work. Let's go to the reminder notification class and define a channel for our notifications. Notice that the builder method on NotificationCompat has a line through it. This means that the method is deprecated. If a method is deprecated, that means that in some future version of the SDK, the method will be removed and replaced by a newer version. If you are ever using a method that is deprecated, you should consider using the updated version of that method. Let's see what our options are for NotificationCompat. Builder. To jump to the source of a method, you can Command+click on MAC, or CTRL+click on Windows, on the method name. Do this on the method you wish to jump to. When we jump to the Builder method, we see that the method is annotated with Deprecated. In the comments, it tells us what method to use instead. In this case, it's still called NotificationCompat. Builder, but there's an additional parameter, a string. If we scroll up a little bit, we can see this new method. The string is called channelId, and is used for NotificationChannel. We can use this parameter to define a channel for our notifications. Let's go back to our reminder notification class and define a string for our new channel. Then, let's pass the string as a second parameter to the NotificationCompat. Builder method. You can see that the strikethrough line goes away now that we're using a non-deprecated method. Now that we are passing a channel ID to our notification builder, we need to register our channel with the notification service. Jump to the items activity, which is our main activity. Let's create a new method called registerNotificationChannel. We will call this method from the activity's onCreate method. First, let's check to see if the device is running Android O or higher. If so, we will grab a reference to NOTIFICATION_SERVICE as NotificationManager. Then, we will create a new notification channel. For the first parameter, pass the same notification channel ID from our ReminderNotification class. Next, pass in a title. This is what the user will see. Finally, you can use the default importance for this channel. We'll talk more about that in a minute. After we have our channel, we can call createNotificationChannel on our NotificationManager, passing in our new channel. Now that we have registered our channel, let's fire up the app and try it out. We can create a new notification, and see that it appears in the status bar as expected. Now let's see how the user can manage the notification channels for the app. Here we have our app icon. If we long press it, we get a popup menu with a button for App info. If we press that button, we are taken to the app setting page in the Android system. Note, you're not responsible for creating this settings flow, this is part of the Android system. If we click the App notifications button, we are taken to another settings page specific to notifications. We can see a categories area that lists out all the notification channels for our app. We just have one for now, Note Reminders. We can toggle this channel on and off right here on this page, which would enable or disable this kind of notification from appearing to the user. If we tap on Note Reminders, we are taken to a settings page that is specific to the Note Reminders channel. Here we see various settings that the user can override to their liking. For example, if the user would like to have the phone vibrate when this kind of notification is received, you could enable that here. If we tap on Importance, we can change the importance level of this kind of notification. It's currently set to Urgent, which will cause a heads-up notification and make a sound. If the user would like a less intrusive alert, they can set this to one of the other importance levels here. Going back to the notification settings page for this notification channel, we see that the user can override do not disturb. If the user feels that this kind of notification is very important and would like to receive alerts even in do not disturb mode, they can set that here. A user can put their device into do not disturb mode by pressing a volume button on the device, and dragging the ring slider all the way to the left. This UI may look different on different versions of Android. So you can see that users have very fine grain control over how their notifications are displayed and how they are alerted. Next we'll learn how to launch the app when a user taps on a notification.

Starting the App from a Notification
Perhaps the most common action when a user taps on a notification is to launch the app from which it originated. Let's learn how to do that using our notification builder. If we create a notification in our NoteKeeper app and then tap on it, a browser appears and attempts to navigate to Google. com. This isn't quite the behavior a user might expect after looking at our notification. This is the default functionality that is provided when we generated our ReminderNotification class. Here you can see that similar to our notification action, we have a pending intent. This allows us to save an intent for later, and fire it when a user taps on a notification. We will go into detail with pending intents in the next module, but for now, let's simply swap out this default intent that is taking us to a URL, for an intent which will launch our main activity. Now we can create a notification, and even if the app isn't running, we can tap on that notification, and it will take us to our main activity. This behavior is much more in line with what a user might expect. In this module, we got an introduction to basic notifications and some of their common applications. We learned that notifications can meet a variety of needs from communications to alerts, to app controls. We learned how notification builder can be used to quickly make your app more visible to users by creating a basic notification using Android's notification framework. We learned about the various parts of a basic notification, and how they can be customized to make the perfect notification for your app. We explored notification actions and learned how they can be utilized to give your notifications additional convenient functionality, such as sharing content or replying to messages. We set up our app to support notification channels, a new feature in Android 8 that allows users to have great control over how and when notifications are presented. Finally, we learned how to start the app when a user taps on a notification, which will bring users back to the app for additional engagement. Next, we will learn a variety of ways to start activities from notifications. We will cover deep linking, and learn how to create an appropriate back stack so that user navigation feels natural.

Starting Activities with Notifications
Starting Activities with Notifications
Hi, I'm Brendan Wanlass, and welcome to Starting Activities with Notifications, where we will learn how to create an appropriate navigation experience for users interacting with our notifications. We'll get started by learning about deep linking, which is a technique that helps users to get a better context as they navigate to your app from links and notifications. We'll learn about the back stack, and why it is important to simulate a proper back stack when deep linking into your app's various activities. Then we'll cover pending intents. Pending intents are a special kind of intent that we can use with notifications and that will help us set up deep linking. Finally, we'll learn the difference between special and regular activities, which can both be started by a pending intent. We'll see how each one should handle navigation and how they are useful in different situations. When a user taps on a notification, the most basic way to handle navigation is to open up the app to its default or activity home screen. However, it is often more useful and convenient to skip over the home screen and open up an activity within your app that is related to the notification. For example, if we receive a text message and tap on it, we can open up to a conversation with that person within the chat app. This concept of navigating the user to a specific activity within the app is called deep linking. You are linking the user to your app, but instead of just dropping them on the home screen, you go deeper into the app to a specific activity. Let's jump into Android Studio and add deep linking to our NoteKeeper app. Let's launch the app and create a notification. Close the app and then tap on the notification. We are taken to the main activity. This is a good start, but it would be more convenient to add deep linking to take the user right to the note to which the notification corresponds. Go to the ReminderNotification class. This is the class that we created in the previous module, which allows us to create notifications. Let's jump to the notify method. Let's create an intent to fire up our note activity. We can add the notePosition to the intent as an extra. Let's rename the last parameter in the notify method to notePosition. Switching over to our note activity, we are passing notePosition as the last parameter, where we call the notify method. Back in the ReminderNotification activity, we can scroll down to where we are calling setContentIntent. Instead of using an intent to start ItemsActivity, let's pass the new intent we created. Now, let's launch the app. We can create a notification like before and close the app, but now when we tap on the notification, we are taken directly to the note activity. We've added deep linking to our reminder notifications, but when we navigate back, we are taken out of the app. It would feel more natural to be taken to the home activity first. Next, we'll learn how to do that using a back stack.

The Back Stack
In addition to deep linking, you'll want to give your users a solid context and understanding of how your app navigation is structured. This is done by simulating a proper back stack. The back stack is Android's way of keeping track of where you've been so that as you navigate back, you'll go through each activity you have visited. If you just start up an activity and then a user navigates back, it'll go back to wherever they were previously. If they navigated to your app from a notification, this means that they will end up on the Android home screen. A better user experience is for them to navigate back through your app's natural activity hierarchy. So if a user navigated to a specific message within a messaging app, they could hit back, and end up in a conversation activity. If they hit back again, they could end up on the home activity. This is a more natural experience and helps a user to better understand where they are inside of your app after a deep link. Using deep linking together with a synthetic back stack, you can direct the user to any activity within your app, and they can find their way back out naturally. Let's see how this would work with our NoteKeeper app. If we've set a reminder notification and later we click on it, we can navigate the user past the home screen and right into that particular note. This way, they can get right to the subject of the notification without extraneous clicks, and by simulating a proper back stack, when the user navigates back, they'll be taken to the note's activities parent, which, in this case, is the home activity. This gives the user a clear understanding of how the child and parent activity relate to each other. This approach provides a consistent feel to the app. Every time the user is in the node activity and they press back, they can count on navigating to the home activity. It is a good idea to follow the strategy of simulating a back stack any time a user deep links into your app so that users gain confidence in navigating around your app. Next, let's learn how to simulate a back stack when deep linking into our NoteKeeper app.

Pending Intents
Pending intents are a special kind of intent that allow us to fire off an action on a delay. These special intents are perfect for starting our app correctly when the user taps a notification. A regular intent, as the name implies, is the most common intent used in Android development. It is commonly used for tasks such as starting a new activity, making a phone call, or taking a picture. A pending intent is similar to a regular intent. It can perform the same kind of actions. The big difference is that a pending intent performs those actions on a delay. With a pending intent, you are bundling up the actions you want to perform, and saving them for later. You can provide this pending intent to another app or widget, and grant that foreign application the right to perform the operation. In other words, execute the intent as if it were executed from your own app. This is perfect for cases where we want some other app or widget to open up an activity in our own app, even if our own app is closed at the time. In our NoteKeeper app, we can create a notification reminder that will navigate to our app when we click on it. This is possible because of pending intent. We can hand the pending intent to the notification, and the notification will launch that pending intent at some later time when a user taps on it. Even if our app gets closed, the notification will keep a reference to that logic, and fire it off at the appropriate time. If we set up our pending intent to perform deep linking with a simulated back stack, we can navigate the user right to the note activity with the home screen added to the back stack. Now let's learn how to create a back stack. Here we have some code that will create a PendingIntent with a simulated back stack. To do that, we use a class called TaskStackBuilder. TaskStackBuilder has a method called addNextIntentWithParentStack. This method takes an intent. This is the intent that we will want to launch when the pending intent gets fired off. The addNextIntentWithParentStack method will also add the parent activity of our intent. It will add the parent of that parent, and so on, all the way up the chain. We will cover how to define that parent chain a little later. All those parents that get added to the pending intent will be used to simulate the back stack so that the system knows which activity to go to when the user navigates back. The intent that gets passed to addNextIntentWithParentStack is just a normal intent. This is the action that we want to fire off in a delayed manner using pending intent. In the case of our NoteKeeper app, we could use the NoteActivity class. We can pass the intent for the NoteActivity class to addNextIntentWithParentStack, and that will set node activity as the target activity, and node activity's parents as the back stack. So with the target activity and the back stack defined, we can create the pending intent. As part of the TaskStackBuilder, we will call getPendingIntent, passing an int and a flag. The int can be used to reference the intent, so we will just pass 0 for now. The flag tells the framework that if we already have a pending intent like this one, to just update its extras and use that saved pending intent. Once we have our pending intent, we are ready to pass it to the notification builder. When we create our notification, it will have a reference to this intent and will fire it off when a user taps the notification. The app will then be navigated to the desired activity with an appropriate back stack in place. In order for the TaskStackBuilder to generate a back stack for a given intent, we need to define a parent for each activity involved. This is done in the Android Manifest. Here we have the declaration for our NoteActivity in the NoteKeeper app. The last line, parentActivityName, tells the framework that ItemsActivity is the parent. TaskStackBuilder will use this information and add NoteActivity to the back stack. If NoteActivity also had a parent declared, then addNextIntentWithParentStack would add that activity as well. All of the activities in the chain would be added to the back stack. Now let's jump into Android Studio and try this out. Here we are in the ReminderNotification class. Now let's create a pending intent using TaskStackBuilder. We will use the addNextIntentWithParentStack method, passing our NoteActivity intent. This will launch the NoteActivity intent when the pending intent is fired off, and it will also create a back stack using NoteActivity's parent. In order for the notification framework to know what NoteActivity's parents are, we'll need to define it in the Android Manifest. Here we can add a parent activity name attribute, and use the ItemsActivity. This way, the main screen, or ItemsActivity, will be recognized as NoteActivity's parent. Now, TaskStackBuilder would use ItemsActivity to synthesize our back stack. We make a call to getPendingIntent with the default values, and now our pending intent is ready. In our notification builder, we can pass our new pending intent to the setContentIntent method. Let's launch the app and try it out. We can create a notification and close the app. Then, we can tap on the notification, and the app launches right into the NoteActivity. If we press the back button, we are taken back to the home activity, even though the app was previously closed. If we tap back again, we leave the app. So, thanks to TaskStackBuilder and pending intent, we can easily deep link into our app from a notification, and simulate a proper back stack.

Regular vs. Special Activities
Let's take a look at how pending intent can launch an appropriate activity either with or without a back stack, depending on the needs of our app. A pending intent can launch both regular and special activities. Let's start with regular activity. A regular activity is an activity that exists and is accessible in the normal flow and navigation of an app. If we navigate to that regular activity, we will have a back stack with each activity we visited. Users will become familiar with this structure and hierarchy as the user app. Now that we've covered how to start a regular activity using pending intent, let's take a look at starting a special activity A special activity should be fairly simple. It should allow users to perform one or two specific tasks. A special activity is typically not part of your normal app flow in navigation. It is a kind of one-shot activity that gives users some quick functionality. It can be used to extend the functionality of a notification and provide a little more for your users to do. I created a simple activity to let users review note and then delete it if they are done with it. Here in the Android Manifest, I've added this activity. It's called NoteQuickViewActivity. This will be our special activity. Let's add a few attributes that will ensure that the task won't become part of our normal activity navigation, and that a user won't accidentally navigate to it. Going back to our ReminderNotification class and the notify method, let's write some code that will launch our special activity instead of the NoteActivity. I added a convenient method to the NoteQuickViewActivity that will give us an intent to launch. Again, we are providing the note position so that we know which note to display. I've added these flags here so that our special activity will be its own task. Here we are creating a PendingIntent without using TaskStackBuilder. A special activity shouldn't have any kind of back stack. We've added this PendingIntent to our notification builder, now let's launch the app. We can create a notification just like before, but now when we tap the notification, we are taken to our special activity. We could review our note and delete it if we want. Our special activity provides users with an alternate way to interact with notes. Depending on the needs of your app, you may want to use a regular activity with a back stack, or a special activity, or even both. In this module, we learned what deep linking is and how it provides users with a greater context and sense of confidence with the navigation of your app. We learned how TaskStackBuilder can automatically build a back stack based on the app hierarchy defined in the Android Manifest. We learned how pending intents are useful for launching an intent on a delay, giving other processes the authority to launch activities on our app's behalf, and we learned how pending intents can be flexible and launch either regular activities with synthesize back stacks, or special activities with a very focused set of tasks. Next, we will learn how to do more at the notification framework. We will learn about various notification styles that can be used for everything from previewing images to controlling music players.

Styling Notifications
Styling Notifications
Hi, I'm Brendan Wanlass, and welcome to Styling Notifications. Android supports a wide range of notification styles. We'll learn how to use several of them, and we'll even compare them across various versions of Android. By the end of this module, you'll have a bunch of new tools for creating new kinds of notifications, and will have a better understanding of how notifications have evolved over time. We'll start with a notification style that's been around for a while, big text style. This style is great for displaying notifications with longer text bodies. We'll cover big picture style, this is a style that you can use to display image previews right from the notification itself. We'll learn about the inbox style, which is a great way to give users a snapshot of multiple messages. Next, we'll explore messaging style. This is a style that provides a ton of convenience by allowing users to perform common actions with notifications without having to go to their messaging app. Previously we went over basic notifications and how to create one in our NoteKeeper app. Here, we'll cover some hypothetical situations where we are required to add new functionality to our NoteKeeper app in the form of various notification styles. Notifications are a great way to enhance your user's experience. Messaging can be more convenient with proper notifications and notification actions. Sharing and receiving images can be more comfortable with image previews, managing emails can be less burdensome by providing a snapshot of the user's inbox, and controlling media right from a notification is what users look for in great media apps. So let's get started. First up, big text style. Big text style is a natural step from the regular compact notification we created in the previous module. It's changed a bit over the years and is easier to use than ever. Let's take a look. Big text style was added in API level 16. This means it was added all the way back in Jelly Bean, or Android 4. 1 in 2012. In more modern versions of Android, it has useful features such as a summary and a collapse toggle. Compared to a basic notification, big text style allows us to display much more text, but maintains the convenience of a basic notification by being collapsible. In the collapsed state, a big textile notification can provide a unique title and body text summary so that with a glance, the user can decide if they want to expand the notification to read more. Let's jump into Android Studio and learn how to create a big textile notification. Here we are in Android Studio, make sure you've downloaded the project from the resources section of this course. Make sure you're using Android Studio 3. 2 or newer since we'll be showing Android P for some of these demos. Open up the NoteKeeper app and follow along. Go to the ReminderNotification class. This is the class we created in the last module that helps us to fire off notifications. We'll modify what kind of notification is fired off when you tap the notification reminder button in the note activity. As we go through this module, we will come back to this class and try out different kinds of notifications. Scroll to the notify method. As part of our notification builder, we can set the content title and content text. When the notification is collapsed, these are the values that will be displayed. Typically you'd want to provide some useful summary of your notification with these values. For now, let's set those to Collapsed Title and Collapsed Body Text. Big text style also supports a large icon. I've added a happy face here, but you can use whatever you want. Continue down, and we can call the setStyle method as part of our notification builder. We can pass NotificationCompat. BigTextStyle, BigTextStyle is also using a builder pattern, so we can compose our style by changing several methods. First, let's call bigText and provide a long string. This is the long message that will show when the notification is expanded. Next, we can call setBigContentTitle. This is the title that will show when the notification is expanded. Pass a suitable title here as a string. Last, let's call setSummaryText. Here we can define a short summary of the message. Now you can use the NoteKeeper app's reminder button to fire off this notification. Here is what the notification looks like on Android 5, 7, and 9. Let's take a look at some of the differences. Android 5 supports big text style, but the collapse functionality is a bit different than in more modern versions of Android. In older versions of Android, like 5, the OS decides when to collapse the notification. You can drag down to expand the notification. In newer versions, you have a toggle to expand and collapse the notification. Aside from that and some minor layout differences, the functionality is the same and this notification is a great choice for supporting longer text messages across many versions of Android. Next, let's take a look at big picture style.

Big Picture Style
Big picture style is a great notification style for showing users a nice preview of an image. It's an easy to use style and creates a big impact. Let's check it out. Big picture style was added in API 22 in 2014, so it's newer than big text style, but most users devices will support it. Let's say we've added a feature to the NoteKeeper app where we can take a picture and add it to our note. Perhaps we want to show that picture as a reminder in a notification. Big picture style is a great choice for this kind of behavior. Big picture style, similar to big text style, can be expanded and collapsed. Taking a closer look at the expanded big picture notification, we see that it shares several elements with the big text and basic notifications. We still have the small icon, app name, and time stamp. We also have a title and body text; however, when using big picture style, we have less room for text due to the large image. That means that if we have a longer string for the body text, it will be truncated. Now let's take a closer look at the big picture style when it's collapsed. The collapsed version of a big picture style can show a small preview of the image by populating the large icon element. The collapsed version will also continue to show the notification title and body text. Let's go add a big picture style notification to our NoteKeeper app. Go to the ReminderNotification class and scroll to the notify method. We can call setLargeIcon, and pass in our desired image so that when the notification is collapsed, users will see a tiny preview of the image. Scroll down and add a call to setStyle. Pass NotificationCompat. BigPictureStyle. As part of BigPictureStyle's builder, call. bigPicture, and pass in the desired image. Go ahead and launch the app and create a notification. We'll see the notification using the big picture style displaying our desired image. However, even if the notification is expanded, we still see the large icon. This isn't optimal since a user is seeing the same thing twice, let's fix this. Back in our BigPictureStyle, let's add a call to the bigLargeIcon method. Let's pass null. That way, when the notification is expanded, no image will be shown for the large icon. Launch the app, create a notification, and try it out. We see that when the notification is expanded, we see our big image, but no extraneous large icon. When the notification is collapsed, the large icon comes into view, perfect. You need to be careful when displaying images in Android. It is common to display photos that were taken on the device when using the BigPictureStyle notification. The problem is, these photos, especially when taken with modern devices, are extremely large. I've loaded a large photo of a sunset into the project. You can see that it has a size of 3, 888x2, 592, and a disk size of 5. 11MB. Let's change our code to use this image for out notification. Let's launch the app and try creating a notification. When we tap the notification icon, the app crashes. When we look at Logcat, we see that we got an OutOfMemoryError. The image would've taken a whopping 362MB of memory. Even though the image only takes up 5MB on disk, it takes much more space when loaded into memory. This is because the image is compressed to some format like JPG or PNG when it's on disk, but when it's loaded into memory to be displayed, every pixel must be accounted for. Our sunset image consists of over 10 million pixels. We need to use smaller images when using big picture style. If you are making a photography app that needs to show large high-res images, you'll need to downscale them before using them with big picture notification. Here is what big picture style notifications look like on Android devices running Android 5, 7, and 9. Big picture style on Android 5 behaves similarly to big text style. The OS will sometimes collapse the notification, and you can expand it by dragging down. The behavior on Android 7 and 9 are essentially the same and we can collapse or expand the notification as we wish. Every API starting in Android 5 can make great use of the big picture style. Next, let's take a look at inbox style.

Inbox Style
Inbox style is the counterpart to big text style. Instead of showing one large message, it shows the user that they have several new messages that need their attention. It is commonly used for messaging and email apps. Let's take a look. Inbox style was added at the same time as big picture style in API 22 in 2014. It also supports collapsing and expanding, as well as a title, body text, and large icon. The body text is shown in the collapsed state, and could be used to give some additional info about the messages. In the expanded state, we can show several one-line strings. These are typically the title or text of the messages in the inbox. This style is not a typical or real inbox. You can't compose or reply to messages here. It is simply meant to provide a quick summary of what messages the user has. When a user taps on this kind of notification, the expected behavior would be to navigate to the app's inbox, so that the user can view their messages. Let's add an inbox style notification to our NoteKeeper app. If we had added some kind of messaging to our NoteKeeper app, we could use the inbox style to support that feature. You're here in the ReminderNotification class, scroll to the notify method. For ContentTitle, let's put five new messages as the string. For ContentText, let's use Review your messages. This style supports a large icon, so let's set one here. Scroll down and call setStyle, passing NotificationCompat. InboxStyle. You can then add several lines as part of InboxStyle's builder. These are the lines that will be shown in the expanded inbox style notification, and represent each new message in the inbox. We can have up to six lines here. Any additional lines will be ignored. Here is what inbox style looks like on Android 5, 7, and 9. Like previous notification styles, on Android 5, the OS will sometimes collapse this notification type. You can expand it by dragging down. On Android 7 and 9, we can expand a collapse this notification type with the toggle. We see our notification title and the new message strings. This is a great style for keeping users up to date with their messages. Next, let's take a look at messaging style.

Messaging Style
The messaging style is a new style in Android 7. It was released with API 24 in 2016. As long as you're using NotificationCompat, this style will fall back to a different supported style on versions of Android prior to 7. This is a robust notification style and there's a lot to learn, so let's get started. Messaging style represents a huge step forward for convenient communication on Android. Combined with the quick reply action, this style can increase productivity by letting users stay caught up with their messages without interrupting their other tasks. Let's take a look at the two parts that typically make up this notification. The messaging style specifically refers to this top part of the notification, where we see a conversation happening. We can get a quick summary of the last few messages in the conversation. This style can show a conversation between two or many participants. The second part which typically accompanies the messaging style is actually notification actions, which features the direct replay text field. We can combine these two features to make a mini messaging app that lets users keep up with the conversation right from the notification. Let's say we want to add a messaging functionality to our NoteKeeper app. We could let friends comment on our notes and get a conversation going. This notification style is perfect for such a situation. Let's jump into Android Studio and see how to do it. As a reminder, you'll want to be using Android Studio 3. 2 or newer to ensure that features on Android 9, or Android Pie, work correctly. Open up the NoteKeeper app and navigate to the ReminderNotification class. Fire up the app and click on a note. I've added a list to the note activity and prepopulated it with some comments. Let's create a messaging style notification so that we can see the conversation when we create a reminder notification. First, let's jump to the NoteActivity. Instead of passing both the title and body text to our notify method, let's pass the whole note info object. I've added the comments list directly to this object, so that will be passed as well. Now jump back to the ReminderNotification class, and let's change the signature of our notify method. Let's change the second parameter to the NoteInfo object, and remove the string parameters. Now that we've got our note with the comments inside, let's create three messages. These messages objects will go directly into our messaging style. For each message, let's provide the comment, time stamp, and name of the person who wrote the comment. I've made sure to prepopulate our comment list with three messages, so we're okay to access the list of messages like this. If there weren't any messages and I did this, we'd get an index out of bounds exception, so make sure to watch out for that. Moving down, let's change the title of our notification to something more appropriate. Let's remove the ContentText since that will be showing our comment conversation instead. Let's update the ticket title as well so that accessibility readers know what the message is about. At the bottom of our builder, let's call setStyle, and pass in a messaging style. For the messaging style parameter, we'll pass our own name. I'll put You, but feel free to put your own name instead. This is the name that will appear next to our own messages when we reply. On the style builder, let's call setConversationTitle, and pass the title of our note. This will appear above the messages. Then, we add each of our three messages to the style. Add them in reverse order so that the newest message will appear at the bottom. We'll be inserting new comments to the beginning of the list so the newest message is always first. Let's launch the app and see what we get. When we navigate to a note and create a notification, we see that we have a note title along with the three comments. This is reasonably useful, but to make things really convenient, we'll want to add a quick reply or direct reply action. A reply action consists of three main components. First we have a remote input object. This is the object that tells the notification to display a text input field for users to type in. Next, we need a reply intent. This is a pending intent that will be fired off when a user submits some text into the remote input. This intent will be responsible for grabbing the text out of the input and handling it. Last, we have the reply action. Both the remote input and the replay intent get bundled into a reply action and added to the notification. The reply action is what causes the action button to appear on the notification. Let's go back into Android Studio and add a reply action to our messaging style notification. Below our three messages, let's create our RemoteInput. This object uses a builder. For the builder's parameter we provide a key. This key will be used later by the pending intent to grab the contents of the RemoteInput. Let's define this key at the top of our class with the other constant vals. On the remoteInput builder, let's call setLabel, and pass Add Note. This is the text that will appear as a hint text when the quick reply's text input field is shown. Finally, don't forget to call build. Now we need to create a class to handle the direct reply. We don't want to fire up an activity because that would interrupt what the user is doing and defeat the purpose of a quick reply. Let's instead use a broadcast receiver. Go to File, New, Other, and choose Broadcast Receiver. We can name our class NotificationBroadcastReceiver. Deselect Exported, as we don't want other apps to have access to this broadcast receiver, and click Finish. Android Studio will create our class for us and add it to the Android Manifest. This class comes with the onReceive method. We'll fill out this method in a minute, but for now let's jump back to our ReminderNotification class. Now let's create an intent that will fire up the broadcast receiver. Let's add our NOTE_POSITION so that the intent will know which note we're dealing with. Jump back to the NotificationBroadcastReceiver. Inside the onReceive method, let's put some code to handle our quick reply. First, we need to grab the bundle from our RemoteInput. After checking to make sure our bundle is not null, we can grab the NOTE_POSITION that we passed with the intent. Next, let's grab the message that was entered into the RemoteInput. We can do this by calling getCharSequence on the bundle, and pass in a queue we defined earlier. Let's convert that CharSequence into a string. If the value happens to be null, we'll just use an empty string. Now, let's add that string to the note. Reference the note by calling DataManager. notes, and pass the notePosition. Then you'll call comments. add on that note. This will let us add a comment to the list of comments in that note. I've created a class called NoteComment. The first parameter is the name of the person who wrote the comment. In this case, let's pass null. We do this because if the name is null, the notification framework will use the name we provided to the messaging style. Next we pass the comment text. Finally, grab a time stamp and pass that to the comment object. Now that we have added our new comment to the note, we need to do one last thing. Since we're handling the RemoteInput, we need to update the notification when we're done. We do this by simply firing off a new notification. Call ReminderNotification. notify, and pass the same note we just updated, and the notification will reflect the new comment we just added, and will also reset the direct reply action. Go back to the ReminderNotification class. Now we will create a pending intent that will contain our BroadcastReceiver intent. Take note that we are calling PendingIntent. getBroadcast since we are firing off a BroadcastReceiver. Now we create the third and final piece of our direct reply action. Let's create our replyAction by calling NotificationCompat. Action. Builder. Pass a suitable icon for a direct reply, as this will show up on older versions of Android and on Android Wear. We can use Add Note for the button text. Pass our replyPendingIntent here, call addRemoteInput and pass our RemoteInput object, lastly, call build. Now that we've constructed our replyAction, pass it to our notification builder with the addAction method. Let's fire up our app and give it a try. We can create a notification in the NoteActivity, and we see our three existing comments, but now we also see an ADD NOTE button. When we tap on it, our direct reply text field appears along with a submit button. We can add some text, hit submit, and we see that the notification is updated with our comment. We can tap on the notification, and we see that our comment has been added to the list for this note. Our notification works great, but it looks a little plain, let's add a little color. Go back to our notification builder and call setColor, passing in a color that matches your apps theme. Then call setColorized passing true. Finally, while we're here, let's add a call to setOnlyAlertOnce, passing true. This will cause our notification to alert only the first time. Our subsequent replies won't cause additional alerts from the device. Fire up the app and create another notification. Now we see that the notification has some color, much better. This is what our notification looks like on Android 7. If you fire up a device running Android 9 and create a notification in our NoteKeeper app, you'll see that the style has evolved. Now we can show an image next to each person's response in the messaging style notification. Android 9 introduced several cool features for this notification style. Do some exploring and have some fun playing around with this notification and trying out the newest features. This notification style was introduced in Android 7. If we fire up an older version of Android, we see that the framework may fall back to a different style. On this Android 5 device, we are seeing the inbox style, along with an icon next to the ADD NOTE action. To support the messaging style on devices prior to Android 7, you would need to fire up an activity to reply to the conversation, as the direct reply feature didn't exist in those versions of Android. Now that you've got a good understanding of the basics, you can begin to explore other notification types like the media style notification. This is a powerful, persistent notification that can be used to control various types of media, like music and video. By building on the basics that you've learned in this course, you can create the perfect notifications to give your users a convenient and engaging experience. In this module, we learned about several notification styles that can be used to meet different needs. We learned about the big text style, which is great for supporting those longer messages. Big text style helps keep the UI clean and organized and gives the users the information they need. We explored big picture style, a style that lets you send image previews and thumbnails so that users can get a fast glance at the media they're receiving. We learned about inbox style, a style that gives users a convenient snapshot of their messaging inbox so that they can stay on top of their communications. Last, we learned about messaging style, a powerful and convenient style that lets users respond to messages right from the notification, letting them be responsive without interrupting their other tasks. Next we'll learn how to create home screen widgets. Widgets are a fun feature that can be a great way to provide users with a slice of functionality right from the home screen of their device.

Home Screen Widgets with Kotlin
Home Screen Widgets with Kotlin
Hi, I'm Brendan Wanlass, and welcome to Home Screen Widgets with Kotlin, where we'll learn how to bring functionality out of your app into the Android home screen. Home screen widgets let your users customize their home screen with your app's most important data and features. Users can drag home screen widgets across their home screen panels and resize them to meet their needs. Widgets are a lot of fun so let's get started. First, we'll see how Android Studio can assist us to making a basic widget. We'll discover the basic components that make up a widget, and add one to our home screen. We'll hook up the notes list to our new widget and learn what it takes to display a scrollable list of data. We'll discuss some of the limitations of layouts for app widgets. We'll learn how to keep our widget up to date with the latest data. Finally, we'll learn how to launch our app when the user interacts with the widget using techniques that we learned earlier in this course. Many of the apps you use every day have widgets available for you to place on your home screen. You can long press somewhere on your home screen wallpaper and see a menu option for widgets. You can drag a clock widget to your home screen for a fun way to keep track of time. You can create a widget for Google Play Music for a convenient way to play songs. If you long press on a widget, you can often resize it. Sometimes, like with this music player widget, the view will change and show more content if it's expanded. You can create a widget for your messaging app and have a conversation displayed right on your home screen. You can even reply to the conversation. Let's open up the NoteKeeper app and create our own widget. This is the app we've been building during this learning path. You can download the source code in the resources section for this course. Once you've got the project open, go to File, New, Widget, and select App Widget. Name the new widget, NoteKeeperAppWidget. You can leave Placement as Home-screen only. Leave Resizable as vertical and horizontal. Next, we have the minimum width and height for our widget. Notice the image here on the left-hand side of this dialog. It shows the Android home screen broken up into a grid of squares. You can think of one cell or square being about the size of one app icon with some additional padding. We can select a minimum width and height for our widget by the number of cells or squares it will take up in the grid. The actual pixel size of the cells varies from device to device. Some devices in Android versions will have more cells than others. This is the same concept you have to be aware of when building regular layouts for your Android apps. You want to build your widget layout keeping in mind that device screen size and pixel density vary, so you'll want the layout to be flexible, allowing some stretching vertically and horizontally. Keeping your layouts fairly simple with some padding will help you to have widget layouts that look good on many different devices. When an instance of your widget is created, it will be sized to match your minimum width and height by default. If you have enabled resizing, users can make it larger if they choose. Select a minimum width and height that will give your layouts enough room to display properly, but that isn't unnecessarily large. For our widget, let's choose a minimum size of 2x2. Keep Configuration Screen deselected, and make sure Kotlin is selected for the language. Then click Finish. Android Studio will create a few files for us. Let's run the app and check out the new widget that Android Studio created. Long press on the app icon and select Widgets. A dialog appears with our new widget. Tap and drag the widget out to our home screen. We see a simple widget and some placeholder content. We can long press the widget and resize it. We can go to our widget menu again and create another instance of the widget. A user can create several instances of a given widget. This is useful for situations where the content could be different, such as for clocks for various parts of the world, or weather in different cities. A widget can be removed from the home screen just like an app icon. Long press and drag the widget to the remove label. This will not uninstall the underlying app to which the widget correlates. Let's look a little more closely at the pieces that make up a basic app widget. A basic app widget consists of three components with an optional fourth component. First, we have the AppWidgetProviderInfo. This is an XML file that describes some attributes in the app widget. It defines both an InitialLayout and an InitialKeyguardLayout. On older versions of Android, you could show a widget on the keyguard or device lock screen, so you don't need to worry about that layout for now. Next, we have the minimum width and height of a widget, which will limit how small the widget can be resized. Then we have the previewImage. This is the image that is shown in the widget menu. Next, we have the resizeMode, which defines what direction the widgets can be resized in. Then we have the updatePeriodMillis, which tells the app how often to refresh the widget. By default, it's set to 24 hours. Last, we have the widgetCategory. Since Android 5, only home screen is valid here. Prior to that version of Android, widgets could be shown on the lock or keyguard screen, and that could be defined here. Android Studio generated this file for us, but you can edit these values to your liking. Next, we have the AppWidgetProvider class. This class extends AppWidgetProvider and starts with four basic methods. First, we have onUpdate. This gets called when the widget gets an update. It will typically iterate through each created widget by widget ID, and update it. Next, we have onEnabled. This gets called when the first instance of the given widget type is created on the home screen. This method could be used to initialize a database or dataset. Next, we have onDisabled. This gets called when the last instance of a given widget type is removed from the home screen. This could be used to clean up the dataset or database. Last, we have updateAppWidget. This is a static method that we can call when we want to cause a widget update. Here we can set up views and buttons on the widget. Creating views in an app widget is a bit different when compared to normal views in an app. Instead of simply inflating our view layout, we will utilize a RemoteViews object. App widgets run independently from the rest of your app. Even if your app closes, the widget remains active and functional. We will use various mechanisms to make this happen, one of which is called RemoteViews. RemoteViews are responsible for displaying our widgets, as well as updating them. RemoteViews run inside a separate process from your app. They run on the home screen and are given a limited amount of functionality. By enforcing the use of RemoteViews when creating an app widget, Android can ensure that an application will not execute code in the systems launcher process. Thanks to strict control over what can and cannot be done in an app widget, we can have a good balance of security and functionality. As a part of that pared down functionality, you'll have access to a reduced subset of views and methods for updating those views. When creating a RemoteViews object, you pass the packageName of your app and the ID of your widget's layout. Then you can call a method on that RemoteView object, such as setTextViewText, which would update the referenced text view with the provided text. The RemoteViews object has various methods that you can use to affect the views in your RemoteViews layout. The list of methods represents the more strictly controlled functionality available to RemoteViews. Instead of referencing views in a layout directly, you simply call one of the available methods on the RemoteViews object. After that, we call updateAppWidget on the appWidgetManager that is path to this method. All of the changes we set for the RemoteViews will then take effect. The next essential part of an app widget is a view layout. When working with app widgets, you'll be able to use a reduced subset of views. For example, constraint layout is not supported in an app widget, so you would need to use something like a relative layout linear layout. You can visit Google's developer page for a list of supported views. Make sure to keep your layouts simple. You'll be working with a reduced amount of space and if a layout gets overly complicated, it may not display correctly. Keep your widget focused to very specific tasks in data. If your supporting device is prior to Android 5, you can show you widget on the lock screen, and can use a separate layout file for that. Last, we have the optional configuration activity. If your widget needs some settings at configuration from the user, you can show a special activity. If your widget is more advanced, you may need to show a configuration activity to make sure your users get the correct settings. If you add a configuration activity to your widget, it will be launched when the user creates an instance of your widget on their home screen. Next, let's learn how to add some data from our app to our new widget.

Showing a Collection in a Widget
App widgets are a great place to show lists of data from your app. Although widget layouts can't use recycler list views, they can use regular list views. Let's learn how to show a list of notes from our NoteKeeper app in our new app widget. Working with collections and remote views is very similar to working with normal list or recycler views. The first piece you need aside from your actual data is an adapter of some kind. For an app widget, we're using RemoteViews, so we are going to use a RemoteViewFactory as the adapter for our collection. It will function similarly to a list or recycler adapter by providing us with methods to update our data and bind our data to our collection view. We will build one of these factories in a moment for our app. The next piece is a RemoteViewsService. As our widget will exist outside of the normal activity or fragment lifecycle and will function even if the app is closed, we need some kind of service to wire things together. The RemoteViewsService will provide our RemoteViewsFactory to the widget. The last piece is the view. RemoteViews don't support recycler lists, but we can use a regular list view. We'll use the RemoteViewsFactory to bind our data to a list view. Let's jump into Android Studio and add our list of notes to the home screen widget. Go to Android Studio and open up the NoteKeeper app we've been building. Create a new file called AppWidgetRemoteViewsFactory. This class will extend RemoteViewsFactory. Let's implement each of its methods one by one. First, we have the onCreate method. If we need to initialize our dataset, we could do that here. Since the data for our NoteKeeper app doesn't need any initialization, we won't put anything in this method. Next, we have the onDataSetChanged method. If our underlying data is changing around, we could call this method and address that as needed. Again, our data is simple, so we won't put anything here. Next, we have getLoadingView. This is a handy method where we could define a view to be shown while our data is initializing or loading. We will just return null for our NoteKeeper app since we don't need to load any data. Next, we have getItemId. Here we can return a unique ID that pertains to a specific item in our dataset based on the position in the collection view. Our data is simple, so we can just use the position as the ID. Next, we have hasStableIds. Return true here if the same ID always refers to the same item in your dataset, in our case this is true. Next, we have getViewAt. This is where we will bind our data to our RemoteViews. We can create a RemoteView object by passing our app's packageName and the ID for our item layout. We will create the layout for our list items in a moment. Next, we can set the TextView in our item layout based on the position of the view. Last, we return the RemoteViews object. As someone scrolls our collection view in the widget, the framework will use this method to know what to draw for each item. Next, we have the getCount method. This just returns the size of our dataset. We can return the size of our list of notes. Next is the getViewTypeCount method. This method returns the number of type of views that we will be returning in this factory. In our case, we will just have one view type. Last, we have the onDestroy method. This can be used to clean up any data or cursors we may have opened. This will get called when the last RemoteViews adapter associated with this factory gets unbound. Next, let's go create our service for providing this factory to the RemoteViews. Create a file called AppWidgetRemoteViewsService. This class will extend RemoteViewsService. The only method we need to implement is called onGetViewFactory. This method returns a RemoteViewFactory, so we can simply return an instance of our AppWidgetRemoteViewsFactory. Make sure to pass applicationContext when instantiating a RemoteViewsFactory. We don't want to tie this factory to any specific activity context, since we want this to work even when the app is closed. After we've created our service, we need to register it in the Android Manifest. Open up the Android Manifest and register the service with the BIND_REMOTEVIEWS permission. This will tell the framework that we want our servers to be able to bind our data to RemoteViews. Now that we have our RemoteViewsFactory in service, we need to modify our widget's layout to include a list view. Open up the NoteKeeper AppWidgetLayout file, which changes our TextView to say notes, and changes the colors to our liking. Move the TextView to the top of the layout instead of in the middle. Let's change our layout's background to a nice semi-transparent gray. Add a ListView below the TextView. Now that we've got all three pieces defined, we just need to wire them together. Go back to the NoteKeeper appWidget class and scroll to the updateAppWidget method. On the RemoteViews object, I'll set RemoteAdapter, pass in the ID for our ListView, next, pass in an intent that will fire up our AppWidgetRemoteViewsService. Now that we've got our collection wired up, let's launch the app and try it out. Our widget now has a list representing each of our notes. You can scroll the list up and down the same way we could with the note list inside our app. We can create multiple instances of our widget if we like. We can resize our widget and the collection view will expand to fill the space. This is a great first step to having a useful companion widget to our NoteKeeper app; however, if we go create a new note, and then go look at our widget, we see that the widget does not update to reflect the new data. This is because the widget is still set to refresh only every 24 hours. Next, let's take a look at how we can cause an update to our widget so that it's always up to date.

Updating a Widget
When the data in your app changes over time, you'll want to make sure to keep your app widget up to date so that users have an accurate picture of what's going on. To update our widget, we need to communicate to it via broadcast. We can fire off a broadcast from our app that the widget can receive and respond to. For our NoteKeeper app, we want the widget to update when we create a new note. So let's jump back into Android Studio and fire up a broadcast when a new note is created. We'll also create a method to receive the broadcast and handle it appropriately. Open the NoteKeeper AppWidget class. In the companion block, create a new method called sendRefreshBroadcast. We will use this method to cause a refresh on our widget. First, create an intent using the widget update action from the appWidgetManager. Set the intent's component to a ComponentName using our NoteKeeperAppWidget class. Then, using the context we passed in, call sendBroadcast, passing our intent. This will cause a broadcast to fire off, and we can listen for the broadcast in our widget class. Open the NoteActivity. In our saveNote method, let's send out a broadcast to our NoteKeeperAppWidget using the sendRefreshBroadcast method. Go back to the NoteKeeper appWidget class, and below the onDisabled method, create a new method override for onReceive. This method will handle any broadcast we send for the widget. First, grab the action from the intent. Check if the action is a widget update action. If so, the broadcast is for our widget to update. Grab an instance of the AppWidgetManager, and create a ComponentName using our NoteKeeperAppWidget class. Call notifyAppWidgetViewDataChanged on the AppWidgetManager. For the parameter, use the manager to get all the IDs for instances of our widget. This will cause each instance of our widget to update and refresh its views. For the second parameter, ask the id for our notes_list. This will associate this update to our ListView. So now when we create a new note, it will fire off a broadcast that our widget class can listen for. That received broadcast will cause a refresh for each instance of our widget. Let's launch to the app and try it out. Create an instance of our widget on the home screen. Create a new note and save it. Go back to our widget, and we see that our new note is in the list of notes right away. So we see that with a simple broadcast communication, we can keep our widgets up to date. The final piece of our widget is making the items in our collection clickable, so that a user can open the desired note to review it. Next, we'll learn how to launch our app from the AppWidget.

Launching the App from a Widget
Being able to display info from our app inside an app widget is very useful. Being able to then direct the user back into your app will complete the user experience. Defining click actions for collections and app widgets is slightly different than normal lists in an app. To define click behavior for individual items in our list, we need to create a pending intent and associate it with our RemoteViews object. We can't set up a pending intent for each item in our list, so we create one pending intent and use it as a template. The pending intent template takes in the ID of our collection, as well as an intent to launch the desired activity. The template is essentially saying when an item in the collection is clicked, launch this activity. Each item is then responsible for adding any additional data in the form of intent extras. This is done with fill in intents. In our RemoteViewsFactory, we can provide the extras for each specific list item. We can call setOnClickFillInIntent in our RemoteViewsFactory, and we can pass in the layout ID for our list item so that the framework knows to associate this FillInIntent with the correct list item. We also pass in a basic intent with any necessary extras added. In the case of our NoteKeeper app, we can add the note position to this FillInIntent. You can use the same basic data types as extras in a FillInIntent that you would use in a normal intent bundle. By using a FillInIntent and adding it to our pending intent template, each click action can be distinguished. The FillInIntent is created for each item in our list and combined with a pending intent template. Since we called SetOnClickFillInIntent in our RemoteViewsFactory, whenever one of the list items is clicked, the pending intent template is filled with the item's specific data, and the desired activity is launched. Let's try this out. In order to launch our app from the AppWidget, we're going to leverage some things we've learned previously in this course. When a user taps on one of the note items in our collection view, we want a deep link into the NoteActivity, displaying that note and also generate a back stack. Open up the ReminderNotification class that we've worked on previously. We can copy the code that creates a pending intent with the back stack. Go back to our NoteKeeperAppWidget class, and in the updateAppWidget method, we can place the code for creating our pending intent. We could remove the code that adds the NOTE_POSITION to our intent. We'll be setting the positions slightly differently for our widget. This is the intent that we will use as our template. Below the pendingIntent, call views. setPendingIntentTemplate, pass the id for our widget's notes_list, and the pendingIntent. Notice the name of this method has IntentTemplate. You're defining the template or pattern that each widget and collection item can use. Jump to the AppWidgetRemoteViewsFactory. IN the getViewAt method, create a bundle and put the NOTE_POSITION in it. Create a new intent and call it fillIntent. Put the bundle in this intent. Lastly, call setOnClickFillInIntent on a RemoteViews object. Pass the layout ID for the widget item and pass in our fillInIntent. This method is saying when a user clicks on one of these widget items, add our fillInIntent to finish out our template. The template is set up to launch our NoteActivity with a back stack, and it will now also have the note position as an extra. So when our NoteActivity launches, it will know what note to display. Let's launch the app and try it out. Go to our AppWidget and tap on a list item. The NoteActivity launches with the correct note displayed. We can hit the back button and navigate to our main activity. We've successfully bound a click action to our list items in the AppWidget collection, and ensure a correct back stack is generated.

Summary
In this module, we learned how Android Studio can help us create a basic AppWidget for our app by using the new component dialog. We learned how to customize a basic notification using a static helper class and how we can use that helper class to create a notification from anywhere in our app. We learned how to bind data from our app to a collection view in the app widget using the AppWidget provider class combined with the RemoteViewsFactory and RemoteViewsService. We learned that although app widgets only have a subset of views available, we can get a good range of utility out of the available views. We learned how to keep our app widget fresh by updating it with broadcast and a notification broadcast receiver. Finally, we learned how to get users back into the app when interacting with the app widget by leveraging our knowledge of pending intents and deep linking. In this course, we learned how to keep users engaged and informed by showing helpful notifications. We used Android Studio and Kotlin to create notifications that are supported across various versions of Android by paying close attention to how the notifications behave across different SDK versions. We used Android's notification framework to create basic notifications and learned about the anatomy of a notification so that you can show the right data and icons to your users. We learned how to bring users back into the app with a smooth navigation experience by deep linking to specific activities with synthetic back stacks. We learned how to use pending intents to delay actions for a later time so that you can save an action and fire it off when a user interacts with your notification. We explored various notification styles that can be used to meet the different needs of your apps. We learned how to display long text, image previews, and message inboxes; allowing you to create the perfect notification for any situation. We discovered how the direct reply action can let users respond to messages right from a notification for a less intrusive and more convenient experience. We learned how to create robust home screen widgets with Android Studio by taking advantage of remote views and broadcast receivers. We learned how to set up widgets that can display app data, stay fresh and up to date, and even get users back into the app with deep linking. I hope you've enjoyed this course and will continue learning how to utilize notifications by checking out the Pluralsight course: Firebase on Android: Cloud Messaging, Cloud Functions and Crashlytics, by Mitch Tabian. It is a course that will help you apply your skills with notifications to take your app to the next level by creating a dynamic, high-impact product that can connect your users and provide them with real time data. Thanks for watching my course, and if you have any questions or comments, please reach out in the comment section. Be sure to check out the next course in the Android Apps with Kotlin learning path, titled Android Apps with Kotlin: Custom Views.

Course author
Author: Brendan Wanlass	
Brendan Wanlass
Brendan is an Android and game developer. He has a passion for well designed, engaging software. He was a designer and engineer for the game Magnetic by Nature...

Course info
Level
Beginner
Rating
0 stars with 3 raters
My rating
null stars

Duration
1h 28m
Released
11 Oct 2018
Share course