Play by Play: Modern Web Security Patterns
by Troy Hunt and Lars Klint

In this course, you’ll learn how to implement and manage all the aspects of web security to be on the more secure end of the spectrum.

Play by Play is a series in which top technologists work through a problem in real time, unrehearsed, and unscripted. In this course, Play by Play: Modern Web Security Patterns, Troy Hunt and Lars Klint investigate current security web approaches and trends with real world examples, and then dive into how these incidents and errors can be fixed with easy to use techniques. Learn how subresource integrity checking can validate assets, content security policies in action and learn how to configure them, and get crucial knowledge on how important HTTPS is and some of the tools you can use to test your site. By the end of this course, you’ll have all the tools you need to learn about how you can secure your web assets, with the Modern Web Security Standards.

Course authors
Author: Troy Hunt	
Troy Hunt
Author: Lars Klint	
Lars Klint
Course info
Level
Beginner
Rating
4.7 stars with 68 raters(68)
My rating
null stars

Duration
1h 24m
Released
18 Apr 2018
Share course

Course Overview
Course Overview
(Introduction) Hi everyone. This is Troy Hunt. And I'm Lars Klint. And welcome to our Play by Play on Modern Web Security Standards. I'm an Australian Pluralsight author and security specialist, and I've got a passion for helping people secure their web assets. And I'm a freelance solution architect at larsklint. com, Microsoft MVP, speaker, instructor, and expert in mixed reality development and Australian Outback internet. I've been building software systems from tiny websites to gargantuan telecommunication systems for the past 20 years. In this course, we will investigate current web security approaches, trends, and real-world examples. So we're going to look at some of the places where we have gone wrong with web security in the past, and talk about how we can fix them with modern web security standards. Learn how resource integrity checking can validate assets such as JavaScript files served by a third party and how it can make your website run smoother and faster. We look at how the browser XSS auditors work and what they do to protect visitors to our websites, we optimize our HTTPS themes. HTTPS is enormously important, and there's lots of ways we can get it wrong, as well as lots of cool tricks to make it better. And one of my favorite things, how to enable your visitors' browsers to automatically send you vulnerabilities that might occur in your site by using the report URI feature. But that isn't all. You'll also get crucial knowledge on how important HTTPS is and some of the tools you can use to test your site. We discuss advantages and disadvantages of HTTP public key pinning, certificate authority authorization, and finally, how you need to apply common sense to a lot of the security hype and fear. To complete the course, all you need is an open mind, an understanding of the internet, and the next hour and a bit to watch this course. I hope you'll join us on this journey to learn about how you can secure your web assets, with the Modern Web Security Standards Play by Play, here at Pluralsight.

Current Issues of Web Development Security
Introduction
Hi, I'm Lars Klint, and I'm here with Troy Hunt again. We've done these a few times, and this is a bit different. So we're going to talk about modern web security patterns, but I don't know what they are. Troy hasn't told me a thing, so this is going to be an interesting Play by Play because you're going to get the genuine reaction here and comments as well. So I'm really keen to see what's going to --- This is like Play by Play Unplugged. Yeah, that's pretty much it. This is going to be the full, legit thing. So alright, the bit that we did talk about, because we had to agree on roughly what we were going to do, is I think I was talking about a case where a particular organization was saying we're secure, completely safe, un-hackable. And I was going, well --- Yes, un-hackable was the word, that's right. Every time someone says un-hackable they usually end up getting a bunch of free penetration tests straight afterwards. They don't always get the results, but they get the tests. And the thing that struck me, I wrote about this at the time, and I didn't want to go away and sort of probe at the thing, but what I wanted to do was point out that security is a spectrum, right? Yes. You know this because we've done enough of these. And there's a bunch of different stuff you can do on the spectrum, and depending on the nature of the site and who you think your threat actors are, who's going to break into your things, you'll do different things along there. And I spend a lot of time writing about all these different things, particularly a lot of the modern web security standards we have, and I thought, well this will make a good Play by Play. Absolutely. And what really caught kind of my attention with this was that security is not on or off, like I get that in a lot of places, like, no, no, we're secure. That's not how it works, right? Yeah. I liken it a little bit to cars where someone says, is this car safe or not? And you go well, it's quite safe, but it could be like a Mercedes S-Class and if you drive it into a brick wall at 100 K an hour, it's probably not going to work out real well. So yeah, this is the analogy. So let's sort of talk about the paradigms that can get you more secure, the things that we can do better. Because we want to move up on this scale that you're saying, like we want to go towards more secure. Yep.

Explaining the Problem of Including External JavaScript
Okay, so we have got a great place to start, and this was entirely unplanned, this was not my doing. Something happened on the internet yesterday, the day before recording. And I know that you've seen this, but I've got a blog post in front of me that describes it, and I wrote about the JavaScript Supply Chain Paradox: SRI, CSP, we're going to talk about those, and Trust in Third Party Libraries. And I want to explain for everyone what actually happened here, because this is a really, really important sort of watershed moment, I think, in the industry. So the situation was, yesterday as I got up in the morning, I started seeing tweets from Scott Helme. Now you and I both know Scott, he's a mate of ours, he's now a security guy. And what Scott was finding here per these tweets is he was finding websites with cryptominers on them. Cryptominers, bad. Okay, are you familiar --- do you want to do the explanation? I can try and explain it. So a cryptominer is someone that uses your computer, or your server, to mine for cryptocurrency. Is that right? Yeah, in a nutshell. Now there is, let's just call it a quasi-legitimate way of doing this. So there are websites out there that say rather than have like monetization via ads, we are going to run a service, and you put the little service on your website, it's just JavaScript, and when it runs in your browser, it's going to mine a little bit of cryptocurrency, maybe you get like a fraction of a cent or something for each person, and a website that does do this in a legitimate fashion, people can opt into it, is called Coinhive. And Coinhive creates this service. Now, frankly there is another discussion about should you be putting a cryptominer on your website, which is going to chew up GPU, or CPU usually, of your browsers as they come along, and something feels a little bit --- Yeah, it's a bit of a gray area. But be that as it may, they do run a service that you can opt into and use of your own free will. What we saw happening here was a bunch of websites suddenly running Coinhive. Now, this is the ICO, the Information Commissioner's Office, in the UK. You're seeing a bunch of websites, and they're not just any websites, are they? Let's quantify both though, quantify and qualify. More than 4000 websites that we know of, many of them government. So there was that one, just sort of scrolling through Scott's list here, we're going to come back to Texthelp, US Courts, not a good look, Student Loan Company in the US, General Medical Council, the NHS, that's the health service in the UK. Somewhere down here as well, here we go, there's my own government. In fact, my own state government here in Queensland, Australia, which was not great. Is it safe to assume that these websites didn't actually put this on their own website? Yeah, and this is where it gets interesting. So we're going to drill down on this image, and if we have a little bit of look at the footer, and I'm pretty sure it's a little bit small, but what's happening here in the console, Scott's popped open the DevTools, you can see here it refers to Coinhive. And this is actually just a warning, the script did actually still run, but it's saying look, there is Coinhive running on this site, and it begs the question, how do you suddenly end up with thousands of websites around the world, including a lot of government websites, running cryptominers, all at once? At the same time even. All at once, at the same time. And what we learned had happened is that there is an external service called Browsealoud, and Browsealoud, per what we see on the screen here, helps websites become more accessible, easy speech recognition, reading translation tools, if you're visually impaired, if English is a second language, this helps. And if fact, this particular site talks about how they help sites make particularly regulatory requirements where you've got to be accessible for people --- So it's a good thing. Yeah, it is a good thing in terms of making your web content available to people who may have, say, visual impairment. So that is good. Now, the way the Browsealoud product, made by Texthelp, works is the same way that many, many online services work. So I'll give you an example. You know Disqus, right? Yes. Okay, Disqus, the blog sort of commenting engine. The way you implement Disqus, on say my blog, is there is a script tag, and it embeds script directly from Disqus. I do the same. It works the same way all over the web, and this is why this is such an important moment, because we're all going hang on a second, we do this stuff everywhere. So, in this situation here, what's happening is there's a script tag on the site that's pulling a piece of JavaScript off their site. Someone managed to modify that JavaScript. So what ends up happening then is you get this modified JavaScript, this one file, which is then directly embedded into thousands of sites now executing in the context of that site across every single user who comes to anyone of those thousands of sites. Because all of those sites assumed that this Browsealoud plugin or script was secure, or safe. Exactly. Now, here's what actually happened to the script. So Scott managed to grab a copy of this before it disappeared; it was online for some number of hours before they eventually realized what happened, and we can see here that there's actually an interesting bit in the heading here, or rather at the top of the file. It says Warning, Do not copy or self host this file, you will not be supported. You've got to load it from them. Then we have a whole bunch of obfuscated content on line 5, and then line 7 down is the normal content. It looks like Base64, or something. So what this is is a bunch of JavaScript encoding. Now if we de-obfuscate it, it looks like this. And what we see here is that this was actually embedding the Coinhive library into the DOM of the website. So it was just dynamically writing it onto the page. So again, you can imagine this gets on every single person's site who had embedded the service. It brings us to the point. What are we going to do about this? Because what happened here is this was like the manifestation of what so many people are concerned about embedding external content, is that someone else literally has control of active content, and active being it can actually run the script. Passive would be if it was images, or something like that. So, I want to talk about a couple of defenses here, and one of them is super, super cool, and it's called SRI.

Subresource Integrity Checking and Content Security Policies
Explaining Subresource Integrity Checking
And SRI is Subresource Integrity. And I want to go through the mechanics of how this works, we're actually going to see it in action, and it's super, super cool. And what SRI is going to do is allow us to have confidence that when we're embedding something from a third party, it is actually legitimate. So, let's do this. I'm going to jump over to Have I Been Pwned. Sounds a bit like a checksum kind of system. It's an integrity check, and we'll see this work in just a moment. So here's the Have I Been Pwned website. Now, Have I Been Pwned does a similar thing to what all of those other government websites were doing when they embed that Browsealoud plugin. If I jump down to the source code and I jump to the very end, around line 364 we see that there is a Cloudflare library embedded in the page. And in fact, let's clarify this. It is actually a jQuery library embedded from the Cloudflare domain. So Cloudflare has a CDN that hosts public libraries. Now I embed this from their CDN for many reasons that make a lot of sense. One of them is that it means I don't pay for it. And when I say pay for it, I don't have to serve this content up from my site. I did the math the other day, when I have a super busy day on Have I Been Pwned, millions of people, of all the public library content, I could end up serving about half a terabyte worth of data in a single day. Now I have to pay for that if I serve it off my site. If I serve it off Cloudflare CDN, I don't pay for it, plus they've got 190_____ nodes around the world, plus if anyone has seen that file before because they might have been on another website using Cloudflare CDN, it's already cached. So there's lots of really good reasons to use a public CDN. The bad reason to use a CDN in this way is what we just saw with the whole Coinhive thing. Now, I want to sort of show you a coupe things here. So first of all, I'm just going to drill down into this JavaScript file, okay, and then I'm going to jump all the way down to the bottom and it just finishes with a whole bunch of minified JavaScript. So, all that's fine, that works, not a problem at all. Now just jumping back a second, you'll notice that on this JavaScript file I have an integrity attribute, so where this is actually embedded. Yep, I did notice that before as well. Okay, cool. So we see after we embed the source attribute it says an integrity attribute is a SHA-384 hash, and then you can see that hash is a great big, long string on the next line. Now what this is is this is a hash of the file over here, it's a SHA-384 hash. If you were to take this file exactly as it appears, minified JavaScript of version 2. 2. 4/jquery, the hash you see back here is exactly the hash of my file. So what we're doing is we're saying this is what I expect to see, and if we were to load this file from anywhere, it doesn't matter where, and it didn't hash down to the same value, the browser is going to do something special. So here's what I'm going to do, because what we want to do now is demonstrate what would happen if the file changed. I'm going to jump over to Fiddler, and the reason I'm jumping over to Fiddler is because Fiddler has FiddlerScript, and in FiddlerScript I can go down to an event such as OnBeforeResponse, and I can modify the contents of a response that goes through Fiddler as a proxy. Now what we're doing here is we're effectively emulating what would happen if the file changed from what we expected. Now in that situation with the Browsealoud situation, that was probably the file changing on the source file system. So someone probably got access to their storage and modified it. This is just modifying it on the wire, normally we have HTTPS to protect against that, but we're just going to emulate this with FiddlerScript. Okay. Now what FiddlerScript is going to do is it's going to add a little bit of text to the bottom here, which says, Hey, I changed the file!, it's going to put it in a comment. Now this functionally doesn't do anything, but it should change the value of the file once it's hashed. So, what I'm going to do is I'm going to start capturing, I'll put that down on the bottom left, which means all my requests are now routing through Fiddler. I'm going to go back to my jQuery library, I'm going to give this a hard refresh, so that's going to pull it through Fiddler, it won't come from cache, like this, jump to the end. There's a comment. There's a comment, Hey, I changed this file! So this file is now functionally different to what it was before. I'm going to go back to Have I Been Pwned, I'm going to go to my DevTools. We've got one warning in here. I'm going to come back and talk about this warning a bit later actually. Let's now give this page a hard reload, and we'll see what happens. Because remember, what's going to happen is it's going to go and grab that jQuery file, which is now changed. So what we can see now is that there is an error on the page, and the error says, Failed to find a valid digest in the 'integrity' attribute for resource, and then we've got the URL of that Cloudflare file. Now in this case it says it couldn't find the SHA-256 value of it, it will go and hash it again and give you a report of the SHA-256. In the case of the attribute, which is SHA-384, the browser with a SHA-384 hash compared it, it didn't match. Bottom line is we know why this has happened, and this is really, really, really significant because when we think back to that issue that we just had with Browsealoud, if people have had integrity tags which said unless the script looks identical to this, don't run it, like this just wouldn't have been a problem. Now, the browser would have refused to load the file, that may have broken other stuff --- At least you would have known. No, but at least you're not getting cryptominers. And you would have known that there was an issue, right? Well, yes and no. And this is where it's going to get a bit interesting if we go off on a tangent here. As an end user you would have known if you opened your DevTools and you looked at the error, but as a site owner, you wouldn't know. There's nothing to tell you as a site owner. The thing we're going to do in a moment will tell you as a site owner. It just occurs to me how simple this is too. I know. It's the easiest thing in the world. There are a couple of nuances with this though, and I'm going to give you one of these nuances here. Let's go with a CanIUse, and this is a great way of seeing browser compatibility. Yes, I have used this before. It is really good. I think you know where we're going to go once we start talking about browser compatibility. We'll look for SRI, and we'll see that Subresource Integrity works great on Firefox and Chrome and Safari. And, well, Edge has come along. So that's the good news. The next version of Edge will support SRI. That's good. The version, as of the time of recording, doesn't. Look, Edge has got a big roadmap of stuff that's going to be coming into the platform, some of it's behind the other browser vendors, this is one of them. Here's the thing.

Issues With Subresource Integrity Checking
When we think about the way that service was added in, the browser aware service, and when we think about where something like Disqus is added in an well, this is actually different to saying I would like to include an external library, which never changes, which is a static thing. So, we noticed when we looked at the source code back over here on Have I Been Pwned, I was including jQuery 2. 4. 4. That will never change. It will never change. If they want a new version, they'll run the version and there'll be a different version number. So I can do this integrity check very confidentially without having any concern about this breaking later on because they changed the source. Because if they did change the source, like if they made a bug fix, it would break, and it would be a different file. Exactly, new versioning, yeah. Now, that is different to something like Disqus. Disqus/Browsealoud, let's use Disqus because people are most familiar with that probably. When you embed Disqus you're saying, you guys can run the service. I'm going to embed your service, and then within there you can do whatever you want with the script, you can load whatever content you'd like, they put in iframes, they bring in images, they can insert media, there's all sorts of stuff they can do when you run that external service. Now you would have noticed before on Browsealoud, if we skip back to what the code actually looked like, they make the point at the top of this file here, they say, Do not copy or self host it. It's because this sort of stuff changes. If it changes we can't use SRI. Oh, no, of course not. Would they not version this, or are they saying we might change the current version? Now this is the thing. They might change the current version. So this is a very, very different model. So they're saying what happens if part of our internal implementation of almost like the black box would provide you, and that's probably a good analogy, this is more like a black box service, whereas a script file is like, it's just a library, it's yours, take a copy, get whatever you want. A very different situation with jQuery. So what happens if say in their internal implementation they want to change something like the way they do output encoding, what happens if they change the signature of the way they call an API or something like that. They're saying we reserve the right to change this within our internal implementation, you shouldn't create a dependency on the one version by doing things like taking a copy of the file. So now we've got a paradox, because we're saying we could actually change anything in this file, this is Browsealoud we discussed, you guys have just got to trust it, but by the way, we just had this really bad thing happen with cryptominers.

Content Security Policies in Action
So you see the challenge here. So, let's start talking about another defense for this, and it's Content Security Policies. And I know you have heard of CSPs before. Yeah. To be honest, the main issue, or the experience I've had with CSPs is that I run a bunch of WordPress sites and it doesn't really play well with WordPress, which is why my experience with them is not very great. You've mentioned your site, let's use your site. Sure. This is the bit where you didn't prepare for this, because you didn't know it was coming. It's alright. Troy Hunt's just checking my website, it'll be fine. Larsklint. com, I'm sure it'll be fine. Alright, so what we're going to do is we're going to go over to your website, and we'll come back to the bit about how you can do this with WordPress and everything, but I want to talk about the mechanics of the CSP first. So if we scroll down a little bit, we see you've got a photo here of you and Scott Allen doing another one of these Play by Plays, we're going to go down here, and I want to copy that image address. Now, in fact let's just open a new tab so we can see it. So this is served directly off your site. Now what I want to do is I want to show you my website, troyhunt. com, and what I'm going to do is I'm going to put your photo on my website, and we'll see what happens. So I'm going to go off to troyhunt. com. I might take my hero image --- _____ in the background there. We can try and replace me with you and see how that works out. So here's --- His site's going to break. There is like an anti-Lars filter on my site. Let's try and put that in. Go. No Lars. So my background image disappeared, but yours didn't go anywhere. That's disappointing. Not for me, it's not. Okay, F12, DevTools. Console. We've now got an area here that says Refused to load the image, and then we've got your URL, the URL of your image. And it says because it violates the following Content Security Policy directive: img-src 'self', and then it goes on and explains all the different stuff. Now, a Content Security Policy, among other things, allows you to whitelist the sources different content types were allowed to be loaded from. So, when we have a look here and we see it says img-src 'self', that means I can load images from self, which is the same site. It also says I can load images from c. disquscdn. com, referrer. disqus. com, stats. g. doubleclick. net. This is so that I can load images from Disqus, because that's used as part of the blog commenting engine, and it's also so that I can load images from DoubleClick, which is part of Google Analytics, because that actually puts a little hidden pixel image in there. To track it and everything. Exactly. And then you'll see there's some stuff around here. So you're kind of whitelisting what sites can provide content. Precisely. Now because larsklit. com is not on there, it said I will not load the image. Now this is really, super cool, because think back to the conundrum that we just had, which is that you're pulling in this third-party library, and you're pulling it in, let's see what URL it actually came in from so that we can get context. So that comes in somewhere off texthelp. com, for argument's sake. Now, what you'd do is you'd say okay, this needs to pull a script from texthelp. com, let's have a script source that allows texthelp. com. And nothing else. Well, and anything else that you need to make --- Yeah, okay, yeah. You might also find that texthelp. com needs to load images from cdn. texthelp. com. So then you go okay, now I'm going to have an image source for cdn. texthelp. com. It's a very conscious decision of which sites you allow. Very conscious, very explicit. And you go through and you build up this list of what would be allowed, and then if anything tries to get embedded in there, such as something like this, it's going to get rejected. Now that is enormously powerful, because even though we can't SRI the JavaScript file that we embed, we can say yes, you can run whatever you want in the file, but you're only able to pull these things from these places. But surely you would combine both SRI and CSP. In an ideal world you'd combine both. The reason why you can't here is because remember, Texthelp explicitly says do not copy or self host this file, and really the message here is that we might change it. So even if you're embedding it from them and you had an SRI hash, your risk then is that next week they change some tiny little bit of the implementation, and now it no longer hashes down to the same value and your SRI attribute, you've got issues. So, in an ideal world you'd do both. In this situation, we can't do SRI, but we can do CSP. Now they could still break your CSP because they could say, well now we're going to go and get content from somewhere else totally different, but I think the really important thing to point here is that because we just had this big watershed moment, and because it was such as issue for these guys, the hope is that services such as this say okay, well look, what we're going to do is we're going to tell you what we're going to load stuff from. Let's everyone agree. This is where we'll load the images from and the scripts from and the stylesheets from, and that's going to be it. And you can confidently create a CSP, and we can still confidently change the implementation, internal implementation, and then if anything wacky like this happens again, it just gets blocked. Yeah, that's fantastic. And again, it's not really rocket science, is it, you've just got to know about it.

Reporting Content Security Policy Violations
Well, let's get back to you, because you made the point that you're running on a WordPress blog, and I think what you're saying here is that it is difficult to add a CSP. Keep in mind, a CSP is usually a response header, and you'd add that to the server responses. And put it this way. So, I use WordPress because it was easy to set up right, which is why most people do it. You click a button and you've got a website, you click another button and you've got a theme, and you're going. There's no development needed or such, it's very quick. But the downside is that you need plugins for everything that you want to extend the website with, and can you trust the plugins? That's really the issue is that you don't know who made the plugin. So, it is a bit of a Pandora's box sometimes to open. This is the paradox, and most importantly people need to make a conscious decision about this. You've effectively just said I've got plugins and they can kind of do anything and I'm going to let them kind of do anything, and you've got to decide whether you're happy with that, and I would suggest that after yesterday as an industry we're less happy about it than what we were before. But, even then, for the sake of CSP, they can still usually be scoped within a pretty strict sense. So you can say they've got to get images from here, scripts from there, etc. One of the things that stops people adding a CSP to something like a WordPress blog, or in my case a Ghost blog, so I run on Ghost, the managed platform, one of the things that stops it is that it's difficult to add response headers to a managed platform, because as it effectively says --- Oh it is, yeah, very much. Now, let me show you how I do this on my blog, because obviously my blog does have a CSP. There's a couple little tricks here. So I'm going to get out of my blog, I'm going to jump back to the home page, and I'm going to jump into the DevTools, let's go to the Elements inspector, into the head, and I'm going to just scroll down until we get to my CSP. And you'll notice that I do have a CSP, here it is. Content Security Policy. And this is kind of cool because you can add a Content Security Policy via a meta tag. It doesn't have to be via a response header. The reason why I can do this with Ghost is because Ghost has a paradigm called code injection where you can add meta tags into the head within the UI, plus I run a totally custom template, and I can add whatever I want into the template. So you can control your template as well. I can. Now the template is just markup, so this is still not response headers. I can't do anything with response headers, but I can do stuff with markup. I'm sure this can be done in WordPress as well, like you can definitely add meta tags. Yeah, so if you can add meta tags or if you can add anything else in terms of content into the head, then you'll be able to do this. Most themes in WordPress will allow you to add meta tags, so that might be an avenue. Okay. So this is looking good, but there's a twist. Remember earlier on when you said the Coinhive situation where the file was modified and we sort of discussed the fact that someone could see whether their browser session was trying to load Coinhive, because they can jump into the DevTools, they could see that warning, but the person running the site couldn't. So the person running the site has got no idea. So let's take the Queensland Government site. The Queensland Government, our state government, would have no idea, short of someone reporting it to them, this would happen. CSPs have a really, really neat feature, which is the ability to report violations. Oh, really? Yeah. So they have this construct called a Report URI, and there's this little Report URI directive that says, when the Content Security Policy is violated, send a report to this address. Wow, and you can build tools around that and monitor and whatever. Exactly. Now, what makes that really cool is that in a case like this, what we could do is say, well, if we suddenly got like a Coinhive implementation sitting on the site, and it violates the CSP, send me a report, and then I know there's something on my site. So the very, very first person that sees that on the site, it violates the CSP, I get a report. That's really cool. You can't do that with a meta tag. Ah, and you can't do that with an SRI either. No, SRI doesn't have an implementation. It'd be good if they did actually, that would be a nice thing. I think we're probably going to go that way because we're getting Report URI on multiple things. I'm going to show you another example. Right. So, I can't have a report implementation here, I can't Report URI, but let's actually show you something here. I'm going to show another trick. We're going to go to my Network tab here, I'm going to --- that's already cleared anyway, but we'll go there. Nothing in the Network tab, I'm going to go back to my heading here, I'm going to go back to the images, I'm going to put you back in here, like so. Okay. My background disappears. If I go --- you're still not there, I know it's terrible. I go to my Network tab, and I do actually have a CSP report, and if I scroll down a little bit, we'll see that this does actually send a JSON payload, which explains everything and says hey, the blocked-uri was this last claimed address, the document-uri was the root of my website, the effective-directory was the img-src, so that's what it violated, and then down at the bottom it shows that again, violated-directive: img-src. Now imagine you've suddenly got all of this information coming to you. As the site owner of troyhunt. com you could go, why is someone trying to put Lars on my home page? No one wants that. Exactly. But now I have the information. But I had also just told you that you can't add a Report URI directive to a Content Security Policy meta tag. So where have you cheated? Very good, where have I cheated? There's my CSP, I've just clicked on that and it's highlighted a great big block there. Just under this I've got two things that are interesting. One of them is I've got this little script tag here of type text/json, and in here I'm configuring a bunch of keys. And you'll see here actually that I've got a key that talks about a reportUri, and it says troyhunt. report-uri. com. This is the endpoint that I'm reporting to, this is actually a service that, you know this, but Scott and I run this service where you can send your reports there. So we've got that. And then down just under that you'll see that I've got a script embedded from cdn. report-uri. com, and what this is is this is a new service that we've launched called Report URI JS. And the really clever thing about this is that there's a little event handler that listens for when the browser raises an event, which is the CSP policy that's been violated. It then refers back to that JSON a little bit further up, pulls some keys from it, grabs that event, and then sends it off to the location that you define. Ah, so now you can use your meta tag to put in a CSP and use the Report URI JS file to kind of hook it all up so that it listens for those, --- That's it. --- and then the browser doesn't have to send them, which it can't, but you do it instead. Well, yeah. So the browser still sends it, but what we're doing is we're orchestrating it with JavaScript. What I meant, the browser doesn't kind of natively send in like --- No, it doesn't. If it was in a response header it would do it. Now you can go and use this script and send it to whatever endpoint you want, you don't have to send it to our service. You'll notice also we've embedded the script with an integrity attribute. So just in case something on our end changed, it wouldn't break all your things or it wouldn't go and Coinhive all your things, it would break the script. And what you're saying is you're actually not changing this, this is a library. We're not changing it. And hey, if you're paranoid, just save it locally, like just download it. Now there is something else that is kind of cool about this as well. We saw that Edge didn't have support for SRI, Edge does have support for CSPs, and it does have support for being able to report to Report URI. So even though Edge doesn't get the benefit of SRI, Edge can still do everything that we see just here. Cool. And in the next version it will do the SRI stuff anyway. Yeah.

Adding Content Security Policy Exceptions
So could you kind of mimic the SRI function with a CSP? No, because they're sort of complementary technologies because you've got to remember, SRI is saying this is precisely what my file must look like. If it doesn't look precisely like this, then just don't run it. CSP is saying here's all the places that file, or anything else on my site, is allowed to get content from, and if you try to get it from somewhere else, don't load it. And ideally you want them both together, and here's a great example, they're both together here on my blog. We've got SRI on the Report URI JS implementation, and we've got a CSP, which makes sure that anything else that gets abnormally loaded into the site, I was going to say maliciously, but the way we put you in was then, you know, it's just us mucking around. So yeah, it blocks that sort of stuff as well. Not only blocks it, but reports it too. And could you then have a CSP just for that image, like say you wanted to have me on your site, but just that image, and nothing else? So what we could do is we could jump up here into our img-src directive, and after this we could literally have larsklint. com. Now, of course we're just adding this into the DOM, I would actually have to add it into my site and then it would get served to everyone. But could you do it just for that image? So you can. You can actually scope this down. So we could actually go back there like that and we could paste the whole thing. You can. Okay, cool. You don't really want to get into that habit though because you're going to start to get a very, very clunky CSP. So if you have a look at mine, mine is mostly services that I use, and then things beneath there can be downloaded. Now, in fairness as well, sometimes that is actually quite a liberal definition. So for example, anything. twimg. com, because when I embed a tweet in my page and Twitter has an image, it pulls it from a whole bunch of different subdomains of twimg. com. In other cases, I've actually been a bit stricter. So for example down here, we can see that I can embed a gist, but only a gist that I have posted. And the reason why is because if I had this in here, and this is part of the script source directive too, so if I just had gist. github. com, and someone managed to, let's say, get XSS on my site, they could go to GitHub, they could create a new gist with their malicious script in it, and then embed it in my site because I'm trusting it. Now, because I've got this path in here, only I can do that. And in fact to be clear, only a gist from my account can be loaded into here because it has to be in that path. And I think that's an important point is that with CSP, yes you can add whatever you want and everything, but just be mindful of things that contain others' content. So if you were to go and do something like start up google. com and then there was a Google path somewhere, some subdomain of Google where you could upload things, and let's be clear, I was going to say then you've got a risk, then you were back in the camp with the 96% of other websites that have no CSP protection whatsoever, because that's about the number, only about 4% of websites have a CSP. Maybe more after the weekend that's just passed.

Issues With the Cross-Site Scripting Auditor
Alright, something a little bit different, cross-site scripting. I've heard of cross-site scripting. Well, and actually I realize we just did CSP, which in some ways isn't that different. I mean, a lot of CSP is there to help protect you from cross-site scripting. What I wanted to look at is the native browser defense, particularly in Chrome, against cross-site scripting attacks. And I don't know if you know this, a lot of people don't know this, there are native defenses within the browser to stop cross-site scripting from happening, and then there are ways to know about it if it does. Okay, I think I knew that there were some defenses, but, I don't know what they are. Let's be really clear about this. We're going to look at Chrome. It's very different in different browsers, because this is really up to the browser to make some decisions about what's going on. Now, I've got a really basic demo here I want to show, and what I'm going to do is just reload this page, because you've got to see what happens when it first loads. So I'm going to F5 this one, and you'll notice that when it reloads, we've got a JavaScript alert that pops up, and the alert just says 0. Let's Ctrl+U into the source code to have a look at this, and you can see on line 17 it's just got an alert box. Now, here's where things get a little bit interesting. What if I was to pass everything you see on line 17 in a query string? Oh, yeah? Because have a think about it now. So Chrome is going to be saying, hey, you just went to a website, you passed a piece of JavaScript in a query string, that precise JavaScript then appeared in the source code and executed. That starts to smell a little bit fishy because I, as an attacker, would really like to find cross-site scripting vulnerabilities where I can put my script in a URL, send it to other people, they click on it, they run my script. Gotcha, yeah. And what can you do if you can run JavaScript in someone's browser? You can mine Bitcoin. Yes, you can mine Bitcoin. Good answer. The other answer is just about anything. I mean, you can, we know that you can access external resources because you can add the, and let's be clear, the Monero coin miner because people will get upset if we say Bitcoin, because they'll say Coinhive, anyway. Apparently there's a cryptocurrency thing, they don't like you mixing them up. Docoin. Again, another one altogether. So, one thing is we can embed that sort of stuff, we can make external requests to request things like malware, we can rewrite the DOM so we can put in a login page there, we can rewrite form actions so when you press the Login button you don't post to the login page, you post to someone else's site. There's a lot you can do. It's very appetizing for someone with nefarious purposes. Right. So effectively, if they can send you their payload in the request, and then the browser just reflects that out exactly as seen, you're going to have issues. So with that in mind, let's have a look at this link. Now, if we have a look down at the bottom left of the page, we can see that this link is going to send a query string called src, and the value of it is exactly that script we just saw before. So let's click it and see what happens. Okay, so this page actually looks very similar to the one we just saw before, and I'm going to do the same thing again with an F5 just to reload it, we see we get the alert, which is what we had before, same old deal there. There's something different on this one though. So the previous page I didn't have any custom response headers or anything like that. This one does. I'm going to open it up so we can see what's in there. Now we're going to talk about this error in a moment as well, but I don't want to drill into this just yet, so we're just going to clear this off the screen. Network tab, let's give this page a reload, get rid of the error, have a look at that first request, and in our response headers, you'll notice down at the bottom we've got an X-Xss-Protection header. Now this is set to 1, so it's turned on, the mode is block, so it will actually block the page if this XSS attempts to run or if the XSS order that picks up XSS, which is what we saw before, but now I've got a report path, which is interesting. And this is very, very similar to the situation we saw with Report URI just before where we can say if the XSS Auditor fires, send a report over to a location. And is this Chrome specific? That's actually a very interesting question, and we're going to come back and see some very, very Chrome specific stuff in just a moment. But the principle, again thinking about the purpose of reporting, is that if something goes on with your site that you weren't expecting, you can be told about it. Especially when it's relating to some of these cross-site scripting --- Yeah, right, the security stuff. You want to know if this stuff is happening to you. Now, this is where things start to get a little bit interesting. I'm going to reload this page, I'm going to get rid of the alert here. Now let's have a look at the error here. It says, Error parsing header X-XSS-Protection, insecure reporting URL for secure page at character position blah, blah, blah. Oh. And this is kind of odd, right? Because the Report URI that we saw before was an HTTPS URI, and in fact if we go back to the Network tab and we have a look at it, that was definitely secure. But here's the trick. This host name is different to this host name. To your question about Chrome --- actually, let me answer this with a demo. If I go to my blog, I go to a recent blog post here, this was the one we just spoke about before, Supply Chain Paradox, we're going to let this page load. This page embeds a couple YouTube videos. Okay, so far, so good. DevTools, Console, I've got two errors there. Google has decided that Chrome should not be able to report when the XSS Auditor fires to another origin other than the one that it actually fired on. That doesn't make any sense. It doesn't make any --- look, they have a rationale, I don't think it makes a lot of sense. I'm going to actually load up a little piece of code here, in fact this is a diff, this is a Chromium project, and we can see the piece of code just here. This was only added very, very recently, and it says hey, effectively if the origin that you're trying to report to is not the same as the origin that you loaded the actual page from, well, then we're going to reject it and we're going to see the errors that we just saw before. And the irony of showing it over here is that Google's own website is doing this at the moment. This is happening because --- So they fall into their own trap. So they've fallen into their own trap, and Scott, who we mentioned before, and myself, have been talking to them and going, are you really, really sure you want to do this, because there are parts of your organization that think you shouldn't do this. So, I think that the important point to make here is first of all, the XSS Auditor, it's very browser specific, that's the way Chrome works, other browser don't work that way. Some other browsers don't implement it at all. Go and try different browsers, they work differently. The second thing is the reporting, the way browser vendors implement this can be on a bit of a whim. This came out of nowhere, and we've actually been building out features to be able to take these reports as well. I was going to say, because that makes sense. You could get, like anyone with a decent amount of data will have a login parser of some sort, whether that's a different service, it's very likely to be. Exactly. Because think about the situation here with YouTube. Does YouTube really want to run endpoints to receive XSS reporting on the same service or the same host name that they're running like the video streaming thing on. Very unlikely. Probably not. So, this is sort of one of these things where it's like, there's some cool tech there, but it's also still in a state of flux, and I don't know exactly where this is going to land. No, because they just changed it, so they'll change it again maybe. So, I don't know that we really can include it a lot here. Actually, I will give you one conclusion. The XSS Auditor that we see over here that does this sort of thing, you never want to rely on this. As someone building a web application, it's not like, ah, there's a native defense, I don't need to output encode my untrusted data or something. So this is always just another layer, and you've got to be resilient whether this happens or not, because let's face it, the implementation of this is a little bit inconsistent. Yeah, and again, because we were talking about the spectrum before, if you just leave everything to the browser default or whatever, you're going to be on the not secure end of the spectrum. With you on that.

Improving and Testing HTTPS
HTTPS and the Browser
Alright, let's do something different. When we look at my blog, how do we know it's secure? There's a little handbag. The somewhat of an in-joke is that apparently many people actually identify the padlock as being a handbag. True story. So now it's a handbag. It's like you go to the shops, you need your handbag, some of us need a handbag before we buy our things. Anyway, moving on. So, we get on our website, it says secure. Now, there is a whole bunch of discussion to be had about whether secure is the right word. Because many of us probably know that we see secure and we see the padlock and we see the green bits because it's HTTPS, and HTTPS gives you confidence in confidentiality, integrity, and authenticity of your transport layer. It doesn't mean that you don't have like a cryptominer running on your site or something like that, it just runs over it securely. Alright, so this says secure, we know it's secure. Let's go to our local Aussie news site here. How do we know this site is not secure? Well there's an information box. It doesn't say not secure, but because it doesn't say secure, you infer that it's not secure. This is a really important observation, because what you just said is when you go to a site that's served over HTTPS, it explicitly tells you that it's secure, there's a visual indicator. When you go to a site that's not secure, because there is a lack of a visual indicator, you imply that it isn't the positive visual indicator, therefore not secure. And this is kind of this odd state we're in at the moment, which is like insecure by default, but it's changing really, really rapidly, and I'm conscious we did a course where we talked about HTTPS not so long ago. Yeah, so if you want to see that, go and watch that. Go and watch that. That was like six months ago. It's all still relevant, but stuff has changed even in the last week, and we're going to get to that in just a moment. So, we have this situation here where it's like okay, anything that's served over HTTP doesn't give you any visual indicators at all. And then we scroll forward a little bit and we get to around about January 2017, and what started happening then, I'm going to log off hackyourselffirst, here's my demo-vulnerable site. You can go to this site and hack away. Go to this site, do whatever you want, don't go to jail. It's actually you won't go to jail. This is made for Pluralsight for a bunch of my courses. We've now gone to the login page, and have a look at how it changes. Yeah, it says Not secure. Alright, so this is important because this is a positive visual indicator, and positive insofar as there is something there, it's not like the absence of something causes us to imply something else. So this is what we started seeing in both Chrome and Firefox in January 2017. And they started saying look, if you go to say a login page and on that login page there is no HTTPS, then you're going to get this warning because you actually need to protect login pages. It's actually kind of important, because if you don't, then someone could modify that traffic on the fly. You want to know about that as a consumer. Exactly, that's important. Now, there's another nuance here as well. We're going to show you a couple of other nuances here. Let's do this. Let's go back to the news. com. au website, and what I want to do now is just go to the search. We're in the search box, the browser toolbar still doesn't have any positive visual indicator if it's secure or not secure. We're going to type a single character. Now we're Not secure. Yeah, right. So what they started doing in October 2017 is saying look, if you enter text into a field, you need to be confident that that's going to be protected. Because what happens if this page was modified when it was loaded, what happens if it doesn't post securely and you're entering something sensitive into the text field? Now that necessarily mean a password. I might be that you're on a healthcare site and you're entering in medical conditions. I was just about to say it could be some privacy data anyway. Exactly. So, what's happening here is we're continually pushing up the bar going make it harder and harder and harder for websites to do their own thing because we're going to shame them. But why wouldn't they put this Not secure as soon as they know there is an input box? Well, because they're saying that unless you actually enter something, we don't need to put it there. Now, I like the way you're going though. So what we've got to keep in mind is all of this is incremental shifts. So we have the January 2017 thing with the passwords, we had the October 2017 thing with the text box. The other thing that happened in the in October is that if we go incognito and we go and to news. com. au --- Oh, it just does it --- --- it does it by default. And the reason why is because Google is saying when you're incognito, you have a higher expectation of privacy. Because this is usually why people go incognito. And what we're going to do as a result is we're going to put that on the screen. Now, let's move onto the next thing. So this is the future bit. Only last week, in fact this was the 8th of February, so this is like literally 5 days before recording. We heard that Chrome is soon going to mark all unencrypted pages as Not secure. Okay, which is what we just did. Every single page, which is what we just touched on. And if we scroll down a little bit, we'll see that this is going to happen as of Chrome 68, which is going to hit in about July 2018, and by the time people are actually watching this you may well be very close to July 2018 when this is actually hit. Now, I'm conscious also that some people say ah, yeah, but my site doesn't have anything sensitive, it's like you're not submitting your passwords, I don't have bank account info, I don't need it. Now, I understand the sentiment. What we've got to remember is that when anybody goes to an HTTP page, an unencrypted connection, any adversary who can get in the middle, it might be an ISP, it might be a state sponsor, it might be someone sitting there with a Wi-Fi Pineapple. Google that one if you don't know what that is. Anyone who can get in the middle of that traffic can modify, they can serve up malware, they can redirect you to phishing pages, and even though your site may not have been important, that could be the thing that becomes the vector to loading up nasty stuff. Exactly. And I've just put a resource up on my screen here, doesmysiteneedhttps. com. A great big YES, you guys can go to the site and read all the reasons why, even if you don't think it does, it actually does. And even if you don't agree, your site's going to get shamed. So you want to fix that. And it's so easy. Like seriously go and watch either Troy's course on HTTPS or the Play by Play we did on HTTPS as well, and all the ways that it's easy to implement. I did this in a workshop the other day. I did this with Ben Cull, we know Ben, Ben is another Play by Play guy, literally in the workshop over the space of about 5 minutes, we HTTPS'd his entire site, upgraded all insecure requests, added HSTS, redirected 301 from HTTP to HTTPS, the whole thing we did it in about 5 minutes flat via Cloudflare for free. Like it can be dead, dead, dead simple. That's exactly what I've done with my site. There are other courses out there that do that.

Using Content Security Policies for Upgrading and Reporting
Okay, so we just talked about HTTPS and we're sort of wrapping up by saying it's amazing, it's so easy, it's such a simple thing to do. One of the challenges that people have when moving to HTTPS is that if your page is HTTPS, then everything beneath it, like the images and the JavaScript, everything else has got to be HTTPS too. And when you and I did the Play by Play with HTTPS we talked about a technology to help you do that. And I want to recap on it very briefly and then go further than what we did before. So, I'm on a demo site here, and this particular demo site is showing an image on the screen, and if I go to the element inspector and have a look at this, the element inspector actually says it's loaded over HTTP, yet we still have the green padlock, the Secure, and the HTTPS. Now do you remember how this happened, because we did do this together? I'm sure this was a CSP. Yes, you're right, it was a CSP. So, I'm going to show you how it does this. I'm going to go to the Network tab, I'm going to reload the page, and then we're going to look at this first request, and right down at the bottom of the Response Headers we see Content-Security-Policy: upgrade-insecure-requests. And this does exactly what it sounds like. It will take this asset, which was embedded insecurely, and it will go no, make it secure. And this is fantastic because it fixes all the embedded stuff that's not secure. Do you remember the browser compatibility story? Well, when you put it that way, my memory is very poor, just on that --- It depends on the browser you use. --- this also lets you then find out which of your resources cannot be served securely because it'll break, right? Well this is where we're going. So, what would actually break? Let's go to badssl. com, because this has epic examples of SSL gone bad. And what would happen is if we go down to mixed, this is what breaking looks like. So this image is embedded insecurely, so there's our HTTP, but we can see up in the address bar we've lost the padlock, we've lost the Secure, we've lost all the green. Upgrade-insecure-requests fixes all that because we've embedded this image just the same way as badssl embedded theirs, but because we've got the CSP response header, and incidentally that can be in a meta tag too just like we saw on my blog before. So what if this resource didn't exist as secure transmission --- well then you're going to have a problem. And that's good, because you'd see it. Well, you would see a lack of something. Yes. But here's the thing. You as an individual end user loading this in your browser may or may not see it, but how does the site owner know? Well we need the reporting. Alright, very good. I'm listening. You're making this very easy. Okay. So, if I scroll down just a tad further, you'll see that we've got a second Content-Security-Policy there, but it's a Content-Security-Policy-Report-Only, CSPRO. Now, what this one does. First of all report-only means it's not going to block, but it will send a report. Now it's going to send a report in the same way as what we saw just before on my blog, it could send a report, except in this particular case it's a response header and we can put the report-uri directive, which you see a little bit further, in the response header. Remember we couldn't put it in a meta tag, we had to have the funky JavaScript? So, we've got a report-only. It says, default-src https. And what this is saying is that every single resource on the page must be served over HTTPS. If it is not, it violates the policy. Now, why do we have this here? Well, if we have a look at this element, we see that it's insecure. There's also a JavaScript file underneath this, also embedded insecurely. Now because we have got that CSP report-only, because we've got a report-uri, both of these assets should violate the CSP and they should cause a report to be sent off to that Report URI. You with me? Yep, I'm with you. So let's go to the Network tab and we see two requests down here. This one just here, and this one just here. Yep, reportOnly. We've got two because we have two assets embedded insecurely. If we scroll down and we have a look at the report payload, we're going to see just like that CSP report we saw before, enough information to figure out what on earth happened. So, the blocked URI in this case was cdnjs. cloudflare. com because we tried to get the JS from the Cloudflare CDN, the document-uri is the address of this page up here, and the effective-directive, so the one that it violated was script-src, because it tried to embed a script. Now what this means is that if you were there as a site owner watching your reports come in, you can go hey, look at this, I just realized where we've got a broken asset, where we've got an asset that was embedded insecurely. If you're on Chrome or Firefox it would have been upgraded and it's going to be secure, that the compatibility story was unfortunately Edge doesn't support upgrading secure requests, but because I just got a report, I can go and I can actually fix the way that resource is referenced. So, what you're saying is that you can use the CSP to upgrade everything, and then we can use the CSPRO to actually report on it without breaking anything. So this is like the best of both worlds. Everyone who can possibly get upgraded gets upgraded, and you get told every single time something needed to be upgraded. Okay, awesome. So, that is CSP, upgrading secure requests, and the ability to report on it. Let's move on to something slightly different.

Advantages and Disadvantages of HTTP Public Key Pinning
And I want to talk about HPKP. Have we done HPKP before? Yes. Okay, don't do that anymore. I'll tell you what, let's jump over here. I'm in the browser, I've got Yahoo open. Now what I want to do is jump into the DevTools on the Network tab, I'm going to give Yahoo a refresh because I want to look at the first request; this will be the one to that main page, Response Headers. Now, here's what we've got, this is HPKP. Public Key Pins, and incidentally these are reporting only, which is kind of interesting. Let's talk about Public Key Pins. So, when you go to a website that serves a certificate, so long as the certificate is valid for the site, it doesn't matter who issued it or where it came from or when it expires, so long as it hasn't expired yet, all that matters is it's been issued by a CA that your browser trusts. So you can go to _____. com and you could get a certificate from Let's Encrypt or from Comodo or from all sorts of different sites. Now, one of the things that we're a little bit concerned about is what happens if an attacker manages to get a certificate issued from a CA in a fraudulent fashion? Ah-ha, and then use that instead. Yes. And now this would also be an attacker who can get in the middle, because this is where they want the certificate. They want to do the man in the middle thing. Now, we have a very noteworthy industry precedent, which is DigiNotar. And DigiNotar was a Dutch certificate authority. We learned that they got compromised allegedly by the Iranian Government who managed to issue certificates for things like Google WorldCard, like startup Google. com, and then because they could man in the middle the traffic, they could sit there in certain DigiNotar certificates and every single one of their citizens, they still see the padlock and the green and the Secure and all sorts of stuff. If they inspected the certificate they would have seen it says DigiNotar and not Google CA for example. I'm guessing someone did at some point. Well, eventually it was discovered through all sorts of other ways, but the point is is that because they managed to compromise that CA and get the certificates and serve them up and the browser trusted them, people got man in the middled. And what we started to say was we really need a better mechanism. And we did have a mechanism, and we do have a mechanism that we use particularly on things like client devices, like mobile phones, which is Public Key Pinning. It's sometimes abbreviated to PKP. And what a Public Key Pin says is not only must you have a certificate, but you must have one with this public key. Now it doesn't have to be the certificate itself, it could be an intermediate certificate, it could be the root CA, you can have many public keys as well. And HPKP is what we now see on the screen here. This is the implementation of Public Key Pinning over HTTPS. Now, Yahoo is using this here, and what they're actually saying, first of all this is report-only, and in fact I didn't even notice it report-only when I was setting this up, but that's interesting, we'll come back to why that might be significant there. It's report-only, it's got a max age, and what it then says is here's a whole bunch of different pins, and you'll see SHA-256 hashes of the public key. And what they're really doing here is they're saying hey, once you load this site, so long as the certificate that's being returned on this site has a Public Key Pin that's in this list, for this many seconds from now, you must also return that public key. So if someone gets in the middle of your traffic later on and they insert their own certificate, it's not going to be one of these public keys, the connection is going to be dropped. Yeah, sure. Here's another problem, and this is probably less a problem with Yahoo who's just a massive organization, but what happens if you're a website who, let's say for argument's sake, the developers have added the pins and there's an IT group that's managing the certificates, and one day the IT group rolls out the old certificate and puts in a new one. What happens to people that have seen the old pins? Well it doesn't work. It doesn't work, it breaks. What happens if the certificate expires and you don't have other pins that are pinned in someone's browser? It breaks. It breaks. How do you fix it? Well you've got to put a new certificate on there then. Well they won't have the pin for that. Oh. So you've got to set up the whole thing again. What? But what does that mean? That means you've got to get a new certificate with new public keys, with --- And every person who's seen this before won't have the public key though. So they will have to --- how do you clear someone else's cache? Well, so there's a couple ways of doing it, and none of them are pretty. One way is is that you say to every single one of your customers, please go into your net-internals in Chrome and delete the Public Key Pin. That'll go fine. Good luck with that. You're a bank and you're telling all of your mainstream consumer customers, please go into net-internals. Not going to happen. The other thing is you say, can you please go and use Microsoft Edge? No, no you cannot. Or Safari? And this is the problem. There's this term which has become known as HPKP suicide where we have seen this happen before --- That sounds dramatic. --- where people have literally committed, and actually literally is not the right word to use here, their site has effectively committed suicide because it's migrated something and killed it for anyone that's seen it before. So you've got this situation where the ramifications of getting it wrong are dire, extremely bad. So that's one thing. Now here's the other thing. If you are able to compromise the certificate authority, which was trusted by all the browsers around the world, which site would you start generating certificates for? Google or Stack Overflow or --- Okay, Google, Stack Overflow. Larsklint. com? Possibly. Nah. No, no, no. I'm sorry, no. Not larsklint. com, not troyhunt. com, not haveibeenpwned. com, not just about every single site on the planet, because the thing is that that is such a valuable thing. You're going to use that against the highest possible target websites in the world. Because certificate authorities are held to such high account that these incidents are extremely rare, and if you have that access, you're going to use it for some really high value target. Like banks or government stuff, or you know. Yeah, exactly. If your site is not banks or government stuff or one of those, you don't need HPKP. Because what you're doing now is you're saying there is this extremely remote situation, which is very, very unlikely going to happen to you, and you're going to use a technology where if you get it wrong, which is very, very possible, you'll kill your site. We're starting to go, maybe this is not such a good idea. No, maybe not. So I want to show you something here. Now first of all, if we scroll down just a little bit you'll see that there is actually report-uri here as well. And in fact, we can see that their report-uri is csp. yahoo. com. So Yahoo have got their own reporting endpoints stood up I would imagine to do both CSP and HPKP. And, to the earlier point, they are running on report-only. Now we saw report-only on CSP just before, it's also in HPKP. I'm actually okay with this because this doesn't break anything. So if you're running HPKP report-only, nothing's going to go wrong. No, because you're not blocking anything. You're not going to block anything. You might start getting a very large number of reports though --- Yeah, if you start changing --- if you didn't do your key management right. Okay. So, one other thing I want to show you here. Google is intending to deprecate HPKP. Well, for good reasons, yeah. I mean, this is the interesting thing, because it's very rare that we see something like a security defense that is actually killed off. But this is really interesting, and you'll note here they say we would like to do this in Chrome 67, which is estimated to be released to Stable on May 29, 2018. I'm going to take a stab at it and say that's probably around about the time this course goes in, or very close to it. So, HPKP has sort of become a pretty pointless thing. Interestingly when I was preparing for this I knew that GitHub had previously used HPKP, and I thought, well, I'll use GitHub as an example. Went to GitHub, no longer doing HPKP. So we're actually seeing sites start to strip it out. I used to have it in Have I Been Pwned, stripped it out. So people are paying attention to this, and I guess --- I think we've seen enough incidents where it's gone really, really bad. I mean, just as a quick example. In 2016, Smashing Mag messed up their HPKP and have written a story here about it. Be afraid of HTTP Public Key Pinning, and they go on to talk about what went wrong, and effectively the way they killed their site. So, yeah. It was a good idea, but it was solving a problem that didn't really need to be solved that way. There's a better way of solving this problem in a way that is reversible and it won't mess your things up. Have you heard of Certificate Authority Authorization?

Explaining CAA
Oh, no. It's another acronym, CAA. Yeah, that's why I was looking at CAA. I've seen it somewhere, but I don't, no, no. We've got acronyms for everything in this industry. Alright, let's talk about CAA. What CAA does is it says, you can at a DNS level declare which certificate authorities can issue certificates for your domain. Every certificate authority has to inspect the DNS records, see if they're CAA, and if there is, they have to adhere by it. So if you now have a CAA record and you have a very, very finite number of CAs in your CAA and someone does compromise another CA, and so long as that CA still goes through and actually does the check, and if they don't do the check and they issue it anyway, it's going to show up in certificate transparency logs, which is a whole other story we're not going to get into, but every CA has to check it. And I want to show you how simple this is to implement. I'm going to go over to a website here, and this site is DNS Spy and it has this little feature here to validate your CAA records. I'm just going to put in troyhunt. com, and it comes back and it says hey, your DNS records for troyhunt. com say that you can issue certificates from Comodo, DigiCert, GlobalSign. You can issue both certificates and wildcard certificates. And, if anyone else tries to issue a certificate and they're not on that list, I'm going to get a mail sent to domains@troyhunt. com. So I'm going to get told about it. Yeah, that's clever. And this works really, really well, and the reason I know it works really, really well is I've recently accidentally tried to issue a certificate from another CA, it's a long story, tried to issue it and they came back and said no, sorry, we can't give it to you. Now, the really cool thing about it is that if you mess this up, it's a DNS record. So you go in and you change the DNS record, and then you issue the cert. So, so long as you've got control of DNS --- Which you would assume that you would have for your domain. As an owner. Conversely, if an attacker gets control of your DNS, well, this is going to be a problem, as well as many other things are going to be a problem for you too. So yeah, that is a different story. But CAA is great because CAA does most of the important things that HPKP did without any of the risks. Yeah, right. Now, this takes minutes to set up. I've got troyhunt. com sitting behind Cloudflare, in Cloudflare there is literally a CAA record you can go and add. When I say minutes, it's probably like less than a minute because they actually give you a shortcut which says just trust Cloudflare CA, and it's like job done, all there. So if you don't have CAA turned on already, go and do it because it's just the simplest thing in the world and you really can't screw it up. I'm going to do that. Yeah, do that. Because I use Cloudflare as well. And you're on Cloudflare too, so go in there, there's a CAA record, and there's a little helper that tells you how to do it. Sweet.

Using SSL Labs to Test Sites
Okay, cool. So, there's one last thing that I want to look at in terms of the whole HTTPS SLL thing, and that's SSL Labs. Now I think you've seen SSL Labs before, haven't you? No, no. I've heard of it, but I've actually never really looked at it. Well this will be new. So, I've just jumped over to SSL Labs, it's run by Qualys, and what this allows you to do is, I'm reticent to say scan a site, because this is really not scanning a site. What it's going to do is it's going to say here is how a site is willing to communicate over HTTPS with clients. Now what this means is that we can look at any single site in here, this is not hacking or tearing it apart. So here's what I'm going to do. I'm going to go and enter a bank in here, and I've picked Barclays. You can go and do this to any website running HTTPS, and again, all it's going to do is tell you the way it will communicate. We're not disclosing anything that isn't immediately publicly accessible to everyone. So I'm going to put Barclays in here, and what Qualys is now doing with their service is they're going, hey I heard you want to talk. What are the cipher suites that you want to support, what are the versions TLS that you support? Will you support CAA? So we'll see in a moment whether Barclays supports CAA or not. And it will go through and test that. It will also test things like HSTS. Remember we saw HSTS in our HTTPS course? This is the technology that helps you ensure that connections are always made securely and they never drop back to HTTP. And we're going to let this run, and it's just wrapped up now. I've seen this before, like the screenshot of something like this, I have seen that, I've just never run the test I don't think. So these are very frequently shared in order to illustrate the HTTPS implementation. You'll see it gives you a grade here, a B grade. A B is a B, it could have been an F, it could have been a lot worse. It's not an A+. If we scroll down a little bit, we start to see reasons why. So for example, the server still uses SSL 3, so that really kind of got killed off with the POODLE bug back in 2014, we don't want to say that anymore, it still accepts RC4 ciphers. It may well be that Barclays has got clients with older devices that they're still going to support that can't support the modern stuff. There may be a reason for this, I don't know, we'd have to try something there. But what I find really interesting about this is the amount of stuff it can tell you. I mean, for example, what they've done really well here is they've got HSTS there, which is the thing we just mentioned in order to upgrade insecure connections. Which is what I did to my site after the last recording. Right, right. Okay, good. So, as we scroll through we start to get an idea of all the different things this site does. So for example, down at the bottom we can see DNS CAA, they don't have CAA, we've just spoken about what CAA is. Frankly, 99% plus of websites don't have CAA anyway. Yours is about to because you're going to do it after this. And then as we scroll through, we'll see things like, what's a good example here? TLS protocols supported. So they're supporting TLS 1. 2 --- Which is okay, I guess. Well it's interesting. Well, 1. 2 is the current generation, 1. 3 is what is coming, there are some services that support it. Cloudflare you can enable 1. 3. What's a little bit interesting here is they don't support 1. 1, but they do support 1. 0, and of course the one that's really something they need to move away from here is supporting SSL 3. And there we see Cipher Suites, then we see Handshake Simulations with different devices, we see are they at risk of the down attack? No, the BEAST attack, the POODLE attack, we see --- I love those names. I know. It's branding 101, it's got a cool name and a logo. Get those two things right, you've got yourself a news headline. And the really interesting thing about all this to my eye is that it makes you think about just how much goes into an HTTPS implementation, and what's really worthwhile whatever I'm doing, is if you're running a site, plug it into SSL Labs, have a read of what comes back. Now, you might find some stuff that's capping your grade, you might find stuff like DNS CAA. It's not going to cap your grade, but it's going to pop up there in orange and go, maybe you shouldn't do this. You know why you should do it now as well. Yeah, well that's right. But it's just, it's a nice shopping list, right?

Interpreting Results of Online Security Tools
It is. Now I'm glad you said that, because that is a really neat transition into the next thing, which talks about shopping lists. That's amazing. I didn't plan this. We didn't plan this, but here we are. I want to look at a couple of different tools that allow you to get a good idea of the security posture of other sites. Sites like, I don't know, like larsklint. com Oh boy. And this is why we didn't rehearse this one. Now, this is run by Scott Helme, so we've spoken about Scott a couple of times. Oh, dear. Oh, dear. Now actually, you know what, I'll make you feel better. Secruityheaders. io, troyhunt. com. It's going to come back with a very, very similar rating. Also, you're now at the top of the recent scans with a D. Oh, that's all right. Actually, sorry, you're now at the second to the last. Yeah, alright. Now, what I really want to talk about here is about what these scans mean, and what I think is really, really important, we will do yours, is to understand what each of these findings actually means in terms of security posture and how important it is. Because what you'll find is that sometimes it's actually not as important as you think it is. The trick is is that you've got to understand what they mean. So let's go through some of the findings on yours, because these are kind of interesting. There's a whole bunch of stuff here that's okay, and then we get down to areas where it goes, you've actually got some issues. You don't have a Content Security Policy. Nope, because that what we were talking about with the WordPress thing, but now I know how to actually get around it. However, if we look at mine, which we know has a Content Security Policy. Oh, you don't have any either. The reason why is that this is just looking at browser security headers. Now remember mine was in a meta tag, not in a header. So this again comes back to this thing about let us actually apply some common sense to interpretation. The goal should never be let's just get A. And it's the same with the SSL scan we just did. There's probably very good reasons why Barclays is configured the way they are. Now their goal shouldn't be so much to get an A, but to look at each one of these things and go okay, is this actually important? Yeah, a conscious decision on each one of them, right? Exactly. So, I know that I've got a Content Security Policy, and I know that I'm doing it as best I can. I can't add response headers to my site, which runs on Ghost Pro, I can't add meta tags. You know that you can do this now as well. X-Frame-Options. See, X-Frame-Options is an interesting one. So, this as we can see here, tells the browser whether you want to allow your site to be framed or not. Now this protects against things like clickjacking attacks. Now, X-Frame-Options, it can be there in a header, it is also represented in the frame-ancestors directive within a CSP, which I have covered by my Content Security Policy. So, although this might take it off here because it won't be in a header, you can put it in your CSP, which is in a meta tag. Yeah, gotcha. You can cover that. X-XSS-Protection, we've just had this discussion about what that does. Again, you've got to be able to add it via a response header, Chrome is going to default certainly to script tags and the source to mode 1 block anyway. We had the discussion about reporting. Well, you kind of can't report at the moment, at least not to another origin because of the thing with the yeah, you've done that. Referrer-Policy is an interesting one as well. So referrer policies let you start to do stuff around if someone clicks a link from my site to somewhere else, what should it actually send? Should it send anything in the referrer here? Should it just send the host? Should it send the whole thing? Referrer policies allow you to be explicit rather than just falling back to browser defaults. So again, they're kind of neat too. You can also put it in a meta tag, it doesn't have to be in a response header. Yeah, right. Okay. So, this makes a lot of sense. These are good reports. Like they're really interesting to be able to look down and have a look at all this stuff and see what it is that your website is broadcasting. Yeah, absolutely. You just need to think of it how important it is, and I can see down here you've got your Strict-Transport-Security here. You've got preload as well, which is awesome. Did you submit it to HSTS? Yep, yep. Beautiful. So we'll give it another go with your site here too, larsklint. com, Scan Me. Now this one is run by Mozilla. You've come back with a D+. Again, we're going to worry less about the score and more about what it finds. And it's going to find a lot of the same stuff. So for example, no Content Security Policy, you've lost some marks for that. Lars 25. No Subresource Integrity. No. Okay, now we've covered this. Scott didn't pick up SRI because it's not a header, so we didn't get that on securityheaders. io. It does turn up here Mozilla Observatory. Now, I find even when I put Have I Been Pwned into here, which otherwise scores very, very well, I still get marked down on SRI. And they're marking me down on SRI because I'm embedding some things from my own site without an integrity attribute. Right. But then you sort of go, in fact someone asked me this question on Twitter just the other day. They said, do I need an integrity attribute on a script tag for content I load off my own site, and this was in response to the whole Coinhive cryptominer. And I said well, well frankly what you're protecting against is someone modifying files on your site. If someone can modify files on your site you've got a bigger problem than just one JS file. That's a whole different range of problems. So there's that. And then the other thing as well is that if you're using, let's say you're using bundling minification as part of ASP. NET and it automatically creates that JS on build time and every time you change a character in your CSS or something, it's going to effectively change the hashed value of the file, then your integrity attribute would also have to change and you'd have to be able to dynamically generate that integrity attribute. It just becomes an absolute --- It's a snowball. Well, there's no value. So, you've got to look at this and go, yes I've got a red mark against it, there's a very, very good reason why there's a red mark, and frankly it doesn't matter. But in this case I probably should look into CSPs, right? Oh yeah, definitely look into CSPs. Now, I wrote a blob post on this as well. Let me just show you that blog post. And this was only a couple of weeks before recording. My Blog Now Has a Content Security Policy - Here's How I've Done It, and that walks you through the entire thing step by step. So if you want to know how to do a CSP, go and start with that.

Improving The Communication
Using a Standard for Contact Details
Alright, cool. So I think that's really good. We've just done a bunch of stuff around HTTPS, around automated scanning of sites as well, about pragmatic security, and this sort of went right back to the start where we're like, let's think about this as a spectrum and add some things where they make sense and the other things --- Absolutely. The pragmatism part of it is really important because otherwise you're going to spend time on something that no one, it's never going to be relevant. Yes, yes, exactly. Now I want to show you one more thing, and this last thing I think is really, really cool because it is the simplest, simplest thing in the world and you will be able to do this in less time than it takes me to explain it. I run, trust me, you will, I run Have I Been Pwned. Yes. So, Have I Been Pwned is a data breach aggregation service. When people find data compromised out of company's websites, they regularly send it to me, and I get this data and I say okay, something bad has happened, there's been SQL injection or something like that, and I want to let the company know. It's like, guys, your data is out there, you probably should let people know. It is enormously hard to contact companies when something like that happens and get a response. I know that sounds crazy, but it's everything from where do I actually find a contact. Very often it's just a contact us form that's going to go to a helpdesk, they might think it's spam, they might not prioritize it. Sometimes it's hard to find any contact. I'm going through Twitter DMs and Facebook messages, I'm going through WhoIs records, it is just insane how much hard work I go through just to try and get someone to pay attention to the fact that they've just been hacked. This is crazy. There is a great solution to this, and I want to just load the file I have on Have I Been Pwned and show you. Check this out. That looks like a text file. It's exactly a text file. So, this is a security. txt file. And this is all it is, it's basic text that conforms to a really, really simple spec. Namely, who do I get in touch with if I find something that's gone wrong with the site. So I've got my email address on there, you can see I've set up a particular security alias, where to contact me on Twitter, there's my public key on keybase if someone wanted to encrypt their communications to me. Oh, right. And the awesome thing about this is if someone found a vulnerability on Have I Been Pwned, they go here. So how do they know that they have to go there? Very good question. So this needs to become a standard. And I'm going to put the site up here on the screen for a moment, this is a security. txt site. This is in draft spec at the moment, it has been submitted to being ratified in part of our web standards, and this is it. Like, it's just absolutely dead simple. No, I love it. And you know, there's a bit of information here about how to set it up, you can go and generate your own here, there's a contact, encryption, if you want to have any acknowledgements for, let's say you've got a page on your site, somewhere where you acknowledge people who have submitted bugs, any policies, things like that. And the great thing is is that mainstream websites are now picking this up and doing it. So for example, have a look at this one, 1password. Oh, right. Password manager. And this is great. We've got some comments in here as well, all the contact information you could need. Have a look at this. These guys have actually got a bug bounty as well. So you can go to Bugcrowd who do managed bug bounties and go and get a, or potentially get a bounty if you find a vulnerability, there's where you go. We've got encryption keys in here, which is fantastic. I'll show you who else is doing it, speaking of the big guys. That's not my site. Google. Yeah, I've heard of those guys. Fantastic. So it doesn't get much bigger than Google. Google has got it in here as well. And, we're really trying to encourage the adoption of the security. txt file, which you sit in the path of. well-known, you drop it in there. As this becomes more and more broadly used and becomes more of a standard, I'm really hoping that we sort of get that momentum with sites all over the place that are adopting it. And what I love so much about it is, look, we've talked about a lot of cool stuff today, CSPs, SRI, all that sort of stuff, that takes some effort, you can break things, there's a little bit of curation, this is a text file. This is just the simplest thing in the world.

Summary
And I think as we sort of start to wrap up the whole idea of modern web security standards, getting to a point where we're starting to acknowledge that sometimes stuff goes wrong, like you may have a vulnerability in the future. I think the attitude should be when I get breached, not if. Because that way that makes you think about all of these things a lot more clearly. Yeah. And you do want to think about it in advance because stuff like this, honesty like if someone finds vulnerabilities in your things, you want to know about it. Absolutely. You want to know about it really soon. And trust me, for everyone listening, your organizations almost certainly would be painful to find someone to report this to simply because you're probably in the spectrum of most other websites that have to deal with this. So, do this, this is epic, it's the simplest thing in the world, and I think that's a really, sort of upbeat, positive note to end on, like security that's simple and easy and risk free. That's awesome. I have now a shopping list of things I need to do to my site before it goes live, this course. And when it does go live, go and just check his site, because I'm kind of curious to see how much is still there then, how much has been left undone. Absolutely. Well thanks, Troy. This was awesome. Like, as I said, I didn't know anything about what was in this course, and I've just learned tons. Awesome. Thanks very much, mate. Until next time.

Course authors
Author: Troy Hunt	
Troy Hunt
Author: Lars Klint	
Lars Klint
Course info
Level
Beginner
Rating
4.7 stars with 68 raters(68)
My rating
null stars

Duration
1h 24m
Released
18 Apr 2018
Share course

