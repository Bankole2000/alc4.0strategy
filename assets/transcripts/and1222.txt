Android Fundamentals: Content Providers
by Sriyank Siddhartha

A ContentProvider is the building block of Android similar to the Activity, Service, or BroadcastReceiver. It allows apps to securely share private data to other apps and manages the access to the central repository of data.

Android Framework provides developers with four components: Activity, Service, BroadcastReceiver, and ContentProvider. This course, Android Fundamentals: Content Providers, talks about how ContentProvider helps an application manage access to data stored by itself and provides a way to share data securely with other apps. Content providers are the standard interface that connect data in one process with code running in another process. This course starts with overview of ContentProvider and letting you design a structured data storage such as SQlite database from scratch. With the help of ContentProvider you'll then perform CRUD operations on SQlite database. Further, you'll explore how to share app's private data securely with some other apps using ContentProvider. At the end of the course, you'll use the concept of Android Permissions to enhance application security.

Course author
Author: Sriyank Siddhartha	
Sriyank Siddhartha
Sriyank began his career with a Bachelor of Technology in Computer Science from India. After working 2 years in Java, he found a great interest in Mobile Application Development. Sriyank works with...

Course info
Level
Beginner
Rating
4.7 stars with 27 raters(27)
My rating
null stars

Duration
3h 26m
Released
27 Jul 2017
Share course

Course Overview
Course Overview
Hi, this is Sriyank Siddhartha and I welcome you all to my fundamental course of Android content providers. I am a techie and love to share knowledge that I have in my head. I believe sharing knowledge is the best way to gain knowledge as well, and today I will share all the fundamental concepts related to the Android content provider with you all. It's always been a big pain as a big nerd to understand the limitations of the SQLite database content provider and also enhance the application's security by using the content provider inside our application. The content provider is one of the building blocks of Android, similar to an activity, service, and also the broadcast receiver. If you are looking to leverage your Android knowledge related to the SQLite and sharing of files using the content provider, then this course is your final stop. Some of the major topics that this course covers include, introduction to the content provider, designing of the SQLite database from scratch, performing create, insert, update, and delete operation using the content provider, exploring loaders and its related classes and interface, such as the cursor loader and cursor adaptor, and at last, we're going to check out how do we expose the application's data, using the content provider, to some other application using the concept of Android permissions. And we are going to check out each and every topic in this course with the help of demo application that will be created from scratch. The prerequisite for this course is not at all demanding, all you need to know is the basics of Android, you should have the Android Studio installed in your system, and you should be able to run Android applications inside your emulator. By the end of this course, you will have a very strong foundation on the topic of content provider, so come join me and let's together explore the Android content provider in deep detail, only at Pluralsight.

Making the Most out of This Course
Prerequisites
Hi, this is Sriyank Siddhartha and welcome to the first module of this course of 'Android Fundamentals: Content Provider'. In this module, I will just let you know, how can you extract hundred percent out of this course. Now, initially, you must be worried about the prerequisites for this course. Now let me tell you one thing- you don't have to worry anything about the prerequisite. Since, this course it designed for the beginners, so we will talk about each and every concept in this course keeping in mind, the beginner level. Now, the only prerequisite for this course is that, you just have to make sure, you have Android Studio, installed in your system. And you should know the basics of the Android project structure, such as, 'what us a java file' 'what is the XML file', and also what is the 'Android Manifest. XML file'. Just the basics of Android project, and you're good to go. And at last, you should know how to run your Android application in an emulator. So these are the 3 basic requirements, to follow this beginner course of content provider. Now, the students who have already gone through the courses of Android Activities, Android Services and also the Broadcast Receivers, will have the plus point. But if you have not gone through these courses, then also please don't worry about it. You will understand each and every concept, that I am going to teach in the course, with crystal clarity. But if you have already gone through, these three courses then you will have the plus point for this course.

Course Overview
Let us all proceed, and check out what are the topics that we will cover in this course. The best part of this course is that, we will cover each and every topic in a very progressive manner. That is, starting from zero level and reaching the peak level. So we will start this course by getting familiar with the content provider. What is a Content Provider and what are its practical usage? And then, we will design a raw data storage such as the SQ Lite Database Storage, and if you have no knowledge of the SQLite Database, then please don't worry about it. We will cover each and every topic related to the SQLite Database from scratch. So this course will cover the complete SQLite Implementation from scratch. And then, we will implement the Content Provider in Android which is the primary motto of our course and perform various operations such as, Insert, Query, Update, and Delete operation. So, these three topics will cover almost all the basic concepts related to the content provider. And now, proceeding forward, we will check out the Loader APIs along with its related classes such as the Cursor Loader, SimpleCursor Adapter, Loader Manager and its Callback Interface. And using the Loader API, we are going to inflate all the data from the SQLite Database into the List View. And the proceeding forward, we will then check out how can we allow the third party application to access our SQLite database using the content provider present inside our application. And during this process, we will check out how to deal with the Android Permissions and also secure our application's private data from outside, untrusted applications. Because when we are going to allow the other application to access our data, then our application will get vulnerable to some untrusted application that might be a potential threat to our application so in that case we are going to secure our applications data from outside world. And at the end, I will give you a very brief introduction to the predefined system providers such as the contacts provider, file provider and also the calendar provider. So these are all the topics, that we will cover as we proceed through the course.

How to Follow Demo Videos
The best part of this course is that we are going to cover each and every concept related to the content proivder with the help of demo application. So to make the most out of this course please follow along with me when I am creating any demo application. So in order to follow the demo videos of this course, you have to make sure that you have downloaded all the exercise file related to this course form the course landing page of this course. So make sure you have downloaded the file and after you unzip the file, you will get this folder 'Android Fundamentals Content Provider' and inside this you will get all the slides in the form of PDF that you can see in front of you. And along with this you will find all the demo application in the form of exercise file such as m3, m4 and m5 exercise files. Now inside each of the folder, you will find the before and after project. Now before is a project that contains the initial code of each of the demo application that we are going to start in each of the module. And after is the final result of the application that we will get at the end of each of the module. Now these demo application, will act as a reference in case you run into any error or you are stuck at any point. So you can simply compare your code with these project files of before and after in each of the modules. So make sure you download the exercise files and get started from the next module onwards.

Getting Familiar with ContentProvider
Activity, Service, and Broadcast Receiver
Hi, this is Sriyank Siddhartha, and welcome to the next module of this course of Android Fundamentals: Content Provider. In this module, we are basically going to get an overview of the topic of, what is a content provider in Android? Now, a content provider is basically one of the building blocks of Android, that is, it is one of the four components present in Android, such as, the activity, service, broadcast receiver, and at last, we have the fourth component as content provider. Now, the topic of activity, service, and broadcast receiver we have covered in a separate course as mentioned in front of you. So if you want, you can go through these courses after taking the course of content provider. So at present, our primary focus of discussion is the content provider in Android. But before we check out the topic of content provider, I would like to give you a brief overview of the topic of activity, service, and broadcast receiver. So first of all, what is a activity? Now, while using any application, the screen that we are interacting with is basically the activity. So the activity is the Android component which is visible to the user, so these are the three activities in front of you. So whatever screen that we see while using the application, is one activity. So the activity is a visible component of Android. Now, proceeding forward, we have the service. Let us understand a service with the help of an example. Suppose we are actually playing a game, so the screen that is visible in front of us is basically an activity. Now, while we are playing the game, in the background, there are a few background tasks that are going on, such as updating the application from the Play Store, uploading a file to the server, so all these activities that are going on in the background without affecting our current activity, is actually done with the help of service. So the service is basically the background task going on in the background without affecting our current user activity. Now, this was about the service. Now, what about the broadcast receiver? So we can understand the broadcast receiver in a very simple way. Suppose this is our Android operating system. So whenever there is some disturbance inside the Android operating system, the Android OS, what it do, it simply broadcast a message to all the application. Now, what kind of disturbance that I am talking about? As for example, suppose we receive a SMS. Now, whenever we receive a SMS, the Android operating system simply broadcast a message to all the application present in your device that hey, we got an SMS, is there any application that want to respond to this event? So it is a broadcast receiver that respond to such broadcasted message. Now, similar to this example, we have few more example, such as whenever the battery goes low, the Android system broadcast a message to all the application. Few other similar examples are, the incoming call, whenever we turn on or turn off the flight mode, or we turn on or turn off the WiFi. So whenever we have any type of such event taking place inside our device, it is the Android operating system that broadcast the message to all the application about these ongoing activities, and it is a broadcast receiver present inside a specific application that respond to such events, and perform task further. And now, after checking out the activities, service, and the broadcast receiver, you must be now curious about the content provider in Android.

Getting Familiar with ContentProvider
So what is a content provider? How can we define a content provider with respect to an example from our day-to-day usage of our application? Now, suppose this is our application, and inside our application, we have a data storage defined. Now, this data storage can contain a file, the SQLite database, or some other files of audio, video, or even photos. So this data storage can be of any type. Now let us assume that this data storage is private to our own application. That is, no outside application is allowed to access this data storage. Our application is only allowed to access our data storage. Now, suppose we have some other application and from this application, we want to access the data storage of our application. Now, since the data storage of our application is private to our own application, so the other application is not allowed to access our data storage, so here comes the content provider into picture. Now, in order to make other applications access the data storage which is private to our own application, we have to use the content provider inside our application. So the content provider will access the data storage of our application and we will expose our content provider to some other application so that the other application, with the help of content provider, can now access the data storage of our own application. So indirectly, the other application is now able to access the data storage of our application. So generally, this is the main purpose of using the content provider. As the name itself suggest, it simply provides the content of our application to some other application. And now, you must be thinking about what type of data storage can we have inside our application that can be accessed by our content provider. So for that, let us check out the data storage option. Now the content provider offers data in two ways. The first way is the file data, and the second way is the structured data. Now, a file data can be some photos, videos, audio file, and even some other text file or JSON file. So this data storage can be a file data. And the other way is the structured data that can be a SQLite database, or some structured array or list. Now, in our course, we are going to check out both type of data, such as the file data and also the structured data, but firstly, we are going to check out the structured data using the SQLite database. And later on at the end of this course, I will show you how to use content provider to deal with the file data. So at last, let us check out the content provider, theoretically. So the content provider is basically the android component that a building block of Android, similar to an activity, service, or the broadcast receiver. And the primary purpose of the content provider is to manage the access to the central repository of the data present in our own application. And that data can be the file data or the structured data, such as the audio files, video files, and also the SQLite database and so on. And when we expose our data to some other application, then we need to take care of the security as well. So while sharing our application's private data outside the application, the content provider maintains the application's security. And we are going to check out this concept at the end of this course with the help of Android permissions. And apart from managing the data, the content provider is also used while implementing the search framework and also while we use the cursor loader and cursor adapter in Android.

Do You Really Need ContentProvider?
Now, before we decide to implement the content provider inside of our application, we need to first be sure that, do we really need the content provider in our application? So for that purpose, you need to first check out your application requirement. So how do you decide that your application needs to have a content provider? Because not all the application contains the content provider. So how can you decide that your application need to have a provider? So firstly, suppose you want to share the complex data or some file to some other outside application. So in that case, you should have a content provider inside your application. And secondly, if you have some private data inside your application, that you want to securely share outside the application. So for that, again, you need to have the content provider in order to maintain your application security. And also in case you want to implement the custom search suggestion, using the search framework in Android. So for that again, you need to have the content provider in your application. And at last, if you want to display the list of data from the SQLite database using the loader APIs, such as the cursor loader, or cursor adapter, so in that case, again, you need to have the provider in your application. Now, once you are sure that you need to have a content provider in your application, then let's design the structured data storage in our next module. And after we design the structured data storage, such as the SQLite, then in the further module, we are going to implement the content provider on top of it.

Designing the Structured Data Storage
Overview and Initial Project Setup
Hi, this is Sriyank Siddhartha, and welcome to the next module of the scores of Android fundamentals content provider. In this module, we will first design the structured data storage, such as the SQLite. So first of all, let us understand our application scenario. So, we will have our main activity, and from the UI of the main activity, we are simply going to access the SQLite database. Now, this SQLite database can also be the structured data such as a Json file or some other files such as audio, video, and images. So, the main model of this module is to design the database so that we can implement the content provider on top of it. So our first step, to implement the content provider will be to design a raw storage to store our data. Now, this can be done in two ways, such as by using the file data that is photos, audio files, and video files, which are actually stored in the application's private storage, and can be shared to other application using the content provider in a most safer way without compromising the application's security. Now, the second way is to design a structured data, such as the SQLite database or some arrays or list. Now, sharing the file data through some other application using the content provider we will discuss in our upcoming modules. For the time being, in this module, we are simply going to implement the SQLite database inside our application. On top of it, we are simply going to implement the content provider from the next module onwards. So the desktop, we'll see it, and check out the initial project setup inside the Android Studio. So here inside the Android Studio, let us start creating a new project and name it as CP, that is content provider, Demo. And here, I will simply modify my package name, sriyank. com, that is com. sriyank. cpdemo. I you want, you can also edit it, but would recommend that please make the package name similar to what I have mentioned here, so as to avoid any difficultly for following the demo reviewed in this course. Decide the project location, and then hit on next. Let it be their default one, hit on next. And now I will simply select the empty activity, hit on next, and then finish. And now I would simply change the project view from Android to project level hierarchy, and then simply expand the project at module source main, and also resource layout folder. And just to save time, what I will do is I will simply go to the exercise files that we have simply downloaded at the very beginning of this course from the course landing page of this course. So inside this, you will find the m3 exercise files within which you will have the before project. So, inside the before project, simply navigate to app, source, main, and then resource layout folder. And I will simply copy the activity main. xml and simply paste it inside the resource layout folder of our project. Hit on OK, and then simply overwrite. Our next step will be to simply navigate to Java folder within which, simply dive deep into it, and there you will find a data folder along with the main activity. So simply copy these two files and paste it within your main package that is com. sriyank. cpdemo. Simply paste it and then hit on overwrite if it ask. And now, let us check out what's there inside the activity main. xml. So the layout of the activity main. xml appears to be somewhat like this. It has some edit text and also some buttons. So, at the top, I have the insert section. So the user will simply insert the country name and also the continent name, and then simply insert it into the database. And suppose in future, user want to update the continent name, then the user can simply update it as well. And down the side, we have some delete section, and also how to query data from the database. So all these edit text and the buttons I have simply initialized or declared inside the main activity. So, inside the main activity, here is the declaration of the edit text and the buttons. And inside the on create method, I have simply completed the initialization process. And down the side, I have simply declared the on click listener on each of the buttons. On a click on these buttons, a method will be executed; that is the on click method. And inside this, on click of each button, these methods, such as insert, update, delete, query rule by ID, edit last, display all method will be executed. And all these methods are present at the bottom of main activity, inside which, we are simply going to write our code in this module itself. So this marks the completion of the initial project setup inside the Android studio.

Creating Contract Class and SQLiteOpenHelper Class
In the previous video, we saw the initial project setup inside the Android studio. Now, in this video, we are simply going to define our contract class. Now, a contract class, in context of an SQLite database, simply contains that database configuration such as the name of the table, and also the column names. And in this video itself, we are simply going to define the database helper class. Now, this class is actually responsible for creating their database, and also to manage their database versions. In short, this database helper class simply creates and manages the SQLite database. And now, apart from main activity, we also have the data package. Now, inside the data package, I have the nation contract class. So what is the significance of this nation contract class? A contract class for the SQLite database contains all the constant values, such as the URI for the content provider, the name of the SQLite database table, and also the column names. So inside the nation contract, I will simply define an inner class for our database table. Since our database will contain the name of the countries and their respective continent, so I have simply defined the name of the class as nation entry, and the name of the contract class as nation contract. Now, if you have multiple tables, then you can simply create the inner class for each of the table. And now, inside this nation entry class, I will simply define the name of the table. And then I will simply define the name of the column to be created inside that table. So here we have simply declared the table name as countries, and there are three columns to be present inside the countries table, such as ID, country, and also continent. Now, if you notice here that I have simply implemented the interface of base column. So even if you remove it, then it makes no difference. But if I implement it such as base column, then this base column simply ensures that the nation entry class will have the column of underscore ID. So, if you open this base column, you will find string ID equal to underscore ID. The same thing we have defined here again. So what I will do is, either I can remove this first statement, or, just for the sake of better understanding, I will simply use base columns dot underscore ID. And this marks the completion of the code inside our contract class. Now, the next important part of the SQLite database is the SQLite open helper class. So here I have nation db helper present inside the data package. So let us open this file. And here you will find this class simply extends from the SQLite open helper. So, here it shows some error. Let us press Alt Enter, and simply implement the methods. And again, it shows some error. Then, again, simply press Alt Enter, and simply clear the constructor matching the super, right? Now, this constructor contains a lot of parameter. So what I will do is keep the context part, that is the context parameter, and simply remove the rest of the parameter. Now what is the significance of nation db helper. This class is basically responsible for creation of the database, upgrading or downgrading all the database. So in short, this class is basically responsible for managing the SQLite database. So here at the top, I will simply define the name of the database. And then I will simply define the database version as one. So the name of the database is going to be nations. db, who's version is actually one. Now, if you notice, inside the constructor of nation bd helper, you will find the super call. That is, we are simply passing the context and then the name. Now this name has to be replaces by database name, so let us use database name as a constant, factory as null, at the version as database version. And now, to create out database, we have to define the database schema using the name of table, and the column names as well. So here, I will simply define the database schema. So this is known as the database schema. So the schema of the database states that create a table of the name of countries whose column will be underscore ID, country, and also continent. Now, the column ID will be of the type of integer; that is, it will simply contain the integer values. And this column will contain the primary key, which will be auto-incremented as we insert rows into the table, right? And then comes the column of country, whose data will be of the type of text or string, and this column will never contain the null values. And at last, I have the continent column that will simply contain the name of the continent as string or text. Now, if you notice here that this countries is actually the name of the database table that we have defined here, right? And then, we have the column name as ID, country, and also continent. And again, these column names, we have again defined inside the contract class. So why don't we use these constants instead of using the raw string? So what I will do is I will simply replace these values with the help of the constants defined inside the contract class. So here, I have simply replaced all the values with the help of the constants, such as create the table of countries that is nation entry dot table name, with the column names as nation entry dot ID, the nation entry dot column country, and then nation entry dot column continent. And now let us rectify this error by simply using this import statement. So this rectifies our error. Now, the significance of using the constant values here is that we can use this constant value throughout our applications package. So this will actually reduce the probability of doing some mistake or running into error. So please make sure you actually use the constant value present inside the contract class. And now, inside our helper class, inside the on create method, what I will do is I will simply use the database instance db dot execute the SQL statement. Now, in order to create the table, we have to simply pass this SQL create country table string, that is the database schema. So SQL country table. So when this statement will be executed, we are simply going to create a table that will appear like this. So the name of the table will be countries, the database name will be nations dot db. And this will be the name of the column: ID, country, and continent. And these will be the content of the database, structured in this manner. So the ID will be the primary key that will be auto-incremented starting from one, two, three, four, and so on. And these will be the name of the countries and their respective continent in which they are present. So this is how our database is going to look like. And now, inside the on upgrade that is actually called whenever we want to make some changes to the database. So for that, first, we are simply going to execute an SQL statement. Drop the table if it exist, and here comes the name of the table, that is countries. So this will simply delete the older table, and it will simply create a new database with the upgraded schema and also the version. So as of now, let us not focus on on upgrade method, because the primary model of this course is to explore the content provider. Now, since we have completed the contract class, along with the SQLite database helper class, so our next step will be to connect our main activity with this SQLite database. So for that, inside the main activity, at the top, I will simply create the reference of SQLite database, such as database. And also, I will simply create private reference of nation bd helper class that is responsible for creating and upgrading the database. And now, inside the on create method, I will simply complete the initialization process of the database helper equal to nation db helper, and simply pass the context of this activity. So this will simply create the new instance of the nation db helper by passing the context of this activity. So this will simply trigger the nation db helper constructor which is present at the top. And then, inside the main activity, down the side, I will simply complete the initialization of the database. Equal to database helper dot get writable database. So this method, get writable database is actually responsible for creating the database. If the database does not exist, it will simply create the new database. If it exist, the it will simply create the connection between that activity and the SQLite database so that we can simply perform the read and write operation. Now, if you want to only perform the read operation, not the write operation, then you could simply use get readable database. But since we are going to perform the insert operation as well, so simply use get writable database from now onwards. And now, down the side, at the bottom, I am simply going overwrite the on destroy method, right? Now, inside the on destroy method, I will simply close the database connection with the main activity by using the close method. So when activity will be destroyed, the database instance will be released. And since it is an expensive operation, so we are only closing the database connection inside the on destroy method. So this is all for this video. Thank you.

Inserting Data into SQLite Database
Let us now proceed and check out how to perform some database operations such as the insert. So if you're in the application right now, our application will appear to be like this. We have the insert section at the top. So we want the user to enter the country name and also the continent name, and then we are simply going to insert the data with the help of this button into the SQLite. So from our main activity UI, we are simply accessing the SQLite database and inserting some data into it. So, on click of this insert button, this code will be executed, which in turn will simply execute the insert method present down the side here. So, inside the insert method, let us first get the user input, such as country name and also the continent name. And now, how do the insert, the name of the country, along with the continent name, inside the SQLite database. So for that, we have a special class of content values. Let us define the content values instance. Now, the content values simply accepts the values in the form of key value pair. Now, the key will be nation entry dot the column name, such as column country, and the value will be the country name. Now, if this nation entry shows some error, then at the top, simply import this statement. And now let us insert the continent name inside the content values as well, so, content values dot put give the key as the column name of continent, such as column continent comma continent name as a value. Now, at the end, what I will do is I will simply use the database instance that I have simply defined at the top SQLite database, and the simply use dot insert method. Now, this insert method takes the first parameter as the table name, that we have again defined inside our contract class, such as nation entry dot table name. And then the second parameter will be the, near the bottom, had simply pass null, and the last parameter will be the content values itself. So when this statement will be executed, it will simply insert the content values that carries that value country and also the continent inside this table. And this insert method simply returns a row ID; that is in which row the values were inserted. So here, let us use long row ID equal to database dot insert method. Now, this row ID is actually the value that is actually present inside the underscore ID column, such as one, two, and three, and so on, like that. And now, let us use a log statement to print the value of the row ID. So let's now run the code, and let's see if we are able to perform the insert operation or not. Let us enter the name of the country as, let's say, India, continent as Asia. Let us click on insert button. And there we go, items inserted inside the table with row ID equal to one. Now, if I enter some other name, such as Japan, that belongs to the continent of Asia as well, let us insert it. So this data was again insert with the row ID as two. And let us insert few more data to the database. Let's say USA, North America, inserted with the row ID of three. And then, I will simply insert few more countries' name, such as Indonesia, Asia, Nepal. And at last, let us insert Japan again. So here, at the end, I have item inserted in the table with row ID six. So, total of six elements we have inside our database table. Now the question arises, whatever data that we have inserted inside the SQLite database, how can we read it? So for that, we have to perform the query operation. So, down the side, I have the query section as well. Enter the row ID, suppose if I enter here four, and click on query by ID, I will get the element present inside the fourth row, that is this one, right? And then, if I click on query and display all button, then I am simply going to get all the content of the SQLite database inside our lock guard.

Query Operation: Print All Records of SQLite Database
Let us now proceed and check out how do we implement the query operation? That is, how do we bring the content of the database inside the lock guard? So, on click of this button, query and display all, I am simply going to perform the query operation from the database. So down the side, I have query and display all method; that will be executed on click of that button. So here I will simply use a statement such as database dot query. Now, this query method simply expects some parameter. So these are all the parameters that we have to pass inside the query method. So the first parameter is actually the name of the table from which we want to query data. The second one is the projection, then selection, selection arguments, and so on. So let me format these parameters, and let me talk about each parameter one by one. So here I have simply formatted the code. Now, the first parameter is the name of the table. Now, the second parameter, that is the projection, simply states the name of the column that you want to receive when we query some data from our database. So this projection will contain the name of the columns that we want to receive while performing a query operation. So here, at the top, I will simply define the add it of string such as projection, and the values as nation entry dot underscore ID, column country, and column continent. Now suppose you only want to retrieve the column country and column continent, and you don't want to receive the ID column as well. So simply remove it. It is totally up to your choice. But for this demo, I want all the columns to be returned in our query statement. Now, the selection parameter simply defines a condition, that is from which row you want to query your data, that is some condition. Suppose you want to target some specific data. So, for that, you have to define your selection parameter. Now, in that case, I want the whole content of the table. So for that, I will simply define the selection parameter as null. And now, next comes the selection argument. Now, this arguments is actually a part of the selection parameter. So for the time being, again, I will make the selection argument as null again. And I will talk about this selection and selection argument shortly in this video itself. Now, the next two parameters are grouping of the rows. So let's make it null and null. Now, the last parameter is the sort order, that is whether you want your data to be arranged in the ascending or the descending order. For the time being, I will make it the default one, that is by passing null. Now, passing null will sort the data in the default sort order. But the default sort order can be in the unordered way. It is not guaranteed. So if you want your data to be arranged in ascending or descending order, then you must specify the sort order as well. Otherwise it will sort the data in the default manner, which may be unordered. So this completes our code inside the query and display all. Now, once this statement will be executed, this query method simply returns a cursor object. Now what is a cursor? The cursor is the object that contains the reference to all the rules. And inside each of the rules, these are the columns that will be present. So here, let us assign it to the cursor object. And now, with the help of this cursor, we are simply going to print out all of the values present inside that database. So first, let us check if the cursor is null or not. So if the cursor is not null, then simply use the while loop so that we can iterate through each of the rules. So, cursor dot move to next. So, this while loop will actually iterate through all the rule. And inside each of the rules, we have the three columns, so again we need a for loop. So here I have simply retrieved the name of the columns, and then I am simply using the for loop to iterate through each of the columns, right? And finally, outside the while loop, I will simply use log dot i, and simply print out the string, str. But before that, what I will do, I will simply close the cursor object, cursor dot close, which is, again, a very important step to avoid any memory leakage, and for the better performance of our application. Now, at the end, I would like to add a point here regarding the cursor object. Now, whenever the database dot query method is executed, it returns a cursor object. Now, this cursor object contains the reference to all the rules. But each of the rule that is returned by this method can be used with the help of a specific index. As for example, suppose this method returns total of six rows from the database. So the cursor will have the index starting from zero, one, two, three, four, and five. That is, all the rules returned will have the index starting from zero, one, two, three, four, and five. So a total of six rows has been returned by the query method. But as soon as the database dot query method returns the cursor object, the cursor object will have the current position of minus one. When the cursor object has a position of minus one, then you need to move the cursor to the position of zero to start reading from here and reach until the end, that is five. So that is why we are using cursor dot move to next, so with each of the iteration, the cursor will start from minus one, then zero, then one, and then two, and will go until five. So currently, inside the if condition, the cursor will have the position of minus one. So when this statement will be executed, the cursor will then have the position of zero. And then, so on, it will increase, and go until five. So always remember, initially, the cursor has a position of minus one. So this marks the completion of the query and display all method. Let us now run the code. So here at the bottom, simply click on query and display all button. So here we go inside the lock guard, we have the content of the SQLite database. These are the six entries that we just inserted in the previous video, right? Let us now proceed a step ahead. Suppose user want a specific data. Let's say, if user enters four, we should get Indonesia and Asia in the output console. So for that, we are simply going to write our code for this row ID and query by ID. So user will enter here five and slick on this button, and in the output console, we will get Nepal and Asia, that is this row. So for that, we have a specific method defined here: query row by ID. So what are we do is, I will simply copy all the code from this query and display all method and paste it inside query row by ID method. As of now, when this query row by ID will be executed, it will simply fetch all the content of the database. But our requirement is that we want to filter the result based on the row ID. So what are we do is I will simply modify my selection parameter. So instead of null, what I will do is I will simply use nation entry dot underscore ID plus equal to question mark. Now, what I mean by this equal to question mark, I will just let you know. Let us modify the selection argument as well. Want to pass the row ID. Now, the row ID will be entered by the user inside the edit text. So let us now get the user input as well. Let us define a string, row ID equal to e t query row by ID dot get text dot to string. So here, this is the use input that I'm specifying here inside the selection argument. Now, this selection argument is the add it off string. Now what happens is that this selection parameter in the runtime simply represent this underscore ID equal to question mark. Now, what about the selection args? So, the selection argument whose value is row ID will simply replace that question mark of this selection parameter by row ID in the runtime. So in the runtime, we will have something like this. Let's say, underscore ID equal to, if user enters five, it will be five. So our final query statement will be filter the result, where the ID is actually equal to five. So we are going to get the column defined by the user whose ID is five. So the question mark in the runtime will be replaced by the row ID that we have defined here. So down the side, let us modify our print statements as well. So here, we do not need to iterate through all the rows, because we actually expecting a single row in the output console. So here, I will simply remove this while loop, because we just have one row with three columns. So one for loop is sufficient enough to print out the values of one row. And also, in the if condition, we can simply write, if cursor is not equal to null, and then simply move the cursor to the next index, right? Because when we get the cursor using the database dot query method, so, initially, the cursor will point to the position of minus one, now, since we are expecting a single row with the help of this query statement, so the row that is actually returned using this statement will have the index of zero. So initially, when the cursor is at position minus one, so we have to move a cursor with one position so that now it will have the position of zero. So when this statement will be executed, the cursor will now have the position of zero instead of minus one. And then, without running into any error, we can use the for loop to print out all the columns present inside the row zero. So again, please don't get confused how a cursor actually iterates through the positions. So let us now run the code. So in the edit text, let us type, let's say, two, query row by ID. And here we get two, Japan, Asia. Let us use, let's say, four, let us query by ID. And there we go, for Indonesia, and the continent is Asia. Let us use six, query row by ID. We have Japan and Asia. Now let us use, and let's say, 20, and let's see what happens. So there we go, nothing happens, because the cursor will actually be null. We are actually asking for the element from the database that does not exist, so the cursor will be null and this if block won't be executed. So in this video, we talked about the projection parameter. Now, the projection parameter simply specify what are the columns that you want inside the cursor. So as a result, the cursor will get all the desired columns that you want. And now, next, we checked out the selection parameter that defines a where clause. That is to filter our rules. And also we checked out the selection arguments. That simply helps to filters our specific results in the output. And also, we checked out the sort order parameter that determines the ascending or descending order of our results. So please do remember these parameters: projection, selection, selection arguments, and sort order.

Updating Record in SQLite Database
Let us now proceed and check out one more database operation, such as the update operation. So here, inside our application, what are we do is the user will simply enter the name of the country and the new continent name. And on a click of update, it will simply update the content and name with respect to the country name defined here. So for that, inside the update method, let us write our code. So here is the update method. So this is the update method though which we can update our data inside the database. So the first parameter is the table name. And the second parameter is the content value. So let us define our content value. Let's say, content values space content value equals to, and let us define the instance of these content values. And then simply insert the values as a key value pair. Let us pass the first parameter as a column name. So here I want to update nation entry dot column continent, and then simply pass the value as the new continent name. Now, the name of the new continent, we are simply going to get it from the user. Let's say, new continent equal to e t new continent get text dot to string, and simply pass this value here, new continent. So now we are done with our second parameter of content values. Now let us define where we want to update our data. So we have to define our selection and also selection arguments. Now, the selection simply states the condition, that is our where clause. So let us define our selection equal to, let's say I want to update the name of the continent at a particular entry. Now, that entry will actually be targeted with the help of either row ID or the country name. But here, as per our application, we have to enter the country name to update the new continent name. So instead of I'd, we are simply going to use nation entry dot country name plus, and then use equal to question mark. Now, this question mark, in the runtime, will be replaced by selection arguments equal to, as a value, simply use the name of the country. Now, the name of the country will again be user-entered. So, string where country. So here, inside that ID, let us pass where country. So now we are done with the selection, and also the selection arguments. So in the runtime, this statement will simply mean where country equal to, let's say, Japan. So in the runtime, the selection and selection arguments, where together mean that where the country name is actually equal to Japan. Suppose if user enters Japan. So the Japan will actually take place of the question mark. Right? So this question mark will be replaced by the user input. So wherever we are going to match this condition, we are simply going to update the content and name as whatever user has entered inside the edit text. And now, at the end, this method of update simply returns how many rows are affected with this updated statement. So here, int rows affected equal to database dot update statement, and now let us write our log statement. The number of row updated, such as simply print rows affected. Now, if you want, you want also make it rows updated. That is the number of rows that are updated. Let us now run the code. And now first, let us display all the content of the database. Suppose I want to update this Japan to, let's say, new Asia. So for that, I will simply enter Japan, and then simply use the new continent name, let us assume Asia new. Let us click on update. So there you go inside the lock guard you can see number of rows updated is equal to two. Now here, if you notice, I have Japan in the second row and Japan in the sixth row as well. So when the statement was actually executed, it simply looked at variable, we have Japan as country value here and here. Simply update the name of the continent to Asia new. So if you click on query and display all data, you will find the updated SQLite database table. So here in the second row, I have Asia, and again I have Asia new at the bottom. Now suppose, if you want to update, let's say Nepal, then simply enter Nepal, or let's say, India, and simply update the name of the continent. So that's all for this video.

Deleting Record from SQLite Database
Let us now proceed and check out our last database operation, that is a delete operation. So here, this is our application, and this is our edit text. So inside this edit text, the user will enter the name of the country and variable, it will find the country available, it will simply delete that particular row. So it will simply delete all the rows where name of the country is, suppose India or Japan, or something like that. So inside our delete method, let us write our code. So I will simply use database dot delete method. Now, the first parameter will be nation entry dot the table name, that is our table name constant. And then we are simply going to use selection, and at last, selection arguments. As said, the selection and selection arguments simply filter out the data. So delete that specific entry where we actually meet these conditions. So let us define our selection and selection args. But before that, let us get the user input of country name. And then let us define our selection. Equal to, we want to delete the entry with the help of the country name. So I will simply use equal to question mark. And then, simply to find the selection argument, equal to any of, let's say, country name, as a first value. So in the runtime, it will simply look for the condition wherever we have country equal to, let's say, India, simply delete all the entries. Or if we have, let's say, Japan, then simply delete all the entries as well. And now, this delete method simply returns an integer value that is how many rows were actually deleted. So int rows deleted equal to database dot delete. And now I will simply mention a log statement. That is the number of rows deleted, and the deleted row's column. Let us now run the code. So here in our application, here, let us suppose entered Japan, and let us click on delete. Now remember, the J of Japan is actually in capital. So, the entries are actually case-sensitive, so always remember this. If I use here smaller j, then our code will not work. So simply use capital J, hit on delete. And now, inside the lock guard, you can notice we have number of row deleted as two. So it does that query and it display all the elements. So here in the output, we have only one, three, four, and five. Now the element present at the position two and six were actually deleted, because in those rows, Japan was the entry. So number of row that was deleted it actually two. Now, suppose you want to delete this fourth row. So simply enter Indonesia and then hit on delete. So this row will be deleted. Now, if I give you a scenario that deleted the row where the row ID is actually for IT. So for that, what you will do is, inside our delete method, instead of column country, simply use underscore ID, right? So wherever the ID of the row is equal to, let's say, four, then delete that entry. So the selection and the selection arguments simply determines where you actually want to delete or update your data. So where the ID is equal to four, then simply delete that particular row. If I use ID equal to seven, then simply delete that particular row. And if I, suppose, give you nation entry dot underscore continent name, then it simply states that where the value of the continent is actually, let's say, Asia, simply delete all the rows where the value of the coordinate is Asia, right? So in this way, we can proceed. So currently, I have just the name of the country. Where the country name is equal to something, delete that particular row. If you want, you can also put multiple edit texts, and also multiple delete buttons as well. Just for the sake of simplicity, I am simply using the country name here. Now add, and suppose, if I try to insert a new entry inside our database, so let's see what happens. If I insert here Germany, and simply use the continent name as Europe, hit on insert, then you will find the items was actually inserted in the row ID of seven. If I use query and display all, and there we go, after five, it should be six, but now we are actually getting seven the a row ID. Now this is simply because, previously, by deleting Japan, we actually deleted the row present at the sixth position. So now, when we insert a new row, it is actually getting inserted at seventh position. So this how the SQLite database query. After five, if you have deleted six previously, then the new element will be inserted in the seventh position, not the sixth position. Like, we have here one and three because two was actually deleted. So this is how it works. So now we have successfully completed our setup for the SQLite database.

Summary
So, finally we have reached the end of this module. So in this module, we learned about the SQLite database implementation, and also performed various operations, such as insert, query, or read operation, update, and also delete operation. And also, we checked out the important terminologies, such as projection, selection, and also selection arguments, right? So these are all the important terminologies that we are about to use in our upcoming modules as well. So from the next module onwards, we are simply going to start implementing our content provider, that is a main model of our course.

Implementing ContentProvider with Insert and Query Operations
Implementing ContentProvider Subclass with It's Abstract Methods
Hi, this is Sriyank Siddhartha, and welcome to the next module of this Android fundamentals content provider. In this module, we are going to start implementing the content provider inside our application, and perform the insert and query operations, as well. So, currently, in our application, we have the main activity that directly interacts with the SQL database. But now, from this module onwards, the things will change. Because we are simply going to disconnect the connection between the main activity and the database. And instead of this, the main activity is simply going to interact with the content provider, and the content provider will be in charge to provide data to the main activity, from their database. So there will be no direct connection between the main activity and their database. So if you look at the steps involved, we already designed a raw storage for our application in the previous module. Now, let us proceed and create a subclass of the content provider that will act as an interface between the main activity and the SQL database. So, here, inside the Android Studio, this is the same application that we created in the previous module. So, inside the data package, I will simply create a new class and name it as nation provider. Which will be the subclass of our content provider. So the class will simply extend from the content provider class. And here, I will simply press alt enter, and simply implement the methods such as on create, query, get type, insert, and delete and update method. Hit on OK. And there we go, we got all the abstract methods inside the nation provider class. And now, let me format the codes. And as the next step, what I'm going to do is, inside the nation provider, I will simply declare the difference of the nation DB helper class. And simply complete the initialization inside the on create method. And add then, I will simply return true. Now returning true at the end of on create method simply states that we have simply completed the initialization process for the nation provider, which is our content provider class. And now the instance of database helper is actually present inside the main activity of Java that is here. So, slowly, we are simply going to remove this code from here because the main activity is now going to interact with the nation provider class. And this nation provider class will, in return, interact with the SQL database. So the main activity will no longer interact with the database directly. So inside the nation provider class, we have too many abstract methods, such as on create, query, get type, insert, delete, update method. So, what are all these methods stands for? So let us check out these abstract methods. Now, the first abstract method is the on create method, which gets executed when the application starts because we are going to register our content provider inside the manifest file. And also it is used to initialize the content provider subclass. And next comes the query method that is used to retrieve the results from a database. And next comes the insert method that is used to insert some record inside that database. Then comes the delete method that simply delete a particular record or all the record from the database. And then we have the update method to update some data inside the database. And at least, I have the get type method. Which simply handles the request for the MIME type of the data for the given URI. Now, the details of get type method I will talk about it shortly in our upcoming modules. Because as of now we have not yet explored the MIME type and what does URI stand for. So I will let you know about this method in our upcoming modules.

Authority String, Content URI, and URI Patterns
So after declaring the content provider class and overriding the abstract methods, now it is time to check out our third step. Now, the third step states that define the authority string its content URIs and also the column names. So, first of all, let us check out what does the content URI stand for. So, the content URI simply appears to be like this. Content colon forward slash forward slash followed by the authority and then we have the path name. Now, to be more specific, this authority can be broken down into package name dot content provider name. So in our case, the package name is actually com. sriyank. cpdemo and then we have the content provider class name as Nation Provider. So this package name followed by the content provider name is basically the authority string. And then we have the path name, which in our case is actually the name of the table that is countries. So at last, one more point to remember here is that the authority string has to be unique. Now, to make it unique, we simply use the package name along with the class name. So there will be no application with the same package name along with the same class name present in the Google Play store, that will show some conflict with your application installed in the user's device. So that is why, to make the authority string unique, we simply use the package name along with the class name. And at last, the path name simply helps the client application to reach out our database table or any particular file. So that is why here we are simply using the table name because we are simply going to access the data of that particular table. Let us now proceed and check out what are content URI patterns. Now, a content URI uses a wildcard character to match a particular URI. For example, we have a wildcard character as asterisk, and we also have hash. Now, the wildcard character of asterisk matches a string of any valid character, for example, name 54 three and hello. If you look at these examples, there is one thing in common. They are all of the type of string. So name is a string, 54 is a string, and then hello is a string. So the asterisk will match a string of any valid character. Now next comes the hash. Which matches a string of numeric character. For example, we have 54, three, and 27. There is one thing in common among these three examples. They are all string again, but they are all numeric characters. So the wildcard character hash only matches with the numeric characters. They do not match with any other text. While, on the other hand, the asterisk matches with any type of string, whether it is a number or any other text. Let us clear our concept with the help of some example. This is the authority followed by the wildcard character of asterisk. Now, on the right hand side, I have an example of authority name, followed by we have a path segment of table one. Now, table one is a valid string character. So the asterisk will match with table one. Next we have this example. Table one slash my data. Now, no matter we have two part segment at the end, that is table one and my data, but both of them are actually string. So this string, as a whole, will again match with asterisk. And next, we have table two, which is, again, a string. So this will, again, match the pattern. Now, at the end, I have suppose seven. This seven is a number, but it is a valid string character. So added up, we have the asterisk matches with any valid character. And here, seven is a string, which is, again, a valid character, so it will, again, match the pattern. Now, let us take some more example, such as table one followed by asterisk. So, on the right hand side, again, we have some example. Table one slash my data. So, it again matches the pattern of table one and then we have asterisk that will match my data. So it will match the pattern. And next here I have table two. But if you notice the pattern, I have table one slash asterisk, so the path segment of table one do not match with the table two. The result will, then, fail. It will not match. Next, I have table one slash five. So, again, table one matches with table one, followed by asterisk, which again matches with character five. So it will, again, match the pattern. Let us now proceed and check out the wildcard character of hash. So, here we have table one slash hash. Now, let us take some example, table one slash four. Now the four is a valid numeric character that can match with hash. As for the definition of hash mentioned at the top. So this URI will simply match the pattern and next we have an example of table one slash hello. Now, here comes the twist. The hash only matches with the valid numeric character. But hello is not a numeric character, so it will not match the pattern. And at last, I have table one slash my data, which is, again, a string, not a numeric character. So our result will fail and the pattern will not match with the given URI. So now I hope you have understood the concept of content URI pattern in case of content provider. Now the question arises where we are going to use these concepts of content URI and URI patterns. So let us check out our application scenario. From the main activity, we are going to pass a URI to the content provider. Now, inside the content provider, we are going to have the URI matcher with some URI patterns defined. Now, the incoming URI from the main activity will be matched with the given URI patterns present inside the content provider. With the help of the matching result, we will then fetch the data from the database, as per the URI. So everything depends on the URI that we are sending from the main activity. Now let me show you an example. Here, inside the content provider, suppose I have a pattern of, let's say, content followed by authority name then I have the table one. Now, this is actually the path name which will give an address to our client so that a client application can access our database table. Now, here I have one more pattern where I have the pathname followed by hash. And at the end, we have table one followed by asterisk, which is, again, a wildcard character. Now, the sequence in which these patterns are defined bears some importance. That is a pattern present at the top will be given more priority. As they are present in the list of URI matcher. Now, from the main activity, let us assume we have a URI that appears to be like this. This is the content authority, followed by the path name, followed by forward, which is, again, our numeric character. Now, when we pass on this URI to the content provider, then the content provider, with the help of URI matcher, will start looking for the possible patterns, with which the incoming URI matches. So among these given URI pattern, the URI matcher will first try to match the URI with the first given pattern, which will again fail. So as soon as the matching process fail, it will then look for the second available pattern. That is table one slash hash. Now, here I have four and here I have hash. So the pattern will then match with the given URI. The matching will be sensors full and then the URI matcher will no longer match the URI with the pattern available after this pattern. That is the last pattern having the asterisk wildcard character won't be used for the matching purpose. So finally, we have got the pattern with which the URI matches, and then we will get the desired result from the database.

Declaring Content Authority and Content URI in Contract Class
So, in the previous video, we already subclassed the content provider class. Now, in this video, we are simply going to declare the string authority and also the content URI patterns inside our demo application. So one by one, we are simply going to declare the content URI and the authority string inside our contract class first. So here, let us open the nation contract or Java. Where I will simply define the authority string first. Equal to the package name, followed by dot, my content provider class name. Now the package name of our application, you will find it inside the builder data file. So here inside the builder data file, you will find com dart and dart CP demo. So simply copy it and inside the contract class, simply replace the package name by our real package name. And then comes to the content provider class name, which you can find inside the nation provider at the top. Nation provider, simply copy it and paste it in place of my CP. So this completes our authority string. And now I will simply declare my content URI. Now, the content URI has a perfect soft colon, forward slash forward slash. So out of that, again, I have to create a URI. SO I will simply use the method of URI. US and simply pass a string of content colon forward slash, and again, forward slash, and then simply add the content authority. Now, finally, our base content URI will simply look like this. Content then package name then our class name. Now, if you notice, our class of nation provider is actually present inside the data package. Right, so at the top, inside of our main package, we have the data package defined. So what I will do is, after CP dot demo I will simply use data dot nation provider. So this provides a complete path to our nation provider class. So again, here, our base content URI will now appear to be CP demo dot data dot nation provider. So this base content URI will have this value. Now, after we have defined the base content URI, we are simply going to define the path name to our country's table. So here I have simply defined the path country's equal to countries. So this string is actually responsible to make a client application point to our database table. So inside the nation entry class, I will finally now declare the content URI. So here I have the final declaration of the content URI. That is actually the combination of the base content URI and the path countries. So finally the content URI off our database table will appear to be like this. Content then followed by the package name, and then I have the class name, and then I have the path name. So this statement is actually comparable to this statement of content URI that we saw in the previous video. That is content followed by authority followed by path name. Which can be further broken down into the package name and the content provider followed by the path name. Which can be further evaluated as this one. Package name, nation provider, slash countries. So the same thing, we have declared here, as well. Now the reason why I have declared the base content URI, the path countries, and the content URI, inside the contract class, because these are all constants. And all the constants related to the content provider and also the SQL database, we have to store it inside the nation contract class. So that all the constants will appear here, and later on, we're going to use it without doing any mistake inside our application, and avoid running into any error. And now at the end, I would like to declare our nation provider class, inside the manifest file. Now, as we all know, the content provider, similar to the activity service or the broadcast receiver, is basically the application component. So we have to declare it inside the manifest file, otherwise our application will crash, if we run it without declaring it. So, let us navigate to and or manifest or XML, inside which I will simply declare our content provider with the help of the tag of provider. And now, it simply asks for the authorities. So inside the authorities, I simply copy the string authority from here. And paste it inside the Android manifest here. And then it simply asks for the name of the provider. So the name of the provider is the nation provider. And at the end, I will simply use exported equal to false. Now, this exported equal to false simply ensures that our content provider will not be accessible to some other application, even if some other third application tried to access our content provider, they will actually fail. Because here we have exported equal to false. Now, if we make it through, then our content provider will now be accessible to all the applications that is any interested application. So here, let us make it false as of now. So the declaration of the content provider inside the manifest file simply marks the completion of the fourth step, that is to declare the content provider inside the manifest file. So now we are done with our fourth step.

Declaring URI Patterns Using UriMatcher
And now, our next step will be to define the content URI patterns inside the nation provider class. So here, inside the nation provider class, what I will do is, at the top, I will simply define URI matcher. Equal to new URI matcher, plus the constant of URI matcher dot no match. That bears a constant value of minus one. I will then define a static block inside which I will declare all of the patterns of the URI. So let us define, first, a very common pattern for the whole table. So URI matcher dot add URI and this method expects the first parameter as the content authority. So here I will use the content authority and now, if this statement shows some error, then inside the import statement import this static field. This will rectify your error and then the second parameter, it expects, is the path segment. That is a path name of our table name, but underscore countries, and for the spot countries, import this static field at the top. And our last parameter will be a constant value. Now the constant value can be to are positive integer, so let us make it one. So this is a pattern that I have defined for the whole table. So the pattern will look like this. Content followed by our authority name and then at the end I have the countries, which is the path to our table. And now, let us define another pattern for, let's say, asterisk. URI matcher dot add URI, give the first parameter as, again, content authority, and second parameter will be the path to the countries, but here, I will use a wildcard character. And upend a string, that will be slash asterisk. And now, give a constant value such as two. So this pattern will appear to be like this. It will have a wildcard character of asterisk at the end that will match any valid character or, in short, string. It may be a number string or any character string. And now at the end, I will now define the pattern that will have the hash wildcard character. Let us now upend slash hash, and then give a constant value of three. So this pattern will appear to be this is our content authority and then I have countries, stable name, followed by hash. Now the hash wildcard character only matches with the valid numeral character, not any other text. Now, at the end, I would like to add a point here. Now suppose we are passing some URI from the main activity to this nation provider, which is our content provider class. So the URI matcher will simply start looking for best possible pattern available inside our URI matcher list. So here are the three available pattern. So first, it will try to match the URI with the first one. If it matches, then it won't look for the other patterns that we have defined here. So, similarly, from the main activity, suppose if I pass this URI, which has the path of countries, and then at the end, I have a valid numeric character of 23. So the URI matcher will first try to match this URI with the first available pattern. So this will fail. And then it will check for the second available pattern, which has a wildcard character of asterisk at the end. Now the property of the asterisk is to match any valid text or string or any number, as well. Only criteria is that it has to be a string. Now here, 23 is basically a string literal, or you can say, a number, as a string. So the content URI will match the pattern with the second pattern that we have defined here. It is not going to look for the third pattern that is the wildcard character of hash. So we have simply defined the priority sequence while defining our URI matcher. The first pattern will be given more priority followed by this pattern and then, at last, we have this pattern defined at the end, which will be given the last priority. So technically, we have done some mistake while defining the sequence, because the best possible and the specific pattern for this URI is actually the third pattern that we have defined here, which is unreachable at this point of time, so we need to put this pattern in the second position. But as of now, what I will do is, I will simply put the hash wildcard character pattern at the end. And when running our application, we will encounter some error that I want to show you. So currently, let the patterns be defined in the sequence, we will crash our application and try to rectify our error, as well. Now, currently, these are some constant value. One, two, and three. So what I will do is, let us define some constant value at the top here. I have now defined the constants for the operation. Let us replace these constant value with the variables that we have defined here. Such as countries. Countries underscore country name. And then, at last, countries underscore ID. Now let me tell you, what are the main purpose for defining these patterns. The first pattern will be for the whole table. And then we have the second pattern as countries underscore country underscore name. This is to identify a specific role in a table with the help of the country name. For example, suppose we want to delete a specific row in a table with the help of a country name. So, in that case, we are going to send a URI that will match with this pattern that we have defined here with the help of the asterisk wildcard character. And similarly, suppose we want to query a row which can be identified with the help of row ID. So, for that, we have defined this pattern, which is currently unreachable, and we will rectify our mistake in our upcoming videos.

Insert Operation Using ContentProvider and ContentResolver
Let us now proceed and check out how do we perform the insert operation using the content provider? So here, inside the Android Studio, I will simply navigate to the main activity and then navigate to the insert method. Now insert the insert method, I am simply using the database instance dot insert method, right? Now instead of database, I will simply use the content provider to insert the data into the table. So here I will simply comment these two lines of code. Because we are simply going to use the content provider class and use its insert method to insert the data into the table. So insert this. I will simply get the instance of the SQL database. Equal to the helper class dot get right table database. That will simply open the connection for the SQL database in the right mode. So from the main activity, we are simply going to pass on a particular URI, and that URI will actually appear here. So with the help of URI matcher, we are simply going to match the URI with these refined pattern. So I will simply use the switch case statement, such as switch and then use URI matcher dot match. And simply pass the incoming URI from the main activity. So here I have simply defined my default statement. And now this match method is simply going to return some value, and that value will be actually comparable to these constant value defined at the top. So down the side, inside the switch case statement, I will simply define the case for, let's say, countries. I will simply use the return statement and simply use a method of insert record. That I have to create, again, inside our content provider class, so simply press alt enter, and let us create this method here, down the side. So when the pattern is actually matched, and when it is actually matched for the whole table, then this case will be executed. And then this method will be executed. So, this method down the side will be called. And now, inside this method, what I will do is, I will simply get the instance of the SQL database. So let us get this statement from here and let us paste it here, and then from the main activity, I will simply copy the statement, this one, and paste it inside the insert record method. So here I am simply using database dot insert method, the name of the table, and then null column hack as well, and then I am simply using the content values instance. Now, again, this method will simply return the row ID where our data has been inserted. And now, down the side, this method insert simply returns a URI. The URI of the newly inserted row. So here, down the side, I will return content URI class. Dot with upended method. Simply pass the URI, that is the incoming URI from the main activity, and then the row ID. And now suppose something went wrong while inserting data into the database. So that row ID will be returned as minus one. So let us write an if condition. If something went wrong, then simply return null. So we are now done with the insert operation. Now inside the insert method here, what I will do is, let us remove this return null, because the statement was unreachable. And now, when we are going to return a URI of the newly inserted row, then it will be received inside the main activity. So here, inside the insert method, let us use the content provider class to insert the data into the database. So now, let us use get content resolver dot insert method, simply pass URI and then the content values. Now, as a first parameter, it simply expects a content URI. So the content URI in our case is actually nation entry dot content URI. And now, as a first parameter, simply pass URI comma content values, and now, this value insert, simply returns the URI of the newly inserted row. So let us use URI space. And now let us print out the URI by simply using the log statement. So, finally, what we are actually doing inside our application now. Instead of using the database directly from the main activity and inserting the data, we are simply using the content provider to insert the data. So, for that, we need to have the instance of the content resolver connected to this activity. So here, let me remove these two statements. We no longer need it. So now we are using the content provider to insert the data into our database. So when this statement will be executed, this will actually trigger the insert method inside the nation provider. So this method will be executed inside the content provider. So here, using the URI matcher dot mask method, we are actually checking out the pattern of the incoming URI that we are actually passing here as a first parameter. Now, after matching the URI, when we see that it is for the countries table, as a whole, then we are simply calling the insert record method that we have defined here. And now, inside the insert record method, we are simply calling database or insert method and simply passing the first parameter as table name, let us change it to table name parameter, that we are getting here. And then the content values. So finally, we are inserting some data into our database using the content provider class. Let us now run the code and let's see what happens. Let us write the country name, let's say China. Continent name as Asia. And insert the data. So in the log you can see item inserted and here we get the URI of the newly inserted row. This is the authority followed by the nation provider class followed by the path name of the table, and then the row ID as eight. And now, if you click on query and display all button, we get all the data from the database that is all the content of the database right in front of you, where the last row is China and Asia. So, in this way, we can simply insert the data into the database using the content provider in front of you.

Query Operation Using ContentProvider and ContentResolver
Let us now proceed and check out how do we perform the query operation using the content provider class? So for this, as well, we are going to follow the same steps that we followed in the previous video. So inside the main activity, I will simply navigate to the query method. So, down the side, I have query and display all method. Now, inside this, we are simply accessing the database directly from the main activity. So our requirement is to use the content provider to query the data. So what I will do is, I will simply comment out this statement. And then I will simply use get content resolver. Dot query. And simply pass on the content URI projection selection, selection arguments, and sort order in this sequence. Now, this URI is basically the content URI, so let us define it here. So here I have simply defined the content URI that we are simply passing as a first parameter here. Now this query method, similar to database dot query method, returns a cursor object. So let us use cursor space cursor equal to get content resolver dot query method. And now the rest of the code to print out the values will remain same, and our next step will be to move inside the nation provider class, where we are simply going to modify our query method. Where I will get the database instance. Now, this time, I will use get rid of database method because we just want to read the database, not write to the database. And then define the cursor, reference, and then I will use the switch case statement to match the incoming URI. I will not define the case for the whole table that is countries constant and then I will define the default case. I will lock out the code from the main activity. And paste it inside the case of countries. And then end comment the code. So let us now clean up our code. So here, what I have is, I have the first parameter as table name, then projection, selection, selection arguments, and at last, I have the sort order. It is totally similar to what we saw in the main activity in our previous module. So this will simply return a cursor object. And now at the end, I will simply return the cursor object. Which will be received inside the main activity here at this point, cursor. And then I will simply print out all the data. Let us now run the code. Let us click on query and display all button. And there we go, we are getting the same output that we got in our previous module. So with the help of content provider, we are able to access the database from the main activity. So from the main activity, we are passing the URI. And this URI is received inside the nation provider query method. So this is the incoming URI from the main activity. And with the help of URI matcher dot match method, we are matching it with our defined pattern that we have defined here. So this is the first match. So after matching with the pattern, we are then calling the database dot query method and then returning the cursor object. So this is the actual flow of our application. Now, if you notice, we have one more query method inside the main activity. That is query row by ID. So, this query row by ID for that, we have to make use of the pattern that we have defined here. The pattern of the ID. So, for that, I have a constant value of countries underscore ID equal to three for a specific row in a table, identified by ID. So inside the query method, I will write one more case, such as case of countries underscore ID. And then, break statement. And what I will do is, inside the main activity, I will simply cut the statement that is this statement from here and paste it inside the nation provider case. Countries underscore ID. And then format the code. So this statement is actually similar to this statement. The only difference will be in case of selection and selection arguments. So this will again return a cursor object that will be received inside the main activity. So here, what I will do is, let us use cursor object equal to get the content resolver in order to access the content provider dot query method, simply pass the URI. Now, this time, the URI should contain the question mark parameter as well. That is underscore ID. So for that, we have to upend the row ID at the end of our content URI. So let us use URI dot with upended path. And then use content URI comma row ID. This will return the URI. And then simply pass the first parameter as URI projection selection, selection arguments, and at last, the sort order. Now the selection and the selection argument we have already find here. So we don't have to define it again. Just we need to create a URI that we have to pass inside the content provider class, using the query method. Which will be, again, received inside the query method here. So after matching it, we are going to get this case. And then, execute the query statement. And finally return the cursor. And also, if you want, you can combine these two cases together because these two lines of code are exactly similar to each other. Or else, if you want, you can also extract the row ID from the incoming URI. But for the time being, let us keep as it is, just to avoid any confusion, since this is a big course. Let us now run the application. So let us now enter our row ID and let us test our code. So let us enter one and query by ID. And here our application has simply crashed. Let us see the exception. It says that illegal argument exception. So, if you click on this statement, it will simply take you to the default case. Where we are simply throwing the illegal argument exception. The URI was actually unknown, but if you look at the log, you will find the URI was perfectly OK. It has a package name followed by the content provider name followed by the path name and at the end, I have the row ID. Now what's happening here is that at the top, we have simply defined the URI pattern sequence. Now, here, first, we are actually having the slash asterisk now. The sequence in which the patterns are defined will be given more priority. So here the asterisk simply matches with any character. Now, in case of any character, a number is actually a character, as well. So this pattern will simply match with the number row ID. So what I will do is, I will simply give more priority to this hash. So simply cut it and paste it just above the asterisk. So now we are giving more priority to this hash than this asterisk. Now, if I run the code right now, and then test our code by simply entering some number, query row by ID, then in the output, we have run India Asia. So in the first row, we have India. Let us try something different. Let us enter eight, query by ID. And here we get China in the output. So remember, the sequence of the patterns also matters. So here I will give more priority to the wildcard character of hash, then asterisk, so as to avoid any error or confusion by the URI matcher. So this was all about how we queried data using the content provider.

Exploring More on Query Operation
Before I conclude this module, I would like to add some point for the query operation that we defined inside the content provider. So, here, inside the Android Studio, within the nation provider, we have the query method that we just defined in this module. So this is the query statement to query all the data from the database. The URI and rest of the parameters are being sent from the main activity, within the query, and display all method. So this is the statement that is being called. If you notice here, we have selection and selection arguments as null. Which means, if you pass here, directly null, then also our code will work absolutely fine. Now, in case, if a client application or your main activity, give some valid value to the selection and selection argument parameters. So in that case, we have the URI defined for the whole table, which will again match with the case present here. But in case of some error, the selection and selection argument parameters coming from the main activity it is not null, then we won't get some desired result, so in that case, what we can do here, we can put the value of selection and selection argument as null manually. So this will make our application more robust and more flexible. So this case will only serve the purpose to retrieve all the data from the database. And similarly, we have countries underscore ID. Where we have a valid selection and selection arguments parameter. And along with these two parameter, we have projection and sort order as well that we are sending from the main activity within the query row by ID method, so this is a statement that is being called. Here you can notice we have the valid values for the selection and selection arguments. We are passing the row ID and we expect to get a particular row from the database. Now in case the client application will send null, and here, as well, null in place of selection argument, so in that case, the URI will be for a particular row. But our selection and selection argument is currently null. So we need to take some precaution in order to avoid such error. So inside the nation provider class, within this case, what I will do, I will again define the selection and selection arguments from the incoming URI. So this URI for this case contains the row ID upended at the end of content URI. So here, again, let us use selection equal to nation. Entry dot underscore ID. Plus equal to question mark. And then define the selection arguments, as well. Equal to new string. And define its content as content URIs dot parse ID and then parse the value of the incoming URI from the main activity here. Now this method returns a long value, which is basically a number, so we need to convert it into a string. So let us use string dot value of method and then pass content URI dot parse ID. So this method parse ID will get the row ID upended at the end of this URI. Which is coming from the main activity, and then our selection argument will be similar to what we have defined here. So there will be no chance that our application will run into error or we get some unexpected result in our cursor object. So this makes our query method more robust and more flexible. And now, inside the insert method, the code will remain same, so there will be no changes inside the insert method. So that's all for this video.

Summary
So throughout the demo video of this module, we were passing the URI from the main activity to the content provider and it is a task of URI matcher to match the URI with the available patterns. So with the help of patterns defined, we were matching it with the best suitable patterns. And with the help of that pattern, we were actually checking out which case needs to be executed and what data we want from the database. So accordingly, the database was returning some data as per the incoming URI. So, finally, we have reached the end of this module. Now, in this module, we learned about the content provider implementation. By using the subclass of the content provider, and overriding the abstract methods, we also learned about the authority string, the content URI, the URI matcher, and also the content URI patterns. And we also checked out the operations such as the insert and query operation, using the content provider. And at last, never forget to declare the content provider inside the manifest file of your application. Because the content provider is similar to activity dot cast receival and a service. It is a building block of Android application, so if you don't declare it inside the manifest, your application will probably crash. So this is all for this module. This is Sriyank Siddhartha signing off. Thank you.

Implementing Delete and Update Methods
Update Operation Using ContentProvider and Content Resolver
Hi, this is Sriyank Siddhartha and welcome to the next module of this course of Android Fundamentals Content Provider. In the previous module, we actually explored the insert and query operations. Now in this module, we are going to perform the delete and update operation using the content provider. So for this, let's not waste time and let's check out how do we perform the update operation using the content provider. So here inside the Android studio. Let us now focus on the update operation. So inside the main activity, at the top, we have the update method. Now instead of using the database. update method, what I will do is I will use getContentResolver. update method. That simply express the first parameter as the URI. So again, I will define Uri which is present inside the contract class. Then as a first parameter, I will pass the CONTENT_URI and as a second parameter we are going to pass the contentValues that we have defined here. And now, third parameter will be the selection and then the selection arguments. And similar to database. update method, this method will again return the number of rows updated. So let's copy it from here and paste it again here and then copy the log statement again and paste it down the side. And let us now strike out these two statements. Now inside the content provider class, let us get the instance of the SQLiteDatabase. Now this time we need the writableDatabase because we are going to modify our database that is perform the right operation. And then let us use the switch case statement along with the default statement. And then write the case for the Countries table as a whole. And now let us call a method, let's say return. updateRecord and then simply pass a parameter of contentValues, selection, selection arguments, and then the table name. So let us now create this method. Simply press alt + enter and create the method. And inside this method, what I will do is I will simply cut the statement that we have commented here. Cut it and paste it inside the updateRecord method. And then we need a database instance. So let us cut the statement from here and paste it inside this method. And finally return the number of rows affected due to this update process. And here we can simplify our code by simply using the table name here, which is coming from here, table name, and then the contentValue as just values. And now inside the update method, let us remove this return statement which is unreachable in nature. So the flow of the code is from the main activity. So from here, we are passing the CONTENT_URI that falls inside the content provider class inside the update method here. Using the uriMatcher, we are simply matching the pattern that will match with the case of COUNTRIES. So inside this, I am simply calling updateRecord method. And here we are updating our SQLiteDatabase. Let us now enter code. Let us enter the name of the country as China and its new continent as Asia New. Let us update our data. So here the number of rules updated is one, and then display all the content of the database. So at the bottom, China has a new continent of Asia NEW. So our codes are working perfectly fine. We are able to update our database using the content provider.

Delete Operation Using ContentProvider and Content Resolver
Let us now proceed and check out how do we perform the delete operation using the content provider in Android. So here inside the Android studio we are again going to follow the same process that is inside the main activity. Let us navigate to the delete method. So here we have selection string as column name equal to question mark. So variable, we have the country name of Japan. Delete all the entries from the database. So down the side let us use getContentResolver to access the content provider. delete method. And simply pass the first parameter as uri and then the selection where class, and the last parameter as selection arguments. Now the URI should actually represent this statement, WHERE country = "Japan". So let us define our content uri such as Uri uri = uri. withAppendedPath. And then pass NationEntry. CONTENT_URI, followed by the country name. So this URI will simply state the content provider to delete a row where the country equal to question mark. That is, suppose if I enter Japan, then delete a row WHERE country = "Japan". And now this will again return the number of rows deleted. So simply copy it and paste it here. And let us print out using the log statement. And then let us command these two lines of code or simply remove the log statement from here. And now inside the nation provider inside the delete method, I will again write my switch case statement. Now this time our case will be different. So the case will be for COUNTRIES_COUNTRY_NAME. So here again I will simply call a method, let's say deleteRecord which we are going to create shortly. That takes a parameter of selection, selection arguments, and the name of the table. So let us create this method, alt+enter. And now let us write the code inside the delete record method by simply getting the instance of the SQLiteDatabase. Now this time we want to have the WritableDatabase. And then what I will do is from the main activity I will simply cut the statement and paste it inside the deleteRecord method here and simply uncommand it. And now let us return the number of rows deleted. So this return value will be received back here which will be again in return received inside the main activity that is here with the help of this variable. And then we're finally printing out the number of rows deleted. And now let us run the code. So here our application is now up and running. Let us now first query and display all. So here is the content of our database. Suppose I want to delete Nepal. So I will here enter Nepal and then hit on delete. So the number of rows deleted was one. And here if you notice our URI appears to be like this. After the path of countries we have Nepal. So this is actually the valid character string. This will simply match with the pattern that we have defined at the top. That is this code pattern of the asterisk right. So when this pattern will be matched, then this case will be executed, that is case COUNTRIES_COUNTRY_NAME. So this case will be to delete a specific row with the help of the name of the country. So in the output console, suppose, if I click on Query and Display All right now we don't have Nepal anymore inside the database. So the row was successfully deleted. Now if I give you a problem statement, instead of using the country name, if I ask you that you have to delete a particular entry from the SQLiteDatabase using the Row ID that we are using here. So for that what you will do is inside the delete method you have to write one more case. That is for the case of COUNTRIES_ID. So this will be the case to delete a particular row with the help of its ID. So here what I will do is I will again call this method, return deleteRecord and then pass selection, selection arguments, and the table name as NationEntry. TABLE_NAME. And from the main activity we have to simply change our URI. Such as, instead of country name, we have to pass the rowID that the user will enter inside the edit text where currently we are simply passing the country name. And now at the end, suppose you want to delete the whole table, that is you don't want to delete a specific row with the help of ID or you don't want to delete a specific row with the help of its country name. You want to delete the whole table so for that you have to write the case of, let's say case for the whole table and then you have to simply call return deleteRecord and simply pass null as a first parameter that is selection and also selection argument as null and at last the table name to delete. So passing null as a value as a first two parameter will simply delete the whole table that is our whole countries table. And now here we can again simplify the code. This parameter can be tableName again which is from here. So this was all about how to delete data from the database using the content provider in Android. Now after we have performed the update and delete operation using the content provider, if you notice, we are using the databaseHelper class instance directly inside the NationProvider class. So inside the main activity, if you notice, at the top we have the SQLiteDatabase and also the NationDbHelper instance. So we no longer need these two instance inside the main activity because we are now using the nation provider class to access the database. We no longer need the main activity to hold these two instance so let us remove it and at the bottom, if you notice, we have some error. Let us navigate down the side and at the bottom we have the onDestroy method. So let us clean up our code and remove this code. So this marks the completion of this video.

Exploring More on Delete Operation
Before we conclude our module, I would like to add few lines of code inside the delete operation so as to make our code more flexible and robust. So here within the NationProvider class, let us navigate to the delete operation method. So inside the delete operation method, we are getting the URI from the main activity. Now suppose the URI from the main activity is equal to, let us assume this URI. So this will match with this case of COUNTRIES which means our client application wants to delete the whole table. So we can pass null and null as a parameter for the selection and selection arguments. So we don't have to make any changes in case of COUNTRIES. But suppose the incoming URI is equal to countries followed by when, oh let's say two, it has a row ID appended at the end. So for that, we have a case defined here as COUNTRIES_ID which means delete a particular row inside the table with the help of the ID present at this position, two, which is at the end. Now by mistake from the main activity, suppose users send selection value as null and also selection argument as null. So in that case the URI will simply match with this COUNTRIES_ID, but due to the values of selection and selection argument it will delete the whole table accidentally and it will result into a blender. So for that what we can do, again define the selection and also selection arguments such as NationEntry. _ID + =? and then define the selection argument like we have defined at the top in case of query method in our previous module. So here let us copy these two lines of code and replace the selection and selection arguments here as well. So now with the help of incoming URI we are extracting the ID from the URI and storing it inside the selection argument string array and then passing the respective values inside the deleteRecord method here. So this completes our case of COUNTRIES_ID. But what about COUNTRIES_COUNTRY_NAME? So for that suppose the incoming URI is other type of, let's say, country name appended at the end of the URI which means delete the row where the country name is India. So for that, again, we have to be sure that the selection and selection argument bears some value so that we can delete this particular rule from our database table. So for that, again, let us define selection parameter equal to NationEntry dot, now this time, COLUMN_COUNTRY + =? again and then define the selection argument. Now, to define the selection argument, we need to get the value of India from the end. So for that purpose what we can do, we have a method of uri. getLastPathSegment that returns a string. Now, we can assign it to selection arguments parameter equal to new string array and then the pass the value as uri. getLastPathSegment. So this will result in extracting the value of India which is the last path segment of this URI. So we will get our desired selection arguments and then we can perform the delete operation as we were doing with the help of the deleteRecord method. So this makes our delete method more robust and more flexible and we have taken precaution to avoid any error or to get the unwanted result.

Summary
So at the end of this module, I would like to recall this slide again. Whatever operations that we perform with the help of content provider such as insert, query, update, and delete, it all depends on the URI that we are sending from the main activity. So whatever URI we send from the main activity it is again matched with the content provider URI patterns as mentioned. And after that we are able to perform specific operation inside our database. So finally we have reached the end of this module. So in this module we learned about the update operation and also the delete operation. And this marks the completion of all the operations related to the SQLiteDatabase using the content provider. This is Sriyank Siddhartha signing off. And thanks for watching. Have a good day.

Exploring Miscellaneous Concepts
Overview
Hi, this is Sriyank Siddhartha, and welcome to the next module of this course of Android fundamentals content provider. In this section, we are going to explore a few of the miscellaneous concepts related to the content provider in Android. So first of all, in this section, we will check out various concepts related to the loader APIs. Now under the loader APIs, we have various classes and interface. These classes and interfaces are CursorLoader, LoaderManager, and also LoaderManager. Callbacks interface. So we will explore each and every concept related to the loader API in detail, and also, we will check out what is a Cursor Adapter and also a subclass of SimpleCursorAdapter that is used to display the list of item by fetching data from the SQL database using the content provider.

Initial Project Setup
So first of all let us check out the flow of activities inside our application that we are about to make in this section. Firstly, we have the MainActivity. Now on click on Query and Display All button. Previously we were displaying all the data inside the log tab but now onwards on click of this button we will first open the new activity that is the NationList Activity. Inside this we will now display all the data in the form of list. So these are all the contained of the SQL database that we are fetching and displaying in front of you. Now what about the Insert Update and Delete operation. How are we going to perform these operations with the help of this desk view. Suppose user click on any of the item. Let us assume this second item of Indonesia and Asia. If user click on it then we will navigate to a new activity whose name is NationEditActivity. Now inside this activity either the user can update and delete their data. So if the user want he can update the name of the country and also the continent as well as if he want he can simply delete the rule. And what about the Insert operation? So for this we have the we have the floating action button inside the NationListActivity. So on click of this button we are again going to open the NationEditActivity that appears to somewhat similar to the previous layout. So here user can enter the country name and also the continent name and then click on Insert button to insert the data into the database. Now if you notice these two layout are almost similar. The only difference will be in the operation that we're about to perform inside the same activity. So these two things are basically one activity that is NationEditActivity. So in the runtime we will dynamically update the UI to perform the Update Delete and Insert operation. Here inside the Android studio this is the same application that we created in the previous module. So first of all let us now proceed and change the project view to project level hierarchy and then expand the project and module. And down the side you will find the build out data file. Let us open this file. And here we have some dependency and also few code. So down the side within the dependencies section I will now add some dependency for the Android material design support library and also for the card view. Android support design followed by colon and then we have to mention the version name of this support library. So for that we have to simply copy the compile sdk version. For me it is 25. If you have 26 or 27 written here then simply copy that 25 or 26 the number and paste it here after the colon. For me it is 25 followed by. 0 and again. 0. That is the suffix. Now if you notice here. It shows some warning. A new version is available that is 25. 3. 1. Let us now update it to 25. 3. 1.. Now remember for your case the compile sdk version might vary. For me it is 25. And again for your case the suffix of this library may vary. For me it was showing 3. 1. So I simply edited 0. 0 to 3. 1. Now again let us add the dependency for the cardview. Now after colon again we have to write the compile sdk version that is 25. So let us type 25. 0. 0. Again it shows some warning. The new version is available that is 3. 1. So let's make it 3. 1. And now sync the project. Let us now again navigate to our exercise file of this module such as m6 exercise file. Now inside the before project let us navigate to source, name, source and layout folder. Inside of which you will find the nation_list_item. xml and also activity_nations_edit. xml. Along with this we have activity_nationsedit. xml. Let us copy these three xml file. And paste it inside the resource layout folder. Here. And within the main package we're about to add some file. So again let us navigate to java and I reach into our package and there you will find NationListActivity and also NationEditActivity. Let us copy these two files and paste it within our main package. And there we go. We have added a couple of layout files and also the java files into our project. Now the NationListItem. xml appears to be like this. This is going to replace a single list item off our list view. For example here this is our list view and these are the layout for each of the list item. So this is basically NationListItem. xml. And next we have activity_nations. xml that contains a list view and also a floating action button at the bottom. Now remember we are using here the coordinator layout and also the floating action button. So make sure you have added the dependency of the material design support library inside build out level file successfully. So this layout represent the layout of our NationListActivity. java. So this is the layout that I just showed you inside the Android studio that contains a list view and also a floating action button at the bottom. And now then we have activity_nations_edit. xml. So this layout appears to be like this. That resemble these two layout present in front of you. And now corresponding to these layout we have NationListActivity and also NationEditActivity present inside our main package here. This is our NationListActivity whose layout is activity_nations. xml and this is our NationsEditActivity whose layout is activity_nations_edit. xml. And inside these two classes I have simply initialized all the edit text and also the button. And down the side I have implemented the onClickListener on all the buttons. On click of these buttons the onClick method will be executed which will then execute the Update Delete and Insert method present down the side. And inside the NationListActivity I have simply initialized my list view and also the floating action buttons. Now add the end inside the AndroidManifest. xml I will now declare my two activities such as NationListActivity and also NationEditActivity. And finally on click of this button we are going to navigate to our NationListActivity. So let us write the intent code for that. So inside the main activity down the side we have our queryAnddisplayAll method which when executed display all the data of the database with the help of log statement. Now inside this let us write our Intent to open our NationListActivity and down the side whatever code that we have written here such as projection, selection and so on that query method let it be like this. This will act as a reference so that you can revisit this project and get all the code snippet to query and display data inside the log tab from the database. So this marks the completion of the initial project startup inside the Android studio.

How Loader APIs Interact with Each Other
After we have completed our initial project startup let us now proceed and check out the loaded API in Android. So what are the significance of loaders or loaders APIs. These APIs helps to load data from the ContentProvider. Now the ContentProvider in return can fetch the data from any data storage. That can be a file or some SQL which is our current application scenario. And it helps to display all the data inside the activity or a fragment. Now the most important point that makes our loaders very special is that it runs on a separate thread. That is it does not block the main thread and it performs all the operation on the separate thread without making our application main UI unresponsive. And this makes our application run very smoothly. And now there are various other classes that are related to the loader API. So let us check out these classes and also the interface one by one. The first class is the class of LoaderManager whose main task is to manage the loaders inside the activity. So when we are going to use the loader inside our activity it is the task of LoaderManager to manage it. Now sometimes we might have the multiple loaders inside our activity or the fragment. So in that case the LoaderManager manage all the multiple loaders present inside the activity. And also remember there is only one instance of the LoaderManager associated with our activity or the fragment. And then we have the interface of LoaderManager. LoaderCallbacks. Now this interface defines few of the abstract methods such as onCreateLoader which is a callback method again. And it is called when we need to create a new loader. And then we have onLoadFinished when the loader has finished loading the data for the activity class then this method is called. And at last I have onLoaderReset when the Android framework or the developer itself try to describe the old loader then this method is called. So inside this method we have to release all the resources to free up the memory. And at last we have the CursorLoader class. Now this class works with the loader API. And works asynchronously in the background thread. That is in a separate worker thread and this CursorLoader loads the data from a content provider using the content resolver object. And since the cursor loader works in the background so it does not block the main UI thread. That is without affecting your current activity it will do all the job in the background. And now at the end you must be thinking how the LoaderManager, LoaderCallback and CursorLoader are actually related to each other. How they basically work to display the data in the list view in front of you. So for that I have a special slide for you. So how do we implement the loader API and its related classes and interface. Now whatever loader API and the classes we are about to implement in this module we will do it inside the NationListActivity. So inside the NationListActivity all the list items that you can see in front of you has been faced with the help of Loader API and its related classes from the SQL database. Now during this process how all the interface and classes are working. So when the NationListActivity starts we will first initialize our loader. Now here I have mentioned CursorLoader which is basically the subclass of the loader. So we can call the CursorLoader as just a loader. Now it is the task of CursorLoader to interact with the ContentProvider with the help of ContentResolver object. Previously whenever we were interacting with our ContentProvider we were doing it with the help of ContentResolver object that we were getting with the help of getContentResolver method. Now this time it is a CursorLoader object that with the help of ContentResolver object ask the ContentProvider to fetch some data from the database. So the ContentResolver provides the cursor object back to the CursorLoader. Now this is a cursor that contains all the rules that has been queried with the help of ContentProvider from the database. So finally we have got cursor object with the help of which we can get all the data from all the rules that has been queried. Now the CursorLoader what it do. It simply send the cursor object to the SimpleCursorAdapter class. A SimpleCursorAdapter, it is basically an adapter class that manage all the cursor data. So it uses a cursor to display all the data in our list view. So this is how our application is going to work. The CursorLoader with the help of ContentResolver will ask the ContentProvider for the data. The ContentProvider in turn will fetch the data from the database and return a cursor object. Now this cursor object will be then sent to the SimpleCursorAdapter which in turn will display all the data in front of you inside the list view. And at the end we have a special class of LoaderManager and also we have the interface of LoaderManager. Callbacks. Now this class and this interface is present above all. The task of LoaderManager is to manage the loader that we are using here. That is our CursorLoader object. And the task of LoaderManager. Callbacks is to execute all these methods depending on if there is any loader event such as the Loader loads the data or the activity gets destroyed. So in that case these methods will be executed.

CursorLoader, SimpleCursorAdapter, LoaderManager, and LoaderCallbacks
Let us now proceed an implement these APIs and classes inside the NationListActivity. So first of all let us use the LoaderManager to initialize our loader object. So inside the Android studio let us navigate to NationListActivity. Now inside this class within the onCreate method I will use the instance of the LoaderManger associated with our activity. So with the help of this method getLoaderManager we are going to call initLoader method. So this method will simply initialize our loader. Now the first parameter it expects is the ID of the loader which can be any number such as one, two, twenty, ten and so on. Let us use N as of now. Now the second parameter is a bundled argument that will be used to initialize our loader. But currently let us pass null and then the total parameter it simply expects the instance of the object that will implement the LoaderCallback interface. So as of now let us pass the context of NationListActivity. Now if we're passing the instance of the NationListActivity so far that we have to implement the interface of LoaderManager. LoaderCallbacks. Now as a template let us use cursor object and then press all enter and implement all the methods. All the three methods. Down the side. So here we go these are the three callback methods of the interface of LoaderManager. LoaderCallbacks. And then our next step will be to create the SimpleCursorAdapater that will use the cursor object to display all the data in our list view. So here at the top let us use private SimpleCursorAdapter and then inside the onCreate method let us use SimpleCursorAdapter equal to new SimpleCursorAdapter. Now what are the parameters that it expects. So these are all the parameters that we need to pass inside the SinpleCursorAdapter. The first is the context of this activity. So let us pass this and then it requires the layout in which you want the data to be inflated so for that we have the layout of NationListItem. xml with in which we want to populate our data. So here as a second parameter let us pass R. Layout. nation_list_item. xml and then the cursor object. So currently we don't have any cursor object. So let us pass null. And now the next two parameters are the from array string and the to array string. So for that we have to first understand what does it stands for. So first of all how does a SimpleCursorAdapter maps the data inside the ListItem. xml. Now suppose we have nation_list_item. xml presented here that have two text view to represent a country and also a continent. Now these two text view contains some ID. So here we have the initial array of to that contains the ID of the respective text view such as R. id. textview which represent Indonesia and R. id. textviewContinent which represent Asia. And corresponding to this string array we have string from array that contains the name of the respective columns of the database such as Column_Country and Column_Continent. So when we are going to receive a cursor from the content provider the loader API what it will do it will simply pass on the data of the Column_Country to this text view. And similarly the cursor loader will pass on the data of the Column_Continent to this text view. And finally we get the value as Indonesia and Asia. So as per our case we are going to display the name of the country and name of the continent. So accordingly let us define our string array of from let's say NationEntry. Column_Country followed by the second element as NationEntry. Column_Continent. And now let us define our string array of to. That will contain the ID of the text view that we have defined inside the nation_list_item. xml. That is txvCountryName and also txvContinentName. So inside this let us define R. id. txvCountryName and then txvContinentName. And now these two ID are basically the integer values. So let us change our data type to integer array instead of string array. And then pass on the array as from and then to. And at last we have the flag. So let us make it zero. And then let us throw some light on this cursor object that we are passing here as null. So for that here what we can do inside the onCreate loader whenever we are going to create a new loader this method will be called. So inside this method we are going to create the instance of the new CursorLoader. That again takes the parameters of the context. Let us pass context of this activity and then it expects the content URI. So let us define NationEntry. Content_URI. And then the third parameter it expects is the projection. And then the selection which is our Where clause and then the selection arguments. And at last the sort order. Now here this statement simply means that we are creating a CursorLoader which is the subclass of the loader. Now this instance is responsible for returning a cursor. Now that cursor object will carry the reference to all the rules present inside the database. Now as for the demo videos that we saw in our previous module we know that when we want all the data from the database we need to make the selection, selection argument and also the sort order as null. So this will return all the data or all the rules present inside the SQL Database. Now the only thing we have to define is the projection. So let us define our projection equal to let us define the name of the column. Now previously we were raising a request for all the three column but now we are going to ask for the column of the country and also NationEntry. Continent and here we are not requesting for the column of NationEntry. _id because we are only concerned for the column Country and column Continent. We don't want the ID. So let me write the command line for you. So this statement returns a CursorLoader object that carries a cursor object, right. And the cursor object contains all the rows queried from the database using the ContentProvider. And now inside the onLoadFinished which is called when the loader has finished loading the data. So when the data has been loaded we have to call adapter or the SimpleCursorAdapter. swapCursor. And then pass this cursor object. Let us make it cursor. And inside the onLoader the insert method again. simpleCursorAdapter. swapCursor and then pass null. Now what does the swapCursor method do. When this statement is executed it welcomes the new cursor and returns the old cursor. But the cursor return is not closed. So the Android framework takes care of closing the old cursor and releasing the resources. And when this method is executed onLoaderReset then what we're doing is we are then releasing all the resources by making our cursor null. That is destroying the old cursor. And now at the end let us attach the simpleCursorAdapter with our ListView. So let us use ListView. setAdapter and pass SimpleCursorAdapter as a instance. So finally we have completed the Loader API implementation and its related classes and interface. We checked out how we are creating the instance of CursorLoader that returns a cursor object that will be used by the SimpleCursorAdapter. And the SimpleCursorAdapter in turn will display all the data inside the ListView. So currently if I ran the code right now then our code should work. As per the slide that we saw just now. So let us now run the code. Down the side let us click on Query and Display All method. And there we go. Our application has crashed. Now let us check out what is the error. So inside the log tab you can notice it says that illegal argument exception. The column_id does not exist. Now to make a simple cursor adapter work and populate all the data you need to also query for the _id column as well So here again inside the projection we need to compulsorily use the _id. Now you must be thinking inside our layout we are now going to display our row ID. We are only concerned for the country name and also the continent name. So why do we need to have this _id column as well We need this column because the SimpleCursorAdapter only works if the row ID has a column name of _id. If we are not going to ask for this _id column then our code will not work. So let us try to run our code right now and let's see if it works or not. Let's click on Query and Display All button. And there we go. Here are the list of all the countries that we have inside our database. I have inserted all these countries and also the continent name from our front page. So make sure you insert few of the country and continent name and click on this button and here we have list of all the countries along with the continent name. Now whatever code that we have written inside the NationListActivity you can get the clarity of the code flow with the help of this slide. How the CursorLoader, ContentResolver, ContentProvider and SimpleCursorAdapter are together working to make our UI appear to be like this. So in the next video we are going to implement the functionality of Update Delete and Add operation on our database.

Delete and Update Operation
Let us now proceed and check out how do we implement the Delete and Update operation on our ListView. So if you remember this slide whenever we click on any of the List Item we will navigate to NationEditActivity within which we are going to perform our Update and Delete operation. So inside the Android studio let us implement the onClickListener on our ListView. So down the side what we can do. Let us use ListView. setOnItemClickListener. And implement the interface of OnItemClickListener that has a method of OnItemClick. Now inside each of the row that we are requesting we have three columns present. Out of which we are inflating the Column_Country and Column_Continent. Now each of the row represent a particular cursor object. So what we can do is let us define the cursor at the top. And then inside the OnItemClick let us use cursor equal to our parent which is our AdapterView. getItemAtPosition. And let us pass the position as this parameter here. And now when we request for item at the particular position we get the object. Now that object is of the type of cursor. So let is type cursor into the cursor object and now with the help of this cursor object we can get all the values present inside these row. So let us first get the ID and then the Country Name and finally let us extract the Continent Name. So with the help of the current cursor object we have got the ID, country and also the continent. And now after this we want navigate to NationEditActivity inside which we can perform the Update or Delete operation. So for that let us write our Intent and then send all these values of ID, country and continent with the help of Intent. And finally start the activity using our Intent. So this Intent will carry all the value of ID, country and also continent to our NationEditActivity. So inside this activity let us retrieve our Intent and get back all the data. So down the side let us use Intent space equal to get the incoming Intent. And then define int_id equal to intent. getIntExtra and give the key similar to what we have given here this ID. Let us copy it and paste it here. And then give the default value as zero. And similarly let us extract the name of the country and also the continent. Now make sure the key of country and continent matches with the key that we have defined here. These two. And after this let us write our condition to check if we want to perform the Update or Delete operation. So if our _id is not equal to zero then what we can do set the text of the etCountry as country and the value of etContinent as the continent that we are retrieving here. And finally set the visibility of the insert button as gone. That is hide the insert button because we want to either delete or update the data not insert the data. Now if this condition fails then we have the Else part which will be for the Insert operation. So inside the Else part we will write some code to prepare our demo for the Insert operation. So here I will make the visibility of the update and delete button as hidden or gone. So let me write the command line so when the Else block will be executed we just want to perform the insert operation or insert the row into the database. And now on click of update or delete button the onClick method will be executed which in turn will execute the update and delete method that I present down the side. So first let us write our code for the delete button. So here at the top we are retrieving the row ID, country and also the name of the continent. So let us make it as a field variable. And then remove the local declaration. And inside the delete method let us write our code such as getContentResolver. delete method. Now the first parameter it again expects is a URI. So in our case we want to delete a row which is present at a specific position. So for that let us use ContentURI. withAppendedId let us pass the ContentURI as NationEntry. ContentURI. And then append the ID as _id. So this will again return a URI. And this URI will appear like this. This is our authority followed by the part name and at the end we will have our ID such as two, three and so on like this. So let us pass our first parameter as URI and then the selection argument. So let us define our selection and selection argument. Let us pass selection and then selection argument. So through this statement we want to mean that delete a specific row. There the column_id has a value of let's say ID that we have defined here. And now this delete method returns the number of rows deleted. And then use the Log statement to print out how many number of rows were deleted. Now similarly inside the update method let us write our code. So for that what I will do. Let us copy the code from the delete method and paste it inside the update method. And here what did we do. Let us use the update method. That explains the second parameter of the content values. So let us define our contentValues. And then insert the values inside the contentValues object as Column_Country and then the name of the new Country that user has entered such as etCountry. getText. toString. And similarly let us insert the value inside the ContentValue as ContinentName. So etContinent. getText. toString. Now this time our URI will be different. So here we are only going to use our Content_URI. So NationEntry. Content_URI. So when the statement will be executed it will return how many rows were updated. So in case of update what we are doing is we are getting the new user input and inserting the values inside the content values object. And then here this is our content URI which is pointing to our database table of nations. And then we're calling the update method by passing the URI ContentValues and also selection and selection arguments. So when the statement will be executed it will update the row that satisfy the condition that we have mentioned here. Let us now run our code. Click on Query And Display All button. And let us update Germany. So here inside the edit activity let us update the name of the continent back to Europe. Click on Update. And now inside the log tab let us see what is the output. So here the number of rows updated is one. Now if I move back so here you will find our ListView has not been updated. We have just now updated the continent name to Europe from Europe New. But if you move back and then click on this button again you will find the updated continent name such as Europe. So when we edit our continent or country name we want it to be reflected in our ListViews. So for that we will write code in future. Now suppose we want to delete this row. So I will now click on delete button and in the log tab you will find number of rows deleted as one. So we have just now deleted that row but if you move back you will find Germany is still present here because our ListView is not getting updated. But if you move back and try to recreate the ListView again you will find the updated ListView. That is earlier the row that we deleted is now getting reflected in our ListView. So how to solve this issue we will check it out shortly in our upcoming videos. So in this video we have successfully implemented the Update and Delete operation on our ListView item. Now in the next video we will implement how to insert a new row inside our ListView using the floating action button.

Insert Operation
In the previous video we performed the Delete and Update Operation. Now in this video let us proceed and check out how do we perform the Insert operation. So for this we are going to make use of the floating action button. So on click of this button we will navigate to the NationEditActivity that will only contain the Insert button. So inside the NationListActivity. java down the side we have defined the floating action button. Let us use FloatingActionButton. setOnClickListener and implement the interface of OnClickListener. And insert this method let us use our Intent to open the NationEditActivity. And now since we are adding a new row so we don't have any row ID predefined. So for that let us pass intent. putExtra and pass the key as _id and value as zero. So when we start the NationEditActivity we are passing the value as _id that has a value of zero. So inside the NationEditActivity within the OnCreate method when this statement will be executed we will get _id value as zero. And we won't get any value of country and continent because we are not passing any value. We are only passing the value of _id as zero. So when this whole block will be executed this condition will fail because we have id equal to zero so the Else block will be executed where we are hiding the Update and Delete button. So when we are performing the Insert operation we will have only Insert button visible. On click of the Insert button this method Insert which is present at the bottom will be executed. So let us write our code to insert data into our database with the help of ContentProvider. In order to access the ContentProvider let us use the instance of ContentResolver. insert Now here we need to define the URI for our table. So URI uri equal to NationEntry. Content_URI. So our Content_URI will appear to be like this. It will have the authority name followed by the path to our table. So let us pass the first parameter as URI and then it expects the ContentValue. So let us define the ContentValue as this one Column_Country and Column_Continent. And pass the second parameter as ContentValues. So this completes our code. Now this insert method returns the URI of the newly inserted row. So let us use URI space and let us define our log statement. Let us now run the code. Click on this button Query and Display All. So let us click on this floating action button. Enter the new country name. Suppose India and continent name as Asia. Insert it and if you move back then at the end you won't find your country name because our ListView is not getting updated. Let us destroy the activity and open it again. But this time down the side you will find our new row inserted at the end. India and the continent name as Asia. And now if you compare all the code of Insert Delete and Update method you will find all the code are similar to what we wrote inside the main activity such as queryAndDisplayAll method, queryRowById, delete method, update method and so on. The insert method as well. So at this point of time you should be able to write code of Insert Delete Update and also Query with the help of ContentResolver and also using the ContentProvider. Only thing you have to take care of the parameters that we are passing inside each of the method such as the URI, contentValues, selection, selection arguments and so on. Now in the next video we are going to write code how to update our ListView whenever we make changes to our database.

Notifying the Observers
So finally let us now proceed and check out how do we notify the observers whenever there is any change inside the SQL database. Now inside the NationEditActivity whenever we perform Update operation, Delete and Insert operation we are basically accessing our ContentProvider class which is present inside the data package. So whenever we Delete or Update any record these methods are actually executed such as Delete Update Insert and also the Query method. Now inside each of these methods we are basically making some changes to our database with the help of ContentProvider. So whenever we make some changes inside our database we want to notify our adaptor that something has changed. So please update your view or redraw your layout so that the changes will be reflected inside our ListView. As for example if I update the continent of India such as from Asia to Asia New. Update it and move back. So here if you notice the changes are not reflected. But if you destroy this activity and recreate it you will find the changes is now getting reflected. So we want to reflect the changes immediately whenever we make any changes to our SQL database. So for that let us first start notifying the observer from the query method. So down the side let us use cursor. setNotificationUri. And pass the first parameter as the instance of ContentResolver. So let us use getContext. getContentResolver. And second parameter will be the incoming URI. And now inside the insert method whenever we insert any data into the database we want to notify the observer such as our cursorAdaptor. a. I have inserted some data into the database. So I am notifying you that redraw yourself because the database has been changed. So insider the insert record method what I will do is I will use getContext. getContentResolver. notifyChange. And then pass the URI here and then the second parameter as the name of the observer. Let us pass null. If you look at the documentation of the notifyChange method it states that the cursor adapter objects will by default get the notification of any changes that occurs inside the SQL database. So we don't have to register our simpleCursorAdapter to get notified for this change. Now at last we have to make sure that this statement is only executed then we have the data successfully inserted into the SQL database. So for that here inside the Else block that means we have the row inserted into the database successfully. Let us paste this statement. So execute this statement only when we have success. And now let us copy this statement and paste it inside the deleteRecord method as well. So here if only we have rows successfully deleted then execute this statement. Now here we need to have the URI instance. So let us use URI uri which is coming from some activity and here as well let us pass this URI to this method as a first parameter. And now at last inside the update method as well let us use the If condition if we have successfully updated the row. Then only execute this statement. Now again we have to pass the URI to this method of updateRecord. So here as well as the first parameter use URI. Let us now run the app and let's see if it works or not. Let us click on Query and Display All button. And let us edit let's say Indonesia. Let us change the continent to let's say Europe. Update it and let us move back. And there we go. Indonesia is now present in Europe. Let us now try to delete this item. Move back and there we go. We have got our updated ListView. So with the help of this statement we are notifying our observer which is our simpleCursorAdapter that hey there is some changes in the database so let us update our ListView. And also if you try to insert new item let us assume new country and new continent insert the data move back and at the bottom you will find new country and new continent inserted at the end of the database. So our codes are now working perfectly fine. So this marks the completion of our demo project for this module.

Summary
So finally we reached the end of this module. Now in this module we learned about the loader APIs and its related class and interface such as CursorLoader, LoaderManager, LoaderManager. Callback interface, Cursor Adapter. That has a subclass of SimpleCursorAdapter that we used to display the list of item using the cursor object. Now at the end I would like to recall the most important slide of this module. Whenever you are going to use the Loader and Cursor Adaptor using the ContentProvider inside your application then please revisit this slide. This slide will help you recall the code flow. How the CursorLoader, ContentResolver, ContentProvider and SimpleCursorAdapter are interacting with each other to display the list of items inside the ListView. And above all we have the LoaderManager and LoaderManager. Callbacks method that are responsible for managing the CursorLoader. And at the end we have the cursor being returned from the ContentProvider which is being used by the SimpleCursorAdapter to display the data. So this is all for this module. This is Sriyank Siddhartha signing off. Thank you and have a good day.

Exposing Your App's Private Structured Data Outside the App
Module Overview and Demo Scenario
Hi, this is Sriyank Siddhartha and welcome to the next module of this course of Android Fundamentals ContentProvider. Earlier in our course, so far we have seen that we were accessing the data storage that is the SQL database within own application. Now suppose there is some requirement that you need to expose your applications data outside the application to some other application. So for that purpose, we need to make some changes in our application code. So basically in this module, we will learn about how do we expose the application's private structured data outside the application. So what are the topics that we will cover in this module? In this module, we will try to access the private database of our application from outside some other client application and perform various operations, such as Insert, Query, Update, and Delete as well. And now, when we are exposing our application's private data to some other application, then it gives rise to the security issues, so for that purpose, we will enhance the application security using the Android permissions inside our application. And apart from the content provided that we created in our course, there are a few predefined ContentProviders, such as a system provider, provided to us inside the Android SDK. Now there are many predefined ContentProviders. The most commonly used providers are the Contacts Provider, Calendar Provider, and also the File Provider APIs. Let us all proceed and check out, what are the changes that we need to make inside our demo application to complete the module objective? So for that, we already have our application defined that contains the ContentProvider. Now this ContentProvider was being accessed with the help of the Activity class, such as the MainActivity. So this Activity class has the access to the ContentProvider which in turn provides the access to the SQL database which is the structured raw storage data present inside our application. Now let us call this application as provider application because it contains the ContentProvider inside our application. So that's why let us call this application as provider application. Now for this module, we want to access the database from outside the application. So for that purpose, I will create a new application and call it as client application. Now with the help of the client application, we will perform the Query, Insert, Delete, and Update operation to the database present here. So from the client application with the help of ContentResolver object, we will access the ContentProvider present in the provider application. And the ContentProvider in return will return the desired result in the form of cursor object, number of rows affected, or the content URI. So this is the overall scenario off of our demo application that we will make in this module.

Initial Project Setup
So let us now proceed a step ahead and check out the initial project setup inside the Android Studio. So here inside the Android Studio, this is the same application that we created in our previous module. Now our objective of this module is to access the ContentProvider such as a NationProvider from outside the application, not within the application. So for that purpose, we will create a new Android Studio project, and let's call it as ClientApp, and this is the package name of our application. If you want, you can edit it from here. Select the project location and hit on Next. Let it be the default one, hit on Next. Let us select our Empty Activity, and then hit on Finish. And then let us see in our project view to the project level hierarchy. Simply expand the Project, app module, src, main, java, and also res, layout folder. Now let me setup the client application and also our demo application that we created in the previous module in the same window. So on the left-hand side, we have the client application, and on the right-hand side, we have the provider application. From the client application, we are going to access the ContentProvider of the provider application. So first of all, let us do the initial project setup. So for that, from the provider application, let us copy the activity_main. xml and paste it inside the resource layout folder of the client application. Hit on Overwrite, and then modify the code inside the activity_main. xml such as remove the context. And let us now give the background color so as to differentiate it with the provider application. So here the activity_main. xml has a background color of this value. Let us check out the layout. It appears to be yellowish in appearance. And now our next step will be to copy the MainActivity from the provider application, and paste it inside our client application inside the package, and then hit on Overwrite. And inside the MainActivity, let us clean up our code. So first of all at the top, let us remove the import package and then down the side we have some error. Let's check it out. So inside these methods, the NationEntry which is actually present inside the Contract class of the provider application, so the Android Studio of the client application is unable to resolve this class. So for that purpose what we can do, we can either put this NationContract class within a jar and integrate that jar inside the client application. Or in another simple way, what we can do, let us open the NationContract. java class, and let us copy a few of the code from here such as let us copy the name of the columns and paste it at the top, inside the MainActivity of the client application. And then apart from the column names, we also need to have the content URI present inside the MainActivity of the client application as well. So for that purpose, let us define our CONTENT_URI equal to content, followed by colon, forward slash, forward slash, and then copy the authority name from the provider application. So let us copy the content authority from here and paste it after this, and at the end, append the name of the country they will name. So copy this countries, which is the name of the table of the database, and paste it at the end. And now, this CONTENT_URI is basically of the type of URI object. So for that purpose, we need to use the method of Uri. parse. That will convert this string into a URI. So if you notice inside the client application, we have the CONTENT_URI that appears to be like this. So this is basically the part that will make our client application to reach out the database of the provider application. And the value of the CONTENT_URI that we have defined here is similar to what we have defined inside the provider application here at the bottom, this one, CONTENT_URI. And now instead of having the public access, now we can convert it to private access. And down the side, let us modify our code. So instead of NationEntry. COLUMN_COUNTRY, let us only write COLUMN_COUNTRY. So this rectifies our error. One by one, let us change it instead of NationEntry. CONTENT_URI, let us put CONTENT_URI. And down the side, let us comment the update method content as of now. We will modify the code inside the update method later on. And then comment out the delete section, and also comment out the QueryRowById method as well. And down the side, we have queryAndDisplayAll method. Now inside this, we have some code related to the Intent. So let us remove it because we don't want it inside our client application. And then again, modify the projection, and down the side, let us modify NationEntry. CONTENT_URI. And now we are good to go inside the MainActivity of the client application. We don't have any error as of now, so everything looks perfect. We have defined the column names and also the CONTENT_URI locally inside the MainActivity of the client application. So this marks the completion of the initial project setup inside the Android Studio of client application.

Making android:exported="true"
So for our demo objective, we are already having the provider application created inside the Android Studio. Now whenever we have the ContentProvider present inside our application, then we need to declare it inside the AndroidManifest. xml. So here is our declaration. Here is the provider tag, and suppose this is the name of our ContentProvider. Now currently I have android:exported="false". Whenever we have exported equal to false, then no outside application can access our ContentProvider. So the ContentProvider is private to our own application at present. And in the previous video, by doing the project setup, we created a client application whose main objective is to access the ContentProvider of the provider application. Now since we have android:exported="false", so the client application is currently not allowed to access the provider application. So let us check out this concept inside the Android Studio. So here on the left-hand side we have our client application and on the right-hand side we have the provider application. Now inside the Manifest file of the provider application, if you notice down the side, we have android:exported="false". So the client application on the left-hand side is not allowed to access the ContentProvider of the provider application. Not only this application, but any other application are not allowed to access the ContentProvider of this application. So let us try to run our application at present. Now remember whenever we have the client application and provider application, then always install the provider application first. Because if you try to install the client application first and try to access their database, all the ContentProvider which is not recognized by the system, by using the CONTENT_URI that we have defined here, then our application will crash. So that is why always install the provider application first so that the Android system will know that we have a ContentProvider that contains the authority name of this one that we have defined inside the Manifest file. So let us now run our provider application. So here this is our provider application up and running. Let us now insert a few data into our database. After inserting a few of the data into the database, let us now check out our database content. So our database currently contains all these elements. And now let us close the provider application and let us launch our client application that will try to access the provider application. And now, let us click on Query And Display All button. And there we go, our client application has crashed. Let us check out the reason inside the logcat. Now inside the logcat if you notice, it says that the Permission Denial. The provider application has not allowed our client application to access itself because it was not exported from another process. So now our next step will be to change the value of exported equal to false to true. So when we make exported value equal to true, then our client application will be able to access the ContentProvider of the provider application. So for that purpose, what we can do inside the provider application, inside the Manifest file, within the declaration of the ContentProvider, let us change the exported from false to true. And now, let us run our provider application again. So here this is our provider application up and running. Let us close it and run the client application again. So always remember you need to install the provider application first and then run the client application. Let us now click on Query And Display All button and insert the logcat. Let us see the content of our database. So these are all the content of the database. By making Android exported equal to true, our client application is able to access the ContentProvider of the provider application.

Using Read and Write Permissions to Enhance App's Security
So now from our client application, we can successfully perform the Query, Insert, Delete, and Update operation as well. Now I just showed you the query operation inside the Android Studio. If you want, you can also insert some data from the client application to the database present inside the provider application. Now it is alright that we are able to access the ContentProvider from the client application. But making android:exported="true" will give rise to security issues. That is, any other untrusted application that are present inside the Android device can access the ContentProvider off of an application, so we need to find some solution. What I'm talking about is suppose we have two more applications such as client application two and client application three. So when we make android:exported="true" the client application two and three both get access to the ContentProvider as well. Now suppose these two applications are untrusted application. So these two applications are potentially a threat to our database because they have now got the access to the ContentProvider of the provider application. So we need to somehow stop these two applications to access our ContentProvider. We only want the client application to access the ContentProvider. So for that, we have to find some solution. Now the solution is to declare some permission inside the provider tag such as android:readPermission equal to some string value. Now here I'm using my. read. permission. So instead of this string, we can replace it by some unique permission string which is only known by the client application. Now whenever we declare some permission inside the provider tag, we need to declare it inside the Android Manifest as well with the help of the tag of permission. So here I have defined permission and then name of the permission. Now remember, the string that we have defined here should match with the string that we have defined under the permission tag. Now this was about the read permission. Now what about the write permission? Now suppose you want to perform some Insert operation or Delete operation? So for that, we have the write permission attribute. And here again, this string is user defined. And then corresponding to this permission, we need to declare another permission tag within the Manifest file, and make sure again this string should match with this string that we are defining here. Now since it is only our client application that knows about these two permissions, so the client application two and three that are untrusted application goes out of picture and they cannot access the ContentProvider anymore. Now our next step will be inside the Manifest file of the client applications. So inside the Manifest file of the client application, we need to declare the permissions as well with the help of uses-permission tag. So if our client application want to perform the Query operation, then we need to declare the read permission. And now make sure this string should match with the string that we have defined here and also here. And along with this, suppose you want to perform the write operation as well, such as the Insert operation. For that again, we have to declare use uses-permission tag and declare the write permission. Now again, make sure this string should match with the string that we have defined here and also with the string that we have defined here. So officially the client application has now guarded access to the ContentProvider of the provider application. So the client application with the help of ContentResolver can access the ContentProvider and the ContentProvider in return will return the desired result back to the client application MainActivity in the form of cursor or the number of rows affected or the URI as requested. So this is how we can enhance the application security by declaring the permission both in the client application and also the provider application. Here inside the Android Studio within the provider application what we can do inside the Manifest file within the provider tag, let us declare our permission, such as readPermission, and then define a unique string for the readPermission. And now to make our permission unique, let us copy the package name, com. sriyank. cpdemo. Let us append. READ_NATIONS. So this is the readPermission that we have defined inside the provider application. And now at the top again, let us define the readPermission within the manifest tag. And let us copy the Permission that we have defined here. Close the tag, and then we have to define the protectionLevel of our permission. Let us keep it normal. Now by default the protectionLevel is actually normal. There are other protection levels as well such as normal, dangerous, development, and so on such as signature. Now what this protectionLevel stands for, I will give you a very good reference from where you can get the idea of the protectionLevel tag that we are using here. So please don't worry about it. Now apart from readPermission, let us define the writePermission as well. And then copy the string from here, paste it here, and change the READ to WRITE. And at the top, let us declare another permission tag for the write mode. And also define the protectionLevel as normal which is by default. And now let us run our provider application. So we have simply updated the provider application inside our emulator. Now what we can do, let us run our client application and let us try to access the database using the Query And Display All button. So here our client application has again crashed. Let us check out the error inside the logcat. So inside the logcat, it says that we need to declare the permission inside the Manifest file, such as READ_NATIONS or WRITE_NATIONS. So as per this slide, we need to declare the uses-permission tag within our client application as well. So within the Manifest file of our client application, let us write our code. At the top, inside the Manifest file, let us use uses-permission tag, and let us declare the permission name. Now the name of the permission we can get from the Android Manifest file of the provider application such as the read and write permissions. Copy and paste it, and also use the uses-permission tag for the write operation. So within the client application, we have declared the read and write permission. When we are going to run our client application, the Android system of the Android device will know that the client application has got the right to use these two permissions. Let us now run our client application. So here our client application is now up and running. Let us try to perform the Query operation. So there we go, we are now able to read the data from the provider application inside the client application. Now so far, we are using the Query method. Let us now try the Insert method that is insert some data into the provider application database. So here I will use Nepal and the Continent as Asia, Insert the data, and there we go, the item was inserted at this position of eight. Right, let us now click on Query And Display All button, and here, down the side, you will find the newly inserted row of Nepal. So now we are able to perform the read and write operation both from the client application. So this is how we expose our application's private SQL data outside the application with some security, that is by declaring the permission inside the Manifest file of both the applications. So our code is now working perfectly fine.

Performing Delete and Update Operation from Outside Application
So far, we have performed the Insert and Query operations from the client application. Let us now proceed and check out how do we perform the Delete and Update operation from the client application. So inside the Android Studio, within the MainActivity, let us now move down the side, and inside the update method let us uncomment all the code. And then, let us remove this Nation followed by dot. And also, let us uncomment the delete code. Here again, let us clean up our code. And down the side, we have the QueryRowById method. Let us uncomment these lines of code as well, and again clean up our code, projection, selection, and our URI path. And now, let us run our client application again. So here our application is now up and running. Let us perform the Update operation. Suppose you want to update the Nepal continent. So let us type Nepal as a Country, and then type Asia New. Update it, and here we go, number of rows updated is one. And now, let us Query And Display All. So down the side you can notice we have simply updated a country from the client application using the ContentProvider of the provider application. And now let us delete some country. Let us delete the Nepal itself. So number of rows deleted is now one. Query And Display All, and there we go, Nepal has been removed from our database. So we can now successfully perform all the operations, Insert, Update, Delete, and also Query from outside the application.

Summary: Demo Scenario
Let us now summarize our demo scenario. So in our demo application, we first used android:exported="false". So when we have android:exported="false", then it prevents any other client application to access the ContentProvider present inside our own application. So the ContentProvider becomes private to our own application. And when we have android:exported="true", then any application including the untrusted applications also get the access to the ContentProvider. Now you must be thinking how can any other application can access the ContentProvider? Because in order to access the ContentProvider, we need to know the name of the ContentProvider. Now there is a way to get the details of the ContentProvider by using the PackageManager class. So using the PackageManager class, you can get the details of any provider present in your Android device. Now once you have got the provider's information, then you can simply access the ContentProvider. So when we make android:exported="true", then it simply raises a concern for the security of our application, so we have to find some solution. So for that, we have to make android:exported="true" along with declaring permission inside the Manifest file of the provider application. So when we declare the permission tag within the provider application, then only those client application who knows the permission can access our application which makes our application more secure and also, at the end if you want, you can allow one application to only read the data or even write the data. So it is not necessary to give both read and write access to a client application. If you want, you can make a client application to only read data or you can make some other client application to write data to your database.

Contacts Provider, Calendar Provider, and File Provider
Now the Android system provides a few predefined system providers such as the FileProvider that helps to securely share the private files of our own application to some other client application. And then we have the Contacts Provider that helps to retrieve the details of the contacts stored inside our Contacts Application of our device. And then we have the Calendar Provider that helps any client application to set a reminder about the event or deal with the calendars. Now I will give you a few references to learn about the FileProvider, Contacts Provider, and Calendar Provider. Now if you are making any Android application that requires to implement the FileProvider, Contacts Provider, or the Calendar Provider, so for that here I am giving you a few of the references. Now inside my course of Android File System in the last module, I have talked about Implementing File System in Our Application using the FileProvider APIs. So inside this module, I have created a very small camera application that opens a camera, take the snap, and store it inside the gallery application or in your disk. So here in this module, I have talked about how to implement the FileProvider, which is basically the subclass of the ContentProvider that helps you to share your private data to some other application. And then we have the reference for the Calendar Provider from the official developer. android. com. So here is the detailed documentation of the Calendar Provider that starts with the basics and then progressively moves forward. And at last, we have the Contacts Provider, again from the developer. android. com. So there you will find all the details of this provider.

References: Android Permissions
Now at the end of this module, I would like to talk about a few of the important references of the topics that I have talked about in this module. In the previous video, I showed you the references from where you can get the details of the FileProvider which is present in my course of Android File System. Now in this module, I have talked about enhancing the applications security by declaring the Android permissions such as the tag of Protection Level. In the course of Android Fundamentals BroadcastReceivers, which is another Android component, down the side within the course content in the module of Enhancing Application Security with BroadcastReceiver I have talked about the Android permission in a little more detail. So inside this module in almost all the videos, I have talked about the Android permissions. So please make sure you go through this module as well. And also inside the Android Services Fundamentals down the side I have one module of Enhancing Application Security with Service where again I have used the Android permissions. So please make sure you first start with the module of BroadcastReceiver and then also check out the module of Android Services Fundamentals. This marks the completion of this module. This is Sriyank Siddhartha signing off. See you all in the next module, thank you.

Conclusion
Quick Course Recap
Hi, this is Sriyank Siddhartha, and welcome to the last module of this course of Android fundamentals, ContentProvider. So finally we have reached the end of this course, and to be honest and frank, I have taught too many concepts inside this course. So at the end of this course, let us now quickly recap all the concepts that we learned in this course. Initially we learned about what is a ContentProvider? It is basically the building block of Android and it is an Android application component similar to a activity, service, or a BroadcastReceiver. To understand the ContentProvider well, we created a raw SQLite data storage that was private to our own application. With the help of ContentProvider, we tried to access the SQLite Database and performed various operations, such as read and write operation. The topic of SQLite Database in this course I have covered in deep detail, so whenever you feel like implementing the SQLite Database inside your application, you can revisit the module of SQLite Database. We created our first demo application whose structure appeared to be like this. We created our SQLite Database which we initially accessed with the help of our main activity. And later on we created our ContentProvider with the help of which we were then accessing our database from the main activity. When we implemented our ContentProvider, we learned about various concepts such as the content URI, that is another crucial thing in order to access a ContentProvider from any activity. And also we learned about the content URI patterns, how it works, and what are the wildcard characters as well. Proceeding forward, we created the NationListActivity where we displayed all the data of the SQLite Database with the help of a list view, and performed various operations with the help of NationEditActivity as well, such as update, delete, insert, and so on. And now, when we implemented the NationListActivity, we used various concepts that we learned with the help of this slide. We implemented the Loader API, along with its related classes and interface, such as the CurserLoader, ContentResolver, ContentProvider, LoaderManager and its callback methods, and at the end the SimpleCursorAdapter that uses a Cursor object to display data inside the list view. For the SimpleCursorAdapter, we also learned about how it actually maps the data from the database column to the text view with the help of its id. And at the end of this course, we also talked about how can we expose the application's private data to any other client application without compromising the application's security by declaring the permission inside the provider application as well as client application. And whatever operation that we performed on the database using the ContentProvider from the main activity, we performed the same operation inside the client application as well, such as query, insert, delete, and update operation. And at the end, we also checked out the references for a few of the predefined important providers, such as the Contacts Provider, Calendar Provider, and also the File Provider. This was a very short recap for this course.

What Next?
Congratulations on successfully completing this course. Now you must be thinking, what next? What are the topics that you should cover after completing this course of ContentProvider? If you're watching this course of ContentProvider directly, without watching the courses of Android component such as activities, services, and also the BroadcastReceiver, they my recommendation is that after watching this course please go through these courses of activities, services, and also the BroadcastReceiver. These are the respective courses that I have made for the Pluralsight. And since the course of ContentProvider is closely related to the persistent data storage, so I will also recommend you the courses related to the persistent data storage, such as the SharedPreferences, Realm database system, and also the file system. These are the three courses present in the Pluralsight library related to these topics of SharedPreferences, Realm, and also the file system, so please make sure you go through these courses one by one. At the end, I would like to congratulate you all for successfully completing this course. This is Sriyank Siddhartha signing off. Thank you and have a good day.

Course author
Author: Sriyank Siddhartha	
Sriyank Siddhartha
Sriyank began his career with a Bachelor of Technology in Computer Science from India. After working 2 years in Java, he found a great interest in Mobile Application Development. Sriyank works with...

Course info
Level
Beginner
Rating
4.7 stars with 27 raters(27)
My rating
null stars

Duration
3h 26m
Released
27 Jul 2017
Share course