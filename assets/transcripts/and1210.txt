Android Apps with Kotlin: RecyclerView and Navigation Drawer
by Jim Wilson

Learn the skills necessary to provide rich data display and easy-to-use navigation by learning to effectively use RecyclerView and navigation drawer.

Providing rich data display and easy-to-use navigation is critical to the success of any application. In this course, Android Apps with Kotlin: RecyclerView and Navigation Drawer, you’ll learn how to provide both. First, you'll learn how to include rich, card-based lists using RecyclerView, CardView and LayoutManager, while managing content display in a RecyclerView by creating a RecyclerView adapter. Then, you’ll learn how to coordinate the creation of the LayoutManager and adapter with the lifecycle of the containing activity through the use of Kotlin lazy properties. Next, you'll discover how to expand your application navigation experience with navigation drawer. Finally, to assure application reliability, you'll see how to create automated UI tests that cover both RecyclerView and navigation drawer. By the end of this course, you'll have the necessary skills and knowledge to create Android apps of your own that provide rich data display and easy-to-use navigation with RecyclerView and navigation drawer.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Intermediate
Rating
0 stars with 8 raters
My rating
null stars

Duration
2h 45m
Released
9 Nov 2018
Share course

Course Overview (trailer)
Course Overview
Hi everyone. My name is Jim Wilson. Welcome to my course, Android Apps with Kotlin: RecyclerView and Navigation Drawer. I'm a managing partner of JWHH, LLC. I've had the good fortune to have been a professional software developer now for over 30 years, and I've been creating apps for Android since the earliest days of the platform. In this course, you'll learn the skills necessary to work effectively with RecyclerView and slideout navigation drawers, and you'll do all this while leveraging the powerful and efficient coding experience provided by the Kotlin programming language. Some of the major topics we cover include displaying card-based data lists with the RecyclerView and CardView, efficiently managing large data lists with the RecyclerView adapter, providing a rich, easy-to-use navigation experience with slideout navigation drawers, and assuring app reliability by incorporating RecyclerView and navigation drawers into your automated user interface tests. By the end of this course, you'll have the skills necessary to display rich data lists and provide an easy-to-use navigation experience using RecyclerView and slideout navigation drawers. To get the most out of this course, you should already have a solid understanding of the fundamentals of developing Android apps using Kotlin and the basics of creating automated user interface tests using Kotlin. You can learn more about both these topics in my courses Android Apps with Kotlin: Build Your First App, Android Apps with Kotlin: Tools and Testing. I hope you'll join me as we learn the skills necessary to display rich data lists and provide an easy-to-use navigation experience with the course, Android Apps with Kotlin: RecyclerView and Navigation Drawer, at Pluralsight.

Working with RecyclerView and CardView
Introduction
Welcome to the Pluralsight course, Android Apps with Kotlin: RecyclerView and Navigation Drawer. This is our first module working with RecyclerView and CardView. My name is Jim Wilson. Throughout this course, we'll look at some of the features that Android provides to allow us to provide our applications with a much richer user experience. So in this first module, we'll take a look at how we can use RecyclerView to display a list of items efficiently and how we can present information within that RecyclerView with a card-like appearance by using the CardView class. Then later in the course, we'll see how we bind data to our RecyclerView by using RecyclerView. Adapter. We'll then spend some time looking at drawer navigation and understanding how it's different than traditional menu-based navigation. We'll then see how to implement drawer navigation within our app, and then we'll finish up by updating our application's test to include coverage in both RecyclerView and our app's drawer navigation. Now as we mentioned, in this module, we'll take a look at using RecyclerView to display lists of information and how we can use the CardView class to provide a card-like appearance of the items within a RecyclerView. So we'll start out with an overview of the demo app that we'll be using throughout the course. We'll then look at the components involved in displaying information with RecyclerView. We'll then see how to use the CardView class to present information within a RecyclerView with a card-like appearance. We'll then update our application to leverage RecyclerView and CardView, and then we'll finish up. We'll look at how we can manage the positioning of items within a RecyclerView with LayoutManager.

App Overview
So let's take a look at our demo. Now as a reminder, this course is part of the Android Apps with Kotlin series, so we'll be using the same demo we've been using throughout the series, and that demo is for an application that allows us to manage notes for Pluralsight courses. So the application has an activity that allows us to interact with a particular note, but that activity is not the starting activity to the application. The starting activity to the application is actually the list of notes, and up to this point in the series, we've been relying on a ListView to show that list. Now the user can interact with that list of notes. So if the user taps on a note, we'll take them to the note activity to display that note, and the user can also tap on the plus sign at the bottom to launch that activity to create a brand-new note. Now our focus in these first two modules in this course is going to be on that list because, as I said, we're currently using a ListView, and we're actually populating it in a very simple way. We simply call toString on the class that represents each note, and that shows the values inside that note. So what we'll be doing in this course is transitioning from a ListView to a RecyclerView, and that RecyclerView will allow us to render that list in a much more modern and rich appearance. But now functionality-wise, it'll still basically be the same as it was before. The user can tap on a note, it'll launch our note activity to display that note, and the user can still tap on the plus sign to create a brand-new note. So now in our next clip, let's take a look at some of the benefits that the RecyclerView provides.

How RecyclerView Works
As we build our applications, we'll commonly need to display lists of data. And for a long time, we did that by using a ListView because a ListView was very easy to use. But the thing is that the ListView has a number of significant limitations. One thing is it always displays our content as a vertical list. Doesn't really provide a way to control the arrangement of the content within the ListView, and that's just a general problem with ListView. It's not very easy to customize. Although the ListView allows us to customize the appearance of an individual item being displayed, it doesn't really give us much control over the rest of the interaction with the ListView. Also, the ListView had a number of performance challenges. As we dealt with large data sets, it didn't necessarily perform very well. So that means that the ListView doesn't really work for our modern applications. We really need a solution that's much more flexible than what the ListView was capable of. So in our applications now, we tend to use the RecyclerView because RecyclerView is really designed for modern applications and is extremely flexible. It gives us a great deal of control over the way it behaves, and that's because RecyclerView divides data display into distinct phases, and each of those phases gives us the opportunity to customize its behavior. In addition, the RecyclerView is really designed to work with large data sets. It provides a very efficient display mechanism because it separates the details of display from the details of the data that's being displayed. So let's take a high-level look at how RecyclerView works. So we'll start out by creating our RecyclerView, and then we have to tell the RecyclerView how we want content laid out within it, and we do that by associating a LayoutManager within a RecyclerView. Now the LayoutManager has one distinct responsibility, how content is arranged within a RecyclerView. And then the rest of the work is delegated out to an adapter, and that adapter's responsible for feeding the content into RecyclerView, but in order to do that, it has to manage a couple things. One thing it has to do is manage the data that's going to be displayed, and that data can potentially be very long. In addition, the adapter has to manage the individual views that will be used to display that data. So when we want to display content within a RecyclerView, the adapter will create instances of our View class, feed those in to the RecyclerView, and will create as many as are necessary. So once it's created that first one, it can create another one, feed that into RecyclerView, and continue doing that until enough views have been created to display the content in the available display space of the RecyclerView. And then from there, the adapter can take the data from the data set and then render that data into the views that have already been created and continues to do that as the user moves through the data displayed within a RecyclerView. But now remember, as we mentioned, RecyclerView divides responsibilities of display into distinct phases. One of the key parts of that is our LayoutManager. In this case, we're using a layout manager that arranges the views vertically from top to bottom. But what if that's not how we wanted things displayed? Well, we could switch to a different layout manager. So rather than using that layout manager, let's say we create a different layout manager which arranges content in a grid layout. Well, by doing that, we could use the same adapter with the same view and the same data set, but now the content will be rendered in the RecyclerView in that grid formation rather than a linear formation from top to bottom. And that really shows us the power of the RecyclerView, a clear division of responsibilities. So now in our next clip, let's see what's involved in adding a RecyclerView to our own application.

Developing RecyclerView Components
Let's take a look now at the steps we'll have to take to incorporate a RecyclerView into our application. Now as you might expect, the first thing we have to do is design the RecyclerView itself, and we're going to do that much like we would with any other view. In most cases, we're just going to place it on the layout resource that we're displaying within our activity. But now, that's only part of the layout work we have to do. We also have to design the item view, and that describes the appearance that we want to use for each individual item displayed within the RecyclerView. And in this case, we'll also tend to use a layout resource, but the layout resource we're using here is distinctly separate from the layout resource we're using with our RecyclerView. So the RecyclerView is on one layout resource, generally that contained within the activity, then a completely separate layout resource will be used to describe the appearance of individual items displayed within the RecyclerView. And then from there, we need to create and associate our layout manager. And the layout manager's responsible for controlling the arrangement and positioning of the items within the RecyclerView. So the appearance of the items will be controlled by the layout we describe for those items, but the positioning of the items in the RecyclerView is controlled by the layout manager. And then we have our adapter. We'll need to create and associate the adapter we want to use with the RecyclerView. And the adapter has a number of responsibilities. It'll need to create the view instances, use the display items within the RecyclerView, it'll need to manage the interaction with the data that we want to display, and it's responsible to associate the data that we're displaying with the views displayed within the RecyclerView. We'll talk in much more detail about this adapter a little bit later. But for now, in our next clip, let's head into Android Studio and start converting our application from using a ListView to using a RecyclerView.

Adding RecyclerView to Our App
Here we are in Android Studio, and what we want to do now is begin the work of converting our application from using a ListView to display our list of notes to instead display RecyclerView. Now before we do that, I want to point out one thing about the class names in this project. Notice here in the Project window we have two activities, NoteActivity and NoteListActivity. Now, NoteActivity is the activity that allows the user to interact with a specific note. Earlier in the series, that activity was called MainActivity, and that was an artifact from the first course in the series when we first created the project that the only activity it had was the activity that allows a user to interact with a note. So for clarity, that class name has been changed from MainActivity to NoteActivity. Functionally speaking, it's still exactly the same as it was before. It just has a more meaningful name now. Now, NoteListActivity is the activity responsible for displaying our list of notes, and that's the activity we're going to be working in throughout this module. Now the layout resource that contains our ListView is content_note_list, and that's a layout that's currently displayed within Android Studio. Now to give us some room to work, I'm going to go ahead and collapse our Project window here. So now with that out of the way, we can begin working in our layout. So the first thing we'll do is go ahead and select the ListView, and then I'm going to go ahead and delete it, so I'll just hit the Delete key, and what I'll do is replace it with RecyclerView. So I'll head over here to the Palette, I'll select RecyclerView, and I'll drag it over to my layout. Now our RecyclerView is placed within a ConstraintLayout, so I'll go ahead and set constraints on the top, bottom, left, and right edges. So we can see over here in our Attributes window that we have constraints set on all four sides. And now remember though, for the constraints to take effect, we need to go down here to out layout_width and layout_height and give those the appropriate values. So I'll first go to layout_width, I'll select match_constraint, and I'll do the same thing for layout_height. I'll expand the list, choose match_constraint. So now our RecyclerView will be sized and positioned based on the constraints that we've set, which will basically cause it to fill the display area of our activity. Now there's one last thing we want to do here. Let's go ahead and give our RecyclerView an ID, and let's give it an ID of listItems. So with that now, our RecyclerView is all set within our layout, but there's still some more work we have to do. We need to go in and update the code for this activity, which is the NoteListActivity class. So let's head over to that class. So here we are in our NoteListActivity class, and you can see that the code related to the ListView is now highlighting in red because we don't have our ListView anymore. Let's go through and start taking that code out. So the first bit of code we'll need to remove is the code where we associate the ArrayAdapter with the ListView because a RecyclerView will need an adapter, but it'll be a different sort of adapter. So we'll take that code out. So now the reference to the ArrayAdapter is gone. The next thing we want to do is remove the code where we handle the selection within the ListView because as we'll see, as we use the code within RecyclerView, the click handling will actually happen in the adapter for the RecyclerView rather than having to do that work in the activity itself. So let's go ahead and remove that code. So then that code's gone as well, and now let's go ahead and scroll down because there's one more line of code we need to remove. So now we're down here in our NoteListActivity's onResume method, and inside this method we're calling notifyDataSetChanged on the ArrayAdapter associated with the ListView. And by doing that here, any time we return back from our NoteActivity, we would refresh the ListView with the latest content. Well, since we don't have our ArrayAdapter or our ListView anymore, we can go ahead and take this line out. And so with that, all the code related to our ListView is now gone. So in our next clip, we can start working on the layout that we'll use to display the individual items within our RecyclerView.

Creating the CardView Appearance
Here we are back in Android Studio, and what we want to do now is start creating the layout that we use to display individual items within our RecyclerView. Now the layout resource we're currently looking at is content_note_list, and that's a layout resource for our NoteListActivity. And we already have our RecyclerView on here. Now, when we create the layout used to display the individual items, there's no implicit relationship between that layout resource and the layout resource containing our RecyclerView. That relationship is created at runtime through a RecyclerView adapter. But one of the really cool things about Android Studio is that it gives us a really good design-time experience to show what things will look like later when we run them. So it will be nice if here inside of Android Studio, at least for design purposes, we could create some kind of relationship between the layout resource for individual items and this RecyclerView. Well, it turns out that we can do that. Because if you look here at the RecyclerView currently, it's using a very generic layout just showing a bunch of items within the RecyclerView. But there's an attribute associated with a RecyclerView that we can use for design purposes. Notice over here in the Attributes window, we have the listitem attribute. Notice that next to it there's a paintbrush. That paintbrush indicates that this is a design-time attribute. In other words, it has nothing to do with the runtime characteristics of RecyclerView, but it does affect its appearance in the designer. Now just for reference, in earlier versions of Android Studio, rather than having a paintbrush there, there was actually a wrench there. But in both cases, whether it was the wrench we saw in the earlier versions or a paintbrush here, simply means that it's a design-time attribute. So if we had an existing layout resource that we wanted to use for the items in our RecyclerView, we could simply set that resource here within listitem. But we haven't created that layout resource yet, so we need to create it. So the easiest way to do that is go to the dots at the right of listitem. Let's go ahead and click on that. That brings up a dialog showing us the list of available layout resources, but notice up here in the top right corner there's the option Add new resource. Let's head up there. Let's go and expand that. We'll choose New layout File. Let's name the resource file item_note_list. So that gives our resource a name. And notice just below there, there's this value, Root element. What this is asking us is that what do we want the top-level element of this layout resource to be, and by default, it's ConstraintLayout. And oftentimes we do want a ConstraintLayout, but in this case, rather than using a ConstraintLayout, let's change it to say FrameLayout. So now with that, our top-level element will be a FrameLayout, and a FrameLayout is a very simple layout type. It's a layout that has just one child item, and that child item generally fills the entire area of the FrameLayout. And we'll see in just a moment why we chose that. For now, let's go ahead and click OK to create the layout resource. So now we have our layout resource that'll be used for the individual items that we want to display. Now there are no hard and fast rules for how things need to appear when rendered within a RecyclerView. In fact, that's one of the really powers of RecyclerView is we have a great deal of control over how things appear. But a very common appearance that people use for RecyclerViews is a card-like appearance, so each item displayed within a RecyclerView appears as if it's on its own individual card. So to do that, we can actually use CardView. So to use CardView, first thing we'll do is head over to our Palette, and we'll choose Containers. And then there within Containers, you can see there's CardView. So let's grab the CardView, we'll drag it over to our layout, and then we'll drop it there. And notice that when we do that Android Studio tells me that in order to use CardView, I'll need to use the library cardview-v7. And Android Studio's confirming that I want to add that to my build, and I do, so I'll hit OK. Now once I do that, you can see the CardView appears within our Component Tree. And with the CardView selected, we can see the attributes for the CardView over in our Attributes window. Now, one of the cool things about the CardView is it renders in a way that's consistent with material design. So it can actually render as if it's floating above the rest of the display and creates that kind of 3D appearance. But now in order to do that, there's a few attributes we need to set. So then the first attribute we'll need to set is cardElevation, and that sets the appearance of how far above the screen it appears to be floating. So for cardElevation, let's using 4dp. So that'll create our rendering effect that causes the card to appear as if it's floating above the screen. So then the next thing we'll set is contentPadding, and that creates padding around the inside edge of the card, and let's set that to 16dp. So with that set to 16dp, a whitespace around the entire inside edge of the card will now be rendered so that the content within it is not bumping up against the edges of the card itself. And then we have the cardCornerRadius, and that allows us to give the card rounded corners rather than square corners. So let's give it a cardCornerRadius of 4dp. So that will give our card slightly rounded corners. And then one more attribute we want to set is this last one here that shows up here as cardUseCompatP., and that has to do with the differences in the way the CardView needs to render depending on which version of Android our application is running on. By enabling this feature, the CardView will take care of dealing with those differences on its own, and we want to do that, so let's go ahead and check it. Now, once we do that, we can see our card in a preview with its raised appearance and rounded corners. But now before we finish up with our CardView, let's take a look at layout_width and layout_height. Notice our layout_width is match_parent, which means we want to occupy the entire width of the parent, and our layout_height is wrap_content meaning that we only want to be as tall as required to render the content within us. And we want to make sure that those settings cascade up our Component Tree. Now our CardView is contained within a FrameLayout, so let's head over to our Component Tree. We'll choose FrameLayout. You notice that once I choose FrameLayout, if we take a look at the Attributes window, layout_width is match_parent, which is what we want, but notice that layout_height is also match_parent. So that means that the FrameLayout would want to occupy the entire space of the RecyclerView, and that's not what we want. We want our FrameLayout's height to be wrap_content. That way, each item will only be as tall as required to display that item's content. So let's switch our layout_height from match_parent to wrap_content. And once we do that, you can see in the preview that the blue line representing the FrameLayout is now just slightly larger than the CardView, and that's exactly what we want. So now in our next clip, let's go and design the appearance of the items displayed within the CardView.

Completing the Item View Layout
Here we are back in Android Studio, and what we want to do now is finish creating the layout resource that we use to display individual notes within our RecyclerView. Now we've already got a layout resource that has our FrameLayout and CardView, and the CardView creates that card-like appearance, but in order to place other views within the CardView, we want to put in a layout within the CardView itself. So let's head up here to our Palette, and let's choose Layouts. So we're head up to ConstraintLayout, and then we'll drag that down to the CardView. So we'll go ahead and drop that on the CardView. So now there's a ConstraintLayout within our CardView, so now we can begin positioning views using constraints. So now we want to make sure that our cards really have a rich and engaging appearance. So one of the things that might be nice to do is actually place an image on each card that gives the user visual feedback that that card represents a note. So to do that, let's head back up to our Palette, then I'll choose Common, then I'll head over here to ImageView, and I'll drag that over to my design surface. I'll drop it on the design surface. Then when I do that, Android Studio brings up this dialog to allow me to pick the drawable resource I want to associate with that ImageView. Well, let me go ahead and expand the Project group. And you notice that here within the Project group I have a resource named ic_assignment_black_24dp, and this is a vector asset that I added to the project. You see that it has this clipboard look that gives the appearance of someone writing on the clipboard. That seems like a pretty good choice for indicating to the user that this card represents a note. So I'll select that. Then I'll go and hit OK. So that places the ImageView on the card, so let me go ahead and set some constraints. So I'm going to set top, bottom, and left constraints. So now you can see that my imageView has constraints against the top and the bottom edges and has one against the left edge. So that'll cause the imageView to be centered top to bottom and be 8dp from the left edge. But now, before we finish up with our imageView, let's see if we can improve its appearance a little bit. Notice that the clipboard is rendering as black because that's the color that's associated with that vector asset. But black's not really that engaging for this situation. It'd be nice if I can give it like a Pluralsight-orange appearance, and it turns out that I can do that. I can actually apply a tint to this image. And since the image color is black and black is all 0s, when we apply a tint to a black image, the image will actually render as the color of that tint. So let's do that. So now in order to set the tint, I need to change the Attributes window to a different view. Currently, the Attribute window is displaying the most commonly used attributes, but if I want to get to the full list of attributes, what I need to do is click these double arrows up here towards the top right. So let's go ahead and click on those. That takes me to the full list of attributes. So let me scroll down and find the attribute named tint. So here I am at the tint attribute. What I'll do is select the dots here to the right of it. That brings up my Resources dialog with Color resources selected. Let me go ahead and expand the Project group. And you'll notice that when I expand that group, one of the choices I have here is Pluralsight_orange, and that's a custom color resource that I have defined in my Colors file. So let me go ahead and select that. Then I'll go ahead and hit OK. And then notice that once I do that, the image now appears as Pluralsight orange rather than black. So we've got our tint applied, so let me head back over to those arrows at the top right of the Attributes window. Let's switch back to the commonly used Attributes view. So now we're all set with our imageView. So now I'll go ahead and add two TextViews to our layout. So now as you can see, I've added two TextViews to my layout. The first one has the ID, textCourse. It has constraints set, so it's slightly to the right of our imageView. Then it takes up the full remaining width of the CardView. And then below that, our other TextView, if I select that, its ID is textTitle, and again, it's to the right of our imageView, and it takes up the full remaining width of the CardView. So we're just about done with our layout. There's just a couple more things we want to do. Let's go ahead and make sure that these TextViews have a really strong appearance. So let's first go ahead and set the text appearance for the bottom TextView, which is our textTitle. So let's head over to our Attributes window, and we'll scroll down a little bit. And here on the Attributes window, I'm going to go ahead and choose textAppearance. I'm going to scroll down. Then I'm going to go ahead and choose Material. Medium. So that makes the text slightly larger. Let's head back up to the other TextView. We'll select that. Let's head back over to our textAppearance. So we'll go ahead and choose textAppearance, and let's head up to CourseTitle. Now CourseTitle is a custom style that we've set that's based on Material. Medium, but adds a couple extra attributes. It actually bolds the text, and it sets the text color to be Pluralsight_orange. So let us go ahead and select that, and when we do that, we can see the text at the top is bold, and it appears in Pluralsight_orange. So that takes care of setting up the layout resource for the individual notes displayed within our RecyclerView. Remember that earlier we actually associated this layout resource as a design-time ListItem resource for the RecyclerView. So that should mean that if we head back over to the layout resource for our NoteListActivity, the preview of the RecyclerView should be using this layout. So let's head over to that resource, which is our content_note_list layout resource. And when we get over here, you can see that the preview of the RecyclerView is now using that layout. But you know it still looks a little bit wonky. It seems like things are a little bit kind of thicker than they need to be. So let's head back over to the layout resource for the individual items, and let's just check a couple things. So now we're back here in the layout resource for our individual notes, and one of the first things I want to check is just the spacing between these two TextViews. You notice that I have the bottom TextView selected, which is textTitle. If we look at the constraints on that, you noticed that's spaced 16dp below the TextView above it. And that may be a little bit broad, so let's go ahead and change that from 16 to 8. So by doing that, our TextViews are a bit closer together. But now there's one last thing I want to check. I want to make sure that my FrameLayout, my CardView, and ConstraintLayout all have their height values set so they're sized based on the actual contents. So let me head over to the Component Tree. So I'm here in the Component Tree. I'll choose FrameLayout. Notice that FrameLayout has its height set to wrap_content. That's what we want. Let's go ahead and choose CardView. That height is also set to wrap_content, so we're good there. So now let's go and check ConstraintLayout, so I'll select that. And you'll notice that the height of ConstraintLayout is match_parent, and that is the default height value when you place a ConstraintLayout, but that's not what we want. So let's head over to our Attributes window. We'll choose the drop-down for layout_height. Let's go ahead and choose wrap_content. Now we don't see any immediate difference here in our preview, but it could lead to problems at runtime if we were to leave that value. So let's head back over to the layout resource for our NoteListActivity and see how the preview looks there. So we're back here in the layout for our NoteListActivity. In the preview, the RecyclerView looks pretty good now. It's actually using the layout resource we created for each individual note, and they're rendering nicely here inside the RecyclerView. So now in our next clip, let's take a look at layout managers.

Layout Manager Classes
Now once we define the appearance of the individual items within the RecyclerView, those items need to be positioned, and positioning those items is the role of the layout manager. Now, the layout manager is represented by the type RecyclerView. LayoutManager, and that serves as the base class for all the layout managers. And if you need some custom layout behavior, you can actually extend the LayoutManager class yourself and provide that behavior as necessary. But in general, we don't need to do that because Android provides several implementations, and those cover most of the common scenarios that we're likely to need. In fact, there are even layout managers designed to handle layout on wearable devices, and all the of the Android provided layout managers support both vertical and horizontal orientations. So with all those capabilities, we're not likely to need to extend the LayoutManager class ourself in very many circumstances. Now one of the most common layout managers we use is the LinearLayoutManager, and as its name implies, items are organized as a linear list. So loosely speaking, items are rendered similar to the way they might be with a ListView. So we have our RecyclerView. We're using our LinearLayoutManager. We can lay out one item under the next, under the next, under the next. Remember that all the layout mangers support both vertical and horizontal orientations, so we could lay them out left to right rather than top to bottom if that's what we wanted to do. Now another layout manager we have is the GridLayoutManager, and as its name implies, items are organized as a grid. And as a grid, items that are adjacent to one another are consistently sized even if the content with those items has different sizing itself. So we have our RecyclerView. We're using a GridLayoutManager. Let's say the first item we display is fairly tall, so the view will get the height necessary to display all the content for that item. But then the item adjacent to it will be sized the same even though the content within it may not necessarily be that large. And it doesn't matter which of the items are first. So we have another item that we render that requires a smaller amount of space, but the one next to it needs more space. Again, they'll both be sized consistently because we're using the GridLayoutManager. Now, when we're using the GridLayoutManager, we can specify what's known as a span, and the specific meaning of span depends on the orientation. So if we're using a vertical orientation, the span indicates how many columns we want the GridLayoutManager to use. If we're using a horizontal orientation, span indicates how many rows we want the GridLayoutManager to use. And then the last one we'll look at here is StaggeredGridLayoutManager. So again, items are organized as a grid, but in this case, each item is individually sized. So we have our RecyclerView. And if the first item requires a tall amount of space, then it will be rendered based on amount of space that it requires, but the one next to it will be rendered based on the amount of space that it requires. And that continues on through all the items being laid out within the RecyclerView. So this gives us that grid style layout while allowing each item to be sized appropriately for its own content. And just as with the GridLayoutManager, the StaggeredGridLayoutManager also supports specifying the span. All right, so now in our next clip, let's go ahead and specify a layout manager for our RecyclerView.

Associating a Layout Manager with Our RecyclerView
Here we are back in Android Studio, and what we want to do now is associate a layout manager with our RecyclerView. Now remember that our RecyclerView was added to our activity's layout resource with an ID of listItems. So we can access it with a synthesized property, listItems. RecyclerView has a property named layoutManger, and all we have to do is assign it the reference of the layout manager we want to use. Now in the case of our notes, we want a simple top to bottom list, so what we'll do is create an instance of the LinearLayoutManager. Now when we create an instance of LinearLayoutManager, we need to pass it in a context, so we'll pass it in our NoteListActivity's this reference. So with that, we've now associated the layoutManager with a RecyclerView. So combining this with the layout resource we created for the others in the RecyclerView, we're just about ready to start running our application and displaying content within the RecyclerView.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that RecyclerView provides a number of benefits over other options we have for displaying lists of information inside of our app, and those include the fact that RecyclerView is extremely flexible. And that flexibility comes because it divides data display into distinct phases, and each of those phases can be customized allowing us to use a RecyclerView on a variety of situations with a variety of appearances. In addition, RecyclerView is able to display data efficiently, allowing us to use it with potentially very large data sets. Remember that there are three primary components related to working with RecyclerView. There's a RecyclerView itself, and that handles presenting the list of data. There's the LayoutManager. That handles the positioning of items within the RecyclerView. And then we have the adapter, and the adapter has two responsibilities. It creates the views that will be used to display items within a RecyclerView, and it handles associating data items with the item views. So that means that in order to use the RecyclerView, there are a number of steps we have to perform. First, we'll need to design a RecyclerView itself, and that's normally simply a matter of putting the RecyclerView of the layout resource that you display within your activity. Then we'll need to design the item view. And again, that's also normally a layout resource, but remember, it's a separate resource from the resource contained in a RecyclerView. This is a layout resource dedicated solely to the appearance of the item views. From there, we need to create and associate a layout manager with a RecyclerView. And normally we're going to use one of the built-in layout managers because they cover the most common display scenarios. And then finally, we need to create and associate the adapter with the RecyclerView. And this is normally where the bulk of the work comes in because in most cases we need to build that adapter ourselves. And we'll see how to do that in our next module.

Binding Data to RecyclerView
Introduction
Welcome to our next module, Binding Data to RecyclerView. This is part of the Pluralsight course, Android Apps with Kotlin: RecyclerView and Navigation Drawer. My name is Jim Wilson. The RecyclerView uses an efficient presentation model that separates view creation from data display. This model's behavior is provided by the RecyclerView adapter. Understanding the RecyclerView adapter is essential to working effectively with RecyclerView. So in this module, we'll start out with a look at the interaction between the RecyclerView and the RecyclerView adapter. We'll then see how to implement a RecyclerView adapter. We'll then take a look at how the RecyclerView adapter manages the views displayed within a RecyclerView. Then we'll look at how it manages the data displayed within a RecyclerView. And then finally, we'll finish up. We'll look at how we handle item selection within a RecyclerView.

RecyclerView and Adapter Interaction
So we've seen our RecyclerView, and we've seen how to create a layout for an individual view item. What we need to look at now is our RecyclerView adapter because that's the key piece that ties together the view items, the data for those items, and then feeds them in to the RecyclerView. So a RecyclerView adapter has kind of two key jobs. First one is to create the item views. Now what's interesting though is that it works very closely with a RecyclerView in doing this because it will return these to the RecyclerView, and the RecyclerView is going to actually manage these item views inside of a pool. The other job a RecyclerView has is to populate the item views. And what happens now is that the RecyclerView will then pass the view items that it's in the pool back in to us to put the data into. So let's get a sense of what that looks like kind of visually. So if we have our adapter, and our adapter, of course, is going to backed by some data, the data we want to display, and we know we've got our RecyclerView, and our adapter is going to be associated with that RecyclerView. Now again, one of the first jobs our adapter has is actually creating these individual view items. So the adapter's going to be responsible to create instances of these view items, it's going to feed them into the RecyclerView, but then the RecyclerView's going to ask us for the data for that item, and that's going to come through the adapter, and the adapter then is going to take the data and then populate that view item. And of course, that process will continue. So as for the next view item, we'll feed it into RecyclerView, it'll ask for the data, we'll populate it, and that carries on. Now obviously this is going to happen often enough to at least create enough view items for what's visible inside the RecyclerView. But think about any time we display a list, whether it's something like a ListView or, in this case, a RecyclerView, the user is likely to scroll through that list. So a RecyclerView's going to need to create some additional instances so that the scrolling goes smoothly. So going beyond just what's visible inside the RecyclerView, the RecyclerView's going to ask for more view items, going to feed it in to the RecyclerView, we're going to have to go ahead and populate that with the data, and that's going to carry on until there are enough instances created and populated where the user can scroll through them smoothly. Now, I'm showing kind of two extra in this graphic we have on the screen, but it's going to be more than that. The key thing to understand is that the RecyclerView just manages enough view instances to make sure the scrolling goes smoothly. But let's think about how all this worked. We kind of did this idea of creating the views as one distinct task, and then populating those views is a completely separate task. Now why would the RecyclerView have us do it that way? Why not just go ahead and have us say, hey, create a view, put the data in it, and give it to me? Why is the RecyclerView managing these as two completely separate tasks? And that's where this idea of the view pools comes in. So the user scrolls through. They go from the first four items in this case to see this second four items, two through five. So they scroll through. And as they scroll through, they'll begin to approach the end of the views that are populated in the pool. So obviously the RecyclerView needs to request some more. Now it could ask that we go ahead and create a brand-new view item and go ahead and populate that brand-new view item, but what's interesting is that this idea of creating the views is somewhat expensive, and the reality is, is that no matter how many data items we have, whether we have 10 items, 100 items, 1000 items, 10000 items, no matter how much data's there, a limited number of items can be viewed at any point in time. So for the RecyclerView, rather than create individual view items for each data item, again, we manage this pool. So what happens is that as we begin to approach the end of the pool as the user's scrolling through it, rather than have the RecyclerView ask our adapter to create yet another view item, what it actually does is move one of the old items from the pool and then sets it up to use that view item from the pool as further down the list. So then it asks our adapter to say, hey, go ahead and give me the next bit of data, and populate that into the view item. So then as this user scrolls down, they approach the end again. We pull one of the old ones we've already gone past out of the pool. We kind of move that down the list. The RecyclerView says, well, give me the data for that guy, I'll go ahead and put it inside there, and this process continues on. Now in this case, it's happening as we're scrolling down, but obviously this process will happen no matter which direction we're scrolling in, scrolling up or scrolling down. So the key idea here is that the RecyclerView is managing a limited number of view items based on what's visible on the screen, plus some extra, and it uses the adapter to simply recycle those view items to show whatever data the user is scrolling towards, whether that be up or down. Okay, so now in our next clip, let's look at the classes and methods involved in creating a RecyclerView adapter.

RecyclerView Adapter Implementation Steps
Now in order for this all to work, we have to provide the view items in a way the RecyclerView can manage them, and we use something we call item view holders. And what happens now is these views are managed using what's called a view holder pattern. And what that means is that we're going to have a reference to the top-level view because the RecyclerView's going to be responsible to render that top-level view and its descendants within the RecyclerView, but also, we're going to hold references to the contained views. In other words, we want to have references that will allow us to actually assign values to what's displayed inside that top-level view. And the way we do that with the RecyclerView is we use a custom view holder class. The custom view holder class that we're going to write will extend the class RecyclerView. ViewHolder, and it will have fields inside of it for all the contained views that are used to display the information for each individual view item. So now when it comes to actually implementing our RecyclerView adapter, we're going to extend the class named RecyclerView. Adapter. And the RecyclerView. Adapter class actually accepts a type parameter. The type parameter that we're going to pass into the RecyclerView. Adapter class is going to be our custom view holder class. Now when we declare our view holder class, you can declare it any way you want, but commonly, we just go ahead and declare it as a nested class within our adapter implementation. Because the view holder class is not normally used outside of our adapter, it makes sense to declare it as a nested class within our custom adapter implementation. The RecyclerView. Adapter class has some very rich capabilities, and there are a number of methods that we can override to provide our custom behaviors. But at a minimum, there are three methods that we pretty much always override. One is the getItemCount method, and we override that method to return the number of total data items that we want to display. We then have the onCreateViewHolder method, and that creates our item view and actually stores the information from the item view in our custom view holder class. So these are the things that we're creating to go into the RecyclerView's pool of view items. And then there's the onBindViewHolder method, and this one receives a view holder from the RecyclerView and the position of the data that we want to display. It's this method's job to then go ahead and set the data values within that view holder for the data item we want to display. And by overriding these methods, we now have our adapter providing the RecyclerView with what it needs. So in our next clip, let's see what it's like to now actually implement our RecyclerView adapter implementation.

Creating and Constructing the RecyclerView Adapter
Here we are in Android Studio. Now as you recall, in the previous module, we converted our NoteListActivity class to use a RecyclerView rather than using a ListView, and as part of that work, we also created a layout resource to display the individual items within our RecyclerView. That's the layout resource we're currently looking at, which is our item_note_list layout resource. So what we want to do now is go ahead and create an adapter that we can use to populate that RecyclerView using this layout resource, item_note_list, along with the list of notes contained within our DataManager. So to get started, the first thing we'll do is create a new class, and that'll be the class for our adapter. So I'll head over here to my package name, and I'll right-click. I'll choose New. I'll then choose Kotlin File/Class. So we'll go ahead and name our class NoteRecyclerAdapter. We'll then go down here to Kind, we'll choose Class, and then we'll go ahead and hit OK. So now remember, in addition to our adapter class, we'll also need a class to serve as our view holder. So here inside of our NoteRecyclerAdapter class, let's go ahead and declare another class that we'll call ViewHolder. And then our ViewHolder class will need to extend the RecyclerView. ViewHolder class. So now once we add that class, we can see that our RecyclerView. ViewHolder is underlined in red. So let's go ahead and hit Alt+Enter and see what's up there. And notice that one of the options we have here is to add the appropriate constructor parameters, so let's go ahead and choose that. Then I'll hit Enter. So you can see there that our ViewHolder class accepts a reference to a View, and then we pass that reference in to our base class. And we'll do some more work with that View reference shortly. But before we do that, there's still some work we need to do within our NoteRecyclerAdapter class. Now our NoteRecyclerAdapter class also needs to extend the base class. It needs to extend RecyclerView. Adapter, so let's go ahead and add that. And RecyclerView. Adapter accepts a type parameter. Now type parameter will be the type of the view holder we're going to use, and that'll be NoteRecyclerAdapter. ViewHolder. So now what this tells us is that we have a class, NoteRecyclerAdapter; it extends the base class, RecyclerView. Adapter; and we'll be using our class NoteRecyclerAdapter. ViewHolder to hold our view information. Now our screen's getting a bit crowded here, so let me do two things. First, let me go ahead and collapse the Project window. Then the other thing we'll do is go ahead and put a line break before our base class, and that'll just give us a little bit more room to work. Okay, so we're set there. Now you notice that NoteRecyclerAdapter is underlined in red. So let me take my cursor up there. Then I'll hit Alt+Enter. You notice that one of the options I have here is to implement its members, so let's go ahead and choose that. You'll notice that the functions we see here, onCreateViewHolder, getItemCount, and onBindViewHolder, are the methods we talked about in the slides. So these are the methods we'll need to override. So I'm going to go ahead and select them all, so I'll do a Ctrl+A. Then I'll go ahead and hit Enter. So now you can see there that we have our class, NoteRecyclerAdapter. It's got our three methods within it. And in addition to that, it has our ViewHolder class. So now in order to start working with our NoteRecyclerAdapter, there's a few things we'll need to do. Now one of the things our NoteRecyclerAdapter will need is a context, so let's go and add the context as a parameter to our NoteRecyclerAdapter class's primary constructor. So now we have it there as a parameter, but we're going to actually need to use it within the class, so let's go ahead and make it a private assign-once property. So we'll simply place private and val before the name of our parameter. So now we have our context as a private property, which will enable us to use it throughout the class, and let's go and add one more property here as well. So let me go and add a couple of new lines here. And then a property I want to add is a property that will allow me to go ahead and inflate layout resources, and we do that using a class called layoutInflater. So let's go ahead and declare another private property here. We'll call it layoutInflater. And the way we'll create our layoutInflater is by using the LayoutInflater class's from method. And we want to create it from the current context, so we'll will pass in the context property. So with that now, we have the starting point for our NoteRecyclerAdapter class. It'll receive the context as one of its constructor parameters, and thanks to our layoutInflater property, it includes the ability to inflate layout resources. So in our next clip, we'll continue working in our NoteRecyclerAdapter class, and we'll add the code to inflate the layout resource, as well as populate the members of our view holder.

Managing Views within a RecyclerView Adapter
Here we are back in Android Studio, and what we want to do now is do the work necessary to create the views that we use to display the individual items within our RecyclerView. So we're here inside of our NoteRecyclerAdapter class, and the first method we're going to work in is this method, onCreateViewHolder. So let's go ahead and remove this TODO that we have inside there. So what we need to do is create that view that we're going to use to display the individual item. So let's declare a local variable here named itemView. Now, remember that in a previous module we created a layout resource that describes the appearance we want to use for each of these notes displayed within a RecyclerView, so we'll want to inflate that resource. To do that, we'll use the layoutInflater property that we have. We'll call its inflate method. So the first parameter to our inflate method is our layout resource. The next parameter we have to pass will be a reference to the ViewGroup that will serve as the parent of the inflated resource. Well, if we look here at our onCreateViewHolder method, we'll see its first parameter is named parent, and its type is ViewGroup. So that's the view group that this resource will be inflated in to, so we'll pass parent as the second parameter. And then the last parameter is a Boolean value. If we pass true, the inflated layout will automatically be attached to the parent. Now we don't want to do that. We're going to let the RecyclerView manage that for us. So instead, we'll pass false. So what we've done here now is we've inflated our layout resource, item_note_list, we've indicated that its parent will be the parent that's passed into onCreateViewHolder, and then by passing false as the last parameter, we've indicated that we do not want to have it automatically attached to its parent. So with that now, we've got the view inflated that we'll use for the individual items within a RecyclerView. Now the return value from onCreateViewHolder is a reference to a view holder that contains the information for the inflated view. So let's call return, and we'll construct a new instance of ViewHolder, and then we'll pass itemView in to our ViewHolder constructor. So now down here in our ViewHolder class, we can see that we received that itemView, and we passed it to our base class, but there's also some other work we have to do inside of here. Remember that our ViewHolder class is responsible to hold references to the contained views that we want to interact with. Now, remember that when we display information inside of our RecyclerView, we want to display two pieces of information, the name of the course that corresponds to the note, as well at the note's title. So our ViewHolder will need to hold references to both of those TextViews. Now when we worked with things like activities, the references to our contained views were automatically found for us. We never needed to call a method to actually get references to those views. But here within our ViewHolder, Android Studio's not able to automatically generate properties for all the contained views, so here inside of our ViewHolder class we're going to need to explicitly write code to get references to the views that we want to interact with within the item_note_list layout. So let's go ahead and declare properties for those. So the first property will be named textCourse. So another view we want to get a reference to is contained within itemView, and to get a reference to the view, we call a method called findViewById, passing in the ID of the view that we want. And the view that we want is one with the ID textCourse, so I'll pass in R. id. textCourse. Now you'll notice that findViewById is underlined in red, and that's because findViewById wants to know the specific type of the view that's being returned. So we'll indicate to findViewById that the type of view coming back is a TextView that could potentially be null. So that'll give us back a reference to the TextView that we'll use to display our course information. But notice there's one last thing we need to do here. Notice that the. after itemView was underlined in red. Well, that's because the itemView that we passed in to ViewHolder can potentially be null, so we'll just make that itemView?. rather than simply itemView.. So now we're set there. We now have a reference to the TextView that we'll to display the course information. So now let's do the same thing for the TextView we'll use for the note title. So we'll declare another property, we'll name is textTitle, and then we'll again call findViewById on itemView, but in this case, for the ID, we'll pass in R. id. textTitle. So with that, we're now all set with the views and our ViewHolder. So what happens here is up in our NoteRecyclerAdapter class, we have that onCreateViewHolder method, and the RecyclerView will call onCreateViewHolder multiple times because remember that our RecyclerView wants to create a pool of views that can be used to display the information. So each time onCreateViewHolder is called, we'll inflate our layout resource to create another view instance that we can use within the RecyclerView, we'll then construct our ViewHolder, passing in that reference to the view, and then inside of our ViewHolder, we'll get references to the TextViews used for the course and the note title within that particular view instance. So that'll take care of creating the views that we want to use to display information inside the RecyclerView, but now we need to add the code to associate the data with those views. We'll see how to do that in our next clip.

Managing Data within a RecyclerView Adapter
Here we are back in Android Studio, and what we want to do now is add the code to our RecyclerAdapter to display the data within our RecyclerView. Now, of course to do that, the first thing we'll need is some data. Remember the purpose of this RecyclerAdapter is to display notes. So let's add a parameter to our constructor that will accept a list of notes, and we'll go ahead and make that a private property. So now we'll receive notes as a constructor parameter. We'll have access to it using our notes property. So now we can go ahead and start displaying the data. Remember the method responsible for displaying the data is this method onBindViewHolder. And notice that onBindViewHolder takes two parameters. First, let's look at the second parameter. Second parameter's the position, so that's the position of the data we want to show. So that's an easy one. That'll be the position inside of our notes collection that we want to display the information for. But now look at this first parameter. The first parameter is a ViewHolder, and it turns out that's our ViewHolder. So earlier when the RecyclerView called onCreateViewHolder, it created those view instances that we then stored inside of our ViewHolder. Well, remember, they went into a pool the RecyclerView was managing. So now when it's time to display some specific data within the RecyclerView, the RecyclerView is passing us back our ViewHolder. So we can then use the properties from within that ViewHolder to display data. So let's go here inside of our onBindViewHolder method. Let's remove that TODO line there. So the first thing we want to do here is get a reference to the current note, so let's declare a local variable named note. And so we'll get the note from our notes collection at the position it's passed in to onBindViewHolder. And then once we have that note, we can start displaying the information from the note using the ViewHolder that was passed in. The first thing we'll display is the course, so let's say holder. textCourse. Now remember that textCourse is a TextView, so we want to set its text property, and then we'll get the note. course property. So that'll give us a reference to the course within the note, and what we want to do is display the course's title. So that sets the text in our textCourse view to the title of the note's course. So now I want to set the note title itself. So we'll say holder. textTitle, we'll set the textTitle TextView's text property, and then we'll set it to the note. title. So now with that in place, as the RecyclerView displays data and the user scrolls through that data, the RecyclerView is able to recycle the views that we created earlier by passing us in the ViewHolder for a particular view, and then we can take that ViewHolder and set the data within the view based on the current data position being displayed. So our NoteRecyclerAdapter is just about ready to use. There's one more important thing we need to do here. Notice we have this method getItemCount, and that's used to indicate to the RecyclerView how much data overall will be displayed. And to set that, we can simply use the size of our notes collection. So let's remove that TODO line from inside of getItemCount, and then we can simply return back notes. size. So now with that, our getItemCount method will return back the size of our notes collection. But now before we finish up, let's take a look at this method. This method does one very simple thing. It simply returns back a value. In this scenario of a method that simply returns back a value is something that comes up frequently when we're implementing our classes. So because of that, Kotlin actually gives us a shorthand for writing methods like this because we've got a lot of boilerplate code here. We had to explicitly specify the type for the function, we had to call the return keyword and return back the value, and of course, we have the opening and closing curly brackets. So Kotlin actually gives us a shorthand that we can use for simple methods like this. To use the shorthand, the first thing we'll do is remove the curly brackets. So now I've gotten rid of the curly brackets. We'll also get rid of the return type specifier, and we'll replace it with an equal sign that will get rid of the return notes. size, and then we'll specify notes. size after the equal sign, and then that's it. Now the behavior of this function is no different than the way we originally wrote it. The only difference is we've used a more concise syntax to specify the behavior of the getItemCount method. All right, so with that, our NoteRecyclerAdapter is all set. So in our next clip, let's go ahead and connect it up to our NoteListActivity, and we'll run our code and see how things look.

Displaying Our Notes List within RecyclerView
Here we are back in Android Studio, and what we want to do now is go ahead and connect up our NoteRecyclerAdapter to our RecyclerView. So now we're looking here at our NoteListActivity class, and we already started to do some of the work with our RecyclerView in the previous module. Remember we had this line here, listItems. layoutManager = LinearLayoutManager. ListItems is our RecyclerView, and we've associated the LinearLayoutManager with it, which means we simply wanted to display the information in a simple linear form. So now to associate the item views along with the appropriate data, we need to connect our NoteRecyclerAdapter to the RecyclerView. So to do that, we'll take the reference to our RecyclerView, which is listItems, and we'll set its adapter property. We'll create an instance of our NoteRecyclerAdapter. Remember our NoteRecyclerAdapter takes some parameters. The first parameter is the context, so we can simply pass in the activity's this reference. And then the other parameter is the notes that we want to display. So for that, we use our DataManager's notes property. And that easily, we've now connected our NoteRecyclerAdapter to the RecyclerView. Let's go ahead and run the code now and see how things look. Here we are now with our app up and running. You can see that now the content within our RecyclerView is using that layout that we created. Each of the items within a RecyclerView are displayed as a card. We can see we have the image to the left of each card, and our course title and note title are all formatted as we specified in that layout resource. You can even grab one of the items and scroll things around. So all that's working well just like we'd like it to, but there is one kind of funny thing going on. Notice that in all these cards where the course title is multiple lines, the course title is running into the note title, so there's something going on with our layout. So let's head back into Android Studio, and let's see if we can get that fixed. So we're back here now in Android Studio, and we're currently looking at the layout resource that we use to specify the layout of each item within the RecyclerView, and I currently have the TextView for the note title selected. And if you look over in the Attributes window, you can see that constraint's set for both the top of that view and the bottom of the view. And if you remember from the previous module, we set the top constraint to be against the TextView used to display the course title, and then the bottom constraint is against the CardView itself, and that's what's creating the problem. Those two constraints are in conflict with one another. It's causing a TextView for the note title to be pushed up into the TextView for the course title. So what we want to do is remove this bottom constraint here. So I'm just going to go ahead and click on that, and now we've removed the bottom constraint from the TextView for the note title. So let's go ahead and run this guy again, and let's see how it looks now. So here's our app up and running again, and now if we look at it, we can see the cards are displaying correctly. So for example, we have this one card here that has the course, Android Async Programming and Services. That course title takes up two lines, but no longer collides into the note title below it, Service default threads. So now our card's laying out appropriately because we no longer have constraints that are in conflict. So our RecyclerView is doing really well now. Now, there's still a bit of work we need to do. At this point, the way we have the adapter set up, the user can see the content and scroll through it, but they have no way to interact with it. They have no way to make a selection. So in our next clip, let's see what we need to do to allow the user to make selections within our RecyclerView.

Item Selection Handling
Now that we have our adapter in place and we're displaying information inside of our RecyclerView, we now want to add item selection. So as the user browses through the information displayed in a RecyclerView, they can select one of those items. Now if you remember when we did our ListView work and we wanted to have item selection, we actually implemented an interface, the OnItemClickListener interface, and associated that the ListView. And what that meant is that with the ListView, the ListView was responsible for handling the item selection and informing our application. RecyclerView takes a very different approach because a RecyclerView has no explicit support for item selection. Instead what it does is it actually allows the contained views to each add their own click event handler. And that's really powerful because it allows us to support the concept of a single item being selected or the idea of a given item having multiple hotspots on it. Think of the idea of tapping on the picture does one thing. Tapping on a link does a different thing. That sort of idea. So let's see what this might look like. So let's say we have a RecyclerView, and let's think about our application scenario. So we've got our CardView, and we've got a CardView created for each of the items, and then in one of those CardViews we have a course title, and then we have a note title. And of course, we repeat that for each of the items being displayed. So now in our application, we want kind of the ListView-based behavior. We don't really care where on that item the user taps. Doesn't matter whether it's the course title, whether it's the note title, whether it's on the card itself. If they tap anywhere there, we want to select that particular note. So in this scenario, what we do is we actually associate a ClickListener with our top-level view. So no matter where they tap on that view or anything contained within the view, there is just one click handling, and we do that for each of the views that we actually inflate. So we're actually associating a separate ClickListener with each of the views that we inflate, and when that's selected, we'll go ahead and show the note that corresponds to it. But that solution's not appropriate for every application. Some applications may have more involved needs. So think of a scenario where you maybe had like a course title, and if the user tapped on the course title, he wanted to show the course. If the user tapped on the note title, he wanted to show the note, and then maybe even had this idea of a like. So if the user tapped on the star in this case, we want to actually record that that user likes this particular item. And so, of course, we'd have to have that star on each of the items. Well, using RecyclerView, rather than being limited to having entire item selections, we could say that okay, well, when you tap on the course title and want to show the course, we can associate a ClickListener with the view showing the course title. We could then associate a different listener with the view showing the note title. So if the user tapped on that, we could show the note. And then have a different ClickListener on the star so we could record the like when the user tapped on the star. And of course, we would do that for each of the views as we inflate them. And so ultimately, all the item's individual views contained within them would have ClickListeners for each of the hotspots for that item. And so this is a real power in RecyclerView because we can do this multiple hotspots for an item, or we can have a single hotspot for the entire item, and that's what we're going to do in our application. In our application, we're going to go with the single hotspot for the entire item. In our next clip, let's see how to implement that.

Implementing Item Selection Handling
Here we are back in Android Studio, and what we want to do now is add note selection capability to our RecyclerView so that when the user selects a note displayed within a RecyclerView, we'll launch the note activity displaying that note. Now remember that the responsibility for handling the user interaction falls to the views displayed within a RecyclerView. So here in our ViewHolder class, we're going to have to handle when the user selects the view corresponding to a particular note. But now remember though, the views are recycled within a RecyclerView, so the views within a particular view holder will show different notes at different times. So our ViewHolder class is going to need a way to know which note it's currently associated with. So to do that, let's add a property to our ViewHolder class called notePosition. We'll make it a mutable property, and we'll give it an initial value of 0. So with that, we can keep track of the position of the note that ViewHolder's currently associated with. So now we need to go ahead and set that property, so we'll do that up in our onBindViewHolder method. Remember that our onBindViewHolder method receives the position of a note, and the code we currently have in there sets the appropriate display values for that note. Well, after we set those display values, let's go ahead and set the notePosition property of the holder to be the value the position passed into onBindViewHolder. So with that, our holder always knows the position of the note that it's currently associated with. So now we're ready to start adding click handling capability. Remember that when we're working with RecyclerView, each individual view corresponding to an item can have their own individual click handling, or we can have click handling just at the top-level view for a particular item, and that's what we want in our case. No matter where the user taps on a particular note, we just want one click handler to handle the selection of that note. So the way we'll do that is by associating a click handler with our top-level view, which is the view passed in as the itemView parameter of our ViewHolder class's primary constructor. And we'll add a click handler on that view within an initializer on our ViewHolder class. So just below our notePosition property, let's go ahead and declare an initializer. Then here within our initializer, we'll add the code for a click handler on our itemView. So we'll say itemView. setOnClickListener. We'll specify the handling within a lambda expression, so we'll say open curly bracket, close curly bracket. Then inside of here, the first thing we'll need to do is create the intent to launch our note activity. So let's declare a local variable named intent. We'll create a new instance of the Intent class. And the constructor Intent class will need a couple of parameters. The first one we'll need is a context. Now our ViewHolder class doesn't currently have access to the context, but notice that the class it's nested inside of, NoteRecyclerAdapter, does have a property for the context, so we could potentially pass that context into the ViewHolder class as a constructor parameter, but there's an even easier way to do it. We can take our ViewHolder class and mark it as an inner class. So let's go ahead and add the inner keyword to our ViewHolder class. And by marking ViewHolder as inner, we've indicated that we want to allow this nested class, ViewHolder, to have access to the members of the containing class, NoteRecyclerAdapter. Because without that inner keyword, the ViewHolder class could not access those properties. So now that it's marked as inner, we can take the context property from the outer class and use it here where we construct the intent. And now the second parameter to the intent is the class information for our NoteActivity class. So that constructs our intent. So let me go down a couple of blank lines after it. So now once we construct the intent, we need to pass the position of the note to be displayed. So I'll call the putExtra method on the intent reference. We need to provide the name of the extra. To specify the extra name, we use the constant, NOTE_POSITION. And NOTE_POSITION is simply a string constant that we defined back in the first course in this series. And then after the extra name, we pass in the value, which is the notePosition property of our ViewHolder class. And with that, our intent's all set, so now we're ready to start the activity. So to start the activity, we'll call the startActivity method on the context property, and we'll pass in our intent. So now with that code in place, when the user selects a particular note within our RecyclerView, we'll launch our NoteActivity, passing in the position of the note they selected. So we're just about ready to test out our RecyclerView. There's just a little bit more work we need to do, and we'll see how to do that in our next clip.

Updating RecyclerView Content
Here we are back in Android Studio, and we're just about ready to test out our app's behavior when the user selects a particular note within our RecyclerView. And we've already done the bulk of the work. Because if we look here at our NoteRecyclerAdapter class, we've got our onCreateViewHolder method that takes care of creating the views that the RecyclerView will recycle, we've got our onBindViewHolder method where we bind data with those views the RecyclerView's recycling, and then down here in our ViewHolder class we've got references to all our views, and we've got a click handler in place to launch our note activity when the user selects a particular note. But there's still just one last thing we need to do, and we'll do that over in our NoteListActivity class. So here we are in our NoteListActivity class, and we've already done the bulk of the work here for our RecyclerView. When our activity's created, we associate the LayoutManager with our RecyclerView, and we associate our NoteRecyclerAdapter with our RecyclerView. But there's one last thing we need to address. Remember, when the user selects a note, the user might make a change to that note, and if the user makes its change to the note, when they return back to the NoteListActivity, we want to be sure that the most recent changes to the data are visible within the RecyclerView. So in order to do that, we need to notify our adapter that the data might've changed. So we'll do that here in our NoteListActivity class's onResume method because remember that onResume will be called when the user returns back to the NoteListActivity. So first thing we need to do is get a reference to our adapter, so we'll use the adapter property of our RecyclerView, which is listItem. Adapter, and then we'll call notifyDataSetChanged. So with that call in place, whenever we return back to our NoteListActivity, the adapter will be notified to refresh the data that's being displayed. And notifyDataSetChanged is a great way to address this issue when dealing with relatively small data sets like we have. It's important to note, if you're dealing with a really large data set, there are more efficient options available. There are ways to notify the adapter of specific items that it manages being changed. But again, for simple data sets like ours, notifyDataSetChanged works really well. All right, so we're all set here. So let's go ahead and run this guy, and let's see how things look. So here we are now with our app up and running. We can see the list of notes displaying within our RecyclerView. So let me just go here to the second note, and I'll select that. As we can see, it launches our note activity, and it displays the correct note. Let's go ahead and make a change to the note title. Let me just go and add some Xs on to the end of that note. So our note title is Delegating intentsXXX. Let me go and collapse the keyboard. Let's go and head back to our NoteListActivity. And as you can see, when we return back to our NoteListActivity, the title of our note is now updated to include those three Xs at the end. And so with that, we're all set now. We're able to display the notes within our RecyclerView. The notes have this nice three-dimensional card-like appearance. The user can select a note to display that note within our note activity, and any changes they make to that note are reflected in the RecyclerView when the user returns back to our NoteListActivity.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that the adapter is the workhorse of dealing with RecyclerView. So the way we implement our adapter is by extending the class RecyclerView. Adapter, and then our adapter handles two distinct aspects of dealing with the RecyclerView. It takes care of creating the view instances that are displayed within a RecyclerView, and then it associates data with those views. But the real power comes from the RecyclerView in the way it manages views versus data. Because remember that the views are decoupled from the data because remember that our RecyclerView will create just enough views to handle scrolling. It doesn't have to create as many views as there are data items behind them because those views will simply be stored in a pool and can then be reused. So now in order to reuse those views, we use view holders. So what we're going to do then is implement our own ViewHolder class that extends RecyclerView. ViewHolder, and it's going to contain some view references. It'll contain a reference to the top-level view that corresponds to an individual item, and then it can also hold references to the views contained within that top-level view. So then when it comes time to display data, we'll need to bind data to the views within the view holder. So basically, the adapter does the job of associating specific data items with the views, but those views will actually come from the view holder. In other words, the RecyclerView has created this pool of views, and then as a user moves through that data, it will pass views from that pool into us. We receive those as a reference to our view holder. Then using the view holder, we can specify the data values we actually want to display. So now when it comes to handling a user's selection with a RecyclerView, remember that the RecyclerView class itself doesn't really have this idea of item selection. Instead, it's the views within the RecyclerView that are responsible to handle the click event associated with a user making a selection. So now there are two broad ways we can do this. One is single item selection. So in this case, we put a click handler on the top-level view. That way, if the user taps on any of the views associated with that item, it's treated as simply a selection of that item. But remember, we also can have multiple selections within an item. In that case, the views within a particular item can each have their own click handlers. So in that sense, we can create multiple hotspots within a single item displayed within the RecyclerView. All right, that wraps up this module. In our next module, we'll start looking at the navigation drawer and see how we can use it to provide drawer-based navigation within our applications.

Understanding Drawer Navigation
Introduction
Welcome to our next module, Understanding Drawer Navigation. This is part of the Pluralsight course, Android Apps with Kotlin: RecyclerView and Navigation Drawer. My name is Jim Wilson. In this module, I'm going to take a look at the navigation drawer, which is one of the key user interface facilities providing users with the ability to easily navigate through your application features. We'll start out by taking a look at the navigation drawer's behavior and how we use it. From there, we'll see how to add a navigation drawer activity to our application. We'll then look through the classes involved in providing a navigation drawer. And then finally, we'll look at how we deal with the layout resources creating by Android Studio when we add an activity to our app that contains a navigation drawer.

Navigation Drawer Layout
Navigation drawer is a very powerful user interface concept, and what it's intended to do is provide our application's main navigation options. One thing that's so nice about the navigation drawer is that it's hidden whenever we're not using it, but then when we need it, we can simply slide it in from the edge of the screen. Technically speaking, we slide it in from the start edge of the screen, but on most devices, that's going to be the left edge of the screen. The only time we would slide it in from the right is if we were dealing with a language like Arabic or Hebrew that's actually written right to left. Then in those cases we'd slide it from the right. But for the overall and majority of devices, we slide it in from the left edge. And just for convenience as we talk about the navigation drawer, we're always just going to talk about sliding it in from the left edge. If the navigation drawer is hidden when we don't need it, how do we find it when we do need it? And there are basically two ways we can do that. One is that we can tap on the app icon, which is simply an icon that appears on the activity's app bar, and that will go ahead and open it up, or the user can simply swipe from the left edge of the screen and effectively pull the navigation drawer onto the screen. All right, so what does this look like in our application? Well, if we look at our application's activity, you notice that we've added an app icon here, and that's just that icon in the left. And the specific app icon here we're using here is what's often called the hamburger or just the stacked bar icon, and that's used to indicate that we have a navigation drawer. So the user can tap on that to open up the navigation drawer, or as we mentioned, a user can simply go to the left edge of the screen and then swipe their finger inward, and that would open the navigation drawer. So once we have that, when a user performs one of those actions, the navigation drawer slides out and overlays our main application content. And then the user can select whatever option they want from the navigation drawer, and then our application will then go on to perform whatever action's appropriate for the user's selection. All right, so to get a sense of what it's like to work with a navigation drawer, in our next clip, we're going to modify our application to now include a navigation drawer.

Creating a Navigation Drawer Activity
Here we are in Android Studio, and what we want to do now is add a navigation drawer to our application. Now we're currently looking at the content layout for our NoteListActivity. As you recall from earlier in the course, this is the activity that contains a RecyclerView that we use to display a list of notes. Now one way we could add the navigation drawer would be to manually add it to our existing layout for this activity. But manually adding a navigation drawer is actually a fair bit of work. It'd be a lot easier for us just to create a new activity and let Android Studio generate the navigation drawer-related code for us. Then we can just hook in our RecyclerView into that activity. So that's what we'll do. So to get us started, we'll head up here to the package name, and I'll right-click. I'll choose New, then I'll choose Activity, and then from there, I'll choose Gallery. When we get to the gallery, I'm going to scroll down here a little bit. You'll notice that here in the gallery, one of the options is Navigation Drawer Activity, and that's the one we're looking for, so I'll go ahead and select that. I'll choose Next. For the name of this activity, let's go ahead and make it our ItemsActivity. We'll want this activity to be the initial activity that the user comes into, so let's go here to Launcher Activity, and we'll select that. And since it'll be our initial activity, let's make the activity's title the application name, which is NoteKeeper. Now I want to make sure that our Source Language is set to Kotlin, and it is, so let's go ahead and click Finish to create our activity. Now once your activity is created, Android Studio takes us into the content layout for that activity. But before we do any work in our content layout, let's head up to the top-level layout for this activity, which is the layout file, activity_items. I'll go ahead and select that. And you can see that that layout actually shows us the preview of the navigation drawer. So we now have an activity that contains a navigation drawer. Now as we mentioned, we want to actually display our list of notes within a RecyclerView inside this activity. So let's head back down to the content layout for this activity, which is content_items. I'll go ahead and select that. And now we'll go ahead and just place a RecyclerView within this activity. So over in the Palette, I'll head over to RecyclerView. I'll drag the RecyclerView onto our design area. Let's go ahead and set constraints on the top, bottom, left, and right edges of this RecyclerView. So now we have constraints set on the top, bottom, left, and right edges. Now remember for those constraints to take effect, we need to set both our layout_width and layout_height to match_constraint. So now our RecyclerView will be sized and positioned based on those constraints. We'll give our RecyclerView an ID, and let's give it an ID of listItems. And now we have our ID there, so we can access our RecyclerView by using the listItems synthesized property within our activity. So we're just about ready to start adding code to interact with this RecyclerView. But before we do that, let's do one last thing here in this layout resource. If we take a look at the preview of our RecyclerView, we're getting the default preview, which just shows a simple list of items. Remember that we'll be using this to display a list of notes, and it would be nice if our preview reflected the way the RecyclerView will appear at runtime. Now remember we can do that by using the listitem attribute of the RecyclerView. Now as you recall from earlier in this course, this attribute doesn't affect the runtime behavior of RecyclerView, but it does allow us to set the way it appears at design time. So we'll use that so that the preview reflects the appearance of our note layout when we run our application. So to do that, I'll head over to the dots on the right of listitem. Remember that at runtime we use this layout, item_note_list, for the layout of the individual notes within the RecyclerView, so let's head over there. I'll go ahead and select that, and then we'll hit OK. And once I do that, our RecyclerView now previews using the layout we'll use at runtime. So we're good to go here with our layout. In our next clip, let's go ahead and start connecting up our note functionality within the activity's code.

Connecting Note Functionallity
Here we are back in Android Studio, and what we want to do now is hook up our note functionality to our new navigation drawer activity. Now we're currently looking at the layout resource, content_items, and that's the layout resource that contains our RecyclerView. As a reminder, the ID of our RecyclerView is listItems, so that's the property we'll use to interact with it when we're in our source code. So let's head up to the source code for this activity, which is our ItemsActivity class. I'll go ahead and select that. That takes us into our ItemsActivity class. So we're going to start out here in the onCreate method, and we want to start setting up our RecyclerView to display the list of notes. So now to interact with that RecyclerView, we'll use our listItems synthesized property. And you'll notice that when I do that, Android Studio's saying that there are multiple choices, so let's see what those choices are. So to do that, I'll hit Alt+Enter. And when this Imports dialog shows up, you can see there are two choices that relate to synthesized properties, and that's because there are two different layout resources that contain a view with the ID listItems. And the one we want is the one in our content_items layout resource. So I'll select that. I'll hit Enter. So now that it's resolved our synthesized property, we can go ahead and start setting attributes on that property. Now remember that our RecyclerView needs a layout manager, so we'll use the layoutManager property; for our notes, we use a LinearLayoutManager; and for our LinearLayoutManager's constructor parameter, we'll pass in our activity's this reference. So now we're all set with our layout manager, so now let's go and associate the adapter. So we'll use the listItems. adapter property. We'll use the same adapter we used before, so that'll be our NoteRecyclerAdapter. For the constructor parameters, we'll pass in the activity's this reference and the notes collection from our DataManager. And believe it or not, that takes care of the bulk of the work of setting up our RecyclerView because remember that most of what we need to do with the RecyclerView is actually handled in our adapter. The adapter handles the details of displaying the content, and the adapter handles the details when the user interacts with content inside the RecyclerView. So our RecyclerView is all set up to display the data, but there is one more thing I want to do with our RecyclerView. Remember that we want to make sure that our RecyclerView always displays the most up-to-date content, so I'll tell it to refresh its content whenever the user returns back to this activity, and we do that by overriding the onResume method. So we'll hit Ctrl+O. That brings up our Override dialog. We'll scroll down. We'll locate onResume. We'll select that. I'll hit Enter. Then after the call to the super class, we'll use our listItems. adapter property, and we'll call notifyDataSetChanged. So now any time a user goes into our note activity and makes a change to a note, when they return back to our items activity, the RecyclerView will be refreshed with the latest content. All right, so our RecyclerView is all set, but there's just one more bit of behavior I want to add to this activity. Remember that when the user taps on the floating action button, we want to go ahead and launch the note activity to allow them to create new note. So let's go up here where we set the OnClickListener for our floating action button. Let's remove the code within the listener that Android Studio provided, and remember we want to start our note activity, so we'll call the startActivity method. And when we call startActivity, we'll pass in the intent to launch our NoteActivity. And so now the behavior of our ItemsActivity is all set. We can display our notes within the RecyclerView, and the user can create a new note by tapping on the floating action button. With that, we're just about ready to verify that our new activity behaves as we expect, but there is a little bit more work we need to do. So in our next clip, we'll finish up the changes to our app, and then we'll run the app to verify that our note behavior works correctly.

Modifying the Manifest and Running Our App
Here we are back in Android Studio, and what we want to do now is verify that our new navigation drawer activity behaves correctly. But before we do that, I want to make sure that we have the appropriate activity set as the launcher activity in our application. So the way we'll do that is we'll head over to our Project window. We have this folder here labeled manifests. Let's go ahead and expand that. And inside of manifests, we have our AndroidManifest file. So let's go ahead and open that up. And as you recall from the first course in this series, the AndroidManifest describes the components within our application, and of course, those components include our application's activities. So to check out our activities, let me just scroll down here a little bit. Now once we scroll down here, you can see the information for our ItemsActivity, and that's the activity we just added. That's the one that contains our navigation drawer and displays our note information. And just above that, we have our NoteListActivity, and that was the activity we used previously to display our note information. Both of these activities have the intent-filter that indicates that they're LAUNCHER activities, and we don't want both of them to be LAUNCHER activities. We only want our ItemsActivity to be a LAUNCHER activity. So the way we fix that is we head up to our NoteListActivity, and we remove the intent-filter that marks it as a LAUNCHER activity. So now with that gone, NoteListActivity is no longer a LAUNCHER activity. Now our ItemsActivity is the only LAUNCHER activity, and that's exactly what we want. So now let's go ahead and run our app and verify that the ItemsActivity behaves as we expect. Here we are now with our app up and running, and the first thing we want to check is to make sure that it's the ItemsActivity that launched, not our NoteListActivity. And we can tell that this is our ItemsActivity because we have our stacked bar icon on the left edge of the toolbar. Remember that stacked bar icon tells us that we have a navigation drawer. So we've launched the correct activity, and we can see that our activity is displaying the RecyclerView with the list of notes. If I try to scroll the list up and down, let's see if that works, and it does. Let's go ahead and select a note. Displays the note correctly, so that's good. Let's head down to our Back button. We'll go back to our ItemsActivity. Let's head over to our floating action button. Now here on our floating action button, notice that it's not showing our plus sign image. It's still showing the default image that Android Studio gave it. Now we'll fix that shortly, but what we'll want to verify right now is that it behaves correctly. So let's go ahead and tap on our floating action button, and that displays our note activity to allow the user to create a new note, so that's also working. So let's head over to our Back button. We'll return to our ItemsActivity. So that all verifies that our ItemsActivity has the appropriate behavior for displaying and interacting with notes. But remember the main reason we created this ItemsActivity is because we wanted to add a navigation drawer, so let's verify this activity does indeed have a properly behaving navigation drawer. So the first thing we'll do is head up there to that stacked bar icon. I'll go ahead and tap on that, and you can see that opens up our navigation drawer. So that part works correctly. Let's go over here and try and drag it back. We were able to hide it correctly. Remember that another way we can display the navigation drawer is to drag it out from the left edge. So let's go over here to the left edge, I'll grab on, and let's drag it out. So that part works correctly. Let's head down to our Back button, and let's verify that our Back button properly closes the navigation drawer. So I'll tap on that, and that works correctly as well. So we're off to a great start. We have our new activity with a navigation drawer, and it has all the note functionality we need. So in our next clip, let's take a closer look at the types involved in working with our navigation drawer.

Navigation Drawer Classes
Let's look now at the types involved in providing this navigation drawer behavior. The primary type is DrawerLayout, and this gives us the ability to have a layout that has our primary activity content, as well as the navigation drawer. And when we look at the primary activity content, that could be any view placed underneath the DrawerLayout. But when we use Android Studio to generate an activity with a navigation drawer, the primary content for the activity is actually referenced through an include, in other words, the layout resource that we use to layout the activity containing the drawer. Then it references another layout resource that'll have that main content area of our activity. And then when it comes to the navigation drawer itself, that also can be any old view. The DrawerLayout doesn't really care about the types of the views underneath of it. But in practice, the navigation drawer is usually provided through a class called NavigationView, and we'll talk more about the details of NavigationView shortly. Now with just these types involved, the core aspects of the navigation drawer are in place. The user could swipe in from the edge of the screen, see the navigation drawer, swipe to push it back, all those sort of things. What they wouldn't have is the app icon behavior. So there's another type called ActionBarDrawerToggle, and that actually connects up with the DrawerLayout and the activity's app bar. And that takes care of making sure that we have an appropriate app icon there, and it provides the behavior that we need. So that way if the user taps on that app icon, that will also open up our navigation drawer. So collectively, these types all provide our navigation drawer-based behavior. So now in our next clip, let's see what all this looks like in code.

Exploring Navigation Drawer Code and Layouts
Here we are back in Android Studio, and what we want to do now is take a closer look at the code and layout resources associated with our navigation drawer. Now we're currently looking at our ItemsActivity, and this is the activity has our navigation drawer. If we look here in the onCreate method where we call setContentView, the layout resource that we load up is our activity_items layout resource. So let's take a look inside that guy. So over in the Project window, I'm going to go ahead and double-click on activity_items. And when we open up this layout resource and we take a look at the Component Tree, notice at the very top of the Component Tree is our drawer_layout. Remember that the drawer_layout provides a capability to have drawers that slide in from one of the edges of the activity. Now underneath that drawer_layout, we have an include, and that include is for our app_bar_items layout resource. So let's head over there, and I'll double-click on that. When we open up that layout resource, we can see that this is the layout resource that provides our toolbar and our FloatingActionButton. So this is the layout resource that provides the overall appearance of the activity itself, but it doesn't describe the content within that activity. The way we get to the content within the activity is through another include, which is our content_items layout resource. So if I head down to that include line and I double-click, that opens up our content_items layout resource. And this guy should look pretty familiar because this where we worked to add the RecyclerView to our activity. So when we're working with a navigation drawer, we're working with three levels of layout resources. The very bottom is the content layout resource where we describe the actual content of the activity. Above that, we have the app_bar layout resource, which is a layout resource that adds things like the toolbar and floating action buttons. Then at the very top is the activity layout resource, which provides our drawer_layout, which gives us the ability to have those slide-in drawers. Well, looking at our preview of our activity, we still have a little bit of work we need to do in our layout resources. Remember that our floating action button here isn't showing the correct icon, but of course, we can't make that change here because we're currently in our content layout resource. What we want to do is head back to the app_bar layout resource. So I'll head over to that layout resource in our Project window, I'll double-click, and we can see there in the Component Tree that's where our FloatingActionButton is defined. So I'll go head and select the FloatingActionButton. Of course, I'll need to change one of its attributes, so I'll head over to the right edge of the screen where it says Attributes. I'll select Attributes, and the attribute I want to change is the one that says srcCompat because that's what identifies the image that's displayed within the FloatingActionButton. So I head down to the dots to the right of it, I'll click on those dots, I'll expand the Project group, and then here within the Project group, I'll choose ic_add_white. And now our floating action button displays the correct image. So our layouts are all set. So let's head back to our ItemsActivity class, so I'll double-click on it here in the Project window. Now let's take a look at the code related to the navigation drawer. And to do that, we'll take a look here in the onCreate method of ItemsActivity. And you'll see we have a group of lines here related to the ActionBarDrawerToggle. So you'll notice the first thing we do is create an instance of ActionBarDrawerToggle, and when we create that, we pass in references to our drawer_layout and the toolbar. Because remember, the purpose of ActionBarDrawerToggle is to allow the user to open and close the navigation drawer by tapping on the icon at the left edge of the toolbar. And then in addition to those references, we also pass in two strings. Notice one says Open navigation drawer, the other says Close navigation drawer. And those are provided for screen readers. So if someone is using a screen reader, those two parameters indicate what text to be read to the user based on the current state of the navigation drawer. Now once we create the ActionBarDrawerToggle, we then add it as a listener to the drawer_layout. So basically, that toggle needs to be informed any time the navigation drawer is opened or the navigation drawer is closed because it has to know the current state of the navigation drawer. And then once we add it as a listener, we then tell the toggle to syncState. In other words, we want to make sure the toggle knows the starting state of the navigation drawer. So by calling syncState, the toggle correctly knows whether the starting state of the navigation drawer is opened or closed. Now just below that, you can see we do some work with the navigation view itself. We'll talk a whole bunch about that in our next module. But for now, I want to show you one other method, so let's just scroll down a little bit. So we're here now at our onBackPressed method. Remember that one of the ways the user can close the navigation drawer is by pressing the Back button, so the code to do that is added to this method. So you notice the first thing we do is we go to the drawer_layout and ask if a particular drawer is open. And the way we identify the drawer is by indicating the drawer's gravity. Because remember that the drawer_layout can actually manage multiple drawers, so we have to tell it which drawer we're interested in. Now in our case, we only have one, and that's the drawer that's on the start edge, which, again, for most devices is the left edge. So basically, we're asking is that drawer open? And if it is open, then we call closeDrawer on the drawer_layout to close it. But if the drawer is not open, we then simply call the super class's onBackPressed. So in other words, if the drawer is open and the user hits the Back button, it closes the drawer. If the drawer is not open, then we do whatever the normal behavior of the Back button is. All right, so that's the code for the Back button, but what about this issue of the Gravity START? Where do we indicate the gravity of the drawer? Well to see that, we need to head back to the layout resource for the activity. So let's head back over to activity_items. So we're here in our activity_items layout resource, and I want to switch from the design appearance to the text appearance. So I'm going to head to this Text tab down here at the bottom. I'll go ahead and select that. So now here in the TextView, let's take a look that entry for our NavigationView. Now as I mentioned, we're going to talk a whole bunch about the NavigationView in our next module, but the key thing I want to look at here is the entry for the layout_gravity. Notice that is has a value of start. And what that entry does is it indicates to the DrawerLayout where the drawer that contains this NavigationView should slide out from. So it's that layout_gravity of start that indicates it should slide out from the start edge. And as we saw in our code, that gravity is also how the drawer_layout identifies the individual drawer. So when we want to interact with one of the drawers within the layout, we identify that drawer by its layout_gravity value. So our application's off to a great start with the navigation drawer. We have the navigation drawer, all the code in place for it, as well as our note-based behavior incorporated into our new activity.

Summary
To wrap up, here are some of the key things you want to remember from this module. Now throughout this module, been looking at the navigation drawer. And the purpose of the navigation drawer is to provide our app's main navigation options. Now the navigation drawer normally slides out from the start edge of the display, and for most devices, that's going to be our left edge. Now remember that the navigation drawer is hidden most the time, so we'll need a way to open and close the navigation drawer, and there was a couple of options there. We can swipe out from the left edge to open it, as well as swipe it back off that left edge when we're done with it, we can use the app icon to open and close it, and we also have the option of closing it with the Back button. Now a key class in providing this drawer-based navigation behavior is the DrawerLayout class. And remember the DrawerLayout class provides drawer layout management, so allows our activity to have a primary content area, as well as it has areas for pullout drawer content. Now remember the DrawerLayout class is not specific to navigation drawers. Its purpose is to allow us to have slideout drawers on an activity. So the DrawerLayout class itself allows it to have multiple drawers sliding out from different parts of the activity if that's something we need. And as part of working with our navigation drawer, we had the ActionBarDrawerToggle class, and that's the class that provides the app icon behavior. So that's the class that allows us to open and close the navigation drawer by tapping on the icon on the left edge of our toolbar. All right, that wraps up this module. In our next module, we'll see how to add the actual navigation behavior to our navigation drawer.

Implementing Drawer Navigation Behavior
Introduction
Welcome to our next module, Implementing Drawer Navigation Behavior. This is part of the Pluralsight course, Android Apps with Kotlin: RecyclerView and Navigation Drawer. My name is Jim Wilson. Throughout this module, we'll be looking at how we implement our navigation behavior when our application incorporates drawer-based navigation. So now the first thing we'll do is take a look at the application we're using in this module and take a look at the features we want to add to the application. We'll then look at one of the key classes in drawer-based navigation, which is the class, NavigationView. We'll look at the resources that are associated with a NavigationView. We'll see how to handle the selections within a NavigationView. And as part of that discussion, we'll see how to use a Kotlin feature known as the lazy properties.

App Overview
In this module, we'll continue working on the same app that we've been building throughout the course. Now as you recall, in our most recent module, we added a navigation drawer to our application. So now that we have our navigation drawer, we're ready to start implementing some of the options within a navigation drawer. Now when we have a navigation drawer, there are two broad categories of options that we put into the navigation drawer. One is simple action-based options. So for example, here we have a section of our navigation drawer labeled Communicate, and it has this Share option and a Send option. So in that case, the user might share some content out or maybe send an email to someone. So these behave very much like options in a regular options menu. Now another type of option we can have in a navigation drawer are options that affect the state of the current activity, and this is where we'll be focusing in this module. So what we want the user to do is choose whether they want to display a list of notes or a list of courses in the current activity. Now because these sort of options affect the state of the current activity, they actually have a concept of being the selected option. So for example, when we're displaying a list of notes within our activity, we want to make sure that this Notes option is highlighted as the currently selected option in the navigation drawer. So now with our navigation drawer in place, the user can then select that they want to see the current list of courses. And when they do that, rather than showing a list of notes, we'll instead show that list of courses. Now we're going to be showing the list of courses within a RecyclerView, and we're going to want our list of courses to have a grid style layout. Now what's interesting here is that even though we're displaying different content, a list of notes and a list of courses, since both of these require a RecyclerView, we can actually use the same RecyclerView to show both sets of data. So of course, the question is how do we do that? Well, let's look at the way our application works now. When our application first starts up, we're showing the list of notes within the RecyclerView. And in order to do that, we had to create a LinearLayoutManager since we wanted the items shown as a simple list, and then we had the NoteRecyclerAdapter that could create our view instances and feed the data into the RecyclerView. Well, once we had these two things created, the way we display that content in the RecyclerView is we connected both the LayoutManager and the RecyclerAdapter up to the RecyclerView. Well, if we wanted to be able to display a list courses as well, what we can do is create the layout manager for the courses. Since we want our courses displayed in a grid format, we use a GridLayoutManager, and of course, we'll also need a RecyclerAdapter to manage the courses and the views for the courses. And once we have all that in place, when a user pulls out the navigation drawer and selects Courses, what we can do is replace the LinearLayoutManager and NoteRecyclerAdapter with a GridLayoutManager and the CourseRecyclerAdapter. When we do that, that RecyclerView will switch from showing the list of notes to showing the list of courses. Then if the user pulls out the navigation drawer again and this time they select Notes, we'll replace our GridLayoutManager and CourseRecyclerAdapter with our LinearLayoutManager and our NoteRecyclerAdapter, and again, the RecyclerView will switch back to showing our notes. So that's what we'll be doing with our application. So in our next clip, let's take a look at the NavigationView, and we'll see the role it plays in providing drawer-based navigation.

Understanding the NavigationView
As we've seen, there are various types that work together to present this experience of the navigation drawer. What we want to focus on now is our NavigationView because the NavigationView is really kind of the primary point of interaction of actually using the navigation drawer behavior. Now if we look in the navigation drawer, you can see we've got some layout area at the top that presents some information. Might use that for things like the currently logged in user or things like Gmail actually used that top area to show which email account you're currently working in if you have multiple accounts associated with your Gmail. All right, so it's just a great place to provide information. So that area at the top is actually a layout. So what happens is the NavigationView has a property, headerLayout, and we associate that with a layout resource, and that provides the layout appearance for that top area. But now the primary interaction point on a NavigationView are the selections, and those look very much like a menu, and in fact, there's actually a property menu that we associate with a menu resource to provide the options that show up there. Now if you look at the menu area of our NavigationView, we're actually taking advantage of a menu feature known as groups. And groups allow us to group our menu items. So at the top there, you see we actually have a group that is an unlabeled group, and at the bottom we have a group that's labeled as the Communicate group. And then each of the options in there are simply menu items that have a title and also have an icon associated with them. Since our NavigationView is using menus to display the options to the user, we simply have to handle those options when they make a selection. So in order to do that, we'll need to associate a listener with our NavigationView. We do that by using the NavigationView's setNavigationItemSelectedListener method. Now when we associate a listener with a NavigationView, we can do that in two ways. One way is we could simply use a lambda expression. So with a lambda expression, we can provide the implementation to the listener right there where we make the call, the setNavigationItemSelectedListener. Now the alternative is we can implement an interface, and then the class that implements that interface can be used as the listener. Now the interface that class would use is onNavigationItemSelectedListener, and that interface has one method, onNavigationItemSelected. And the interface is what Android Studio uses when it generates an activity that supports drawer-based navigation. Now no matter which type of a listener you use, when the user makes a selection, your listener is called, and the listener will receive a reference to a MenuItem, and that's the menu item that corresponds to the user's selection. So all we have to do inside of our listener is check the ItemId property of that MenuItem, and that will tell us which option the user has selected. And then from there, we simply implement our desired behavior. All right, so now in our next clip, let's head into Android Studio, and we'll start implementing our application's navigation behavior.

NavigationView Resources
Here we are in Android Studio, and what we want to do now is take a look at the various resources that are associated with our NavigationView. Now we're currently looking at the layout resource for our ItemsActivity, and that's the layout resource named activity_items. As you recall from the previous module, this is where we have our navigation drawer's NavigationView defined. So let's head over here to the Component Tree, and we'll select the nav_view. Now as we talked about, when we work with our NavigationView, we kind of work with two separate areas. We have the area at the top where we can provide status information, which is layout. And you'll notice that over in the Attributes window there's an attribute called headerLayout, and that points to the layout resource nav_header_items. But then remember the NavigationView also has a menu-like area, and that's the place where the user can make selections. So looking again at our Attributes window, we have the attribute named menu, and that points to our NavigationView's menu resource, which is named activity_items_drawer. So let's take a look at both of these resources. So let's head over to our Project window, and we have our layout resource nav_header_items. So let's go ahead and double-click on that. And when that opens up, you can see this is just a regular, old layout resource. In fact, if we look at the Component Tree, we can see it's composed of, first, a LinearLayout. Then under our LinearLayout, we have an imageView. That imageView is currently showing our Android image. And then it has the two TextViews. The first TextView contains the text Android Studio, and the other textView has an email address inside of it. Now, of course, you can do anything with this you want. This is just a regular layout resource, so any status information that's appropriate for your application can be shown in this layout resource. All right, that's it for our layout resource. In our next clip, let's take a look at our NavigationView's menu resource.

Modifying NavigationView Options
All right, so now let's take a look at the menu resource for our NavigationView. So again, back over in our Project window, let's head to the menu resource activity_items_drawer. We'll double-click on that. And if we look at the Component Tree for this menu resource, you might notice that it has a little bit more going on than we might commonly see when designing a simple options menu. And what we're doing here for the menu that's within our NavigationView is we're taking advantage of the menu's ability to use groupings, and we're using groupings in two different ways. If we look here to the top of the menu, we have one that's explicitly a group, and that group has four options underneath of it, nav_camera, nav_gallery, nav_slideshow, and nav_manage. So now let's head over to that group within the Component Tree. Let's go ahead and select it. So now let's look over in the Attribute window. Notice that the group has a checkableBehavior attribute, and it has its value set to single. Now what that means is that only one of the members within this group can be checked at a time. So from an application standpoint, what we're doing here is using this group to kind of indicate distinct modes within our navigation drawer. And we'll see how we can take advantage of that capability in our application shortly. But for now, let's head back over to our Component Tree. And notice that we have another grouping here labeled Communicate. Let's go ahead and select that. And then if we take a look over in the Attributes window, notice that this is just a menu item. We've given the menu item a title of Communicate, which causes that text to appear as the grouping header within our NavigationView, and then the options displayed underneath that header are created by having a menu underneath the Communicate menu item that then has additional menu items, which in this case are menu items with the IDs nav_share and nav_send. And what we're doing here in this case is indicating that these are actions that the user can perform. So the group at the top is used to select and to indicate a current display mode. The grouping below that, that we're actually creating as a menu item with a menu underneath it, is used to perform distinct actions, actions like sharing something to social media or sending something to another person. So now let's focus on the group at the top, and let's see how we can use that within our application. Now currently, our application only shows notes, but remember that each note has a course associated with it, so it'd be really cool if our app, in addition to showing the list of notes as it does now, could also show the list of courses. By including the list of courses within our app, we could then add course-related features like allowing the user to view all notes associated with a particular course. So this will give us a great use of our navigation drawer. We can allow users to indicate whether they'd like to have a list of notes displayed or a list of courses. So to do that, here under our menu group, let's cut this list down from four options to two. We'll have one for our notes and one for courses. So we'll start by removing the bottom two items since we don't need them. So let's select the item nav_slideshow. Then I'll hit the Delete key. Then I'll do the same here for nav_manage. And then what we'll do is change our first item, nav_camera. So I'll select that. Then over here in our Attributes window, I'll give it an id of nav_notes, and we'll make the title Notes. So we're all set with that menu item. So let's head back over to our Component Tree, we'll select nav_gallery, and we'll give it an id of nav_courses and a title of Courses. So now with that, our NavigationView will present the user with two display modes. When the user selects Notes, we can show the list of notes. When the user selects Courses, we can show the list of courses. So, all right. Now we're all set with our NavigationView selections. In our next clip, we'll start looking at how we can handle those selections.

Handling NavigationView Options
Here we are back in Android Studio, and what we want to do now is add the code to handle when the user makes a selection from within our NavigationView. Now we're currently looking the menu resource for our NavigationView, and as you recall, our NavigationView will display four options. The top two options are Notes and Courses, and those correspond to the IDs nav_notes and nav_courses respectively. Then our other two options are Share and Send, and those correspond to the IDs nav_share and nav_send respectively. So now we'll handle those options and the code for the activity that contains our NavigationView, and that's our activity class, ItemsActivity. So let's go up here and select ItemsActivity. So now remember this class was generated as an activity that contains a navigation drawer. And by doing that, Android Studio did all the work to allow us to handle the options within the navigation drawer. So one of the things it did is had our activity class implement the interface, OnNavigationItemSelectedListener, and then inside the onCreate method for the activity, it set the activity class as the listener for when the user makes a selection from the NavigationView. Now the interface, OnNavigationItemSelectedListener, has just a single method, so let's scroll down to that method implementation. So down here in our method onNavigationItemSelected, and this is the method that gets called any time the user makes a selection inside of our NavigationView. You can see when the user makes a selection we'll receive a reference to a MenuItem, so that tells us which menu item they selected, and then here inside of here we have a when clause where check the ID of that menu item. So it makes it really easy for us to know which option the user has selected. So now the generated code still contains all the original options from the menu resource that we're using, and we've changed a bunch of this. Remember the one thing we did is we got rid of the options nav_slideshow and nav_manage. Well since they're no longer in our menu resource, we don't need them here in our code. So I'll highlight those. I'll hit Delete to remove them. So those guys are gone. So now what we'll do is add in the options that we used for our notes and our courses. So the first one here, nav_camera, let's change that to nav_notes, and then here where we have nav_gallery, let's change that to nav_courses. So now our when clause has conditions for all the options contained within our NavigationView. So let's just add some simple code here to verify that we're handling the options correctly. So what we'll do here within our check for nav_notes, let's call a method we'll create called handleSelection. And let's just pass in the string, Notes, to indicate that we're handling our Notes option. Now to create that method, I can either go over and click on the light bulb, or I can simply press Alt+Enter. Let's choose Create function. I'll hit Enter. Let's change the name of our parameter from s to message. I'll hit Enter. We'll keep our parameter type as String, so hit Enter again. And then down inside here, let's just add the code to display a Snackbar, so I'll say Snackbar. make. Now in order to display a Snackbar, we need a reference to a view contained within the activity. Now it can be any view contained within the activity, so let's use our RecyclerView listItems. We'll display the message. And for the length of time, we use the Snackbar constant, LENGTH_LONG. So then that creates our Snackbar, and then to display it, we'll simply call show. So now when the user selects our Notes option, we should display a Snackbar with the text, Notes, inside of it. So let's do that same sort of thing for the other options. So to do that, we'll scroll back up to our onNavigationItemSelected method. And then here in onNavigationItemSelected, let's call handleSelection for each of the other three options. So now when we run our program, each time we select one of the navigation drawer options, we should display a Snackbar with the appropriate message. So let's go ahead and run this and verify that it works as we expect. So here we are with our app up and running. Let me go and expand the navigation drawer. Let's go down here to Notes, and we'll select that. Notice that we get our message showing Notes. Let's go back up and expand our navigation drawer. Let's go down to Courses. We'll choose that. It displays the message, Courses. Go back up to our navigation drawer, and we'll expand it. Let's go down here to Share. We'll select that. That shows the right message. And just for completeness, let's do it one more time. Go back up here to our navigation drawer, expand it, go down here to Send, we'll select that, and that displays the appropriate message. So we now have all of our NavigationViews set up, and fundamentally, that takes care of everything we need to do to give our app drawer-based navigation. But we really haven't yet provided our users with any sort of improved app experience. So in our next clip, we'll take the work we've done with our navigation drawer and combine that with the work we've done with our RecyclerView, and we'll begin the process of providing a richer app experience by giving our users the ability to switch between the list of notes and the list of courses.

Using Kotlin Lazy Properties
Here we are back in Android Studio, and what we want to do now is add the functionality to display either the list of notes or the list of courses in response to the user's NavigationView selection. Now as you recall, we're displaying both the list of notes and the list of courses within the same RecyclerView, so that, of course, is going to affect the way we set up our RecyclerView. So let's take a look at how we're doing it now. So let's go to our activity's onCreate method, and there here within onCreate, we associate the LinearLayoutManager and our NoteRecyclerAdapter with the ListView, and that, of course, is the layout manager and adapter we'll want to use when displaying notes. When we're displaying a list of courses, we'll be using a different layout manager and a different adapter. And since a user can switch back and forth between showing the notes and the courses, it probably makes sense to take this layout manager and adapter and promote them up to properties so we can simply reassign them to the RecyclerView whenever we need to. So let's go ahead and do that. So first we'll go here to our LinearLayoutManager, let's right-click, let's go over to Refactor, we'll choose Extract, we'll head over to Property, and then we'll go ahead and select Property. Android Studio is asking whether we want promote it to the class or to the file level. We want the class level, so we'll select that. And then it's asking us what we want to call the property, so let's call it our noteLayoutManager. Then we'll go ahead and hit Enter. So now our LinearLayoutManager is available through the property, noteLayoutManager, so now let's do the same thing with our NoteRecyclerAdapter. So let's head down there. Now this time, rather than using a right-click to promote it to a property, I'll use the keyboard shortcut Ctrl+Alt+F. Again, we want to put the property within the class, so I'll select the class, and we'll go and accept the default name noteRecyclerAdapter. So I'll hit Enter. So now we have our two properties, noteLayoutManager and noteRecyclerAdapter. Then, of course, the code that associates them with the RecyclerView is using the properties rather than creating the instances directly. So let's go ahead and run the code and just verify that everything still works correctly. And you'll notice the app never started. The app actually crashed in the process of starting up. So obviously, the change we just made has broken something. So let's head back to Android Studio and take a look at our Logcat. Let's see if we can see what's going on. So we're back in Android Studio looking at the output inside of Logcat. Notice that the exception we have is the IllegalStateException, and it tells us specifically what's happening. It says that a system service is not available before an activity's onCreate method is called. And if we look down here in our call stack, we can see the error occurred within our ItemsActivity, so let's click on that link, and let's see what line that is. So go here where it says ItemsActivity, line 21. We'll click on that. And notice that that's the line where we create our NoteRecyclerAdapter as part of our noteRecyclerAdapter property. Well, let's close our Logcat here, and let's just see what's going on. So now we're back here in our ItemsActivity class. Now, here within the onCreate method, that's where we actually do the work to associate our noteRecyclerAdapter with the RecyclerView. But remember, before we made the changes, we actually created the instance of the noteRecyclerAdapter as we were assigning it to the RecyclerView. Now with the noteRecyclerAdapter being a property, it gets created in the process of creating the activity instance itself, and that occurs before onCreate is called. And what we want to do is delay the creation of this noteRecyclerAdapter until onCreate is called. So, of course, the question is how do we do that? Well, it turns out that Kotlin gives us a solution for that. When we create a val property in Kotlin, we can actually create it as a lazy property. And what that means is the instance that's associated with that property won't get created until the property is used. So let's go ahead and change our noteRecyclerAdapter to be a lazy property. So the way we'll do that is we'll start out by changing the equal sign to instead be by lazy, and then we'll surround the creation of the NoteRecyclerAdapter with curly brackets. And then let's go and add a few line breaks just to make this a bit more readable. Now what this is saying is that I want to have a property, noteRecyclerAdapter, that returns back a reference to a NoteRecyclerAdapter, but I don't want it to create that instance until I actually use the property the first time. So that will delay the creation of the noteRecyclerAdapter instance, and that should take care of the problem that we encountered. Now one of the things that I like to do, any time I have a property within an activity that accepts a this reference, I like to always make it a lazy property. So just like I made our noteRecyclerAdapter a lazy property, I'm also going to make our noteLayoutManager a lazy property. So now both noteLayoutManager and noteRecyclerAdapter are both lazy properties. So I have the convenience of a property, but we delay creating the instance until we actually need it. So let's go ahead and run our code again, and let's see what things look like. And you'll notice that this time our app starts up fine. So by marking those properties as lazy, we delayed the instance creation until we needed it. All right, so now in our next clip, let's go ahead and implement the code to display our list of notes whenever the user selects the Notes option within our NavigationView.

Implementing Note List Navigation
Here we are back in Android Studio, and what we want to do now is implement the code to display the list of notes whenever the user selects our Notes option from the NavigationView. Now we're currently looking at the onCreate method of our ItemsActivity, and here within our onCreate method we already have code that displays the list of notes within our RecyclerView. Well, the same thing we doing here at app startup is what we're going to want to do any time the user selects Notes from our NavigationView. So I just take these two lines here where we associate our noteLayoutManager and noteRecyclerAdapter with the RecyclerView, and that's move those into a method. So I'll highlight these two lines. Let's go over here and right-click, choose Refactor, let's head over to Extract, then we'll head over to Function, and we'll select Function. Let's name our function, displayNotes. Our function doesn't take any parameters, so we'll go ahead and hit Enter to create it. So when we do that, we can see that Android Studio took those two lines of code, put them inside of a function named displayNotes, and then it calls displayNotes up here inside of our onCreate method. So all we need to do now is head down to the code that handles the note selection and call this displayNotes function. So we'll head down to our onNavigationItemSelected method, and then here inside of onNavigationItemSelected, we'll replace this call to handleSelection with our function displayNotes. So now with that in place, when our app first starts up, we'll display our list of notes, and also, whenever the user chooses Notes from the NavigationView, we can also display the list of notes. Now we can't really test out our NavigationView behavior until we add the code to display the list courses, but let's just go ahead and run our app, and let's just verify that everything looks as we expect it to. So we'll go ahead and launch the app. So our app's up and running, and it started up correctly, so that's good. So let's go and open up our NavigationView and see what that looks like. Now when the NavigationView opens up, everything looks okay, but remember that our app has two display modes. We can display the list of notes, or we can display the list of courses. But the NavigationView isn't currently giving the user any indication of which mode we're in. There's nothing that says whether we're showing notes or courses. Now notice what happens if I go down here to Notes and I select it. Now, of course, we continue to display the list notes because that's the only thing our app displays. Let's head back to the NavigationView and open that up, and notice that Notes is now highlighted. Because when the user made that selection, the NavigationView automatically made that the highlighted selection. Well, what we want to have happen is when the app first starts up, we'd also like to have Notes highlighted. So let's head back to our code, and let's see how we can do that. So now we're back here inside the displayNotes function of our ItemsActivity, and what we want to do is after we associate the layout manager and the adapter with the RecyclerView, we want to select the Notes option within the NavigationView. So to do that, we use the menu property of our nav_view. So that gives us access to the menu itself. Then what we want to do is use the findItem function, and what we want to find is the NavigationView menu option that corresponds to our note selection. And our note selection has the ID nav_notes, so we specify that with R. id. nav_notes. And then once we find that menu item, we set it to selected by setting its isChecked property to true. So now with that code in place, any time we call our displayNotes function, we'll make sure that our Notes option is selected within the NavigationView. So let's go ahead and run our app and verify that that is indeed the case. So now our app's up and running. We're correctly displaying our list of notes. Now let's go and expand our navigation drawer. And you notice when I do that, now Notes is selected. So our application is correctly selecting the Notes option whenever we display our list of notes. So now in our next clip, let's go and add the code that will allow us to display a list of courses in addition to displaying a list of notes.

Adding Course List Adapter and Layout
We're now ready to start adding the code to our application to display the list of courses, as well as the list of notes. But now before we get back in Android Studio, I just wanted to remind us the way we'll be displaying the courses within a RecyclerView. So now, as you can see, when we display our list of courses, we're going to have the courses arranged within a grid. So we're going to want to display them in the RecyclerView using a GridLayoutManager. So now in order to display the courses like this in our app, there's a few things we'll need to add to our project. We'll need to have a layout resource that we can use for the individual items, and of course, we'll need a RecyclerAdapter that can load up the courses and feed them in to our RecyclerView. Now I've provided those files for you in the before directory that goes with the exercises in this module, so let's go ahead and add those to our Android Studio project. So let's head back to Android Studio. So we're back here in Android Studio, and the way we'll add these files to our project is we'll simply copy them out of the file system and paste them into the appropriate folders inside of our Android Studio project. So we'll head over to the file system and open up the before directory for the exercises in this module. So the first thing we'll do is copy the layout resource, and that's the file item_course_list. So I'll right-click on that, head down to Copy, choose Copy, and we want to paste this into Android Studio. But before we do that, you want to look at your Project window and make sure you currently have it open in the Android view. As you can see, we're currently open in the Android view, so I'm going to head over here to the layout folder inside of Android Studio. I'm going to right-click on that folder. I'll head up to Paste. Choose Paste. Android Studio then prompts me to see if I want to change the filename, and I don't, so I'll just go ahead and hit Enter to keep the same filename. And then once I do that, if you look down below the layout folder, you can see we now have item_course_list as part of our project. So let me head down there, and I'll double-click on item_course_list. Let's go ahead and zoom that in so we can see a little better. And once we zoom that in, you see we have a TextView that we'll use to display the course title, and we have our ImageView that contains the icon. So that takes care of adding the layout to our project. The next thing we'll want to do is go ahead and bring in the RecyclerAdapter for our courses. So over in our Project window, let's scroll up a little bit. So now once we scroll up, we can see our package name along with all the source files in our project. We'll switch back over to the file system. Over here in our file system, we have our CourseRecyclerAdapter source file selected. I'm going to go ahead and copy it. This time I'll just do a Ctrl+C. We'll head back over to Android Studio. Here in Android Studio, I'll select the package name, and I'll just do a Ctrl+V to paste that file in. Again, Android Studio just confirms the filename. I'll hit Enter. And you can see now that our CourseRecyclerAdapter has been added to our project. So let me go down here and select that. We'll go ahead and collapse the Project window so we can see a little better. So now if we look at our CourseRecyclerAdapter, what we're doing should appear pretty familiar because it's basically the same sort of things we did in our NoteRecyclerAdapter. Notice that we inherit from the RecyclerView. Adapter class. Now in this case, rather than accepting a list of notes, our primary constructor accepts a list of courses. Then inside of our onCreateViewHolder method we inflate the item_course_list layout resource, which is the layout resource we just added to the project. Then down here in our onBindViewHolder method we set the course title values into the views so they can be displayed within our RecyclerView. Then we manage that in a ViewHolder class that holds a reference to the TextView that we'll be using to display the courses. Now again, this is the same sort of things we did earlier in the course when creating our NoteRecyclerAdapter. So if any of these things seem unfamiliar or you just don't remember the details of what we're going here, just head back and watch those modules again, and we'll walk through each of the individual steps that we had to follow to create our RecyclerAdapter. All right, so our project now has all the files that we need. So in our next clip, let's go ahead and finish the process of displaying the list of courses within our application.

Implementing Course List Navigation
Here we are back in Android Studio, and what we want to do now is add the code that will display our list of courses whenever the user selects the Courses option from our NavigationView. And in order to do that, the first thing we'll have to do is create the layout manager we'll be using to display the list of courses. Now just as we did with our notes, we'll do that through a lazy property. So let's declare a property named courseLayoutManager. Since we want this to be a lazy property, we'll say by lazy. We'll add curly braces, and then within the curly braces, we'll go ahead and create an instance of a GridLayoutManager. We'll pass in our activity's this reference as the context. And then remember that GridLayoutManagers accept a span, and we want this to display in two columns, so we'll give it a span value of 2. So that takes care of our layout manager, and we'll also need a RecyclerAdapter. So let's create a lazy property named courseRecyclerAdapter. We'll add our curly braces. And then inside of here, we'll create an instance of our CourseRecyclerAdapter. We'll pass in our activity's this reference for the context. We want to construct it with the courses from our DataManager. Now you see when we do that, our courses is highlighted in red, and that's because our CourseRecyclerAdapter is expecting a list. As you may recall from back in the first course in this series, when we put our courses in our DataManager, we did it as a hash map. Remember that back in that course, we talked about if wanted the values to available as a list, we could actually do that. We could use the values property from our courses, which gives us access to the values inside the hash map, and then we can simply call the toList method to convert it into a list. So with that, we now have lazy properties for both the LayoutManager and a RecyclerAdapter that we can use to display our courses. So now let's scroll down a bit, and we'll add the code to associate this LayoutManager and RecyclerAdapter with our ListView. So I've scrolled down here to where we have our displayNotes function, and that's the function that associates the layout manager and adapter for our notes. So just below this function, we'll add another function named displayCourses. And there's a few things we'll want do inside of this function. The first thing we'll want to do is set our RecyclerView's layoutManager to our courseLayoutManager, and then we'll set our RecyclerView's adapter to our courseRecyclerAdapter. So that'll take care of telling our RecyclerView to display our list of courses and to use the appropriate layout manager. So the last thing we'll do is set the NavigationView's menu item for our courses to checked. So now with that line in place, it assures that we always set our courses option to checked any time our displayCourses method is called. So now the last thing we need to do is call displayCourses when a user selects our Courses option. So let's scroll down a bit. So we're down here in our onNavigationItemSelected method, and inside of here, for the condition where the user selects Courses, we'll replace this call to handleSelection with displayCourses. And with that, we're all set. So let's go ahead and run our code and verify that it works as we expect. So now we have our app up and running displaying a list of notes. Let's expand our navigation drawer. Let's head down to Courses. I'll select that. And notice that when I do, my RecyclerView now displays the list of courses formatted just as I told it to. It's using the correct layout resource for the individual courses, and it's arranged them in a grid. Let's head over to the edge here. We'll pull our navigation drawer out. Let's head up to Notes, and we'll select that, and we again display our list of notes. And so with that, our app is doing everything just as we've asked it to. We have our navigation drawer that allows a user to choose whether they want to see a list of courses or a list of notes. When they make that selection, we simply change the layout manager and adapter associated with our RecyclerView, and our app then displays the correct information that corresponds to the user's selection.

Summary
To wrap up, here are some of the key things you want to remember from this module. As we saw, when we're implementing our navigation drawer behavior, we're going to make use of the NavigationView class. The NavigationView is really what serves as our navigation drawer. Remember that our NavigationView has a couple different areas on it. It has a layout area, so we can associate a layout resource with that to provide information, and it also has a menu area. Now we use that menu area to provide the options within the navigation drawer, and oftentimes we'll divide that menu area into groupings. There's a couple different ways we can provide groupings. As we saw, one way to do it is by using an actual menu group, and that allows us to have options that can have a selected state. So we often use that to indicate the display mode of our application. We can also have groupings by simply having a menu item that has a submenu under it, and in that case, we use the menu options that simply provide actions the user can perform. Now when it comes to handling the options within our NavigationView, we need to associate a listener with the NavigationView, and we do that with the setNavigationItemSelectedListener method. Now the listener can either be a lambda expression, or it can be an implementation of the interface onNavigationItemSelectedListener. And the code that Android Studio generates for us leverages this interface, so it'll do all of our navigation drawer option handling within the method for this interface. Now as part of working with our navigation drawer, we also learned about Kotlin lazy properties. Now, lazy is a mechanism we can use with val properties, in other words, assign-once properties. And by making a property lazy, we delay the property body execution until its first use. So rather than the value being determined when the property's declared, the value's determined the first time we use the property, but we still get the benefits of it being a val property because once that value's determined, it's remembered. So the body of the property is only executed on that first use. Every time after that, we're using the value that was determined at that time. All right, that wraps up this module. In our next module, we'll learn how to incorporate our RecyclerView and our navigation drawer into our app's automated user interface testing.

Testing RecyclerView and Drawer Navigation
Introduction
Welcome to our next module, Testing RecyclerView and Drawer Navigation. This is part of the Pluralsight course, Android Apps with Kotlin: RecyclerView and Navigation Drawer. My name is Jim Wilson. Throughout this module, we'll be looking how we can incorporate testing of our RecyclerView and drawer navigation into our automated user interface tests. So we'll start out with a quick review of the way automated user interface testing works, we'll then look at how we can form actions that involve drawer navigation, we'll look at how we can perform actions that involve our RecyclerView, and then we'll finish up by building an automated user interface test that incorporates interaction with both drawer navigation and RecyclerView.

Testing and Test Action Classes
As we go through this module, we'll be focusing on how we incorporate testing of our drawer navigation and our RecyclerView in performing automated user interface tests. Now our discussion assumes that you're already familiar with the basics of automated user interface testing. If that's not the case, don't worry. Just head back to another course in this series, Android Apps with Kotlin: Tools and Testing. And in that course, we'll walk you through all the basics of how you perform automated user interface testing with Android. Now let's just take a quick review of what's involved in automated user interface testing of our Android apps. Remember that Android Studio allows us to create something called instrumented tests, and these are tests that run on an emulator or physical device, and these are tests that have full access to the Android environment. Now one of the things we can do with instrumented tests is create automated user interface tests. And as the name implies, these are tests where we verify that our app behaves as expected in response to actions performed by the user. Now a key part of performing these automated user interface tests is the Espresso framework. It's a testing framework that allows us to interact with our user interface during the testing process. Now a central part of using the Expresso framework is the Espresso class's onView method. The onView method accepts a matcher, and that matcher allows us to specify criteria of a view that we want to match on. Could be something as simple as the view's ID, or it can be other characteristics of the view. And then what the onView method does is based on the matcher, it returns back a ViewInteraction. That ViewInteraction's associated with the view that matched the criteria, and then we can use that ViewInteraction to perform some action on that view. And it's these actions that require special handling when it comes to working with drawer navigation and RecyclerView because we have to use special classes to perform actions on these portions of our application. So let's look first at drawer navigation. We have a class, DrawerActions, and that has the actions that allow us to interact with a DrawerLayout. The main thing we use this class for is to open and close the drawer. And then we have our NavigationViewActions class, and this allows us to interact with a NavigationView. And the main thing we use this class for is performing the action of making a selection from within the NavigationView. And then finally, we have the RecyclerViewActions class, and as its name implies, it allows us to interact with our RecyclerView. So this gives us actions that we can perform on the RecyclerView itself, and it gives us actions that we can perform on the items within the RecyclerView. And we can perform these actions based on the item's position in the RecyclerView, as well as we have the ability to specify matching criteria to select the item within the RecyclerView that we want to interact with. So in our next clip, let's head over to Android Studio, and we'll start creating an automated user interface test that interacts with both our drawer navigation and our RecyclerView.

Setting up Our Test
Here we are in Android Studio, and what we want to do now is add an automated user interface test to our application that incorporates interaction with both our drawer navigation and our RecyclerView. So now the drawer navigation and the RecyclerView we want to interact with are both contained in our ItemsActivity, which I currently have open here in Android Studio. So now to create the test, we'll head up to the Navigate menu. I'll select that. We'll head down to Test, and then we'll select Test. Android Studio then confirms that we want to create a new test, and we do, so I'll hit Enter. Now we can name the test class anything we want. Let's go ahead and name it NavigationTest. And once I enter the class name, we'll go ahead and hit Enter. So next, Android Studio prompts for our destination directory. Now since this is an automated user interface test, we want to put it into our androidTest directory, so I'll go ahead and select that. And then that creates the stub for our class. Now let's go and add some opening and closing brackets to our class. So we've got our class there. Now we're going to need a number of imports in order to create the test, so I'll go ahead and add the imports that we commonly use when creating an automated user interface test. Now if these imports don't look familiar to you, I again encourage you to head back to the course, Android Apps with Kotlin: Tools and Testing, where we walk through each of these imports in detail. Now as part of creating our test class, we need to mark the class with the annotation RunWith, and we need to identify the class that will be used as our test runner, which is the AndroidJUnit4 class. Now within our class, we'll want to go ahead and provide a rule that will handle starting the activity that we want to test. Now we're going to start our test with the ItemsActivity, so let's create a property named itemsActivity. We'll set it to a new instance of ActivityTestRule, and we'll pass in the class information for our ItemsActivity. So that creates our ActivityTestRule, but for it to be visible to the JUnit testing system, we need to mark it with the @Rule annotation. And remember that by default, the test system won't be able to see this property because of differences in the way Kotlin represents properties versus the way Java represents fields, so we mark it with the @JvmField annotation. So that takes care of our test rule. Now, of course, we'll need a test function. So now the test we'll be creating will actually verify the behavior of our RecyclerView after the user makes a selection in our navigation drawer. We'll want to verify that when the user switches from viewing the courses to viewing the notes, they're making a selection, and our RecyclerView still behaves correctly. So let's go ahead and call our test function selectNoteAfterNavigationDrawerChange. Let's go ahead and give our function a body, and to make our function visible to the testing system, we'll need to mark it with the @Test annotation. So with that, we have everything we need in order to start creating an automated user interface test. So in our next clip, let's start adding the additional features we'll need to incorporate navigation drawer and RecyclerView testing.

Adding Test Dependencies
Here we are back in Android Studio, and what we want to do now is start incorporating the features into our test that will allow us to interact with both our drawer navigation and our RecyclerView. So the first thing we'll need to do is bring in some additional imports that will give us access to the types we need to perform these interactions. So let me go ahead and paste those in. So now we have the imports for our DrawerActions, NavigationViewActions, and our RecyclerViewActions. Now looking at this, there a couple things you'll notice as compared to the other imports. Now the first thing you'll probably notice is part of the package name is showing up in red, which means we're missing something to incorporate these imports, and we'll fix that in just a second. But before we get to that, let me just point out one other thing. If you look at the imports we already had in place, a number of them end in a. * after the class name. As you may recall, the reason that. * is there is it allows us to use the method names within those classes without having a class qualify them, which allows us to write our tests in a way that are just a little bit easier to read because we're not cluttering it up with a bunch of the same class names repeated over and over when we're calling the test methods. Now we could do that same thing with the imports that we've just added, but for the purposes of this demo, I'm not going to do that because I want to make it really clear which methods are coming from these special action classes. So just keep that in mind. When you're creating your own tests, you can put the. * if you don't want to class qualify the actions for our drawer navigation and our RecyclerView. All right, so now on to our bigger issue, the fact that part of the package name is showing up in red. And our problem is that we don't have all the dependencies that we need to access these classes. So now in order to add the necessary dependency, we'll head over to our Project window to our app's build. gradle file. We'll go ahead and select that. And then here in our build. gradle file, within our dependencies section, we want to add a dependency for our Android tests. So we'll add androidTestImplementation, and the dependency we'll want to add is part of the Espresso system, and it's espresso-contrib. So now that we have the expresso-contrib dependency added, let's head up top here, and we'll go ahead and sync our project. So that looks good. Let's head back over to our NavigationTest class. So now we're back here at our NavigationTest class. You'll notice that the imports for our DrawerActions, NavigationViewActions, and RecyclerViewActions no longer have part of the package name highlighted in red. So adding that dependency now gives us access to those types. So now we're ready to start adding some actual code to our test, and we'll start doing that in our next clip.

Automated Course Selection
Here we are back in Android Studio, and what we want to do now is start adding some code to our automated user interface test. Now our test code will go inside of our test function selectNoteAfterNavigationDrawerChange. But remember that our test class includes this ActivityTestRule, and that ActivityTestRule takes care of launching the activity we've identified there, ItemsActivity. So that means that by the time our test function starts running, that activity's already open, so our test code can just start interacting directly with the activity. Now our test wants to verify that when the user switches from viewing the courses to viewing the notes to make a selection within our RecyclerView works correctly. So in order to do this test, the first thing we'll have to do is switch our application from the notes view to the course view so we can then switch it back later on. So that means that we'll need to make a selection within our navigation drawer to switch to our course view. So to interact with our navigation drawer, the first thing we have to do is open it. So the way we'll do that is start by using the Espresso class's onView method. We need to identify the view we want to operate on, so that'll be our navigation drawer, which has the ID drawer_layout. So we use withId, passing in the ID for our drawer. We want to perform an action on that view, so we'll call the perform method. And remember, as we discussed, the actions for things like our navigation drawer require special action classes, so we're going to use our DrawerActions class, and the action we want to perform is an open. So that takes care of opening up our navigation drawer. But now once the navigation drawer is open, we want to make a selection, and that selection's going to need to interact with our NavigationView. So we'll again use the onView method. The view we want to interact with is the view with the ID nav_view. We again want to perform an action. The interaction is going to be with our NavigationView, so we're going to use our NavigationViewActions class. And we want to navigate to a particular selection within that NavigationView, so we use the navigateTo method. And the selection we want to navigate to is the selection with the ID nav_courses. So that should take care of selecting courses within our navigation drawer. So let's go and add some code here to now interact with one of the selections within a RecyclerView showing our courses. And what we'll do is we'll simply select the first course that's being displayed. So to start us out, let's just declare a variable named coursePosition. We'll give it a value of 0. And what we'll do is use that variable to select the first course being displayed within our RecyclerView. So we'll again use the onView method, and this time we'll pass in the ID of our RecyclerView, which is listItems. We want to perform an action on our RecyclerView, so we'll again call perform. Since we're interacting with our RecyclerView, we use the RecyclerViewActions class. And what we're going to want to do is select one of the items within the RecyclerView. So what that means is we want to perform an action on one of the items contained within the RecyclerView, so we use the actionOnItemAtPosition method. So now, this actionOnItemAtPosition method is going to actually interact with an item being displayed by the RecyclerView. Those items are managed by our CourseRecyclerAdapter class's ViewHolder class, so we need to specify a type parameter here, CourseRecyclerView. ViewHolder. So now actionOnItemAtPosition accepts as its first parameter the position of the item we want to interact with, so we'll pass in our coursePosition variable. So what's happened now at this point is that we've identified that we're interacting with a RecyclerView, and we've specified the position of the item within the RecyclerView we want to interact with. So now we want to specify the action we want to perform on that item, and all we want to do is select it, so we'll perform a click action. So now with all that in our test method, the first thing we'll do is open up our navigation drawer and select Courses from the navigation drawer. So that'll then cause our RecyclerView to display the list of courses, so we then interact with the RecyclerView to select the first item being displayed. So let's just verify that all this code we've added works as expected. So what I'll do here is head up to the green arrow to the left our test method name. I'll select that. I'll then select Run. Android Studio then prompts me as to where I want to run the test. I want to go ahead and run it on my emulator, so I'll hit Enter. We see that our test launches, opens the navigation drawer, switches the displaying list of courses, and then ends. And you can see there in the background that Android Studio says that all tests passed. So that shows us that that code ran without any errors. So our test is off to a good start. So now in our next clip, let's add the code to switch back to displaying the list of notes.

Automated Note Selection
Here we are back in Android Studio, and what we want to do now is add the code to our test method that will display the list of notes and make a selection. Now we've already added the code to our test that opens up the navigation drawer and selects the courses from the navigation drawer to display the list of courses. And so now as we add the code to display the list of notes, we're going to do very much the same thing that we've already done. So to make a selection from the navigation drawer, we'll again need to open the navigation drawer, so we'll again call the onView method identifying the view with the ID drawer_layout, and the action we want to perform is the DrawerActions class open action. Once the drawer is open, we're going to make our selection from our navigation view, so we'll call onView, passing the ID for nav_view. And the action we want to perform is to navigate to one of the selections within our NavigationView, and this time the selection I want to navigate to is nav_notes. So once we make that selection, our activity should now be displaying the list of notes within the RecyclerView, so let's again select the first note being displayed. So we'll declare a local variable named notePosition with a value of 0. We'll want to select that note from the RecyclerView, so we'll want to perform an action on the view with the ID listItems. So now to make the selection, we'll again use the RecyclerViewActions class's actionOnItemAtPosition. Now in this case, our RecyclerView is displaying a list of notes, so the ViewHolder that we're interacting with is the NoteRecyclerAdapter. ViewHolder class. And then for the position of the note, we'll pass in our notePosition variable. And I want to select that note, so we'll perform the click action. So with that, when we run our test, we'll first open up the navigation drawer, select Courses, tap on one of those courses, and then after that, we'll again open the navigation drawer, select Notes, and then select one of those notes. So let's go ahead and run this and see if everything behaves as we expect. So as you can see, when we run the test, we see the navigation drawer open, we see the list of courses, navigation drawer opens again, we see the list of notes, and then when we select one of those notes, that then opens up our note activity to display that note. So as we can see, when we run our test, everything behaves as we expect it to behave as we're watching the test. The thing is our test doesn't actually include any code to verify behavior. So in our next clip, let's add the code to verify that selecting a note from the RecyclerView behaves as expected.

Asserting That Correct Data Is Displayed
Here we are back in Android Studio, and what we want to do now is add the code to our test method that verifies that the application behaves as expected because everything we've done up to now has instigated behavior within the application. We first do the work to open up our navigation drawer to display the list of courses within our RecyclerView, and we select one of those courses. Then after that, we again open up the navigation drawer to display a list of notes and then select one of those notes. But there's nothing here that actually verifies that things behave as expected. And the key thing we want to verify here is that when we switch to displaying the list of notes and the user makes a selection of one of those notes, that the note that gets displayed is the correct note. In other words, are we displaying the note that the user selected? So now before we add the code to do that, let's take look at the layout for the activity that's used to display the notes, and that's our layout here, content_main. So we'll switch over to that. So we're here in our layout, content_main, and you can see that we have three views here. Now the first view is a spinner that allows the user to select what course a note is associated with, and then we have two TextViews, one for the Note title and one for the Note text. So in order for our test to verify appropriate behavior, once the user makes a selection, we want to look at the values in each of these views here to make sure that they're the correct values for the selected note. So let's head back over to our NavigationTest class and add the code to do that. So now we're back here in the test method of our NavigationTest class. So now in order to verify that the correct note is being displayed, the first thing we have to do is get a reference to the selected note. So let's declare a local variable here named note. Now remember that the code that makes a selection within a RecyclerView relies on this variable, notePosition, to identify the position of the note being selected. So let's use that notePosition variable to get that note at that position from our DataManager's notes collection. So now we have a reference to the note that corresponds to the note the user selected. So the first thing we'll do is use the onView method to interact with our spinner, which has an ID of spinnerCourses. We want to check a condition on that view, so we use the check method. Then we want to check that the displayed text matches the specific value. And what we want to check is that the displayed content contains the appropriate value for the title of the course associated with this note. So that takes care of testing that the appropriate course value is being displayed for the note. Now I want to check that the Note title is correct. So we want to do a check on the view that has the ID textNoteTitle, and we want to check that the value displayed corresponds to this note's title. And then the last thing we want to do is verify that the view that has an ID textNoteText contains the correct value for this note's text. So now with that, we have all the code in place to verify that the correct note is being displayed. So let's go ahead and run our test, and let's see what happens. So now as our test runs, we see all these selections and interaction happening as we expect them to, and if we look here in the background at Android Studio, we can see that our test has passed. So as you can see, by using these action classes, we can now build rich automated user interface tests that incorporate all the necessary user interactions with our navigation drawer and our RecyclerView.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that testing our drawer navigation and our RecyclerView is very consistent with other forms of UI testing that we perform. We rely on ViewInteractions to interact with the views, we locate our views by using matchers, and then we can perform actions on those views. But it's those actions that require special handling. We have the DrawerActions class that allows us to interact with the drawer layout, so it lets us open and close the drawer. We have the NavigationViewActions class, which allows us to make selections within the NavigationView. Then we have the RecyclerViewActions class that allows us to interact with the RecyclerView itself, as well as the items within the RecyclerView. All right. Well, in addition to being the end of this module, this is also the end of this course, but there's still a lot of great stuff to learn about developing Android apps with Kotlin. So as you continue building your skills, I'd encourage you to check out the next course in this series, Android Apps with Kotlin: ViewModel and Lifecycle. And in that course, you'll learn how to use some of the Android architectural components to simplify managing the data behind your activities by decoupling the data from the activity itself. But also, as much fun as it is to keep building your skills, it's also really important to make sure that you have the fundamentals down. So if you haven't already done so, there's some other courses I would encourage you to check out. We have Android Apps with Kotlin: Build Your First App, where we really go through the fundamentals of building Android apps using Kotlin. We have Android Apps with Kotlin: Tools and Testing, where we show you how to use Android Studio effectively when building Kotlin applications, as well as going into all the details of how we build automated testing for our Android apps, including unit testing and automated user interface testing. And then we have the course, Android Apps with Kotlin: Resources, Styles, and Themes. And there you'll learn how to work with the various types of resources within our Android applications, as well as learn how to use styles and themes to give your apps a customized appearance. All right, that's it for this course. Look forward to seeing you in the other courses in this series as you continue building your skills to build Android apps with Kotlin.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Intermediate
Rating
0 stars with 8 raters
My rating
null stars

Duration
2h 45m
Released
9 Nov 2018
Share course