Building Android Apps with Kotlin: Getting Started
by Alex Dunn

Dive into the language set to replace Java while building Android applications. This course will give you a foundation of both Kotlin and Android skills to allow you to build apps faster and cleaner than ever before.

Building Android apps has traditionally been bogged down by the limitations of Java. In this course, Building Android Apps with Kotlin: Getting Started, you will learn foundational knowledge of both Kotlin as a language and using it to build Android apps while building a real world app along the way. First, you will learn some of the basics that go into building Android apps while using Kotlin. Next, you will discover ways to access remote data over HTTP. Finally, you will explore how to store data locally on the device. When youâ€™re finished with this course, you will have the skills and knowledge of Android and Kotlin together needed to build better apps with cleaner code.

Course author
Author: Alex Dunn	
Alex Dunn
Alex Dunn leads the mobile development team at EF - Education First and is a Xamarin and Microsoft MVP. His background in mobile application development has leaned into enabling applications to do...

Course info
Level
Beginner
Rating
3.9 stars with 31 raters(31)
My rating
null stars

Duration
3h 44m
Released
22 Jan 2018
Share course

Course Overview
Course Overview
Hi everyone! My name's Alex Dunn, and welcome to my course on Building Android Apps with Kotlin: Getting Started. I'm an application architect and instructor that's shipped dozens of production mobile apps. I've received MVP awards from Xamarin and Microsoft for my involvement in the mobile app development community and can be found speaking at mobile development events all around Boston. The popularity of Android development is growing quickly, and since Google announced Kotlin's official support within the Android platform, development just got even easier. Kotlin's strengths alongside Android's flexibility give us an environment with fewer hassles and even more fun. This course is going to provide you with a foundation of both Android and Kotlin skills to bring to your own applications, as well as a real-world example app to reference. Some of the major topics we'll cover include the foundation of Android applications, using remote data over HTTP, storing data locally on the device, useful libraries and tools, and, of course, Kotlin as the language to write it all in. By the end of this course, you'll know how to build your own native Android apps from scratch using Kotlin instead of Java. But before beginning the course, you should be familiar with some basic object-oriented concepts with other languages like Java or C# or Ruby or really any others. But no prior knowledge of Android or Kotlin is required. I hope you'll join me on this journey to learn about both Android and Kotlin with the Building Android Apps with Kotlin: Getting Started course at Pluralsight.

Getting Started
Course Introduction
Hi! I'm Alex Dunn, and welcome to my course on getting started with building Android apps using Kotlin. In this course, we will explore the world of Android from a new perspective with a fresh new programming language. Together, we'll follow a real-world story and build a fully robust application that encompasses features that most real-world apps need for a foundation. This includes a beautiful UI built on Material Design, interfacing with external data through an API, local databases, and a data-drive UI. Now let's dive in and get things started. In this module on getting started, we'll take a look at what to expect from each module and how they come together to complete the course. We'll look at the types of Android development skills to take away and the requirements of the app we'll be building, along with the story we'll follow while doing so. We'll then move into setting up our development environment with Android Studio and Kotlin, look at the project types we can start with, and kick off our app's project before digging into some code.

What You'll Learn
Since the title of this course is Building Android Apps with Kotlin, there are two core concepts that we'll be digging into. The first is Android and the foundational pieces that all Android developers need to know regardless of the language being used to develop the application. This includes things like how pages are created and maintained, the lifecycle of applications and how to manage it, building the UI with different types of views, libraries that are specific to Android development, how resources are managed, and more. We'll also look at Kotlin on its own while drawing comparisons to other languages, especially Java. We'll dive deeper into some of the best parts of Kotlin like property getters and setters and how they allow us to write less code, how Kotlin plays with other Java libraries, tools provided by the Kotlin team, JetBrains and Google, that help us write more efficient code in our applications. For those who are completely new to Kotlin or perhaps haven't heard of it before, know you're not alone. Here's some basic information to understand about the history of Kotlin and what it is at a core level. Kotlin's a new programming language developed by a team at JetBrains that runs in the Java virtual machine. This means that it's not just the language for developing Android apps but can replace Java anywhere it was used before. It can also be compiled down to web language to replace the use of JavaScript on the client side of web development and even has some experimental uses for compiling to native code that can run outside the JVM completely. It was built to be more efficient than Java and allows developers to write less code that is way more useful. This saves both time and money during the development process. It's also interoperable with Java, which means you can use libraries built with Java in your Kotlin code and even use libraries written in Kotlin in your Java code. You could even write parts of your app in Kotlin and other parts in Java or C## depending on what is more comfortable during the development process. Kotlin was inspired by other object-oriented languages that people have come to love such as C#, Groovy, TypeScript, Java, and more. If you're familiar with any of those languages, you'll see that inspiration come through as we write more and more Kotlin code in our application. Lastly, as of Spring 2017, Kotlin is now an officially supported language by Google for Android development. They've moved forward with building out great tooling to help grow the language as a forerunner in building Android apps. Together, Kotlin and Android make for a great development process that, after this course, you'll come to see is the future of building Android apps and can save you time and headaches while building any app that comes your way. One of the best ways to learn is through building real-world examples to help put yourself in the mindset that you can follow after completing this course. Because of this, we'll be following a story of building an app that encompasses major components that most real-world apps utilize. This way, you'll have a fully built project that you can reference when developing your own applications in the future just as all of us developers do when working on new projects. So with each of these modules that come together to complete the entire course, you can expect to be introduced to new Android and Kotlin concepts and building blocks that you may or may not be familiar with. We'll then look at examples of how these concepts are implemented and different ways developers have approached these problems, along with helpful libraries from Google, JetBrains, and other third parties to help solve these problems even more easily. Finally, we'll move back to our project and implement these concepts using some of the approaches mentioned before. These ultimately help us get closer to a complete and usable application.

The App
Without further ado, let's jump into our story and get things started with building Android apps using Kotlin. You as an Android developer have been reached out by none other than Wikipedia. They're looking to rebuild their Android app using the latest technologies and have asked for your help in doing so. They're interested in seeing what the power of Kotlin has in their Android app and want to see it built from scratch using the latest languages and tools. They sent over a set of basic requirements the app must fulfil and some basic wireframes of each of the separate pages within the app. Outside of this, you're allowed to take your own creative direction and influences to build a really cool app. Here are the basic requirements from Wikipedia. The app needs to allow users to explore random Wiki pages to ensure they see new content that they may find interesting. They should be able to search articles and view the results, track the history of the articles they viewed, and clear that history to start fresh, and, lastly, toggle certain Wiki pages and articles as favorites to enable them to see the pages offline. Now let's see the wireframes for each of the pages to see how Wikipedia would like you to build their application. The first page is the Explore page, and this is where users will land when they open the app. There are a few key requirements for this page. It needs to have a search bar that opens to the search page when selected. A scrolling list of cards for random articles that allows the user to pull and refresh the list with new random articles. It needs to have tabs to allow users to access this page along with the history and favorites page. And tapping on an article card should go to the detail page of the article. The next major page is the History page. This page will also have a scrolling list of pages, but this will be more with a thumbnail and list view, the same tabs as the Explore page to view Explore, History, and Favorites, a "clear" button in the toolbar, which will delete the user's history, and a confirmation dialog that needs to show to allow the users to ensure they want to delete their history before performing the action. Now we have the Favorites page, which has similar cards to what we saw on the Explore page. This page should also have the same set of tabs and should have a list of Wiki pages that were favorited by the user. The first of the secondary pages is the Search page. This page should have a search bar in the toolbar that shows the results of the search request as a list of articles with their thumbnails. The toolbar should also have a Back button to go back to the Explore page. The last page to build is the Detail page. This is the viewing page where users can read the articles and Wiki pages they've selected. The toolbar title should change to the title of the article being presented. There should also be a toolbar button to allow the user to add or remove the page from their favorites and also give them a Back button to go back where they came from.

Creating Approach
Now that we know what we have to build, let's set up an approach to how we can build our application. We'll first build out our base views and pages. While we do this, we'll learn about Android activities, fragments, views, and how they all play together. We'll look at some of the controls available to us and build out the pages we just saw and how we can organize them all together to create a user-friendly and appealing interface built on the latest from Google's Material Design. We'll then move to interacting with the API from Wikipedia in order to query for pages. We'll learn how to build HTTP requests, parse JSON data sent down from the API, and look at some popular approaches and libraries that give us the data access we need. We'll also look at how to handle accessing data asynchronously and some ways that Kotlin in particular makes this easier for us. We'll next build our local data layer to allow us to store Wiki pages locally on the device. We'll implement a SQLite database and look at some of the options we have to do so. We'll look to the Kotlin team and libraries they've built, such as Anko, to make our lives easier when implementing local databases and making a request to it asynchronously so we don't block the UI when accessing our SQLite database. Lastly, we'll tie all these pieces together and bring our API and local data into our user interface. Combining all four of these major pieces to our approach will give us an easy-to-follow process while building our first Android app with Kotlin.

Setting up the Environment
Now let's get started and set up our environment. We'll need to install Android Studio 3. 0, which contains all the new tooling for Kotlin development. We'll need to enable Kotlin development in our project creation and create our new Wikipedia app project. The first thing we'll need to do to get our development environment set up is to install Android Studio 3. 0. As of fall 2017, this is still in beta, but it is required to have all the newest Kotlin tooling built in to the editor. We can go to the Android developer downloads portal and download the latest beta. Clicking the Download button will kick things off. Make sure to accept the terms and download the installer for either Mac or Windows. Since the installation process varies so much between Mac, Windows, and Linux, I'll lead you to the documentation from the Android developer portal on how to install Android Studio 3. 0 preview or any preview version of Android studio, especially if you're installing alongside the stable version of Android Studio or have the Android SDK and NDK installed through some other program like using Xamarin, React Native, or some other form of cross-platform development, which will already have it installed. The most important thing to remember is to not reinstall the Android SDK when installing your version of Android Studio because having two will cause problems with your individual SDK installations, your emulators, and everything else that comes with the Android SDK. So once you have it installed, you'll see this little preview window here. We can go ahead and click on Start a new Android Studio project since we're going to be starting from scratch with our new Wikipedia app. Now we can go ahead and fill out the fields required to kick off our application. The important things are the application name, the domain name from the company, the project location where we're going to be keeping all our files, and the most importantly to include Kotlin support. This is required in order to enable Kotlin support through the development of our application and enable all the tooling that's going to help make our lives easier when creating Kotlin files rather than Java. Now let's fill out the rest of our other fields for our application name, company name, and select our location. We can hit Next, and now we can see all the different targeted Android device options that we can have. We're not going to be targeting Android Wear, TV, Android Auto, or Android Things for our Internet of Things. Instead, we're going to simply select Phone and Tablet and select a reasonable minimum version to be supported. In this case, I'll just select 5. 0, Android Lollipop, which is where Material Design started its implementation. Don't worry about selecting any particular minimum version since we're going to be using libraries to help us with backwards compatibility. You can also use the Help me choose option, which will open up a diagram to explain the different distribution percentages of each of the android operating system versions. Let's leave it at 5. 0 or Android Lollipop and click Next. Here we get different templates that we can start with built in to Android Studio. We can start with a basic activity, an activity with a bottom navigation, an empty activity, a fullscreen activity, ads, maps, a login activity, a master/detail flow, a navigation drawer, a scrolling activity, a settings activity, and a tabbed activity. Each of these is going to start us off with an implementation of a specific activity that's the start of the application. This is also going to be having the back-end written in Kotlin rather than Java. We can start with No Activity and do everything from scratch. This will allow us to learn everything and how the process works together rather than starting with a template. However, if you want to get started faster, I would suggest starting with either Basic Activity, Empty Activity, or the Bottom Navigation Activity since our wireframes from the Wikipedia specify that we'll need bottom tabs to move between our Explore page, History page, and Favorites page. We'll select No Activity and do everything from scratch. Now we wait for the installer to get everything started, install the proper SDK versions, and unzip the build tools that we need to start running our application. Let's move ahead to when the installation is finished. We can click Finish. And now Android Studio will open up our new application. Now that our application's project has been created, let's take a look at what we start with. We have our Gradle scripts, which include the build properties and settings that we need to install and run our application. This will include dependencies and especially include the Kotlin dependencies we need in order to run it at runtime. You'll see that we'll have the classpath in our dependencies to org. jetbrains. kotlin with the Gradle plugin for Kotlin. Now let's open up our source code and see what we have. We have our actual application here and our source code. You can see that we still have the path named java even though we're using Kotlin. This is because all source code regardless of language goes under the java subfolder. We don't start with any Kotlin files with the Empty Activity or No Activity setting in our installation. However, if you did run with an existing template, this is where you'd see your code that starts off the application. We also have our resources folder, which includes some drawables and mipmaps for our launcher icon, which is the application icon we see in the base operating system. We also have some XML values here for different colors, strings, and styles. We get into those later when we talk more about Android resources. The other more important thing we have is the manifest file. This is what defines our application and allows us to add activities that are registered to the application so that we can process and run them. We also get a test folder, which includes example unit tests using Kotlin. We won't dive in much into unit testing in this course. However, there are other courses on using unit testing in Android development that might help if you're interested in learning about unit tests. If we collapse our folders back to the root, we'll see that we have some other folders such as the build folder, which has nothing used other than a text file for version information, a gradle folder, which has some of the properties we need in order to use Gradle for builds, the. idea folder for the editor, and the. gradle folder for running Gradle builds. We won't be needing these in particular, and all of the files we'll be needing will be under the app folder here including the resources folder and the java folder. You'll notice that we won't be able to run our application yet or make it. Since we don't have any files that go into the source code, we're going to have a failed build.

Module Summary
Now at the end of this module, we're reviewed what to expect to get out of the entire course, learned about the application we'll be building, and the requirements the app must fulfil, created our approach to complete our entire application, and set up our development environment with Android Studio leading to our project creation with Kotlin support. In the next module, we'll learn about how Android handles user interfaces, the different components that come together to complete an Android application at a basic level, and some of the unique underlying pieces that make up the app lifecycle with how Android handles it from the operating system.

Creating and Managing Views and Activities
Module Overview
Welcome to the next module on building Android apps with Kotlin, Creating and Managing Views and Activities. I'm Alex Dunn, and I'll be leading you through your mission to build a great new Android app for Wikipedia using the latest tools and technology. In this module, we'll take a quick step back to go over some of the basics of how Android handles applications and expand on how to build user interfaces. We'll talk about what goes into building an Android app and all of the different components that end up coming together, Android activities and how they work together, the lifecycle of an Android activity, using components that are available to us either out of the box or from one of Google's Android support libraries to complete our UI, how Android handles resources such as images, layouts, styles, and more, and then we'll take the lessons learned and start applying them to our Wikipedia application all while looking at some of the ways Kotlin in particular makes our lives easier when building out our activities and views.

What Goes into an Android App?
Let's start with talking about the different bits and pieces that come together to complete an Android app, the first of which is what we'll be focusing on in this module and the next. We'll add some activities to our application to represent each of the major interactable pieces. These will represent the different pages we received from Wikipedia, or most of them anyway. They wire up our UI logic and manipulate views and data while interfacing with other services. This is where the magic happens. We'll then build up the interfaces for each of these activities using the latest views and components available to us. These are our actual interface elements, our cards, toolbars, layouts, text views, images, inputs, etc. The last bit to mix in are Android fragments. These are somewhere in between activities and views, and we'll dive much deeper into them in the next module. Together, these make up the Android application interface, one of the three major pieces that complete an app. The next of the three major pieces of an Android app is the guts, or the behind-the-scenes bits that aren't necessarily apparent to our users. The first of the important pieces of the guts is remote data. This is where our data comes from that isn't stored right away on the device including web APIs, integration to third-party data providers, push notifications, web socket connections, or any other source of data outside the app. The second component of our Android app's guts is local data. Local data is what we store locally on the device such as pre-existing data files, local databases to store information we receive from remote data sources, and locally created and stored files. The last bit is the business logic. This is what ties all of it together. This is how we map remote data to local data, handle what should happen after an action from the user, update views with data from either remote or local sources, and direct traffic based on events. The third of the three categories is the extras or the pieces of the app that aren't necessarily required. Hardware integrations are, well, integrations with hardware components on the device such as the camera, gyroscope, GPS, speakers, and microphones. These integrations often connect back to the guts of the app down to the interface to show or use the data collected from these hardware components. Background services are different ways that our app can still process data in the background. These services can include syncing data in the background, handling notifications, maintaining a connection to the camera or microphone, or communicating through other applications. The last piece of these extras are Android widgets and more. Widgets are a rather unique feature to Android and allow for an application to have a small interface or feature directly built in to the app via the home page, settings, or other area depending on the Android version. This is where extra features such as communication to Google Chromecast, Android Wearables, and Android TV would exist if your application intends on working with any of these. These three categories--the interface, the guts, and the extras--work together to complete a running Android mobile application. When these come together, we can create something that is beautiful, feature rich, and fun to use.

Android Activities
So now we know what goes into an Android app, let's start diving deeper. We'll start to talk about Android activities, learn a bit about them, and think about how they'll fit in our app before we jump over to Android Studio and start adding them when we begin to build out our interface. No better way to answer the question of, What is an activity?, than to jump to the Android documentation. An Android activity serves as the entry point for an app's interaction with the user, providing the window in which the app draws the UI. Now you might be thinking, Alex, didn't you just say you were going to create an activity for each one of our pages? But this says it's the app's entry point for the window. This definition does make it sound like an activity represents an entire application, but that isn't really true. We do have access to an application class that wraps the lifecycle of the entire app. However, activities are also not simply pages as we might use them as so often. They can act as an entire application, and there is even a design pattern for building Android applications that uses a single activity and uses fragments to handle the idea of pages. We'll talk more about how this is possible in the next module on fragments. But for the sake of this application, we will use activities more often and allow for the communication between multiple activities. In the end, we'll have a bit of a blend of fragments and activities to fulfil our application page requirement. We can break down a very basic activity structure in Android as the starting point for the window of our application. This activity is then filled with views that complete the user interface we see on our device. These views enable the user to interact with our application. In a more advanced situation, we can use some more complex controls such as toolbars and tabs. These views still lie within the activity and can be paired with a combination of views, fragments, and views within those fragments. Activities have a very thorough lifecycle. This lifecycle allows us as developers to tie in custom logic, wire-up, or backup during the events in the cycle. These events have accompanied functions that we can override in our custom activity classes within our Kotlin code base. The first event is the creation of the activity or the onCreate function in Kotlin. After being created, the activity then starts via the onStart function. The activity resumes with the onResume function at which point it is running. This means that users are actively interacting with the UI of our activity and using our application within this current activity. When the user is done with the activity, whether going back to a previous one or invoking an action that starts a new one, the current activity is then paused. This is done via the onPause function. From here, the state of the activity can actually go in two directions. If the user goes back to the activity, it will go through the onResume function and begin running again. Alternatively, the user can continue after the app has been paused such as going back to the previous activity or, if they left the activity, to go to a different application. At this point, the onStop function is called. This stops the activity. The stop state can again go in two directions. If the user comes back to the activity such as going back to your application after leaving to another application or the home page of the phone, the onRestart function is called. This onRestart kicks the chain of events back to the onStart function and so on until the app is running again. Now, on the other hand, if the user does not go back, and the operating system decides to clean up memory, or if the user closes your app from the switcher, the activity will be kicked over to the onDestroy function. This is the last chance to execute any code before the activity is dead for good. This lifecycle diagram might seem a little confusing, so let's see a quick visual example. Let's say the user is using your app and is currently in one of two activities. When the user clicks on a view, the code of your application starts Activity 2. When this happens, Activity 1 pauses, and Activity 2 is then created. Activity 2 starts, which then moves to resume. And at this point, it's running. Now when we go back via the Back button or some other means, Activity 2 is paused, then stopped, while Activity 1 resumes from being paused and is the act of running the activity again. Now when the Android operating system needs to clean up memory, our second activity is destroyed, at which point it is dead. Here's a simple example of what an activity looks like in Kotlin with each of the overrides of the lifecycle functions. For the first time in this course, we can look at some actual Kotlin code, even something as simple as this. Already we see some great advantages that Kotlin gives us. We don't need to define a constructor or the base constructor of the base class we inherit from. We can pass in nullable parameters in the functions and safely handle null checks or not require them. We have more readable function overrides, and we don't even have to define a return type if it is void as each of these functions are.

Android Views
We'll take a really deep look into the activities in Kotlin once we get into our demo. For now, let's talk about Android views. Let's look at the smallest component that makes up the interface of our app including controls from the most basic of buttons to the most complex of adapter-driven recycler views. UI components are broken into two main categories, the first of which are views, the things that we've been talking about this whole time. The basic definition of a view is a simple UI component with a collection of properties and functions. These views can live next to any other view but cannot have child views. Then we have ViewGroups. These inherit from views in that they also are UI components with properties and functions, but they also contain child views from one to any number of them. They can be used for layouts or for creating more complex functional controls from a collection of simpler views. We can logically break views into three categories, the first of which are layouts. They allow for structuring collections of views in different ways, whether they're stacked, grid, relative, or changed depending on the orientation of the device. The second are basic components. These are used for displaying content and receiving user input. You can think of basic components as elements in a form or in a detail view. The third are structural and advanced components. These help provide advanced and interesting user experiences, help structure the flow of the application, and enable complex features by combining other simpler views and layouts into one comprehensive control. Android ships with a number of layouts we can use, and there are more that are provided by the Android support libraries and from the community. From Android we get a linear layout that stacks child views either vertically or horizontally, a relative layout that allows for child views to be positioned relative to other child views or the parent layout, a frame layout that positions children absolutely based on their width, height, margin, etc., and a grid layout that puts views in rows and columns. We also get some unique layouts from Android support such as the coordinator layout that is similar to the frame layout but allows for child views to attach behaviors based on events within the layout, or the constraint layout that is similar to the relative layout but makes it easier to position elements in the designer view. We also have access to a large number of basic components. To name a few common use control types, we have edit text for user inputs, text views for rendering text and styling it, buttons, switches for handling bool values, pickers for different selectable options, dates, and times, and image views for rendering images within them. Structural components that are built on other simpler views or layouts are pretty cool. They have some unique features and make it easy for developers to unlock complicated functionality more easily. Some examples include toolbars and action bars, along with all the different controls within them, tab layouts and tab bars for organizing changes in content from tabs, the new bottom navigation view, which is similar to tabs, a navigation drawer, aka the flyout menu, and a scroll view for allowing our content to scroll in any direction. Lastly, we have the advanced and unique controls. These also have some interesting functionality but aren't necessarily used for structuring the app as the previous controls are used for. Most of these views come from Material Design and the new set of controls Google created to fulfil the need to meet design standards. These include things like Toast and the new Material Design Snackbar, the floating action button, bottom sheets, expansion panels outside of the toolbar overflow menus, custom dialogs, and, finally, lists, grids, and recycler views. List, grids, and recyclers are also considered layouts due to the fact that they control the layout of other child views. However, they use adapters and view holding with recycling to render large amounts of content in an efficient manner. Android handles views in two primary ways. First is with Android project resources. Resources include a slew of different types of files that we'll talk about shortly. These include the XML files that represent the markup of our views. We will also use our code to interact with the views. This allows us to reference the XML layout resources, as well as create new views and source code to manipulate within an activity or a fragment. We'll be doing plenty of this in our app using Kotlin. Here's an example of an extremely simple Android XML layout resource. It represents a single coordinator layout mentioned earlier with a TextView and a BottomNavigationView. Each of these views contain a number of properties in order to position them properly in our UI. The only two require properties in a view are layout_width and layout_height. The rest of these represent extra information to help with positioning, styling, and more. This may seem like a lot of text to create such an incredibly simple view, and you're right. Luckily, we have some awesome tooling within Android Studio to make our lives easier. We can use the designer view of our layout file to see a number of different windows that help us better create our interface. We have a toolbox on the top left to allow us to drag new controls into the view, a hierarchy of views just below that to allow us to select a certain view more easily, as well as visualize the parent/child relationship of all our views together. We also have the main Design view that allows us to move around selected controls and see information about them, and a window to the right, which shows all the properties of the view we have selected. We can also edit these properties right here on the right. There are some other great features to this view that we'll be able to showcase during our demo such as switching themes, rotating the phone, showing or hiding the blueprint, changing the type of phone, screen size, and more. Now that we've designed our view in either the XML editor or the designer view, we need to be able to use our views to update and manipulate them. This is where we write our Kotlin code within our activities, fragments, or other areas that reference our views. In this example, we're in an activity, and we want to set the text of our TextView to Hello world. In Kotlin, we override the onCreate, call setContentView to reference the XML layout resource we created, then get the auto-mapped message TextView and set the text property. This seems intuitive, but there is a lot going on under the hood of Kotlin that is secretly making our lives so much easier, for example, auto-mapping the TextView by its ID in the XML to a property on our activity, as well as mapping the Java setText function to a property that is set upon the TextView class. Let's take a look at the exact same thing but in regular old Java. We have to manually get a reference to the TextView and set it to a local variable by using the findViewById function with an explicit cast. We then have to call the setText function and pass in the Hello world string.

Android Resources
Let's talk quickly about Android resources. We'll look at them more as we use them in our Wikipedia app. Resources are part of our app where we put a number of different assets that need to be referenced by our code. When files are added to the resource folder in a particular supported subfolder, they will get mapped to the R class in Java. This auto-generates an integer ID that we can use in our Kotlin code to get references to different resources. Some of the most commonly used resource types include layouts, drawables, which are images and other XML resources to define how to draw different patterns, menu lists, styles and themes, raw files such as audio or video files, animations, fonts, color lists, strings, other values, and more.

Demo - Creating Activities
Now that we've done some learning about how Android apps work, activities, views, and resources, it's time to get back to our Wikipedia project and start creating some of these activities and views. We've seen some of the ways Kotlin makes this process easy, but in our demo, we'll be highlighting this even more. Let's start by creating our different activities using Kotlin, then create the layout files for each activity, and register our activities in the manifest so Android knows how to start them. We'll create views within our layout files, and, of course, we'll run our app. Let's move over to Android Studio and get things started. So now over in Android Studio, what we're going to do first before adding any sort of activities or views to our files is dig through our resources and very specifically take a look at our styles. And one thing we're going to add is a substyle to our AppTheme here, and we're going to name that AppTheme. NoActionBar. This is because we're not going to be using the Android action bar in our application. Rather, we'll be using the new toolbar view provided by the Android support libraries. So let's go ahead and set some properties here. And what we're first going to do is add the windowNoTitle equals true. And this will remove the default title that creates the action bar, and then we're going to add another name, which is windowActionBar, and set that to false. So these two properties here are telling the Android system that when we have this theme, we want to have no action bar and no title. So now that we have our main theme open, we can take a look at some of the other options for creating themes, although we won't really need to dig into it here. But you can see we can open our editor, and we get access to all sorts of themes for the different types of views that we have. So we can pick a theme, and we'll pick the AppTheme. NoActionBar. And you can see that we're able to basically pick and choose different control themes that we want to be able to make changes to for the base of our application. So we can update properties on the right, view what the changes look like on the left, and actually edit some of these properties here, which is pretty neat. So we have our theme set up. Let's start creating our activities. We're going to need to create our very first MainActivity of our application. The first thing we're going to do is create a new package underneath our primary Java package and call this our activities. This is where we're going to put all of our activities that we create. So let's go ahead and hover over New. And in Android Studio, we can see that there're a whole bunch of different options we have to add a new file. We can add a Java or Kotlin file class right away, add a resource file, basically some of these raw ones, C++ files, image assets, etc. But what we're going to focus on here are these bottom options that expand with even more involved templates. So we can go ahead and pick from any of the default templates provided or go over to the Android Gallery where we can look at third-party and other Google ones in order to pre-create and pre-populate a lot of the necessary wire-up for creating an activity. Since our MainActivity is going to house our Explore view, our History view, and our Favorites view with that bottom bar for tabs, we should consider using the bottom navigation activity to create our basic MainActivity. So here we'll be able to fill out fields to name it, apply a name to the layout file that's going to be created with it, give it a hierarchical parent, which we won't need since this is going to be the initial activity in our application, pick the package name where it's going to be, and that's going to be our activities folder, and then also select the source language. So we're going to make sure that this is Kotlin, not Java. So we can go ahead and hit Finish here. And we might see a pop-up dialog that we already have some images added. We can go ahead and proceed anyway. And from here, we get a sync progress started due to our build starting from adding a new class. And we also get this nice little opening up to that layout file that was created. So this is an Android layout resource file, and this is the design view we saw earlier. From here, we can see that we have some views for our tabs at the bottom, our bottom navigation view, and the text that's going to be changing here. So our Gradle sync has finished. Let's go over and look at what the code created that was output. We can hop over to our MainActivity, and we might see some errors here. We're going to see some red text over our R file or our R reference more than likely, and we'll see some populated little dialog that shows up here where Android Studio detects that, Hey, this is probably the R class from your generated project file. Do you want to add that? So we're going to hit Alt+Enter and add a reference, so you can see that it imported what we needed. So we're going to be using that command quite frequently as we add references to different classes through our code. Make sure you save. And then the last thing we're going to do is go over to the AndroidManifest, and you can see that it added this activity property here. This is where we're going to be registering our activities in order to make them usable within our application. This is where Android has them registered so it knows where to find them. When we try to move to them and start them and to kick off the lifecycle within the Android operating system. However, there're two things we need to add here. We're going to need to create an intent-filter here, which is going to say that this MainActivity is the launcher for our application. So we do that by adding an intent-filter. And we'll use a lot of the auto-complete here as we go through it. We'll add an action and give it the name android. intent. action. MAIN. And you might see that pop up in the auto-complete right away. Self-close that, and there's one more thing we need to add, which is the category with the name of android. intent. category. LAUNCHER. So these two properties together tell the Android operating system by reading our manifest that this activity, our MainActivity, is the MAIN action for opening our application, and it has a LAUNCHER intent. So now that we have that, we can go ahead and run our application by clicking the Run button. And from here, we'll be able to see our different Android emulators that we can see or physical devices if you have any plugged in. If you don't have any virtual devices or Android emulators, you can click this Create New Virtual Device here. This will bring you through a dialog that is pretty simple and easy to follow to help you create your Android emulators to fit the needs that you have. We're going to pick one that we've already created previously called the Android Accelerated x86, which is using the HAXM hardware accelerated virtualization so that we can have a faster, more efficient emulator. We can click OK and start running. So now in our application that's running in the emulator, we can see we do still have that default Android action bar, and this is because we didn't take the new theme we created and apply it to our application. We'll do that when we go back and add more activities and give them their themes. And also see that we have our bottom navigation view and that selecting different items changes the main text. This is a good start, but we're going to take a deeper dive next module when we talk about fragments and using a FragmentManager to change this active view and use the proper fading animations that best fit Material Design. So now that we've been able to use the great tooling from Android Studio to create our activity, let's do one from scratch. The next activity we'll need to create is the Detail activity. This activity is going to represent our Detail page for our Wikipedia articles. Rather than going through and clicking the Add Activity and picking one that best makes sense, we're going to go ahead and start with just the raw activity file. We're going to start with creating a Kotlin class. We'll call this ArticleDetailActivity. From here, you can pick the different type of file that you want to start with a basic template. In this case, we'll pick Class since we're creating an activity class. Hit OK, and this is our basic template here with a pre-existing comment with the author and date. Now what we need to do is add some inheritance and have our activity inherit from the AppCompatActivity just like our MainActivity was doing from the template. This AppCompatActivity inherits from the Android activity with some extra features for backwards compatibility. We do that by using the colon and then start typing in our class name and see some auto-complete. You see that it automatically brought in our namespace. However, we do need to declare which constructor is going to be used to initialize it. In this case, we'll use the default constructor, which takes no parameters. The next thing we'll need to do is create a layout file. Over on the left side under the resource layouts, select New, Layout Resource File. We're going to follow the same naming convention created by the template, and we'll call this activity_article_detail. In this case, we'll just pick a LinearLayout. We'll select the main source set since this is where our code exists, and the directory name within resources is going to be layout since this is a layout file. We'll skip any of the additional qualifiers since we don't need these particular fields. Click OK, and this will open up the Design view again. Our article Detail page is going to need a web view. We can do this via text or via the designer. In this case, we're actually going to be stripping out the LinearLayout base and go with more of a FrameLayout. Since we're only going to be using a web view, we don't need to have LinearLayout stack child views since we're only going to have one child view. From here, we can do this manually since we're going through this whole process manually. And we can get the auto-complete to add a WebView. Again, we'll need to automatically set the layout_width and _height to match_parent, and we should also give this an ID so it's easier to reference in our Kotlin code through the auto-mapping. We can do this by using the naming convention of @+id and then give it its name. The @ indicates which resource or that we're going to be using a resource. Plus (+) indicates that we're going to be adding it if it doesn't already exist. And then we pick the ID as the resource type. This tells the processor to add the ID of article_detail_webview if it doesn't exist already. We can actually self-close this WebView since we're not going to be adding any child views. The next thing we need to do is assign this layout that we just created to map to our ArticleDetailActivity. Back over to the Kotlin file, we can override the onCreate function. We'll select the override that just takes the nullable bundle savedInstanceState parameter. We will still need the super call here. And, instead, we're going to now call the setContentView and then get a reference to the layout file by calling R. layout. activity_article_detail. And once again we'll pull in a reference to our R class that's been generated. And so now when this activity's created, it's going to set the ContentView to the layout from the resource class and find the ArticleDetailActivity layout. You'll notice that we actually don't need semicolons with each of these calls unlike Java and many other object-oriented languages. This is because the Kotlin compiler is intelligent enough to tell when your statements are meant to be separated and can do so with things such as line breaks, spacing, etc. The last thing we need to do is register this activity to the AndroidManifest. We can follow the activity that was created from our template and simply create it for our new ArticleDetailActivity. We get plenty of auto-complete from the tooling, which is great to help us write this more quickly. So we can go ahead and hit Enter to select the activities. ArticleDetailActivity. And that's it. We don't need to provide any intent filters since we're not doing anything special other than starting this activity from the selection of a given Wikipedia page. So now to make sure that this works, let's go over to our MainActivity and add an event just to test something. We can get a reference to that message TextView and add an OnClickListener. In Java, we would have to create a new instance of the view. onClickListener class. However, in Android, we can actually use a new single, which can pass in a parameter of a given type and do something with it. This is basically auto-mapping overrides within listener classes to make these methods much shorter and quicker and easier to read. So here we know that we're setting an OnClickListener. And we're going to map the OnClick function to pass in a given view parameter and do something with it. We also get some auto-suggestion where if this parameter view is in use to change it to an underscore. This allows the Kotlin processor to ignore this field when processing it. It also makes it readable when we need to have more parameters passed in through these listeners, and we only need to use very specific parameters within our custom code. So what we can do with this message. setOnClickListener is start the activity of our new ArticleDetailActivity. We can create a new intent by simply calling Intent, passing in a given Android context after we pull in a namespace. The Android context that's going to be creating this intent is this current activity, so we'll pass in this, and then we'll need to get a reference to our ArticleDetailActivity Java class underneath. We do that by calling the ArticleDetailActivity, two colons, and then we get the auto-suggestion here for the class. java. We can now go and update our application live in our emulator by calling Apply Changes or by rerunning it again. So now back in our MainActivity, we can go ahead and tap or click on the label and see that it kicked off a brand-new activity with the default theme as well. We don't have any content here since we haven't added anything to our web view. However, we can see that we're starting a new activity since it doesn't have our bottom navigation view and has changed the label. Back over to Android Studio, we now just have one more activity we need to have before we really dig into creating the views that make up the UI. Back over in the Project view in the activities, let's do this with the tooling once more. We'll go over and select Activity, and from here, we'll select an Empty Activity. We're going to call this our SearchActivity, which is going to be started when we click on the search bar from the MainActivity. This is not a launcher activity as our MainActivity was. And it's going to be backwards compatible with AppCompat. We'll select the package name and once again ensure that we have Kotlin set as programming language. And then we'll hit Finish. You can see that this does a very simple wire-up very similar to what we did manually. It even went ahead and added the updated activity to our manifest right below our recently created ArticleDetailActivity. So now we have our three primary activities. This means that we can start creating our different layouts to complete the pages required by Wikipedia for the Explore, History, Favorites, Search, and Detail pages. The first thing we're going to do is apply that new theme that we created at the beginning of the demo. This is simply AppTheme. NoActionBar, and once again we can use the auto-complete to help us out.

Demo - Updating Views and Layouts
Now let's continue by updating our layout for our ArticleDetailActivity. The first thing we're going to need to do is create our custom toolbar. We'll do this by adding an AppBarLayout, give it an ID, as well as a width and height. We'll then add an Android. support. v7. widget. Toolbar, which is the actual toolbar underneath. This will also need an ID, width, and height, and we'll set the layout_height to the actionBarSize attribute from Android. We'll then give it a style or theme from the ThemeOverlay. AppCompat. Dark. ActionBar. This gives our text a white look over a dark ActionBar color. Now let's add a ProgressBar below our WebView so we know when our page is loading. We'll also need to give this an ID and a static width and height size. Now that we've updated our layout, let's go into our ArticleDetailActivity. Here we're going to call the setSupportActionBar function from the AppCompatActivity. This sets the SupportActionBar using a v7 toolbar that we added in our layout. The next thing we need to do is get a reference to the SupportActionBar we just set. From here, we'll call the setDisplayHomeAsUpEnabled function and pass in true. This sets the Back button on the left side of the toolbar next to the title. Now we need to handle when that Back button is hit. We do this by overriding the onOptionsItemSelected and then checking if the item that was selected is the android. R. id. home. If that's the case, we call finish and return true. This is all we'll need to do for now in our ArticleDetailActivity, but we'll be doing more wire-up once we have some article data. The next activity we'll need to update is the search activity. Let's move over to the activity_search layout and proceed with adding the AppBarLayout and toolbar just like we did previously in the ArticleDetail layout. We'll also give this an ID, as well as a width and height like we did before. We'll use the same ID in this instance so it makes it easier to use the same code that we did in our ArticleDetailActivity code-behind. We'll also still be using the attr/actionBarSize for our height and set the theme to the ThemeOverlay. AppCompat. Dark. ActionBar. Now we'll need to add a RecyclerView, which is going to be used to display our search results when we're done getting them from the Wikipedia API. This will fill the layout_width and _height, so let's use the match_parent setting. Over in the Design view, we'll notice that we actually seem to have two toolbars. This obviously isn't what we want. However, we'll notice that this is because it's not using the proper theme that we set in our manifest. We can select the AppTheme. NoActionBar and see that the result is what we want--one toolbar and the RecyclerView right below it. Now we'll need to add the search bar within our toolbar. We can do this by creating an Android resource menu. Let's move over and create a new menu resource file, and we'll call it the search_menu. Let's move over to the Text view and add our item underneath our menu. Give it an ID and set some other custom properties such as showAsAction equal to always and set the actionViewClass to the android. support. v7. widget. SearchView. We'll then give it a title of Search combined with the rest of these properties and ensure that it is always visible in the toolbar. Now back over in our SearchActivity, we're going to do some of the same wire-up we did in the ArticleDetail with setting the supportActionBar and setting the DisplayHomeAsUpEnabled to true. We'll also once again override the onOptionsItemSelected function and ensure that when the home item is selected, we finish the activity and go back to the previous one. With this done, we're going to do some unique setup in order to get the search functionality to work. We're now going to override the onCreateOptionsMenu function. This is what's called whenever we're creating a menu based on a menu resource. So what we're going to do first is inflate the menu from the search_menu resource we have. We can use the menuInflater. inflate call to do this. We pass in the menu we created and then the menu object that's passed into the parameters. Once we get a reference to our menu, we can get the specific item we created by its ID. After that, we can get a reference to the SearchManager service by calling getSystemService and passing in the ID of the SEARCH_SERVICE from our context. Then we'll get a reference to our SearchView from the ActionView we assign to the searchItem in our menu resource and set the SearchableInfo to the current component. Now we'll setIconifiedByDefault to false and requestFocus. This way, it's expanded and is focused the second we start the activity. Lastly, we'll create an onQueryTextListener object. This has two functions we can override internally--the onQueryTextSubmit and the onQueryTextChange. This is what allows us to handle submissions or when text is changed in the search bar. Later on, we'll use this to actually invoke our search from our Wiki service to call to the API and get objects to update the view. And with that, we have our three primary activities with their layouts created and updated. In the next module, we'll create plenty more layouts for our fragments and our internal views for cards and list items.

Module Summary
By the end of this module, we've learned about what it takes to build an Android app. We've also learned about activities, how they're structured, their lifecycle, and more. We've talked about Android views and the components available to us to use in our apps, learned about Android resources and how to use them, and, lastly, we finally got our Wikipedia app in progress. In the next module, we'll talk about Android fragments and how they work together with activities and other views. We'll apply them to our bottom navigation view for our Explore, History, and Favorites pages.

Creating and Managing Fragments
Module Overview
Welcome to the next module on building Android apps with Kotlin titled Creating and Managing Fragments. We previously learned about what goes into an Android app and how to build activities and views. Now we're going to cover the last piece of Android application interfaces and dive deeper into fragments. In this module, we're going to be covering the basics of what a fragment is. We'll look at the fragment lifecycle and compare it to the activity lifecycle we learned about in the previous module, as well as how these two work together. Then we'll talk about how to use fragments in our Android applications and look at some of the views and controls we can use that revolve around the use of fragments. After learning all about fragments, we'll move back to Android Studio and build out fragments for the Explore, History, and Favorites pages including creating them, wiring them up, updating their layouts, and with this complete, the foundation of our interface will be done, and we'll be able to move on to interacting with Wikipedia data.

Fragments and Their Lifecycle
Let's dive into Android fragments and what they're used for. We learned about how an Android activity creates the window in which our application is drawn, and we talked about how activities contain views and manipulate them. Fragments lie in between activities and base view components. They themselves act as views with a layout resource file but also contain logic and other views within them just like activities do. Fragments can contain other views and are responsible for their child view management while the activity is not really aware of these child views. We can break down fragments into a few key responsibilities and details. Fragments contain layouts and child views in the exact same way that activities do. Just like activities, fragments contain logic and talk to external data and business logic. Fragments also update their child views and manipulate their appearance and related data. Unlike activities, fragments cannot live on their own. They must live with an activity in order to be created since their lifecycle is managed by the activity via the FragmentManager and some of the automated processes that the Android SDK helps out with behind the scenes. This happens when inflating a layout that contains a fragment. Let's go over the lifecycle of a fragment within an Android activity. In each of these phases of the lifecycle, we as developers are given a function within our Kotlin code to override and attach our logic to. The first piece of the lifecycle is the attachment of the fragment to its parent activity. After that, the fragment is officially created and goes through to the onCreate function. We then hit the CreateView phase to inflate our layout file and register our child views to referencing code. Next, we move to some familiar lifecycle phases that we saw in our activity lifecycle diagram for start and resume. These bring the fragment to its active running state. When the parent activity is paused, or the activity moves the fragment out to replace it with another fragment, it moves to this pause stage. From here, the fragment can either resume or stop depending on whether the fragment was brought back into the view within its parent activity or if the parent activity stops or removes the fragment completely from the manager. Once it's stopped, the fragment moves to destroy its view. This is the last chance to turn back before being removed completely. If it is re-added to the activity, it goes back to the CreateView stage. If it does not, it moves to destroy the fragment, then detach it from the parent activity. Once the fragment is destroyed and detached, it's completely dead. The only way to come back now is to restart the lifecycle completely with a new instance of the fragment.

When to Use Fragments
At this point, we've gone through the basics of what makes a fragment and what it does. Let's now move to when we should use fragments. Why not just use views and activities? What's the point of these? What controls use fragments to make our development lives easier? We can break the purpose of fragments into three core concepts, two of them being the most valuable and the last being an optional use of it. The first major concept is a separation of logic and encapsulation of context within an application. We can contain separate pieces of logic of equal importance in our application within fragments that exist within the same activity context. The second and arguably most valuable is the reusability of fragments throughout our entire application. By breaking out logic to encapsulate it within a fragment, we can then take that fragment and use it anywhere in our application. Any activity can contain any fragment, and any fragment can be manipulated for reusability with different sets of data. Lastly, we have the ability to drive an entire application from a single activity by using fragments. We mentioned this briefly in the previous module, but with the robust lifecycle of a fragment and its flexibility, it's completely possible to have just one activity and use its FragmentManager to update fragments that act as the contextual pages that make up the app. Fragments have four most common use cases, although they are definitely not limited to them. The most common is with tabs, specifically using the tab layout with the ViewPager control. Similarly, they are used with the new bottom navigation view but aren't meant to be held within a ViewPager just like they are with tabs. They are also used for general component reuse between common activities and, lastly, within carousels and other pagers that use the ViewPager control just like the tabs do as their driver. In order to use tabs with fragments, we create an instance of a fragment for each tab. This means that we can reuse the same fragment with different data or completely different fragments if the views themselves are completely different. We then attach these fragments to a ViewPager control using an adapter class to map what fragments belong to which tab in the view. Similar to tabs, we use the bottom navigation view with fragments by creating an instance for each view whether they're the same or a unique type. The biggest difference in how we use them is that we use transitions and transactions within the activity's FragmentManager rather than using a ViewPager to show or hide a given fragment depending on what's selected. Creating fragments for general reusability is easy. You simply create your layout in fragment code, then drop it into any other layout file that contains the fragment. You manage it within the FragmentManager of the activity, and you can instantiate a new instance of it whenever you want. Using fragments with pagination is just like setting them up for tabs. Use a ViewPager control with a page adapter class to manage the creation of the fragments and mapping them to items in the pager. Once this is set up, it allows users to cycle through the pager and hit different fragments for each pager view.

Demo: Creating Fragments
Now that we've learned quite a bit about fragments and how to use them, let's start building out the rest of our interface for our Wikipedia application. In this demo, we'll create unique fragments for our Explore, History, and Favorites pages. We'll then wire up the bottom navigation view to handle fading the proper fragments in and out depending on which item is selected in the navigation view. Then we'll wire up our reusable control layouts for our card views and list items while setting up our final navigation. Lastly, we'll run the app and get an idea of what it might look like before we start to use some real data from Wikipedia. Now that we're back over in Android Studio, let's start by creating our fragments for our Explore, History, and Favorites pages as required by Wikipedia during our requirements gathering. With each of these fragments, we're going to have a Kotlin file behind it, as well as a layout resource that we'll add. Let's start first by creating the History fragment. Over on the left side in the fragments folder, right-click and go to New. And down on the bottom, we can hit the Fragment subsection and select a new blank fragment. From here, we're going to change the name to HistoryFragment since that's what we're creating. And we do want to create a layout XML. We're not going to include the factory method or the interface callbacks. And then we can just hit Continue. This starts us off with a pretty bare-bones call on fragment file. This was actually translated from Java in the templates, and you can see some of the oddities because of that such as the empty required public constructor. Over on the left, we can also go and hit the new layout resource and see that we just get a base FrameLayout with a TextView. Let's start by updating our layout. So we're going to delete this TextView and start by adding a RecyclerView, which is going to represent the list of our history items that we visited as we browsed the app and hit new articles. We're going to have it match the parent's width and height since it's going to fill the whole page. The Favorites fragment is just like the History fragment, so we're going to go ahead and move over to create a new fragment in our folder, and we're going to rename this to the FavoritesFragment. Once again, we'll include the create the XML layout, and we'll uncheck the factory methods and interface callbacks and double-check that the language is set to Kotlin. Since just like our History fragment, our Favorites fragment is also going to contain a list, let's go over to the layout file and remove the TextView and replace it with our RecyclerView that fills the whole page just like we did a couple of seconds ago. Now just be sure that the RecyclerView here has a different ID than what it was from the History fragment if you just want to copy and paste it over. So now that we've got our very simple fragments done, let's go create the Explore fragment, which has a lot more going on. Over on the left side, let's once again go over and hit New, Fragment, and select blank fragment once more. We'll go through the dialog again and change the name to ExploreFragment and hit all the same options we did previously. (Working) So with our third fragment created, we're going to move over to our resource file and start making some pretty drastic changes. Unlike the last two fragments, this one doesn't just have a RecyclerView. It does for having the random cards, but it also has that SearchView and the floating card underneath it, so it's going to be a little bit more complicated. Let's start by replacing this FrameLayout with a new CoordinatorLayout from the Android support library. This CoordinatorLayout allows us to handle events that change when over layouts change underneath. This is going to be useful for us to add some parallax scrolling for our search bar when we're scrolling the cards that are underneath it. With our base layout set up, let's go ahead and remove this TextView that's created underneath. We're going to start creating our complex layout by adding our toolbar that contains our floating search bar card. We start by adding a support. design. widget. AppBarLayout and give it an ID. We're going to give it an explicit height of 92dp with a width of match_parent. This is the toolbar that's going to be going underneath the main toolbar that contains our search bar and handles scrolling for collapsing. Because of that, we're also going to add this CollapsingToolbarLayout and give it the width and height of matching its parent AppBarLayout. We're also going to give this a toolbarId, which is key for handling which toolbar is actually collapsing within the layout. We're now going to add two other unique properties. The first is going to be the actual scroll flags which coordinate with the CoordinatorLayout that contains this to handle what happens when we're scrolling. We'll set it to scroll and enterAlwaysCollapse, and we'll also set the contentScrim to the primary color, meaning that the color behind this toolbar is also going to be the primary color set in our style to match the toolbar that's underneath. Now let's start by creating our search_card by adding a card_view base that's going to contain the actual label and the icon for search. We want to make this look like a search box itself even though it's going to redirect to the actual search activity, so we set our width and height and also give it some margin and elevation. And, last, we add that collapseMode parallax so we know how to scroll it when we're scrolling underneath. Now that we're adding the content within the CardView, we need a LinearLayout with a height of 48dp and start adding our ImageView and TextView. Our ImageView is going to be 24dp by 24dp, and it's going to have the color tint of gray since we're going to be on top of a white card. We then set the source of it to the ic_search_black_24dp that we added. Lastly, we add the TextView to contain the text of search with the matching width and height of the parent card. We also set it to center vertically so that it's lined up with our icon that's right next to it. We'll use 16sp for the textSize, and we'll set the text to Search Wikipedia to tell the user that tapping here is going to let you search for articles. What we're going to do next is not what's going to be in the final application, but it's used to demonstrate what happens when we add multiple toolbars to our view. We're going to add an app widget toolbar underneath and give it the ID of the toolbar which we set for the collapsing toolbarId above. This is not going to be our primary main toolbar at the end because all of our other fragments also need toolbars as well, and we don't want to have to maintain each one of them. So now underneath, let's go ahead and create a RecyclerView for what's going to be our randomly generated article cards. This is also going to have a layout behavior that's going to handle how we scroll and how we affect the CoordinatorLayout to handle the AppBar scrolling underneath. We do this by setting the behavior to the AppBarLayoutScrollingViewBehavior. Over in the design view, we can see what this looks like, and, yikes, that's pretty bad! This isn't what we want. We have two toolbars on top, and the search and title are all collided. Let's collapse the sidebar so that we can see what this looks like even better. We have our search bar and our title on top of it and our RecyclerView below that. But this toolbar situation just looks wrong. This isn't what we wanted at all. We can look at some of the properties on these and see what's going on. We can hit the TextView within the search_card and see that something's not lined up properly. On the right side, we can scroll down to the properties and make it to our gravity property. With TextView, we don't just have the layout gravity, but we also have the text gravity itself. So we can hit center and see that that actually change it a bit. However, we don't want the text centered completely, so let's just hit center_vertical and see that it's lined up just how we wanted. So now we're getting closer, but we need to figure out this toolbar situation. We want the search bar to be underneath our toolbar that's unique, so let's go see what that looks like by switching the theme in the Theme editor to a regular AppTheme rather than the AppThemeNoActionBar. Now that's closer to what we want except we still have that floating toolbar that we created earlier. We can go back to our layout text side and delete that toolbar we created since we're going to be doing it at the activity level to put the search bar underneath it. That looks pretty good. Now we can go see what those other fragments look like if we fix the toolbar and add it in the Design view. Once again, we'll go over to Favorites, and we'll switch it to the AppTheme rather than AppThemeNoActionBar and make sure that that's exactly what we want. We'll ignore what the layouts are for the individual items since that's just a representation in the tooling and not what's actually going to be output.

Demo: Using the Bottom Navigation View with Fragments
But now that we have our general layout set up for each of our fragments and they look like we want, we're going to now go over to our MainActivity's layout file and start setting up our bottom navigation view and then switching between these different fragments when we hit different navigation items in that view. The first thing we're going to do is remove that TextView that was auto-created for us to switch the message. Let's delete this and start by creating an AppBarLayout that's going to contain our main toolbar. Since we're not going to be adding a toolbar for each of our fragments and using one primary one, we're going to do this here in the MainActivity. We'll set the width to match_parent and the height to the ActionBarSize standard from Android. And within this AppBarLayout, we'll add our widget. Toolbar, which is going to have the ID of toolbar to match what we set in our CollapsingToolbarLayout in our Explore fragment. Now before we start dumping our fragments into this activity and handle the switching, there're two more layouts which we'll create that're going to make our lives easier by doing now. This is going to be the reusable layouts for our list items and card views within our RecyclerViews. Let's start by creating our list item by going to the layouts and hitting New, Layout Resource and calling it the article_list_item. This is going to be what's used for the search results, as well as the History view. This is going to be a very simple layout with just a thumbnail image and a TextView right next to it to have the title of a Wikipedia article. Let's start by adding an ImageView to a LinearLayout that's positioned horizontally. Our ImageView's going to be 32 by 32 dp and have a unique ID so we can set it in an adapter, and also set a margin to 16 dp so we have some room around it. We're going to want it centered vertically and horizontally within its container, and we're going to want to set the TextView to be right next to it. This TextView's going to have a layout_gravity of center_vertical. And we can head over to the Design view to see the progress we have and how it looks. We can't really see anything on the left side, but we can see the blueprint. This is going to look good for now, so let's go ahead and move over to creating our CardView item, which is going to be used for the random view on the Explore page, as well as the Favorites list of articles. This is going to be a little bit more complex since we need to add a CardView as our base that's going to be holding a larger image, as well as the TextView for the title underneath. We'll start with a relative layout base and add the CardView within it so that we can handle spacing from the CardView around its parent. Let's set a layout_margin of 16dp to be consistent with Material Design standards. We're also going to align it to the top of the parent and center it within it. This is going to allow us to have padding equally all around it and ensure that things are spaced evenly as they go through the list. We'll also set the background color to white for the card and give it an elevation of 4dp. Within it, we're going to create a LinearLayout that's going to contain our larger ImageView, as well as our TextView for our title. We'll set the layout_width and _height properly for the ImageView and give it a unique ID so we can set it in our adapter. Then we'll create our TextView with very similar properties and also another unique ID so we can use it. Now let's give it a gravity of center so we can be centered within right underneath the image that's representing the article. We're also going to text the line center so everything is lined up just right. Again, we can't see anything on the left since we haven't populated it with content. However, if we expand this a little bit so we can see it larger, we see that we have our CardView, and our blueprint shows that we have our ImageView and TextView. This is okay since the ImageView is what's going to be pushing the height, and our TextView is going to be set in the center once we have article data that's going to represent it. And now that we've completed these reusable layouts early ahead of time, we can head back to the MainActivity and start setting up our bottom navigation. We can see the one that was given to us had a Home, Dashboard, and Notifications view, but we need new icons and new text that better represent what we have. We can do this by downloading icons over at the Material Design website. This is at material. io/icons. This is a full suite of icons that can be used on both Android and iOS and is great for searching and using to hit standards and look great. We're going to need three new icons for our Explore, Favorites, and History. Let's see if we can find something that's useful here before having to go and worry about creating our own. If we type history into the search, we see we have a pretty good icon that's used pretty consistently between material apps. We can go ahead and pick a color and a size of 24dp since that's the standard for the bottom navigation and download the PNG packet. Now let's go and search for a heart or a favorite icon that will better represent what we have for our Favorites toolbar item. We'll find the filled heart and do the same thing by downloading the PNGs. Now what about for our Explore page? I imagine something like a globe or a compass, which we're searching here. However, if we just search explore, we find something that's just right. Let's go ahead and download this s well, and then we'll have all three of the icon sets we need for our bottom navigation view. So now let's start importing these into our projects. We should open them up and unzip the zip files that are downloaded for us. Once we do this, we can copy the Android side of things since we download them for Android, iOS, and web, and you see we get all these drawable folders. We can copy these and paste them in Android Studio right under the resources folder. This is going to automatically generate the different sizes and pixel densities that each of these images need to fit. If we double-check the folder that it's going to be going under, you can see that when it's added to the drawables folder, it's done for each of the proper densities that was set in the folders we copied from. Now let's go ahead and do this for the other two--Favorites and Explore. Again, copy over to Android Studio resources and paste. And one last time for the Explore, go to Android, copy all the drawable folders, and paste them into the resources folder in Android. If you try to paste it to the drawable folder, you can see that it's going to create some issues. So let's make sure that we copy it properly again. Go over to resources and paste it from the root. Great! Now that we have all three of our icons, we need to go update our bottom navigation view to properly set them. This is done by going to the menu resource that's set in the bottom navigation view. We'll take each of the three items that was auto-generated for us and switch out the icons for the ones that we've downloaded--the ic_explore_white, the ic_favorite_white, and the ic_history_white. But now we need to fix these titles, and these are also pointing to other resources within the strings values. So in order to change this, we can't just type our text in. Well, we can but we shouldn't. It's best to use the Android string resources for static strings like this. So over in the values folder in strings, we can go ahead and switch out what we had for our previous navigation items and also clean out some of the other auto-generated strings. So now back in our menu, we go to the title properties and switch it out to the new strings with the IDs that we created. Let's also update the IDs of these menu items to better represent the three navigation items we have for Explore, Favorites, and History. So now over in MainActivity, if we go back to the Design view, we can see that we have exactly what we wanted with our icons and our titles for each of our three fragments we created. So we have our toolbar set up, and we have our bottom navigation view. But now we need to actually set up to switch out the different fragments within the rest of the content that we have blank here. Let's go back over to the text. And between the AppBarLayout and the BottomNavigationView, we're going to want to add a new container that's going to hold our fragments. For this, we can use a simple FrameLayout. If we were doing this with tabs rather than the bottom navigation view, this is where we'd use a ViewPager that would set up an adapter to contain our fragments. However, we don't want to use a ViewPager with the bottom navigation since it breaks the standard set by Material Design. Within our FrameLayout, we can set some constraints to fit within the bottom navigation view and the AppBarLayout. We're also going to need to eventually set some margins so that we don't fill underneath the AppBarLayout but, rather, go right below it. We'll need to set an ID of the AppBarLayout so that we can properly hit the constraints. And over in the Design view, we can see these constraints as the squiggles as above and below. Lastly, let's add some elevation to our BottomNavigationView so that it looks like it's separated from the main content view. We can do this by just setting the app:elevation to 4dp. Now with our layout looking good, we can head over to our MainActivity's Kotlin file and start wiring up how we actually handle switching out our fragments. We're going to see a whole bunch of errors here since we deleted that message TextView and all the logic there for setting the onClickListener to move to a different fragment. So let's start by clearing all of this out and then start by setting our fragment's transaction manager to load up our first fragment and handle how we switch them. Now that we have everything clearing out, let's go start by creating instances of our fragments as properties on our activity. We can do this by setting a value of ExploreFragment, HistoryFragment, and FavoritesFragment, and making sure to pull in the packages for each of them as we add them. We'll start by seeing some of these red squiggles for errors because we need to init them within our base constructor's initialization. We can do this just by new-ing them up in a very easy way. So now that our activity has our three fragment instances, we need to set up our initial fragment that's viewable within our container, and then set up what to do in this OnNavigationItemSelectedListener. Let's start by getting the supportFragmentManager and beginning a transaction. Within this transaction, we call the add within our container, and we want to add the exploreFragment. When we call commit, this is what's going to add it. This is done in the onCreate so that we can create it initially. And now over on the OnNavigationItemSelectedListener, we're going to create another transaction just like we did before. This time we're going to set a CustomAnimations of fade_in and fade_out. This is going to handle the animation that happens when we switch which fragment is visible. Now we can add a switch over the itemId by using the Kotlin when statement. When the itemId is navigation_explore, we want to replace the fragment_container's fragment with the exploreFragment. When it's navigation_favorites or navigation_history, we want to replace the container with the existing fragment that best represents it. Now that we've set our transaction setter animations, and done the replace call on it, we can commit at the very end. So now we can handle how we click and how we switch out which fragment is visible, and we have our initial visible fragment set to the Explore by setting the transaction to run in the onCreate. So now let's go ahead and run this in our emulator and see the results of switching our fragments out. Now that it's started up, we can see that there's something a little off with our search bar underneath our toolbar. However, we're here to check out the fragments switching, which does seem to work the way we want. Now that we're done with switching out our fragments, let's go over and fix this issue with the toolbar by going over to the MainActivity and adding some margin for our fragment_container underneath our AppBarLayout. So over in our MainActivity file, we can add the layout_marginTop to set the attribute for the actionBarSize since that's exactly what our AppBarLayout's height is. We can then run this and see what the update looks like. And look at that. It looks just like we wanted. The only thing that's missing now is actually setting the title content. However, our fragment switching works with our bottom navigation, and we have our CardView set up for our search, and everything works underneath it.

Demo: Recycler Views and Finished Fragments
So next let's go ahead and wire up clicking that CardView and having it navigate to the search activity. Over in our ExploreFragment, we're going to get a reference to the search_card_view by doing some of the auto-mapping we've seen before that Kotlin provides us and setting the OnClickListener to a new single that's going to create an intent that goes to our SearchView. This is just like what we set up originally in our MainActivity by clicking that TextView. We'll set the context to the context of the fragment, which is the activity that contains it, and then set it to start the activity for the search activity. Now we need to set up our different RecyclerViews in order to see them with the fake data that we can view before we wire up with some real Wikipedia data. Let's start by creating some adapters that are going to contain the data that maps to the RecyclerViews. We can create a new adapters folder and then create an ArticleCard adapter. And then after, we'll create another RecyclerAdapter for our individual list items. So we can call this the ArticleCardRecyclerAdapter, and then ensure that it's a Kotlin class and hit OK. This ArticleCardRecyclerAdapter needs to inherit from the RecyclerView. Adapter. This RecyclerView. Adapter also takes a generic type that represents a RecyclerView. ViewHolder. However, we haven't created a ViewHolder yet, so let's go ahead and do that as well. Over on the left, let's create another folder and call this holders. This is where we're going to put our two ViewHolders that contain the views for our card that we created, as well as our list item. We'll go ahead and create another Kotlin class and call this the CardHolder. Ensure that it's a class rather than a file and hit OK. This CardHolder needs to contain an ItemView within its constructor and inherit from the RecyclerView. ViewHolder with the same constructor passing in this view. We're then going to set up some properties to represent the image that we had underneath, as well as the TextView. We only need to set up these properties for views that are going to contain data or that are going to update within our adapter. So we don't need to represent our card or its container. We can also auto-map from the ItemView. findViewById rather than creating a separate constructor since we have this item created within the constructor that's part of the signature of the class. And this is all we're going to need for now until we start wiring up real data to update with the Wikipedia page. So now that we have our ViewHolder created, we can go back over to our Adapter and set it as the type within our RecyclerView. Adapter we're inheriting from. Now we need to override a few methods in order to fulfil the contract. This includes getItemCount, onBindViewHolder, and onCreateViewHolder. GetItemCount represents the number of items that our RecyclerView will contain. We'll use a static 15 for this. OnBindViewHolder is how we update the ViewHolder's content with new content from our page. OnCreateViewHolder is where we create our ViewHolder. We're going to do this by inflating our layout from our article_card_item we created and then instantiating a new CardHolder by passing in the cardItem we created. We also need to return this cardItem since that's what the expected return is for the CreateViewHolder. Now let's go ahead and create our other adapter by copying and pasting the ArticleCardRecyclerAdapter and renaming it to the ArticleListItemRecyclerAdapter. This is the adapter that's going to be used for our History page, as well as our Search page. We still have our getItemCount and everything set up properly. However, we're going to be using a new layout for the article_list_item, and we're also going to need to set up a new ViewHolder for our ListItemHolder. We can do this by copying and pasting as well. However, we are going to need to go change the IDs since they are different from what we have for our card_item. Rather than the ID of article_image and article_title, it'll be result_icon and result_title. So now that we've updated our ViewHolder and adapter, we can go back over to our fragment and start wiring up our adapter with our RecyclerView. Right below where we set our search_card_view. setOnClickListener, we're going to get a reference to our explore_article_recycler, and we're going to need to give it a LayoutManager. The LinearLayoutManager tells the system that we want to be having these items stack either vertically or horizontally defaulting to vertically. And we also set the adapter to tell it what data we're going to be using with the adapter we just created. Now rather than just returning right away, let's set a variable of view and return that at the end. So now our ExploreView has its recycler and its search bar set up, let's move over and set up the recycler for the FavoritesFragment, as well as the HistoryFragment after that. We're going to do the same thing where we set a variable of view, and then we're going to get our reference to the proper recycler with trying to do the auto-mapping, give it a LayoutManager and an adapter. And then this fragment is basically good to go for now. So now let's hop over to the HistoryFragment and do just about the same thing but with the different adapter. So we'll switch out the return for a view variable. We'll go and get a reference to the recycler and set the LayoutManager. And then we're going to set the adapter to one of the adapters we just created. So the History gets the ArticleListItemRecyclerAdapter, but we're going to go back over to Favorites and fix it to use the card adapter that we created. So this is going to let the HistoryView use the single listItems and is going to let the Favorites use the cards just like the Explore. One more thing we should do before going and trying to run this is go get a placeholder image to load that can sit before we open up the image from the actual article pages we get. This will also help us just visualize what we want without having our actual data yet. So let's grab this image icon in black and download it. And once we've downloaded it, we're going to do what we did before when we pulled in the icons for the bottom navigation view, and we're going to go to our Explore, go to the Android subfolder from the expanded zip that we have and copy that into the resources to create the folders for the proper drawable resolutions. Once we make sure that it's imported properly, we're going to go back over to our cardItem and listItem layout files that we created, and we're going to set a default source in our ImageViews. This is for the article_image and the result_title fields, and then we're also going to set just a default text to help see the listItems as we view them in our RecyclerViews. Now when we run this, we're going to see an issue right away. We can hop over in Android Studio and open up the logcat to see exactly what exception is thrown that caused the crash immediately. If we go up and over in the view, we can see that we have an old reference exception where it's trying to set the method of onClickListener. Weird! The only place we're doing this is with that search_card_view, which was pretty straightforward. So here's where we're going to actually learn something different. In fragments, we can't use this auto-mapping like we did in activities. This is because the Kotlin engine that's doing this underneath is going to try to do this in the onCreate override, but you know that in fragments, we're doing the setups in the onCreateView override. This is because we need to have the view set from the inflater before we can actually get a reference to any of our subviews. So in order to properly fix this error, what we're going to end up having to do is create private variables for each of our views and set them the old-fashioned way by calling view. findViewById and casting them to the proper type. So let's set up one for our CardView, as well as our recycler. We'll initialize them as null, and then underneath the view inflation, we're going to call the view. findViewById, give it a generic type, and then from there we can set the OnClickListener, and we want to do a hard set with our double exclamation point, meaning that if it's null, we want it to crash again because we want these to be guaranteed there. Now we'll do this in the Favorites fragment as well. We'll clear out the favorites_article_recycler auto-mapping and create a new variable. We'll call the findViewById with type RecyclerView and get it by its ID and swap those out. So now the Favorites fragment should be good. Let's go update our last one with the History fragment. Once again, we'll create a historyRecycler, which is a null RecyclerView, and then we'll go and find it by ID from the main view that we inflated. And then we'll swap out the broken auto-mapped one. (Working) Now let's switch over to the emulator and see what we have. We have our awesome looking parallax scrolling, which hides our search view underneath our toolbar. However, I think we messed something up with the layout for our individual cardItems, and it'll likely be the same thing for our listItems. So let's go back to Android Studio and fix what we need to real quick. The first thing we're going to need to do is go fix our ArticleListItemRecyclerAdapter view since we forgot to swap out the CardHolder for the other ListItemHolder that we created. So we'll need to do that everywhere. We can start by doing it in the class definition from inheritance, and then we can see that the errors come all the way through. We'll fix the typo right here and add the capital H, and then we should be good to go after we clean this up one more time. Don't forget to bring in the namespace with the Alt+Enter shortcut. Then with the holder all cleaned up, we'll go back into those layout files, and rather than having them set to the layout_height of match_parent, we're going to set them to wrap_content from the container. So with that, let's scroll on down to the article_card_item layout file resource that we created, and from here, we're going to take a look at the relative layout up top that has layout_height of match_parent, and we're going to set that to wrap_content. Now with that fixed, let's head over to the article_list_item layout and do the same thing. We want to set the layout_height to wrap_content rather than match_parent. So now over in our emulator, we can see that each of our lists has a pretty good look. We have our cards for our Explore and Favorites, and our History view has those individual list items. The cards will expand when we have larger images coming in. And also tapping on the search card opens up to the search view. We're pretty close to done here. The only thing we have left to do is fix these titles in the toolbars by actually setting them. So in order to do this, we'll head back over into Android Studio into our MainActivity. And within our onCreate, we're going to be calling the setSupportActionBar, which takes in a regular toolbar that we created and sets it to the action bar for an activity. This is how we're going to be able to use the title from an activity to set the title within the toolbar itself. So let's go over and add a new theme to our styles for the AppToolbar and set the text color to white in order to have our darker toolbar with a white text over it. Now we can go into our MainActivity, and within the toolbar, we can set the theme to this new style that we created within our resources. We'll set this to the AppToolbar style, and then we'll be able to go in and see the update run and view our title. By default in Android, an action bar's title is set from the title of the activity itself. We get this from the app manifests or the AndroidManifest file. You can see that each of these activities we've added has a label, and this points to another string resource just like we had for our bottom navigation view menu. So in our strings, we can update the app_name, which we have as Wikipedia, which we don't need to, then we're going to update these titles for each of our activities and fragments. We can set it to Wikipedia for our MainActivity and clean up the rest of these resources we don't need. Now when we go and view our manifest, it'll be updated with setting it to Wikipedia. So when we run the application and hop over to the emulator to view it, we can see our toolbar is set. And now I have a great-looking UI set up that's ready for some real data coming from Wikipedia. We can scroll and see the parallax scrolling looking awesome. We'll be able to continue to scroll when we have more items and real data that'll update with each of the cards. And we have this done for our Explore, Favorites, and History views.

Module Summary
In this module, we learned all about Android fragments. We talked about what fragments are and how they're used. We looked at the robust lifecycle of fragments within the context of an activity. We also looked at the different types of controls that use fragments and talked about some of their most popular use cases. And, finally, we've gone and updated our Wikipedia application to complete the foundation of our interface that is now prepared for using data from the Wikipedia APIs. In the next module, we'll go and look at some of the Wikipedia APIs and how we can use its data to map to Kotlin models and manipulate our views within our UI.

Getting Started with the Wikipedia API and Kotlin Models
Module Overview
Welcome to another module on building Android apps with Kotlin. I'm Alex Dunn, and in this module, I'll be taking you through the Wikipedia API and Kotlin models to handle our data. In this module, we'll take a look at how Kotlin models work. We'll also talk about how we can map JSON to Kotlin models to be able to use it in our code. We'll then look at how the Wikipedia API works in order to get data from Wikipedia. Then we'll create our models in our app that we'll be able to use from the Wikipedia API to map to data that we'll be using in the UI that we created previously.

Kotlin Models
Let's start by talking about Kotlin models. A model is a class in Kotlin that is used to represent data structures but doesn't apply any business logic. That means that our models are very simple, they hold properties to contain our data, but they're not really doing anything in particular. There are a few key things that are important to know when talking about models versus other classes in Kotlin. A model contains properties to define the data that's contained within it. It also has some helper functions to create data structures or map data. However, these do not apply necessary business logic that other complex objects can do. It also applies access restrictions for certain properties and functions within it. This way, it can determine if other classes and objects are allowed to access those properties or functions. We can take an example class in Java that represents a very basic data model. We'll call this a Dog, and it'll have a bunch of different properties that are contained within our private fields, such as the name, breed, and age. We get values from these through these get functions, such as the public String getName that returns this. name. We can restrict access to these private fields by not including functions. For example, there is no setBreed function, although there is a setName and setAge. This in turn makes the setting private so it can only be set within this class. If we don't restrict it, we set the values of these private fields through set functions. This is sort of the standard for how Java handles basic data. Now we can look at this in Kotlin. We're able to fit so much more within such little space and so few lines of code. In Kotlin, we can make our properties public if they're going to have both getters and setters. This means that we don't have to create functions to map them. In Kotlin, in order to help map it to Java, it automatically creates these functions behind the scenes. So if we're using this Kotlin-created class in our Java code, we will still be able to use the setBreed or setName function, although we don't have to explicitly create it here. Rather than not creating a function such as the setBreed in the Java class, we restrict access through visibility modifiers on the getter and setter. So you can see in our breed property, we have a private set, which means that we're only able to set the breed property from within the Dog class. Because of this, we don't need to create any extra functions to secure our model. We can specify what can be null or not with that String modifier at the end, such as with name and age. We can also initialize these non-null properties through the init or through a constructor. There're also other ways that we can build models in Kotlin to make it even smaller in code. Down here, we have the same class Dog. In this case, however, we are allowing the breed class to be set. And what this signature does is creates a new class that has a public variable of name, breed, and age. All of them can be accessed from just the base constructor defined in the signature of the class. This means that our entire model could be defined in one line of code. This isn't necessarily as readable, but it's interesting to see the possibilities that we have with Kotlin versus Java.

Mapping Remote Data to Kotlin Models
When we talk about models, it's always talking about how we structure our data. However, it's also important to know where that data's coming from and how it was structured and mapped to our Kotlin models. In the case of the Wikipedia app, we'll be using the Wikipedia API to get JSON data and map that to our Kotlin models. So let's talk a little bit about other remote data types and how we can actually map these to Kotlin. There're some very popular remote data schemes that are returned from APIs. The two biggest ones are XML and JSON. There is also the HTML type that can be returned from APIs, although it's less of a standard, and JSON has become more and more of the standard. So when we map JSON objects to Kotlin, we can take a look at a pretty basic JSON object again for a dog. In this case, we have a couple properties and their variables set. We have the name, breed, and age just like we had when we were defining our model, and we have some properties here that define the values for Felix, the breed of Border Collie, and the age of 4. We know what our class could look like for a dog just like we saw before, and we can see that there's a one to one mapping from our properties in our Dog class in Kotlin to the fields that we get back from our JSON object. Then when we create an instance of the Dog class in Kotlin called someDog, we are able to get the name, breed, and age fields and have them map from the JSON values.

An Introduction to the Wikipedia API
So it's pretty clear how easy it is to map data from JSON to Kotlin classes. In the next module, we'll be looking at some libraries and tools that actually help us do it in our code. However, in this case, we'll be sticking to learning about the Wikipedia API and creating the models that we need in order to map them. So let's talk briefly about the Wikipedia API itself. There are some primary resources here that are important to know and use for the Wikipedia API. We have the primary documentation page, the sandbox environment, which allows us to play with the API and test out some of our queries or some of the other endpoints we can use. And then we have the hardcore documentation at the API reference. This is where we can go and view all the hundreds of different properties we can set in our query strings that we send over to the API and see what type of returns we get instead. There are some rules with using the Wikipedia API just as there are with using every other third-party API. Wikipedia can't just open themselves up for brute force attacks by constantly hitting their API, so we're going to follow some rules to make sure we play properly within them. The first is to use the custom user-agent header. When we make a request to the Wikipedia API, they don't want us to use the regular user-agent that's passed up. This means that we when we build our app need to use a custom HTTP header with a value of user-agent and then pass up some customized field which commonly uses the value of our app ID for our app. We also want to make sure that we don't abuse the free service that Wikipedia is offering for us. They state this pretty clearly in their documentation, but the biggest part of that is try not to repeat requests that we don't have to. That means if we already have the data locally, don't go repeat the same request of the server just to get the same data back. We'll have to apply some caching or some properties within a service in order to contain the data that we've already received. All in all, be respectful of the fact that Wikipedia is offering up a free service for anyone to use to get more information to users and people around the world. We can break down how we use the API and the different queries and properties we can use into a few important keys. The first are actions. Actions are what we're actually trying to do with the data. That can be things like edit or add or in our case query. We'll be using the query action in order to get data back down from the API since we're not going to be building an interaction layer for editing pages or creating new pages. There're also additional parameters that are set once the action is created. Certain actions allow for certain parameters, and also these parameters nest into additional parameters that are readable. For example, when we set the type of content that we want to be retrieving from the API, we can also set additional subtypes of content as long as we have the first one set. The third most important is the format. This allows us to tell Wikipedia how we want the data returned to us. So we can specify things like HTML or XML or what we'll be doing in this case and requesting it to be as JSON. Here's an example query. I've broken it down into a URL where we can see each of the different query string values on a new line. Everything comes from the primary URL of Wikipedia. org/w/api. php. After that, the query string parameters we pass in are what define what we're trying to do. The first thing we're setting here is the format to JSON like we said. Then we're setting the action to query to say that we're trying to get data back from the API and not create or edit or manage. Then we set the format version to 2. If you set it to 1, there're a few different property changes that you're going to get, and the 2 is the latest version. So we'll be using that going forward. We then choose the type of generator we want for getting that content. In this case, this query is getting a set of random articles from the API. We then choose the properties we want for the page that's pulled down from the generator. In this case, we want to get the images from the page, and we also want to get the info. We then set the grn limit. This means the number of pages that we want to be returned. In this case, we're setting it to 1. So if we start to break down the query string parameters, we can kind of understand what we're trying to do. We want to get a random article with the page images and info, and we want to just get one of them. So we're trying to just ask for a single random article. Now, because we've specified the prop query string parameter for page images and info, we're able to now set the in-prop parameter, which allows us to ask for a nested property within the info property. In this case, we want to get the URL property. That way we can take the URL and register it in a web view or open it up in a browser or something. When we execute this query or just copy and paste this URL into the browser, you're going to see an example result that looks like this. All results coming back from Wikipedia have this base object that has the batchcomplete, the continue object, and then the result of the query if that's what the action was that we chose. We don't really need to talk about the batchcomplete or the continue since they're mostly about continuously requesting data and how we can handle understanding whether a request went through or not and how to create additional ones. We're not doing anything intensive enough to need that. The most important thing here is the result of the query object. Within that, we have the pages property, which is an array of these page objects. These page objects contain a whole bunch of properties. We see the pageid, the title, the contentmodel, the language of the title, the fullurl, and then the editurl and canonicalurl. These are some of the most important properties that we're going to need since we need the pageid to understand what pages are unique that we've collected and the fullurl to register it in a web view within our app.

Demo: Creating Wikipedia Models
So now let's head over into Android Studio and start creating our models. Before we do that, we'll go and browse the Wikipedia API and its documentation. We'll go briefly over the sandbox and execute a sample query. However, I'll leave it up to you so that you can go and play around with whatever you want and see what other type of queries you might want to build. We'll then create the models for the data we need and match it up to the sort of JSON we just looked at. Over at the Wikipedia API's main page, let's scroll down and look at some of the information they call out. We do get an introduction to the API, as well as a simple example. We learn more about the endpoint that's available, and we kind of get access to the rest of the resources that Wikipedia wants us to use. One thing you'll notice that we didn't just cover is that there is the option to use other languages within the Wikipedia API. We also learn a little bit more about the action and the format and some of the other actions' specific parameters. This is also where it goes into detail about identifying your client with that user-agent header that we talked about. It's important to follow this rule in order to properly identify our app within the Wikipedia API. Further down, we talk about API etiquette, which is kind of what we went over earlier. And, lastly, at the bottom, you'll get to your useful links to bring you to the sandbox. This is where we can play around with the options we have to build our queries. We'll leave the action here as a query that's kind of set to the default, and the props that will default to revisions. You can play around with some of these other options and some of the sub-options for a given property. You can also specify some detailed options within the format or within just the main action options. Clicking the Make request button will give you this giant JSON object just like we looked at before. However, in this version of the query, we do expect the revisions prop, which gets us the entire content of the page. We aren't going to be needing that in our app since we'll only be opening up the URL. Over in this other tab, I've executed the query that we just saw to get a single random article. This is the article detail that we're going to be using to map our models. However, in this JSON format, it's pretty ugly and hard to read. I personally like to use jsonprettyprint. com in order to make this JSON more readable. You simply copy any JSON object and paste it, and it kind of breaks it down line by line in proper spacing. Now that we have this object, we can kind of break down the individual models that we see. We notice that within the page, there's this thumbnail object that we're going to want. This is going to be the very smallest object we'll need to create, which then leads us to our page object, then our query object, and then our complete request/response object that contains all of it. We'll ignore the continue object since we're not going to be using it. However, for each of these other ones, we are going to want to create Kotlin models so that we make our lives easier when mapping the JSON to our data. Be sure to keep this JSON object available so it makes it easier to map the properties here to the properties in your Kotlin models. Let's move over to Android Studio and get started. Within our package, we're going to create a new package called models. This is where we're going to store all of our different models. And the first one we're going to create is this thumbnail. The thumbnail has three properties--source, width, and height. The source is the URL for the image, and the width and height are pretty obvious. So now we'll go and create a Kotlin class called WikiThumbnail. Within this, we're going to want to create those three properties for the source as a string, and then the width and height as numbers or integers. We'll keep the source as a nullable string in case the Wikipedia API returns us something that's empty. We'll also set a default width and height to 0, although these should be set by the thumbnail object returned to us from the Wikipedia API. Now let's go over and create our next model, which is going to contain all the data required for our page. We don't need most of these properties, so we actually don't need to create them in order to properly map them. Some of the most important ones are going to be the pageid, the title, and the thumbnail. There're a few other ones we might want, especially the fullurl, so let's go ahead and create properties for just the ones we need. We'll create a property called pageid, which is going to be a nullable integer. We'll then create one for title, which is again going to be nullable, as well as fullurl. The last of these properties we're definitely going to need to map is going to be the thumbnail image. Wikipedia stores that as an object that we just created the WikiThumbnail class for. So we can create a property of type WikiThumbnail. Now with that done, let's go and create our third model, which is going to represent our query that's returned. Don't forget to go back to the JSON object we were checking to make sure our properties are being mapped. We'll also be able to look back here for the other objects we'll need to be creating. So we've created the thumbnail, as well as the page object. So the next is that query date. So let's head back over to Android Studio and create that model we need for the query data. It's going to be a pretty simple model that just contains a list of the page objects we just created. Again, right-click on the model's package we created and pick a new Kotlin file called WikiQueryData. We'll switch it to class to save ourselves some time. Now we're just going to have the page's property, which is simply an ArrayList of the WikiPage we just created. We'll also instantiate it as the default empty list of ArrayList. That way we can add to it and not have to deal with the null checks. That's all this model really needs to be, so we're done here. We have one more to create, which is going to wrap the entire rest of the query. This is this whole object that represents everything we see here. Although we aren't going to be talking about the batchcomplete or continue properties, we do need to have the property for the query object that we just created. Let's head back over to Android Studio once more to wrap this up. Again on the left side in the Project view, we'll right-click on the models and add a new Kotlin file, and we'll call this the WikiResult. This is going to represent the actual result that we get back from the API as a whole. And the only property we need is query, so that's the only one we need to create, which is going to be a nullable WikiQueryData class that we just created, and it'll default to null. Again, a simple three-line class, and that's all we're going to end up needing. Now in combination with that, the WikiQueryData, the WikiPage, and the WikiThumbnail that we created, we can represent all of the data from the API that we need in order to create our data to use in our pages. Now before we head into the next module and start interacting with the Wikipedia data API, there's one more thing we can do to make our lives easier. We can create another model that's going to represent getting the URLs that we need for our different queries. Remember from Wikipedia's instructions, we need to be able to search for Wikipedia articles by text, and we need to be able to get random articles for the Explore page. However, creating a model for getting URLs isn't like what we just did for our models with mapping to data from an API. In this case, we're going to be actually generating a string that represents the URLs. In this case, we don't need a class, but we can actually use the new Kotlin object. We'll call it Urls and use this object to create two different functions for getting our two different URLs we need. An object in Kotlin allows us to create static methods that you might know from other object-oriented programming languages like Java. There's no sense of static in Kotlin. So we use this object to represent the data that we need to create these URLs statically. We have our BaseUrl that's going to be used to add these extra parameters for getting our extra URLs. We'll create a function called getSearchUrl that's going to return a string, and it's going to contain the BaseUrl plus the different properties we need. So we'll set the action to query, the formatversion to 2, the generator to prefixsearch, which from the documentation is what allows us to set the term that we're setting in to invoke a search on the prefix of content for either the title or the content within the page. We'll also set the gpssearch variable to pass in the term that we're setting, the limit to the take and the offset to skip. This allows us to pass in a query that uses a term and only takes a given amount but can skip a certain amount if we want to add pagination. We can use Kotlin string adding shortcuts with the dollar sign and the variable name. We then add in the properties for the pageimages and info, then the internal properties for thumbnail and URLs, the thumbnail size default to 200. We can also set the pilimit, which is a different way of restricting it for certain types of pages to make sure that we're definitely restricted within our take. We then choose what terms are going to be searched. And in this case, we have the description. We set our format, and then we set the inprop URL because we do want that URL to be able to render the page in our detail activity. All in all, this is going to build the giant string that we end up using to create our HTTP request to get the data that we want for searching for a bunch of articles from Wikipedia. This function can now be treated statically just like it would be in Java with a static function. So we can simply call Urls. getSearchUrl and pass in these parameters for the term, skip, and take that we need to get the output URL. Now let's create just one more function for getting the other URL we're going to need to get different types of data. In this case, we need to have a URL for getting random articles. This function is going to take an integer called take so that we can add scrolling and loading more within our Explore page. This allows us to set a certain amount of articles we want to take from the Wikipedia API. So, again, we'll start with our BaseUrl and start adding the extra strings we're going to need. We'll once again set the action to query. However, we are going to have some different parameters than the one above. And I'll just save you the time of having to add it here. So we have the format to JSON, the formatversion to 2, again, the generator to random. We also have some of the other properties that we saw from our example of getting a single random article. The only difference in this case is that we set the grnlimit to that take rather than to a static 1. This means we'll be able to get an entire set of random articles rather than a single one. We can pass in that parameter as any given value determined by how much we want for our random articles on our Explore page. This could even change depending on the type of device you're using, whether you have a tablet or a phone, in case you want to load more for a larger screen size. A good value might be something between 10 and 30 for this sake so we're not pulling down a whole bunch of data all at once. So now we have this static Urls file that we can use to get these different URLs. This, again, is a different type of model, but it contains these functions for getting data out rather than representing data that we get from an API. The very last thing we need to do is make sure that this properly builds. We can use the Cmd+F9 or go up above to the build and run Gradle build. This makes sure that our models are properly written, and we don't have any issues in our code.

Module Summary
By the end of this module, we've learned a bunch about how Kotlin models work. We've also compared them a bit to Java models and seen that Kotlin has done us a great duty of making our lives easier in writing less code and way more readable code. We talked about how we can map JSON to Kotlin models and how the property mapping seems pretty straightforward. We looked at the Wikipedia API, talked about the sandbox and how to break down queries to get what we want from it. And then we've gone ahead and created models for our Wikipedia pages, the Wikipedia page result, and the query result that we're going to need in order to create requests to Wikipedia, map them to Kotlin models, and then move ahead to using that data within our app. In the next module, we'll build up some services that are going to actually talk to Wikipedia. We'll take what we learn from this module and use the models we created to request data and use it. We'll be able to take that data and go use it in our interface to show that data to our users as they go through searching or getting the random articles within the Explore page.

Accessing External Data from Wikipedia
Module Overview
Welcome to another module of Building Android Apps with Kotlin. In this module, we'll be talking about accessing the external data from the Wikipedia APIs. We'll do a brief introduction into HTTP and learn about making HTTP requests, as well as a brief look at how we can connect to the internet in other ways. We'll start making requests in Java and then compare them to how we'll be making requests in Kotlin. We'll look at some helpful libraries and tools that are going to make our lives easier in building these requests and getting the data from the APIs. We'll also talk about how we can actually use the data from the APIs and map them to the modules we created in the previous module. Then we'll go ahead and update our Wikipedia app to go and pull data by creating a provider class that'll communicate to the API with two functions to search and get random articles.

Connecting to the Internet
Let's start talking about how we can connect to the internet in Kotlin with Android. There are three common ways we think about connecting to the internet from within our apps. We look at HTTP requests such as posting and getting data, creating bidirectional socket connections to our servers, and then creating custom or manual connections using TCP or UDP protocols underneath. Primarily within apps, we often see the use of HTTP requests to APIs or SOAP services or the use of web sockets. When building our app, we'll only be looking at HTTP, so we're going to focus on talking about that now. We can break down an HTTP request and how it's made from an app. The first thing we have is our device. The device for the client is responsible for building the HTTP request and configuring it in order to process it on the server. This means selecting the types of headers we want, processing a body that's going to be sent up, determining the type of method we want to use, and setting up other configurations. This request is then sent over from the device through the internet service provider. This could either be the Wi-Fi network the device is connected to, the LTE network, or any other data connection. This internet service provider is what helps us connect our request to a given server that we're trying to reach. That's done by mapping a URL to a server, etc. The server then takes the request from the device and processes whatever it needs. That might include communicating to different databases, applying some business logic, mapping models, etc. It's common to use things such as RESTful or SOAP APIs in order to process this data and set a standard. Once the data is processed on the server, it then returns an HTTP response, which contains other headers, as well as the response body. This is where we get the data that we need for the response that we receive. There are a few primary components to building an HTTP request from our apps, the first of which are the headers. These are things like setting the user-agent that we'll be doing later in order to help the Wikipedia API determine where our requests are coming from. This is also where you might specify the type of authorization tokens you're sending up or other simple data types. There's then the body, which is the beef of what's being sent up. In the case of what we'll be using in our app, this is basically going to be empty. However, if you were doing things like sending a request to create an object or update an object on a server, this is where you would put the body, which would likely be JSON data or XML data. There's then the method type. There're different ways to send data to an API over HTTP, and there are standards set for different methods that we can use. Here are some examples of these methods. We have the HTTP GET, POST, PUT, DELETE, OPTIONS, and PATCH. The names are pretty descriptive for what their roles are, and there are standards set for HTTP for what they can each do. GET seems pretty obvious. It's for retrieving data from a server. This means that we can optionally pass up a body which can be used to help filter. However, most people try to avoid setting a body and instead use either headers or additional URL parameters. A POST is intended to be used for creating an object. This means that we send data up and then receive a completed object back. Although that's the standard, you'll often see other APIs that use POST more often and don't necessarily return the entire processed entity back to you. There's also PUT and PATCH, which are pretty similar and are used for updating an object. Then there's DELETE for removing an object and OPTIONS for getting the types of things that we can do with a given object type. In the case of this app, we'll be really only using GET since we're not going to be creating any data and instead will just be getting data back from the API for searching and getting random articles.

Making HTTP Requests in Java
When we talk about making requests, it's important to look at the code we need to write in order to process it. We can compare how this is done in Java within Android and then look at how it's done in Kotlin. We'll start with a simple function called downloadUrl. The intention of this function is to take a URL data object, which is a Java type, and return the string data from the server URL. This in turn is going to create an HTTP request with the method of GET for a given URL and then process the data that's returned in the body of the response back down to a string. So this might either be something like an XML object or a JSON object, but simply wrapped as a string. This does not include the actual mapping of this string to a given object type such as the models we created. So now we'll go forward and look at what would be in the body of this function. We first need to set up our initial variables. We have the InputStream that's going to be used to send data up, the connection that manages our connection to the server over HTTP, and the string result that will be returned. With these, we now create our connection by calling the openConnection function on the URL object that's passed in. We can then set a read timeout and connect timeout just to make sure that we're not sitting endlessly. And we set the RequestMethod to GET. And we set the input to true in order to actually carry the response body over. And then we call the connect in order to open up the connection. Once the connection's open, we can call things like getResponseCode, which is part of the response sent back. This means that we can check to make sure that it's an OK response, meaning that the server processed things well. If it's not, we can throw an exception that says that the error code was whatever was passed back. After we've processed the responseCode, we then want to get the InputStream from the connection. This InputStream streams the response body that's returned form the response from the server. If it does not equal null, then we'll call readStream, which will return a string. After we've done reading the string, we want to make sure we close the stream and disconnect the connection. After all that, we can finally return our result. But, wait! We had that readStream function which wasn't built for us. In order to actually get a string from a stream object, we need to do a little bit of work. We created an InputStreamReader and process the raw buffers. We go over each buffer in the stream and add it to a new output buffer while making sure that we don't exceed the read size. After that, we can take that output buffer object in to string it and return that object. That's a lot of work to make something so simple. All we want to do is send a request and get data back. So we as application developers shouldn't be worrying about things like this.

Making HTTP Requests in Kotlin
It gets a little simpler when we talk about making HTTP requests in Kotlin. Kotlin does us a few favors with just the nature of its programming language. However, there's still some room to make some improvements. Luckily, we can fit this all in one slide here, and we're going to basically do the same thing. We have another downloadString function that returns a string from a URL. In this case, we don't need to do a whole lot to map the stream to a buffer or to handle the actual connection logic. We can use Kotlin's built-in with operator, which is going to help us handle the lifecycle of the URL connection, as well as the streams within it. This means that we don't have to worry about calling close or disconnect at the end since they'll automatically be disposed once we exit the with statement. So we can open up the URL connection and set the requestMethod to GET. Notice we don't have to set this on the actual request object since Kotlin automatically maps the request object to the current context that we're within. Instead, we just simply set requestMethod equals GET, and then we handle the BufferedRead to go pull down the data from the response. We then take the response and append it to an end object, and we return that toString, very similar to the readStream that we just looked at. That's a little better! We can fit it all in one processed function. It's easier to read. It makes sense. And there's not a whole lot of headache. Notice that in Java, we had to have comments for every line since they started to bubble up and added a whole lot of code to one section that might be hard to read if it's all in one place. However, this is only one part of the story.

Going from JSON Strings to Objects
We still need to worry about taking the JSON string that we received and actually mapping it to models or objects in Kotlin. In order to map JSON to objects, there're a few ways we can do it. We can do it manually. JSON is just a string, so we know it's a structure, and we can do it by mapping certain properties to other properties within an object. We can also use the JSONObject model provided by Kotlin and Java and do the mapping from there. You can think of this like a dictionary of strings, so we can map a string to a certain type within our model. Or we can fall back on some useful third-party libraries supported by things like Google or other third parties to make our lives a lot easier. Here're some examples of processing JSON. In this first example, we created a JSON object with the given string. In this case, we're using the same dog model example we did in the previous module. This dog is a simple JSONObject with a name of Bentley and the age of 4. From here, we can create the JSONObject by passing in the string, and then we can construct the dogObj by passing in the dogObj (JSONObject). getString and. getInt for the given property names. Then we can print out the properties for the structured dogObj. Now this is an example using a library from Google called Gson. In this case, we simply output the dogClass, and we call gson. fromJson, pass in the string and the class that we want to map it to. That's one line of code that kind of substitutes the rest of these four lines above. It also makes it a lot more readable.

Helpful HTTP/JSON Libraries
There're a lot of helpful libraries out there for building HTTP requests or mapping JSON or doing all of it. But here are a few of my favorites that I've used and have experience with going through building applications in Android. The first is OkHttp. This is a library built by Square and is widely popularized in the community. It's fast. It makes your code readable. It's very heavily supported by the community and by the Square developers. However, it just does HTTP. It's not going to help us with mapping models or anything like that. The next is khttp. This is a newer library that's also built around Kotlin. OkHttp was built originally in Java and is still supported in Java. However, because Kotlin is completely interchangeable with Java, they work well together. Khttp was built from the ground up with Kotlin itself and handles a lot of the features that Kotlin makes a lot easier. Because of this, it makes it very easy to use and is also well supported within the community. However, it's not as flexible as some other libraries, and just like OkHttp, it just focuses on the HTTP requests and not some of the other tooling we might need. The next library that's very popular is Gson. This is the library we showed previously to make mapping JSON objects easier. Gson's extremely easy to use and is great for mapping JSON objects to actual models. It's extremely well supported within the third-party community and by Google itself since that's the creator. However, it's really just doing one job, which is a good thing. However, it's not going to complete our needs in order to build HTTP requests and help handle modelling. The last one is Fuel. This is a brand-new library also built with a focus on Kotlin and Android from the ground up. It's extremely easy to use and is very friendly to read. This is a huge benefit especially for a new programming language like Kotlin whose focus is making our lives easier as developers. It uses a lot of the latest Kotlin features and also makes our code easier and shorter. Unlike some of the other libraries, it's very flexible and has some built-in plugins that we can use right out of the gate. This includes supporting Gson for auto-mapping results that we get back from the HTTP response. This means that we don't just have to get the string or get the object, we can get the string and map it automatically with Gson by creating a simple deserializer. So it will help us kill two birds with one stone and only have to import one single library. Here's an example of using Fuel with the Gson plugin to create an HTTP request. We have an example URL as a string, just someUrl. com/getDogs. All we want to do is make an HTTP GET request and map the response object to a dog. Previously, we'd have to handle all the URL connections, get the inputStream, map it to a string, then take the string and map it to a dog object either by hand or using Gson itself. In this case, we can do it all in a few short lines of code. We call the string. httpGet, which is an extension method written in Kotlin. Then. responseObject, which is another extension method brought to you by Fuel. We then pass in the type that we want to map it to, and we can optionally pass in the deserializer, which we'll be doing in our demo. And then we pass in a triple action in order to process the data that's returned. This action is what's called when the response to the server is complete and we have the data. These first two underscore (_) parameters we'll talk a little bit more about in the demo. However, these are the request object and the actual HTTP response object. And then the third is the actual result and the data passed down from the body after processing. With this result object, we can do whatever we want with that dog, or we can handle errors by checking the responseObject. This is going to make our lives a lot easier in building a simple, readable class to make requests to Wikipedia.

Demo: Creating a Wikipedia Data Provider
So let's go ahead and head over into Android Studio and implement Fuel to build HTTP requests and talk to the Wikipedia API that we learned about in the previous module. We'll add Fuel and Gson dependencies as part of our Gradle build, then implement a new provider class. We consider a provider class something that is used to provide data from an external source. This is just the naming convention that I prefer. However, you can name this whatever you want. And use this provider class to actually retrieve the data from Wikipedia and also handle some error checking. Then map that data to models automatically using the Fuel and Gson plugins and handle an action to return them. So let's head over to Android Studio and get started. Now that we're over in Android Studio, from the last module we completed this Urls object that we're going to be using to create the URLs to build our requests. Before we build our requests, let's go look through some of the libraries that are going to help us out. The first thing is going to be Fuel, which I mentioned previously. This is a pretty useful third-party library that is useful for building HTTP requests and mapping the data back from the request to models that you can use. It has a few different packages you can install for things like using reactive extensions, Moshi, Jackson, and Gson, which we're going to be using. They list here the different types of dependencies you can add to your Gradle build and also some documentation below. Feel free to read through the rest of this documentation on GitHub, which explains a bunch of different ways you can build your HTTP requests and send and receive data, as well as parsing it. For our app, we're going to end up including the base package, the Android package, and the Gson package. I've also pulled up Gson's documentation here from GitHub. Again, this is in Google's repository. This includes some documentation on how to properly install the dependency with Gradle or Maven, as well as links to other guides for their documentation and deeper dives. From here, we're just going to need to install the dependency since we're not going to actually be doing very much with Gson other than what's used in Fuel to map our models. So let's get started by adding these two different dependencies to our project. In Android Studio over on the left in the Project view, open up the build. gradle for your app module. If you scroll down in this big object, you'll see the dependencies section, which will likely already have a bunch of fields filled out for the different dependencies from the Android support libraries that we needed. This is where we're going to copy and paste from the documentation the different types of dependencies we need for Fuel. We can go back over to their GitHub and copy it from there. Scroll back up to where they show the Gradle dependencies, and we're going to need to make sure that we grab the base, the Android, and the Gson dependencies. We'll start by copying this over. And in this case, I'm going to use version 1. 9. 0. However, there may be a newer version. Make sure that you read their newest documentation or just use 1. 9. 0 since that's what we're going to be using in this course. I'm going to just copy this to make it a little bit easier for typing out the different dependencies and add some comments here so we know which ones are for which. We have our base, our Android support, and our Gson support. This is also going to automatically bring in its dependency for the Gradle package for Gson itself, so we don't need to add that separately. Now that we've added our dependencies, let's create a provider, which is going to be a useful class for getting the data through HTTP from Wikipedia. Creating the provider's package, and then add a new Kotlin file or class. We'll select the class and call this the ArticleDataProvider. The DataProvider name is just the convention I'm using to know that it is just for processing data from an external source, although you can really name this class whatever you want. You might notice a banner above that says that the Gradle files have changed since your last sync and to use the Sync Now button. We want to make sure we hit this to make sure our dependencies that we just added properly sync before we continue using them. So now in our ArticleDataProvider, there're a few different functions we're going to need to create. We need one for searching for articles and then another for getting random. However, before that, we need to create a subclass for the WikipediaDataDeserializer. This is what allows Fuel to know what they're deserializing the data with and what they're using to do it. This is where we could include Gson and create a deserializer that's going to use Gson to parse the string from the reader down to the object that we need, which is going to be the WikiResult model we created in a previous module. We override the deserialize function and then call Gson. fromJson passing in the reader and the type, which is the WikiResult Java class. Now that we have this data deserializer, we can actually simplify this using some of the handy tools from Kotlin. Rather than having to call in the body of the override function, we can simply call equals in the body. Since it was only a one-line function, we can save the bulk from the brackets and just use this equals operator. This is going to make our code easier to read going forward. Now that we have our deserializer, let's start creating our functions. We'll first create the search function, which is going to take a String for the term we're searching by and, again, that skip and take. These are the same things that are going to be passed into the URL. We get a reference to the URL's object and the function getSearchUrl and pass in these parameters. Now we can use Fuel's extension httpGet on top of the String URL, which is then used to call the responseObject function that takes in a certain deserializer, as well as an action with three parameters. We pass in the deserializer that we created, and then we create this triple action here. The third parameter is the result of the request. And now we have this action callback, but we're not really sure what to do with it. In order to do something with this action, we ourselves in our search function should pass an action to call back to. Here we can call a responseHandler, which is going to be another action that takes in a WikiResult. Now within this action response from the httpGet request, we can call our responseHandler. This result parameter is a Kotlin pair object, which means it has two object types within it--the data and the error. In this case, we need the data as a WikiResult so we get the value from it from the val pair processor. Then we take our responseHandler we passed in and call invoke by casting data to the WikiResult. So all in all, we get the SearchUrl, we call the extension from Fuel, we pass it in as the responseObject and get the result action, and then we pass that result action to our own handler. So now let's go and do the same thing for getRandom. We'll again add a responseHandler, but in this case, we'll be making the request from the getRandomUrl from our Urls object. Use the same deserializer and the same action result. We want to do the same thing and pass the data from the double to the data object that we need. In this case, we can see we can change the underscore to an error, in which case if we wanted to use the error, we can use that data. Same thing with the action. The first two parameters are the request object and the base HTTP response object. Since we don't need these, Android Studio gives us the dialog to rename it to underscore, which means it won't be processed. This can save us the reading time of having random parameters or variables passed around that aren't used so that we know that these objects aren't used in our action. However, we're smart programmers and should know that we need to handle our errors. In order to do this, we should rename the underscore for the response object to the proper variable name. From here, we can now check the response status code returned, and we can check to make sure that it's OK or 200 before we pass in our data. So we know that if it's not 200, we can throw a new exception that gives us a proper error message that we need. We'll go ahead and update to getSearchUrl function to do the same. So now we're using the response check and the result. However, we don't need any data from the request object, so we can skip it. There's one more very important thing we need to do, and that's to set the user-agent header. Remember back to the Wikipedia API documentation where they ask us to set a user-agent so that we don't spam their service. We can do this very easily in Fuel by setting the FuelManager. instance. baseHeaders and map the User-Agent to something custom. For our example, we'll set the user-agent to Pluralsight Wikipedia. However, it may be worthwhile to name this something unique yourself. Again, this is our polite way of letting Wikipedia know that we're making the request so that if we ever run into any issues, they know to shut off our service so that we can't overload their system and cause problems. Wikipedia's a free service, so we want to make sure that we're respectful. So now we have a class that wraps up making the HTTP request and mapping the data back to our models. We get to skip the Java headaches of making HTTP requests manually and mapping our data. We use two helpful libraries with Fuel and Gson, as well as all the helpful tools from Kotlin, such as our actions and triples and doubles in order to map our data more easily. With this object, we'll be able to make all the requests we need. Before we wrap up, make sure that it properly builds and that you don't have any syntax errors. We can do this again by hitting the Cmd+F9 or going up top to hitting Build and build the application. In the demo of the next module, we'll use this class to go get data from Wikipedia and start using it in our interface we created. We'll add the ability to search and show the search results below, as well as get random articles and show them on the Explore page.

Module Summary
By the end of this module, we've done a whole lot about learning about HTTP and how we can make requests to servers on the internet. We've compared how making HTTP requests in Java is to Kotlin, and we know that Kotlin's a lot better just as we've seen throughout the rest of this course. We've also looked at some helpful libraries and talked about some other ones that we aren't going to implement such as OkHttp, khttp, and Gson on its own. Instead, we've selected to go with Fuel, which is a great combination for making HTTP requests and mapping data through the Gson plugin that they've created. We've now updated the app to create a provider class to handle getting the data from the API. And in the next module, we'll be using the data that we retrieve to go and update our view. This means that we'll finally be able to go get data from Wikipedia and show it on the Explore page through the random article grabber. And we'll also be able to go to the Search page and actually let users search for articles by starting by entering the text and passing that over to the provider and returning the data to the view. This is going to help make our app extremely functional and is one step closer to completing our end-to-end, real-life application.

Adding Functionality and Data to the View
Module Overview
Welcome to another module on Building Android Apps with Kotlin. In this module, we'll be talking about adding functionality and data to the view that we created in our application. In this module, we'll be looking at how we can do things such as pass data between different activities, create data-driven controls such as RecyclerViews and how we update that with actual data. Then after learning a bit about this, we're going to head over into our Wikipedia app and set up our Explore page to use data from Wikipedia. We'll then set up the Search page to add actual search functionality and display articles. And then we'll set up the Article Detail page within the ArticleDetailActivity to pass information from the Explore and Search pages when an article is selected.

Communicating Between Activities
Let's talk about how we can pass data around Android applications. We'll also look at some examples using Kotlin and how to do this. There's basically a single way that we communicate between different activities when we want to start an activity and send data. The activity that's kicking off the next activity creates an object called an intent. The operating system itself takes this intent and invokes the data within it. This is then kicking off the new activity, and the new activity can then take data from that intent. The key is in the intent. So what exactly is that? Android defines an intent as an abstract description of an operation to be performed by the operating system. That's a pretty abstract description. The short version is that it tells the operating system that we want to do something. We can use these intents for a few different things like starting activities like we just talked about. However, this isn't the only purpose of an intent. We can also use it for broadcasting to BroadcastReceiver classes. This is useful for things like handling push notifications or allowing apps to communicate back and forth between each other. It's also used for starting Android services. Services are used for a bunch of different things, such as kicking off background tasks like syncing data from a server to the local storage within the device to make sure that the data is always in sync, down to helping kick off push notification receivers using the combination of services and BroadcastReceivers. So what exactly goes into an intent? When we build an intent, there're a few different components that we use. The first are actions, which is what the intent is actually going to do. There're a few different options that are built in to Android, and it is also possible to build your own. We then look at the data and category, which pairs well with actions in the sense that there are categories that intents fall under and actions that go within those categories so that they work together. Then there are the extras. And that's not just to say everything left over; extras in Android intents means the rest of the data that we want to pass in custom. This is how we'll actually be passing data back and forth to activities by creating a serialized JSON object and passing it in as a string to the extras of the intent. These three things together create an intent that's used to do things within the operating system of the Android. Here's a quick example in Kotlin of adding simple extras to an intent to start a new activity. The first thing we do is create an intent from the current context. This might be the current activity or the application context for the entire app. We then decide what the activity is that we're going to be assigning this to, which is the activity we're trying to move to. After that, we can start to put key/value data into the extras. We call that by saying intent. putExtra with a key and then the data that's going into it. There're a few different base values this can be such as strings, arrays of strings, integers, doubles, and more. Basically, all of the primitive types are supported with passing into extras. After we have our extras put into our intent, we tell the context to start the activity with the given intent that we created. You can also add extras into a bundle. Here's an example of putting the same sort of string message into a bundle rather than directly into the intent. Instead of calling intent. putString, we call intent. putExtras and pass in the bundle that has the putString there. Then everything is the same. We create the intent, add everything in, and then start the activity with that intent. On the flipside from the activity that is started from the given intent, we need to be able to get the data that's passed to it. We do this by calling intent. getStringExtra. With that, we use the key that was used to pass in from the original activity, and then we can get the string value that was passed. We can also do the same thing by getting it from a bundle if we call intent. extras. getString. Behind the scenes, Kotlin is doing a bunch of stuff here for us with the auto property mapping, which makes our lives a lot easier and makes our code cleaner. In Java, we'd have to call getIntent. getStringExtra or, if we're getting it from a bundle, we'd have to call getIntent. getExtras. getString and pass them all in as functions. This looks a lot cleaner and gets right to the point.

Data-driven Controls
Now that we know how to pass data between different activities or how we can use intents to create services and invoke background receivers, let's talk about some controls that also depend heavily on data within them. There're plenty of different controls that rely on data such as things like TextView where we can set the text to something, but in this case, we're going to specifically look at collection controls. These are things that use a collection of data and then within them manipulate subviews with the data collected within the collection, the first of which is a ListView. The name is pretty descriptive. It's a list of items. We can dynamically bind a collection of models to this and update a given view, as well as handle adding, removing, or moving different items within the list. Along with the ListView, there's the newer RecyclerView. This is Android's response to the ListView having bad performance issues with large collections and not being able to handle better layouts. The difference between these two is the way the RecyclerView handles data, as well as the fact that the RecyclerView is not dependent on being a list. You can use a custom LayoutManager to lay out the items in a way such as like a huge circle or a grid or something like that rather than a flat list. Because of this, in the community, we've basically stopped using ListViews. A RecyclerView can do the same thing, it's more performant, and it's way more customizable. So going forward and within our Wikipedia app, we'll only be using RecyclerViews to create our lists. We've already done that a little bit, but in this module in our demo, we'll be going ahead and actually adding the data to the adapters and handling the RecyclerView more dynamically. There're a few different components to a RecyclerView, and we saw a little bit of this in our demo. The RecyclerView relies on a ViewHolder, a LayoutManager, an adapter, and the data that's bound to it. The ViewHolder is responsible for handling the layout that each of the individual items within the collection are. This is where we'll actually be storing the information for a single card or a single list item view within our Wikipedia application. The LayoutManager is responsible for how the RecyclerView lays out the child objects. Again, this is for things like laying it out in a linear list or in some sort of grid or however else. It's completely customizable. The adapter is what handles binding the data to the ViewHolder in the RecyclerView. This is where we set and tell the RecyclerView how many items we have, what ViewHolder to use, and what data to use. Then, of course, there's the actual data, which in the case of our Wikipedia app would be an array list of WikiPage models. The way a RecyclerView works is pretty intelligent, and it helps our performance in a great way. Take this example of a RecyclerView. If we're scrolling down in the sense that the drag is coming from the bottom of the screen to the top, we're moving items out through the top, which is where our past views are. The way the RecyclerView works is that it takes the views that are not within the active view and throws them away. These unused views are then recycled, and then their dirty data is cleaned up and bound to new data, which is then pushed back up into the view. These means that we don't have to create a new layout every single time we want a new item with different data. This is the way ListViews used to work. Instead, we can minimize the number of times we have to create new views only to the number of items we require on the screen plus or minus a few to make sure that we don't have issues when scrolling quickly. The RecyclerView components break down like this. The two base objects within the RecyclerView are the adapter and the LayoutManager. The LayoutManager tells the RecyclerView how to lay out its items, and the adapter tells it what it's laying out. The adapter then uses the ViewHolder and the data in order to actually map data to the objects in the view to show what they need to. Then within the ViewHolder, there's the actual layout resource file that tells the ViewHolder what layout we're using for each individual view.

Demo: Adding Functionality to the App
So now let's head over to our Wikipedia app and start making some updates. In our demo, we're going to be looking at updating the Explore page to actually use the random articles that we can get from Wikipedia, which is going to mean we need to update the CardHolder, as well as the adapter that's used for that RecyclerView. Similarly, we'll go and update the Search RecyclerView within the search activity. This is using a different holder and a different adapter since it has a different set of data. Then we're going to update the ArticleDetailActivity to be able to receive a WikiPage passed to it from either the Explore or Search pages and render it within a web view. For all of these, we'll be able to load our data asynchronously. This means that while we're making a request to Wikipedia through our article data provider, our UI won't need to lock up since we can run it on a different thread and then update the UI when this thread finishes getting the data. Then, lastly, we'll add a nice, friendly pull-to-refresh to the Explore page. We'll use the swipe refresh layout from Android Support in order to add this functionality to our Explore page. This will allow the users to pull down in order to refresh the random articles they see in the first page. So let's head over to Android Studio and get started. Now that we're over in Android Studio, let's get ready to update our source code in a few different places. We're going to be updating our two different adapters for our article cards and our article list items, as well as our ViewHolders that are associated with them. With this, we'll be able to update our fragments in order to tie the data from our article data provider to our adapters to show this data in our RecyclerViews. Let's start by opening the ArticleCardRecyclerAdapter. Here we're going to add a collection of WikiPages, which is going to represent our dataset. This array list of WikiPages will be set within the fragment or activity that's updating with the data. Now we need to update our getItemCount function to return the size of the array list. This is going to tell the adapter when we update data to make sure that we know the amount we're going to be doing. Now in onBindViewHolder, we need to set up to actually update our ViewHolder with data. So in our CardHolder, we can set the WikiPage that's associated with it at the time of rendering. We can do this by calling a new function called updateWithPage, which is going to set the currentPage, as well as update the data within the view. Let's start by setting the titleTextView. text property to the title from the WikiPage model that we passed into this function. This means that every time we're going to be calling onBindViewHolder in our adapter when a new view is pulled in in the RecyclerView, we'll be updating that TextView with the title of the WikiPage associated with it. So now back in the adapter in our onBindViewHolder, we can call the holder. updateWithPage and pass in the page which is from the currentResults set at the position passed in from this function. With these updates, if we were to use this recycler adapter and set an array list of WikiPages, we'd be able to see the cards with an updated title. However, we still need to set the image, but it's a little more complicated than setting a TextView. Images are going to be pulled down from a URL, which means that we need to actually make an HTTP request to download it, parse it into a bitmap, and render that within the ImageView. That's a little much, and we as application developers can make this a lot simpler by using a very popular library to help us out. There are many options to use for third-party libraries. However, in this application, we're going to opt to use Picasso by Square. This is the same team that built the OkHttp library that we talked about in a previous module. Here we can add the implementation and change our Fuel from compile the implementation to match the rest of our pulled-in libraries. Since we updated our build settings, we should be updating our Gradle by syncing it. You can go ahead and click this Sync now and wait for it to run. Now that we've included Picasso, we can start making references to the library in our code. We can check to make sure the thumbnail on the page isn't null before we try to set it, and then we import Picasso and call with passing in an Android context, which we can get from our ItemView. Then we use the load function to pass in a URL and tell it which ImageView to load the image into. It's pretty simple to use, and it's really extensible to use in different parts of our application. So we'll be doing the same thing when we get to our other ViewHolder for our list items. So now our updateWithPage call updates the text and the image. The next thing to do is now use this new updated adapter within our fragment. We're going to need to get articles from the articleProvider, so let's create a private variable or property within our fragment for our articleProvider. Now let's set up another helpful function called getRandomArticles. This is going to be useful to reuse for when we add pull-to-refresh a little bit later. We can call our articleProvider. getRandom and pass in 15 or any arbitrary number you choose, and then add a handler here with the wikiResult. We're going to want to have this handler update our adapter, so we need to have another property for our adapter rather than setting it in the onCreate view. Now we can update the Explore recycler to use this property. And then in our handler, we can tell the adapter to update the currentResults with the wikiResult data that we get back down in our handler. This also takes it off of the UI thread and allows it to be called asynchronously so that it's not holding up the UI while we go and load objects from the server. However, because of this, we need to make sure that when we update the dataset in our adapter, we call it on the UI thread. We do this by calling activity. runOnUiThread, or if you're within an activity, you simply call the runOnUithread method and tell that what to do. In this case, we need to call the adapter. notifyDataSetChanged, which tells the adapter we need to start updating the views because we have new data. So now that we've done this for our card recycler and our Explore page, let's go do the same thing for our list items. Again, this will have an ArrayList of WikiPages that's going to represent our dataset. We'll update the getItemCount, and we'll also update the ViewHolder so that we can update it with a page. We can take what we used in our CardHolder and add it to our ListItemHolder to add a currentPage property, as well as an updateWithPage function. So let's do that now. Again, we'll check if the thumbnail's null, and we'll use Picasso to lazily load the image from a URL into the ImageView for the thumbnail. Then after that, we'll set the titleTextView's text to the title of the WikiPage that's passed in. And we'll make sure to set the currentPage to hold it. Now that we have our updated holder, let's go back to our adapter and update the onBindViewHolder override. This is going to do the same thing that we just did in our card adapter, so let's go ahead and grab the page from the currentResults and pass that into the holder's updateWithPage function we just created. So now every time we're using the ListItemRecyclerAdapter, we'll be able to properly update those ListItem views with the data for the WikiPage. So this is going to be used in our search activity, so we need to create a reference to our adapter just like we did in the ExploreFragment. Now we can get a reference to our recycler through the Kotlin auto-mapping and set the LinearLayoutManager, as well as the adapter to the adapter we just created. Once again, we'll get a reference to a new article data provider just like we did in the Explore page. The only difference is how we actually invoke this. We need to actually do something in the query's textSubmit function that we created a while back. When the text is submitted, let's call the articleProvider. search and add our handler just like we did before. We'll clear the results of the adapter and then back on the activity's UI thread, we'll tell the adapter that we have an updated dataset so that it knows to update the UI and rebind all the events. So, now we've got adapters that can update the proper views and bind the ViewHolders with updated data from Wikipedia, let's start updating our ArticleDetailActivity to be able to take in a WikiPage and update the web view that's within it. Here we're going to actually get a string extra from the intent and assume that it's going to be JSON. We can use Gson that was pulled in with Fuel to actually deserialize this string into a proper WikiPage model. We do this by calling Gson. fromJson passing in the string and then setting the class that we're going to be parsing it to. Just be sure you call getStringExtra and set it at the default getStringArrayExtra that Android Studio decides to tell you. So now we can take the article_detail_webview that was auto-mapped and call loadUrl from the fullurl property of the WikiPage that's passed in. We'll also need to add this useful handler I've pasted here to make sure we actually properly load the URL rather than calling over to the web view, which certain versions of the Android operating system will do. We do this by setting the webViewClient on the WebView and overriding the shouldOverrideUrlLoading and return true. So in order to actually pass that data over to the ArticleDetailActivity, we're going to need to add a click handler to our ViewHolder. We can do this in the init, or you can opt to do it in the adapter. We call the setOnClickListener and pass in the view. And from here, we're going to be building an intent like we just talked about. We build the intent for the ArticleDetailActivity, and we start to add the Gson string to the extras for that intent. We're going to use the variable page, and then we'll call the ItemView's context. startActivity passing in the intent. Now let's just copy/paste this over to the ListItemHolder since they're both going to be doing the same thing by passing the page that's currently bound to the ViewHolder into the intent to start the activity. So now that we have the new ArticleDetailActivity that can load the page from Wikipedia and the two item holders that can start that activity, let's go and add a nice pull-to-refresh feature so our Explore page to be able to update the random articles that are seen. We do this by wrapping our RecyclerView in a SwipeRefreshLayout from Android Support v4. We'll give it an ID and make sure that the layout, width, and height are match_parent, and we've wrapped the entire RecyclerView in it. Back over in our ExploreFragment, we're going to need to get a reference to this just like we do with our other controls. So we'll create a private variable or private property for our refresher, and within that, we'll be able to handle refreshing data and showing the refresher whenever our data's loading. So let's create that reference and find it by ID from the root view. Now in our getRandomArticles, we can tell when we're done to tell the refresher that it's done refreshing. This in combination with a listener for when the pull-to-refresh is invoked will allow us to load the content when the pull-to-refresh happens and hide it when the refresh is done. So let's add an OnRefreshListener and set the isRefreshing to true and call the getRandomArticles function we just created. So we set the refresher to true beforehand, get the random articles, and then when it's done, we'll tell it to stop. The next thing we need to do is move that app:layout_behavior into the refresher. If we don't do this, the refresher is going to lay on top of the toolbar. This is a nuance for using the Coordinator Layout with a collapsing toolbar in that the root element below needs to have that layout_behavior. Also now that we're actually making the request over HTTP, we need to make sure our AndroidManifest is updated to use permission with the android. permission. INTERNET. With the permission in place, let's make sure when the view is first created that we also call the getRandomArticles so that we load them right away when the app starts or whenever the ExploreFragment comes into view and is created for the first time. Then we can move the isRefreshing setter into the getRandomArticles and wrap it in error catching to make it one happy little function that handles all of the loading of the articles and showing it in the UI. When we catch an exception, we're going to want to tell the user that something went wrong. We can do this by using the AlertDialog. Builder and setting it to the activity setting the message and title and then calling it to build and show. So this means whenever we catch the exception that's thrown if we don't have a Success status code from the HTTP request, we can let the user know that something went wrong instead of just showing them empty articles. Now with all that together, let's run the app and see what we've got. The app quickly loads and renders 15 random articles while lazy loading the heavier images. We can pull down and refresh and get 15 new articles and have their images lazy loaded and cached. When we click on one of these, it takes us to the Detail page and loads the web view, and we can go and hit the search bar over to the search activity and search for things. In this case, we'll look up Kotlin, and from here, we can go ahead and click and also go into that ArticleDetailActivity and load that WikiPage that was just selected. So now our app is starting to come together with some real functionality. We allowed the users to get random articles, to search them and view them, and in the next module, we'll increase that functionality by adding offline storage to allow users to track their history and favorite articles. This means that whenever they close and reopen the app, they'll still be able to view their past history and their favorites right away.

Module Summary
In this module, we packed in a whole lot of information. We talked about different ways we can pass data between activities and how important the intent is within the Android operating system. We learned that we can serialize data into JSON using the Gson plugin we installed with Fuel to make it simple to pass data back and forth as a string and serialize and deserialize when we need it. We also talked about data-drive RecyclerViews and were able to update those within our app. With all this together, our Explore page is more complete, as well as our Search page and our Article Detail page. We're getting closer and closer to having a complete app. In the next module, we'll talk about how we can handle offline storage to help build our History page and our Favorites page. We'll look at some examples of local storage databases and implement a SQLite repository in order to store pages for our Favorites and History and then map them back through custom adapters to their RecyclerViews. This will allow our users to favorite articles, as well as track the articles that they've viewed previously.

Storing Local Data
Module Overview
Welcome to another module on Building Android Apps with Kotlin. In this module, we're going to talk about storing local data on the device itself separate from using external data like we did with using the Wikipedia API. So in this module, we'll take a look at what storing data really means within building Android applications. We'll look at some different ways that we can do this within Android with some of the stuff that's built in. Then we'll take a look at some libraries that use these different types of storage and make our lives easier as developers by wrapping some of the complicated code. Then we'll go into our Wikipedia app code and add some repositories and DBHelpers in order to properly store our favorited articles and our previously viewed articles into History and Favorites repositories.

What Does Storing Data Mean?
Let's talk about what storing data really means when we build Android apps. There're a few different reason why we might want to or need to store data locally. The first is performance. We can avoid making requests to external data providers such as over HTTP or web sockets by using offline data first. This means that our app can perform more quickly by using data rather than having to wait to make requests. The second is offline capabilities. Sometimes our apps still need to function and give our users a comfortable and fun experience even though they might not have an internet connection. This might be true for apps that are meant for syncing data when they're offline, for users that are using them in load data areas, and when there's no Wi-Fi. And, of course, this will also help us increase our better user experience. By storing data locally, we can increase performance and add offline capabilities, which in turn makes our users happier since they can do more and do it faster. The most popular way that this is done is by taking remote data access just like we've done in our Wikipedia app to the Wikipedia API and middleware it between talking to the pages. This is what it looks like when remote data is piped down two pages within our application. However, this process can take time since we need to wait for requests. So we add this sort of middle tier of storing certain data offline in order to skip having to call remote data every time. This means our pages can respond faster or load faster, and our users can enjoy their time in our app more quickly.

How to Store Data in Android
There's a slew of different ways we can store data offline in Android, the first of which is super basic file storage. This means we're simply writing to any sort of file we want. This is also a process that some of these more complicated ways of storing data use underneath the covers. The second is using the Android keystore built in to the operating system. This is used mostly for secure storage for things that need to be encrypted on the device. Then there are shared preferences. This is an encoded XML file within Android that our app has access to. This also allows us to open up these sort of offline sort of things to other applications within the operating system or to the operating system itself. This is different from keystore since the keystore is completely private to our application and is doubly encrypted. The next few ways involve more complicated data processes such as using relational databases. No doubt the most popular way to store relational data in Android offline is using SQLite, and that's also exactly what we'll do in our Wikipedia app. If your data doesn't need to be relational or simply can't due to its structure, your best bet is to use document databases or any other real NoSQL database. This means storing things like JSON objects or other serialized version of data that's not necessarily structured into separate relationships or separate buckets, but more in mass documents. Then, of course, there's custom storage where we as developers can build whatever we want. Android also provides us some APIs and tools to help us do this more easily. We can use the custom data provider from Android and talk to any of these different types of data stores and also do anything custom within it. When we store data in Android, there're three key places that we need to know where data might be stored or where we can control it being stored. There're internal storage, external storage, and public storage. The names sound pretty obvious for their purposes. The internal storage is the flash storage on the device. External storage might be SD cards. And public storage, although could be within internal storage or external storage, allows for that data to be shared between applications. It lives within a public domain in the operating system. Let's dive a little bit deeper into these different ways that we store in these three places. The first, of course, was the file storage, the most simple of all the different ways of storing data. This means that our app code within our Android application simply reads and writes to a file by its path using stream readers and stream writers. This allows us to put basically anything into any sort of file we want that could be something like a JSON file or a simple text file. It's super useful for customizing. However, there is a lot of overhead with writing to local files all the time and should be avoided if we can by using things like memory caching. The second is the keystore process. This is a process that doubly encrypts using the device key in the operating system itself and secures that data from within our application. The process basically looks like this. User 1 wants to store or retrieve information from the keystore. It tells the keystore what it wants to store or retrieve. The keystore then takes the device key and either encrypts or decrypts the data depending on whether we're writing or reading. That key is then used within the actual user store, which is a file in the operating system. This is then passing the data back through the keystore back up to the user. The next is the shared preferences process. This is very similar to the file process except that we're not in control of where this file is stored. Shared preferences are exposed through an API within the Android SDK. And it works by simply setting a value with a key, which is then encoded into an XML file. If we want to retrieve it, we retrieve it by a key. It's simply key-value pair data. Shared preferences isn't super useful for large datasets or complicated datasets since we don't want to store too much within a given key, and we have to wait for the encoding and decoding process within this XML file, which means our performance can be pretty bad if we're trying to do more than get simple values in and out. Relational databases allow us to store complicated datasets that have relationships to others. Here's an example where we have a user object that has a child type of location. It can also have many different locations within it called a one to many relationship. This user also has a one to one relationship with a given class, and the class has a one to many relationship with given sessions. A lot of complicated data coming from third-party providers is already built in a relational way since it's coming from some sort of SQL database behind the scenes. That's Microsoft SQL Server, MySQL, PostgreSQL, or any other form you want. Getting data in this sort of way, it makes it a lot easier on the client side to store it in this way as well. The second is document or NoSQL databases. The way this work is that the app code initializes a request to actually write to an encoded JSON file, similar to how regular file writing works. That process is then adding an index from the JSON file to either a memory index or another file index that's optimized. This means that we don't have to actually go to the JSON file and read and write all the time, we can then get that index data back whenever we need it and avoid multiple requests to the JSON file to keep our performance up to par. Then there's the next step with Android ContentProviders. Keep in mind, this isn't just a different way of storing data, it's also useful for connecting different data types into one simple ContentProvider that can be consumed by our Android app, although Android's documentation itself suggests not using a ContentProvider unless you plan to share that code within other applications or services in the Android operating system. So keep that in mind when you're going forward and building out applications using this. It's not just the one shot and pull everything in from different places. It has the potential to be shared. The basic process is that we talk back and forth between our app code and our custom provider we build. This custom provider can then talk to different storage types such as SQLite, encoded JSON files, file storage, or even to external data through HTTP or web sockets. Basically, it's meant to take a whole bunch of different data storage types and combine it into one place to get different data types.

Database Libraries
Now that we know all the different ways we can actually store these things, let's talk about some of the database libraries that make our lives easier for both relational databases and for document databases. Since most of the other stuff is baked right into the operating system, we don't really need third-party libraries to help us out. Relational databases are databases structured to recognize relationships among stored items of information. Like we looked at with our example, a user can have multiple different subtypes and be related to a single type on its side. Most of the complication here comes with mapping these types of relationships back to our Kotlin or Java models. We do this by using an ORM. Most of the libraries we're going to be looking at help us use their ORM in order to better map our objects or our models back to the serialized data within SQLite, the first of which is Sugar ORM. It has a few pluses, and it also has a few cons. It's extremely easy to use and is really well documented. It makes mapping our model super easy, and it's been around for a while. That also means that it was built in Java and not built on the Kotlin platform using some of the latest tools. It is also relatively slow in its performance compared to some of the other ORMs or other types of storage. It can also be restrictive, meaning that it doesn't have a lot of extensions that are built in or built by Sugar and requires third-party tools in order to build on it even more. Then we DBFlow, which is a library built by Raizlabs and made public on GitHub. DBFlow is extremely fast, and it is also componentized and has a bunch of extensions you can use. It also has a whole library for building your own extensions and has built-in Kotlin extensions. It was originally built in Java. However, a lot of it has been converted to Kotlin, and it utilizes a lot of the latest features that we have in our awesome language. This does mean that it has a larger overhead, especially compared to some of the super slim libraries, such as Anko. Anko was built by the Kotlin team. It's owned by JetBrains. It contains a whole bunch of other tools too. It's not just for SQLite. It has a Commons library which is used for things like async requests and other extra tools for handling threading. There're also some other Anko libraries used for toasts and other UI components. It's super componentized, which means we don't have to pull all of those things in with the library. If we just want the extra SQLite helpers, we can pull those in. But because it's built like this, it's not incredibly robust. It doesn't do a lot of the actual ORM work that things like DBFlow and Sugar do, but it does keep the library super small. Anko is what we're going to be using in our Wikipedia app in order to store our data offline. Onto the document databases. A document-oriented database, as a particular kind of NoSQL database, is able to 'parse' data and store it with basic key-value pairs. So a single document gets a single key and allows that whole thing to be indexed in order to keep our performance up to par rather than having to read and write to these massive documents. Some of the most popular you'll see also provide a lot of offline storage features or syncing features. However, we aren't going to be needing that, which is why we're going to stick to something slimmer and smaller such as using Anko, the first of which is Firebase Realtime Database. This is an awesome third-party database that was then bought out by Google. Firebase does do a lot more than just the database syncing. It handles push notifications and a whole bunch of other services as well. It's what Google's trying to push as a platform for building your mobile apps on. It's an incredibly robust platform and offers great features such as full offline syncing and extra storage. However, there is a data risk in the sense that you might be having your data go over Google's wire through Firebase rather than exclusively through your own, something to keep in mind when you're building enterprise applications that need extra security. The next is Couchbase Lite. It has similar offline data syncing and also allows you to build your own Couchbase server, which means you can go over your own private data connections for your offline syncing rather than having to rely on their own such as you do with Firebase. It has a ton of community support. However, because it is built to be maintained by yourself, it means you have to have a lot of overhead and server maintenance, plus the actual library itself is pretty large. The next is Realm, which is probably the biggest competitor to Couchbase and Firebase, and it's incredibly robust. It's also very fast with its data parsing and its offline syncing, and it does it in a very intelligent way to make sure that things aren't going over connections that don't exist beforehand. However, because this library does a lot and does it well, it has an even larger overhead than some of the other ones we've seen.

Demo: Create Favorites and History Repositories Using Anko
So now that we've learned a whole bunch on how we can actually use offline features in local storage within Android apps, let's go get started in updating our Wikipedia app. We'll go and add the Anko dependency and also look at some of the documentation they have. I would suggest reading a bit further into it because it does have a lot of features that we won't necessarily be using in this app that would be great to use in your future applications. From here, we're going to create a Favorites repository and History repository, which are going to be responsible for actually storing the Wiki article data into their proper SQLite tables underneath Anko. Then we'll create a WikipediaManager. This class is going to be responsible for talking to these repositories, as well as to our previously built article data provider. This article data provider mixed with our repositories through our WikipediaManager allows us to separate the concerns of our data logic from our business logic. The WikipediaManager can handle error catching and mapping things back to proper models that we want on the client side. It can also handle calling things asynchronously. It's always a good idea to separate your concerns and avoid monolith objects, which is why we're going to separate them this way. So let's head over to Android Studio and get started with adding some of these offline features in storage. Let's look over the Anko documentation from Kotlin's GitHub. Anko has more than just SQLite helpers. There're a few different particular libraries that we can add to our Android apps for the Commons, extra layout helpers, SQLite, and more. In this case, we're going to be adding two for SQLite and the Commons library. We can look at their documentation for some examples on how to make SQL queries using their ManagedSQLiteOpenHelper. This is a class that we're going to end up going to implement with our custom article DBHelper, which is going to be used to help us create our two different tables for our Favorites and History Items. So let's go into our Gradle build and add the two different Anko libraries. We'll add the org. jetbrains. anko:anko-SQLite:0. 10. 1, as well as the anko-common:0. 10. 1. There may be updated versions for your libraries, but 0. 10. 1 is guaranteed to work. Make sure you hit your Gradle sync and get started. Let's go ahead and add a new package to our app. We're going to call this a repositories folder. This is where we're going to add a few different classes such as our open DBHelper, as well as individual repositories for accessing History and Favorites items. Let's start with our first open DBHelper, which is going to be a Kotlin class. We'll call this the ArticleDatabaseOpenHelper. Make sure you select class and hit OK. The first thing we need to do is make sure that the base constructor takes in an Android context since the ManagedSQLiteOpenHelper is going to require this as well. Here we can also pass the name of our DB file, as well as some other options into the default constructor of the ManagedSQLiteOpenHelper. Now you'll notice some red squiggles over our name for our class, and it's going to tell you that we need to implement some of the abstract members from this helper. We can select both the onCreate and onUpgrade since they both need to be implemented, and they'll automatically stub out these methods below. Clean out these empty ToDos, and we can go ahead and fill these in. We can use the onUpgrade to upgrade the schema, which we won't have to do here, so we can go ahead and leave that empty. In onCreate, we're going to define our two different tables for our Favorites articles and our History articles. Here we're going to use some SQL helpers in order to set the table columns. We're going to need an ID, a title, a URL, as well as some thumbnailJSON. We can also set the type of data that these columns are going to be, which will be an INTEGER in the PRIMARY_KEY for ID and TEXT for the rest. Then make sure you copy and paste the rest to create the History table just like the Favorites table, but make sure they have different names. This is going to take the ArticleDatabase. db SQLiteDatabase file and create two different tables within it. So now we can go create our repository classes for our History and Favorites. We'll start with Favorites. And these repository classes are what are going to be used to actually access the data and make queries to get them, update them, or see if we have any at all. Separating this into custom repository classes makes it easier to contain this data logic. So now let's get started with this FavoritesRepository and set our default constructor to take in an ArticleDatabaseOpenHelper. Make sure you set vals so that we can use it throughout the actual class. We need to have a constants TABLE_NAME for Favorites so that this repository knows what it's talking to. And now let's stub out some methods to do the different actions we want such as adding a new favorite article. Here we can call the databaseHelper. use and then call insert to the TABLE_NAME and set the values for the different columns that we defined before. Passing in a page, we'll get the pageid, title, fullurl, and then we'll also get JSON data from the thumbnail. We'll follow this same sort of pattern for our other functions we're going to be creating such as removing a favorite by its ID. Again, we'll call databaseHelper. use, and this time call the delete function rather than insert. Then we can add a whereClause to tell the database which articles we want to delete. In this case, we'll delete ones where the ID column equals the pageId that's passed into the function. But don't forget to import org. jetbrains. anko. db. delete. Otherwise, you might have some issues with the two different overloads. Let's continue by adding another function called isArticleFavorite. There're a few different ways to implement this where you could use the databaseHelper. use and call the select and map that out. However, I want to show a different way that this can be done by pulling the items into memory and then filtering after the fact. This may be less performant depending on the situation of your SQL tables, but in this case, it won't really make much of a difference. So we'll create a different function called getAllFavorites, which will pull every single row in our table in order to help us parse it within memory rather than in in the query. We create a rowParser, which tells the database or more exactly how Anko should map the row from the database to a proper model. In this case, we want a WikiPage. So in our parser, we new up a WikiPage and then assign the properties back from the columns. So now back calling getAllFavorites, we can get all the pages as an ArrayList of WikiPage and then return only if the pages contain any that have the pageId that's passed in. This will tell us that we have a row with this pageId, which means that it is a favorite. And now with this, we have all the functions we need for our FavoritesRepository. We can add and remove them, determine if an article is a favorite, and get all the favorites that are stored. So now let's create our historyRepository, which is going to do largely the same thing but with our other table. Because of this, we can copy some of this code, and we'll go and change it later on since we're also going to need to add some new methods. It might also be good to abstract this into a base articles repository and implement it differently with the TABLE_NAME, but that's entirely up to you. For the sake of doing it quickly, we'll copy and paste it here. Again, we'll need to take in a databaseHelper in our constructor, and we'll paste in the existing functions. We'll need to change some names, as well as remove some of these. We don't need to know if an article is in History, so we can remove that. And we'll change some of the Favorites to History. And that's all we really need for this repository. So now we have both our History and our Favorites repositories with our DBHelper, which gives us a way to store our articles in two different tables.

Demo: Separate Business from Data Logic
Now we need to be able to handle managing this with some business logic. Our activities and fragments need to be able to call these functions. However, it's nice to add another abstraction layer to separate our data logic from our business logic and UI logic. Because of this, we're going to create a manager class, which is going to handle communicating to both our repositories we just created, as well as our provider we created earlier, which talks to the APIs of Wikipedia. So let's add a new package called managers, and within this, we'll add a manager for our articles. Select Kotlin File/Class, and we're going to name this the WikiManager. Make sure you set it to a Kotlin class and hit OK. This WikiManager is going to be taking in a provider, which is going to be the ArticleDataProvider, as well as each of the repositories we created before. We can set these to private vals so that we can use them as properties within the class right away. And now we can create some methods that proxy these calls to our provider and our repository. This allows us to handle things such as caching, which we'll do here. We'll create in memory favoritesCache and historyCache as a simple ArrayList of WikiPages. This means that in order to get our History or Favorites, we don't always have to hit SQLite, which is going to increase performance for our users within our app. So let's start wrapping some of our calls for our provider such as calling search and getRandom. We'll return our provider. search taking in the same parameters, and then we'll do the same thing for getRandom. These will both also take the actions for the handler and pass that proxy straight through to the provider. And now let's create some of our functions that are going to talk to our repositories such as getting History items. In here, we're going to check if the historyCache is null, and if it is, we're going to set it to all the History from the repository and then just return the cache. Then we can do the exact same thing for getting all Favorites. Now let's add a function for adding a WikiPage to the Favorites, in which case we're going to add a page to the cache if it's not null, and then also add it in the repository making sure that it's both stored in memory, as well as in the actual long-store data in our files. Then for removing a favorite, we're going to call to the repository to remove it by its ID and then update the favoritesCache to equal the favoritesCache filter where it does not equal the pageId as an ArrayList. This means that we're going to get a new ArrayList where none of them have the same pageId. Then we can check getIsFavorite by making a call to the repository. You could also add another caching layer here if you want, but I do want to demonstrate how we don't always have to use caching if we don't want to. Just like we had addFavorite, we can do the same thing for History, and then get all of the History items, loop over them, and remove them individually from the database. Another way to do this would be to update the historyRepository to have or remove all or a Clear function itself that could be called. However, I once again want to show some differences in performance and memory versus all in SQL. We'll get into this a little more in the next module when we talk about actually updating the UI and the activities and fragments to implement some of this. So now we have all our business logic wrapped in our managers. This is also a good place to add some extra error handling and return some smarter error results. In this case, we know our code is going to be relatively clean thanks to a lot of the extra helpers from Kotlin to help us check for null and make sure that we don't execute code that can't run. So now that we have our manager, repositories, providers, and DBHelpers, we need to understand how we can actually use these within our activities and fragments. One popular way to do this would be to make it static. However, we really want to stay with an object-oriented approach. Previously with actually using the provider itself, we simply new-ed it up within the different fragments. However, this is a little more complicated with the DBHelper since we don't want to have multiple instances that open up multiple connections to SQLite at the same time. We only want to deal with one DBHelper to use in both our repositories in order to properly make queries without breaking anything. A good way to do this is to use dependency injection with inversion of control. However, that subject is a little more complex than this course requires. So instead we're going to take a very similar approach without all the behind-the-scenes magic of reflection within Java and Kotlin. We're going to create a new Application class that's going to inherit from the Android app application. This class can be used to manage some of the lifecycle of the entire application outside of the scope of activities and fragments. This means that we can create a single instance that lives within the application and then get a reference to these within the activities and fragments from the application context properties on those classes. This creates what's sort of a singleton method but not technically since it does live within the context that we use in Android. It's not simply creating a static or a one-time single use. It stays within the lifecycle of the application. So what we're going to do is add these private properties within the Application class. These will be initially set to null, and then will then be instantiated within the onCreate of this Application class. We'll need to set up our dbHelper first and then our favoritesRepository, historyRepository, provider, and manager since the manager requires all of these together. We add our checks to make sure they're not null. If they are, we will obviously want to throw an error. However, they're clearly instantiated right above. So now that the application class uses all of these properties, we can get references to them from the applicationContext of our activities. So let's go update some of our activities and fragments in order to use this new method. We'll go ahead and delete the articleProvider that we were using, and instead we're going to have a private var wikiManager, which is going to get a reference within the onAttach of our fragment and then cast our current activity. applicationContext to this WikiApplication. And then we can simply call. wikiManager since that has a public getter. Then we can go ahead and update where we were calling our provider and instead call the WikiManager since our methods were named the same and take the same parameters. In order to properly secure our WikiManager to make sure no other classes are changing it, we can provide a private set within the property. The repositories provided in DBHelper are already fully private, so we don't have to worry about those. Now let's go and update the SearchActivity the same way we just did for the Explore fragment, except rather than instantiating our wikiManager in the onAttach, we're going to do it in the onCreate of the activity, and we can get the applicationContext property directly since we're already within an activity. Now let's go back and update some of our other fragments that we haven't quite gotten into implementing yet such as our Favorites and History. Let's go ahead and add another WikiManager here and instantiate it in the onAttach just like we did in the Explore fragment. You can actually go ahead and copy and paste this code from the Explore fragment since we're not going to need to actually use the WikiManager yet, and we'll be doing that more in the next module when we implement these offline features in our UI. So now let's go ahead and copy the onAttach here and move into the HistoryFragment where we'll instantiate the same property. Make sure you set up the property, but we can paste it ahead of time. Add the WikiManager so that we have all our references there, and then we're good to go on all of our fragments. The last thing we need to do is go fix the SearchActivity to make sure we properly update everywhere where the articleProvider was calling to use the wikiManager. So now our activities and our fragments are properly using the wikiManager rather than the articleProvider, which is going to set them up for using the offline storage as well. The last thing we need to do is update our AndroidManifest in order to tell the operating system the actual Application class we want to use for our application. We do this by setting the android:name property of our application node within the manifest. Make sure this properly builds, and then we're going to be good to go for our next module. In the next module, we'll take these new offline features of our repository and DBHelper using Anko and do some background asynchronous calls to the manager to then go and get data offline, show them within the RecyclerViews for the History and FavoritesFragments, and then also add the ability to add these and remove these from Favorites from a toolbar action within the ArticleDetailActivity. Within the ArticleDetailActivity, we'll also automatically add each viewed article to the History. This way, our features are going to be fully built out for our users, and the last thing to do is just a little bit of cleanup, which we'll also be doing at the end of next module. With all that together, we'll have our fully functioning complete real-world app for Wikipedia complete with HTTP requests to web APIs, offline storage with SQLite, and awesome controls within our UI that give our users a great and full experience.

Module Summary
Now that we've actually gone and updated our Android application, and we have some offline storage capabilities to store our Favorites and History, we're ready to move on to our next module. In this module, we talked about what storing data really means within Android apps and looked at all the different ways that we can do this. We talked about using file storage, key storage, shared preferences, relational databases such as SQLite like we used with the Wikipedia app, document databases for more complex objects that can't be relational, and how we can use custom providers to mass all of these types together into one shareable package. We also took a look at some third-party libraries that can make our lives easier when writing to either document databases or to SQLite. We chose to go with Anko because it was built by the JetBrains and Kotlin team and makes our lives easier without adding a huge overhead to our super-slim application. Now within our app, we can store our favorite articles and our previously viewed History articles. In the next module, we'll go and update the app in order to actually properly favorite articles from the UI, as well as add these articles to the History and show them in each of those lists. We'll then talk about some other subjects in Android development that you can study further or how to further advance your Kotlin skills.

Updating Views with Offline Data and Future Steps
Module Overview
Welcome to another module on Buidling Android apps with Kotlin. In this module, we'll be wrapping up our Wikipedia application by updating our views with the offline data from our repositories, then talking about some future steps you can take as an Android developer to learn more. In this module, we're going to do things a little bit backwards in the sense that we're going to jump right into Android Studio from the get-go rather than learning something new right away. We're going to go into Android Studio and add a new favorite button to the toolbar of our ArticleDetailActivity to allow users to toggle this article off and on in the Favorites. We'll then update the HistoryFragment and FavoritesFragment to update their recyclers to handle the articles that are pulled in from the offline storage in our repositories. Then we'll do a little bit of touchup to the UI to make sure our users have the greatest experience they can get out of our application. After this, our application will be done, and we'll move into talking about some future research topics to look at. Then we'll summarize what we've gone over in this course including everything we've put into our Wikipedia application and given over to the Wikipedia team.

Demo: Wiring up the UI with Offline Data
So let's head over into Android Studio and get started. We're going to start by creating that toolbar menu option and updating those fragments with their adapters. We're then going to allow users to clear their History with another toolbar option on the HistoryFragment. Then we'll update some layouts to make sure our UI looks great and is clean for our users to experience. Now over in Android Studio, there're a few different files we're going to be updating, the first of which is the ArticleDetailActivity where we're going to add the ability to add that article to the History using the wikiManager. So let's go into the ArticleDetailActivity, and we're going to need to add a private variable or a local property for the wikiManager just like we've done in all our fragments and our other activities. So let's get that reference and then instantiate it from the applicationContext in the onCreate. Now after we've loaded the page, this is where we can tell the wikiManager that we want to add the current page to the History. The wikiManager will take care of the rest of it and add it into the local repository. So now the next thing to do is create the menu option to add it to Favorites. And to do this, we need to create a menu resource that's going to be used in the toolbar. We'll call this the article_menu. Here we're going to go into the text side and add a new item, which is going to have both text and an icon. And, of course, we'll need an ID so we know what's hit. We'll set the icon to be the same heart drawable, and we'll make sure that we showAsAction always, which means it will always be visible on the toolbar. So now that we have this menu, we can go back into our ArticleDetailActivity and override a few different functions. We already have an override for onOptionsItemSelected in order to tell the activity to go back when we hit the Back button, and so here we can add another if statement for if the ID is the action_favorite to determine if the article is favorited or not, and then either remove it or add it to the Favorites. And, of course, we want to tell the user whether we successfully removed it or added it, and we'll do this by using an Android toast, which will show a little pop-up in the bottom. So if it was removed, we'll say the article was removed from Favorites. And if it's added, we'll say the article was added to favorites. We'll also want to add a try/catch on this to make sure that we don't have any exceptions. And if we do have an error that happens in the manager, we'll throw another toast to say we were unable to update it. So now we have our logic in place for when we select that item, but we need to tell the activity to use the menu that we created, and we do this by overriding the onCreateOptionsMenu. We then take the menuInflater that's passed in and inflate the menu by its ID. And with those two overridden, we now have our toolbar button set up, and the last thing to do is update the toolbar's title with the page title from the WikiPage. This is just going to make our ArticleDetailActivity look a little bit finished. The next thing to do is now go and update the actual FavoritesFragment to show the Favorites that we have from the wikiManager. We're going to do this by creating our recycler adapter just like we did on the ExploreFragment, and then we're going to update the RecyclerView with it. We're also going to then in the onResume override go get the Favorites from the wikiManager and add those into the adapter that we're creating. So let's create a private property for this adapter, and then of course in our RecyclerView, we're going to end up setting it. And now we can override the onResume function. And here we can use Anko's helpers to do things asynchronously. This is going to call outside of the UI thread, which means when we actually get Favorites back and we want to update the adapter, we need to run it back on the UI thread. So we'll get the Favorites, clear the adapter, and then all them all, and then we'll call activity. runOnUiThread and notify the dataset has changed within the adapter. The doAsync is part of the Anko Commons library and is a great tool for making asynchronous requests. Over in History, we're going to do basically the same thing, but rather than pulling in the wiki Favorites, we're going to be pulling in the wiki's History. So let's go copy and paste that onResume since the logic is going to be basically the same. Again, we'll continue to use Anko's doAsync rather than using callbacks like we did in our Provider class. And we'll just switch out the getFavorites for getHistory, and this will be good to go. The next thing we need to do is create the menu option in the HistoryFragment, which is going to give the user the ability to clear their History. So just like we did for the ArticleDetailActivity, let's create a new menu resource and add an item here. You can grab an icon if you want, but in this case, we're going to show that you can just use text in the fields as well. So we'll give it an ID, a title, and again we want showAsAction always to make sure it stays in the toolbar. Now just like we did in the ArticleDetailActivity, we're going to need to override those two functions in order to properly update the support toolbar. So we'll override onCreateOptionsMenu, and we'll inflate the new menu that we created and the menu that's passed in. Then onOptionsItemSelected, we'll check if the itemId is that new action or the ID of the item we created. And then we're going to want to show a confirmation dialog to the user. We can do this by calling activity. alert and give it a title and message. Since this action is going to be doing something dramatic to the user's data, we want to give them the ability to confirm whether this is the action they want to perform. So in the activity. alert, we create the yesButton function override, and we can also create the noButton function override. And this is how we handle what's done when Yes is hit or No is hit. So if Yes is hit, we want to clear the adapter, which means we want to wipe out the local data. Then in the background, we want to clear the History by calling doAsync using Anko. And then back on the UI thread, we'll come back and notify the dataset change. And then we can also ignore creating a noButton and do nothing within it since if No is selected, all we really need to do is close the dialog. So now I'm back over in the FavoritesFragment, let's make sure that we properly set our recycler's adapter. And then also back on the HistoryFragment, we want to make sure that the historyRecycler's adapter is set to the new private adapter. This way when we're updating our data, it properly updates on the UI. So now let's see what we've got. So once the app loads, we'll go and check out the History and FavoritesFragments and then go and view some articles. We'll notice that Favorites is empty, and History is as well since we haven't viewed anything since adding this feature. So let's go select some articles and try to add them to Favorites and also add them to History. We can see our toolbar option and click it, and the toast pops up that it was added. Now if we go back, however, we'll notice that we have that new Lewis County, Idaho showed up since we selected it, and it also shows up in our History. We can select a new article and go back and view that in our History. However, there are some current issues with this setup. If you're clicking around your own app a little bit more, you might notice a few issues such as clicking Favorite twice, we're not successfully removing articles. There might also be some issues with getting the initial load of data before putting it in the cache. I want to make sure that we look at how we can test our app fully and notice that we have some issues. This way we can go back and debug what's going on, and it's especially important to keep an eye out for caching issues. In this case, we actually have some false positives from our caching. We're able to get articles from the cache within our manager for both History and Favorites. However, we're not able to get them from the repositories. Things are obviously added correctly the first time. However, the cache is not properly loaded.

Demo: Smoke Testing and Bug Fixing
Let's go through the app once more and confirm some of the issues we might have seen. If we click on a given article and add it to Favorites and then go and try to remove it from Favorites by clicking it again, you'll notice that the same toast happens twice. It says that the article is added to Favorites, which shouldn't be true since it's already there. We'll also notice that we can't actually load Favorites in once we've obviously added or removed one. This seems to be an issue with properly getting the articles from the repository. It seems like the cache updates properly in the sense that we were able to add it and then remove it. However, we aren't able to get them initially. So now if we go and add it to Favorites without hitting it again and getting that fake added to Favorites, we do successfully see it in the list. So let's go take a look at our repositories. That's probably going to lead us to the answer where things are going wrong. The first thing we can do is open up the FavoritesRepository and look at the getAllFavorites function since this is what is being called within the isArticleFavorite and then filtered in memory. We created our rowParser and have our empty ArrayList of WikiPages, and it seems like that's all that's being returned. We're not properly using the rowParser. So in this case, we need to call to the databaseHelper. use and then use the select function and pass in the parser. We then copy and paste the same thing over into the HistoryRepository since it's doing the same thing in getAllHistory. So now we're properly using our rowParser and calling to the database to actually update it. So now let's go and confirm that the changes we made actually solved the issues that we saw. Since memory caching is such a popular practice within mobile development, it can cause so many issues, and it's important to make sure that we can track our caching, as well as our actual repository work. This is a real-life example of how we might have issues and track them backwards using our own logic that we built out. So let's go confirm that everything's working now. We should see our articles in our Favorites right away since we have them stored in memory. So that looks pretty good. We can then go into one and hit the Unfavorite, and we see that the article is successfully removed and then can be re-added. You can click this as many times as you want to see that the article is properly added and removed back and forth. And now after removing, it is killed from the list once we go back in, which is great. So this seems to be working, and this seems to be the fixes that we needed. However, there are also some apparent UI issues that we're going to want to take a look at. You might notice the cards being clipped underneath the BottomNavigationView, as well as just how bad the cards look if the images are too small, or even if we're getting full-size images, we have so much space on the sides. This isn't a very attractive user experience, and I think we can do a bit better. Let's start by going to our ExploreFragment and updating our RecyclerView. Here we're using a LinearLayoutManager to lay out our cards in just a vertical fashion. Instead, let's use the StaggeredGridLayoutManager. This is a layoutManager give to us in the same library. And in this case, we give it the spanCount of 2, and we want it to lay it out vertically. We'll do the same thing on the FavoritesFragment. The StaggeredGridLayoutManager is what is often referred to as a Pinterest style layout in the sense that it's going to fill in these cards with whatever space it can with the number of columns that we have for spans. In this case, we picked 2, but you can pick any number you want and see what it looks like. Now let's go fix that issue with things going behind the navigation view on the bottom. You notice that we have the same issue originally up top, and we fix it by adding a layout_marginTop to the actionBarSize. So let's do the same thing by adding a layout_marginBottom. We can also make our BottomNavigationView look a bit better by giving it a background color white so that it stands out a little bit more from the off-white background of the page behind it. This will also help with showing a bit of the elevation and the separation from the toolbar, BottomNavigationView, and the cards that are going underneath them. All in all, this is going to make our view look a whole lot better. The last thing we can do is clean up the card item itself, and we can do this by adding a little bit of margin or padding in our LinearLayout or around our ImageView and TextView. This will help make things look better if we don't have an image or if we do have an image and it's a bit smaller. So let's add a marginTop to our TextView and also add a margin in our LinearLayout to give some space within the card itself. This is going to look a whole lot better. And now we can go run it again and see what this looks like. Select your device and go ahead and hit OK. And then we'll move over to that device and see what we've got. You'll right away notice the difference in the LayoutManager from using LinearLayoutManager to StaggeredGridLayoutManager and how much better this looks if we have cards that aren't filling their entire space, especially if we go ahead and get random and a lot of them don't have icons. The same thing looks pretty good on Favorites. And the more we fill this out, the more it will fill in the space on the sides. Our original ListView. Items already look pretty good since the thumbnail size seems to match that a bit better. Now our users have a much better experience on the Explore and Favorites, and the cards themselves are no longer getting cut off at the bottom. We can scroll all the way to the bottom and see that even after the images load, we have space. We can still now add and remove items, view them in the Favorites, and then go into History and view those as well. However, you may have noticed one more issue. If you go to the History tab, we don't have the Clear toolbar option that we created. Where did that go? We did the proper overrides for onCreateOptionsMenu and onOptionsItemSelected, but where did it go? It turns out that this is what we use in activities, and there's one extra step we need to make sure we take within our fragments to update the activity's toolbar. So let's head back into Android Studio and fix that real quick. Anywhere in the constructor or initialize or even in the onCreateView override, we need to setHasOptionsMenu to true. This will tell the parent activity of the fragment that we're going to use this fragment options menu rather than the parent one. So now let's go ahead and run this and see what differences we have and make sure that we can actually properly clear our history within our app. This will wrap up everything we need to test since we'll be able to add and remove items from Favorites and then add and clear items from History. So let's go ahead and preload our History with some new items since we completely reinstalled the app. We'll just go and add a whole bunch of these articles by viewing them initially. This will properly add them to History, and we see that by viewing them on the list. And now we can hit the Clear option we see in the top and view our dialog. If we hit Clear, nothing happens. But if hit OK, we should see that our items are cleared locally, and if we go back to History, they're no longer there. So now all three of those main pages work together, and everything is syncing properly to our local repository using Anko and SQLite and is updating all the way through our UI.

Future Research Topics
Now that we've finished building the Wikipedia app using some real-life examples of offline storage, real-life API data, and Material Design for our UI, let's talk about some future research topics that might be useful for you as an Android developer that we weren't able to get to in this course. The first is inversion of control and dependency injection. We mentioned this a little bit earlier when we talked about how we can properly separate our concerns for our business and data logic. This is a design pattern that's very common in Android application development and takes that sort of separation to a new level. The next is app linking, which is used in two ways--to either receive data from a given link or send it out to another application. This is a means for two different applications within Android to talk to each other and is very common when building Android applications, especially at an enterprise level. This sort of process could be incredibly useful in our Wikipedia app by allowing our app to read Wikipedia links and showing them in the Wikipedia Article Detail page. Then, of course, there're hardware integrations. This takes steps towards learning how to use the camera in the Android device, as well as other things such as the gyroscope and other hardware components. Then there's the system drawing level. It's important to know what's actually going on underneath when we build our controls out that are built for us. Learning how to use the drawing interface as an application makes it a lot easier to build custom controls in the future. If you're interested, there're also plenty of topics on game development in Android where Kotlin is becoming more and more prevalent. It might be worth looking up if that's something that's interesting to you. Of course, there're also push notifications, which we weren't able to build into the Wikipedia app, but many applications use themselves. There're plenty of tools and plenty of different topics to look at such as using Firebase rather than Google Cloud Messaging, as well as some other newer versions of using Android push notifications. Another common thing that's used in Android applications is background data syncing. We mentioned this a little bit when we talked about Android intents and how they are used with different background syncing services. These types of services allow data to be background synced to the device in your application without having to have the app running itself. Next is content providers, which we talked about pretty briefly in the SQLite module. Content providers allow you to package up different places where you're getting your data and allow other applications to use it to get access to those data types. This is also very common when applications are communicating to each other right alongside app linking. Of course, there's always web sockets as well, which is an alternative way to connect to the internet rather than HTTP requests. If you want to do stuff in real time, you'll more than likely be working with web sockets within your Android applications. There's also Android widgets, which is something that's pretty proprietary to Android development from any other application development. Widgets live outside the scope of the application running itself and have their own lifecycle. This allows you to build components that live on the user's home page on the device. Then there're wearables for Android Wear and Tizen if you're using Samsung devices. And it's a great experience when using your Android apps to communicate to different wearable apps on those devices. And, of course, there're always ways to increase your Kotlin skills to make implementing all of these different types of services even easier. Kotlin's a growing and expanding language, so it's important to stay on top of a lot of the changes that come out. And, of course, right alongside Kotlin, Android is always changing too. It's important to never stop learning new skills, especially as new features come out for the operating system and new devices come out with new hardware or new tools that allow us to build better apps.

Course Summary
So we just went over a list of a whole bunch of different things that we didn't actually learn or go over in this course. However, it's important to look back and realize all of the things we put into this Wikipedia application and everything we learned along the way. When we look at the application we built, there're a lot of different mini-components that we learned about and put into it. We take the center of our application, and inside it, we created activities for some of our different pages. For others, we created fragments that live within these activities, and we also learned about how these two play together and their lifecycles. We also learned a bit about Android resources even though there's a little more we could have dived into. This is for things like our layouts and drawables and menus and styles and colors and everything else that we used within our app. We also built in using HTTP requests to talk to the Wikipedia API using Fuel. Outside of using that external data, we implemented SQLite using Anko, two things that look a little different, and Anko also extended outside to just the use of SQLite, as well as to make asynchronous data processes. We looked at a few other ways to make asynchronous calls outside of Anko such as using callback handlers like we did in our provider. These two ways are pretty unique to Kotlin and allow us to use new tools to do things a lot more cleaner rather than the old async task ways of doing it in Java. We also added in Picasso image loading for lazy loading images. This is important for increasing the performance of our app, which is another topic that we also talked about. Our app is fast, slim, and easy to use, which is always a plus for our users. We also talked about Kotlin models and how we can handle mapping data back to them. We then talked about taking those models and adding them to navigation between activities and how we pass data back and forth. We also learned a whole lot more about RecyclerViews and implemented them in a bunch of different places in our app. RecyclerViews are a very common control on Android, not just in the application we built, and it's important to know how to use them properly to make sure our app is incredibly performant. We then looked at Material Design and a lot of the controls built for us by the Google team to make our UI great for users. We, of course, used the actual Wikipedia API hand in hand with those HTTP requests, which is important for learning how to use external APIs, or if you're going to build your own, how to consume them on the client side. With that, we learned about JSON parsing and mapping that data back to our models using Gson. And, of course, there's a whole lot more that went into this. We learned how to use Android Studio and, of course, we talked a whole bunch about Kotlin and some of the great features of the language that help us build applications faster and better. We used Kotlin to keep our code clean, short, and to the point, that's more readable for other developers that might be joining our team and building apps with us. And, of course, with all of this together, Wikipedia loves this new app we've built for them. We were given at the very beginning basic wireframes and basic needs of each of these pages, and we ended up building something incredible. Take, for example, our Explore page that we received. They simply wanted a list of articles, and we were able to give them that with a great UI that didn't sacrifice performance and didn't sacrifice dither images by using this new staggered layout. We built the History page, which loads data offline and keeps track of the articles the user viewed previously. We, of course, have our Favorites page to allow users to view their favorites and go back into them and remove them if they want to. We have the Search page for searching articles, which, of course, is functional and great. And we have the Detail page that loads it and allows users to toggle that Favorite off and on. In the end, we learned a whole bunch of great things that are going to help us as developers do better in building Android applications. We created a foundation of both Android and Kotlin building blocks on their own, as well as how these two work together. We then used examples of ways to implement these concepts such as actually using Anko and SQLite to store data offline or building HTTP requests to talk to the internet. We then looked at a whole bunch of helpful tools and third-party libraries to make the implementation of these concepts even easier and help us in our development process by focusing on the business needs rather than the little nitpicky things that go into Android application development. And with all this, we have a functional and working real-world application that we can use to reference as we go forward in building great applications on the Android platform. And, of course, all along the way, we used Kotlin as the newest means for building Android applications. We saw side by side how Android is built better in Kotlin than with Java. We keep our code cleaner, more readable, and more functional by using this newer platform to build our applications upon. Thank you for joining me in learning about building Android apps with Kotlin. I'm Alex Dunn, and I'll see you in the next one.

Course author
Author: Alex Dunn	
Alex Dunn
Alex Dunn leads the mobile development team at EF - Education First and is a Xamarin and Microsoft MVP. His background in mobile application development has leaned into enabling applications to do...

Course info
Level
Beginner
Rating
3.9 stars with 31 raters(31)
My rating
null stars

Duration
3h 44m
Released
22 Jan 2018
Share course