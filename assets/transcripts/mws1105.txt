Making a Web Form Accessible
by Fiona Holder

Web accessibility is more straightforward than you'd think. This course starts with an inaccessible web form and steps through each of the changes necessary to make it accessible, including an introduction to testing with free screen reader software.

Web accessibility can seem like a daunting topic, but it's actually fairly simple to make improvements and meet the guidelines with some small changes to your HTML and CSS. In this course, Making a Web Form Accessible, you'll be starting with a fully-functional, but inaccessible web form for booking a room at a hotel. You'll walk through the minor changes required to make it fully accessible. You don't need to have any prior experience of making a website accessible, just a good understanding of HTML, CSS, and JavaScript/jQuery and you're ready to go. At each step, you'll be shown what the issue is, a straightforward way of resolving it, and the improved outcome. Never used a screen reader before? You'll see how to get started with the free NVDA screen reader to see your site from a different perspective. You'll also learn about WAI-ARIA (a specific kind of HTML) and how to fix the form validation. By the end of this course, you'll know how to create a web form that is vastly more usable for everyone, and still just as stylish as when you started.

Course author
Author: Fiona Holder	
Fiona Holder
Fiona Holder is Director of Software Development at Xibis Ltd, an innovative web and mobile application development company. She primarily works in C#,ASP.NET MVC, JavaScript, CSS, and HTML5,...

Course info
Level
Intermediate
Rating
4.9 stars with 46 raters(46)
My rating
null stars

Duration
1h 47m
Released
21 Apr 2016
Share course

Getting Started with Keyboard Accessibility
Introduction
Hi, I'm Fiona Holder for Pluralsight. In this course I'm going to walk you through the step-by-step process of making a web form accessible. Our first module is getting started with keyboard accessibility. But before we dive right in, I'm going to discuss what we mean by accessibility. The W3C site states that web accessibility means that people with disabilities can use the web. Just like adding a ramp into a shop instead of steps, there are changes that we as web developers can make to better accommodate the disabled. Saying that, I prefer the BBC's take on accessibility, which is the word used to describe whether a product can be used by people of all abilities. This isn't about disability, it's about usability. I mentioned adding ramps into shops to allow wheelchair users in, but when we add a ramp, it isn't just wheelchair users who benefit. Parents certainly have an easier time not having to struggle up steps with a baby. This is exactly the same with web accessibility. By accommodating the disabled, we make life easier for everyone and fewer people have to struggle. If you need any more motivation, it's clear that no matter what the purpose of your website, the more people are able to use it, the more successful it will be. More people will be able to buy your products, book into your hotel, even just read your company blog, but it's all good news for your business. So in this course I'm going to introduce you to our case study. This is an example website form which is fully functional but not very accessible at all. Throughout the rest of this course, we're going to update this form to solve all of its accessibility issues step-by-step. The first thing we'll tackle is a few of the keyboard accessibility issues in the form, so that it's usable without a mouse. In the second module I'll introduce you to the NVDA screen reader and show you how to use it. We'll solve some issues that the site has when navigated with a screen reader. Then I'll introduce you to an HTML enhancement called ARIA, which will make our form even easier to understand for screen reader users. The web form does have client-side validation, but it's not very accessible, so we'll update it to be much easier to follow. Finally, we'll clean up a number of general usability issues with the site resulting in a much more accessible web form. In total during this course we're going to resolve 22 accessibility issues with our web form. That's a lot for what is basically a single page of a website, but they're mainly straightforward fixes. So why have we got so much work to do making this form accessible? Picture a team that have just built a house. It looks great, everything seems to be working fine and the finishing touches are being made for a family to move in. Then someone shows up and says, oh didn't we tell you that they have a pet elephant that needs to sleep in the front room? The builders are up in arms and they're going to have to move the tree, they're going to have to widen the doorway and make a whole host of changes to this house. In the end they have something that isn't perfect, but it does the job. The doorway's a little odd and moving the tree wasn't easy, but the elephant gets his room. If the builders had known about the elephant from the start, it wouldn't have caused anywhere near as many issues and it should've been factored into the plans all along. This house, where the elephant was considered at the planning stage, is much more suitable. This is the same principle as developing accessible websites. Too often accessibility is seen as a phase two, nice to have requirement, and when the developers start on it, they find themselves having to redo some existing work. It's a pretty frustrating process. It takes a lot of time. This course will show you the 22 tweaks we need to make to our case study. But as we go through, keep in the back of your mind that most of the cases just having considered accessibility from the start would've reduced the amount needed significantly. As developers it's our responsibility to ensure that the accessibility doesn't start in phase two. It's an easy sell to management. More people can use the website and the costs of considering accessibility after the first launch will be much higher than starting with it.

What Disabilities Are There?
So what kind of disabilities should we be accommodating for as web developers? First, there are physical disabilities. People may have limitations of muscular control, joint problems or paralysis. Going back to the point that accessibility can help everyone out, this also applies to people with short-term issues too, like broken limbs or even someone trying to use a website while holding a baby. These are likely to result in people navigating a website with the keyboard alone or a device that simulates keyboard use. We need to ensure that this is possible and that users don't need to use a mouse to achieve certain tasks. Some users may be okay using a mouse but lack finer motor control. This often applies to elderly users. We can help them out by not putting buttons and links too close together to prevent accidental clicks. There are various different types of color blindness, but they all essentially mean a difficulty to differentiate between colors. What this means is that we shouldn't use color alone to convey information like saying that the labels in red indicate required fields. Users that are deaf or hard of hearing needs captions on videos and other audio-based content. This is one of those things that may be useful to everyone else too. Maybe if they're using your site in a noisy environment or they have to work in silence. Visual disabilities are a wide spectrum from mild vision impairment to total blindness. Someone with a minor impairment may want to increase the font size on your site or use a magnifying tool. For severe impairment and blindness, a lot of users use a screen reading tool or refreshable Braille display. A screen reader doesn't just read out the entire web page from start to finish. They're sophisticated pieces of software that read out content and allow the user to navigate and interact with the page using keyboard commands. Later on in the course I'll show you how to try a screen reader for yourself.

WCAG and Section 508
So how do you know whether your site is accessible or not? The W3C's web accessibility initiative has put together a set of web content accessibility guidelines, that we'll refer to WCAG, that a site can be accessed against. The guidelines are made up of several testable success criteria, which give us a really clear set of objectives to work towards. All we can do is make our sites more accessible. It's not really possible to claim that a site's 100% accessible just because it meets the WCAG, but it has reached an acceptable standard. There are actually three levels of conformance to the guidelines. Level A, which is the lowest, AA, and AAA, the highest. Each of the success criteria in the WCAG is associated with a level. So to be level A conformant, a site has to meet every one of the level A criteria. To be level AA conformant, a site has to meet all level A and level AA criteria, and so on. Typically, when we make a site accessible, we aim to meet the criteria for level AA. The criteria for AAA can be really tricky and in some cases impossible to meet depending on your site. Though, of course, we should try to meet AAA if we can. The WCAG criteria are grouped into four principles. Content should be perceivable. This covers things like providing text alternatives for images and captions for video. It should be operable with a keyboard and easy to navigate. Sites should be understandable and behave in predictable ways, helping the user to avoid mistakes. Finally, sites should be robust and well structured, maximizing compatibility with current and future technologies. It's worth mentioning that there's a common misconception amongst developers that if a site requires JavaScript to function, it cannot meet the WCAG. Now this simply isn't true. The current version of the WCAG is 2. 0. Now the previous version required the site to function without JavaScript, but since the second version's publication in 2008, use of JavaScript is fine as long as the success criteria are still met. In the introduction page for the WCAG, there's the statement WCAG is a technical standard, not an introduction to accessibility. This is essentially them saying this is really stunningly complex, so proceed with caution. Now the guidelines are daunting at first because each criterion has to be completely testable. They list out several different ways it's possible to meet each criterion, and also some aspects that would cause a failure to meet one. Saying that, once you're used to the structure of the guidelines, it's really not that bad. It's actually useful that they go into a high level of detail because it helps you to make technical decisions. There aren't any vague statements in the WCAG. This is the WCAG guidelines web page. I'll walk you through one of the success criteria so that you can get used to the format. In the table of contents you can see how they're broken down into the four principles we discussed earlier. I'll choose a relatively simple one, the use of color, which is success criteria in 1. 4. 1. This requires that the site should not use color as the only means of conveying information. You can see that this is a Level A criterion, the most basic level of conformance. Over on the right there are two links, How to Meet 1. 4. 1 and Understanding 1. 4. 1. The How to Meet page explains a number of sufficient techniques that would mean a site passes this criterion, such as ensuring that information conveyed by a color difference is also conveyed in text. There's more information about each technique linked to here. This one explains a number of examples to give you ideas on how to convey information in text as well as color. Understanding 1. 4. 1 gives us some more background information about why this criterion exists. In this case, it explains that users who are color blind or using a text only output like a screen reader require the information in text as well. There are some links to further reading on the topic. You can see that even for a relatively simple example, there's a great deal of information in the WCAG. But it's easy to work through and it contains loads of useful examples for implementing changes. In addition to the WCAG, it's worth briefly mentioning Section 508, which is another set of accessibility guidelines defined by the US government. Any software used by federal agencies must comply to it. There's just a single level of compliance, but the majority of the guidelines are very similar to the WCAG, so we'll just refer to the WCAG in this course.

Our Case Study
So it's time to introduce you to our case study, the website with all the accessibility issues, which is a form for booking a room at a hotel. So this is our form. It has a sidebar section that gives more information, like the terms and conditions of booking. There's also a search box fixed to the bottom right. The form itself has two date entry boxes. I've used the jQuery UI library to add date pickers to them. There's a select box to allow you to select the location you'd like to stay in. You can choose additional activities to book by checking the boxes here. I've added JavaScript to update the total price when they're selected at the bottom. There are also special requests such as champagne on arrival. I've hooked this up to the same pricing logic to update the total. Also when you check the breakfast box, it asks you to provide a desired breakfast time. This field only shows up when that breakfast box is selected. It asks the user to provide their name, email address, and optionally their phone number, followed by their card details for payment. They can then click on Book to proceed or Cancel their submission, which results in the form being cleared and then being informed that the process has been cancelled. There's nothing essentially wrong with this site on first inspection. It's fairly typical of a web form.

Keyboard Accessibility
The first few issues we're going to tackle are related to keyboard accessibility. It's not something that most developers naturally consider when putting a site together, but it's pretty easy to get working. Of all the accessibility issues, these are also the easiest to understand and test. Just try using your site without the mouse. If you're not used to using a keyboard to navigate the site, I'll run through the basics. The arrow keys allow you to scroll through the content. You can use Tab to jump to the next control, like links and buttons and form fields. Shift + tab jumps one step backwards. Once you have tabbed to a link or a button, press Enter to activate it. You can also use the space bar to check and uncheck boxes. Let's dive into the issues with the site and how to resolve them. The first relates to keyboard focus. I mentioned using the Tab key to jump through the controls. One control can have focus at a time, so that the user can perform an action on it. Okay so I'll press Tab on our example site to jump to the next control. It's not clear what has focus right now. I'll keep tabbing, and oh so it's clear that we're now in the date picker. What's happened here is that the developer has decided to hide the focus indicator that the browser provides with this CSS. So why on earth would they have done that? By default some browsers put a blue outline around the input control or link that has focus as you can see here. The problem is that most sites have a well-defined color scheme like ours with the dark gray and the orangey-pink. I've had designers in the past ask me to hide the blue because it doesn't fit with the site branding. This is a failure of WCAG 2. 4. 7, Focus Visible. It's a level AA criterion that states that the keyboard focus should be highly visible at all times. As you saw on the our form, keyboard-only users can easily get confused without it. I'm not sure why this isn't level A to be honest. It seems pretty fundamental. Let's fix this. We could simply change the outline color, but it can still be a bit subtle, so I'm going to add a colored box shadow instead. In case CSS3 isn't supported, I'm also going to change the border color. Now it fits in nicely with our branding. It looks good on the input boxes, but it's pretty ugly as a box around the buttons. It's not great on the links either. For the links instead of the outline, I'll change the color and make them bold when focused. For the buttons I'll set the background color, which will be a little neater than the box around it. Alternatively, we could've switched out the button image with CSS. Let's have a look at our changes. It's really clear where the focus is and the styling fits in nicely with the site's theme. So when we want to show where the keyboard focus is we can just rely on the browser's default outline, or change the color of it. Or we could remove the outline and apply our own styling. Try to make it more than just a change of text or background color. In my example the buttons had both a color change and the outline retained, and the links changed color and became bold. The key here is not to be subtle. Remember that people may have visual impairments. Ensure that it's immediately obvious where the focus is at a glance. Considering that the outline was originally removed for design reasons, now that we've taken the time to style the focused areas nicely, the site looks a lot more polished and professional with the changes we've made.

Focus Ordering
Onto Issue 2. Now that you can see where the focus is, you may have noticed something odd about the order. Let's have a look. The focus jumps first to the search box, then to the sidebar, and then to the form. I'd expect it go to the form first. The WCAG criterion for this is 2. 4. 3, Focus Order. It states that components should receive focus in a meaningful order, and it shouldn't jump around unexpectedly. We as developers have a little discretion as to what meaningful means, but most sites have a logical order you'd expect it to follow. This particularly benefits those using magnification tools who can't see all of the screen at once. They don't have to keep searching around for where the focus has gone. So what's causing the focus to be in the wrong order in our site? Looking at the HTML, it's because the search and the sidebar sections are before the main form. By default the focus order just follows the structure of the underlying HTML. That's what's happening to our site. The other reason that focus could end up in a strange order is when the tabindex attribute is set on controls. When you set it to numerical value, that is the order that's followed. Let's say we have four controls on a page. By default the tab index flows left to right like this. If you wanted, you could set the tab indexes so that it behaved like two columns like this. But then you add some unrelated control like a select box at the top without a tab index. Now the select box is focused last. The browser focuses those with tab indexes first and then all the other controls. You can easily get in a complete mess with this as once you've set tab index somewhere, you end up setting them everywhere to preserve an expected order. Basically, unless it's really, really necessary, don't set the tabindex attribute to control the focus order. It quickly becomes a maintenance nightmare. There's even a bug filed against the HTML spec to try and get it removed, and a proposal to document that it's strongly discouraged. Thankfully we haven't been playing around with tab index in our form, so the only thing we need to do is reorganize the HTML, so that the main section comes first and the tweak the CSS a little so it looks the same as before. The focus now jumps to the form first as you'd expect.

Select Box Groupings
Issue 3 is related to the location select box on the form. I don't think it's very usable right now. So in the box there are various cities in the UK. They aren't in any recognizable order though, which makes it a little difficult to find what you want. Keyboard users could press Enter to show all the options, but quite commonly if there are lots of options like this, users press a key to jump to items beginning with that letter. If they press L and jump down to London, Leeds, and Leicester, they might miss Liverpool at the bottom and assume it's not in the list. The cities are in different countries too, but they aren't ordered by that either. At the moment all the options are just listed out within the select element. I'm going to change our site to add optgroup elements like in the code on the right. These group multiple options together within a select, and I'm going to use it to group the cities by country. We define an optgroup with label England and place the English cities within it in alphabetical order. Now that I've made this change, it's way clearer to see what's going on. If you were searching for a specific city, it's really clear where you should look now. There's no specific WCAG guideline that you'd fail if you didn't organize select options properly, but 1. 3. 1 Info and Relationships does cover doing what you can to ensure information is laid out as clearly as possible. In general, we should try and eliminate any possible cause for confusion. This brings us to the end of the first module. In this module we've covered what accessibility means, and the range of disabilities we should accommodate for. I've explained how the WCAG guidelines work and then introduced you to our case study site, a hotel booking form. We've then solved three accessibility issues with it. The fact that focus wasn't visible, the order of control focus, and finally the organization of items in the select box. In the next module I'll show you how to use a screen reader, and we'll fix some related issues with the site.

Improving Our Form for Screen Reader Users
What Is a Screen Reader?
In this module, we're going to be improving the case study site for those who use screen readers. I'll start off by explaining what a screen reader is for, and show you an example called NVDA, and then we'll get onto fixing some of the issues that we find. When a user has a severe visual impairment, they aren't going to be able to rely on magnification and contrast tools to use a computer. A screen reader interprets what is on the screen and outputs it to the user, either using a text-to-speech engine or a refreshable braille display. They also allow the user to interact with the computer, navigating around and entering data on forms using the keyboard. They have a wide array of keyboard shortcuts to make interactions simple. There are two types of output from a screen reader, speech and braille. Some people will use both. The speech is synthesized from the text and can sound strangely robotic. New users of screen readers typically find that the speech is way too fast by default, but experienced users often speed it up even more. A refreshable braille display, like the one shown here, contains a row of cells with dots that are raised to form braille characters. When a sighted user views a web page, they can glance over the contents of the whole screen and immediately get a sense of what content there is on the page. Screen readers process content line by line from top to bottom. You can imagine this can be really frustrating for a user. Thankfully, screen readers have a lot of features that allow the user to sort of skim the content to see what's there. They can jump between links and headings and also different areas of the page, but this only works well if the website has been designed with this consideration. If headings aren't defined properly, for example, the user is left just listening to the content from top to bottom. There are a lot of screen readers available. The Mac OS actually as a screen reader built in called VoiceOver. With Windows, there are a few popular options. The most commonly used is JAWS by Freedom Scientific. It's over 20 years old, so it's built up an impressive array of features. Usage has been declining over the past few years, though, as alternatives are now feature-rich enough to compete. Window-Eyes by GW Micro has been gaining popularity as it now comes bundled in with the Microsoft Office Suite. Finally, NVDA, Nonvisual Desktop Access, is an open source solution that we'll be using in this course. It's completely free to use, and so is the best option for developers wanting to test their applications, although I'm sure they'll appreciate a donation. VoiceOver is also free as it's bundled into the Mac OS. There are lots of screen readers out there, and they do work slightly differently. Certainly the way they're controlled and the keyboard shortcuts used are different. Should we worry about all the differences and the quirks? Not really, almost all of the time if content's accessible to one screen reader, then it will be accessible to another. The screen readers themselves also improve over time. The best thing to do is focus on accessibility best practices and standards, and try out your code in at least one of the popular screen readers to check you're doing it right.

Using NVDA
Okay, so I've done a lot of talking about screen readers; it's time for me to show you one. I'm going to demo how I use NVDA on Windows. If you'd like to follow along, go to www. nvacess. org to download it for free; maybe you can try out what I'm doing on a website you've developed. I'm going to run through how to configure it and then how to use it to read out the content of a website, jump between things like headings, and enter data into a form. Once you start NVDA, you'll see this intro screen. A lot of keyboard commands use what is referred to as the NVDA key. This is the Insert key on your keyboard. My Surface Pro keyboard doesn't have an Insert key for some reason, so I've checked the box here to use CapsLock as the NVDA modifier key, too. There's also the option to automatically start NVDA when you log in to Windows, which you probably don't want to select if you're just using it occasionally for testing. To bring up the NVDA menu, press the NVDA key and N. (Computer voice response) NVDA menu. There are a whole load of preferences you can set here, and I'm not going to go through all the options right now. The NVDA site has a decent user manual if you want to review these further. One thing I do tend to change is under the Keyboard settings menu. By default, NVDA reads back to you as you type characters and words. For testing purposes, this gets pretty annoying, so I've switched that off. We're going to use NVDA to just browse a website first. NVDA works fine in most browsers, but they recommend we use Firefox, so I will. Don't forget when you're testing to just use the keyboard and not the mouse. It's pretty tempting to use the mouse to jump around content, but remember, it's not what we're testing for. If you're feeling really brave, once you're used to the keyboard commands, turn your monitor off for testing if you feel it gives you a better insight into what a typical user would experience. Let's try browsing the NVDA User Guide. One thing it's worth mentioning is that NVDA has a speech viewer that makes it user to use for testing. You can access this in the NVDA menu under Tools. It just outputs everything that the NVDA says out loud to this window. If you want to note down a bug, it's a lot easier taking a screenshot of this window then remembering what the screen reader said. By default, when you first access a page like this, NVDA will read out the title and the first line of content, in this case the header. (Computer voice response) NVDA April 2015 User Guide document. You can press the Down Arrow key to get it to read the next line. (Computer voice response) Heading level to Table of Contents. Pressing the Up Arrow reads the previous line, so you can use the Arrow keys like this to read through the document. (Computer voice response) List with 15 items, bullet link 1, Introduction. Bullet link 1, introduction list with 5 items, white bullet link 1. 1 General Features. White bullet link 1. 2 Internationalization. If you would like it to read the whole document out from where you've currently read to, press both the NVDA and Arrow Down keys. Pressing the Ctrl key stops it from reading any further. (Computer voice response) White bullet link 1. 3 Speech Synthesizer Support. Let's review the commands that I've used. The Arrow Down key will read the next line and the Arrow Up will read the previous. NVDA and the Down key will read everything from your current reading position. Finally, we can press Ctrl to stop reading at any point. The next thing I want to show you is how NVDA interacts with forms. NVDA has two different modes, browse and focus. They may be called by different names, but the two modes are common to screen readers in general. We've only seen browse mode so far, which is for navigating and reading content. When you press a key in browse mode, it isn't sent to the website, it's treated as a command to NVDA. That's fine until you actually want to enter some data on a form, which is what focus mode is for. When you switch into focus mode, the majority of the NVDA commands stop working so that you can press keys to type into input boxes. NVDA sometimes enters into focus mode automatically, and sometimes you have to tell it to do so, depending on how you're navigating the document. I've put together this really simple form with three input boxes and a button to show how NVDA interacts with it. When it reads out the instructions at the top here, it's still in browse mode, and if we just use the Arrow keys to navigate down, it continues to be in browse mode. (Computer voice response) Here are some instructions for the form. Name started is required, it has auto complete. Focus mode is activated by pressing the Spacebar after NVDA has described the edit field. It plays a sound to let you know focus mode is enabled; and now you can begin typing. (Computer voice response) Name started is required, it has auto complete, blank. I'm using Tab to jump between the fields here. (Computer voice response) Email Address started is required, it has auto complete, blank. When I tab onto the button, a different noise sounds to tell me we're back in browse mode again. (Computer voice response) Submit button. NVDA enters focus mode automatically if you're tabbing between fields, but if you're just using the arrows to read, you have to manually activate it by pressing space. You can get back to browse mode with the Esc key. So to recap, if you're in browse mode and you want to enter focus mode to enter data into a form control, press the Spacebar. Tabbing jumps between input controls, and pressing Shift+Tab jumps back to the previous control. Finally, to exit focus mode and return to simple browsing, press the Esc key. I mentioned before that sighted users can just glance over a page and get a sense of the content that's there. The way that screen reader users can achieve something similar is by the use of quick keys. These are single letter commands that when pressed, jump between different elements on the page. They only work in browse mode. For example, when you press the H key, NVDA reads out the next header on the page. Pressing H again will jump to the next one, and so on. Just as we can Shift+Tab to jump backwards through input controls, Shift+H goes back to the previous header. Jumping through the headings is a really good way to get a sense of what content there is on the page. Let's try out the H quick key on the NVDA User Guide. (Computer voice response) Table of Contents heading level 2, 1. Introduction heading level 2, 1. 1 General Features heading level 3. It's a little redundant here because there's a Table of Contents at the top, but you can see how this would be really useful to step through most sites. Another thing you can jump between is links with the K key and buttons with B, though there aren't any buttons on this page. (Computer voice response) ESpeak link. Supported Speech Synthesizers link. Supported Braille Displays link. No Next button. These aren't all the quick keys that NVDA supports, but they are the most useful ones, in my opinion. H is headings, K is links, B is buttons, and L is lists. An interesting one is D for landmarks. This jumps between identifiable areas of the page, like navigation, main content, and footer, provided that they are identified as such using HTML5. The final thing I want to show you in NVDA is a useful little tool for when you're testing your sites. If you press the NVDA key and F7, it brings up the element viewer. This shows you all the links in the page; there are lots in the User Guide. You can also see the headings and their hierarchy, which is an easy way of checking if you're using the right heading tags. This guide has a nicely structured set of headings, which is what you'd want to see. There's also a view of all the HTML5 landmarks on the page, but the guide doesn't have any.

Making Content Readable
Now that you know how to use a screen reader for testing, let's go back to our case study and see how that behaves when we use a screen reader on it. Those images for headers are likely to be an issue. You can see here that the subheadings of our example site, like this about your stay heading, are actually images. Let's see what NVDA can detect here. When we read down through the content, it's got nothing to say about the image. If we use the headings quick key, H, it can only detect one heading in the entire page, the New Booking heading at the top. (Computer voice response) Main landmark, New Booking heading level 1. No next heading. This is a failure of WCAG 1. 1. 1, Non-text content. This states that all non-text content, like images, should have a textual equivalent. There are a few permitted exceptions to this, like CAPTCHAs. In addition, if an image is just decorative and it's okay for the screen reader to ignore it, we should make that clear in the HTML. We actually have two issues here, that the screen reader has no text equivalent to use for the image, and it's not identified as a header. With images, we provide the text equivalent in the alt attribute. We can then wrap this in h2 tag, so that NVDA knows it's a header. This would be a perfectly good technique, but I think it's always best to keep sites simple where you can, and there's no real need for this to be an image. It would be cleaner if it just matched the style of the main header. So I'll just replace the image with text. Let's have a look at this again in NVDA. Pressing the H key now reads out the headers properly. (Computer voice response) New Booking heading level 1. About Your Stay heading level 2. Your Details heading level 2. Payment heading level 2. In the Elements List you can see that the document now has the heading structure you would expect. One of the other requirements of WCAG 1. 1. 1 is that we identify purely decorative images, like the picture frame in the corner of this slide. We can do this by including an empty alt attribute. This informs the screen reader that it can completely ignore the image. Moving on to Issue 5. There are a couple of links in the sidebar of our site that could cause some confusion. If the user was navigating through the site using the Tab key or jumping between links with the K quick key, it can be confusing to encounter links that simply say, click here or read more, like the ones in our side bar. (Computer voice response) Complementary landmark Click here visited link. Read more visited link. Where possible, we should avoid this. I'll reword the text here so that the link text is self-explanatory. We've already dealt with the images in the sub-headers, but this site is using images for buttons, too. When we tab through the buttons in NVDA, it doesn't have anything to tell us because again, there's no alt text on these images. (Computer voice response) Booking graphic link. For the Book and Cancel buttons, I'm going to opt for just replacing the images with text and styling the buttons. There's nothing in the images that we can't achieve with CSS, and it also means that text magnification will work on the buttons too, whereas the image just wouldn't scale. There are cases where we'd rather not do that, though. The Search button has an icon, so in this case we can put an alt attribute on that image. I've styled the buttons and also ensured that the background color changes when focused. The Cancel and Book buttons are now communicated properly by NVDA. (Computer voice response) Cancel link. Book link. And the Search button now has alt text, so NVDA knows what it is. (Computer voice response) Complementary landmark search graphic link.

Entering Form Data
Pretty much the most important thing you can do to make a form accessible is associating with the labels with the input fields, which is Issue 7. Right now, we can see in the HTML that there is no association between the labels and the form fields. This is the case throughout the form. When we tabbed to the Location box and the checkboxes, NVDA can't tell what they are. (Computer voice response) Combo box collapsed. Main landmark checkbox not checked. Checkbox not checked. Checkbox not checked. WCAG 3. 3. 2, Labels or Instructions, covers this one. It basically states that when content requires user input, labels or instructions are provided. The labels should be in close proximity to the input, so that the relationship is clear to those using a magnifier too. To associate an input with a label, the input must first have an ID, which ours already do. We set the for attribute to the label to the ID of the input it's associated with. Now that I've done this for the whole form, let's look at the Location select box and the checkboxes with NVDA. It should read out the labels. (Computer voice response) Location star combo box collapsed. Main landmark Gym Access 10 pounds checkbox not checked. Breakfast 10 pounds checkbox not checked. An added bonus of this technique is when you click on a label for an edit field, the field gains focus. Clicking the label associated with a checkbox checks the box for you, which is really useful, especially for those with poor fine motor control, as the checkboxes themselves are pretty small targets to click on. We have associated the labels with the checkboxes, but there's another issue here that we haven't addressed. When we Tab to the checkbox here, it tells us that the label is Gym Access. (Computer voice response) Gym Access 10 pounds checkbox not checked. That may be fairly self-explanatory, but it's not reading out the overall question being asked, which is what additional activities do you want to book. If you imagine the form asking you your favorite color, just being read green, blue, and so on would be confusing without the actual question. On the left is what we currently have, a question and then a number of checkboxes and their associated labels. To group the fields together in a way that the screen reader will understand, we'll wrap it all in a fieldset element. The legend element within the fieldset defines its heading, which is our question in this example. You should do this for any sets of fields that have some label or instruction that applies to them all. You can even nest fieldsets, though that may be overkill. I've made the change to our demo site now. Let's see what happens when we tab to the checkbox. (Computer voice response) What additional activities do you want to book? Grouping, main landmark Gym Access 10 pounds checkbox not checked, Breakfast 10 pounds checkbox not checked. Much better. The field set by default puts a border around the field like this, but it's easy to remove all style with CSS so that the form looks the same as before. I actually prefer how it looks with the border around, so I've just styled it to fit the site theme. The final issue I'll discuss in this module relates to setting keyboard focus in JavaScript. When we check the Breakfast box, there is JavaScript to make the desired breakfast time appear, and it sets keyboard focus to that box. For me, using the mouse it doesn't seem like a problem. Doing the same with NVDA, we check the box and it jumps us down so that we can enter the time. The issue is that without being able to see what's going on, the screen reader user is going to miss the other activities' checkboxes as they continue tabbing on through the form fields. (Computer voice response) Breakfast 10 pounds checkbox not checked. Desired Breakfast time edit has auto complete. Blank. Special Requests list. Champagne on Arrival 40 pounds. Please don't set focus to controls in JavaScript based on some user action or even when the page first loads. Screen reader users typically process content from top to bottom, and it can be really disorienting to suddenly find yourself in the middle of a page. It can be frustrating for sighted keyboard users too if the focus suddenly jumps outside their control. With the setting of focus removed, the field still appears, but the screen reader user will get to it once they've tabbed through the rest of the checkboxes. (Computer voice response) Breakfast 10 pounds checkbox not checked. Checked. Spa Day 50 pounds checked. Spa Day For Two 90 pounds checked. Golf Pass 80 pounds. Desired Breakfast time edit has auto complete. In this module, I've explained how screen readers work and introduced you to the screen reader we'll use in this course, NVDA. I've shown you the basic controls of NVDA so that you can follow along and test it on your own websites, too. We've fixed up a few issues where the screen reader couldn't read our form, and given all the fields proper labels. I've covered how we can group fields together using the fieldset element and also why it's not a good idea to set the keyboard focus. In the next module, I'll introduce an extension to HTML called ARIA, which will help us to improve our support for screen readers further.

Using WAI-ARIA to Provide More Context
What Is ARIA?
In this module, I'm going to explain how we can use a technology called, ARIA to improve the experience further for screen reader users. Websites are getting more and more complex with interactions such as drag and drop, widgets like tree controls and expandable menus. You can imagine that it's difficult for screen reader users to interact with this kind of control. That's where ARIA comes in. ARIA stands for Accessible Rich Internet Applications. It's a framework that allows us as developers to provide this rich functionality in a way that screen reader users can still understand and use. You'll typically see ARIA referred to as WAI-ARIA. That's because it's been developed by the W3C's web accessibility initiative. The same people who put together the WCAG guidelines. I'll just refer to it as ARIA in this course but they are one in the same. ARIA helps us to describe things that sighted users would just be able to figure out from the context. Here is a menu structure which could be used to control some content shown on a single page using JavaScript. It has a hierarchy, the HTML item is nested within the Topics item. The hierarchy itself is something we could communicate to screen readers just from the structure of the HTML. The best way to implement something like this is to have a series of nested lists, which the screen readers handle well. There's a lot more going on here than just the structure, though. To a screen reader this is a load of nested lists. To you and me, it's clearly a tree menu. We can see that the topics section has been expanded but the blog section has not. The home section can't be expanded at all and neither can the rest of the topics, apart from c sharp. Also, it's clear from the color change that JavaScript is currently selected. ARIA gives us the ability to let the screen reader know all of this information so that the user understands fully what's going on. And they don't have to guess or use trial and error to work out how to interact with it. This is achieved by adding attributes to the HTML. The kind of things you can describe with ARIA attributes, loosely fall into three categories. You can state what role and element has, like the fact that it's a menu item. You can describe its current state, like the fact that it's selected. And you can also describe other properties the item has, like that fact that when you activate it, a popup with appear. These all paint a picture about the element that can be output but the screen reader. Just because we have to put attributes on elements doesn't mean we should only be doing this when the page loads. The whole point of ARIA is that we can develop widgets that are controlled client side with JavaScript. We just need to ensure that the JavaScript itself adds updates and removes the attributes when necessary. Let's take our menu example again. On load of the home page the first item has ARIA selected, true and the topics item has ARIA expanded, false to show that it can be expanded but it isn't right now. Now we've written some JavaScripts so that when we click on the topics item, it expands. Becomes colored to show that it's selected and the home item loses its color. When the JavaScript does this, it should also be adding and amending the ARIA attributes. Like setting ARIA selected and expanded to true on the topics item. The screen reader is able to pick up on the ARIA attributes that have changed and so when the topics item is focused, it can announce that it's currently selected. Screen readers don't just read the document at the start and assume nothing has changed since. They're always looking at the current state of things. Before we go any further, I wanted to mention that this menu example is not a full implementation guide and there are other attributes you'd probably want to put on this to improve it further. I'm just trying to explain how ARIA is used. We'll cover full examples in our case study later on. Now there is a clash between some of the newer HTML 5 elements like, button and the ARIA roles. Where possible, use the HTML 5 element. Screen readers also support HTML 5 and so when we use a button element the screen reader already knows that it's a button. It doesn't need a button role. So why does ARIA even have a role of button? It's for when you can't use the button element. Perhaps you have a site that's already been released and you don't want to have to switch all the buttons to a different element and update all the CSS. Then it makes sense to use the ARIA role. Over time some ARIA rolls and properties will become redundant as HTML becomes more expressive. One important distinction between HTML 5 and ARIA is that ARIA is only used to expose information to screen readers, it will not influence browser behavior in any way. So when you use a button element in HTML the browser makes it keyboard focusable, clickable and also applies some default styling. If you give a span element the role of button the browser doesn't care, you have to make it focusable and functional and style it yourself. And that's why using HTML 5 is preferable. On the other hand, it does mean that you can add ARIA without having to worry about breaking anything.

Improving the Labeling
We've already labeled up our form fields, but there are a few improvements we can make with ARIA. You can use the ARIA label attribute to give a control some label text without having to put an actual label element on the page. This should be used pretty sparingly though, because only screen readers will know about it. You don't want sighted users to be confused about the purpose of the text box. Another useful attribute is ARIA labelled by. You set the value to the ID of a control that labels it. If you're using standard labels, there's not need for it because you would just set the fore attribute on the label. But this allows you to use other elements for labeling. You can put multiple ID's in the attribute value, separated by a space to show that the control has two labels. We could have used it for the checkboxes on our case study form where the checkboxes actually labelled by the, "What Additional Activities Do You Want To Book, " heading and the activity name. We use field sets in that case though because I feel like it's a simpler solution. These labeling attributes should only really be used for the more complex scenarios where standard labeling won't do. There are a couple of issues we have with the form labeling. The first is the search text box, which is currently unlabeled. This is one of those cases where we really don't want to put a label there because it wouldn't fit in well with the design. And it's clearly obvious to sighted users what the purpose is, without a label. We'll use the ARIA label attribute to give the text box a label. NVDA now reads out the label with the input is focused. Search terms edit has auto complete, blank. One more place where the labeling could be improved is the card expiry date fields. Currently, the label is only associated with the month drop down and there's no label for the year. Expiry date stock combo box expanded. Combo box collapsed. We don't want to remove the fact that the label is associated with the first drop down as this allows us to click on the label to set focus to the field, like for the rest of the form. If I were to use ARIA label by on the year select box to associate it with the expiry date label, it would work but the user wouldn't know that this was the year field. I'll just use ARIA label to state that it's for the expiry date, year. This now makes a lot more sense when tabbing through the controls. This is a good example of the kind of thing ARIA is designed for. There's no need for me to use it throughout the form fields but it helps us in the situations where we get stuck. Expiry date stock combo box collapsed. Expiry year combo box collapsed. We can also make some improvements to the instruction text in the form. Another use for ARIA attribute is ARIA described by. You set the value to the ID of an element that contains more information about the control. This could be instruction text for what to enter within an input box. Or just some more useful information that might be relevant, like an explanation that clicking a certain button will cause something to happen. This should never be used instead of a label. The describe by element is for adding supplementary information that could be useful in addition to the label text. The only occurrence where we have additional instruction text in our form is the desired breakfast time input here. There is text afterwards stating that the restaurant is open from eight until 11 for breakfast, which is pretty useful to know when you're trying to complete the form. I'll give the instructions an ID and set ARIA described by on the breakfast time input to that ID. Now, when we tab to the input NVDA outputs this text too. (Computer Voice) Desired breakfast time edit has auto complete. (Computer Voice) The restaurant is open from 8am until 11am for breakfast.

Live Updating
The next thing we need to look at with our form is letting the screen reader know when content is updating. Quite often a site will have some elements that update or appear without the page reloading. There are all kinds of reasons for this, such as a chat window or a status bar that gets updated with text describing the current operation. There are also arrows and warnings that can appear and countdown timers. Before ARIA, there wasn't as simple way to alert the screen reader user of these updates. They would just have to step through the content and hope that they stumbled across something new. To state that an area maybe updating client side, you can add the ARIA Live attribute that contain the element. There are two levels of importance that you can choose from and these effect how the screen reader presents the update to the user. So it's up to the screen reader to determine what that actually means. When we set ARIA Live to polite, we're basically saying that when an update happens to this region, the user does need to be informed but it shouldn't interrupt what they're currently doing. Screen readers tend to implement this by informing the user when they're finished typing or they've reached the end of a sentence being read out. Although this definitely varies depending on the screen reader used. Setting the value to assertive means that an update to this region is really critical and the user needs to be informed right away. This is less commonly used as it interrupts the user. It's useful for things like informing them they've lost internet connection and been disconnected. Or they can no longer complete the task they started. Don't use it unless it's really necessary. I've put together a quick example to show how ARIA Live works. I have a webpage with some instructions and there's a counter at the bottom that gets updated by JavaScript every ten seconds. I've put Aria Live assertive on the counter so that when it updates, the screen reader is informed. Main landmark, here are some instructions at the start of the form. This allows us to test when the screen reader. The update count is now one. The screen reader gets some way into reading the instructions and then informs us of the change. If I press the down arrow, it continues reading from where we were. The fact that its announced the new area doesn't mean the reading position has moved. Lets us know about updates. The first case in our form where we have content updating dynamically is the fact that the breakfast time field appears when the box is checked. Now I don't think we need to alert the user to this, the breakfast time field appears later on in the form so the user will naturally get to it. And it's not like the change is really urgent and they have to act immediately after checking the box. We don't want to add noise to the user experience. The other area that updates is the total price at the bottom when activities are selected. I'll add an ARIA Live attribute to the pricing area and set it to polite because it's not urgent information, it's just nice for the user to know what the current total price is. Now when I add an activity, it lets us know the total price. £119. 99. It's still a little odd, though. I put the ARIA Live attribute on the section containing the total price label too but it's only reading out the price value. Which may leave the user confused as to what's being read out. You can actually control what aspects of the ARIA Live labeled region are read out with another attribute, ARIA Atomic. It's a Boolean attribute and the default is false. Atomic false means that only the element that actually change content will be read out. There were two elements within our live region, one was a label and one was the price. So when only the price got updated, NVDA only read out the content of that element. When you set ARIA Atomic to true, the screen reader reads out the content of all of the elements in the live region even if some stayed the same. So what we actually want to do with our form is specify ARIA Atomic true on the pricing section so the whole lot is read out. Let's try it now. Total price £119. 99. One thing to note about the ARIA Live Regions is that sometimes when you're developing a complex widget the screen reader can try to notify the user before you're done updating all the elements. What you can do is set ARIA Busy to true before you update it and set it back to false when you're finished. At which point the screen reader will announce the changes. We don't need this for our form because we're only updating one thing, the price.

Buttons and Semantic HTML
The next issue we're going to look after is the fact that we're using anchor tags for buttons that are controlled with JavaScript. You can see in our HTML that the submit and cancel buttons are just anchor tags with hashes in the href attribute. This is a fairly common way of creating a client side button. When we tab to it in NVDA, it describes it as a link. Cancel link. Book link. WCAG 1. 3. 1 Info and Relationships is a fairly general success criterion. Its basis is the information that can be conveyed through presentation can be programmatically determined. In other words, don't style a cow to look like a pig because when you prod it, it will still say moo. And in our form, we shouldn't be making a hyperlink behave like a button. What we're essentially doing is using an anchor tag, usually used to link to another page entirely, to act as a client side button when we should actually be using the button element. 1. 3. 1 mentions that we should be using Semantic HTML, but what does that actually mean? It essentially means using common sense to choose the right HTML elements of the job. If you have a headline, don't put it in a paragraph element and style it, use a heading element. When we use the right elements, browsers and screen readers can make sure they work as the user would expect. For example, a button would accept keyword focus but a span styled to be a button would not by default. Instead of using div elements for a sites navigation menu and main content area, if we use the nav and main elements the screen readers can work with this. The D quick key in NVDA navigates between these landmark regions, which wouldn't be possible with just divs. Now this is where ARIA can lead us astray. We have a problem right now that the button that's being announced by NVDA is a link, but wait there's that new role attribute so I can fix this by giving the link a role of button, right? Well, yes setting the role a button will make NVDA realize that our intent is to use that element as a button. So it sort of fixes our issue but it's not the right fix to provide Semantic HTML. Instead of trying to convince everything that our link is a button, we should just use the button element. Try to remember that ARIA roles are there to allow us to build completely custom widgets and let screen readers know what their purpose is. It's not designed so that you can use whatever element you like for anything, where a standard HTML 5 element would do. I'll replace our three button links with actual button elements. The CSS doesn't need to change as they already have a class of button. NVDA should now properly communicate these buttons. Cancel button. Book Button. That brings us to the end of this module. I've introduced you to ARIA and how it can be used to provide information on the state of custom widgets to screen readers. I've improved the labeling of the form and also linked instruction text to a field so that NVDA reads it out. We've discussed ARIA Live Regions for informing screen readers users of content that has updated and implemented this in our case study. Finally, I've explained why Semantic HTML makes life easier for screen reader users. In the next module, we'll be tackling the form validation and error messaging.

Fixing the Form Validation
Validation and Required Fields
In this module, I'm going to run through how we can fix up the client side validation that the form has so that it's more accessible. Let's have a look at the validation that we do have. It's all client side and triggered by the click of the Book button. Typically you'd have server side validation to back this up, but for simplicity we're just working with the JavaScript implementation here. The validateForm function first removes any current error messages from the validation-summary area, which is at the top of our form. It also removes the invalid CSS class from all of the input controls. After this there are a number of function calls to validate the various fields on our form. We'll look at a straightforward one first validating that the payment card type has been selected. The validateRequiredField function takes an input control and an errorMessage, and if the value of the control is empty it adds a validation issue to the form. The addValidationIssue function adds the invalid CSS class to the input control and appends the errorMessage to the validation-summary element. There is some more complex validation going on, like the validateDate function. If the field is required, it checks whether a value has been provided, and if so, it then checks whether it's a valid date. The validateText function performs the required field validation, and also checks that the input doesn't exceed a maximum length. The validateForm function calls these methods for each of the input controls, and then returns whether it's valid or not by checking if any error messages have been added to the form. Let's give it a try. I'll leave some mandatory fields unfilled, put an invalid date in, and way too much text in the card number field. When I press the Book button, all the relevant messages are shown at the top, and the fields have the invalid CSS class now have a pink border instead of the orange. The first issue with our validation is how the required fields are labeled. Where there are mandatory fields in our form, we've placed an asterisk at the end of its label. To make this WCAG compliant, the asterisk method is fine, but we need to state what they mean. People use asterisks for many different purposes, like referring to a footnote, and we need to be 100% clear about what this one means. With this message at the top, we've eliminated any cause for confusion. Again we can use ARIA to make this situation clearer for screen readers. By adding the aria-required attribute with a value of true, the screen reader knows that this is required and can communicate that to the user. So when should we be using aria-required? Here there's no indication at all that the field is required in the label, possibly because it's stated elsewhere in the form. We should definitely put aria-required on this one. Our next example has required stated explicitly in the label text. Assuming that the label is correctly associated with the input control, we don't need aria-required here because the screen reader would essentially be saying required twice if we added it. Finally, this is the situation we have in our case study where an asterisk is used to indicate a required field. I don't think aria-required is 100% necessary here as most users will pick up on the asterisks being read out, but it's safer to put the attribute on so that the user doesn't overlook it. I'll add this on to the required fields in our form. Now when we tab onto one of the required fields, NVDA states that it's required. Stay from starred, required, has autocomplete, blank.

Making the Errors Clearer
WCAG 3. 3. 1 Error Identification is a basic level A criterion that covers what we should do to inform all users that a validation error has occurred. There are a few issues in our form that mean that we don't meet this criterion. The guidelines state that all users should be made aware of an error, and there should be a message describing what the issue is, and this message should be as specific possible. We can still use color and icons to bring the users attention to the issue, but there should always be text explaining it. Issue 15 is that our form isn't currently doing a great job of identifying which of the fields are invalid. At the moment, when a field is invalid, the boarder changes from orange to pink, which is barely noticeable. There's no way for a screen reader user to understand which ones are invalid either. There's another ARIA attribute that we can use here. When we add the invalid CSS class to the fields, we should also be adding an aria-invalid attribute and setting it to true. This informs the screen reader that there's an issue with this field. So let's change the JavaScript to add aria-invalid to the controls in addition to the CSS class when we've identified an issue. I'm going to add a shadow and a background color to the invalid CSS class too so that these fields are more obvious. Now when we have invalid fields, it's much clearer what's going on. Location star combo box collapsed, invalid, entry required. The next issue relates to the actual error messages themselves. WCAG 3. 3. 3 Error Suggestion is a level AA criterion. We've already covered informing the user that an input control has an error, but people may not understand what they actually have to do to correct it. This guideline states that users have to be informed of exactly what the issue is. Quite often forms just highlight a field when something needs correcting and let the user figure out what's wrong, but people with cognitive limitation may not be able to. It's easier for all of us if we just know what to change. At the moment in our JavaScript implementation, we just have a single error message for each input control. But for the validateText function, for example, we're actually checking two things, whether a value has been entered and whether it's too long, but we're only displaying a message saying please enter the card number, which would be really confusing if you had, but you just entered too many characters accidentally. I'll change this function so that you have to pass in a different error message for when the input is too long so that it can display the right one to the user. I've done the same for the validateDate function so that there's a different message for when the format of the date is invalid. I'll ensure I also explain what the expected date format is, and that's an important aspect here. We should be explaining exactly what's wrong and also how to fix it. Now when there are errors in our form the messages that are shown are much more descriptive.

Validation for Screen Readers
The next issue is that we're not doing everything we can to make sure screen reader users are aware that there are errors with the form. Now the issue for screen reader users is that when we press the Book button and there are issues, it seems like nothing happened. It just feels like the button is broken because it hasn't let us proceed. Cancel button, Book button. We can see that there are errors highlighted, but the screen reader user can't see that, and the screen reader hasn't read anything out. So there are two possible ways that we can inform screen reader users that there are errors. We've already discussed using ARIA live regions to alert screen reader users of a change, and we could set that up on the validation error section at the top of the form. Alternatively, we could set focus to the error section. I said earlier on in the course that we shouldn't set focus to input fields because it's really disorientating, but this is a case where it would make sense to programmatically set focus as it reflects exactly how a sighted user would behave, shifting their focus to the errors after pressing the buttons at the bottom. The issue with ARIA live here is that it would read out the errors, but if the user wants to correct them, they can't easily just tab back through the form. The best thing to do here is move the focus back up to the top so that they can go through the form again and correct the issues. So in order to be able to set focus to the validation section, we need to set its tabindex to -1, and what this does is it means we can't tab to it using the keyboard, but we can set the focus to it with JavaScript. It would also help to have a message to introduce the errors, so I'll add that in if any issues are found. I'll make it a heading so that it's easily jumped to, and also I'll set the keyboard focus to the whole area. Now when we press Book and there are errors, the focus shifts and NVDA reads out the issues. Book button. There was some issues with the form submission. Please correct them and try again. Please enter your email address. The final issue with our validation is that we haven't actually associated the error messages with the inputs. We've identified which fields have errors with ARIA-invalid, but when tabbing through, NVDA just tells us that they are invalid, not what the issue is. Email address starred, invalid entry, required, has autocomplete, blank. What we can do to fix this is give all the error messages their own ID, and then we can set aria-labelledby on the input controls to associate each error with each input. Now when we tab to an input control with an error, because we've set labelledby, the error message is read out. Book button. There was some issues with the form submission. Please correct them and try again. Please enter your email address. Please enter your email address, set at invalid, entry required, has autocomplete, blank. To get down to this field with the arrow though, we had to tab through all of the controls until we reached this one with the issue. What's really useful, especially when a form spans more than one page, is when the error messages themselves are hyperlinks to the input controls with the error. Let's change them into links. We'll have to tweak the CSS a little bit as well. Here it is fully implemented. Book button. There were some issues with the form submission. Please correct them and try again. Please enter your email address. The error is a link, and when we activate it we're taken to the input control to correct the issue. Please enter your email address visited link. Edit, invalid entry, required, has autocomplete. This can be helpful for sighted users too, just being able to click the link and go down to the specific place in the form. That's everything we have to fix with the validation. After introducing you to the implementation in the form, we've discussed how to identify the required fields and also the invalid controls when issues do occur. The error messaging has been improved so users know exactly what to fix, and we also ensured that screen reader users know that errors have occurred in the first place. Finally, we've linked together the error messages and the input controls. The next module is our final module. Our form is so much more accessible, but there are still a few improvements we can make before we're completely done.

Adding Some Final Improvements
Scalable Text
In this final module, there are a few final improvements that we can make to our case study. Once it's all fixed up, I'll also review some useful accessibility testing tools that are available to help us. Issue 19 is that we should be ensuring that text can be resized. While users with more severe visual impairment may rely on a screen reader or specific magnifying software to read content on the internet, we still need to consider those with mild visual impairment. These users don't tend to use screen readers, but they can struggle to read small text on a screen. This probably affects more users than you'd think. The elderly tend to struggle with tiny font sizes. What these users need is the ability to increase the size of the text on the screen so that it's easy to read without causing any significant layout or functional issues. The level AA criterion 1. 4. 4 Resize Text states that we have to ensure that text can be resized up to 200% without loss of content or function. Browsers provide built in zoom and text scaling functions, so essentially all we have to do here is ensure that we don't actively prevent this in CSS and that content still displays fully when scaled up. The criterion explicitly states that a user should not have to use assistive technology, like a screen reader or magnifying software, to be able to scale the text. That's because we're dealing with a wide user base here, and those with minor impairments don't tend to install assistive software. There are two permitted exceptions to the text scaling requirement, if it's an image of text, or if the text is a caption for an image. I've put together this example to show the kind of things we have to watch out for. There are two paragraphs of text on this page. The first has the font size set explicitly to 18 pixels. The second has it set to 1. 1 em, essentially slightly larger than the browsers default. If we use the browser's zoom function and take it to 200%, this works fine. Nothing about the layout is broken. The image of the kittens is still placed to the right, and it's the same height as the box with text in it. It's pretty frustrating to have to scroll around the page though. What users may want instead is just the text to be made bigger, and the layout should remain generally similar. In the content settings in Firefox, it's possible to set the default font size. I'll change it to be twice as big, 32 pixels. Now this has had an interesting effect. Because we've explicitly set the first paragraph to 18 pixels, we've essentially overridden and ignored the browser's default setting. However, the second paragraph scales up correctly because we've only stated that the text should be slightly bigger than the browser's default. When we use relative units like ems or percentages, we're not overriding the browser settings and so the user can increase the text size without having to zoom the whole site. We should avoid stating sizes explicitly in pixels. Another issue with text scaling is when the surrounding content can't adapt to accommodate the bigger text. Here the CSS has been set up so that the white box is the same height as the picture. It's not an issue with the default text size, but as soon as we try to make it bigger the text gets cut off at the bottom. Make sure you design your sites to be flexible and not make assumptions about the amount of space needed to display the text. Let's see how our case study form has coped with the 32 pixels default setting. It's had absolutely no effect because our font sizes are in pixels. Let's change these to relative units in the CSS. It's not the prettiest layout, but it has worked this time. The buttons at the bottom seem to have fixed widths though, which causes the text to overflow. I'll change that to a minimum width so that they scale better.

Error Prevention
Moving on to issue 20, which is that we need to do more to prevent users from making errors when submitting the form. Ensuring that our users don't make an error in their form submissions is useful for everyone, but when people use assistive technologies or have cognitive limitations, the risk of misunderstandings or miss clicks increases. Sometimes an error doesn't have a great deal of impact, but there are lots of cases where it could cause significant problems for the user, like if they buy the wrong quantity of an item or delete something accidentally. In our case study form, the user may book for the wrong hotel location or on the wrong dates. Probably the most important method of preventing errors is validation, and the more of this you have the better. For example, we have checks like ensuring the card number isn't too long, which could prevent incorrect input. We should also be confirming with the user that they are happy with what they've entered. The level AA WCAG criterion 3. 3. 4 Error Prevention covers this. If the system causes a legal commitment or financial transaction or modifies data, then we have to provide a method of error prevention to protect the user. There are various techniques that can be used to satisfy this criterion, and the developer has the freedom to choose what suites their application best. I'll review them in turn. One way of preventing mistakes from causing headaches for the user is to provide time for them to correct or cancel their submission. This isn't suitable for some applications, like when a legal commitment is made, but for others it may be perfectly possible to undo a change. The user doesn't have to be able to cancel the submission indefinitely as long as the time limit in the process for cancellation is clearly stated to the user when they submit the form. For example, an online shop may allow users to cancel orders up to 24 hours after they've been placed, but after that they cannot be cancelled. If necessary, the cancellation doesn't have to be performed using the website, though that is the ideal. It's okay if the policy states that the user has to call the company to cancel as long as the method of contact is suitably accessible. In some cases, allowing an undo option is simply impossible, like when transferring money between bank accounts. Sometimes it's just too complex for the developer to implement an undo or for the company to process cancellations. In these scenarios, we have to do everything we can to confirm with the user before the final submission as the user will not have a chance to correct it. What we have to do to meet this technique is ensure that the user is prompted to review and confirm the data when they submit the form. If the data is being collected in multiple stages of the form, like in a checkout process, the user has to be either able to go back through the stages and make corrections or make corrections on the summary page itself before submitting. Another useful technique is to add a checkbox next to the submit button with a label like I confirmed that all data entered is correct or I'm happy to delete this data. The user must check the box for the submission to be accepted. This is most often seen in situations like transferring money using online banking. It forces the user to acknowledge and double-check their submission. In our case study, there are two buttons here that we need to consider adding some method of confirmation for. Imagine you just filled out the entire form and you were ready to complete your hotel booking when oops you click Cancel instead of Book. We should add a confirmation pop-up here to ensure that they really mean to cancel as this could be pretty frustrating. The Book button needs a confirmation pop-up too. Because this is a single stage form, that's sufficient here because the user can just review all of the inputs in this page and edit them as they need to. If this was a multi-stage process, we'd have to look at either providing an editable summary page or the ability to go back to previous stages to correct the data. Bearing in mind that we're trying to prevent user error here, there's another improvement that we can make. We already talked about the user accidently pressing Cancel instead of Book, so we should reduce the chance of that by moving the buttons further apart. We've already made the Book button a more prominent color, which also helps to avoid confusion. The simplest way to confirm that the user wants to cancel their booking is just to use a JavaScript confirm pop-up. This returns true if the user chooses to continue with the cancellation. I'll also move that Cancel button away from the Book button. Now if we do click Cancel unintentionally, we have the ability to remain on the page instead. I'll add another confirm call to the Book button to ask the user to review their submission. It's nice to add some additional detail into the message, so I've included the dates and the location of the booking. Now the user is much less likely to make a mistake and book for the wrong dates or hotel.

Making It Easy for the User
Issue 21 isn't anything that would cause a site to fail the WCAG, but it can make a big difference to usability, and that's simplifying what the user has to input. In our form we have a box where the user can enter their desired breakfast time, and there's some guidance as to what input format is expected and when the restaurant is open for breakfast. Let's have a think about all of the validation we have to put in for this, all of the mistakes that a user could possibly make here. We have to check that the time is entered in the correct format. We should probably make it flexible enough to accept 09 or just 9 at the start. We need to ensure that it's actually a valid time, so you can't enter 9:75, for example. You need to choose a time after the restaurant opens, so we have to check for that, and also before the restaurant closes. That's a lot of validation we're having to do, and more importantly there are loads of ways that the user can enter something incorrect or get confused. It's always frustrating to have to go back and edit your submission because of mistakes like these. Instead of having a free text entry, I've replaced the control with a select box. It's eliminated all four possible errors. The user can't enter a wrong format or an invalid time, and there are only options here that fall within the restaurant opening hours. It's so much easier to use. If you find yourself adding validation to an input control, think about what you could do so that it's impossible to make the mistake in the first place. It's easier for the developer and easier for the user too. The final issue is another one that would pass the WCAG, but it makes the form much less usable. The special request box uses a select input control with the multiple attribute to allow you to choose more than one option. For the inexperienced web user, these controls are incredible difficult to figure out. Just clicking on the option switches the selection, so users are probably going to assume that you can't select more than one anyway. Only a small percentage of people will know that you have to Ctrl+click the second item. Once you've selected an option and changed your mind, it's not obvious how to deselect it either. It's even more confusing when using the keyboard. It actually took me awhile to figure out how to select anything at all. I was expecting to be able to tab between the options, but you actually have to use a combination of the Arrow Keys, Ctrl, and the Spacebar to select things. I have no idea how a screen reader user would manage. I've switched this over to be series of checkboxes within a field set, like the activity selection, and it's so much easier to use. While we're improving things, I'll also add in some CSS so that the label that follows a checked checkbox is made bold. This just makes it easier to see what's been selected at a glance.

22 Bugs Squashed
So there we have it. We've squashed 22 accessibility bugs with our form, and it's now significantly much more accessible and useable. I'll discuss useful testing methods and tools that we can use to verify this, but first let's recap on what we've fixed. In the first module, we had a look at improving the case study site for keyboard users. First off we ensured that it was clear which control actually had keyboard focus, and then we made the order that the controls gain focus more sensible. The location select box had options in a confusing order, so we reordered them and added in grouping by country. In the second module, I introduced screen readers and showed you how to use NVDA. We solved a lot of issues in this module, giving the images alt text so that the screen reader knew what they were, and ensuring that links didn't just say click here or read more so that they could be understood out of context. We replaced the images used for the Book and Cancel buttons and styled them with CSS instead. One of the most important things you can do to make a form accessible is associate the labels with the input fields, which means screen reader users know what the inputs are, and you can check a box by clicking it's label. We also introduced a field set around the checkbox options so that the question text was read out, as well as the label for the checkbox itself. Finally, we removed the JavaScript that was setting focus to the breakfast time entry when the checkbox for it was checked as it would cause screen reader users to miss the remaining checkboxes when it skipped ahead. In module three we discussed WAI-ARIA and how we can use this to improve the experience for screen reader users, especially when we're developing custom widgets. We improved the labeling using aria-label to give the search box a hidden label and aria-labelledby on the expiry date year box. We used aria-describedby to associate the instruction text with the breakfast time input box. I discussed how we can use ARIA live regions to announce the price changes when the user selects additional options on the form. Finally, we made the buttons actually use button elements instead of links and discussed semantic HTML, which is all about using the right element for the job. Module four was all about fixing up the client-side validation on the form. We added a message to explain that the asterisks denoted required fields and added an aria-required attribute to the fields themselves. We tweaked the CSS so it was more obvious which fields had invalid entries and added the aria-invalid attribute to the input controls there. We made sure that the error messages accurately described what the issue was with the input and how to correct it and set the focus to the error summary when the Book button was pressed so that screen reader users knew that there were issues. We changed the error messages into links to jump to the input control in question and also associated the error message with the control so that screen reader users could hear what the issue was. Finally, earlier on in this module we've discussed using relative font units so that text scales properly and preventing errors with confirmation or undo functions. We've reduced the chance for mistakes by simplifying the input controls and making it much easier to use by replacing a multi-select box with some checkboxes instead. This is where we started, pretty much totally inaccessible to keyboard only and screen reader users, and it's got a fair few general usability issues too. Here's the accessible version. I said at the start that you can't make a site 100% accessible, but this meets a WCAG AA standard now, which is the level that most sites should be aiming for. I don't feel like it's compromised the experience for the average user either. I personally find this much easier to use, and it's no less attractive. If anything, it feels much more polished and professional now.

Accessibility Testing
So hopefully you now have a much better idea of the kind of things you can do to improve the accessibility of a site. A good way of assessing where a site is at right now is to run it through an accessibility testing tool. What these tools do is run a series of tests against a web page to see if there's anything identifiable that would cause problems. The tools usually do a good job of describing what the issue is and providing suggestions to fix it. The main drawback of these tools is that a lot of the guidelines like the WCAG actually require human assessment to evaluate whether something passes a criterion or not. This means that the tools only test for quite a small subset of the guidelines. On the other hand, tools like this are incredibly useful for checking the ones that do have specific enough rules to implement automated testing for, like checking that all images have alt attributes. You wouldn't want to go through a whole site and check that yourself. You do usually have to test one page at a time though. The only way you're really going to be certain that your site meets a level of the WCAG is to run though all the guidelines and check it. There are also a lot agencies out there that can do this for you. Let's have a look at a few of the tools you can use for automated checking. I wonder how many of the issues they would've found with our original inaccessible case study site. The tools require a publicly accessible URL to load and check the site, so I've put it up on my blog at myaccessible. website/inaccessible/booking. html. There were 22 issues we discussed in this course, but not all of them would've actually caused a failure to meet a WCAG criterion. They were more general usability issues or best practices. For example, the site would still pass the WCAG level AA if we didn't alert the user to the total price changes with an ARIA live region. It's not really fair to expect the testing tools to pick these kinds of things up, so let's take those out. What we're left with is 14 reasons that the site would've actually failed to meet WCAG level AA. Let's see how many of these the tools can detect. WAVE, the web accessibility evaluation tool by WebAIM, is a relatively basic testing tool where you enter a URL and it displays the site overlaid with notes on any issues detected. You can filter these down based on the guidelines and the level you're looking to meet. What you do is put the URL in the box here and press Go. All of these tests I'm running I'll show in real time. I haven't speed up any of the processing as they're nice and quick to run. So here are the results. It shows the page with the little icons next to areas that it's managed to identify. It's picked up that there's no alt text on the heading images and also that the form controls here aren't labeled properly. Over on the left is a summary of what's been detected. You can click the flag icon to show more details. Clicking on each of these takes you to the area of the page with the issue. The eye icon is documentation view, and if you select one of the issue tags like the missing alt text one here, it explains the issue and how to fix it. And at the bottom here there's also a link to the related WCAG criterion Non-text Content for more information. So WAVE found 4 of the 14 issues that would've prevented this from passing the WCAG AA standards, image alt text, the link purpose where it just says click here or read more, the fact that we were using images for buttons, and also that the form fields weren't labeled correctly. Google's developer toolbar in Chrome has an extension that adds accessibility tools. I'm not sure why they wouldn't just include this by default to be honest. You can ask it to do an accessibility audit of the site you're viewing in Chrome. They seem to have their own set of audit rules, which doesn't tie up with any guidelines. Here's the inaccessible site loaded up in Chrome, and I'll press F12 to bring up the developer tools. In the Audits tab at the end, there's a checkbox for an accessibility audit, so let's run that. It breaks down the issues into severe problems and warnings. I'm not sure what it's using to distinguish the two as its decided that the form controls not having labels is severe, but the images not having alt text is just a warning, and they're both equally important in my opinion. When you expand an issue, it shows all of the elements that have failed. These are all of the form field controls in our site that don't have labels. It does highlight them when hovered, but doesn't scroll to them like WAVE does. Each issue has a link to a wiki page for more information. It gives lots of examples for how to give controls labels, some incorrect examples, and then a little explanation below. So the Google tool has actually found the same four issues as WAVE. Tenon. io is a web product, and you have to pay to gain access, but it does seem to be by far the most fully featured testing application out there. The main benefit is the API so that you can work accessibility testing into your continuous integration cycle. It does have a free checker on the home page where you can enter a URL, and it will let you know any issues. It doesn't overlay them on the screen like WAVE, but it does seem to check for a few more things. Unlike the previous two tools, this has a lot of options. You put your URL in, and then you can choose things like the WCAG level you're testing for and the Viewport Size to load in for testing. You can also choose to store the results. Here we go. So at the top here there's some summary information and the ability to download a CSV describing the issues found. For each error, it shows the associated markup and the WCAG guideline that it has failed to pass. We're looking at the images missing alt text here, so it's 1. 1. 1 Non-text Content. There's a brief description of what the problem is. All of the problems are just listed out here. There are recommended fix links, but you have to log in to view those. Tenon. io has picked up on one more issue than the other tools, the fact that we're using links when we really should've been using buttons. To be honest though, the tools are all picking up on the same basic issues, and it reinforces my point that after the 14 reasons the site could fail WCAG AA compliance, only a small subset can be picked up by these tools. These tools are still useful though, especially the API features in Tenon. io.

Summary
Before we wrap up, I wanted to mention some of the fantastic blogs and resources out there where you can learn more about accessibility. It's a really interesting topic if you'd like to learn more. I'm sure I've left some of these out, but these are the ones that came to mind. Marco's Accessibility Blog has been running since 2007. He does accessibility Q/A for Mozilla, and his blog includes a great guide on testing with NVDA. A lot of content about accessibility points out what people can improve, but Accessibility Wins is a blog that highlights sites with great accessibility and any good news about accessibility improvements. The Paciello Group are an accessibility agency who also have a regularly updated blog with technical content. Wuhcag, which is a brilliant name, has loads of resources to explain web accessibility and all of the different criteria in the WCAG in a more digestible format. It's really nicely written. I have to mention my own accessibility blog, myaccessible. website, which is a valid URL. I blog about a range of accessibility topics and post videos on my YouTube channel. Recently I've been having a look at how well some of the most popular sites on the web implement navigation with just a keyboard. That brings us to the end of the course. I really hope this has been useful and you're feeling confident about making sites that you develop accessible for all. If you have an existing site to maintain, don't get overwhelmed trying to fix everything at once and make it 100% perfect as even small improvements can make a huge difference to users. Thanks for sticking with me through this entire course. I hope you've enjoyed it.

Course author
Author: Fiona Holder	
Fiona Holder
Fiona Holder is Director of Software Development at Xibis Ltd, an innovative web and mobile application development company. She primarily works in C#,ASP.NET MVC, JavaScript, CSS, and HTML5,...

Course info
Level
Intermediate
Rating
4.9 stars with 46 raters(46)
My rating
null stars

Duration
1h 47m
Released
21 Apr 2016
Share course
