Progressive Web App Fundamentals
by Nik Molnar

There's a set of technologies, which when used together, supercharge web apps so they can compete with native apps. This course will introduce each of them, and teach you to convert existing apps into Progressive Web Apps - and to engage users.

The web is one of the most powerful and ubiquitous application delivery platform in the world. And yet, in recent years it's become an underdog, overshadowed by native applications brokered through costly app stores. In this course, Progressive Web App Fundamentals, you'll learn the fundamentals of Progressive Web Apps. First, you'll discover how to create installable web apps with Application Manifests. Next, you'll explore how to send push notifications. Finally, you'll learn how to achieve background syncing and how to automate testing of Progressive Web Apps. Once you've finished this course, you'll know how to turn your standard web app into something that's installable, works offline, and can more deeply engage users via push notifications using nothing more than a browser and your existing web development tool set.

Course author
Author: Nik Molnar	
Nik Molnar
Nik Molnar is a Program Manager at Microsoft and co-founder of Glimpse, an open source diagnostics and debugging tool. Nik lives in Austin, Texas where he specializes in web development, web...

Course info
Level
Intermediate
Rating
4.4 stars with 65 raters(65)
My rating
null stars

Duration
2h 56m
Released
8 May 2017
Share course

Course Overview
Course Overview
Hello everyone! My name is Nik Molnar, and welcome to my course, Progressive Web App Fundamentals. I'm a program manager at Microsoft and a long-time web developer and web enthusiast. And the web is the most powerful, ubiquitous application delivery platform in the world. And, yet, in recent years, it's become an underdog overshadowed by native applications brokered through costly app stores. But the introduction of a set of new technologies, which when used together super-charge existing web applications into powerful progressive web applications, have the web poised to steal back the spotlight it so rightfully deserves and to engage users more deeply than ever. In this course, we're going to learn the fundamentals of progressive web apps covering application manifests, push notifications, background syncing, as well as the best practices and recommendations you should follow to make a truly great app. By the end of this course, you'll now how to turn your standard existing web apps into something that's installable, works offline, and can more deeply engage users with push notifications using nothing more than a browser and your existing web development toolset. Before beginning this course, though, you should be familiar with JavaScript and service workers, which are covered fully in my Pluralsight course called Building Offline Web Apps with Service Worker. I hope you'll join me on this journey to learn how to super-charge the web with the Progressive Web App Fundamentals course at Pluralsight.

What Is an "App"?
Introduction
Hi! I'm Nik Molnar. I'm a web developer who lives in Austin, Texas. I tweet at @nikmd23, and I blog over at nikcodes. com. Today we're going to cover Progressive Web App Fundamentals. And we'll begin by exploring the idea of, What is an app? To do that, I'd like to begin by charting how applications have evolved over time across two different axes. The first, the vertical axis, is reach. And reach is the ability to make your application available to anyone anywhere. The second, the horizontal axis, is richness. This is how rich the client-side interactivity of the application is and how intuitive the user interface is to use. In the beginning, applications were not very rich, and they were only used locally. An example of this includes command line tooling where everything is on a black and white screen, and you have to type in arcane commands to make the computer do what you want to do. These were really only good for computer enthusiasts like you and I. Then somewhere around 1992, we began to explore the next phase of the application evolution, which was graphical user interfaces. These were much more usable and much richer interfaces for users but still quite local and only lived on your machine. And then sometime around 1998, the web really began taking off. This was a great step forward for reach because we could build one web page that would be available to anyone anywhere. It didn't matter what their platform was or where they lived. Unfortunately, the web 1. 0 was very limited to mostly just text and maybe some basic images. But over the years, things on the web got better and better, and richness increased. I'd say the pinnacle of this was in the mid-2000s--2004, 5, 6--where Flash and Silverlight were really taking off and allowing us to play video and audio and have animation and interact with webcams and microphones. This was a great time for the web. And all was going well until sometime in 2007 when everything changed. That's when Steve Jobs stepped on stage and introduced the iPhone. The iPhone was an incredible device for the time. It had a speaker and a microphone and a touch screen. One of the very interesting decisions that Apple made about the original iPhone was that there would be no SDK for creating native applications. Instead, Apple encouraged everyone to create web applications, which sounded like a great idea considering the state of the web and how rich the interfaces were thanks to Flash and Silverlight. However, Steve Jobs, Apple's founder and CEO, was not fond of Flash or Silverlight, and he had never allowed them to be run on an iPhone calling them spaghetti-ball pieces of technology that had lousy performance and really bad security problems. The fact that Flash never shipped on an iPhone really signaled the beginning of its demise. And instead of getting this rich web-based application model on the iPhone, instead one year later in 2008, Apple introduced their native application SDK, which began the era of the app. Now apps are different. They take a step back on reach, but they're much richer experiences. They use touch and gestures and eventually added in voice control. These are very natural user interfaces for humans to interact with. Unfortunately, unlike the web, Apple's native SDK was proprietary. And the huge success that they had with it meant that other smartphone vendors followed suit with proprietary native SDKs. So we took a major step forward in richness but a major step backwards in reach. Since that time, companies have been forced to have an iOS team to make their iOS apps, an Android team to make their Android apps, and whatever other teams they need for all the other proprietary platforms that are available. This is the problem of not having an app model with reach. We need to make multiple applications for multiple platforms. So what we really want to do is figure out, How do we move from this very rich but not great reach position into the ultimate position where we have both richness and reach? To understand the requirements for what such a solution might look like, let's consider some of the features that make what we call an app an app.

What Is an App?
When users talk about apps, they usually have several expectations in mind. First of all, the app was something that was findable in an app store. This is particularly true on mobile platforms where developers use the iTunes store or the Google Playstore for example. Next, users expect apps to be icons on their home screen, icons that they can move around and prioritize as they please. They love its touch and gesture to control them. Many of them will work offline or at least provide a basic experience when offline. They can receive push notifications about events and things that are happening within the application even if they're not looking at the application currently. The apps can do some amount of background processing, whether that's just simply playing music, uploading or downloading content, or doing some other CPU-intensive processing. And, finally, users expect apps to have access to the features and sensors of whatever device it is that they happen to be running the app on. This set of expectations and features makes apps sound pretty amazing actually. And because of that, they've dominated a large segment of the developer population over the last 10 years. But some studies show that they aren't all that they're cracked up to be. Let's dig into this a little deeper and look at the numbers.

Apps vs. Sites
For this next clip, I've compiled together a bunch of data from ComScore's 2016 Mobile App Report. That report shows that in terms of which platform is getting more users, there're way more people hitting websites than apps. The top 1000 sites average 11. 4 million unique visitors a month compared to the top 1000 apps, which only get 4 million. But app users are much more loyal spending nearly seven times as much in native applications than they do on the web. This means that user acquisition is much easier on the web, but retention is harder. This time split paints a pretty bleak picture for the web. However, if we dig a little deeper into app usage, we see that it's a very short tale with users spending 46% of their time in their most-used app. Half of your time is spent in your most-used app. And then nearly 19% in the second most-used app, 10% for the third most-used app, 7% for the fourth most-used app, 4% for the fifth most-used app, and 14% of their total time spent on all of the other apps combined. This means to get any reasonable amount of time spent in your app, you have some pretty fierce competition. Let's take a look at what that competition looks like. Here're the ten most-used apps in the world by unique visitors according to ComScore. Facebook owns the top two and three of the top 10. Google owns another five of them, which means that two companies control seven of the most-used apps in the world and eight of the top nine. So if your name isn't Facebook or Google or Pandora or Amazon, the other two apps in the top ten, you're going to have a hard time being one of your user's most-used apps. And that's just looking at the usage numbers. Usage only matters after an app has been installed. But nearly half of all users, 49% of them, on average install 0 apps per month. Half of all app users don't install an app in any given month; 13% of users install one app a month; 11% of users install two apps a month; 8% of users install three apps per month; 6% of users install four apps a month; and there's only 13% of users that install five or more apps per month. So getting users to download and to use your app is a bit of a challenge. There's one other consideration to factor in, and that's growth. And over the last two years, the top 1000 websites have grown at twice the rate in terms of monthly audience than that of the top 1000 apps. Now they are both growing, so there is some opportunity in the app stores, but the web is seeing much bigger growth. In fact, Chrome browser alone gets over a billion users daily. That's a pretty impressive number. So we've talked a lot about apps, and through this data we've compared it to sites in the web. But what is it that makes the web the web?

What Is the Web?
What makes the web the web can often be a rather philosophical question. But I really like the list of items that Google developer, Alex Russell, put together. He states that the web at its heart is about URLs and links, which is true because this whole thing started off as hypertext allowing you to move from one document to another with an address that we can hand around that anybody can get back to the same document. The web is also all about markup and styling that's readable by both humans and by machines. And it's progressively enhanced for additional richness and capabilities. We can start with our content. We can layer on styling with CSS. We can add additional behavior with JavaScript, and so on and so forth. And, finally, the web is free to implement. Anybody can create a site using simple tools that are free. You can publish and get your idea out there. Now you might be asking yourself, Aren't there other app models that follow this? Aren't there other app models that were built from web technologies? Well, yes, we have them. Many platforms have tried to create app models based on top of web technologies. They include names like Adobe AIR, Palm's WebOS, Apache Cordova, which is specifically geared towards mobile devices, Microsoft's WinJS, Electron, the latest entrant to throw its hat in the ring, and even the W3C, which is the standard's body that controls a lot of the way that the web works, created their own specification called Widgets. But, unfortunately, all of these technologies excluded one of the web's most important aspects--its free-to-implement deployment model where anybody can publish at any time. So if none of these technologies are going to let us have our cake and eat it too, to let us have both rich UIs and provide our applications with true reach, then what will?

Introducing Progressive Web Apps
Hopefully the thing that will give us both richness and reach without compromise is the hero of today's course--the progressive web app. Progressive web apps begin life as 100% web, which gives us the reach and all the properties that come along with being the web. But they also have the ability to be enhanced into rich applications that are first-class citizens on the platforms that support progressive web apps. In reality, a progressive web app isn't a new thing per se. Many of the technologies that drive progressive web apps have been around for quite a while. What makes progressive web apps special is really the fact that these technologies have been pulled together to serve this purpose and give it a name. Alex Russell, one of the forefathers of progressive web apps, states that, "it happens on the web from time to time that powerful technologies comes to exist without the benefit of marketing departments or slick packaging. They linger and grow at the peripheries, becoming old-hat to a tiny group while remaining nearly invisible to everyone else. Until someone names them. " This phenomenon that Alex is talking about has happened several times in the past. Many different developers used XMLHttpRequest in their earlier versions of IE. But Ajax didn't become a thing until Jesse James Garrett gave it that name. Likewise, it took Ethan Marcotte to coin the term "responsive web design" to change the way that we think about content. So Alex Russell has given the name "progressive web app" to this collection of technologies. So what are they? What is a progressive web app? Well he lays out nine attributes of what makes something a progressive web app. First, it's responsive. Your application will fit any form vector just like Ethan Marcotte coined the term. Next, it's connectivity independent. It'll work online or offline. Or even on a spotty network, which is probably the most important. Third is app-like interactions for both the navigations and the way that you use the app feel like they're native. Fourth is that the app is fresh. It's always up to date, and those updates happen transparently thanks to the web and service workers. Next, it's safe, and it's safe because it's served over transport layer security or HTTPS to make sure that no third parties are snooping on your traffic. Sixth, Russell says that they're discoverable, and that they're identified as applications thanks to the W3C manifest specification that we'll be looking at in a little bit, as well as search engines that are able to find them. They're re-engageable. They're applications that can reach into their host operating system and tie into the mechanisms that are available there to re-engage you, most commonly thought of as push notifications. They're installable allowing you to add them to your home screen or to whatever desktop metaphor is being used in your OS. And, finally, they're linkable. There's no friction to install, no friction to access. A URL is the entry point at which you will find and access an application. So effectively, progressive web apps are just websites that took all the right vitamins. They started off as a website, and they grew up strong to become applications. And these applications can be especially strong, stronger than most people realize. The capabilities that the browser makes available to these types of applications is extensive and growing all the time. Let me tell you about just a few of them. First of all, you have a network proxy available to you to change, sniff, cache, do anything that you want to with traffic available on service worker. There's app packaging so that these things can be installable with W3C manifests. Push notifications are available. And background syncing so that you can do some offline tasks to get information from the network or send information up to some API somewhere. All of these will be covered in this Pluralsight course. Additionally, there's local storage so you can save data on the device. There's the gamepad API which allows you to interact with joy sticks and controllers that may be plugged into the machine. The page visibility API lets us know if the user is physically looking at your application. There's the ability to capture audio and video and photos from the camera and microphone, as well as the ability to play back audio and video with media playback. We can make devices vibrate. We can check the battery status and go into low power mode for our applications if the user's about to run out of battery. Integrated payments are coming to make it easy to do one tap and pay for something in one of our applications. Credential management to make logging in easy. Streaming of networks to get really low-level access to networking. We have the ability to do peer-to-peer communications, access Bluetooth accessories, and even share things across the web with the new web share API that's being worked on. In fact, there're so many capabilities that there's a bit of a humorous website called youmightnotneedelectron. com, which just proves to you that with all of these capabilities maybe you don't really need to install some giant framework to build an app. Something to think about. Let's go ahead and take a look at progressive web apps in action.

Demo
For this demo, I'm going to introduce you to three different things. First, we'll take a look at pwa. rocks for progressive web apps rocks, a project from the Opera dev relations team. Next, we'll look at the demo application for this course, SodaPopped. com. And, finally, to see how it works as a mobile app, we'll use the Android Studio Emulator. So first we'll start in Chrome looking at pwa. rocks. This is a listing of progressive web apps from around the world the Opera dev relations team has put together. There're some fun little sample apps in here and some more serious apps, like the Flipkart app, which is a major eCommerce provider from India. They've bet quite heavily on the progressive web app platform. There're a whole lot of apps in here, and as you'll see if we scroll down towards the bottom, we'll find our app, SodaPopped. com. Let's take a look at that. SodaPopped is a simple little social drinking application similar to Untappd and Vivino for beer and wine, but SodaPopped just features craft soda. We can see the list of available different brands. We can drill into one of those brands and see the different beverages that they have. Let's take a look at this caramel apple soda from Boots Beverages. And we can find some information about it. All the various flavors are indexed by whether or not you want something that's fruity or cola or has coconut in it. Let's go ahead and take a look at some of the colas. And here're all the different brands who make a cola that are in the catalog. I can drill into one of the specific drinks, and here you'll see one of my favorite colas, this Mexicane Cola made from Maine Root. And I can upload photos. I can write a review about that beverage. And, of course, I can go to my profile. Here're all the sodas that I've reviewed and the pictures that I've uploaded of them. And then, of course, the actual text of the reviews. Let's go ahead and take a look at SodaPopped inside of the Android Emulator. Inside the Android Emulator, which I'll show you how to get and set up in our next module, I can open up Chrome, and I've already browsed over to SodaPopped. com. All the same features are available. But as you can see, this sight has scrunched down and worked responsively to fit the mobile form factor. So here's my list of brands. And, once again, I can go back to my profile. Here're all the sodas that I've taken pictures of and their reviews. But because this is a progressive web app, I can get prompted to add SodaPopped to my home screen. When the prompt pops up, I hit the Add to Home Screen button. And from here, I can actually go ahead and close chrome entirely because now on my home screen, I have an icon for SodaPopped. When I open it up, a splash screen appears here in blue until the page loads. And then it loads, and now I'm using the app. But you'll notice the app is no longer called Chrome. It's called SodaPopped. It is its own application that's running as a first-class citizen along with the other apps on Android. I'll go ahead and open it again. The other great thing is I've been able to set up push notifications. If I go back to my profile, I've already gone ahead and subscribed to push notifications. And so if while I'm using the app or even if while the app is shut down, if some alert comes in, like this one that we just received, here's a little notification that's telling me some news about SodaPopped. Great! It looks like Fest Cola has introduced a new soda, Southern Peach Ginger Ale. That sounds good. Let's go take a look at it. When I click on it, my app will open up, I'll see my splash screen, and, great, look at this. Brand-new soda. I can be the first to review it. So as you can see, it's pretty hard to tell that this is any different than a standard native app. We're going to learn more about how to build these as we go through the rest of the course.

Summary
There're really five key things that we need to learn about to understand the fundamentals of a progressive web app. The first is how to take applications offline. Now we won't actually be covering that in this course. Instead, I would encourage you to check out my Building Offline Web Apps with Service Worker Pluralsight course. It does a deep dive into service worker and everything that you need to do to make your website work offline. So with that prerequisite out of the way, in this course starting with the next module, we'll look at how to make a web app that you can add to a home screen. In module 3, we'll cover how to send push notifications. In module 4, we'll dive into background syncing, so that way we can send data when your app is not even running. And we'll wrap up the course by looking at some best practices for progressive web apps. So in review, in this module we covered the balance between richness and reach for applications over history. We took a look at what users expect from apps and briefly covered the history of web-based app models. We dove into some data that compared the usage between applications and websites. And I introduced the concept of a progressive web app. And we took a look at one with SodaPopped. com. So onto the next module where we will look into how to add an app to a home screen.

Adding to Home Screen
Why Add to Home Screen?
In this module, we'll cover how to meet one of the first expectations of app users, which is the ability to add an app that they like to their home screen. But before we get too far into learning how to get our progressive web apps running on the home screen, let's talk a little bit about why we'd want to make that possible. For ComScore's 2016 Mobile App Report, they looked at where users place their most-used application. And by an overwhelming majority, the place that users put their most-used apps is on their home screen. Seventy percent of them, in fact, put their most-used app on their home screen. If progressive web apps are ever going to compete at all, we're going to have to get our progressive web apps onto our users' home screens. ComScore also dug into why users decided to put their apps on their home screen. Fifty-nine percent of respondents said that they prioritize home screen access to the apps that they use the most. This rings true with me. I know I do this. I keep my browser and my email up on my home screen because those are the two apps that I use the most. Nearly just as many people said that easier access was a motivating factor for putting an app on the home screen. That's the reason why my Google Maps navigation application is on my home screen, as well as my remote control app. Forty percent of the respondents took into account situations for when they need to use the app quickly. This factor really resonates for me. On my phone, the home screen has my camera app so that way when my little daughter does something really cute, I can whip out my phone and quickly take a picture. However, my wife keeps her camera app buried inside of a folder. And so whenever I'm holding onto her phone and she says, "Babe, take a picture of our daughter, " it takes me forever to find the camera to take a quick picture. And it's really frustrating to me. So I do the same thing, I put apps that I need to access quickly on the home screen. Next, ComScore found that 27% of people place an app on their home screen just due to their sheer interest in that app or that kind of app, which is true for my Major League Baseball app and SodaPopped of course. And, lastly, 12% of respondents put an app on their home screen just simply because they like the logo of the app, which really isn't my cup of tea. That's not something I've done before. So now that we understand why users put apps on their home screens, and that we really should be able to provide them with that functionality, let's figure out how to actually do that.

Intro to Web App Manifest
Letting a user add your progressive web app to their home screen begins with W3C's web app manifest specification. Now you may be thinking, Haven't we always had Add to Home Screen functionality since the early days of the iPhone? Well, yes, that's true. But with the web app manifest specification, we finally have a standard way to do it and to rally behind. In the past, every different browser had their own proprietary implementation, and it was really hard for us to achieve Add to Home Screen across all different platforms. The web app manifest makes this simple though with a JSON file that we fill in some metadata on, and that's it. It's done! We'll cover that JSON file in depth in a moment. And not only do we now have this standard, but the web app manifest starts to allow progressive web apps to do more than the old Add to Home Screen ever did. Web app manifest allows progressive web apps to more deeply integrate with the host OS. Now our apps can stand alone in a task switcher or appear in privacy and security settings, things like that. But, of course, as with all web standards, a standard is only good if browser vendors actually implement them. So the browser support for web app manifests looks like this. We've already got support shipped in Chrome and Opera. And Microsoft and Mozilla are adding support to Edge and Firefox as we speak. Essentially, by the time you're watching this course, support might already be available in all of the major browsers except for Apple's Safari, which still has proprietary implementation but a lot of ways to achieve the same kind of things. So throughout the course of this module, any time that there is an Apple-specific way to do something, I'll call it out just so you know I can be as compatible as possible. Of course, browser support changes over time, so depending on when you're watching this course, you might want to check out and see what this matrix would look like today now for you. So for that, you can either head over to caniuse. com or head over to the course notes at nikcodes. com/wpa-fundamentals, and I'll provide the exact link that you need there. Now using a web app manifest couldn't be easier. You just add a link tag to the head of your HTML pages with a rel of manifest and point the href to the manifest. json file. Now technically it's suggested that any manifest JSON files you serve up from your server use a content-type header of application/manifest+json. But it's not strictly required. And that's it. Now you've wired a manifest into your application. Let's take a look at what goes inside of the manifest.

Manifest Properties
As I've mentioned, a manifest is simply a JSON file that has some specifically named properties inside of it. I've broken up those properties into a couple of different categories just to make consumption in this course a little bit easier. The first category is around identifying your app, and it has two properties, both name and short_name. Next there's the way that you present your app with several different properties including the start_url, theme_color, background_color, orientation, and display. And the third category is icons, which is the way that you will graphically represent your application to your user. Let's take a look at what these different properties will look like inside of your manifest file. So here's my manifest. json. I have two different properties called name and short_name with two different values. In this case, I'm calling both of them SodaPopped. Now the short_name property shows up under the apps icon on the home screen. And the name property shows up in the various different install prompts to add to home screen and the app-installed banner. Now Safari on iOS has a similar type of property that's used with a metatag called apple-mobile-web-app-title. It's a bit of a mouthful, but if you set that metatag, then Apple will pick it up and also allow you to name your app when users choose to add to home screen on an iOS device. Next, we get into some of the presentation category properties. The first one we'll look at is the start_url. This is what URL in your app should the users go to when they press the icon on the home screen. In my case, I'm just going to the home page so I have /. You might want to do something a little bit more specific for your app or even tack on a query string parameter that tells you that that user has come from an installed app as opposed to typing the URL directly into a browser. The next two presentation properties are colors. So, first, the background_color, which is used to create a splash screen. So in this case, my background_color is a bright blue, and the splash screen that pops up when somebody clicks on my app's icon will use the bright blue color I've specified here, as well as the icon and the name. The next is the theme_color. The theme_color is used in the Chrome of the application. So in this case, I've chosen a dark blue color that just blends right in with my application. So it doesn't even look like there's a difference between the Chrome and my app. Here, I'll change it to red. And so now you can see if my theme_color was red, it would look something like that. In iOS, you can set a splash screen image with a link tag that has a rel value of apple-touch-startup-image. Lastly, I'll also point out that the theme_color that we set here is the global theme_color for your site, but if you have a specific page in which you want to override the theme_color, then you can just set a metatag whose name is theme_color and set whatever color you want to override for that specific page. The next property is orientation. Orientation can be set to any, which allows the user to rotate the phone however they want to. Or you can put it into a portrait mode where the buttons on the phone will be on the bottom or into a landscape mode where the buttons on the phone can be on the sides. The next property is display. I think for the purposes of this course, you'll mostly want to use standalone, which will make your app look and feel the most like a native application. But you can set it to browser, in which case the browser's URL and some of its navigation and its own controls will be available. But in standalone, your app basically takes over the whole screen, and you have to provide Back buttons and navigation and all those kinds of things the browser normally would. You can do something kind of similar on iOS by setting a metatag named apple-mobile-web-app-capable with dashes in between all of those words. The next category is icons. Now icons is actually an array of objects where each object describes a different icon. And what you'll want to do is you'll want to put in a source, which is a path to wherever your image lives, the type of image it is (in this case, I'm using all PNG, so it's image/PNG), and then the sizes property, which tells the browser what size the image is before it downloads it. In this case, I have a 192 x 192 image. When the browser goes to use these images, it will download the most appropriate size for the device and pixel density on the device the user is using. These icons show up in all kinds of different places, the icon on the home screen and the install prompt and the install banners. And iOS has similar functionality with their Apple touch icon link tag. The next category of properties that we'll look at is some miscellaneous properties. We have dir for direction, lang for language, description, scope, and serviceworker. So I'm going to comment out all those other properties. And in the same manifest, we'll keep on adding to these properties. The first is dir, which in this case I've written ltr, which means left to right. I could have also done rtl, which is right to left. And this is the direction in which all of the text you're describing in the manifest should be read. So because SodaPopped is read left to right, I do ltr. If I was in a country or a region where people read right to left, I would flip that and, thus, flip my text. Next we have the language. This is English of the US variety. And so I do en-US. The description can be used to describe my app. The scope is a very interesting property and probably the most important property of the miscellaneous ones. The scope tells the device what part of the URL scheme for your domain this app owns. So, for example, because my scope is /, this app owns all the URLs for SodaPopped. But if I had /foo here instead, any URLs that did not begin with /foo instead of opening in my app would open in the browser because we're saying that that URL is not inside of the scope of what this app controls. The last property is a serviceworker property. If you're unfamiliar with serviceworkers, you should really watch my service worker course that's now available on Pluralsight. But, essentially, this is yet another way to register your service worker. And you can set both the source and the scope, and any of the other options that are available on service workers can be set as additional properties here. The last category of properties that we're going to look at have to do with applications. And by this, I mean native applications that might be associated with this site, not necessarily progressive web apps. Those are related_applications, prefer_related_applications, and screenshots. Essentially the same way that your site can declare that it is an application, your site can also declare that there is already a native application associated with this brand. You've probably seen this before on things like espn. com or cnn. com where you'll get a prompt to ask you, Do you want to install the native app that goes with this experience? Given that you're taking a course on how to build a progressive web app, I'm not sure if you'll ever need these properties, but I wanted to include them for completeness' sake. So the first property is screenshots. It's an array of images just like the images that we saw for icons. And so you'll pass in the source and a path to the image of a screenshot. I could potentially see Windows using this property on a progressive web app because Microsoft has said that they will include progressive web apps in their app store. I don't know if they actually will use the screenshots property, but I could see them doing that. So keep an eye out for that. The next property is called related_applications. This is where you actually define the app that's in the native app store. You can specify a platform which, would be something like Play or iTunes. And then the other properties like URL or Id may or may not make sense depending on the platform. For the play store, you'll have to both specify the URL to your app, as well as your app's Id. And the last property is prefer_related_applications. This is a Boolean, and you use it to tell the host operating system whether or not you prefer to open links in the browser or in the related applications. So in the ESPN case, if they set this to true, when you click on an espn. com link, it would actually open in the application instead of in the browser. So now that we've seen all of the different properties that are associated with web app manifest, let's go ahead and look at how we can build one of these.

Creating a Manifest
For this demo, we're going to use my favorite web app manifest creation accelerator called realfavicongenerator. net. We'll use it to both generate a web app manifest, as well as to check our site for its usage of icons. So now I'm in Chrome, and I'm at realfavicongenerator. net. This is an online tool that helps you to create web app manifests, as well as images at all the right sizes for the various browsers and the way that they like to see these kinds of images. It's a pretty simple wizard-based tool. Let me show you how we'll use it. The first thing we need to do is select our main image. In this case, I have an SVG of a bottle of cola that we're going to use. The generator does some processing and starts to allow us to see some options. The first set of options is around iconography for iOS and its proprietary system. Realfavicongenerator. net not only knows about web app manifests, but it also knows about iOS's proprietary options. You can see in the center here what my icon is going to look like on iOS. I'm going to change the color to that bright blue that I mentioned earlier. I'm going to remove any of the margins so my icon uses up all the space. That's it as far as iOS is concerned. Next for Android, I have a few options that I can make. The first is my app name, which will be SodaPopped, and I'll want to set my theme_color, which is that dark blue that I mentioned earlier. You can see here what it'll look like on the splash screen. Actually, in fact, this is a bug in the realfavicongenerator. They used the theme_color to show the splash screen. The background_color is what's actually used for that. But you will see in the switch here that it is showing that the Chrome will look like it's the right color. If I go in to see more options, we'll want to make sure that we're not in browser mode, that we're in standalone mode. And I want my Start URL to be /. I can force my users to open up the portrait mode or the landscape mode, but I'm going to go ahead and leave it unspecified so it can be either. Windows and Edge also use proprietary system for setting its properties. I want to be nice and support edge and realfavicongenerator lets me do that. Let's fill in the color that we're going to use. Once again, I'm going to use my bright blue. And we'll use the original icon as is, not this white silhouette version. Safari on Mac OS also uses some special images for both pin tabs that are focused and unfocused and the touch bar. We'll change the color of that touch bar to be a kind of red color color like that. That looks great. There're a few other options that I can use, but this is all that I'll need. You can explore on your own if you'd like to. I'll go ahead and hit Generate, and it does some crunching and soon it comes back with a zip file of all the images and assets that I need, as well as any of the tags that I need to add to the head of my HTML pages. Here's the Favicon package. Let me go ahead and save that. It's being downloaded. And here's the HTML that I need to add to my head. Before we do that, I also want to point out that not only can I download this stuff when I generate it on the fly, but I can use Gulp or Grunt, and realfavicongenerator. net will even generate the Gulp or Grunt code that I need to add to my build. So I could just copy this, and every time I run a build, I'll get whatever updates have been made to these assets. We'll stick with this. Let me go ahead and copy my HTML. I'll switch over to Visual Studio. I'm going to paste that into the head of my main layout. I'm actually going to remove the theme color because that is the page-by-page specific override. I'm fine with that global color. So I've saved that. Now I'm going to switch over to the directory where I downloaded all the files, and you can see my zip file for favicons. Let's go ahead and extract all of these right here. And there're our favicons. And we're going to drop them into my web project, all of these moved here. Great! Now if I go into Visual Studio and refresh the listing of files, there're a whole bunch of files that have not been added to my project yet. So let me go ahead and add each of these into my web project. And now when I deploy to Azure, these assets will be included. Let me go ahead and take a look at the manifest. This looks great. It's very simple. But realfavicongenerator does miss a couple of properties that I'd like to have set. The first is short_name, which will also be SodaPopped. I also notice for some reason here that my theme_color and my background_color were set to be the same. Let me go ahead and fix that. There, now my background_color will be that bright blue, and my theme_color will be the dark blue. Also the orientation is not explicitly set, and I want to do that. There, that looks good. Now I've already made these changes and deployed them to the live site. Let's go and see what realfavicongenerator's checking functionality will do for us. So I'm back at the website, and instead of going to the generator like we did before, this time I'll go to the checker. We'll check my site, which is an HTTPS site and go. Now realfavicongenerator. net will check my site to make sure that I'm following all of the best practices to integrate my iconography with whatever browser my users happen to be using. When this check finishes, it will come back and show me exactly how everything will look in each of the browsers. So here we go. On iOS, I can see my icon with the bright blue image. On Android, I have this little bottle with no background behind it. On Windows 8 and 10, it looks like I actually have a bit of an error, and that's good for me to see and know. Now I need to go and fix this. This is not the color that I wanted, and the name isn't right either. Everything looks good on Mac OS X, as well as my favicon. So I'll go in and I'll tweak the colors on Windows 8 and 10 and make sure everything looks good. But it's a good thing that this check was available for me to find that. In the next module, we'll look at deeper ways of testing and making sure our manifest is doing what we want, particularly on Android.

Testing Manifests
In the last clip, we saw a very basic and simple way to do some high-level checks on our web app manifest. In this module, though, I want to introduce you a little bit to Android Studio, a free IDE for developing Android apps. We won't be doing any actual development in Android Studio. Instead, we're going to use the built-in Android Emulator to get an Android environment up and running that we can see our app running in. So we'll do a couple of things. First, I'll show you how to get the emulator up and running. Next, I'll show you how to connect Chrome dev tools directly into the version of Chrome running inside of the emulator. We'll look at how to then manually add our progressive web app to the home screen and see our web app manifest in action. And, lastly, we'll take a look at install banners, the best way to get users to install your application. To get started testing web app manifests with the Android Emulator, you'll want to download Android Studio. You can get Android Studio for free from developer. android. com/studio. Just click the giant Download Android Studio for whatever your platform of choice is and follow the installation steps. Once it's installed, go ahead and get it up and running. If you have to create a new project to open it, just go ahead and create anything. It doesn't really matter. All we really want to be able to do is use the Android Virtual Device Manager, which is this tiny little button in the tool strip. Go ahead and press that button, and the manager will be opened. Now the first thing you'll need to do is create a new virtual device. Click the Create Virtual Device and input the settings that I'm using for my device. Let's look at my settings. The new device will let you give a name (I'm calling mine Pluralsight), as well as select which kind of hardware you'd like to run. There're all different shapes and sizes available. Pick whichever one you'd like. For this course, I'm going to use the Nexus 6. You can also choose the version of Android you'd like to target. All the different versions will be available here. I'm going to use the newest one available, the Nougat release, which is at API level 25. If you don't have the image for that version of Android already on your machine, you can just click the Download button. And after it's been downloaded, you'll be able to select it. There're a few other settings I like to set. For the emulated performance, I always like to make sure that Hardware is selected. And then in the advanced settings, for my app I have a webcam, and so I will point the webcam in the emulator to the webcam on my laptop. And I also make sure to enable keyboard input. This allows me to type on my physical keyboard into the emulator. When all of that is done, hit Finish. Once you have your virtual device created, go ahead and hit the Play button to boot it up. When the window appears, you can resize it and drag it and place it on your screen however you see fit. There, that looks great! Now the first time you boot your device, you might have a really old version of Chrome running on it. There're probably multiple ways to upgrade Chrome on Android, but the easiest way I've found in the emulator is to open up whatever version of Chrome you do have and head over to www. apkmirror. com/apk/Google-inc/chrome. Here you'll find a listing of all the versions of Chrome and the APK files that you'll need to download. When you click on it and download, it'll automatically the newest version of Chrome or whatever version you selected onto your device. And with that, you have Chrome up and running in Android. So we can go to any site we want to. In our case, we'll head over to SodaPopped. com, and we can see our site running on an emulated device. Now before we dive too deep into the emulator, let me take a step back and show you what we could be doing in Chrome locally on my machine. Here I'm running my site on the localhost, port 55194. This site is running through the web server built into Visual Studio. If I open up the Chrome developer tools, I can head to the Application tab and look at the manifest options. This is telling me how Chrome is seeing my manifest. I can see the name we specified in the earlier clip, the theme and background colors, my orientation, display, and the icons that I'm using. This is really great for when I'm running the app on my local machine. But this localhost, port 55194, I'm not going to be able to navigate to in my emulator. I'll show you. From here we'll go to localhost:, port 55194. And, of course, the site can't be reached because port 55194 on the localhost, which in this case is the Android Emulator, isn't going to work. But there's a little trick that we can do to get access to our local web server that's running on our box. Back in Chrome, if I head over to the chrome://inspect URL, I have the option to turn on port forwarding. What I want to do is I want to forward to localhost:55194 what's running on my actual machine. And I can pick any port that I want to. I'll use 8080 in this case. Any traffic that comes in on port 8080 will automatically be forwarded to 55194. As long as I have this tab open and that setting turned on, port forwarding will be active as you can see in the yellow banner. So now if I switch back over to my Android Emulator and I change the port to 8080, Chrome actually does proxying and connects me back to my local web server. So now I can hit breakpoints and debug in Visual Studio from the Android Emulator. One last trick that I can do on this chrome://inspect tab--I can see all of the different tabs that are running not only on my device but on remote devices. So here we have this Android SDK. This is my emulator. And I can see that I have the SodaPopped running in port 8080. I'll go ahead and hit Inspect. The Chrome dev tools will appear. And now I'm actually looking at what's happening inside of my Android Emulator, and I can scroll around, and I can select things as if I was looking at the local site. I'll head back over to my Application tab, and I can see my manifest and the information contained within it as we could before. Now how do I actually add SodaPopped as an app in Android? Well I can do what I'd call the old fashioned way by clicking on the menu and going down and saying I want to add to the home screen. This will let me rename it if I want to, but we've prepopulated the name because we filled out the manifest properly, and there's an icon. Instead, what I'd prefer to have happen is to have this site prompt the user to add to the home screen. Chrome for Android will automatically do this to users who are engaging with your sites as long as this site meets certain criteria. It looks something like this. You see that prompt that popped up there at the bottom? This will happen automatically at some semi-difficult-to-determine time for users who are using your apps. It will ask them, Hey, do you want to add this to the home screen? It looks very much like the standard native Would you like to install this app? banner. Now the Chrome dev tools let us spoof it or emulate what the Add to home screen banner would look like, but we'll look like when it would naturally do this in the next clip. I'll go ahead and say, Yes, please add to home screen. And if we go back, we can see that it's now installed with the proper icon and name. And if I open it, I see my splash screen, and now my app has taken over the whole screen, and it's given its own Chrome. Here you can see the SodaPopped in the foreground as in the app and Chrome in the background, which I'll close. There we go. We are our own app running in Android. You can see that the dev tools say that I was disconnected. That's because I just closed Chrome, the browser. However, if I go back to chrome://inspect, I can still see that it's running, but this time I connect to it again, and I'll be connecting it to SodaPopped, the app running on Android. It can be a little confusion, but you'll get the hang of it after a little while. So let's talk a little bit more about this Add to home screen banner and when it will actually appear.

Install Banner Requirements
As I mentioned, the app installed banner that we were able to force using the Chrome dev tools will appear automatically for users if your app has certain criteria. That criteria is fed into a heuristic and is constantly being tweaked by the different browser vendors. At the moment, there're a few things that we know your app will need to do or properties it'll have to have before an install banner would ever appear to your user. First, you have to make sure that your site is served securely with HTTPS and a little green lock icon, which would mean that you have no mixed content warnings or anything like that. Next, you have to have a service worker registered. Your start URL must work in offline mode and at least return a 200 in some kind of experience. And you also have to have a web app manifest with at least the following properties--a name, a short_name, at least one icon with the size of 144 x 144 or larger, a start_url, and a display mode that's either standalone or full screen. These rules and settings will change over time. And in the last module of this course, I'll show you the best way to automate checking to see if your application is meeting whatever the current set of rules is. But for now, let's move on and look at some of the events that are raised by the app manifest that will help you customize the experience for your users.

Manifest Events
So far in this module, we've only looked at the declarative properties that can be specified in a web app manifest. But the manifest specification also adds two programmatic events that we can use to understand how users are interacting with the installable nature of our applications. The first is onappinstalled. It's pretty simple. We can add an event listener for that and know that our user has installed the app. So in this case, I'll just do a simple console. log. This event is very basic. The more interesting of the two events is the beforeinstallprompt event. When that event is fired, there's a property called userChoice that you can call, which will return a promise that resolves once the user has made a choice on the install prompt either choosing to dismiss it or add to the home screen. Since userChoice returns a promise, we can add a then call to it, and their choice will be passed into the function used in that then. I'm going to create a simple variable called message here where we look at the outcome of the choice. And if it was equal to the string dismissed, then I'm going to set the message to User cancelled. Otherwise, I will say User installed. And for the purposes here, I'll just simply log out that message. So now I know that the user saw the prompt and whether or not they decided to add to the home screen or dismiss the prompt. But perhaps the prompt wasn't raised when you'd most want it to appear. We're not allowed as developers to force that prompt to appear to our users. We can do it in our dev tools to help our testing, but we can't choose when it appears to our users. But using the beforeinstallprompt event, we can kind of get around that. So let's re-implement it. This time what I'm going to do is I'm going to take that event, and I'm going to prevent the default thing from happening. I'm not going to have the install banner appear. Instead, I'm going to tuck the event away into some global state that in this case I'll call promptEvt. Now at some time in the future, after I am pretty sure the users had a positive interaction with my app, perhaps I gave them a freebie, or they just successfully purchased something, then at that point, I will check to see if we've already had a promptEvt that we've stored away. So in this case, if we do have one, then I'm going to call the. prompt method on it. Remember, this promptEvt is the event from when the prompt happened before that we cancelled but we've stored. So effectively, Chrome has said, I'm about to show the user the banner. We've cancelled, but we've saved the ability to show them the banner until later. And now we're choosing to show it to them. We have to do the same thing we did before if we want to know if the user did add or dismissed. And so in this case, once again, we call. userChoice, and we follow the same promise chain that we did before. I've simplified it in this case just by logging out the. outcome property. And that's it. Those are the two events that are available to us on the web app manifest.

Summary
That about does it for the web app manifest specification and adding the Add to home screen functionality to our apps. So let's recap what we've learned. In this module, we looked into why adding to home screen matters with some data from ComScore. We also had an introduction to the web app manifest followed by a deep dive into the properties and events that are available in the specification. We created a manifest using the realfavicongenerator, deployed it, and then used the Android Emulator to make sure our app installed and showed everything that we expected it to. In the next module, we're going to look at how to send push notifications to our users and make our new app even "appier. "

Sending Push Notifications
Why Push Notifications?
In the last module, we learned all about web app manifest, which allowed our users to install our apps to their home screen so there'd be an icon that they could access at any time. It made getting into our experience that much easier. Now in this module, we're going to take things one step farther and increase even more user engagement by reaching out and interacting with our users with push notifications. Now native apps have had push notifications for a long, long time. But the web is only just receiving this capability. Because of that, I want to quickly cover why push notifications are even important for us to consider, and then we'll jump into how to implement them. At the end of 2015, the Kahuna Mobile Marketing Index reviewed 400 million data profiles and found that 63% of users opt in to receive push messages. Now this number accounts for usage from all mobile operating systems. But if we dig in a little bit more deeply, we see that Android users opted in at 87% clip while iOS users are a little bit more stingy at a 47% opt-in rate. Either way, we're looking at half of our users tend to opt in to receiving push notifications. Now that's really important because in this same study they found that essentially retention rates double at both the 30-, 60-, and 90-day marks if we're able to push a message to a user. That's because push notifications keep our experience front and center in the user's mind and allow them to more easily interact with our content without necessarily having to be proactive to visit our site. I do have to point out, however, that these great numbers really only apply if you're doing a good job with your push notifications. There're a few best practices that you should follow to get the most juice for the squeeze. So, first of all, great notifications are timely. They provide information to the user when the user needs it. So an example of a great notification is when I receive one from my airline app saying that my plane is now boarding at Gate B16. That's timely. I needed that right then. The next best practice for great notifications is relevant information. Relevant information is going to tell me things that I need to know or things that I care about. Once again, finding out that my plane is boarding is really important because it's my plane. Finding out that my buddy's plane is boarding, not so relevant to me. And, lastly, great notifications are very precise. So once again, that notification told me to go to Gate B16. It gave me all of the information that I needed to know to action. In fact, I didn't even have to enter the app to know what to do because the notification told me everything that I needed to know. So great notifications should be timely, relevant, and precise. I'll also call out that to get the user to opt in to your notifications, you should ask for that permission on context. Don't ask for that permission as soon as they've installed your app. Instead, maybe wait until they've done gesture in the application that would tell you that they're looking to be notified. And then at that point do the prompt. So now that we understand how important push notifications are and how to make great ones from a best practices standpoint, let's look into how they're actually implemented.

Intro to Push and Notifications
When you dig in to figure out how to implement push notifications, you'll see that there're actually two separate specifications that are concerned. The first is the web notification specification from the W3C. Now this specification has been around for quite a while. As you can see here, the date is October 22, 2015. And this is the specification that actually deals with the notification part, the little toast that would pop up on your screen. Now because it's been around for quite a while, the browser support for it is really great. It's supported in Chrome 5, Firefox 22, Edge 14, Safari 6, and Opera 25. Essentially, all of the major browsers support notifications. But these notifications only work when the user is running your app. And what's really missing is the push part of push notifications. So another spec was created called the Push API spec from the W3C. And this handles pushing the notification information down to the user's device, and then you use the notification specification that we just saw to make the toast appear. So push is really all about getting data to go from some messaging server down to the device. And I also want to make sure that it's clear that this API is not the same as the HTTP/2 push mechanism. Now this API is much newer. And as such, it's browser support isn't nearly as good. You'll see that it works in Chrome and Firefox. It's coming soon in Edge. The team is working on it right now. There's no support in Safari and no indication of when support will arrive. And it has been working in Opera since version 42. So the world of push notifications deals with two specifications, and further than that, there are two types of push notifications. There're persistent notifications and non-persistent notifications. We're going to look at the non-persistent kind first.

Non-persistent Notifications
Non-persistent notifications are simply notifications that are not associated with the service worker. As the developer, you interact with non-persistent notifications exclusively through the notification API. When interacting with that notification API, there are several static members that you'll use. The first pertains to your permission to show a notification to your user. To do that, you can check the. permission static member to check to see if you've previously been granted access. If so, simply show the notification. However, if permission has been denied, then we definitely don't want to pester the user by asking them for permission again. But if it hasn't been denied, then we can ask for permission using the requestPermission method. RequestPermission returns a promise so it's then-able, and if the user did go ahead and grant permission, then once again we can show the notification. So as you can see, essentially, we want to check to make sure we have permission. And if we don't and it hasn't been explicitly denied, we'll request permission. And if it's granted, then we can go ahead and show our notification. Let's take a look at what showing a notification looks like. To show a notification, you simply new up a notification object passing in two parameters. The first is a string, and it's the title of the notification. And then next is an object, which are all of the other options. The title of the object is like the subject of an email. And it appears as the mainline text. Here on Android, you can see the title appearing on a notification, and this is what it looks like in the desktop version of Chrome. Let's take a look at what the properties are that we can pass into this options object. The first is body, and it contains a string of the body text. Just like an email has a subject line, a notification also has a body. You can see how the body text appears in Android. And here's how it appears in Chrome for desktop. From there, there're several different images that you can set as options on the notification. The first is a badge. With a badge, you pass a path to a URL of an image, and that image will automatically be downloaded, scaled down, and turned into a solid color for the purpose of the notification. So in Android, you'll see a little tiny white version of the badge image appear in the top left corner of the screen. And when the user touches it, it will turn into a gray version of the badge inside of the notification. On Chrome for desktop, the badge isn't shown at all, at least at time of recording. The next image you might want to use is the icon. Once again, you pass a URL to an image, and that image appears inside of the notification itself. On Android, it shows up on the right-hand side. And in Chrome for desktop, it shows up on the left-hand side a little bit larger. The last image property that you might want to set is actually a bit of the content itself, and it allows you to insert a single image into the notification. In this example, I'm setting a picture of cream soda as the image for my notification, and you can see how it appears in Android, as well as in My Desktop browser. The next set of properties that will be of interest to you are the tagging properties. If I send several notifications without a tag, they will each show up one after another. In this case, I've sent notification of Title 1 followed by Title 2 followed by Title 3. The user will receive three notifications. But if I tag all three of these notifications with the same tag, they will collapse down together, and only the last notification will be seen because each notification with the same tag replaces the previous notification that also had the same tag. So, once again, here's the example on Chrome for desktop. I've sent three notifications this time without tags called Title 1, Title 2, Title 3. If I re-run the exercise giving each notification the same tag, we would only see Title 3 because the last notification replaced the earlier one with the same tag. The other tagging property is renotify. Renotify if set to true will force the user's phone to vibrate or make a sound when a notification comes in that replaces another notification. So my Title 3 if renotify was set to true would re-buzz my phone even though it replaced Title 2. Effectively, if you want every notification regardless of tag to notify, buzz, or make a sound on your user's device, set renotify to true. The next property is data. You can pass along any object that you want to to the data property, and it will be preserved for you to inspect later. This can be pretty handy, and I'll show you an example of it later on in the demo. So this is a bunch of properties, and we still have more to go. So I'm just going to kind of comment all of these out to save some space on the screen, and we'll jump into our next set of properties, which are the action-related properties. Now the first one is called requireInteraction. If we set requireInteraction to true, on devices with enough screen real estate (so usually like a desktop browser), a notification toast will just stay open until the user explicitly clicks on it or closes it. Now it might not stay open forever, maybe it will time out or maybe other notifications will come in, and eventually the browser will decide to get rid of it, but requiring interaction will try to keep the notification open until a user interacts with it. The next property is called actions, and it's really powerful. But I will point out that you only use these on persistent notifications, which we'll look at in a later module. But since we're reviewing all the options now, I thought I would include it. We'll review again. Effectively, actions are buttons that you can insert directly into a notification. So the actions property takes in an array of objects. And each object has three properties. The one called action is effectively an Id or an internal name that you give to your button kind of similar to how you might name a button in HTML. The user will never see that name, but when you go and process your code, that name has meaning to you. Next is the title. This is the label that will appear on the button. And, finally, there is icon. This is the icon that shows up next to the button. So on Android, these actions appear like this right in line with the notification. I can click on Action Title, and my back-end code that receives the event that says that a click happened will tell me that I've clicked on the button, as opposed to the body text or some other part of the notification. Because actions takes an array, I can specify multiple actions. And in this example here, you can see we have the first action called Action Title and then a second one that I added in called Action #2. Android doesn't currently show the icons. It ignores them. But on Chrome for desktop, we get to see our action with its title, as well as the icon. Here I'm using a little plus icon. And if I use the secondary action, I can pass in a different icon there. So here's Action #2 with a star. Now how many actions your user's browser supports could be variable. And so there's a max actions property, it's a static property, that hangs off the Notification class that you might to use to see how many actions that device is capable of showing. Right now for both Chrome for Android and Chrome for desktop, the max actions that will be shown is two. After actions, we get into the various different sound properties that are available. Silent is pretty easy. If it's set to true, it won't vibrate the phone or make a sound on the phone. Instead, the notification will just appear up in the icon area on the top left. The sound property allows you to specify a custom sound to play instead of the default device or browser sound. Although at this point, no browsers actually implement or support this property, although it is defined in the specification, so there may be support coming for this soon. And then the last kind of related property here is called vibrate. Vibrate takes in an array of integers, and each integer is alternating between making the motor in the phone vibrate or not vibrate. So in this case, the notification would vibrate for 200 msec, and then stop vibrating for 100 msec, and then begin vibrating again for 200 msec. Some people get really fancy with this property. And I've seen implementations where the vibration matches the Super Mario Brothers theme song or Smooth Criminal or things like that. There're a few other miscellaneous properties that we'll cover. The first is dir, which is the text direction. And it can either be left to right, ltr, or right to left, rtl. This just specifies which direction your text should be read in your notification. Next, you can set the language. Here I'm just doing something basic like en-US. And, finally, I can set a timestamp, which I can read back out in my application code. So those are all the different options that we can pass into the notification constructor. Let's go ahead and take a look at some of the instance members that hang off of this n variable that we're creating on the first line. So as we've seen, we can create a new notification by simply calling the constructor, passing in a title, and one of the myriad of options that are available to us. With that instance, there're several different things that we might be interested in doing. The first is adding an event listener listening for errors to see if the notification errored for some reason. Pretty simple. The next and more interesting one is the click event, which will notify you when the user has clicked on the notification. From there you could do a whole bunch of different things in your application, maybe store some data in the database, fetch something, whatever it is that your application calls for. One of the things that you might want to do once the notification has been clicked is to close it by simply calling. close. So there you have it. Just using this Notification class, we can create, manipulate, and interact with non-persistent notifications. Let's go ahead and take a look at persistent notifications next.

Persistent Notifications
Persistent notifications are very similar to non-persistent notifications except for the fact that they're associated with a service worker. So because of that, we interact with them with a slightly different API. As we saw in non-persistent notifications, all we have to do to create one is simply new up a notification using the Notification constructor. But to create a persistent notification, instead of doing this, we instead call the showNotification method that lives on the service worker registration. Then instead of newing up a new notification, instead we pass in the same parameters that that constructor takes into the showNotification itself. So we pass in a string title and an object that is the options filled with all the properties. And as I mentioned before, we can use actions in this context. This is all we need to do to create a persistent notification. But to interact with them, once again, the API is slightly different. To handle clicks, we add an event listener to the service worker itself, that's what self is here, for an event called notificationclick. Now the event object that's passed in has an action property on it. And if that action property is undefined or null, then we know that the user clicked on the body of the notification itself, not necessarily one of the actioned buttons that we may have specified for the notification. So in this case, if we log out Notification clicked!, that means that the user clicked on the notification body itself, not one of the action buttons. So after this if handler, we can do some code to handle action clicks. So let's go ahead and expand on that comment there. So we're still in the notificationclick event handler. We handle notification clicks as opposed to action clicks. And to handle an action, we might want to set up a switch where we switch on the action that gets passed in. This is the Id, the underlying name of the action that I previously compared to naming a button. And in this case, I'm looking for an action called view. And if I break into that case with a switch, and I log out View action clicked!, I know they clicked on the button that I named view. And I could have another case if there was a button called add or remove or something like that just by adding additional cases here. And then I've thrown in a default case to be safe where I'm just kind of warning and echoing out the name of the action that was clicked. And that's really all the differences that there are for persistent notifications. The power of having actions is great, and using a service worker comes in handy. But there's really not much of a difference. Let's go ahead and play around with some of this in a demo.

Web Notifications Demo: Intro
In this demo, we're going to take a look at notifications from a few different angles. First, we'll play with some options that are available for notifications with an online app called the Notification Generator. Next, we'll take a look at non-persistent notifications and the intricacies of the tag option. And, finally, we'll look at notification events with a persistent notification.

Web Notifications Demo: Notification Generator
In Chrome, I've navigated over to Peter Beverloo's Notification Generator. The Notification Generator is a simple little one-page application that allows you to play with all the various web notification API properties and then see how notifications are materialized when you click the Display the notification button. So let's go with a simple short sentence for our title and leave all the other properties as defaults. And when I display the notification, you'll see what appears. Now that's nothing too interesting. Let's go ahead and start playing with some more options. Let's go ahead and do a multiple sentence body and see how that looks. We can see that lots of text kind of fills in there. I wonder what happens when there's a lot of text and an image. Let's go ahead and change the image to this cat photo that he has prepopulated. And it looks like my text gets a little cropped down, but the cat photo appears, which is nice. What's missing, though, is the icon that I would like. Let's go ahead and see what the options are for icons. I can experiment with PNGs, JPEGs, static and animated GIFs, tiny or huge. Let's just go ahead and do the normal PNG icon and display the notification. And, great, I can see the cat icon, the cat picture, and the text. I can specify a badge, but as we saw in previous clips, badges don't appear in the desktop version of Chrome. And so I don't see it appear here. And I can play with some of the other properties that we learned about like actions. Let's go ahead and add two actions. And let's display an alert when an action is triggered. There we go. Here's the alert with an icon, a title, a body, an image, and two different actions that both have icons. Press on No, and an alert pops up letting me know that I clicked on action #1. That's because this is zero-based index. So if I click on Yes, this will be action 0. This is a really handy little app to test what your device or browser supports. I know I was very happy when I picked up an actual Android device, and I set the vibration property to Smooth Criminal. I hit Display the notification and buzzing in my hand was an old-time Michael Jackson jam. For the next part of the demo. For the next part of the demo, let's go ahead and switch over to a local version of SodaPopped that I have running so we can look into how tagging works.

Web Notifications Demo: Notification Tags
To dig into the tag option, we'll go ahead and open up the F12 tools. And I'll browser over to the sources where we can create a new snippet that I'll call Tagging. Snippets just give us a nice little window with some room to write some code and see how the browser responds. So what I want to do is I want to fire off a new notification every 250 msec or so. I'll go ahead and do that by using the window. setInterval function. Window. setInterval will call the function that I've defined here that's currently empty. And it will call it every 250 msec since that's the interval that I've specified. Let's go ahead and new up a notification every time the method is called. And what I'd like to do is use the title of the notification to show a number to keep track of the number of notifications we've shown. I'll call that number i, but let's go ahead and define it up above. Great! Now we'll start shooting off a whole bunch of notifications. But this will never end, so let me go ahead and add in a little escape clause so we don't get millions of notifications. There, every time the function is called, it will iterate i by one, and if i gets greater than 9, we'll go ahead and stop the intervals from running. I'll go ahead and execute by hitting Ctrl+Enter, and you can see we have three notifications appear. That's the most that Chrome will show from one origin at a time. If I close 0, 1, and 2, then we see 3, 4, and 5 appear. And then 6, 7, 8. And, finally, 9, and the last one should be 10. And so that's the default behavior when we don't use a tag with our notifications. Let's go ahead and put in a tag. So I'll specify an options object, and I'll set that tag to any random value, in this case foo. But now the important note is that all 10 of our notifications have the same tag. Let's see the behavior of Chrome now. I'm going to hit Ctrl+Enter to run. And as you can see, we can see one notification continually get updated where it counted from 0 up to 10 and then stopped because each notification every quarter of a second replaced the notification that came before it because they all have the same tag of foo. Let's go ahead and take this one step farther and do a dynamic tag where half of the notifications will get one tag, and the other half will get the other. To do that, I'll create a new variable called t, and we'll do a little bit of math to figure out if i is currently odd or even. So we'll say i % 2, and see if that equals to 0. If it is, we'll set t to even. And if it's not, we'll set t to odd. And then instead of having our tag be equal to foo, we'll set it equal to t. Let's go ahead and run now. What we should see are two different sets of notifications each get updated, one with odd numbers and one with even numbers. And there you go. You can see both notifications count up. We have the even notifications on the bottom that ended at Title 10 and the odds at the top ending at Title 9. From here, let's switch over to Visual Studio where we can mess around with our service worker and use some persistent notifications to make some actions and handle their events.

Web Notifications Demo: Notification Events
Now I'm in my code editor, and we're going to go ahead and add a notification into our service worker. So, first, I will register the notification in the service worker. We'll use this notification to say that there's been a new soda added to SodaPopped. And we want to go ahead and add in a whole bunch of options. First, let's go ahead and specify a body. Then let's go ahead and add in some branding with images, icons, and badges. First, I'll add an image to the Vanilla Cream from Thomas Kemper soda that we're notifying the user about. Then we'll specify the icon that we'd like to appear. And we'll use the same image for the badge. And let's also add some action buttons. The first action will be for adding the soda to our wish list. We'll give it a title of Add. And we'll specify an icon. Let's go ahead and add one more action button. We'll name this one Rate. And we'll set its icon to be a star. Now maybe a little unusual, but we've set up this notification to appear every time the service worker is loaded. So I'm going to go ahead and switch over to Chrome. We'll make sure that we're updating the service worker on every refresh. Hit Go. And, great, our notification has appeared with our title, our body, our image, our buttons, and the icon. Now let's figure out how we can respond to click events on all of these elements. The easiest event to handle is the close event when the user closes a notification. Let's take a look at that. To do that, we add an event listener for the notificationclose event, pass in a callback. And in this case, we'll just log out the fact that the notification was closed. In your example, you might want to do something more interesting like maybe ping Google Analytics to know whether or not this notification was used or not. Let's go ahead and take a look at that in Chrome. Once again, we'll reload our service worker. Let me drag the console up here so we can see once we get logged out. I will close, and we can see that the notification was closed. Let's go ahead and add click events to handle all the other places a notification can be clicked. To do that, we will an event listener for the notificationclick event. And, of course, that takes in a callback. Now when the notification is clicked, regardless of where it's clicked, we actually want to close it. So let's do that using the close instance method on the notification itself. And now we'll go ahead and log out what button or part of the notification was clicked. We'll start with a switch statement over the evt. action property. And we'll add cases for each of the buttons. For an add, we'll console. log that add was clicked. And we'll break the switch statement. We'll do the same thing if rate was clicked. And, finally, we'll use a default case to handle any other clicks, and that should do it. We should now be notified when any part of our notification is clicked. Let's go test it again in Chrome. I'll refresh the page with the Update on reload button selected so the notification should appear. It does. Let's click the body of the notification. And we can see that our notification was clicked. We'll try again. This time I will click on the Add button, and it looks like Add was clicked. One more time, we will click on the Rate button, and we see that Rate was clicked. And then just to finish the loop, of course we already saw that if I click on the Close button, we know that the notification was closed. So in this clip, we saw how to play around with various different options with the Notification Generator. We created non-persistent notifications and saw the intricacies of the tag property. And we created persistent notifications here and saw how to handle all the various different event handlers. So that's all we really need to know for notifications in and of themselves. Now the next step is to go and look at the push part of push notifications.

Push API Fundamentals
To handle push, there're three main phases that we have to implement. And this clip will look at the three phases from a really high level, and then we'll dig into the details of each one as we move forward throughout the rest of the module. The first phase is configuring a push. To configure push, we begin with a normal response from our web server to our user's browser. The only difference in this response is that includes something called a VAPID key, which we'll learn more about in the future. From there, if we want to be able to send a push notification, we'll request the browser to get a push subscription. It does that by calling the message server, which is run by the vendor of whatever browser they're using. And the message server will respond back the subscription for that user. From there, the browser will send a subscription information back to the web server, which we can store in a database until we need to send a message later. Now sending a message is actually phase #2. The web server will have to do some work to make sure that the message is appropriately configured and send it off to the message server. From there, we'll go into phase 3, where the message server sends the message to the browser, and we can receive that message and show a notification. Let's dig into the details of how we configure the push.

Configuring Push
To configure a web push, the first step is to respond from your web server with a page that has a public VAPID key embedded within it. A VAPID key is a cryptographically secure key as defined by the Voluntary Application Server Identification for WebPush specification. Effectively, it has two strings associated with it--a public key and a private key--and they'll look something like this. The public key you'll embed in your page. The private key you will keep secret and private on your server. With that key available, you'll use the pushManager API to query and ask the browser if there's already a subscription associated for your app by calling pushManager. getSubscription. But what is a subscription? Effectively, a subscription is just an endpoint. It's a URL that we're later going to post data to. And so when you get back a subscription, you get an object that can be serialized into something that looks like this containing that endpoint. Along with the endpoint are keys. These keys are used to encrypt the message that we're going to later send to this browser. So this is a subscription. But let's assume when we call getSubscription that there isn't already a subscription associated and so we'll get back a null. In that case, we're going to want to wait around until it's the right moment to ask the user to subscribe because asking the users to subscribe will create a browser prompt. We don't really want to do that unless we know that they just had a positive interaction with our application. When that has happened, we'll use the pushManager again, and this time we'll call. subscribe. The code for that's very simple. It looks something like this. We'll have our service worker registration. We'll take the pushManager property and call subscribe on it. Now the subscribe method takes in an object with several options. The first one is userVisibleOnly, and it has to be set to true. This effectively is telling the browser that we're only going to use push in conjunction with notifications. This may change in the future, but as of right now you actually have to specify this as true while the spec is being fleshed out. The other property is this applicationServerKey, which takes the VAPID public key we've already talked about and does some manipulation to it, converting it to Base64 and to a Uint8Array. The implementation of the urlBase64ToUint8Array method isn't entirely complex, but it's not something I'd like to do by hand. The implementation shown here is found in various places in the Google documentation, and I'll link you straight to it in the course notes so you can just copy and paste it into your own application. From there subscribe returns a promise, and when it's finished, we will have a subscription. The next step is to take that subscription and send it back to our web server where we can then persist it into a database. Once we've done that, we can move on to sending a message. But before we do, let's do a quick demo to see how this stuff actually works.

Configuring Push Demo: Intro
For this demo, we're going to do everything that's required to configure web push. So, first, we'll go ahead and generate some VAPID keys. And then we'll implement the code used to subscribe a user.

Configuring Push Demo: Permissions
For the rest of the demoes in this module, we're going to add the ability to send a push notification to subscribed users anytime a new flavor of soda is added to the SodaPopped database. Just recently DRY Sparkling has introduced a new cranberry-flavored soda that's not currently in the database. But by the time we're done implementing this feature, when it is added, all of the users will be notified with a push notification. So it looks pretty delicious to me, so I can't wait to get the feature up and running. As we learned previously, the first step for push notification is generating a VAPID key. We can do that over here at this push companion at web-push-codelab. appspot. com. This companion helps you write your push notification implementation and makes generating keys very easy. You can just press this Refresh Keys button and get a different set of keys every single time. We'll go ahead and use this one. I'm going to copy this public key, and we'll drop it into our profile page. I'm also going to jot down the private key for now. I don't normally want to ship this in my source, but this is just a quick place for me to store it for later reference. There're other ways of generating these key pairs, and I'll show you an alternate method in a later demo. The next step is to add a button to my profile page that allows me to subscribe to push notifications. Let me show you what the profile page currently looks like. On SodaPopped, here's my profile page. I can see my name, the number of reviews that I've done, and those individual reviews. There's actually a subscribe button hiding right about here, but it's hidden right now because I haven't done the implementation. Let's fix that. First, I'm going to get a reference to that button and set it into a variable called notify-btn. The button has an inner element, that's the icon, so I'm going to go ahead and grab that as well. And now that I have a reference to the button, let's make it appear when the browser supports push notification. So, first, we'll check to see if service workers are supported, as well as push notifications. If both of these things are supported, we will remove the hidden class that's currently sitting on the notifyBtn. Let's go ahead and save and see if this is working. I'll switch back over to my profile. We'll refresh the page. And, great, I have a push notification button appearing. You can see that it's disabled. We'll fix that in a moment. Continuing on, the next thing we'll want to check is to see if the user has already explicitly denied permission to send notifications. Then if the user has not explicitly denied permission already, we will go ahead and enable the button. Let's take a look at that. I'll refresh the page. And, great, now we have our button, and it's enabled. It's not doing anything yet, but we'll get there. Let's keep on inching this implementation forward. Now we know that we may have permission to send notifications, but let's see if there's a subscription already set up. To do that, we'll have to get access to the service worker once it's ready. Calling. ready returns a promise that will give us access to the service worker when it's up and running. I want to save the service worker that we have access to into some kind of a global spot that I have available under the sp namespace. And then we'll go ahead and we'll get access to the subscription. GetSubscription also returns a promise, so we'll have to use a then method to get its result. And what we want to do is check to see whether or not the subscription is null to know if the user already has a subscription. So let's go ahead and do a check here. There we go. I've stored that away into a variable called isSubscribed. And depending on whether or not the user is or is not subscribed, we'll update the icon within the button. Now the icons in SodaPopped are based off of Unicode characters, so I'll go ahead and input the Unicode characters that I want to appear based on whether or not the user is subscribed. Great! And with that, we're now checking the subscription. Let's go ahead and take a look at how this is operating in the browser. If I refresh my browser, the button appears as we'd expect. I still can't click on it. Let's go ahead and deny permissions to the notification. We can do that by clicking on the i icon in Chrome, going down to notifications, and changing this to Always block on this site. We're required to reload the page for that to take effect. And, great, our button automatically disabled because permissions are denied. If I change it to Always ask, which is the default, when I reload, I now have the ability to push, but we don't have a click of a handler added in. Let's go ahead and do that next.

Configuring Push Demo: Subscribing
To actually subscribe a user to push notifications, we need to add an event handler to this button. So we'll go back to Visual Studio, we'll grab the notify button and add the click handler, and now that we have the click handler in place, we can implement it. The first thing I want to do is actually disable the button to stop a user from clicking it multiple times because subscribing a user could take a little while. There, now it's disabled. Next, since the user is clicking the button to toggle the state of their subscription on or off, let's check to see if there is already an existing subscription when they've clicked to make sure that we can turn their subscription off. To do that, we'll use that global service worker we saved away earlier. Once again, we'll use the promise that hangs off of getSubscription to find out if they have a subscription. And so if the subscription is not null, we will call the unsubscribe method on it. That will unsubscribe it in the browser. The. unsubscribe method will also disable the subscription in the message server, but we'll need to tell our own web server to unsubscribe as well deleting any records in the database we may have for this user. I'm just going to put in a TODO comment for that for now since that's not the point of this exercise. I'll want to update the icon on my button, and then we'll want to un-disable our button. We'll want to enable our button so that it's operable again. That handles the unsubscribe. Let's handle the subscription case. So if s is null, then we'll want to call subscribe, so we'll use our global service worker again to access the pushManager and call subscribe. If you remember, subscribe takes in an object, and that object has two properties--userVisible Only, which we set to true, and the applicationServerKey. Now that key is our pubKey that we defined at the very beginning of the file, but we have to manipulate it a little bit first. Let's go ahead and get the implementation that we need to get this key in the right format. So I'm back over at the Google Chrome push-notifications repo in GitHub. And the implementation that we need is here. I personally would like to see this built into the spec itself. But it's not there at the moment. So I'm going to copy that. We'll go back to Visual Studio, and we'll paste this function in. So we're going to grab the name of this function, pass into our public key, and that should do for getting subscribe to execute. When the subscription completes, we get a promise, so we'll want to chain a then onto this to then sync up with our server. So we'll take that subscription, and we'll set it to our server using a fetch. We'll look at the implementation of the server-side part of this code in a later demo. And there're several options on the fetch that we'll have to define. First, we need to define some headers. We'll set the content type to application/json. Next, we'll set the method of the request. In this case, we're going to do a post. We need to configure how fetch will handle the cookies for the user who's logged in, and we do that with a credentials property. And we end by sending the body of the request, which will be a serialized version of the subscription. Once our server processes it and responds, then we'll want to update our button so that it's in the proper state. And let's go ahead and enable the button as well. And with that, we can switch back over to the browser and see how this works. I'll go ahead and refresh the page. We have the ability to subscribe. And now when I click the push notifications button, I get the prompt that says am I allowed or not? Let's go ahead and say Block. And you'll see that the button just stays disabled and never comes back on. I'll go ahead and change that in the browser to always ask. We'll reload. Yes, let's go ahead and turn on push notifications. This time I will allow it. And now our push notifications icon has changed, so I can turn off notifications. And if I push the button again to turn them off, they turn off. So that's great. We've configured push. Now let's move onto the next step, which is sending messages.

Sending Messages
Now that we have push configured, the next step is to dive into how to actually send a message. There are three main steps to do that. The first is to create and encrypt a message. Creating a message is very easy. Encrypting it can be a little more difficult. If you read through the spec, you'll see that the encryption involves elliptic curve Diffie-Hellman key exchanges and HMAC-based key derivation functions. Those two things aren't really in my wheelhouse, and I prefer to leave the security and cryptography to the experts. So instead of writing that code by hand, I would head over to the web-push-libs organization on GitHub and take a look at all of the different libraries that they have there for various different languages, including Java, JavaScript, Python, C, and C#. In the demo that corresponds with this clip, we're going to take a look at the C# library to send out web push notifications and not have to deal with any of the cryptography. Once we've generated an encrypted message, the next thing that we need to do is send that message to the message server. Sending a message to a message server is pretty easy, and it follows this generic event delivery using HTTP push specification. Because every different browser vendor will implement their own API, the spec writers wanted to make sure that all of the APIs were uniform and consistent. So this specification defines the behavior of how those APIs are supposed to work. There're a few key things that they call out. For example, The specification covers some headers that are required, as well as some optional ones for when we're calling message servers. The first such header is the encryption header, which passes over the salt value, which is the salt that was used to encrypt the message. Our WebPush library will take care of setting this header. Likewise, it'll take care of setting the crypto-key providing more information about the keys used to sign the message. There is a TTL header, which stands for Time To Live. This is the number in seconds in which the message should be allowed to live on the message server. So if you try to send a push notification, and the user is offline, for example, if the TTL was 0, that message would never get delivered because it would hold onto the message for 0 seconds, try to deliver it, and it would fall off the queue after it tried to deliver. But with a Time To Live, it could stick around for however long you tell it to, although the message server may ignore it and use a shorter time than it wants. Next is an optional topic header, which takes in a string. The topic header works basically the same as the tag on a notification. If I send three different push notifications all with the tag new-soda, the last one in will win particularly useful if a user is offline. And maybe during that time you would have sent them three notifications. You can use the topic to send them just the last one. There's an optional urgency header, which can be used to say how important a message is to the user. And there're four different options here--very-low, low, normal, and high. The message server might choose to ignore very low message, for example, if it knows that the device it's sending the message to has a low battery. And then the content-encoding header is not a new header defined by the spec, but the value, aesgcm, is required to tell the message server how you're sending the content over. That's it for headers. The spec also determines how status codes should be used. If the message server returns a 201, then that's great. That means that the push message was received and accepted, and it will be sent out as soon as it should be. However, if you get a 400 back, that means you made an invalid request, and that usually means one of the headers that we just covered was improperly formatted or missing. If a 404 is received back from the message server, then that's telling you that the subscription that you're using to send the message has expired and can no longer be used. In this case, you kind of just need to delete that subscription from your database and wait for the user to re-subscribe in the app. If you see a 410, that means that the user has unsubscribed, but you forgot to maybe delete it from your database. A 413 means that the payload that you're trying to send is too large. You're allowed to do 4096 bytes or less at the moment. And if you receive back a 429, that means that you're making too many requests, and there'll be a header included with this response called Retry After that will tell you how long you should wait until you try sending more push notifications. So that's a high-level overview of some of the sticking points of the web push protocol. So once we've sent a message to the server using that protocol, then the message server can send it to a browser, and we can move on to receiving the message. Let's go ahead and code up the steps seen in this slide.

Sending Messages Demo
For this demo, we're going to do two things. First, we're going to acquire the WebPush library for C#. And then we're going to use it to send a message. To install the WebPush library, I'm going to use the NuGet Package Manager. So I'll right-click on my project, Manage NuGet Packages, and we'll do a search for WebPush. And there we can see the WebPush library by Cory Thompson with 1. 5 thousand downloads. I can go ahead and click the button to upgrade. I've already installed it, but we'll just go ahead and stick with the version that I have. Now that I have access to that assembly, I'm going to go over to my AdminController, which handles all the administrative functionality for SodaPopped, and add in the ability to start sending push notifications. So I'll just scroll down to the bottom of this controller, and we'll create a new private method called NotifyUsers. We'll pass in both the name of the brand and the name of the drink that is going to be new. We want to notify users when there's a new drink or a change to a drink. And, there, that gets us started nicely. Now before I actually go and start sending the push notifications, let me show you how I would use the WebPush library to generate VAPID keys as opposed to using the website that I showed earlier. It's actually really simple. I'll just create a variable to store the keys and then call the GenerateVapidKeys on the VapidHelper utility class. The keys object has several different properties, but the two that we would need are PublicKey and PrivateKey. And that's all I need. Those two properties right there will give me my own self-generated keys. Now we already generated keys in an earlier clip. You might remember that I've stored the public key here in a variable, and I just put the private key and a comment here. We're just going to use those keys for this demo since I've already subscribed using those keys. You don't want to change keys once users have started subscribing with those keys. So we'll stick with these and delete this little bit of code. So let's go ahead and use those keys. This time I'll create my real details object, which is part of the WebPush library and where I specify the keys. So I'll do that with this VapidDetails object, and we're going to use this overload that takes in three arguments--a subject, the publicKey, and the privateKey. Now the subject is just a string, and they recommend that you make that string be a mailto of your email address so if the message server has any problems, they can get in contact with you. So there's my email address as the subject. The public key is the publicKey that we previously generated and are already using in profile. js. So I'll copy and paste that. Let's format this a little bit better. And the privateKey is also the privateKey that I've already captured in earlier clips. And I'll copy and paste that. And that's all we need to do with this WebPush library to create the details around our keys. The next thing that my NotifyUsers is going to do is it's going to get all the list of subscriptions that we've already stored in our database. And so I have some helper functions that make doing that easy. There we go. Now I'll have a collection of subscription objects. The next thing I want to do is get all of the full information about the drink that we just added or edited, and I'll do that with the two slugs that were passed in here. So let me go and get that data. Great! Now data will tell me everything that I need to know about the drink. The next thing we're going to do is create the JSON data that we use inside of the push down to the browser. I'm going to call that payload, and I'll use JSON. NET to convert an anonymous. NET object into a JSON string. This object will have two main keys called drink and brand. And each of those keys will have two sub-keys named name and slug. And we'll do the same thing for brand. There we go. Now we've created the payload that we want to send down to all of our subscriptions. To send subscriptions, the WebPush library has an object called the webPushClient that we need to create. Now we should have everything configured and ready to use, so let's go ahead and actually start sending some push notifications. To do that, we're going to loop over all of our subscriptions. And the subscriptions currently are in my own format that I use with my ORM, but I need to convert them into the WebPush library's PushSubscription model. So I'm going to go ahead and I'm going to use a linkSelect clause to convert them from my own data model to the data model that's expected. So we'll just go ahead and take each of the subscriptions. We'll select it and pass each one into a lambda expression where we new up a PushSubscription from the WebPush library. And that PushSubscription will take in an Endpoint, which I have in my data model. It will take in the P256DH key, which I also have in my data model. And, lastly, the auth key. And with that, I have the foreach up and running. And so what we want to do is we want to use the WebPushClient to send a notification to the subscription with a vapidDetails and payload. So we'll use the subscription. We're sending everybody the same payload, and we use the same vapidDetails all across the board. And that should be enough technically to start sending the notifications. However, just in case the request to the message server bombs, we'll go ahead and wrap this up in a try-catch. And I'm going to go ahead and catch any WebPushExceptions. And then I can manage those exceptions however I want to. Typically, if there's an exception that comes back from the message server, it's going to have one of the status codes that we talk about in the previous clips. And so depending on what the error status code returned is would tell us how we should respond, whether or not we should try again, try again a little later, delete the subscription and validate it, etc., etc. But for right now we'll just go ahead and leave a TODO. Now the last thing we need to do is actually call this new method, NotifyUsers, that we created. And so I'm going to come up to this DrinkEdit method, and right after we have upserted the drink into the database, I will go ahead and execute the NotifyUsers method. There we go. Let's go ahead and save and build and see if this thing works. Build succeeded. I'm going to flip over to the browser, and we're going to go interact with that AdminController. So to do that, I have to go to the /admin URL, and the new flavor that we wanted to add was the Cranberry flavor from DRY Sparkling. So I'll click on DRY Sparkling. Let's add a drink to their listing. The name of the drink was simply Cranberry. The slug, which will be the URL that we used to access this, I'll just make also cranberry. It is for DRY Sparkling, that's the brand. The sweetener that DRY Sparkling uses is cane sugar. And then the flavors for this drink, this is a fruit flavor. We don't have a specific flavor for cranberry, so we'll just roll it up into fruit. And it is a limited edition so that's available during the holidays. So now when I press Submit, I should see a push notification. But I did not. Actually, that's expected. That's because we're now sending the push notifications to the message server, and the message server in fact is trying to send it to my browser. But in my browser in my service worker, I'm not responding to that event. Let's take a look at how we would do that.

Receiving Messages
When the message server sends the push message to your user's device, a few different steps happen. First, the message is dispatched to the browser. And then the browser will wake up your service worker and get it started. From there, your service worker will get the chance to handle the push event. The push event is pretty simple to handle. You call self. addEventListener where self is referring to the service worker, and you listen to an event called push. That event will have a property called data on it, which I will convert into JSON. And that's the payload that we saw sending in the previous demo. And then from there, I can do whatever it is that I need to do with the payload that was send down. Maybe I'll store that info into IndexedDB or do something different. But for us, the next step is going to be showing a notification. And so to do that, we have to call the showNotification method, which will create a persistent notification. So to create the persistent notification, we'll have to configure all of the various options that we want for the notification and then call the evt. waitUntil method, which takes in a promise, which self. registration. showNotification actually is. And that should show our notification. So from there, the notification will appear to your user, and if we want to handle any events or be notified when the user interacts with the notification, then we have to handle the notification click event. That is registered in a very similar way. In your service worker, you do self still referring to the service worker and add the notification click event listener. I recommend basically immediately taking the notification that's on the event and closing it. That's a really nice way of showing your user that you received their input gesture, their click, and you closed the notification and then start doing some further processing. In our case, we're going to pick out some individual bits of data from our JSON payload. So I can grab the brand and the drink, and we want to take the user to the page to show them that new drink, and we can do that by calling waitUntil, which will allow this method to run until this activity completes. So we will waitUntil we open up a window that goes to the origin of the targeted event, which in our case would be SodaPopped. com or localhost. And then we want to send the user to /brand/drink, which in our case would be /drysparkling/cranberry. So now that we have a basic understanding of how this works, let's go ahead and put it into practice.

Receiving Messages Demo
In this demo, I'm going to show you how to send a notification and response to a push event. And then we're going to look at how to handle clicks on the notifications themselves. We'll also end the demo by taking a look at the Android emulator and configuring it to receive push notifications. The first step in receiving a push notification is handling the push event within our service worker. So let's go ahead and implement that. I'm in my service worker now, and I'm just going to go ahead and scroll down a bit here to right below my activate event, and we'll go ahead and handle the push here. So to do that, I had an event listener to self. The event is named push. And there, now we're ready to start handling the event. What I'm going to do is I'm going to define two different variables really quickly. The first will be the actual payload, the data that was sent in from the push event. And then we'll use that payload inside of the options object that we're going to create for our notification. There're lots of option properties that we want to configure. The first is the body, the text that shows up in the notification. And there with that we should be able to set the body to a string that's similar to something like Cranberry from DRY Sparkling where Cranberry is the name of their drink. Let's go ahead and add in our icons and badges. They're both going to point to the same image for now. Now we have our icon and badge. And, next, we'll add in the data property and set that to the payload. And, lastly, because what we're creating is a persistent notification, we have the option to add action buttons. We're going to go ahead and add two. The first action will be to see the new drink, and so we'll give it a title of See It and an action of view. And we'll also specify an icon. Now please remember this double curly brace syntax that I'm using here is not really part of anything that's going on in this course. My build system will automatically optimize an image called eye-png and replace this token with the new path. You could just use a straight-up path to a PNG like what I'm doing for icon and badge. Our second action will be to save the drink to your Pop it Later list, which is SodaPopped's version of a wish list. And instead of an eye icon, we'll use a plus icon. That about does it for my options. Let's go ahead and send the notification. So the first thing we'll want to do is tell the event to wait until the notification has been sent. The waitUntil method takes in a promise, and it will wait until the promise resolves. And so by calling showNotification, that returns a promise satisfying the contract required by waitUntil. We'll set the title of the notification to New soda on SodaPopped. And, of course, we'll pass in all of our options. And that should about do it. Let's see if we can get these notifications to appear. In SodaPopped app in the browser, we'll go over to the admin portal. I will click on DRY Sparkling. And because of the way we have notifications set up, users will be notified both when a drink is added and when it's edited. So I just have to click on this Cranberry drink. We can pretend that we're editing it, and I will hit Submit. And, hey, look at that! We have our notification appearing. We see the New soda on SodaPopped, the name of the drink, the brand, and my two buttons are there. Let's go ahead and close this. And now we want to start interacting with click events on the notification itself. So I'll go back to Visual Studio, and we can add in the notification click event handler. So very similar to the way that we subscribed to push events, we say self. addEventListener. And this time the name of the event is notificationClick. The first thing we'll want to do when somebody clicks on our notification is to close it. So we'll grab the notification off of the event and call the close method. Next, we'll pull the payload off of the data property that we passed into the event. And from here, I'm going to set up a switch statement to handle each of the various different parts of the notification that the user might have clicked. We'll switch on the action. And because of that, we're going to end up with three different cases. We're going to have a case for later, which is one of the buttons that they can click on, a case for view, which is the other button, and then of course there's the default case. Now if they've clicked on the view button or on the main body of the notification, I kind of want to do the same thing, which is just take them to the page to show them that new drink. So I'm going to let the case for view fall into the same case for default. And we'll code it up like this. First, we'll grab the drink slug and the brand slug so that we can figure out the URL we need to send the user to. And with those two, we will once again tell the browser to wait until we are able to open up a window. Now the URL that we want to go to is going to be comprised of a bunch of different variables. So let's go ahead and build up this string. The first part is going to be the actual origin, which will either be SodaPopped. com or localhost with the port. I can figure out which one the user was on by using some data from the event in there. That event. target. location. origin will give me the right domain. From there, we want to send them to /brand and then /drink. And with that, we should be able to open up the browser window to take them to the new drink. Let's go ahead and fill in the later case. Now I don't want that case to bleed into the view and default case, so we'll put in a break right away. And above that, we can put in the actual implementation. In this case when the user clicks the later button, I just want to update their state so that this drink is now in their later list. We'll do that by using the fetch API. First, let's build up the data that we're going to submit on the fetch API. So I'm going to build up some form data with the FormData object, and I'm going to send over all the same data that would have been submitted had the user done this in this SodaPopped UI that exists on the website. So, first, we need a drink. id, which is stored in the payload. I also need a drink. slug, as well as a brand. slug. There, that's all of that data. Now we'll tell the browser to wait until we're done doing the fetch. We're going to want to send this data to the review/later URL that's already created in SodaPopped, and we're going to update the fetch with a couple of different properties. First, we're going to set the method to post. Of course, we want to attach the form data to the body of the request. And to make sure everything is authenticated, we want to send over our authentication cookies, and I have to include the credentials to do that. And that should be all I need to do to handle any click event that the user is sending my way from the notification. Let's switch back to the browser. And let's go ahead and, once again, we'll go to Cranberry. We will edit it. My notification appears. And let's see what happens if I click on the body of the notification. A new window is opened, and I am now looking at the DRY Sparkling Cranberry page, which is great. Nobody's reviewed it. Nobody wants to try it yet. It's brand new so that's to be expected. Let's edit it again. And this time, I'm going to click on the See it action button. Now if I click on See it, I should get the exact same experience as when I click on the full body of the notification. And I do. And so one last time, we're going to go ahead and go to Cranberry. We're going to force the notification to appear. It does. This time, we're going to use the other action. I'm going to Pop it Later. The notification disappears, and I don't see anything. But if I go and I look at my profile, I should now have the DRY Sparkling Cranberry soda on my wish list, my Pop it Later list, as SodaPopped calls it. So I go to my profile, scroll down, and look at that. Pop it Later list, DRY Sparkling Cranberry. It worked. That's awesome! Let's take a look at how we can view notifications in the Chrome Emulator real quick. Notifications in the Chrome Emulator work basically how you'd expect except if you're in a situation where you don't see notifications appearing and they should be, you have to make sure you've configured the emulator to allow notifications to come through. Let me show you how. Just go into the Android Settings, scroll down to Accounts. And I already have my Google account added. But if you don't have an account listed there, go ahead and hit Add account, and you can add your own Google account. Once you've done that, you can open up your app. You'll want to make sure that you're subscribed from this device, which I am. Go ahead and close both of the settings and my app. And so now from the admin portal within SodaPopped, I'm going to go ahead and click on DRY Sparkling. We'll go to our Cranberry soda that we've been working on. We will update it. The notification appears. I can see exactly what it looks like in Android. I can click this See It button, and it opens up. And I can see it. And so everything in the Android emulator works as expected after you've set up that one account configuration option.

Summary
That about does it for this module. We covered a lot of ground, and we began by looking into how push notifications are used to increase user engagement. And we talked about what makes a notification great. They need to be timely for the user, relevant to what they're doing, and precise containing all the information that they need to action on. Then we did a deep dive into non-persistent and persistent notifications, as well as how to set up a push subscription, send a message, and receive those messages. In the next module, we'll look into background syncing to allow for saving and sending data when a user has an intermittent connection.

Background Syncing
Why Background Sync?
In this module, we're going to explore how progressive web apps can do background syncing of any input data that a user may have had while they were offline. You've probably seen scenarios like this before with any communications-based mobile app you may be using. So, for example, when I'm offline, I can open up my email app and write an email. And even though I can't actually send it, when my phone is connected, it will automatically send without me having to reopen the app. But when are we offline? Well there're lots of places that offline can happen to us. One of the most common for me is when I'm in the air flying or even sometimes out on a boat. In large crowds at baseball games that I like to go to, the cell towers just get overwhelmed, and I don't have much of a connection. Inside of any buildings or down in basements, particularly big buildings or when you're in elevators, it's really hard to get a connection. Or even in situations where you think you have a connection, but what you really have is a phenomenon called Lie Fi, which is when your phone is telling you you have a connection, but that connection is so spotty, you can't actually get any packets out. Now there're lots of other scenarios besides background syncing to consider for building an app that works well offline. And if you want to learn about those scenarios and the prerequisite for background syncing, which is service workers, I recommend checking out my Building Offline Web Apps with Service Worker course available on Pluralsight now. So now that we know a little bit about when users are offline, let's figure how we can implement background sync.

Intro to Background Sync
The capability to do background syncing is defined in the Web Background Synchronization specification from the W3C's Web Platform Incubator Community Group. It's a pretty simple specification that defines the sync manager interface with its two methods and the sync event. Support for the specification is just beginning to appear in browsers. It's currently available in Chrome 49 only, but it's in development in both Firefox and Edge and should be supported by them soon. Either way, we can view background synchronization as a progressive enhancement. Let's take a look at how we use it.

One-off Synchronization
To complete a one-time synchronization, there're several steps involved. First, on at least one of the pages in your site, you need to register a service worker. Registering service workers is fully covered in my Building Offline Applications with Service Worker course available on Pluralsight. From there, you'll wait until your user does something to trigger an event that requires persisting state to the web server. But instead of making a network call to persist to the server, we'll first want to persist the same state to a storage mechanism within the browser. Covering all the various different storage mechanisms within the browser is outside of the scope of this course. But I highly recommend Craig Shoemaker's HTML5 Web Storage, IndexedDB, and File System course to get a complete overview of the options available. However, for this module, I am going to be using IndexedDB, so I'll give you a very quick overview of it. First and foremost, we have to open up a database, which happens asynchronously. Here I'm going to open a database that's called sodapopped. I'm looking for the first version of that database. And when that database is successfully opened, I'll pass in a callback. I'll grab a handle to the database off of the event. And then using IndexedDB's fairly verbose API, I will open a transaction that's for both reading and writing against the reviews collection. And on that transaction grab an instance of the reviews object store. I'll then create an object with all of the values that I want in it. So in this case, I have a property called comments. And I would grab the commentsBox from my form on my page and stick its value into it. It doesn't really matter what object I'm creating or the values that are passed into it. So in this case, I'm just showing a few sample values. From there, I take that reviews object store. I put those values into it. And if I've successfully stored those values, then I would register for a background sync. And that so happens to be our next step, which is to call the sync. register method. So inside of that callback, I might write some code that looks like this to call sync. register. First and foremost, I'd want to be defensive and make sure that both service worker and sync manager are APIs that are available within the browser. If they are, I'll use the navigator. serviceWorker. ready API to get back an instance of my service worker when the service worker is installed and ready to be used. And then using an extended promise handler, I would take the service worker, access its sync manager, and register for a background synchronization. When you register, you have to pass in the name of a tag, which is a name for this synchronization. And just like tags and notifications, if you overwrite and use a tag a second time, the last instance will win. And then after I've finished registering for the sync, I can do anything else that I might need to do. Perhaps I might need to update the UI on my screen. From there, all we need to do is handle the sync event from within the service worker. And like all service worker events, I would basically add an event listener to self. In this case, the name of the event is sync. I can check the name of the tag, and I can execute whatever logic is required for that tag. In this case, I will tell the service worker to wait until we are done syncing the data with the server, which in this case would just make a simple fetch call.

One-off Synchronization Demo: Register
Now that we've seen an overview of how background syncing works, let's take a look at some code. First, we'll register a background sync when a user adds a review to a soda in SodaPopped. And then we'll handle the background sync even to actually persist data when their internet connection is restored. The scenario we're going to light up in this demo revolves around the Pop it Now functionality in SodaPopped, which allows a user to rate their sodas. To see what I'm talking about, we're going to navigate over to the brand. And I'm going to go and look at one of my favorite sodas made by Maine Root, and that's their Mexicane Cola. Nobody's reviewed this soda yet. And if I want to, I can hit the Pop it Now button. I can choose how many stars I rate this soda. This is a really good cola, so I'm going to rate it five stars. I can leave a comment. In this case, I'll say something simple like Great cola! And I can add an image. Here's one that I took at Torchy's Tacos. Currently when I hit Save if I'm online, everything will work as expected. But what we want to be able to do is save even when we're offline. To do that, I'm going to pop over to Visual Studio and take a look at the drink. js file, which is the JavaScript that runs for this page. This file does a whole bunch of different stuff on the page as you can see here. I've _____ down so that we can focus in on what matters, which is handling the submit event on the now form. Currently when a submit event is raised, we prevent the default action, meaning the form won't submit like it normally would. We disable the Submit button. And then we go ahead and check to make sure that the user is authenticated before we continue. This is where we want to go ahead and pick up with the background sync implementation. To begin, let's open up our IndexedDB local database. And when we successfully open it, we'll go ahead and handle the event. Inside the event handler, I'll want to get access to the reviews objectStore for my database. I'll go ahead and grab the image out of the files input box on my form. And I'll use that image along with many of the variables that are defined at the beginning of the file to create the value that I want to store in the database. We'll specify the key, the drinkId, the drinkSlug, the brandSlug. We'll parse out the rating from the slider. We'll grab the input comments, the picture, and we'll set a flag stating whether or not this value has been synced with the server yet. Then we'll go ahead and put this value into the reviews objectStore. From there, we'll want to handle successful PUT operations. And we'll do that with the onsuccess operation handler. First, we'll check to see if the serviceWorker and SyncManager are available. And if they are, we'll get access to our currently ready serviceWorker. Ready returns a promise, so we'll use the then method, which will pass in the serviceWorker, which we will use to register a sync. We have to pass in a tag name for our register method. I'll call this sync-reviews. And after we've successfully registered the sync, we'll go ahead and update the UI in our form. If the user does not have a serviceWorker or SyncManager, that's okay. We'll just want to fall back to the standard way that we would update the service in this data, which is using Ajax. And with that, we have everything that we need to register the sync event. Let's take a look at how we'll handle sync events from our service worker file.

One-off Synchronization Demo: Handle Sync
To handle the sync event, I'm going to switch over to my service worker, and we'll go ahead and add the event listener for sync. The first thing we're going to want to do is to check the tag of the sync event that's coming in. In this case, we only want to do something if the tag is equal to sync-reviews. Before our implementation gets too complex, let's take a moment to look at how syncing works with the Chrome dev tools. I'll switch back over to the browser, press F12 to open the dev tools, and head over to the service workers tools. Let's go ahead and make sure that we're going to get the newest service worker that we just updated. We have it. If we take a look at the implementation, we should see that we have added the event listener for sync. Let me go ahead and add a breakpoint there because what I want to show off is back on the Application tab, on the Service Workers submenu, we have the ability to force a sync event to happen by clicking on this Sync link. And when that happened, you can see that I've hit my breakpoint. If we inspect the event, you'll see that the tag is set to a hardcoded string, test-tag-from-devtools. So we won't do anything with that since we're specifically looking for a tag called sync-reviews. But it's nice to know that you can trigger one of these to test your logic nonetheless. We'll go ahead and remove that breakpoint and go back to implementing our sync event handler. So when the event tag is sync-reviews, we will want to tell the service worker to wait until we're done using the common event. waitUntil method. So we'll want to wait until we're able to open the database. And in this case, the openDatabase method is a small helper function that I've written that wraps up the onsuccess event callback as a promise. I did that because waitUntil explicitly likes and works with promises. So wrapping up the callback into a promise makes my implementation a little bit cleaner. Then when the database is open, we'll grab the database from the event, and we'll get the reviews objectStore just like we've done before. From there, we'll return some data that we read from the reviews collection, and we want to return all of the reviews that have not been synced. My getData function is implemented here. This basically also wraps back the reading process of IndexedDB to make it promise based. Once we grab all of the elements added into IndexedDB that have not been synced yet, then we're going to want to go ahead and send all that data up to our server. So we'll take each of the results, and the results here are all of the items in IndexedDB that have not been synced. And we're going to want to iterate over each of them. And for each individual result, we'll go ahead and create the FormData body that we'll want to post to the server. And these three or four lines of code will basically go through all of the properties of each result and add them into the FormData object. Once we have that, we will send that FormData to the server using fetch. We'll go ahead and update the method to be a POST. We'll pass along the body of course. And we also want to include the cookies for this request so the server knows what user is making this request. And in fetch we do that using the credentials property. Once the fetch is made, we'll want to make sure to update the local database to know that we've synced. So we'll take the response of fetch. We'll check to make sure that it was good. And if it was, we'll take the result that we read from IndexedDB, and we'll change the isSynced property to true. And we'll update local DB with a new version of the result. And that should do it. Let's see how our sync works. I'll start by making sure my service worker is being updated. It is. So now let's go ahead and take our app offline. In the version of Chrome that I'm using, simply selecting the Offline button is not enough to fake the background sync mechanism. So instead I really have to take my computer offline. To do that, I'll take a look at my network connections, and I'll disable my Ethernet adapter. Let's go ahead and pop this now for Mexicane Cola. Again, we're going to give it a five-star rating. We'll say that it's a great cola just like we wanted to before. I can add an image. And even though I'm offline, I'll go ahead and hit Save. And things seem to work for the most part. Let's take a look at what's happening under the covers. If we look at the IndexedDB data for SodaPopped and my reviews column, we can see the main-root-mexicaine-cola entry, and we see that it is not synced. Let me go ahead and go back to my service worker. I'll open it up. We'll go to our sync listener. I'll put a breakpoint there. Now the sync has not happened yet because we're offline, and syncs should happen when we become online. Let me go ahead and bring my computer back online. And moments after my machine comes online, we hit the breakpoint. And if we look at our event, the tag shows that we're running sync-reviews. We can continue. And the save goes through, no problem. That about does it for one-off synchronizations. I'm going to take a brief moment to talk about the future of background sync and periodic syncs.

Periodic Sync
So far we've only handled one-off syncs, which are great for when users input data while offline but not good for just regularly returning to your back-end to gather new data. For example, think about how Twitter might keep your app up to date when you're online so that when you're offline, you have some recent tweets. This is where periodic synchronization comes in. But I want to stress that this is not implemented by any browsers right now. And the specification is still being worked through. But I wanted to show you some early thinking for completeness' sake. Periodic sync is very similar to regular syncs in that you'll begin with the service worker, and instead of getting the. sync synchronization manager, now you'll use the. periodicSync synchronization manager, and you'll register for a sync. A tag still needs to be passed in and works just the same way as tags on a one-off sync. But there are some additional properties like minPeriod, which dictates the minimum amount of time in between periodic syncs. So in this case, I'm saying we have to sync up at least every 12 hours if available. And there're some thoughts around setting a powerState, so if the battery is low, you might want to avoid draining it, or a networkState, so you don't necessarily want to synchronize over cellular, for example, if you're sending down a lot of data. That's really it for the register method. It's a promise so you can use then to handle success and failure conditions. To handle the event, it works the same way as standard sync except the name of the event has changed to periodicsync. You'll still check the tag and then implement the proper logic for whatever synchronization tag happens to be passed in. That's it for periodic sync. Keep an eye on the specification to see when this functionality becomes ratified.

Summary
That's it for this short background syncing module. Along the way, we covered when and why we might need background synchronization in our progressive web app. We went in-depth into how to perform a one-off with synchronization leveraging IndexedDB. And we took a look at the future by briefly reviewing the proposed API for periodic synchronization. In the next module, we're going to cover best practices for progressive web applications.

Best Practices for Progressive Web Apps
Intro to PWA Checklist
In this module, the final one of the course, we're going to take a look at some of the best practices for creating great progressive web apps. Over on the Google developer site, they maintain the Progressive Web App Checklist. This is the list that we're going to be using to make sure we're following all of the best practices. And later in the module, I'm going to introduce you to a tool called Lighthouse, which will help us test some of the items on this list. The link for this page is included in the course notes, but you can see it here at the top of the screen. Not only does the list call out what you should be doing, it also lists how to test to make sure you're completing the objective appropriately, as well as how to fix your application to meet the objective when you don't. Let's go ahead and take a look at each of the items on the list.

PWA Checklist Overview
The Progressive Web App Checklist is broken into two major categories. The first category highlights a list of baseline requirements that Google recommends for a minimal progressive web app experience. And then most of the items in the checklist fall into an exemplary category, which is for progressive web apps that are trying to go above and beyond to really match and compete with native applications. There're about half a dozen items on the baseline checklist. The first is that your site has to be served over HTTPS. This shouldn't be a problem for you since most of the technologies involved in progressive web apps only light up on secure HTTPS sites. Next, it's expected that your application works with responsive web design techniques so that pages can be viewed on tablets and smaller phones and mobile devices. Third, metadata needs to be provided with a web app manifest so that Add to Home Screen experiences will work. We covered how to do this extensively earlier in the course. And then the start URL in that manifest needs to load, meaning that it returns at least a 200, while the app is offline. The last few baseline items include a general performance check making sure that a page is interactive in less than 10 seconds on a 3G connection. Like all good web apps, it should work cross-browser in not only Chrome but also Edge and Firefox and whatever other browser your users tend to be using. The transition between pages should always feel snappy even on a slow connection. And you should ensure that screens within your app are deep linkable and that each page has its own URL, which is a pretty common practice on the web. Now I'd like to point out that all of the items on the checklist except for the three with an asterisk here are testable via the Lighthouse auditing tool created by Google. We'll look at that tool in a little bit, but it's nice to know that at least for the baseline experience, there is some automated tooling that can help you. That's not true of exemplary experiences, which we'll look at next. The exemplary items on the checklist are broken into further subcategories, the first of which is the indexability and social subcategory. When it comes to indexability, it's no surprise that the first item on the list is having your site's content be indexed by Google. The next few items are around making sure that the metadata on your website allows Google to index it the best that it can using things like schema. org and social metadata for Facebook, Twitter Cards, and Open Graph, and then if your content has multiple different URLs to make sure that you're using proper metadata in the head section of each page to specify the canonical URL. And then, lastly, to make sure that you're using real URLs with a history API as opposed to fragment identifiers, which are the parts of the URL that come after a hashtag. That's kind of the way the old Twitter web client used to work. The next category is around user experience. And there're some pretty common sense things in this list. You don't want your content to jump around as the page loads. Native apps don't do that. And although the web does kind of do that default, there are easy ways to stop that from happening. If you are looking at a details page, and you press the Back button to go back to the listing that you were previously on, you want the page to stick to where it was, not force the user to re-scroll back down the list. You want to make sure that if a user taps on a textbox or something like that that the onscreen keyboard doesn't cover up what they're trying to type in. If your app runs in full screen mode or stand-alone mode where the user's not going to have an address bar, you want to make sure that they have a way to share that URL or really that screen, and this really hints towards the new Web Share API that Google is pushing, although that API hasn't actually landed in Chrome or any other browser yet. So I feel like this particular item on the checklist is an extra exemplary. The next is an update to one of the baseline items, and this is around responsive design again. The baseline experience should be for phone and tablet support, and the exemplary experience is phone, tablet, and desktop support. You should make sure that your app install prompts are not used excessively and that you are intercepting the Add to Home Screen prompt so that you can only show it at a good time. We looked at how to do this in an earlier module. The next category is around performance. Once again, it's the same recommendation from the baseline, which is a fast load on 3G, but in the baseline, Google would like to see your page interactive in less than 10 seconds, whereas an exemplary application would load in less than 5 seconds on a 3G connection. There's a caching category where the checklist specifies that you should be using a cache-first networking strategy as opposed to a network-first strategy. And the site itself has a notification or visual indication that the user has gone offline. There're a bunch of common sense items around push notifications, many of which we covered in the push notification module of this course, but they are to provide content to the user to let them know why you want to push the notifications and the kinds of things that they're going to be getting in push notifications. You want to make sure that when you're asking them to enable push notifications that you're not too pushy, no pun intended there. I find this one to be really interesting, but Google would like to see you dim the screen when you're asking for permission, which would effectively make the notification prompt feel a bit more like a modal dialog. And, of course, the best practice is what we already mentioned in the push notifications module that push notifications should be timely, precise, and relevant. And then you should give your user a way to turn off their push notifications and turn them back on directly in the app and not have to use the browser Chrome UI to accomplish that task. Lastly, there are a few different miscellaneous additional features for an exemplary application. These fall into the extra exemplary category for me as well, just like the Web Share API. The first is that the user is able to log in via the Credential Management API, which is just beginning to ship in Chrome, and it's not available in other browsers. And they can easily make payments if your app does that with the Payment Request API, another new API that Google is pushing. So that covers the items on the checklist. Let's look at how we can test some of those with the Lighthouse auditing tool.

Intro to Lighthouse
I've mentioned Lighthouse several times already in this module. And in the next clip, I'm going to demonstrate how to use it. But what exactly is Lighthouse? Well the first thing to know about it is that it's free and open source, and that it's the newest auditing tool made available from Google. Google has had a history of creating auditing tools for web applications. There used to be an auditing tab in the Chrome dev tools, and then they created PageSuite Insights. Lighthouse follows in those tools' footsteps doing very similar things, but it's the first auditing tool to explicitly check for progressive web app best practices. Running Lighthouse is as easy as can be because you can use their Chrome extension, or if you'd like to automate it, there's an npm module available that you can run locally on your machine or from a continuous integration environment.

Lighthouse Demo
In this demo, the last one of the entire course, I'm going to show you very quickly how to install Lighthouse. And then we're going to use it via the Chrome extension, as well as from the command line. And, lastly, I'm going to show you how Lighthouse is integrated with one of my favorite web testing tools, WebPageTest. The easiest way to get started with Lighthouse is to head over to its repo on GitHub at GoogleChrome/lighthouse. From here, you can peruse through the code base into the detailed documentation. But I prefer to start at the more friendly home page where you immediately have an installation button for the Google Chrome Extension. Let's go ahead and install it. I'll click the button. We will add the extension. And when the installation is complete, a banner will pop up that says that Lighthouse has been added to Chrome. That's all we need to do for the Chrome Extension. Let's see how it's used. I'm going to flip over to the brands page of SodaPopped. I'll click on the button, and I have two buttons. I can either go to Options or Generate report. Options allow me to turn off different tests and audits that Lighthouse will run. By default, they're all on, and we'll leave it that way. So I'll click Generate report, and you'll see the browser start doing various convolutions and dancing around a bit as Lighthouse is forcing SodaPopped through several different tests. It usually takes about 30 seconds or so to get results. And when they're ready, they'll open up in a new tab with a report that looks something like this. The reports are actually pretty easy to read, and they're broken up into a couple of major categories. The first and the one we're most interested in is the progressive web app category. But there's also a category of general best practices, performance, and some fancier stuff. Let's take a look at the progressive web app section. I scored a 96 out of 100, which is awesome. My app can load on offline and flaky connections. The load performance is really fast, and I can see a breakdown of all of the different numbers. I have a meaningful paint in under 800 msec, for which I scored a 100. I got a 99 for my speed index score, the goal of which is 1250, and I'm just under it at 1169. And you can see I also did very well with my estimated input latency and my time to interactive. For any one of these metrics, if you want more info, you can click on the little question mark icon, and help text will appear below the metric. I also got good marks for my site being progressively enhanced, for network connection that is secure, for the fact that a user can be prompted to Add to Homescreen, that the web app will use a custom splash screen once it's been installed. I got a bit of a mixed bag on the address bar matching brand colors. My manifest is using a theme_color, but I decided not to add that metatag for the theme_color's overriding color for each individual page. I'm not sure why Google sees this as a bad thing since I have a theme_color. So I'm just going to ignore this. It doesn't really bother me. And then, of course, my design is mobile-friendly. I can click down on that and find out more details. Actually, I can do that with any of these tests. I can click on each one of them to find out more details about what was being tested. The best practices section is where I get the most dings to my score. Google would prefer me to be using HTTP/2, but I've not switched over to that yet for SodaPopped. I want to soon, but I'm still using HTTP/1. And I'm also getting dinged because one of the components that I'm using, this swiper component for my carousel, is using an old-school proprietary flexbox implementation, this ms-flexbox. And so I'm being dinged for that. It would prefer me to use the standard flexbox display property. I do pretty well on most of the other tests, but I have some color contrast ratio problems. I have seven different elements where the foreground and background colors do not have a sufficient contrast ratio. This is really important for accessibility. Overall, my performance score does really well. And for the fancier stuff, I'm using some new JavaScript features. Actually, in fact, I'm not using old JavaScript features. I'm not using Date. now, and I'm not using console. time. Instead, they would prefer me to use performance. mark and performance. measure, both of which I covered in my Real World Web Performance course on Pluralsight. So that's it for the Chrome Extension. Let's take a look at how we would do this in an automated fashion from the command line. In my command line, I have Node installed. I currently have version 6. 10. 2, and you'll need a version near that to be able to work with Lighthouse. To get Lighthouse on your machine, you simply npm install lighthouse, and you'll want to say that globally. We're going to have to wait a minute or so while npm downloads Lighthouse and all of its dependent packages and gets them set up on our machine. So this should just take a second, and then you'll be ready to go. Now that we have Lighthouse, it's very simple to use. We just call Lighthouse, and we pass it the URL we want it to test. Let's test the same brand's URL. I'll press Enter to run. We'll see a Chrome browser window get opened up with a couple of different tabs. It'll do the same dancing and testing that we saw earlier when we were using the extension. And that's it. Once that's done, we can flip over to the directly that we're running the command in, and the HTML report will be generated that we can open up. And here you'll see the exact same report that we were looking at earlier. My 96 out of 100. Here's the one that I ran for the browser. And here's the exact same thing that I ran from the command line. If I switch back over to the command line, we can play around with some of the optional parameters that can be passed in Lighthouse. So once again, I will call Lighthouse pointing it at the brands page. But this time I will say that the output should be pretty. This will run the exact same report, but this time the output will just be formatted right here on the console, which is really nice if I don't want to have to open up a browser to see the report. And now that the report has finished, I'll scroll back up to the top. And you can see there's my 96%. I have all my green checks, my scores. I can scroll through to find the things that I didn't do well on. There's my theme_color tag. I have a red X on that. And really quickly I can see what's good and bad about my audit right from the command line. So that covers running Lighthouse from a command line. I also mention that it's integrated with WebPageTest. So let me go ahead and close down these reports, and I'll flip over to webpagetest. org. WebPageTest is an awesome testing application used mostly for performance analysis. If you're not familiar with it, of course I tend to recommend my WebPageTest Deep Dive course on Pluralsight where I cover in detail how to configure WebPageTest tests, how to analyze the results that come back from it, how to manage your network configurations. We can do some deep customization to script WebPageTest and use its API. And then I get into some enterprise concerns around authorization and firewalls. A new feature for WebPageTest, though, is integration with Lighthouse. That's not covered in the course because it's so new, but I'll show it to you here now. To use it, I'll simply type in the URL we want to access. We'll use the brand's URL again. And you'd open up the advanced settings, go to the Chrome tab, and check the Capture Lighthouse Report. There's a bit of a warning that says that this only works on mobile devices and Chrome beta. So let's change our browser from the standard Chrome, and I'm going to run this test on the Nexus 7 Chrome Beta. I will start my test, and in a moment, I'll have my results. Once the test completes, we'll have all of the standard WebPageTest goodness that we can go through and analyze including the videos and the filmstrips and the waterfalls. But we also have this new Lighthouse PWA score. So you can see from that test on the Nexus 7, I actually scored an 83, slightly lower. If I click on the number, I'll be taken to my Lighthouse report. And I can scroll through and I can see all the scores from the individual metrics. One thing that I've noticed is that it's reported that I'm using HTTPS. I clearly am, and I've scored well when I tested that from my local machine before. But I think because of the way that WebPageTest works, it actually breaks this one particular test. So I'm just going to ignore that. And that's it. Now I'm getting Lighthouse reports from WebPageTest or from the command line or from my browser extension. Let's wrap up what we've learned about these best practices.

Summary
In this module, we learned about the progressive web app checklist, a Google maintained list of best practices for progressive web apps. The list is broken into two main categories, one covering a baseline minimal progressive web app experience, and the other covering a more exemplary experience. From there we learned how to automate some of the items on the checklist by executing and reading Lighthouse audits. We also briefly saw how to integrate Lighthouse into WebPageTest. That's the end of the module, as well as the end of the course. Let's review what we've covered in our time together.

Course Summary
In this course, we studied five different modules. In the first module, we covered the history of the push and pull functionality between native applications and web applications. We learned all about the desire of each platform and its quest to be both rich and have wide reach. In that context, we covered the motivation behind progressive web apps and used it to lead into the rest of the course. In module 2, we took a look at the web app manifest specification, the first technology in the cluster of technologies that make up progressive web apps. The web app manifest specification allows us to have next to native installation experiences with icons on home screens and rich integration with the host operating system. In the third module, we learned all about how to increase user engagement with push notifications. We covered specifically the Notification API, which has been around for quite a while, as well as the newer Push API and went through several demos to configure and send notifications to mobile browsers. In the fourth module, we took a look at what to do when a user is offline to make sure that any data they input into our system is able to be synced with the server when a connection does become available. And then, of course, in this module, module 5, which we just wrapped up, we covered all of the best practices recommended by Google for progressive web apps. I hope you've enjoyed this Progressive Web App Fundamentals course and are as excited as I am about the future of the web and progressive web apps. If you have any questions, feel free to use the discussion board on the Pluralsight page or to tweet me directly at @nikmd23. I've compiled a huge list of resources over on my blog at nikcodes. com/pwa-fundamentals. You'll find links to all of the specifications we've talked about, all the demoes, samples, and much more there. And I'll try to keep it up over time. If you have a moment, be sure to check out my other courses. And, once again, thank you for watching. Have a great day!

Course author
Author: Nik Molnar	
Nik Molnar
Nik Molnar is a Program Manager at Microsoft and co-founder of Glimpse, an open source diagnostics and debugging tool. Nik lives in Austin, Texas where he specializes in web development, web...

Course info
Level
Intermediate
Rating
4.4 stars with 65 raters(65)
My rating
null stars

Duration
2h 56m
Released
8 May 2017
Share course
