Firebase on Android: Cloud Firestore
by Mitch Tabian

Firebase has announced Cloud Firestore as its new flagship database. In this course you’ll learn how to use Firestore to manage your application data with its unique “document-oriented” design.

At the core of modern mobile application databases is a thorough understanding of Firebase. The Firebase Database is an incredible product, but there’s still a big opportunity for improvement. The Firebase team listened to the feedback from the developer community, and Firestore is their answer. In this course, Firebase on Android: Cloud Firestore, you will learn how to master the new flagship database for Firebase. First, you will learn how to structure data following Firestore's document-oriented design. Then, you will see how to create, retrieve, update, and delete data and images. Finally, you will explore querying individual documents or entire collections with only a few lines of code. When you’re finished with this course, you will have a foundational knowledge of the Firebase Cloud Firestore that will help you as you move forward to develop mobile applications.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
4.9 stars with 21 raters(21)
My rating
null stars

Duration
2h 14m
Released
16 May 2018
Share course

Course Overview
Course Overview
My name is Mitch Tabian, and welcome to my course Firebase on Android: Cloud Firestore. I'm a self-employed Android developer, and I'm here to teach you about Firebase's new flagship database, Cloud Firestore. Cloud Firestore is essentially an upgraded version of the Firebase database. In a nutshell, there's a lot of things Firestore can do that the Firebase database can't, but there's nothing the Firebase database can do that Firestore can't. The Firebase database is an incredible product, but there's still a big opportunity for improvement. The Firebase team listened to the feedback from the developer community and Firestore is their answer. Some of the major topics we'll cover include structuring data. Firestore has a unique document-oriented design that I find extremely intuitive. Compared to object-oriented programming, you can think of objects as documents, and lists of objects as collections. Creating, updating, and deleting data. We'll insert documents into collections, insert documents into sub-collections, update individual fields in documents, and delete documents. Reading data. With Firestore, you can query individual documents or query entire collections of documents. These queries can be executed with only a few lines of code, and automatically operate on background threads. By the end of the course, you'll have an excellent understanding of how you can use Firestore to manage all your application data. Before beginning the course, you should be very familiar with Android Studio, and I recommend watching my Firebase on Android series on Pluralsight. I hope you'll join me on this journey to learn about Firestore with my Firebase on Android: Cloud Firestore course at Pluralsight.

Getting Started
Introduction
My name is Mitch Tabian, and welcome to my course Firebase on Android: Cloud Firestore. Let me start off by saying I'm extremely excited to be making this course. Firebase has a wide variety of incredible developer tools, and Firestore is no exception. It's truly a premium product, and I'm proud to be making a course on it. If you haven't watch the three courses preceding this one, I highly recommend it. I'm going to be moving forward with the assumption that you have. If you don't know what I'm talking about, search Pluralsight for Firebase on Android. You'll see four courses appear. In the first part, you'll learn about Firebase authentication; in the second part, the Firebase database and cloud storage; in the third part cloud messaging, cloud functions, and crashlytics; and of course the fourth part is the Cloud Firestore course. I'm going to start things off a little different than usual. Typically, the first clip of my courses is an introduction to the content you'll be learning. I usually talk about things like why you should take the time to learn what I'm teaching and a brief introduction on the content, but this time I'm going to start off with a full application demo of what we'll be building in the course, so just sit back, relax, and I'll take you through the app. Here is the Tabian Consulting application. This is the login screen. I've already registered an account, so I'm just going to log in with my email, mitch@tabian. ca. All this is done with Firebase authentication. Check out the first part of the Firebase on Android series to learn more about this. Now that I'm authenticated, I have access to the application. If I click the menu on the top right, I see a bunch of different options. There's Chat, Account Settings, Admin, and Sign-out. Those are all covered in the courses preceding this one. In this course, we'll be working with everything contained in the Issues option. I'm going to click it. This is what we'll be building. It's an issue tracking system. If you work in the industry, you might be familiar with the popular issue-tracking software named Jira. This was built with Jira in mind. Here's how it's structured. Users can create new projects by swiping over to the Projects tab. Then they click the plus icon in the top right. I'll create a new project named Decrease Company Overhead, and I'll give it a description of decrease annual overhead by 10%. Now I'm going to click Create. If I refresh the view, I can see the new project. If I click the project, it takes me to another screen where I can edit the project properties. It has an avatar, the project name, the description, and the timestamp of when it was created. If I click the avatar, I'm greeted with two options, choose a photo from the phone's memory or take a new photo with the phone's camera. Since this is just a demonstration, I'll choose any image. Now I'll click Save. If I refresh the Projects list, you can see the project avatar is now showing the image I selected. At the top of the Projects list is a search view. If I click the magnifying glass, I'm able to search through the list of projects. Now let's take a look at the Issues tab. Issues must be created under a project. An issue cannot exist if it's not assigned to a project. A project can have many issues, but an issue can only have a single project. As you can see, we have some issues already added to this project. You can tell which project these issues exist under by looking at this spinner. Right now we're viewing the issues in the Increase Revenue project. If I click the spinner, you can see all the projects. There's the new one we just created. If I click it, the list below changes. Notice there's no issues. That's because it's a new project. I'm going to create a new issue. I can create a new issue by clicking the plus icon in the top right. This first text field is an auto-complete text view. It automatically populates with all of the projects that are available. As you can see, if I click it, there's the list of projects. If I start typing, it filters the projects based on the characters that I entered. I want to create a new issue in the Increase Revenue project, so that's what I'll select. Next, I need to categorize this new issue as a bug or a task. I'm going to call this a bug. The Summary is basically the title. It's meant to be a short description of the problem or task. I'll write problem with income-tracking software. For the description, I'll write income-tracking software is reporting false numbers. And lastly, I need to give it a priority. I'll give it a high priority. Now I'll click Create. After it's created, the user gets a snackbar message at the bottom. All the issues in the list are sorted based on priority. The highest priority is at the top of the list. If I click on an issue, I can see the details of that issue. But there's also some extra fields. There's a spinner for the status of the issue; it can be In Progress, Done, or Idle. I can add attachments to the issue by clicking here. Once again, I'm greeted with a dialog asking if I want to upload from memory or take a new photo, and I can assign the issue to a Tabian Consulting employee. Let's upload some attachments. I'll just choose an image from memory. I'll choose a handful of random ones. As I select the images, they're being uploaded to Firebase storage. They're saving automatically. I don't have to click the Save button. If I select an image from the list, a fragment is inflated with the image occupying the entire view. The image is draggable and scalable. To remove attachments, I just hold my finger on one of them for about 500 milliseconds. After that, a trash can icon appears below the list. I can select multiple attachments by clicking more of them when the trash can is visible. If I click the trash can, they're deleted from storage and also from Cloud Firestore. Now I'm going to press back, and we'll look at the last piece of functionality. So far we've looked at creating projects, editing projects, creating issues, editing issues, uploading images, and deleting images, but we haven't deleted any projects or issues. If I hold my finger on the issue for more than 500 milliseconds, it highlights. The toolbar also changes. This works in the same way the attachments did. I can select multiple issues or a single issue. If I click the trash can while I have any selected, it's deleted from Firestore and any attachments that are associated with it. If I swipe over and do the same thing with the project, the project is deleted and any issues associated with it. That's the full application demo of what we'll be building in the course. I wanted to make something practical, and I think this sort of design really fits well with Cloud Firestore. This course is absolutely packed with value, and I really look forward to reading your comments and reviews when you've done it.

Introduction to Cloud Firestore
For those of you who are familiar with the Firebase database, Firestore is essentially an upgraded version of it. Comparatively, the Firebase database cannot do everything Firestore can, but Firestore can do everything, and more, than the database can. The only real downside of using Firestore is that it's technically still in beta, but the Firebase team has declared Cloud Firestore as its new flagship database moving forward. Compared to the Firebase database, Cloud Firestore offers additional functionality, performance, and scalability on an infrastructure designed to support more powerful features in future releases. The Firebase team says we can expect to see new query types, more robust security rules, and improvements on performance. That stuff is all great, but in my opinion, those aren't the best things about Firestore. The best things about Firestore is its intuitive data structure. It took me quite some time to be comfortable with the Firebase database and the best practices in terms of organizing your data. There's a lot of things to watch out for; nesting data, flattening data structures, creating data that scales, and I ran into a few issues with saving lists of data. Also, the way the data is structured, if you have a lot of it it's going to be almost impossible to fix a data issue. You'd have to either build a tool that you could explore and find bugs with, or download the entire database JSON file and search it manually. Overall, the Firebase database is an excellent product, but there's a huge opportunity for improvement. My first experience with Firestore was quite different. I found it very intuitive. The document-oriented design makes logical sense, and I understood it very quickly. You basically don't have to worry about nesting data. Of course, you need to be mindful of the way that you're nesting it, but overall it's much simpler and logical. You don't need to worry about flattening data structures. You can create collections within documents, then sub-collections within those documents. That can go forever, and you don't risk any issues. Scalability is a problem of the past. The Firebase database tops out at 100, 000 connections or 1, 000 writes per second. It's also recommended that the database is shared into multiple databases. Firestore, on the other hand, does not have this limitation, and in theory it automatically scales to whatever number of connections and writes are necessary for your system. And the last thing I want to mention is offline data persistence. Firestore allows for data storage, even when applications go offline. That means you can turn off the device connectivity, then make a change to the database from the app. Obviously Firestore won't be updated right away, but as soon as I bring the phone back online, the change will be written. I think this feature is really incredible. Users can get a consistent experience even when connectivity isn't the best. I don't want to talk too much about the data structures before we get into the course content, but I think seeing some actual examples of how we'll be saving data will be helpful. Here I am in my Firebase console in the Firestore section. Don't worry about how I got here or how I set it up at this point, I just want you to take a look at some data. As you saw in the application demo, we're building an issue-tracking system. At the top of the hierarchy are projects, then there are issues within those projects, and attachments then within the issues, so it goes projects, issues, then attachments. So intuitively you would expect to see a list of projects. If you selected a project, you would expect to see the properties unique to that project, and then the issues within that project, which is exactly what we see here. If I click a project, there's the properties, otherwise known as fields in Firestore. Then inside the project I selected there's a collection named issues, and if I click on Issues, I see a list of all the issues within that project. So if I'm using the correct Firestore terminology, there's a list of issue documents. If I click on one of the issue documents, I see the unique fields associated with that issue, and if that issue has attachments I see another collection named attachments. If I click on the attachments collection, I see a list of attachments. Now I'll click on one of the attachment documents, and here's where our road ends. We have the fields associated with the attachments, but no more collections. To me a system like this is very intuitive. I love it. It's simple, and effective. I'm curious to know what you think of it. Let me know in the discussion section of the course or send me a direct message on Instagram. That's probably the most reliable to get a hold of me.

Prerequisites and Dependencies
As I stated in the introduction, this is the fourth course in my Firebase on Android series on Pluralsight. This course can stand alone, but I highly recommend watching those courses first. in the Firebase on Android series, I walk you through building the Tabian Consulting application. Each course in the series improves the app. In the authentication course, we build a login and registration system using Firebase. In the database and cloud storage course, we built a user profile and a real-time chat system. In the cloud messaging, cloud functions, and crashlytics course, we sent push notifications to users when new chat messages are received and admin broadcasts from an admin. We also integrated Firebase crashlytics for detailed error reports from the Firebase console. And in the Firestore course, which is this course, we'll be building an issue tracking system. Since this is the fourth course, I won't be covering things like creating a new Firebase project, syncing the Android project with Firebase, or any of the small details we covered multiple times in the other three courses. Other concepts you should be familiar with are RecyclerViews, ListViews, callbacks, using an interface, fragment to fragment communication, using glide to set image resources, creating custom object classes, otherwise known as plain-old Java objects, touch listeners, ViewPagers and tabs, and fragments. If you don't have a good understanding of those concepts, you can still take the course, but there's likely going to be some confusing parts. What exactly do I mean by that? Because the course topic is focused on Firestore, I won't be explaining those other concepts in detail. For example, I'm not going to explain how to set up tabs and a ViewPager, I'm going to assume that you already know how to do that. Let's take a quick look at the dependencies in the Build. Gradle app file. Since this is the fourth course in the series, I'm only going to talk about the new dependencies that I've added. first is the glide library. In the other courses, I was using the Universal Image Loader to set images. I switched because the Universal Image Loader is not being maintained by the owner anymore. Actually, it hasn't been maintained for over two years now, so I think it's a good time to make the switch. Next is the Firestore dependency. You'll also notice that the versions are updated. In the previous three courses, I was using Firebase version 11. 0. 4. Now I'm using 12, and it seems very stable. And the last new dependency is the circle image view library. As its name implies, it's a library for circular image view widgets. That's it for the new dependencies. I'll be targeting and compiling to SDK version 27 and using Android Studio version 3. 0. 1. That's everything I recommend for the course. If you meet all this criteria, I guarantee you'll have a valuable experience.

The Story Behind the App
For the duration of the course, we're going to approach app development from the perspective of an imaginary company Tabian Consulting. For those of you who have watched the rest of the Firebase on Android series, we're going to be continuing right where we left off from the Cloud Messaging, Cloud Functions, and Crashlytics course. Now that Tabian Consulting has over 100 employees, management is getting more and more difficult. The company has decided to implement an issue-tracking system in the Tabian Consulting mobile application. The issue-tracking system will allow users to create projects, report issues under those projects, and track who has been working on the issues and tasks. You've been hired as a developer to implement this system. You've chosen to use Firebase Cloud Firestore, as it's essentially a superior version of the Firebase database.

How to Use the Source Code Files
For your convenience, I've add the source code files to a GitHub repository, and also attached them to the exercise files for the course on Pluralsight. I recommend using the code on GitHub since it's easy to switch between modules and clips, but if you want to get the code from Pluralsight you're more than welcome to do that too. Let's walk through how to get the code from GitHub. Launch Android Studio, click on Check out project from Version Control. Here's where you're going to put the GitHub repository URL. Open GitHub, and let's get it. Navigate to github. com/mitchtabian, and then /TabianConsulting. Click Clone or Download right here, and copy this URL. Go back to Android Studio and paste the URL right here. Click Clone. This message will pop up asking if you want to open the project you just referenced. Click Yes. If you already had a project open, you can also import from Version Control by going to File, then New, then Import project from Version Control. Then paste the URL right here. At this point, if you're getting any kind of an error, I suggest going to File, Invalidate Caches and Restart, and then click Invalidate Caches and Restart. If you have any issues with loading the source code while following along with the course, this is the first thing you'll want to try, invalidating the caches and restarting. Notice I can't click the Play button yet, so there's still a problem. Open the Logcat. Android Studio is telling us we need to configure the SDK. I'm going to choose Build Tools Version 27. 0. 3, since that's the newest version at the time I'm making this video. The last thing you need to do is get your Google Services JSON file from Firebase. Remember, the Google Services JSON file is what enables Firebase to communicate with your project. If you need a review on how to do that, watch the clip named Syncing the Android Project with the Firebase Project, in any one of the Firebase on Android courses preceding this one. After you add the Google Services JSON file to the app folder, you should be good to go, but if you're still having issues, make sure your Android Studio is the same version as mine, 3. 0. 1, and all the SDK tools are up to date in the SDK Manager. Now accessing the source code for each clip is very simple. Click down here where it says Git, drag this window upwards and expand it. These are all the clips of the course, so if you wanted to open the source code for the start of the module named Inserting Custom Objects, then you'd select the branch named Module_4. 2_Start. If you wanted to see the code for the end of that module, you would go to Module_4. 2_End. You'd click Checkout as new local branch and click OK. Now all the code is updated. Let's do another example. Suppose you wanted to open the code for the module named Querying Documents in a Sub-collection. Once again, click down here, select Module_5. 3_Start, and then Checkout as new local branch. Now you're ready to start that module. Keep in mind that once you've checked out a branch once it will be added to this local module section right here. If you want to open that same branch in the future, all you need to do is click it and then select Checkout. You don't need to use Checkout as new local branch since it's already a local branch. If the naming of the branches is confusing to you, let me explain by referencing one of my other courses on Pluralsight. At the time I'm filming this, this course is obviously not published yet, so I'll have to refer to a different one. Here's another one of my Android courses. It's called Android Gestures: Getting Started. Pretend we're working on this course and we just imported the code from GitHub like I just showed you. This would be module 1, this would be module 2, this would be module 3, and so on. That's how I've named the branches for the project.

Integrating Cloud Firestore
Introduction
Before we move forward, I want to remind you that this is not an introduction course. This is the fourth course in a series. For that reason, I won't be going through a lot of the Firebase setup procedure like I did in the previous three Firebase on Android courses. I'm not going to be walking you through how to create a new Firebase project, registering the app with Firebase, or walking you through how to add the Google-service. json file to the app folder of your project. Remember, if you need a review on how to add the Google Services JSON file to the project, watch the clip named Syncing the Android Project with the Firebase Project in any one of the other Firebase on Android courses preceding this one. So moving forward, I'm going to assume you have the source code, it compiles and runs, and you're able to use the Tabian Consulting application.

Adding the Firestore Dependency
To get the most up-to-date Firebase dependencies, I always recommend getting them from the Firebase documentation. You can find the Firestore dependency at firebase. google. com/docs/Firestore/quickstart. If you scroll down and select the Android tab under the Set up your development environment heading, you'll find the dependency. I've already added the dependency ahead of time. Open the build. gradle app file. There it is right there. Notice I'm using version 12. The most recent version is actually 15 at the time I'm making this video, however, I was having some issues with 15 so we'll be using 12 for this course. And, yes, I realize I just contradicted myself. I told you I recommend always getting the most recent version, but in this case it was causing problems, and sometimes the new versions do, so be wary of that.

Security Rules
If you've never used Firestore before, the Database tab in your Firebase console will look like this. You're given a choice to use Cloud Firestore Beta, or the Realtime Database. I'm going to click Get Started. Test mode will allow anyone to read or write to your database. We obviously don't want that. With Start in locked mode selected, I'm going to click Enable. It might take a few seconds for Firebase to get everything set up. Once it's done, navigate to the Rules tab. Firestore rules are similar to the Firebase Database rules, but different enough that it's worth talking about. Firestore security rules consist of something called match statements. The match statements identify documents and who has access to them. The document=** means all documents in the database, so this statement here is defining the rules for every single document in the database. But we don't need to do it like this. We can specify special rules for any document or collection. let's use our project hierarchy as an example. If you recall, we had projects, issues, then attachments. I'll comment out these default rules. To set rules for the attachments collection, we would write match /projects squiggly brace, project, squiggly brace, then issues/ squiggly brace issue, attachments squiggly brace, attachment. The curly bracket indicates a variable. If you recall from our database, each project document contains a variable ID. If I select the issues collection, we see the same thing. Each issue document has a unique ID. Attachments are the same. That's why we use the curly brackets. At the highest level you have two basic operations to control, read and write. Read can be broken down into two sub-operations, get and list. Write can be broken down into three sub-operations, create, update, and delete. Let's start with read and write. Suppose I only want the person who added the attachment to be able to read it? I could write something like this, allow read: if request. auth. uid == resource. data. user_id. Resource and data are keywords. Resource. data allows us to access the fields of that particular document. If I refer to the database and take a look at an attachment, we see the user_id field. I'll go back to the rule. So that security rule is checking to see if the authenticated user's id is the same as the one who published the attachment. I'm going to comment this out, and we'll look at another example. Suppose you wanted the user who created the issue to be able to create update or delete the attachments, but anyone could view them. That would look something like this. First write the match statement, so match projects/ project, issues, then issue, allowing anyone who is authenticated to read the document would look like this, allow read: if request. auth does not equal null. Allowing only the creator to write, update or delete would look like this, allow write: if request. auth. uid == resource. data. reporter. If you're confused about the reporter field, take another look at the database. The issues document don't have a user id field, they have a reporter field instead. That's the user_id of the user who created the issue. I'll go back to the Rules tab. That would achieve our goal. We just need to press Publish and the rules would be active. You can also use security rules to check for specific strings or keywords in the fields. There's a great example of that in the documentation. Go to this URL. If you scroll down to the Data validation heading, you'll see the example. Here the Firebase team is showing us that we can check for a field named visibility and compare it with a string. If the string is public, then the document can be read. If we ever needed to make a bunch of documents unreadable by the public, it would be as simple as changing the visibility variable in those documents. If we were using a simpler rule, like if auth does not equal null, then every authenticated user would still be able to read them. If we ever needed to make a large amount of documents unreadable in a hurry, they'd need to be deleted or a new rule implemented. Both of those methods can get really messy, really fast. Having a check to see if the document is public is a clean, simple solution. The last concept I want to talk about is accessing other documents. With Firestore, we can write rules that check for the presence of fields in other documents. Basically what we're doing with this is making a query inside the rule. This is a really cool feature. It can save you a ton of code on the client side of things. Suppose you only wanted admin users to be able to edit issues. To do something like that, we need a users collection. We don't have one in this project, but I'll quickly create one just for this demonstration. So I'll click Add collection, I'll call it users, and click Next. Each document ID would be the unique user ID each user gets from Firebase authentication. It's automatically assigned, and never changes. I have mine copied to a Notepad file, so I'm just going to paste it in here. This is the user ID Of the user I'm currently authenticated with the app. The fields will define what it means to be a user. In the most basic case, they'd at least need a name and a user ID. So I'll add a field name, name, and I'll give this user a name of Mitch. Now a user_id field, I'll copy the user ID from the document ID and paste it in here. Now I'll add another field. This is what it will mean to be an admin. I'll make it a Boolean and set it to true. Now I'll save it. Back to the Rules tab. Our goal here is to only allow admin users to edit the issues. I'll copy this rule, comment it out, now paste it below. Delete everything after the issue variable so it looks like this. Now allow write: if get databases $(database)/documents/users/ $(request. auth. uid). data. admin == true. We need to use the dollar sign, because that denotes a query. It queries the database for the user document that contains the current authenticated users user_id. Then if it contains the field named admin and it's true, then they can write to the field. Hopefully those examples were helpful. For this course, we're going to be keeping it very simple. The only security rule we'll be using is match document **, then allow read, write: if request. auth does not equal null. After clicking Publish, the rules should be live within a few minutes. The rest will be commented out. I'm going to leave them here just in case I want to reference them later. That's pretty much all I want to talk about regarding security rules. The rest is up to you. I definitely recommend checking out the security rules section of the documentation at firebase. google. com/docs/Firestore/security/get-started. There is a ton of really great examples. Don't be afraid to get creative and try to come up with some useful rules to save yourself some client-side code.

Indexing Data
For those of you who've never heard of indexing before, indexing data is a very common way to increase the speed of queries that are performed on the database. I'm not going to get into details about it on this course, but if you want more information on how indexing increases query speed, there's a bunch of courses on Pluralsight you can check out. One of the most recent ones is SQL Server: Indexing for Performance by Kimberly L. Tripp. You can find many more by just searching the keyword index on Pluralsight. One of the great things about Firestore is that it automatically indexes the data for you, so every time you add a new document to a collection, the document fields are automatically indexed, and therefore, optimized for search queries. In terms of indexing, Cloud Firestore has only one limitation. If you want to create complex indices that span multiple fields, typically an index consists of a single lookup field, then you have to make them yourself, but as it turns out, Firebase has you covered there as well. You can easily create them from the Firebase console. To create your own indexes, open the Firebase console and navigate to the Cloud Firestore section. Click on the Indexes tab up here. The first thing I want you to notice is this note. It says Run your desired query in your app code and you'll receive a link to generate the required index. The Firebase team is telling us that one way to create a custom index is by just trying to make the query and then clicking the link that they provide. I'm sure you're a little confused by that, so let me explain. Let's check out the documentation. go to this URL. Under the Compound Queries heading, there's an example. The documentation is telling us that if we want to make complex queries to Firestore, like this one right here, we should just try to do it in our app, then when it fails click the link from the log output and the index will be generated. You're probably still a little confused, so let me explain once again using different wording. In these examples, the user is trying to query Firestore using two conditions. In the top example, they want you to find the state denoted by CO, and it also must have the field name equal to Denver, so there's two conditions. That's considered a complex query. If it only had a single condition, we wouldn't have to worry about it, Firebase would automatically index it, but since there's two, there's no index for that. But when we try to make the query using the app, it will return a link as a log output. If we click the link, an index will get created for those search conditions. So it's very convenient. Once again, the Firebase team has the developer in mind, and they're trying to make things as simple as possible. If you wanted to be proactive and not click the link they provide, we could index this ourselves. Taking the top one as an example, we'd want an index on the state field and the name field, but we need the collection as well. If you scroll up, you'll see the collection they're using is named cities. I'll go back to the Firebase console and I'll show you what you need to do. The collection is named cities, and we want the index on the name field and the state field. Then you would just need to click Create Index, and Firebase would generate the index for you. That's all there is to it. After that, if you make queries with the search conditions on the name and state field, it would hit the index and your search would be optimized. Once again, the Firebase team is making life simple for the developer.

Limitations
In general, Firebase is an incredible technology, and there's nothing else like it. The tools they provide, mostly for free, are something I would probably pay a lot of money for. However, in terms of querying data, there's one thing you can't do, and I think it's an important one. There's no way to do a full-text search. Never heard of a full-text search? It's the same thing as doing an SQL "LIKE" query. You can query a database with only a couple of characters and get results that match those inputs. I always use the example of searching for a name if you don't know the spelling. If you are searching for a name like Elizabeth, and you didn't know the spelling, the SQL query would look like this: SELECT * FROM table_names WHERE name LIKE "eli*". That would return all the names with the character combination eli, and you'd certainly find what you were looking for. As a more practical example, consider any of the popular social media apps right now, apps like Instagram, Facebook, or Twitter. If you search for someone's name or user name, a list of suggestions appears below the search box. That's a full-text search. It's taking what you're typing, and searching the database for data that matches those character combinations. Unfortunately, Firebase has no query like that. There's no way to search for something unless you know exactly what you're looking for. For example, if we wanted to search a collection named cities for a city named Vancouver, the query would look like this: citiesRef. whereEqualTo("city", "Vancouver"). It's not possible if you don't know the spelling. It won't work if you do something like this: citiesRef. whereEqualTo, city, and then VAN*. The wildcard means nothing. I think this type of query is very important. It has so many applications. I'm very surprised there's no out-of-the-box solution for this problem yet. currently the only way to resolve this problem is to use another product like Elasticsearch or Algolia. I think I pronounced that right. You need to build a cloud function that copies the data from Firebase to one of those products to make an index. Then you query the index. It's a lot of work for something that I think could be solved by Firebase. For more information on how to do this in detail, check out the Firebase documentation at firebase. google. com/docs/Firestore/solutions/search. I look forward to the day Firebase streamlines their own full-text search product.

Module Review
In the first part of the module, we talked about the expectations I have for you as a student. Because this is the fourth in my Firebase on Android series, I won't be walking you through how to create a new Firebase project, registering the app with Firebase or walking you through how to add the Google-service. json file to the app folder of your project. If you need a review on how to add your Google-service. json file to the project, walk the clip named Syncing the Android Project with the Firebase Project in any of the other Firebase on Android courses preceding this one. Next we talked about security rules. Firestore rules are similar to the Firebase Database rules, but different enough that it's worth talking about. Firestore security rules consist of something called match statements. The match statements identify documents and who has access to them. Let's review one of the examples that we looked at. The first example was our project's hierarchy. If you recall, we had projects, then issues, then attachments. To set rules for the attachments collection, we would write match /projects/ project issues/issue attachments, and then attachment. Then the simplest rule, which is what we'll be using in the course is to only allow reads or writes if the user is authenticated. So you would write allow read or write if request. auth does not equal null. If you want more information on security rules, make sure to check out the Firebase documentation, or re-watch the clip named Security Rules. Next we talked about indexing data. Being the incredible product that it is, Firebase automatically indexes your data. With respect to Firestore, it indexes the fields in your documents, but there is a limitation to this. By default, Firestore only indexes individual fields, so if you want to do more complex queries that specify conditions for multiple fields, you need to create a custom index from the Firebase console, or you can click the link generated when you attempt to make the query from the client. The last thing we talked about was limitations. There's only one thing that really stands out to me if we're talking about limitations, and that's full-text search. Referring to the example I used in the clip, imagine you wanted to use search a database for a user named Elizabeth, but you weren't exactly sure how to spell it, if you were querying an SQL database we would do something like this, SELECT * FROM table_names WHERE name LIKE "eli*". That would return all the names with the character combination eli, and you'd certainly find exactly what you were looking for. It would return a large list of results. Unfortunately, Firebase has no query like that, there's no way to search for something unless you know exactly what you're looking for.

Inserting and Managing Data
Introduction
Cloud Firestore is a NoSQL document-oriented database. There are no tables or rows. Firestore has a unique design where data is stored in documents. The documents are organized into something called collections. Each document contains key value pairs. They can be strings, numbers, Booleans, objects, arrays, timestamps, geopoints, references, or, of course, null. As you saw in the application demo, we're building an issue-tracking system. At the top of the hierarchy are projects, then there are issues within those projects and attachments within the issues, so it goes projects, issues, attachments. So intuitively you'd expect to see a list of projects. If you selected a project, you would expect to see the properties unique to that project, and then the issues within that project, which is exactly what we see here. If I click a project, there's the properties, otherwise known as fields, then inside the project I selected there's a collection named issues. If I click on issues, I see a list of all the issues within that project, so if I'm using the correct Firestore terminology, there's a list of issue documents. If I click on one of the issue documents, I see the unique fields associated with that issue, and if that issue has attachments I see another collection named attachments. And if I click on the attachments collection I see a list of attachments. I'll click on one of the attachment documents, and there's where our road ends. We have the fields associated with the attachments, but no more collections. To me, a system like this is very intuitive. I love it. It's very simple, and I find it very effective. I don't want to talk too much about technical details until we look at some examples, so without further ado let's insert some data.

Inserting Custom Objects
The first step when inserting data is determining what the data should look like. I always recommend inserting some dummy data into the database just to get a feel for what it's going to look like. While I was designing the course, that's the first thing I did. I created a projects collection right from the console and inserted some fields that made sense to me. Of course, this gets revised over time, but that's the best place to start. Once you have a general idea of what the fields are going to be, you can build Java object classes to represent them. Open Android Studio, and let's take a look at the Project object class. The first thing I want you to notice is the IgnoreExtraProperties annotation. If you annotate your class with this, class fields that don't show up here will be ignored when querying a Project object from the database. I think in general this is almost always a good idea to do. It can prevent crashes when casting objects into queries to Firebase, but there's not really any downside that I can think of. Next we have the fields. Notice the way I'm naming the fields. Everything is lowercase, and words are separated by underscores. As a rule, you should always try to keep fields lowercase in the Firebase Database and Firestore. Capitalization matters, so making sure everything is lowercase can save you some potential headaches. The string fields are pretty self-explanatory, they're strings, but take a look at this date field. This is new to Firestore. The database doesn't have a Date or Timestamp data type, and it's very useful. If you annotate a Date field like I've done here with Server Timestamp, Firestore will automatically insert a Server Timestamp if the Date field is null. In other words, if I insert a Project object into Firestore and the time_created field is null, a timestamp will automatically be added. I absolutely love this feature. It means less code for me to write, and I don't have to worry about accuracy. The last part of the class I want you to notice is the Parcelable implementation. You don't need to make Firestore objects Parcelable, this is so we can send project objects through bundles later in the course. I just wanted to make sure that's clear. You do not need to make the object class Parcelable to insert it into Firestore. That's for something else. If you don't know what a Parcelable implementation is, it's just a way of packaging objects when they're attached to bundles, that's all. By writing implements Parcelable and inserting the required methods, the object can be added to a bundle. The methods associated with a Parcelable implementation are this Project method with a Parcel input, this Creator method, describeContents, and writeToParcel. One thing you need to watch out for is the Date field. Date fields are obviously not strings, so you need to use writeSerializable on the parcel like I've done down here. Also up here in the Project(Parcel in), notice I'm casting it to a Date field and writing in. readSerializable. You need to add those lines of code to implement Parcelable on a Date field. If you don't do that, and you add a Project object to a bundle, the Date field will be received as null.

Inserting Documents
Before we write any code, let's quickly go over the code that I've provided. All the new code pertaining to this course will be kept in the issues package. As you can see, there's only a handful of classes in there right now. We're going to start with IssuesActivity. IssuesActivity is the activity that comes into view when we first navigate to the Issues section of the app. IssuesActivity hosts two fragments using the ViewPager, and therefore the tabs, IssuesFragment and ProjectsFragment. Obviously IssuesFragment is for listing issues, and ProjectsFragment is for listing the projects. The interface, IIssues, is implemented in IssuesActivity. IIssues will have lots of uses as we move forward with the course, but for now it's just for showing or hiding a progress bar and building snackbar messages. Now that you have an idea of how the project is structured, let's go over the project creation process. In ProjectsFragment, there's an onClickListener attached to this plus icon in the top right-hand corner of the toolbar. If I click it, I'm taken to a new activity named NewProjectActivity. Notice the call to startActivityForResult and the ResultCode. This is for displaying a snackbar message after a new project is created. So later, when we call finish in New Project Activity, onActivityResult down here will detect the activity finish and build a snackbar message. Open NewProjectActivity. It's a simple layout with four main components. There's an x to close the activity, a TextView labeled Create, an EditText for the project name, and an EditText for the description. If we look at the onClick Override method, there's two cases, if the user clicks the x icon to close the activity or if the user clicks the Create TextView in the toolbar. If they click Create, a method named CreateNewProject is called. This is where we'll write the code to create a new project. Of course, the first thing we need to do is make sure the fields aren't empty. Our objective here is to insert a new project document. When writing data to Firestore, you always start with the same object, the FirebaseFirestore object. Inserting a document is different than inserting a collection. We want to insert a document here. To insert a document, we need a DocumentReference object. Call it newProjectRef. To reference where the document will live, write db. collection, then specify the collection_projects, then. document to tell Firestore you're inserting something. Now let's create the Project object that we want to insert. Write Project project = new Project. Our project objects need six parameters, the project name, the project description, the user ID, the time created, avatar image, and the projectId. We have the project name, we have the project description, to get the user id we write String userId = FirebaseAuth. getInstance(). getCurrentUser(). getUid(). Pass null for the time created. Remember, because we have the @ServerTimestamp annotation on the Project class, Firestore will automatically insert the timestamp. If you don't remember what I'm talking about, open the Project class, this right here. I love this feature. It's subtle, but it saves time. Let's go back to NewProjectActivity, pass in a blank string as the avatar. To get the project ID, we use the project reference and then call getId. Now we're ready for the insert. There's a handful of ways to insert data with Firestore. In this clip, we're going to use the set method. Write newProjectRef. set, pass the project, and then add an onCompleteListener. Before we move forward, I want to point something out because I'm anticipating a bit of confusion. Notice when I write newProjectRef. set(project), there's onCompleteListeners, onSuccessListeners, and onFailureListeners, so which do we choose? Obviously, you know we're going to be using an onCompleteListener since I wrote it above, but why didn't we use the onSuccessListener? You can, you can use either. If we wanted to use the onSuccessListener, this is what we'd do. NewProjectRef. setProject, then add onSuccessListener, new OnSuccessListener, and that's it. But the thing with the SuccessListener is that it only checks for success, it doesn't check for failure, so we need to add an onFailureListener down here also. But if we're using the onCompleteListener we don't need to do that, it executes on completion, whether it was successful or not, so I usually use onCompleteListeners. But of course, then there's a problem, how do you let the user know if the task was successful or failed? Inside the onComplete method we can write if task. IsSuccessful, we know it was successful, and then otherwise, obviously it wasn't. That's going to be the general form for all of our set tasks. If the task is successful, we want to create an intent. Add the extra intent_snackbar_message, and give it a message of created_new_project. Set the result, and reference the SNACKBAR_RESULT_CODE from ProjectsFragment, then call finish. So when our task completes successfully, that result code and message will get intercepted by onActivityResult in ProjectsFragment. Open ProjectsFragment. Remember, right here, go back to NewProjectActivity. If the task fails, we'll create a snackbar message and let the user know the project creation process failed, so we'll use the message failed_create_new_project, and then just show a length of long. And lastly, hide the progress bar below the else statement. Let's run it and take a look. I'll navigate to NewProjectActivity by pressing the plus icon. I'll enter a project name of Testing New Project, and a description of this is test project number 1. Now I'll click Create, and the snackbar message is saying it was successful. If we take a look at the database, there's a new project ID in the fields associated with it.

Adding a Collection to a Document
We've inserted a new document, now it's time to insert a new document within a collection. I've added a lot of new code to this clip, so let's quickly go over that. For starters, we have a new object class named Issue. All of this should be very familiar to you from the Project object class. The only real difference here is the fields, and this method down here named getPriorityString. I'll talk about getPriorityString in a moment. The constants at the top are for some of the fields. For example, the status field can have one of three possible values, In Progress, Done, or Idle. Priority can be High, Medium, or Low. Issue_type can be Task or Bug. Now check out the getPriorityString method. I want to display the priority in TextViews as High, Medium or Low, but the priority field is an integer, and that's what this method is for, it returns a string representing the priority of the issue. The next class I want to talk about is SpinnerAdapter. When creating a new issue, the users need to select the priority from this spinner. I need to build a custom spinner adapter to display an image and text. The class named SpinnerResource in the utility package holds all the spinner values we'll be using in the course. It holds all the text and all the drawables. And lastly, it is NewIssueActivity. open it up. There's quite a bit of code here. That's because there's a lot of functionality in this activity. Each spinner needs its own initialization method for setting the values. Here you see the initialization for the IssueTypeSpinner, and the initialization for the PrioritySpinner. Other than that, the activity is very similar to a Projects activity. There's a bunch of input fields and a TextView labeled create for inserting the data. Scroll to the CreateNewIssue method. The first part of this method is very similar to what we did in ProjectsActivity. We're checking the AssignToProject field and the Summary field to make sure they're not empty. The AssignToProject field is for the project name. Remember, each issue must be added to a project. An issue can't be created by itself, it needs to be part of a project. And the summary is basically the title of the issue. It's meant to be a short description. If those fields aren't null, we can move to the next part. Remember, each issue must be part of a project. That's what this loop is for. It's checking to see if the project entered into the AssignToProject field matches the name of one of the projects in the database. However, this isn't going to work yet, because we haven't queried the database to retrieve the projects. That will come later in the course, so for now I'll comment out the this loop and this logic. We'll just insert issues and make sure we type the project name correctly. The insertion starts the same way as the project. We get the FirebaseFirestore Instance object. Now create a DocumentReference. I'm going to write it all out, and then we'll talk about it after. So we'll get the DocumentReference, so we do db. collection, then mention the collection_projects, then document the project Id,. collection, the collection_issues, and then. document. So we're referencing the project's collection, then the projectId of the project that we're inserting the issue into, then the collection named issues, and then we tell it we're inserting a new document. As you probably guessed, we have a problem. How can we add an issue to a project if we don't know what project it is? Remember, our hierarchy goes like this, projects, projectId, issues, issueId. To create an issue in a project, we need to know the projectId, but we haven't queried the projects yet. That's going to be later in the course. So to resolve this problem until we query the database, I'm just going to hardcode a projectId. I'm copying the ID right here. Now I'll go back to Android Studio and I'll create a variable named projectId right here. Now we're ready to create the new issue object. First get the userId of the user creating the issue, FirebaseAuth. getInstance,. getCurrentUser, and then getUid. Get the ID of the issue, so final String IssueId, newIssueRef. getId. Instantiate the Issue object. Set the Assignee field. We'll set it to none since no one has been assigned to it yet. Set the description. We can get that from the description EditText field. Set the Issue_id, we can get that from the variable above. Set the Issue_type. We need to reference the spinner value for that. So reference our SpinnerAdapter class, mIssueTypeSpinner, getAdapter, and then getSelectedText. Set the Priority. Once again, we need to get a spinner value, so it's the same thing except we're referencing a different spinner. Set the issue Reporter, which is who reported the issue. That's going to be from the userId field. Set the status, so issue. setStatus, and we can reference the Issue class and do a status of IDLE. The Summary, so we get that from the Summary field. And finally, the projectId, which we hardcoded above. Since we used an onCompleteListener last time, I'll use an onSuccessListener and do an onFailureListener also. I just want to show you that it doesn't matter which way you choose to do it. In the onSuccessMethod, we want to do pretty much the same thing as with a project. Open newProjectActivity and let's copy that code. Copy the if else block inside onComplete, now go back to New IssueActivity, paste it down here, and let's take only what we need. First hide the progress bar, cut the Intent stuff, paste it below hideProgressBar. We just need to change the snackbar message to created_new_issue. Cut the snackbar message, paste the snackbar message, and change the message to failed_to_create_new_issue. Run it, and let's take a look. I'll click the plus icon in the top right. Remember, we need to make sure the project name matches exactly since we don't have the proper checks in place yet. I'll type Testing New Project, and I'm making sure the characters match exactly. We can call this a task or a bug, it doesn't matter what you choose. Write a summary, I'll write testing first issue, a description of test, select a priority, it doesn't matter what you choose, and finally click Create. There is the progress bar and the snackbar message telling us the issue was created. If you don't see the new collection in the database, refresh the browser. Sometimes you need to do that with Firestore. it's not quite like the Firebase Database. There's the new Issues collection. If I click it, we can see our new issue. Something I want you to notice before we move on is this priorityString field. Open the Issue class. Remember in the Issue class we didn't add a priorityString field, we only created a getPriorityString method, so Firestore automatically inserted that because it found a getter method. This is pretty cool. So if you ever want to save some extra fields and you don't want to actually add the fields to the class, you can just create a getter method and Firestore will automatically insert it. If for some reason you don't want that value inserted, just use the @exclude annotation.

Module Review
We started the module by building a custom object class for inserting new projects into Firestore. The class had six fields, a name, a description, a creator, a Date field called time_created, an avatar, and a project_id. By annotating a Date field with @ServerTimestamp, we enabled the ability for Firestore to automatically add a timestamp when the object is inserted. To trigger the timestamp generation, we just need to pass null to the time_created field. Next we worked on inserting the first new document. every insertion starts the same way, with the FirebaseFirestore Instance object. Next is the DocumentReference. The DocumentReference is for specifying where the new document will be inserted. After we had the reference, we instantiated the Project object and set it to the DocumentReference. We used an onCompleteListener to check for when the task was completed. Inserting a new issue is basically the same process. We started by getting the Firestore Instance object reference, instantiating the DocumentReference for telling Firestore where we'll be inserting the data. We ran into an issue getting the projectId because we haven't done any database queries yet. For now, we hardcoded the projectId. We'll come back and fix that later. Next we assigned all the field values to an issue object. We set the issue object to the DocumentReference, and finally used an onSuccessListener and onFailureListener to check for success or completion of the task.

Querying Data
Introduction
Querying data with Firestore is very similar to querying the Firebase database. Essentially, you create a reference to the document or collection you want to get, and then initiate the task and check for completion with an onCompleteListener or an onSuccessListener. My overall impression of Firestore is that it's essentially a better version of the database. There's a lot of things Firestore can do that the Firebase database can't, but there's nothing the Firebase database can do that Firestore can't. I had almost no real difficulties when first exploring Firestore, but I still remember the first time dabbling with the Firebase database. Inserting and reading lists of data was especially problematic. With Firestore collections, I had no issues with lists.

Querying Documents Within a Collection
Before we look at the code, I want to define exactly what we're trying to accomplish. Here is IssuesFragment. I'm going to click on the plus icon in the tool bar to create a new issue. If I click the Assign to project field right here, a list of projects pops up. If I start typing, the list auto-completes based on the characters that I enter. This is what we'll be implementing. It's an autoCompleteTextView populated with all the projects in Firestore. Setting this up will be a simple two-step procedure. Step 1 is querying the projects and step 2 is initializing the AutoCompleteTextView with the project names. Open NewIssueActivity. If you checked out the branch for this clip, all the code has been already added. Scroll to the method named initProjectAutoCompleteTextView. Here's where the query begins. As you probably guessed, we're going to start with getting a Firestore instance object. The purpose of this query is to get the entire contents of the Project collection. In other words, we want to get all the documents contained in the Projects collection. To get the contents of a collection, we need to use a CollectionReference. You can tell it's a CollectionReference because the last method called on the Firestore instance says collection. Once we have the reference, we can execute the query. To execute the query, we use the get method, and then add an onCompleteListener. Just like when we were inserting data, there's an if else block checking for task success. If the task is successful, we want to add the projects to our Project array list. When querying the contents of an entire collection, the listener will return a task object that's iterable. It's iterable because it's returning a list of all the documents in the collection. To retrieve each document in the collection, we need to loop through the results. That's what you see here. I'm calling getResult on the task object. That returns a list of QueryDocumentSnapshot objects which contains our documents. We can retrieve our project objects by calling document. toObject, and then referencing the Project. class. This secondary array of projects is for the AutoCompleteTextView. The ArrayAdapter takes a String array object so this makes it easier to set up. You can see here the project names are being added to the secondary array. Then they're passed to the ArrayAdapter and set to the AutoCompleteTextView widget. That completes the query and the setup of the AutoCompleteTextView. This initTextWatcher method is just to improve the user experience. It just checks to see if the user entered anything into the AutoCompleteTextView. If they didn't, or they removed the project name, it will give them an error message letting them know they need to select a project. Scroll down to the createNewIssue method. Uncomment this, now cut all this and paste it into the else section. Delete the hardcoded projectId, we don't need that anymore. Now this logic will all work properly. This loops to check to make sure the name entered in the AutoCompleteTextView is one of the project names. If it is, then we can create a new issue. If it isn't, the user will see a Toast that says select a valid project, and the AutoCompleteTextView will also show an error. Scroll down to the bottom of the file. This is the last thing I added. There is an onTouch listener attached to the AutoCompleteTextView. That way if the user touches the view suggestions will pop down. If I didn't add this, the AutoCompleteTextView would only display results if the user enters two or more characters. Run it, and let's take a look. Click the plus icon. Now I'm going to touch the AutoCompleteTextView. Great, there's our projects.

Querying Documents Within a Sub Collection
I've made a lot of code changes for this clip. I'll talk about each piece of functionality briefly before looking at the code. This is IssuesFragment. Notice the spinner at the top is now showing a selectable list of projects. If I change the selection, the list of issues is updated below. The issues aren't ordered in any particular way, it's just displaying the data retrieved from the query. If I swipe over to the Projects tab, we see a list of projects. This Searchview is also working now. If I start typing some characters, the list is filtered. Like I said, I've added a ton of code. We'll start by looking at IssuesActivity. Open it up. IssuesActivity is responsible for querying the list of projects. The list of projects is then sent to IssuesFragment to be displayed in the spinner, and then also to ProjectsFragment to be displayed in the RecyclerView. The method that retrieves the list of projects is called queryProjects. QueryProjects works the same way as the query we built in newIssuesActivity. We reference the projects collection, use the get method, and then add an onCompleteListener. If the task is successful, we loop through the results and add the projects to the Array list. To get the Project object from the queryDocument snapshot, we can use the two-object method. This project list is then sent to ProjectsFragment and IssuesFragment with the updateFragments method. Open ProjectsFragment. Remember, all that's happening in ProjectsFragment is the list of projects is being displayed in the RecyclerView, and there's a SearchView at the top for filtering the projects. Everything is pretty straightforward here. The updateProjectsList method is called from IssuesActivity, and the list of projects is set. The RecyclerView is set up using the initRecyclerView method, and the SearchView is set up using the initSearchView method. I'm not going to talk about these methods in detail. If you want more information on SearchViews or RecyclerViews, consider these resources. For RecyclerViews, a great course is Enhancing the Application Experience by Jim Wilson, on Pluralsight. And for setting up a SearchView, my course, Android Keyboard Inputs: Getting Started. The module named Providing AutoComplete Suggestions has a clip on setting up a SearchView. Open IssuesFragment. The logic in IssuesFragment starts the same way as IssuesActivity, with the updateProjectsList method. After the list of projects has been retrieved, the spinner displaying the project names is initialized with the initProjectSpinner method. The RecyclerView containing the issues is initialized with the initRecyclerView method. You probably see a problem with this. We've queried the list of projects, but what about the issues? As you can see, the IssuesRecyclerViewAdapter takes a list of issue objects, but currently there shouldn't be any issues added to the list. That's where the getIssues method comes in. If you look closely at the initProjectSpinner method, you'll see a getIssues method call in the onItemsSelected method. There's also a global project variable holding the currently selected project. That way, the getIssues method knows what project to get the issues from. Scroll down to getIssues. Here is another collection reference query. You should be very familiar with these by now. We use the same type of query to get the projects in IssuesActivity, and then also in newIssueActivity. The only difference here is we're querying a sub-collection, not a parent collection. It's called a sub-collection because there's more than one collection met call on the Firestore reference. There's the method call referencing the projects collection, and there's the method call referencing the issues collection. The selected project is used in the query to find the project document the user has selected. just like every other query we've made, we're using the get method and attaching an onCompleteListener. When the task is successful, we loop through the query documents snapshot and add the issues to our global list. After we have the issues, the IssuesRecyclerViewAdapter is notified the data set is changed, and the results become visible in the list. Run it, and let's test everything. Let's try to create a new project and see if the list is updated. Navigate to ProjectsFragment, click the plus icon. I'll give the project a name, it doesn't matter what you use here, and then a description. Now I'll click Create. It says the project was created. I'll drag downwards to trigger this SwipeRefreshLayout, and there's our project. Let's try a new issue. Go to IssuesFragment and click the plus icon. Assign it to the new project we just created. Give it a summary, give it a description, and click Create. The snackbar says a new issue was created. Make sure the correct project is selected in the spinner, and there's our new issues, so everything is working as we expect.

Sorting, Ordering, Limiting, and Paginating Queries
Cloud Firestore provides powerful query functionality for specifying which documents you want to retrieve from a collection. As you saw in the clip named Indexing Data, you can also create custom indices on multiple document fields. Because there's so many different query possibilities, I'm going to do a few simple examples and then reference the docs where you can get more information. Many of the queries aren't practical to our application, so going through some examples is probably the best way to approach this. my goal is to stimulate creativity and give you ideas of what's possible. Open IssuesActivity. Scroll to the queryProjects method. The first query method we'll look at is orderBy. OrderBy works in much the same way as the orderBy methods available in the Firebase Database. You just call the orderBy method on the query and specify the field you want to target. I'm going to order on the time_created field. Then to specify whether I want ascending or descending order, I just write Query. Direction. DESCENDING. That's it. Now the results will be ordered with the most recent at the top of the list. Open IssuesFragment. Scroll to the getIssues method. I want to order the issues based on priority, and I want the highest priority issues at the top of the list. Once again, we can use the orderBy method for this. Write orderBy and then reference the field_priority, and then Query. Direction. DESCENDING. That's it; pretty simple stuff. Open a new browser window and visit this URL. As you can see from the menu on the left, there's three major sections with respect to sorting, ordering, limiting, and paginating data: Perform Simple and Compound Queries, Order and Limit Data, Paginate Data with Query Cursors. We're currently viewing the first. Select Simple queries on the right. As its name implies, these are the simplest type of queries. You can search a collection for documents containing the fields you specify. In this example, they're searching a cities collection for a field state where it's equal to CA. Using our project as an example, we could do something like search for issues where the parity is High, Medium, or Low. Next, we have compound queries. Compound queries will require a custom index. We talked about this in the clip named Indexing Data. Remember, Firestore will automatically index individual fields in your documents, but it does not build indexes of multiple fields. If you need a refresher on how to create a custom index, make sure to re-watch that clip. Compound queries can be very useful. You can chain any number of queries together as long as you've created the custom index for it. Next is Order and Limit Data. The first example here is limiting the search query to the first three names in the cities collection. By default, it will order them alphabetically. If you want to get the last three cities in the alphabetically sorted list, you could do something like this. They're ordering on the name field, specifying descending order, and then limiting to the first three. The next example here demonstrates ordering on multiple fields in the same document. It's ordering the cities by state, and then ordering the ordered cities by population. That sounded a bit confusing. Let me give you an example. Suppose you had a collection of six cities, Albany, Chico, Aberdeen, Westport, Benson, and Floyd. Each city document contains three fields, the state, the name of the city, and the population. If we use the query in the example and sort it with respect to state, then with respect to population, this is what the result would be. First you'd see the states sorted alphabetically, you'd have California, then New York, then Washington. Then you'd see the cities ordered with respect to population within the already ordered list, so the cities form California would be ordered in ascending order like this, the cities in New York would do the same, and the cities in Washington. Next we'll look at Paginate Data with Query Cursors. This page starts with some pretty boring examples, but there's one you won't want to miss at the bottom. Start with the heading titled Add a simple cursor to a query. The example here shows a search refined using the orderBy method and the startAt or endAt methods. This type of query isn't particularly exciting. It does basically the same thing as the less than or equal to logic. The next heading isn't much more interesting. In this example, they're referencing the document named SF, and then refining the search with a secondary query using orderBy and startAt. Once again, this is just another variation of what we've already seen before. Now for Paginate a query. This is my favorite type of query refining. often when returning results from a database the list is massive. If you have a popular application, it's not out of the question to have literally millions of results returned. That's where pagination comes in. You can see here they start with an initial query of 25 cities ordered by population. When the query completes, another query is built continuing from where the last query left off. This process could theoretically continue until you've returned hundreds, thousands, or even millions of results. Of course, you would want to structure this differently. You wouldn't want to chain the queries like they're doing here. Using something like an iterative loop would work much better. This kind of pagination is really powerful stuff. If you remember anything from this clip, remember this.

Realtime Updates
Just like the Firebase Database, Firestore has Listeners for detecting when changes are written to the database. There isn't any practical examples I can apply to our Tabian Consulting project, so let's look at the examples in the documentation. Visit this URL. Like I said, this works in a very similar fashion to the EventListeners in the Firebase Database. All we need to do is create a DocumentReference or a CollectionReference, call addSnapshotListener and set an EventListener interface. Then any writes to the document or collection that's been referenced will trigger the onEvent method. Pretty simple stuff, however, there are some nuances you might want to be aware of. If your users need to know precisely when the data is written to the server, you'll need to write some custom logic. Scroll down to the heading titled Events for local changes. Here it says local writes to the app will invoke a snapshot listener immediately. That means when a user writes to the database collection or document that the listener is listening to, they'll see it triggered immediately. That's fine, but the other users relying on the data form the server will not see that data immediately. It gets added into a queue. There's a special flag for determining if the new data has been written to the server yet, or if it's still sitting in that queue. The flag is contained in the metadata for the write operation. It can be retrieved by calling getMetadata. hasPendingWrites on the snapshot. When the flag returns true, the data is officially written to the server. If you want to detect when that occurs, you'll need to add another object to the SnapshotListener. down here is an example. You need to include this constant to the SnapshotListener, a MetadataChanges. INCLUDE flag. That way when the pending write flag is changed, the Event Listener will trigger and you can let your users know that the write has officially completed. If you don't add that constant, the EventListener will not trigger when the write is officially completed. By default, it does not detect changes to that flag. The only thing you really need to watch out for when using EventListeners is detaching the listener when you're done with it. By default, if you create a listener, it will not stop listening until the application is completely closed, so if the user puts the app in the background it will continue listening. You can remove a listener by following the example here. Just create a ListenerRegistration object, probably best as a global variable in your fragment or activity, and then call the remove method when you're done with it. Calling remove in onDestroy is probably the best option.

Module Review
The first type of query we looked at was querying a document inside a collection. As you now know, every query starts the same way, by instantiating a FirebaseFirestore Instance object. Next we need to specify whether we're querying a document or a collection. If we're querying a document, then we need a DocumentReference. If we're querying a collection, then we need a CollectionReference. You can tell a CollectionReference apart from a DocumentReference by looking at the very last method call. After we have the reference, we can call the get method and attach an onCompleteListener. Inside the onCompleteListener, we can check for success using an if else block like this one. Next we looked at querying a sub-collection. The process is pretty much the same, instantiate the FirebaseFirestore Instance object, specify the collection we want to query, add some sorting options if you want, call get, attach an onCompleteListener, check for success, but here's where it differs. When querying a collection, it will return a list. Because it's a list, we need to iterate over the results. That's what this loop is for right here. Next we looked at some of the advanced query options, things like performing compound queries, ordering and limiting data, and paginating with query cursors. The clip wasn't long, and we looked at a lot of different examples. If you want a review, I suggest watching the clip named Sorting, Ordering, Limiting, and Paginating Queries. Lastly, we talked about real-time updates. Real-time updates with Firestore are very similar to real-time updates with the Firebase database. You start by getting the collection or document reference, then add an EventListener. The EventListener will trigger when any changes are made to the reference you specified. The only thing you need to watch out for is removing the listeners. The listeners will not detach themselves. To remove a listener, you need to use a ListenerRegistration object. I recommend making it a global variable in your Activity or Fragment, then calling the remove method when the view is destroyed.

Updating and Deleting Data
Introduction
Just like the Firebase database, updating data with Firestore is pretty much the same as inserting it. There's only a few subtle differences. Firestore has an update method that you can use on a DocumentReference. For example, suppose we wanted to update a single project. We'd get the DocumentReference, then call the update method and specify the fields we wanted to update. Other than that, you can also just use the set method like we did when first inserting data. Deleting data is a straightforward process. For example, if we wanted to delete a project document it would look something like this. Create a DocumentReference to the project, call the delete method, and then attach an onCompleteListener.

Updating a Document
I've added a new activity to the source code files. Open ProjectDetailsActivity. You can get to ProjectDetailsActivity by selecting any of the projects from the list. I'll select this one. This is the activity where we can make changes to a project. Right now we'll work on updating the project name and the description. Later in the course, we'll work on updating the project avatar. When the activity is created, it retrieves the selected project from an intent extra in the getSelectedProject method. The ProjectDetails are set to the widgets using the setProjectDetails method. If you scroll all the way to the bottom of the file, there's a method named updateProject. UpdateProject is called when the Save button is clicked at the bottom of the screen. Like always, we start by getting the Firestore object instance. But there's something you haven't seen before. There are several ways you can update data. In this example, I'm using a HashMap to update the fields that I want. I want to update the Name field and the Description field, so that's what you see as the keys in the HashMap. Then, of course, the values are retrieved from the TextFields. The rest is pretty straightforward, you reference the document you want to edit, and then call the update method and pass the updates. Like always, we use an onCompleteListener and let the user know if the updates were successful. Run it, and let's take a look. Select a project, edit the name, edit the description, and now click Save. As you can see, the updates were written to the database.

Overwriting a Document
Another way to update documents is to completely overwrite them. This is actually my preferred method. If you don't want to change some of the fields, you just input the same fields back. I've made a lot of code changes. Open IssueDetailsActivity. You can get to IssueDetailsActivity by selecting any of the issues from the list. I'll select this one. This is the activity where we can make changes to an issue. As you can see, issues have a ton of fields to update, and later there's going to be even more because we'll be able to upload attachments. Let's take a look at the code. IssueDetailsActivity starts out very similar to ProjectDetailsActivity. The selected issue is retrieved from an intent extra with a getIssue method. If the issue is retrieved, getIssue returns true, therefore the rest of the Activity methods will execute in onCreate. These methods are named very intuitively, so they'll likely do exactly what you assume. SetupActionBar sets up the widgets in the ActionBar, initIssueTypeSpinner initializes the IssueTypeSpinner, initPrioritySpinner initializes the spinner containing the priority options, initStatusSpinner initializes the spinner with the three available status options, getEmployeeList queries the Firebase database for the list of all the Tabian Consulting employees. For more information on how that works, make sure to watch my Firebase Database and Cloud Storage course on Pluralsight. It's number 2 in the Firebase on Android series. And finally, the setIssueDetails method sets all the issue properties to the widgets in the activity. Scroll down to the SaveChanges method. This is the method that's executed when the user clicks the Save button at the bottom of the activity. As usual, we start by making sure the required fields are filled out. In this case, that's just the Summary field. If the Summary field isn't blank, then we can move on to updating the data. As always, we want to start with a FirebaseFirestore object instance. Next we need the DocumentReference for the issue we're updating. There's nothing special here. This should all be review to you. Here's where you'll need to be careful. We're instantiating a new Issue object and setting the fields, but you need to watch out for the fields that shouldn't be changed. For example, we want to update the issue, but the Time_reported field should never be changed. That field is only set when the issue is first created, and if you pass null it will update because the @ServerTimestamp annotation in the issue class. So down here when we set the Time_reported, it's very important to do the same timestamp that was there before. The same thing goes for the Issue_id, the Reporter, and the Project_id. Those fields should not change. That's why we're getting them from the original issue object. After that, we're ready to set the document and listen for completion. So as you can see, this is pretty much the exact same process as inserting new data, we just need to watch out for updating fields that shouldn't be updated. Run it, and let's test. Select an issue from the list. Now let's change some fields. Change the Status, change the Summary, change the Description. We can't add attachments yet, that'll be later in the course. Change the Priority, change the Issue Type, and we'll assign it to a user. Now I'll save the changes. If you were watching Firestore in the background, the document was updated almost instantly, and if I select the same issue from the list, we can now see the changes.

Deleting a Document
I've changed a lot of code for this clip. Let's quickly go over the changes. Here we are in IssuesFragment. I built a custom class that implements the ActionMode. Callback interface. The ActionMode. Callback interface is going to allow us to change the toolbar when a specific event is triggered. The event that will trigger it is a long press on the RecyclerView list items. Let me demonstrate. If I hold my finger on a list item, it highlights. Once a list item is highlighted, the ActionMode variable is no longer null. While the ActionMode variable is no longer null, any list items I select will also be highlighted. To exit this mode, I can either click the list items that are selected, or I can press this back arrow. Let's look at the code. Open IssuesFragment. I don't want to talk too much about the technical details of implementing something like this because it doesn't technically pertain to Firestore, but I think it's worth giving you a general overview. At the bottom of the file is a class that implements the ActionMode. Callback interface. A class that implements the ActionMode. Callback interface can be used to alter the toolbar and inflate a custom one temporarily. The onCreateActionMode method inflates the toolbar using the menu specified here. You can find the menu in the menu folder. OnActionItemClicked is triggered when a widget in the toolbar is clicked. We only have a single option, the trash can icon that you saw in the top right. If the trash can icon is clicked, this logic is executed. The onDestroyActionMode method is called when the back arrow is pressed or when finish is called on the ActionMode, which is what you see here. The ActionMode. Callback object is instantiated when onLongPress is detected on the list items. Open IssuesRecyclerViewAdapter. If you take a look at the ViewHolder, you can see I've implemented the onlongClickListener interface and attached it to the view. If it's triggered, another interface relays the message back to IssuesFragment right here. The highlighted list items are recorded using the SelectableAdapter class. Open it up. This class holds a SparseBooleanArray. Each position in the array is either true or false. If it's true, that means the list item corresponding to that position in the array is highlighted. If it's false, it's not highlighted. Go back to IssuesRecyclerViewAdapter. If you scroll up to the top, you'll notice it extends SelectableAdapter instead of RecyclerView. Adapter. Now that gives us access to the methods in the SelectableAdapter class. If you take a second look at SelectableAdapter, you can see it extends RecyclerView. Adapter, so we can still use all the same methods in our RecyclerView. Adapter class. Go back to IssuesFragment. I'm guessing some of you are very confused. I don't want to spend too much time explaining this in detail, I need to stay on topic with Firestore, but I think this functionality is really cool, so hopefully you can use it in your other projects. Now let's delete a document. Scroll to the method named deleteSelectedIssues. Here's where the delete occurs. I want to mention another caveat before moving forward. In the clip named deleting multiple documents with batched writes, we'll be deleting multiple issues and multiple projects using the list items selected from the ActionMode. Callback, but in this video we're going to start by deleting a single document. Just keep that in mind. I wanted to mention that, because it's going to seem a little silly when we can select a bunch of issues from the list, but only delete a single one. Don't worry, it will all come together in the next clip. To find the issue that's been selected, we need to loop through the issues in the list. We can check for a match using the isSelected method from the SelectableAdapter class. That will return true if that list item is selected. Remember, the IssuesRecyclerViewAdapter class contains this list of issues, so the list item positions are identical. Now that we know what issue to delete, let's delete it. This index variable is final, because we use it down here in onComplete. To delete a document, you get the DocumentReference. Then just call delete. It's that simple. After the document is deleted, we remove it from the list and let the adapter know the DataSet has changed. Scroll down to the bottom of the file. DeleteSelectedIssues is being called down here. When the user clicks the trash icon in the ActionMode. Callback toolbar, an alert dialog will pop up asking them to confirm their choice. If they click yes, the issue is deleted. Run it, and let's test. Here we are in IssuesFragment. I'm going to hold my finger down on this issue, and now I'm going to click the trash icon. As you can see, the issue was removed from the list and also from Firestore. I want to reiterate. What we just did doesn't really make sense. We should be able to delete multiple issues by selecting them using the ActionMode. Callback. We're going to finish implementing that functionality in the next clip using batched writes.

Deleting Multiple Documents with Batched Writes
If you ever need to set, update, or delete multiple documents at once, using a batched write is probably the best way to do it. We're going to use a batched write to delete all issues selected in IssuesFragment. We're also going to do it to delete projects. The projects will be a little trickier since every project can potentially have issues. That means if we want to delete a project we need to find the issues in that project, delete the issues in that project, and then delete the project. Later in the course, we'll see this gets even more complex with attachments. We'll talk more about that later. Open IssuesFragment. We're going to start by altering the deleteSelectedIssues method. If you recall from the previous clip, we currently only delete a single issue. We need to update this method so it will delete every issue that has been selected by the user. Start by instantiating a WriteBatch object. This is the object we can use to execute multiple write operations at once. Instantiate a new ArrayList named deletedIssues, remove the index variable. Now instead of doing the delete right here, I'm going to delete this code and replace it with batch. delete, and then pass the reference. That's going to add the delete operation to our WriteBatch. Now add the issue to the secondary array list. Once the loop is complete, remove all the deleted issues from the master list. Notify the adapter that the master list has changed, and call the method executeBatchCommit. Scroll to the executeBatchCommit method. To officially commit the batch writes, you need to call commit. Then, as always, we can listen for completion using an onCompleteListener. That will delete every issue selected. Before we move forward, let's test it. Now I'll select all the issues I want to delete and I'll press the trash can icon. That looks good, it looks like they were removed. If I check for them in Firestore, they're gone. The next thing we need to work on is deleting projects. Open ProjectsFragment. As I stated in the beginning of the clip, deleting projects is going to be a little trickier. scroll down to the ActionMode. Callback class. As you can see, the method that starts the whole process is called deleteSelectedProjects. Scroll to deleteSelectedProjects. Just like in IssuesFragment, we start by finding all the projects that were selected by the user. They're saved in this local ArrayList named deletedIssues. Once we what projects have been selected for deletion, we can remove them from the master list and notify the adapter. This loop will loop through the selected projects and query the issues associated with it. The issues are saved in this ArrayList. Once they're collected, we send them to IssuesFragment via this interface method. It sends the issues associated with the project in question, and then the project itself. Open IssuesActivity. At the bottom of the file is the interface method. It sends the project and the issues associated with the project to IssuesFragment. I didn't need to do this, but I wanted to reuse code where I could, and the list of issues needs to be updated when the deletes are complete anyway. Open IssuesFragment, and let's take a look at this method. Scroll to deleteIssuesFromProject. First we remove the issues from the master list and notify the adapter. Next we instantiate the WriteBatch object and loop through the issues. Each delete is added to the batch. Once all the issues are added to the batch, the executeBatchCommit method commits the writes and listens for completion. At this point, we can delete the project. I want to point out that we could have just deleted the project and the issues would have been eventually cleaned up by the database, however, later in the course the issues will have attachments associated with them. The attachments will be images, and the images will be saved in Firebase storage, so we can't just delete the project without first finding the attachments and removing them from storage. If we deleted the project without getting the address to the image in storage, it would just sit there doing nothing, and storage space isn't free.

Transactions
A common complaint about the Firebase database is that there's no way to return data from insertions, deletes or queries. Transactions are an answer to that. You can go about your regular process of inserting data, deleting data or querying data, but you can get a result returned. The whole process is pretty straightforward. Let's walk through the example the Firebase team has provided in the documentation. Visit this URL. Like every query, we start by instantiating the DocumentReference, but here's where it gets a little different. Instead of calling the get method and attaching an onCompleteListener like we usually do, you call the runTransaction method. Then create a new Transaction. Function. This data type you specify here can be anything as long as it's not a primitive data type, so things like integer, object, string, double, and so on. The function returns a transaction object. We can get the data snapshot from the transaction object. Then you can go about getting the field or objects you wanted to from the query. In this example, they get the population, check if it's less than or equal to 1 million, and then update it and return the updated population. If the population is too high, it throws an exception. I love how the Firebase team actually listens to the developer community. I actually submitted a request for this exact feature late in 2017. I don't know if it was my specific request that got this implemented, but it feels good do know they're listening anyway.

Module Review
We started the module by updating data in Firestore. There are several ways to update data. The first method we talked about was using a HashMap to set individual fields in a document. In general, updating data isn't much different than inserting new data. It's basically the same process. Updating data is essentially just inserting new data on top of old data. When using a HashMap, you can set the key value pairs of the fields you're interested in. To submit the updates, I'm using the update method on the DocumentReference. Then, like we always do, set the onCompleteListener and listen for completion. The second method we used for updating data was setting it. This is exactly the same process as writing new data to the database. However, there is one thing you need to watch out for. Consider this example. If we wanted to update an issue document, you'd start by getting the FirebaseFirestore instance and the DocumentReference. This is nothing we hadn't seen before. Now we instantiate a new issue object and set the properties. This is also nothing we hadn't seen before. The thing to watch out for here is the properties that should not be changed, things like the Issue_id, the Reporter, the Project_id and the Time_reported. All those fields should never be changed. Compared to your other projects, this is obviously going to vary. The key point to take away here is make sure you don't update fields that shouldn't be updated. After the updated issue object properties are set, we call the set method and listen for completion. Next we worked on deleting data. When a user selects issues from the list, they highlight. Then if they press the trash can icon the issues are added to the WriteBatch and deleted. To instantiate a WriteBatch object, you call the batch method on the Firestore instance. To add the deletes to the batch, you just call delete and specify the DocumentReference. To execute the WriteBatch, you need to call commit on the WriteBatch object. Then listen for completion using an onCompleteListener.

Updating, Querying, and Deleting Images
Introduction
This module was meant to serve as a sort of coming together section for the course. We're going to use everything we learned in the other modules. We'll be writing new data to Firestore, reading data, updating data, and deleting data. To keep things interesting, we'll also be introducing something new. We're going to upload images to Firebase Storage and save pointers to the images in Firestore. I'll also show you how to remove images from Firebase Storage. The images will be attached to the issues, and the issues can be deleted so we need to be able to remove them from storage. Here's a demo of what we'll be implementing. Each issue will have the ability to store attachments. Remember this Add attachment TextView? Before this module it didn't do anything. Now if I click it I'm prompted with a dialog asking if I want to upload an image from storage or take a new one with the phone's camera. Let's chose one from storage. I'm just going to choose something at random. As soon as the image is selected, the upload task begins. While the image is being uploaded, a temporary image is displayed in the ImageView, but once the image upload is complete, the ImageView displays the image from Firebase. If you watch closely, you can tell when the image finishes uploading. The ImageView will flash an image of an Android for about half a second. I'll upload another image so you can see. Now watch the ImageView closely after I select the image. There it is. The Android flashed briefly when the image was done uploading. That was the resource switching places with the temporary image. If I click on the attachments, they're inflated to a full screen view. This ImageView is draggable and scalable. Removing the attachments is very similar to how we selected issues and projects for deletion. If I hold my finger on an attachment, it eventually highlights. You'll also notice a trash can icon appearing below. If I click any other attachments while I have this one highlighted, they'll also highlight. If I click them again, the highlight is removed. If I click the trash can, the images that I selected will be deleted from storage and removed from the issue. You'll also have the ability to set an image to a project. If I navigate to a project, I can select the avatar by clicking here. This is the same process as we just looked at. The user can select an image from memory, or take a new one with the phone's camera.

Selecting an Image to Upload
The process of uploading an image and displaying it starts with first selecting which images you want to upload. Open ChangePhotoDialog. If you watched the entire Firebase on Android series, you should already be familiar with how to do this, but I've made some changes to my old code, so I think it's worth going over again. This is the dialog you see when you click on the Add attachment TextView. It prompts the user to either select an image from storage, or take a new one with the phone's camera. The most important part of this class is seeing what happens with the image URI once the image is selected. Notice this onPhotoReceivedListener interface I've defined at the top. This is the interface we'll be using to send the image URI to the fragment or activity we want to use it in. If you scroll down to the onActivityResult method, you see the interface sending the image URI. There's two cases. This one is for an image selected from memory and this one is for an image taken with the phone's camera. That's really all you need to know about this class. Open IssueDetailsActivity. Scroll to the onClick method. The add_attachment case is for inflating the dialog. First we check to make sure the storage permissions have been accepted. IF they have, ChangePhotoDialog is inflated. If they haven't, then we ask the user. Scroll up to the top. Notice I've implemented the onPhotoReceivedListener interface from the ChangePhotoDialog class. Scroll down to the bottom. The getImagePath override method is the one associated with that interface, so when an image resource is available it'll get sent here. This is where we'll want to initiate the image upload process.

Uploading an Image and Saving as a Document
Open IssueDetailsActivity. Scroll to the getImagePath method. As I stated in the previous clip, the attachment upload process is initiated once an image resource is available. We know an image resource is available by checking for null here. I built a separate class for handling all the image uploading. It's called IssuesPhotoUploader. Open it up, and let's go through it. The constructor takes four arguments, the context, the projectId, the issueId, and an AttachmentUploadCallback interface object. That interface is at the top of this file. It's for communicating with the activity or fragment that starts the upload process. When the upload is complete, the callback is notified, which then notifies the activity or fragment. The upload process is started with the uploadAttachment method, or the uploadNewPhoto method. The uploadAttachment method is for uploading attachments, and the uploadNewPhoto method is for uploading a new project avatar. The only reason there's two different methods is because the attachments and the avatars are saved in different locations in Firebase storage. There's only one project avatar, but there can theoretically be infinite attachments, so the naming conventions are different. I'll show you what I mean shortly. Just notice the uploadAttachment method is setting a Boolean named IsUploadingAttachments to true. It also sets a URI object variable that we'll need later. I'll explain that later also. After that, it just calls uploadNewPhoto. UploadNewPhoto starts a background process for converting the image resource to a ByteArray. This is done on a background thread because it's known to slow the UI thread. Once the resource is converted to a ByteArray, the ByteArray is set to a global variable named mBytes. Then the executeUploadTask method is called. ExecuteUploadTask does exactly what it sounds like, starts the upload process. I'm not going to review this method in detail since I covered it in my course named Firebase on Android: Realtime Database and Cloud Storage, but I'll point out the important parts. Remember that Boolean named mIsUploadingAttachments? Here's where we use it to set the Firebase storage path. The project avatar is simple. The same image is overwritten so the name is the same, but the names of the attachments need to be different. We're using a timestamp to create the name. That guarantees the names will be different for each image. Once we have the image name, we can start the upload. Once the upload task is complete, there's two options. Once again, we're using the isUploadingAttachments variable to check if the image is an avatar or an attachment. If it's an attachment, the method setNewIssueAttachment is called. If it's an avatar, the method updateProjectAvatar is called. Scroll down to setNewIssueAttachment. This method inserts a new attachment document into the issue. As you can see, the DocumentReference is pointing to the attachments collection within the issued document. A new attachment object is instantiated and set to the reference. When the task is complete, we let IssueDetailsActivity know by calling updateImageUrl on the AttachmentUploadCallback interface. UpdateProjectAvatar has nothing we haven't seen before. There's a HashMap containing a single field, the avatar field. Open IssueDetailsActivity. Scroll to the updateImageUrl method. Here's where the callback sends the downloadUrl and localImagePath of the original image. We need to send the localImagePath and downloadUrl because we need to replace the image resource from memory with the image resource from Firebase storage. We'll talk more about that in the next clip. For now, let's just test the upload process and make sure the images are being uploaded to Firebase storage, and also the pointers are being inserted into Firestore. Run it, and let's take a look. Right now I have two tabs open, one with Firestore and one with Firebase Storage. In Firebase Storage, the images will be saved in the images folder. The attachments will be saved in the issues folder. Each issue will have its own folder denoted by the issue ID. Inside the folder denoted by the issue ID will be the attachments associated with that issue. The projects folder is similar. inside here you'll find folders denoted by the project IDs, then inside you'll find a single image named project_avatar. They should never have more than one image in here since the avatars are just overwritten when it's changed. We'll test the avatar first. Make note of this image, we're going to change it. I'll click the avatar, select an image from memory, I'll just choose this one. Now I'll click Save. That's going to start the upload process. I'll press back and keep refreshing until I see the change. There's the new image. We could check Firebase Storage and Firestore but I know it worked because I can see the new image here. Next let's upload some attachments. Select an issue, click on Add attachment. I'll choose one from memory, this one is fine. Now let's check Firestore. Find the issue we're looking at. Now there should be a new collection named attachments. Click it. There's the new attachments. There's two because I did some preliminary testing before I filmed the video. Now let's check Firebase Storage. Navigate to the issues folder, select the issue ID we were working with, and there's our two images The next thing we need to work on is querying the images from Firestore and displaying them in a horizontal RecyclerView like I demonstrated in the introduction.

Querying Images Saved in Firestore
I've added a ton of code in this clip. Make sure to check out the correct branch. Since there's been so many code changes, I want to quickly go over the new classes I added. The first is the ScalingImageView class. Open it up. This is actually a class from another one of my courses. It's named Android Gestures: Getting Started. It's available on Pluralsight. The class extends ImageView, but it's no ordinary ImageView, it's scalable and draggable. Let me demonstrate. As you can see, I have some attachments on the issue. If I click them, a new fragment is inflated. The fragment only contains a single widget, the ScalingImageView widget. As you can see, I can zoom in on the image and drag it around. I can also zoom out. That's what this class does. If you want a detailed walk-through of how I built it, check out my course named Android Gestures: Getting Started. The next class is FullScreenImageFragment. This is the Fragment that I demonstrated. It contains the ScalingImageView widget. The only code in this class is for setting the image to occupy the entire screen and showing a progress bar while the image is loading. Next is HorizontalSpacingItemDecorator. This ItemDecorator is responsible for adding the spacing between these RecyclerView ListItems. The last class I've added for this clip is AttachmentRecyclerViewAdapter. Open it up. As you probably guessed, this is the RecyclerViewAdapter class responsible for setting the attachments in IssueDetailsActivity. Everything is pretty standard in here except the IsAttachmentSelected interface. Also notice I'm extending by SelectableAdapter like we did in the other adapters. If you scroll down to the ViewHolder, you can see it in action. The process is similar to what we did in the RecyclerView containing all the issues and the RecyclerView containing all the projects. I need to make the list items selectable. That way a user can select attachments for removing. This ViewHolder works a little different than what we did with the other adapters. It uses a view and overlays it to make the list item look like it's highlighted. We had to add this extra view because the images occupy the entire ListItem view. If we did the same thing as in the other adapter classes, the list items wouldn't appear highlighted. You can see the visibility of the overlay view being set in the onBindViewHolder method. We check to see if it's selected, and if it is, then the Overlay view becomes visible, making the list item appear to be highlighted. Open IssueDetailsActivity. Scroll to the isSelected method. This is the interface method from the AttachmentRecyclerViewAdapter class. Go back and take a look. When one or more item is selected, the isSelected Boolean is set to true. Go back to IssueDetailsActivity. If the isSelected Boolean is true, then we can enter something I like to call AttachmentMode. AttachmentMode is defined down here with these two methods. What does it mean to be in AttachmentMode? If the activity is in what I like to call AttachmentMode, then the trash icon becomes visible. If it's not, then the trash icon is hidden from view. Now let's look at the attachments query. Scroll down to the method named getAttachments. There isn't anything special here. Everything in this method should be review to you. We want to get all the attachment documents in the attachment collection for this issue. Here we have the CollectionReference. We're sorting the query with respect to the timestamp. The oldest attachment is displayed first. Each attachment document is added to the attachments ArrayList. When a new attachment is added, it's detected by the AttachmentUploadCallback interface. Its override method is named updateImageUrl. Scroll down to it. Remember this method? It's called when the new attachment is finished uploading. Since the image is done uploading to the server, it's removed from the attachments list and a new downloadUrl is added in its place. That's going to ensure the app doesn't crash if the user tries to delete the attachment. That's not going to make sense now, but it will later when we implement the delete functionality. I'm guessing some of you are confused by that. Let me explain a little better using visuals. When I select an image from storage, the image is added to the attachments array in the getImagePath method right here, so the image being displayed is actually an image from the phone's memory. If I tried to delete that attachment, the pointer would reference the image in the phone's memory. I don't think I need to tell you that that would cause problems. I don't want to delete it from the phone's memory, I want to delete it from Firebase Storage and Firestore. That's why here in the updateImageUrl method we need replace the URL with the imageDownloadUrl. That way if the user tries to delete the image it will be removed from Firebase. Run the app, and let's test it out. Select any issue, and let's upload some attachments. I'm going to upload a bunch really quickly and make sure it can handle multiple uploads at a time. There's the first one, and the second, the third, and we'll do one more. It looks like it had no issues. Now I'll hold my finger down on one of them, that's the Overlay view showing. Now I'll click a few other images, so that works. Now I'll unselect them by clicking them again. That all seems to be working exactly as expected. Next we'll work on deleting the attachments.

Deleting Images Saved in Firestore
Deleting attachments is not going to be a simple process. The reason it's going to be difficult is because we have so many different scenarios. Scenario one is deleting attachments from IssueDetailsActivity. Scenario two is deleting an issue. This becomes more complicated than before because now we have attachments in the issues. So we need to find the images in storage, delete them, find the attachments in Firestore, delete them, then delete the issue. Not a simple process. As you probably guessed, deleting a project is going to be the most complicated. You need to find the issues in the project, find the attachments in the issues, delete the attachments, delete the issues, then delete the project. Of course, some of the code can be reused, but there's still a lot of it. We'll start with scenario one, deleting attachments in IssueDetailsActivity. Open IssueDetailsActivity. Scroll down to the method named RemoveAttachments. This is where it all starts. When the user clicks the trash can icon, this is the method that's executed. We start by getting a list of the selected attachments from the RecyclerViewAdapter. Next we iterate through the attachments. Notice the list doesn't actually contain attachment objects, it contains a list of integers. The integers represent the position of the attachment objects in the attachment list, so it's basically the same as having actual attachments. The first check here is for making sure the user isn't trying to delete an attachment that hasn't finished uploading yet. That would cause a crash. This bit of code is for extracting the filename from the downloadUrl. If that confuses you, consider this. I have an attachment document selected here in Firestore. The downloadUrls look like this. In order to delete it from storage, I need the storage path, and to reference the storage path I basically only need the filename. That's why we need to extract the filename from the downloadUrl. I know what you're thinking. You're thinking, but Mitch, the image name is right there, and you're right, it is, but if you go back to Android Studio I'll I'll show you why that's not useful. Look at the variable named url. It's retrieved from the attachment ArrayList. The attachment ArrayList only contains image URLs, not actual attachment objects, so we can't get the image name, but that's okay. Extracting the image name is simple. Now that we have the image name, we can use it to query Firestore for the actual attachment object, which is what you see here. We don't actually need the entire attachment object, we just need its id. Its id, the downloadUrl, and the filename are all passed to a method named deleteAttachmentDocument. DeleteAttachmentDocument does exactly what it sounds like. It deletes the attachment document from Firestore. When that's complete, the attachmentFileName is passed to a method named deleteAttachmentFromStorage, and yes, that method does exactly what you think it does also. It deletes the attachment from storage. After that, the attachment is removed from the list, and the adapter is notified. That's basically the whole process. Scroll back up to RemoveAttachments. Remember, this loop will go through all the selected attachments and repeat the process we just went through. I'll do a short demonstration just to show you what it looks like. You don't have to run the app on your end if you don't want to, just watch me. Here I am in IssueDetailsActivity. I have some attachments down here, and I'm going to delete them. I'll select them all, and now I'll press the trash can icon. It looks like they were removed. I'm going to press back and visit the issue again to refresh the view. and they're gone. That was scenario one, the easiest of the three. Now let's work on scenario two, deleting issues from IssuesFragment. So when I select an issue from here and I press the trash can icon, the attachments in that issue will be deleted, and then the issue will be deleted. Let's work on that. Open IssuesFragment. Scroll to the method named deleteSelectedIssues. Remember, this is the method that's executed when the trash can icon is clicked. I've added a bunch of new methods to this class. Currently, the way it is, it doesn't delete any attachments so we need to change a few things. Delete these three lines of code. Now write deleteAttachments, pass the deletedAttachments, pass the batch, and pass null. We're passing null for the project object, because we don't want to delete the project, just the issue. Remember when I told you we were going to reuse some code? That's why there's an option to pass a project here. We're going to use that for scenario three. Let's walk through delete attachments. First the issues that I've selected are removed from the issues list. That way the user thinks they're gone immediately. Then we loop through the issues we want to delete. This query is for retrieving the attachments in the issue. We're doing basically the same thing as in IssueDetailsActivity. We get the attachments, extract the filename and the id, and then call a method for deleting it. That method is deleteAttachmentDocument. Scroll down to deleteAttachmentDocument. As you can see, this is the same thing as IssueDetailsActivity. We delete the attachment from Firestore, then delete the image from storage. Nothing new here. Scroll back up a bit. This if statement is making sure all the attachments are deleted before deleting the actual issue. Inside that if statement is another if statement. It's for reusing code. This case is for deleting a project, which we'll look at in a moment. And this case is for deleting an issue, which is what we're doing right now. You're already familiar with the executeBatchCommit method. That's going to officially delete the issues that were selected, since by this time all the attachments have been removed. This else statement at the bottom is for deleting a project. Like I said, we'll look at that next. That's the end of scenario two. Once again, I'll do a demonstration. Here I am in IssuesFragment. Notice if I select an issue there's attachments. I just wanted to point those out. Those attachments are being stored in a directory that I have showing here. Now I'll go back. I'll select a couple issues, and I'll press the trash can icon. Now when I refresh the storage directory we should see that the attachments have been removed. They're gone. If I refresh IssuesFragment, the issues are also gone, so that's all working. Now for scenario three. This is the most complicated, but we're going to reuse some code so it won't be that bad. Open ProjectsFragment. Scroll to the deleteSelectedProjects method. This is the method that's executed when the trash icon is clicked. The only thing I've added to this class is the deleteProjectAvatarFromStorage method. It's right down here. As its name implies, that's going to delete the ProjectAvatar from storage. Nothing special here. Let's examine the deleteIssuesFromProject method for this interface. It's being implemented in IssuesActivity. Open it up. This is what we need to change. Currently this method is executed in IssuesFragment. Al it does is delete the issues associated with the project, and then delete the project. Obviously that's not going to work because we have attachments to worry about now. Lucky for us, we can reuse some of the other code. Change this method to deleteAttachments. Pass null for the WriteBatch object. Now go to IssuesFragment, and let's walk through the logic. Scroll to the deleteAttachments method. Now that we've changed the interface, this method is going to be called when a project is deleted. Keep in mind that Project object isn't going to be null when deleting a project, but the WriteBatch variable is. If we follow the logic, the differences come down here. If the batch is null, then the deleteIssuesFromProject method is called instead of the executeBatchCommit method. Scroll to deleteIssuesFromProject. This method is responsible for adding the Issue Document deletes to a WriteBatch. Once they're all added to the batch, the executeBatchCommit method is called and the documents are deleted. Then the project is deleted right after that. Scroll back up to the deleteAttachments method. That's pretty much it. The only other thing is this else statement down here. This is going to run if there's no issues in a project. If you scroll up a bit, you can see the if part. It says if deletedIssues is greater than 0. So this else is for deleting a project that has no issues, and therefore no attachments. And that's it for scenario three. I'm going to run it and test it out. I've created a new project here. If I go to IssuesFragment, you can see the project has some issues in it. The text is all just random since I'm going to be deleting them anyway. Each of these issues contains attachments. I'll quickly show you. Notice that one has attachments, that one has attachments, and that one has attachments. Also notice in the background I have the directory showing in Firebase storage that contain the attachments. Now I'm going to delete the project. I'll highlight it and click the trash can icon. If I refresh ProjectsFragment, you can see the project is gone. If I go to IssuesFragment, you can see the project is no longer in the spinner. Let's take a look at Firebase Storage. If I refresh the page, all the directories are gone. I know that was a lot to take in. I could have easily just showed you some simple delete queries, but I don't think that would have been very useful. You learn the most when you're able to see actual practical examples of how to apply concepts.

Module Review
Since there was so much code in this module, I think the most efficient way to review it will be to go through the processes and describe what's happening in the background. Let's start with uploading an attachment. Attachments can only be uploaded from IssueDetailsActivity. Once storage permissions are accepted, the user can click the Add attachment TextView and they'll be prompted to choose an image from memory or take a new one with the phone's camera. As soon as the image is selected, the upload task begins. Once the upload task starts, there's no way to cancel it. I can exit the activity or even move the app to the background, the task will still complete. If I click an attachment, the image is inflated to a full screen view. This ImageView is scalable and draggable. Remember, if you want more information on how to build an ImageView class just like this, watch my Pluralsight course named Android Gestures: Getting Started. I'm going to add a few more attachments so I can demonstrate how to remove them. Just a few should be fine. That should be good. Users can select the images by holding their finger down on the screen for longer than about 500 milliseconds. Once an image has been highlighted, more can be highlighted just by clicking them. A trash can icon also becomes visible. If I click the trash can icon, all the selected attachments are deleted from Firebase Storage, and from Firestore. I'm going to add some more attachments, because next we'll review the issue deletion process. We can delete issues from IssuesFragment. This is similar to deleting attachments. If I hold my finger down for more than 500 milliseconds, the ListView item will be highlighted. After one has been highlighted, I can select more by clicking them. To start the deletion process, I just click the trash can icon in the toolbar. First the application will search for any attachments in the issues and delete them. Once the attachments have been removed, the issue document is removed from Firestore. Deleting a project is the most complicated. It's the most complicated because when we delete a project we need to delete all the issues in that project, and if we delete all the issues in that project we need to delete the attachments in those issues. If we weren't saving images, this would be a straightforward process, but storing images occupies a lot of memory, and memory costs money, so we need to make sure the images are removed from Firebase Storage if the attachment document is deleted. Projects can be deleted from ProjectsFragment. For the user, this is exactly the same process as deleting issues. I just hold my finger on a list item for more than 500 milliseconds, and it highlights. After it's highlighted, I can select more projects just by clicking on them. To delete a project, I just click the trash can icon in the top toolbar. First the application finds the issues associated with the project, then it finds the attachments associated with the issues, it deletes the images from storage, deletes the attachment documents, deletes the issue documents, and finally deletes the project document. If you want to review the technicalities involved in all these processes, I suggest re-watching the module. There was a lot of small details to watch out for.

Tying It All Together
Review: Integrating Cloud Firestore
In the first part of the course, we worked on integrating Cloud Firestore to the Tabian Consulting application. It was composed of four major topics, adding the Firestore dependency, security rules, indexing data, and limitations. In Adding the Firestore Dependency, we added the Firestore dependency to the build. gradle app file. We're using version 12. Version 15 is technically the newest version as of today, but I was experiencing some issues with it so I stuck with 12. With the Firebase Database, you can specify unique security rules for each individual node. Firestore security rules function in a similar fashion, but with Firestore you use something called match statements. Learning to master match statements can help you save a ton of client-side code. It's really an open canvas in terms of what's possible. We looked at several examples in the clip named Security Rules. If you need a review, I suggest re-watching that clip or take a look at the security rules section of the documentation. There's some really excellent examples in there. Next we talked about indexing data. Creating an index of a database is one of the most widely used methods to speed up database queries, and as you know, Firestore automatically indexes your data. However, by default Firestore will only index individual fields, it will not create indexes on multiple fields. What does that mean for you? It means you can make queries that specify conditions for more than one field at a time. For example, suppose you were querying a collection named cities. You wanted to find all the cities within a state called California, and those cities had to have a population less than or equal to 10, 000. The query might look something like this. By default, this query would fail because you're specifying more than one condition. Condition one is the state must equal California, and condition two is the population must be less than or equal to 10, 000. There's two fields in that query, and if there's more than one field you need a custom index. Fortunately for us, creating a custom index on those fields is incredibly simple. First you navigate to the Firestore section of the console, select the Indexes tab, click the Add index button, reference the collection. In our example, the collection will be called cities. Specify the first field, which is state. It doesn't matter whether you select ascending or descending order, just make sure your queries match what you choose. Specify the second field, which is population, and then click Create Index. creating an index might take a few minutes. Once it's done, you'll be able to make complex queries like this one on the state and population fields. The last thing we talked about was limitations. In terms of limitations, Firestore doesn't have many. It's an excellent product, and a huge step up from the Firebase Database. However, as you know, there's no way to do a full-text search. I think having a full-text search is a very important feature. I'm really surprised they improved so many other search functions, but they still haven't added a full-text search. I guess maybe they're holding out for later releases. Yeah, we'll go with that.

Review: Inserting and Managing Data
In the module named Inserting and Managing Data, we created our first documents and inserted them into Firestore. The module was broken down into three major topics: inserting custom objects, inserting documents, and adding a collection to a document. In the first part, we started by building the first custom object class and inserting it into Firestore. If you're familiar with the Firebase Database, which I expect most of you are, you probably found this very familiar. It's basically the same, but Firestore has a few added features. For example, the ServerTimestamp annotation. When we add the ServerTimestamp annotation to a Date field, the timestamp is automatically inserted whenever a document is written to the database and the field is null. This is a wonderful thing. I don't have to worry about inserting a timestamp anymore, Firebase does it for me. Keep in mind that Parcelable implementation is not required to insert custom objects, that's just for packaging objects into bundles. In the next part, we worked on actually inserting our first document. Inserting a document always starts the same way, by instantiating a FirebaseFirestore Instance object. Next we need to specify the DocumentReference or the CollectionReference. In this example below, we're inserting a new project document into the projects collection. Once we have the reference we need to instantiate the object, we want to insert and set the fields. Notice the time_created field is null. If we set a null Date field, the ServerTimestamp will automatically be inserted here because of the @ServerTimestamp annotation. Now that the fields are set, we can insert the project by calling set on the DocumentReference and then passing the object. We can check for task completion using an onCompleteListener. In the last part, we worked on inserting a document into a sub-collection. That's where the issues are inserted. They're in a sub-collection within the projects. Inserting a new issue was basically the same process. We started by getting the Firestore Instance Reference, instantiating the DocumentReference for telling Firestore where we'll be inserting the data. We ran into an issue getting the projectId because we haven't done any database queries yet. At this point, we just hardcoded the projectId and we came back and fixed it later. We set the issue object to the DocumentReference, and finally, we used an onSuccessListener and an onFailureListener to check for success or completion of the task. Remember, it doesn't matter whether you use an onCompleteListener or an onSuccessListener with an onFailureListener. The only difference is the onCompleteListener will execute whether the task was successful or failed, but with an onSuccessListener you also need to add an onFailureListener. The onSuccessListener will not check for failure by itself.

Review: Querying Data
In the module named Querying Data, we retrieved the first documents from Firestore. The module was broken down into four major topics: querying documents within a collection; querying documents in a sub-collection; sorting, ordering, limiting and paginating queries; and real-time updates. In the first part, we worked on querying our first document from Firestore. In IssuesActivity, we needed to retrieve the projects using the query below. Like always, we start with the FirebaseFirestore Instance object, next we specify the document or documents we want to retrieve. In this case, we needed all the project documents. We ordered the documents in descending order with respect to the time_created field. That way the oldest projects would show at the top of the list. The get method initiates the query. We listen for completion using an onCompleteListener. Because we're getting a list of project documents, we need to loop through the QueryDocumentSnapshot to retrieve each individual project. That's all there is to retrieving the project documents. Next we worked on querying documents in a sub-collection. This is essentially the same process. A sub-collection just means that it's a collection within a document. at its core, it's essentially the same process. The queries only differ with respect to the CollectionReference object. Here's an example. Here's what the CollectionReference would look like when querying the projects collection, and here's what the CollectionReference would look like when querying the issues collection. The issues collection is technically a sub-collection of the project documents. Here's where the unique project id would go, and here's the reference to the issues collection. Next we explored some of the options regarding sorting, ordering, limiting, and paginating queries. These are all terms used to describe methods of manipulating query data, things like greater than or equal to conditions, less than or equal to conditions, specifying ascending or descending order, limiting queries to a specific number of documents, ordering alphabetically or numerically, and of course, pagination. Do not forget pagination. The documentation has a ton of really great examples for all these query methods. Here's where I go when I need a review, firebase. google. com/docs/ Firestore/query-date/queries. The second one is the same, but the last part of the URL is order-limit-data, and the third is query-cursors. Lastly, we talked about realtime updates. Firestore realtime updates are basically the same thing as realtime updates with the Firebase database. You can set something called an EventListener to a DocumentReference or a CollectionReference. The EventListener will constantly check the reference for any changes. If a change is detected, the EventListener will trigger and execute the logic you have inside. Just like the Firebase database, the only thing you need to watch out for is removing the listener when you're done. The EventListeners will not detach themselves. If the user navigates to another activity or fragment, the listener will continue working. If the user moves the app to the background, the listener will continue working. This will consume unnecessary resources. For that reason, you need to remove the listener when you're done. To remove a listener, you need to use a ListenerRegistration object. I recommend making it a global variable in your activity or fragment, then calling the remove method when the view is destroyed.

Review: Updating and Deleting Data
In the module named Updated and Deleting Data, we explored a few different methods for updating data and deleting data. The module was broken down into five major topics, updating a document, overwriting a document, deleting a document, deleting multiple documents with batched writes, and transactions. We started by updating our first document, a project document. Doing a document update starts the same way as every Firestore task, with the FirebaseFirestore Instance object, but here's where it gets a little different. In the example below, I'm instantiating a HashMap object with strings as keys and objects as values. I'm specifying an Object type, because that way I can add any object I want to the HashMap. In other words, I'm not restricted. Next I set the key value pairs. In this example, we're updating the name field and the description field. Once the updated values are added to the HashMap, we can call the update method on the DocumentReference, and then pass the updates. Other than that, everything is the same as any other Firestore task. We can use an onCompleteListener or onSuccessListener to check for task success. Only the fields specified in the HashMap will be updated. All the other fields in the document will remain unchanged. Next we looked at an alternative method for updating documents, using the set method and overwriting them. This is actually my preferred method of updating documents. Not because it's easier, it definitely requires more code, I like making updates this way because it forces me to carry entire objects around. That statement likely confused the majority of you, so let me explain. In the course, we updated issue documents. Here's how it started. We get the FirebaseFirestore Instance object, specify the document we want to update using a DocumentReference, then we instantiate a new Issue object and set the fields. Once the documents were set, we called the set method on the DocumentReference, passed the updated issue, and listened for completion. So why do I prefer doing it this way as opposed to using the update method? As I said, I prefer doing it this way because it forces me to carry around entire objects. In the context of this example, it forces me to pass entire issue objects around to the activities or fragments where they're being used. The alternative to that would be only to pass the updated fields and the updated values. It basically prevents me from getting lazy and possibly running into problems later on. Next we worked on deleting documents. Deleting a document is a very simple process. Start by getting the FirebaseFirestore Instance object, specify the document you want to delete, then just call the delete method on the reference. Of course, if you wanted to check for completion you'd also want to use an onCompleteListener or an onSuccessListener. That method of executing deletes is great, but more often than not you probably want to wait to delete a bunch of documents at once. That's where batched writes come in. You can use batched writes for setting new data, updating data, and deleting data. Basically it allows you to add a bunch of Firestore tasks to a queue. Then you can commit the queue for completion. Here's how we used batched writes to delete multiple issue documents. First we looped through all the issues currently in view. We determined which issues to delete by checking the IssuesRecyclerViewAdapter. Remember, the user can select issues from the RecyclerView by holding their finger down for more than 500ms on a list item. The delete operations are then added to the WriteBatch. Once the loop is complete, we can execute all the tasks in the batch by calling the commit method on the WriteBatch object. The last concept we looked at was transactions. It sounds weird, but transactions are kind of special to me. As I mentioned in the course, late in 2017 I submitted a feature request. Transactions were an answer to my feature request. I said it would nice if tasks could return data. At that point, there was no task that could return anything. Of course, we're talking about the Firebase Database, Firestore wasn't released yet. I don't know if it was my specific feature request that prompted the Firebase team to work on transactions, but I like to believe it was. It feels good to know they're listening to the community. We didn't actually implement a transaction in the course, but we looked at an example in the documentation. All you need to know about transactions can be found in the docs at this URL, but in general, they enable us to return values from tasks.

Final Thoughts
Hopefully this course was as much fun to watch as it was to make. I definitely enjoyed the Firestore course the most out of all the Firebase on Android courses so far. The thing I like most about Firestore is that the Firebase team actually responded to developer suggestions. To put it simply, Firestore is an upgraded version of the Firebase database. The Firebase team listened to the community and built a product to suit our needs. I think that's really powerful. Of course, it's still in beta, but I think it's safe to assume there's some more amazing things to come on the horizon. In case it wasn't obvious, I put a lot of extra time into developing this course. I wanted to make sure I covered everything in the Firestore documentation, and gave you a ton of real, practical examples you could learn from. I'm not fishing for compliments or asking for praise, but I do ask, if you can, to leave a rating on Pluralsight. I depend on course ratings to fine-tune my teaching methods. Any and all feedback is welcome in the discussion section for the course. Or, if you have a more personal question, send me a direct message on Instagram. My handle is mitch. tabian. If you haven't yet, stop what you're doing right now, pause the video, or open a new tab and go to the course page. It'll take about 15 seconds to leave a rating. I know it's a pain, I always catch myself doing the same thing, I forget to leave a rating, but after being on the other side of the fence, so to speak, I've realized it's very valuable to have ratings. If you're interested in my course creation process, or just my life in general, follow me on Instagram and YouTube. On Instagram I post stories talking about the courses I'm working on, and insights into the development process. I'll tell you about my projects, upcoming courses, and sometimes what I ate for dinner. I hope you enjoyed the course, my name is Mitch Tabian, and as always, thanks for watching.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
4.9 stars with 21 raters(21)
My rating
null stars

Duration
2h 14m
Released
16 May 2018
Share course

