Android Fundamentals: ConstraintLayout
by Rebecca Franks

Learn how to create layouts with Android Studioâ€™s Layout Editor and ConstraintLayout. This course will teach the basics of using ConstraintLayout, such as Constraints, Guidelines, Barriers, Bias, and Chains.

Knowing how to build layouts for your Android app is a necessary skill, and using ConstraintLayout and the Android Studio Layout Editor is essential to being a successful Android Developer. In this course, Android Fundamentals: ConstraintLayout, you will learn how to build great layouts using ConstraintLayout. First, you will learn all about Constraints and how to manage them in the layout editor. Next, you will explore some fundamental constructs such as working with Chains and Guidelines. Finally, you will discover how to use some of the more advanced features of ConstraintLayout such as Circular Positioning and Barriers. When you are finished with this course, you will have a foundational knowledge of ConstraintLayout that will help you as you move forward to becoming a great Android Developer.

Course author
Author: Rebecca Franks	
Rebecca Franks
Rebecca Franks is an Lead Android Developer. She has over 6 years experience in developing
 Android applications. In March 2016, she was awarded with the status of Google Developer Expert for...

Course info
Level
Beginner
Rating
5 stars with 69 raters(69)
My rating
null stars

Duration
1h 25m
Released
24 May 2018
Share course

Course Overview
Course Overview
Hi. My name is Rebecca Franks, and welcome to my course, Android Fundamentals: ConstraintLayout. I am an Android developer at Over, and a Google Developer expert for Android, and I've been developing Android apps for over 6 years now. ConstraintLayout is evolving into such an advanced layout mechanism with so many new features being added all the time. With these advancements the Layout Editor in Android Studio is getting even more powerful. Learning how to use the Layout Editor and ConstraintLayout is essential to creating a great Android app. In this course we are going to learn how to use ConstraintLayout and cover a lot of the different features of it. Some of the major topics that we will cover include creating different types of constraints and navigating the Layout Editor, different features of ConstraintLayout, such as chains, guidelines, and groups, some of the more advanced features, such as ratios and circular positioning, and finally, we will cover some tips and tricks to working with ConstraintLayout, and by the end of this course you'll know how to create a layout using ConstraintLayout and how to use the Android Studio Layout Editor. Before beginning this course you should be familiar with Android Studio. I hope you'll join me on this journey to learning constraint layout with the Android Fundamentals: ConstraintLayout course at Pluralsight.

Introduction to ConstraintLayout
Introduction to ConstraintLayout
Welcome to the course, Android Fundamentals: ConstraintLayout. In this module we will be doing an introduction to ConstraintLayout. My name is Rebecca Franks, and I am a Google Developer Expert for Android. You can find me online at @riggaroo and riggaroo. co. za is my website. In this module you will learn the basics about ConstraintLayout. We will learn what it is, why it exists, how it is different from other layout types, and we'll also learn how to add ConstraintLayout to our projects. Then we will take a look at the basic controls inside the Layout Editor. So what is ConstraintLayout? It is an advanced layout mechanism in Android, which is compatible with API level 9 and above, which should be more than enough for your needs. It allows you to have relative positioning with constraints, so you can position views relative to one another. We will touch more on this later. ConstraintLayout enables you to create layouts with a flat view hierarchy, which means that layouts are easier to maintain and perform better than other traditional layout types that may require nesting of layouts. The more you nest layouts the more complicated the drawing process is in Android. Some interesting information about ConstraintLayout is that it uses an algorithm called the Cassowary algorithm to determine how to constrain views to one another. This algorithm is also used on other popular platforms, such as in the iOS auto layout feature. It was released at Google I/O 2016, so it has been around for quite a while and has seen a lot of improvements since the initial release. The Google team is actively working on ConstraintLayout by adding new features and fixing any issues that are reported. It's also a very easy mechanism to do custom animations using ConstraintLayout, and we'll touch on this a little bit in the later modules in this course, so be sure to stay tuned. So what are some of the advantages of using ConstraintLayout over other layout types? Well, first is that it's really easy to use, and it simplifies our layouts, as we discussed a little bit earlier. We also get very flexible controls with ConstraintLayout, so new mechanisms for controlling how to constrain items to one another have been released, and they are more in the works. It is also a better rendering performance with ConstraintLayout due to the fact that you're not have to nest items in one another. A constraint is the first thing we should learn about ConstraintLayout and the most important feature. A constraint is the relationship between two views and it controls how views will be positioned on screen. Now that we have covered some theory let's dive into a demo. We will be adding ConstraintLayout to a project, and we will have a look around the Layout Editor.

Adding the ConstraintLayout Dependency to Your Project
We are now going to take a look at how to add ConstraintLayout to your projects. This applies for an existing project that may not have ConstraintLayout included, as well as checking if your new project contains ConstraintLayout and the correct version. So the first thing that you need to do is once you've created a basic application in Android Studio you need to head to your top level build. gradle file. First, in this file you need to check if the Google repository has been included as part of the repositories link. This will allow us to go and download the latest version of ConstraintLayout inside our dependencies. If we then head to the module build. gradle file we will see in the dependencies section that there is an implementation dependency included for ConstraintLayout. Now you might want to double-check your version that you've included in your current project to make sure that it is the latest one. In this video we will be looking at using 1. 1. 0 beta 5. There may be a newer version available for you to use, but some of the basic principles of constraint layout will still be applicable from these videos. If we wanted to convert an old layout to use ConstraintLayout there are a couple of options for us to do that. So we are looking at this file called the old_demo_layout. This file is just using a linear layout at the top, but what if we wanted to change this to ConstraintLayout? Well, the first option that we can do is we can click on this LinearLayout and then right-click and say Convert LinearLayout to ConstraintLayout. This will then give you a couple of warnings in case you had stuff inside it, so it'll attempt to do a best effort to convert a layout to use ConstraintLayout, but often you need to double-check that everything works as expected if you have a very complex layout, as things may not be in exactly the right place that you're expecting. I'm going to click OK now, and now we have the ConstraintLayout as this top level layout in our app. We can switch to the Text view version of this, and we can see that this is now using ConstraintLayout instead of LinearLayout. Alternatively, we could also just edit this file and change from using a LinearLayout to now use a ConstraintLayout if we wanted to. We don't have to do the right-click, change to ConstraintLayout feature.

Creating Your First Constraint
By default, when we create a new project using Android Studio it uses ConstraintLayout as the top level layer dependency. We're currently in the activity_main. xml file, and we will see that by default the Hello World TextView has been added into this layout. We can also see that this Hello World TextView has four constraints set on it already. It has a top, bottom, left, and right constraint set on it. We can also see more information about this view if we click on it and see on the side panel. Here we will see the attributes of this view, such as the constraints, here we can see them depicted, as well as all the other different attributes of this TextView I'm going to delete this TextView, just so that we can add one ourselves and see how the constraints work. So now to add a view into this layout all we can do is click on one that we want from this little palette over here, and drag it into the view. So I have a button that I am going to now drag into this view. You will see that this view doesn't have any constraints because it doesn't have those lines that we saw in the other view. We will also notice that there's a warning here or an error to say that this view is not constrained. It only has design time positions, so when we run this on a device it's going to jump to the corner, and it won't be constrained properly. So how do we constrain this view? We can click on the top handle and drag it to the top of the screen. Now it has a top constraint. We can click on the other handle and drag it to the side. Now it has a left constraint on this view. I am now going to add a bottom constraint and a right constraint. Now this view is constrained to the center of the screen. In order to delete a constraint all you need to do is hover over the constraint that you want to delete, and then when it is red click on that constraint and the constraint will be deleted. We can also delete a constraint from the side panel. You will see we have the button view selected, and now we can see over here if I just hover over this constraint you'll see a little x arrow appear. If I click on that the constraint will be deleted as well. We will discuss more about constraints in the second module. This was just a basic introduction to what a constraint is.

Layout Editor Controls Walkthrough
Now that we've had a look at how the basic constraints work inside the Layout Editor I want to take a little bit of time to look at the different features inside this Layout Editor, so that you become a little bit more comfortable with the different buttons available for you to use. The first button is the Design mode button. When it is selected here you will see that we have the Design and Blueprint mode selected by default. This allows us to see the Design mode and the Blueprint mode. We can toggle just between one if we want to see the Blueprint mode or the Design mode by itself. Now some people have asked what the difference between the Design mode and the Blueprint mode is. The Design mode shows you a real life view of what your app will look like at runtime, so it has all the styling applied to your views, whereas the Blueprint mode is just a text-based view of your layout, which may be a bit easier to work with, as it sometimes shows a bit more information about the layout. The next button that I want to have a quick look at is the Rotation button. This allows us to view our app in different modes. So, by default, Portrait is selected, but I can change to Landscape mode if I wanted to, and this'll just rotate both the Design mode and the Blueprint mode for us. We can also change to look at Night Mode if we wanted to apply a Night Mode setting. The next thing that we can toggle in this Layout Editor is the device size that we want to preview. We have the Nexus 4 selected here, but we can easily adjust to a different size phone if we wanted to. So if we wanted the Nexus 6P we could just click on it, and now we will see the layout has adjusted to the size of that device. Another option is to change the actual version of Android that you want to view it on. So we know that there can be some differences between different versions of Android. It is advised that you try your layout on different Android versions. We can also change the theme of the layout that we are viewing by clicking on the AppTheme button. Here is we wanted to change to a dark theme just to see how the app would look we could click on Material Dark and select the Material theme. Now we will see the Material Dark theme has been applied to this layout, and we can see if it makes sense and if things are properly themed according to that. The last thing that we can also change up top here is the language that we want to preview this layout in, so if we wanted to see it in a different language we could click here and change that, and then the layout would appear in the different language. Having a look to the side of your view you will see there's something called the Palette. Now this is where you will find all the different views that you can add into your layout that you want to use. So we already dragged a button from here, but we can quite easily drag anything that we want into our view. So we can drag a Switch if we want to show that in our view, and we can search for different items if we want. So if you wanted to find an image button we could just type in here for the word image, and now it will find the different views that are available for you. Lastly, taking a quick look at the Component Tree we will see that this describes exactly what is in our view already, so selecting on something from here will automatically select it in our view. You will also notice that this Component Tree contains very important information about each individual view. It is highly recommended that you follow all the warnings and errors that are on this Component Tree, as it is very likely that these indications will show that your view does not display properly on a device if they are there. In this module we learnt the basics about ConstraintLayout. We learned why we should use ConstraintLayout over other layout types, we learned how to get ConstraintLayout set up in our projects, we learned about basic constraints, and we completed a walkthrough of the Layout Editor. You should now feel comfortable with the idea of ConstraintLayout and how to get started with it. In the next module we will go into more details about constraints.

Basic Features of ConstraintLayout - Constraints and Bias
Constraints in XML and the Layout Editor
Let's take a look at the basic features of ConstraintLayout focusing on constraints and bias. In this module we will learn in depth about constraints and bias. We will cover what a constraint is and the different ways in which you can use constraints. We will also cover horizontal and vertical bias. So what is a constraint? A constraint is a relationship between two views that controls how the views will be positioned. As you can see in this image, we have a Button and a TextView. The Button has two constraints. The top constraint is constrained to the parent, and the start constraint is also constrained to the parent view. We then have a TextView that is constrained to the end of the button using its start constraint. It also has a top constraint to the parent view. The great part about adding constraints in the Layout Editor is that you can still edit your constraints via XML, should something go wrong. This also makes it easy to review code on a third-party tool, as you will still be able to ream the XML that is generated. This is an example of the XML of the Button from the previous slide. We can see that the last two lines refer to constraints. The first constraint defines the top constraint to the view, and is constrained to the parent. The second constraint defines the start constraint and is constrained to the start of the parent view. Let's have a look at how we can make constraints in Android Studio.

Creating a Layout Using Constraints
We will be recreating this layout using ConstraintLayout. This layout has a few complex relationships and is typical of a layout that you may be asked to make. It has a header image, a profile image, a name, a title, and three buttons. We will be working through this layout throughout the next few clips. I've created a file called profile_layout that I'll be working in. We want to ensure that Autoconnect is disabled for now, as this will automatically create constraints, and we are currently learning how to create constraints manually. We will cover this button in later clips. The first thing that I want to do is drag an ImageView into our layout. I will just select the background that I have already added to this or and select OK. Now this view doesn't have any constraints. I am going to give it a left constraint by clicking and dragging, a top constraint by clicking and dragging, and because I can't really touch that other constraint I will just add a constraint on the side here. Now I also want to remove the default margin that has been added onto this view. I will remove the start margin and the top margin. If I wanted to change the value of the default margin I can just edit it over here. So if I want my default margin to be set to 24 dp I can set it over here or any other value that I want. I'll leave it at 8 dp for now. I'm going to set the height of this ImageView, as I don't want it to take up the whole screen, so in order to set the height I'm going to go over here and set it to about 150 dp, and then I'm going to set the width of it to match constraint. Okay, so my image isn't exactly 150 dp in height here, so what I'm going to do is I'm going to change the scaleType to set it to centerCrop, just so that it looks a bit better on this view. Alright, so now we have an ImageView that is constrained to the left, right, and top of our view. Let's add another ImageView into our layout and constrain it to the bottom of the header image. Let's drag in an ImageView for the profile picture, and then let's select the image that we already have in the project as a profile picture, and now this is also quite large, so I'm going to change the width and the height to be about 70 dp because we want it to be square. Now I have an ImageView in my layout, but you can see it's not constrained, so I'm going to add a start constraint and I'm going to add a top constraint. So selecting it here and just dragging it to the bottom of this image view. Also, I might want to increase this margin a little bit because it's quite a small margin that we've got there, so we'll increase this to about 32 dp. Next thing we want to do is we want to add a TextView into our layout. So I'm going to drag a TextView on, and then constrain the TextView to the end of the profile picture and to the bottom of the header image. I'm going to change the dummy text of this view to read out Rebecca Franks, and I'll remove this default text there. This is using the tools text namespace. I also want this to appear a bit bigger, so I'm going to use a different text appearance for this one. I'll use the Display1 text appearance. Now let's add the title underneath the name. Constrain it to the bottom of the name and to the end of the profile picture. Let's remove the default text and give it a dummy text with the words Android Developer. Now we mostly have a working layout that looks very similar to the one we are aiming for, but there are a few issues with this layout. The first issue is that the text is not properly constrained to the parent. If we had a bit of a longer name to display the text would likely go off the screen. Let's change this text to make it a bit longer and see what happens. You will see that this view is not properly constrained at this point. We need to add a constraint to the end of this parent view. Then we want to set the width of the TextView to match constraint. Cool. So now it works a lot better than what it would have before. The same thing for this view over here. So I am going to add another constraint to the end, and then I'm going to set the width of it to match constraints, and that'll take up the full width, and if the text gets a bit longer it'll go further down from there. So let's just remove this text. So now we have a default layout set up with all our constraints on it. So if we had to make this on a bigger sized screen, so let's change it to a Nexus 7, you'll see that the layout still works properly. This is exactly what we want.

Autoconnect, Clear All Constraints, and Infer Constraints
I want to talk about a few of the other features in the Layout Editor; Autoconnect, Infer Constraints, and Clear All Constraints. So in the previous clip we turned off Autoconnect. Now we need to make sure that Autoconnect is turned on. Autoconnect is on when there isn't a strike through the icon. Now that I have Autoconnect on, when I drag any view into my layout it'll automatically try to create constraints for you. So if I drag a button into my view and try to align it at the bottom you will see that it's automatically added these two constraints into my view. Now this can be pretty useful, but you might also want to turn it off at some point if you aren't getting the correct constraints that you want. The next button that we're going to have a look at is the Clear All Constraints button. So this button will just remove every single constraint on all the views inside your layout. So clicking on this button at the top here that says, Clear All Constraints, we will see that all the constraints have now been removed from every single element, but the views have remained in their design positions. Now we can start to add manual constraints if we want to or we can use the other button called Infer Constraints, and this will try to automatically determine the constraints that need to be set on the views. So let's click on this Infer Constraints button. As you can see, sometimes Infer Constraints doesn't give you exactly what you're looking for. It works best with really simple layouts. So I'm going to undo what we just did now, and now we can start to just manually create the constraints again.

Center Constraints
Let's talk a bit about the center constraints. Center constraints are a unique way to constrain your view to another view. It's basically the top and bottom constraints are constrained to the same view. You can see in this example that we have two image views where the smaller image views top constraint is constrained to the bottom of the larger image view, and the bottom constraint of the image view is constrained to the same handle as the top constraint. Let's take a look at how to do that in code. So this is what the center constraint will look like in XML. Taking a look at the two highlighted lines of code we can see that there are two constrains, a top and a bottom, that are both constrained to the bottom of the other image view. This will automatically then create the center constraint. Let's take a look at how to do that in Android Studio. Let's take another look at the layout we were working on previously. If you can remember from the sample layout that we were looking at getting to the profile picture was centered on the bottom of the header view. So let's do a center constraint to get that same effect. So clicking on this top constraint we are going to constrain it to the bottom of this image view. Now that gives us the look that we were going for at the start, but we want to center this image view on the bottom of the header view. So we will select the bottom constraint and also constrain it to the bottom of the header view, and there we go. We have a view that has a center constraint on it.

Baseline Constraints
The next constraint that we're going to talk about is a baseline constraint. This allows you to align two baselines of view that contain text. So in this example you can see that the text view is aligned to the baseline of the text inside the button. Let's have a look at how that looks in XML. You can see that the highlighted line says constraintBaseline_toBaselineOf. This will then align the two baselines of the views that contain the text. Let's have a look at how to implement this in Android Studio. I have two views in my layout, and I'm going to align the baseline of the TextView to the button. So all I need to do is click on the TextView and then click on this baseline button. Now you will see the baseline handle appear. I can click and drag on this and then drag it to align to the baseline of the button. Now these two baselines are aligned. Now if I increase the height of the button you will see that the TextView will move with it. You see the baseline of the TextView is now aligned with the baseline of this Button text. That is a baseline constraint. You can use a baseline constraint on any view that contains text.

Horizontal and Vertical Bias
Let's take a look at bias. Bias allows you to move a widget with a tendency or bias to one constraint. So how does this look in XML? Here is an example of a TextView with a start and end constraint. There is a horizontal bias set on it with a percentage of 20%. This means that dependent on the size of the screen this view will appear in different places. You can set a horizontal or vertical bias. Let's take a look at how to implement bias in Android Studio. Okay, let's drag a TextView into our view, and you'll see because we have Autoconnect on it automatically added the two side constraints. Now I'm just going to constrain it to the top just for good measure and give it a bit of a margin at the top. Now you will see that by default because we have two constraints set on this view we get the horizontal bias indicator in the Attributes panel. By default, when no bias is set we have a bias of 50%, so in the middle. So I could start to drag this view, and you will see that the TextView moves with a bias towards the side that I've chosen. You can drag it to the certain percentage that you want, and if this gets a bit tricky to work with you can switch to the TextView version and change the percentage here. Now the view is biased towards the start of the screen by 20%. I can also set a vertical bias if I want to. For a vertical bias I need to make sure I have a top and bottom constraint set on my view. Once the two constraints have been added the vertical bias option will appear in the attributes panel. If I then move this up and down I will then be positioning this view at the chosen percentage of the screen vertically. Bias can be very useful, but is often overused, as developers seem to think that the layout will just appear exactly the same on all devices. Just remember that bias uses a percentage of a view and not a dp value. You can often get away with just using standard constraints without bias to achieve what you're looking for. In this module we covered constraints, baseline constraints, center constraints, and bias. We also had a quick look at Autoconnect, Infer Constraints, and Clear All Constraints.

Using Chains in ConstraintLayout
Introduction to Chains and Chain Modes
Let's talk a bit about Using Chains in ConstraintLayout In this module you will learn about using chains in ConstraintLayout. More specifically, you will learn about horizontal and vertical chains and the different chain modes that are available for you to use. A chain is a group of views that are linked to each other with bi-directional position constraints. In this example both views have a constraint to one another, therefore creating a horizontal chain. Chains help you to evenly distribute views inside a layout. You'll see that a chain can either be a horizontal chain or a vertical chain. Chaining a view does not mean it can't be part of another chain. A view can be part of both a horizontal and a vertical chain, making it easy to build good layouts. Another thing to note about these two different chains is that the chain does not align the views in that direction. You still need to include other constraints. For example, a top or bottom constraint needs to be added to the views in the horizontal chain. With chains there are a few different chain modes that distribute the views inside the chain with different styles. The different modes are spread, packed, spread inside, and weighted. We will go into more detail in the demo.

Creating Horizontal and Vertical Chains in Android Studio
In this demo we will be creating horizontal and vertical chains with different chain modes. We will also be discussing the chain modes that we mentioned earlier. So let's have a look at how we can create horizontal and vertical chains within ConstraintLayout. So I'm going to drag a couple of views into my layout, and then I will create different chains. So the first thing I'm going to do is I'm going to take a TextView, I'm going to take a Button as well, and another TextView. You may notice that these views are not constrained at all. By looking at the areas in the Component Tree we can see that these views just have Design time positions. So in order to create a horizontal chain we're going to need to select all the views, so select, Shift, Shift, select, and then we're going to right-click and say Chains, Create Horizontal Chain. Okay, so now we'll see that this view has a margin of 16 dp set on it by default, and we've removed that, and now you'll see that these views are distributed evenly. It's a lot easier to see when you use the same type of view, so if we pull in three buttons you will see that the distribution works and looks a lot neater. So let's select all of these and Chains, Create Horizontal Chain, and remove this margin here. So now you can see with the buttons the views are distributed evenly, as the sizes are all the same. So another thing to note is you can cycle through the different chain modes by clicking on any of the views inside the chain, and then by selecting the chain icon at the bottom you can then iterate through all the different chain modes that we briefly mentioned earlier. Another big thing to note about the chain is that your view is still not constrained to the top or bottom, so you'll see here it's still giving me errors on this side and this is because now I need to actually add constraints to the top or bottom of this view. So if I add one to constrain it to the top of that view now you will see that this view is constrained to the bottom of this view, but the horizontal chain's distribution is still maintained. You need to add a top constraint to every view in this chain in order for it to display correctly. What I like to do is to use constraints to align the views to one another. What we will do is take the top of this view and align it to the top of the other view, and the same thing for the other view. Take the top of the view and align it to the top of the other view, and then we will just want to remove this 8 dp margin that has been added automatically, and then you will see that all the tops of these views are aligned nicely together. So now these views have it, but these ones obviously aren't constrained as well, so let's just add constraints to the top of the view for these ones, and now you'll see I've created some horizontal chains. In order to create a vertical chain we do a very similar thing. So I'm going to add some more buttons onto this view, and now I'm going to select all the views that I want to be included in the vertical chain. Holding down the Shift key I then select each view that I want to be included, and now I'm going to say right-click, Chains, Create Vertical Chain, and now you'll see these views have all been distributed evenly in a vertical manner, but that doesn't mean that it doesn't still keep this distribution of the horizontal chain. So you can see that you can really build some complex layouts using chains. It is really useful and it would be really difficult to achieve this without using ConstraintLayout.

Exploring the Different Chain Modes
Let's take a deeper look at the different chain modes and how we can go about setting them up in Android Studio. Open the file, different_chain_modes from the sample app that is packaged in this course. You see that this file has all the chain modes we briefly mentioned in an earlier clip. Taking a deeper look at how these modes differ we can see without diving into code that they all give very different effects. The first set of buttons is chained using the spread mode. This is the default style, and the views are all distributed evenly within the available space. The next chain style is the packed style, and you can see white a visual difference as to what the packed style looks like. The views are packed together. The next mode is the spread inside mode. In this mode the first and last views are fixed to the constrains on each end, and the rest of the views on the chain are evenly distributed. The last mode, and most interesting, is the weighted mode, and it is based off by using a spread or the spread inside mode, and to achieve a weighted chain you would need to then set each view to match constraints or 0 dp. There is then a special property that you set on the view in order for it to take up a certain weight of the distribution. So how do we go about setting these different chain modes that are available for us? Well, we did see in the first clip that we could just cycle through these different button modes here and we will get access to all of them, but it is also very useful to know how to do this from XML. So switching to the Text view of this and clicking on this first button you will see that it never gets to this button within the XML. Now one thing to note is that when you specify a chain style the chain style is typically set on the first item in the chain. So now you can see on this view itself we've got app:layout_constraintHorizontal, and the chainStyle is set on it, and the chainStyle is set to spread. We could easily change this to spread_inside and see the difference of it or we could change it to packed, and you will see that difference. The big thing to note about the bottom example with the weights is that it uses a spread or spread_inside chain mode with an additional property on it. This additional property is the weight property that can be edited to anything you want. All the views in this chain have a weight property on it, and the whole chain will display the views with those certain weights, so there is no such mode as a weighted mode, but you would just make use of it when you use something like a spread or a spread_inside mode.

Adding Chains to the Profile Layout
Okay, so now we want to actually start using chains in the profile_layout that we were building up from the previous clips. So what we're going to do now is head to the profile_layout that we've already been building up, and we're going to add three buttons into the layout. So I will drag three buttons in, button one, button two, and button three, and you can see that this layout has added all these strange constraints, which I don't really want, so I'm just going to remove them by clicking on it, and deleting it, and the same for the bottom one. I don't want those constraints. Same for this one. Delete and delete that constraint, and delete that one, and delete that constraint. Okay, so I'm going to constrain this view to the bottom of this text view, and I'm going to delete that bottom constraint. I'm going to constrain this view to the top of that view, and delete the bottom constraint, and the same with this one. Constrain it to that one, and I also want to delete the 8 dp margin that it's added. Just leave it as 0, and that one's already 0. Okay, so we want to apply a chain here to make sure that they are evenly distributed and that the sizes are even as well. So I'm going to press Shift and select all the buttons that I want to use and then I'm going to click right-click, Chains, Create Horizontal Chain. Great, and now my views are all evenly distributed. The only problem is the 16 dp margin that we've got on this one, so we can set that back down to 0, and now I have a chain in my layout, and all my buttons are evenly distributed. The one thing we might want to do is to set the width of these buttons to match constraint, so that they take up the full width of the layout, and then I'm going to add an 8 dp margin on each side or 16, let's make it 16, and 16 on the side. Okay, so let's just change the text of these three buttons to what we actually wanted. So we wanted this first button to say Add Friend, so we will change it here, Add Friend, remove that. We wanted this one to say Message, and we wanted this last one to say Remove. I think we also wanted this button to have the colored button style, so I will just change it over here to Button. Colored, and that'll apply the color that I've set throughout on the whole theme, as the theme over there, and that's it for chains. So in this module we learned how to create horizontal and vertical chains. We also learned about the different chain modes of spread, packed, spread inside, and we applied these learnings into that layout that we were creating from the start.

Optimizing Your Layouts with Guidelines and Groups
Introduction to Guidelines
Let's take a look at how we can optimize our layouts using guidelines and groups. In this module we will learn about the two different concepts; creating guidelines, and creating groups in ConstraintLayout. We will also see how these two concepts can help neaten up our layout files. A guideline is a visual guide that is visible in the Layout Editor, but not visible when running on a device. You can think of a guideline like a gridline that you may be used to seeing in a design program, like Sketch or Photoshop, and you generally align things to the guideline. A guideline can be used to align multiple views with similar pairings. A guideline can be horizontal or vertical. In this example on the left we have a vertical guideline that has an offset of 16dp from the start of the screen. We have a TextView and a Button that are both aligned to the guideline. This will neaten up our layout files, so that we don't have the duplicated margin values all over the place. Here is how a guideline is created in XML. It acts as a normal view in the Layout Editor, but has the property of constraintGuide_begin on it. This indicates that the guideline is a beginning guideline, and we will cover more on this later. It also has a value of 16dp. This guideline is also a vertical guideline, as indicated by the Android orientation property on it. Your guidelines should also be given Android IDs, so that they can be referenced by other views in your layout.

Creating a Vertical Guideline in Android Studio
Let's take a look at how we can create different guidelines in Android Studio, and how to align our views to a guideline. I've opened up the Android app that you can find in this courses download section, and now we will start to look at how we can create guidelines. The first thing that I'm going to do is I'm going to drag a few views into our constraint layer that we have already, and then we will create a guideline. So the first thing I'm going to drag in is a Button, and then I'm going to drag in a TextView. So now these views are not constrained at all. You'll see they don't have any links on them. So the first thing that I'm going to want to do is create a top constraint on this one, as well as a top constraint on that one to the bottom of this button. Now these views are not constrained to the start of this parent. So the first thing that I'm going to want to normally do is create this constraint. So once I've created this constraint we will see that it's automatically added this 8dp margin onto it. Typically with Android you want to have like a 16dp margin all around, so I normally would then just add the 16dp margin on both of these views. The problem with this is that your layer can quickly become very complicated, and then you'll have a lot of views with the same dp margin on it, so switching to this TextView version you'll see that now in a few places we've got the same 16dps in every single margin start of every view. So now this becomes an even bigger problem when you want to design for, say for instance, a tablet where you will then be having a bigger margin. So, say on a tablet you have a 64dp margin on the sides on the left and right, so now to change that you would have to go and update every single one of these views that you have referenced with the 16dp. So in order to make this a bit more efficient we will use something called a guideline. So in order to add a guideline we would just right-click on this section or anywhere on the view, and we would say, Helpers, Add Vertical Guideline. Now you will see by default it adds it as a start guideline, and you can faintly see that it's got a 16dp value over there. So if I click on it you will see that I can then drag it across my view and give it different values, so you can just drag it if you want. So if you wanted to have a bigger dp margin you can do that, but you can also just control this here on the side, so I'm going to say that I wanted a 16dp, and then we'll move it to the side over there. So what we can also do is we can then change that this should go from the end of the view, so we would just click on this little icon at the top here, and that cycles through the different kinds of guideline modes, so in this case, now we've got the margin set as a really big margin of 368dps, which is not ideal, so if we have it as a right guideline we probably want it to be like a 16db margin on that side or something like that. There's now the mode as well on a guideline, which is very interesting, and that is the percent mode. So if you click on it again, you will see that it's now sitting at 93% of the view. So I can move this and say, okay, this should take up 8% of the view, and now, depending on the size of the device, it'll calculate 8% of the screen and use that towards the guideline. So this is pretty powerful and really hard to achieve without using guidelines. So once we have a guideline in place I'm going to switch this back to using just the dp value, and we will move it back to 16dps. Great. So now that we have this guideline in place we actually want to use it because at the moment these views aren't using the guideline at all. So in order to do that I'm going to delete this constraint that's already been created on the side, and I'm going to then constrain it to the guideline itself. So this can be a bit tricky, and sometimes you may want to do it in XML, but now you can see it's constrained to this guideline. Specifically, then I would remove this margin value in here, because it's taken care of by the guideline. So I say 0dp for that margin, and I need to do the same for the TextView. So the TextView still has the 16dp margin here, but I want it to be aligned to this guideline, so I just select this constraint, and then constrain it to the guideline, and now I want to remove this 8dp margin that's been added automatically. Okay, great. So now I have this guideline, that's great, but what does it actually do? So now we can see if we start to move this guideline all the views that are attached to it or referencing it are moving as well. So what we can do is in our tablet layout or we can create another values file for our table, and we can specify that the tablet should have maybe a constraint of 64dps for the margin left and margin right, and this is particularly useful and cleans up your code quite a lot, so now we don't have to reference the same dp value everywhere all over our code. We just have it on our start guideline. Over here we have our start guideline that references our value, and then our text view and our button are both constrained to the start of that guideline, and that's it. We've created a guideline.

Creating a Horizontal Guideline in Android Studio
So let's go and create an end guideline as well, just so we can practice it. So right-click, Helpers, Add Vertical Guideline, and that sort of created in the same space, which is a bit annoying, but we can easily move it, so we can say just change this to 20dp. Okay, now we can see it, so now we can drag it to the end of the view, and we can actually just cycle through and make it come from the other side. So now we can say this one we want it to come from the end for 16dp, and if we have a look at how that looks in XML you will see that this one says constraintGuide_end, and that means it's coming from the end of the view, and now we can align views to that on the other side as well. So we can create a button, and align it to this guideline, remove this margin, and we can drag in a TextView as well, align it to the guideline, remove the default margin, and now when we move this guideline we will see that both of those views move as well. Not only can you create start and end guidelines, but you can also create horizontal guidelines from the top and the bottom of your view, so that's also useful if you wanted to add a top margin on everything that is aligned to it. So we can go about doing that as well. So we just right-click, Helpers, Add Horizontal Guideline, and you will see by default it's created with a 20dp margin. So we'll change this to 16dps, and now we have that view aligned. So let's --- now this button we want to align to this guideline, so let's delete this constraint, and align this button to the guideline. Okay, and we'll set that to 0. Cool. So now if I move this guideline you'll see that the button moves as well. The TextView is moving because it is aligned to the bottom of this button, not because of the guideline, but because the guideline's moving the TextView will ultimately move as well. So that's how you can set up horizontal and vertical guidelines. I think the real power comes in when you start to use percentages of the screen because that kind of thing you've never been able to do before without using a guideline object or without creating a class yourself and manually doing the calculation of the size of the screen and getting exactly the width and all that. So pretty powerful, and really useful as well.

Introduction to ConstraintLayout Groups
In ConstraintLayout there is a concept of a virtual group. A group is a helper element that is used to group views together. It is not to be confused with an Android ViewGroup, which is different. This group only contains references to IDs of views that should be included in it, whereas a ViewGroup actually contains the views itself. A group is used to set visibility of all elements inside it at one time. This is an example of a group defined in XML. As you can see, it's got the property, constraint_referenced_ids in it, and this contains references to all the different elements that will be included inside this group. We also include the id of the group, so that we can later use this inside our Java or Cartland files that we want to control. When we set the visibility on this group this visibility property will apply to every single view that is referenced inside the constraint_referenced_ids.

Implementing a ConstraintLayout Group in Android Studio
Let's have a look at how we can create a group in Android Studio and change the visibility of all the items inside the group. Open up Android Studio and we are in the file called group_example. So what we're going to do is typically in a lot of layouts you might have an error screen that represents a state when the view is in error. So, for instance, if you try to do a network call, and the network fails for some reason, maybe you don't have internet, you would typically maybe display an issue or an error to your user to say, hey, there is no internet, would you like to retry, and then a retry button underneath. So what happens with a lot of that is that a lot of times is that you need to toggle between these different layouts, so you need to set the visibility of a whole bunch of views inside your layout and then switch to view the visibility of a whole bunch of other views inside the layout. So this is where a group comes in real handy because you can group a whole bunch of views and just hit the visibility on the group itself. So what we're going to do is we're going to recreate sort of an error screen. So we're going to drag in a TextView, and we're going to drag in a Button into our view. So this button we're just going to set some text on it to say Retry, and this TextView we are going to set some text saying Error occurred. Delete this TextView, and we'll call this textViewError, and we'll call this button, call the buttonRetry. Okay, and let's give it some constraints. So our view is constrained to the center. Give it some constraints, and constraints at the top, and like normal, we want to set the width of this one to just match constraint, and let's give it a bit of a higher margin value, and constrain that one to the bottom. Okay, so now we've got our little error layout that we want to show, but we also want to hide this and show this at different times. So typically what you would have to do is set the visibility on the Retry button to gone or invisible and then on the error layout as well you would have to say the same thing, and maybe you would have an image or some other like loading bars or something like that. So in order to avoid having to do that repetitive kind of work what we're going to do is we're going to create a group. So we're going to right-click here, and say Helpers, Add Group, and now you'll see no visible change here, but in the Component Tree on the side you'll see that a group has been added into our view. So let's call this group groupError, and now what we want to do is we want to select the views that we want to be included in this group, so we'll select these two views, and then we are going to drag them into the groupError layout item that we've just added, and now you'll see there's a dropdown, and these two views are now referenced within this groupError layout. So if we switch to the TextView version we'll see that we've got this Group item that's now been added, and it has now got this constraint_referenced_ids property on it, and it's referencing these two different things that we've just created. So it doesn't actually contain the views themselves inside it, just referenced us to these views. So it's important that these IDs match exactly to what exactly is referenced here. Okay, so now if I want to set the visibility of the whole of all of these inside the group all I need to do is hit the visibility here to gone, and then every single view inside that group will be set to gone. I can also just set them to invisible if I want the sizes to still be taken into account on screen, but not to show them visibly, and I can obviously also set it to visible. So now inside your layout, inside your Java or Cartland that you're writing you can just find reference to this groupError and set the visibility on that itself and not needing to find all the views that are referencing for this error layout, so it neatens up your layout quite a lot, as well as your Java or Cartland code that you're writing. In this module we learnt about guidelines and groups and how they can help you neaten up your layout files and reduce the amount of boilerplate code that you need to write in order to maintain your layout files.

Advanced Features of ConstraintLayout
Implementing Barriers in ConstraintLayout
By now you should be pretty comfortable with the basic features of ConstraintLayout, such as creating constraints and creating some complex layouts using ConstraintLayout. In this module we are going to talk about some of the advanced features of ConstraintLayout. We will be looking into using barriers, creating views with aspect ratios, and positioning views with circular positioning. So what is a barrier? A barrier references multiple widgets as input, and creates a virtual guideline based on the most extreme widget on the specified side. This is a pretty difficult concept to explain, and once you see it in action you will get a better understanding and know when it should be used. In this example that we have here we can see that we have and end barrier that includes the left TextView and Button below it. We can also see that the starting constraint on the TextView on the right is aligned to the end of the barrier, and when one of the views in the barrier gets bigger the views aligned to the barrier move further along. Barriers can be defined to be vertical or horizontal in your view. This is an example of how a barrier looks when defined in XML. We can see that it is similar to the other virtual helpers we saw before, such as a group where it has the property of constraint_referenced_ids and this contains a list of IDs of the views that the barrier should use to form itself. We also specify the barrier direction, which can be right, left, top, or bottom. So let's create a barrier in Android Studio. In order to create a barrier we need more than one widget to form a barrier, so let's start by creating and adding a TextView and a Button to our layout. So I'm just going to drag on a TextView, and then I'm going to drag on a Button into our layout. Okay, now that we have these two views in our layout we just need to constrain them and make sure that they have constraints set on them. So this has got a top and side constraint, and the button has a side constraint, but now we'll add a top one as well. Cool. So now what we want to do is we want to make sure, we want to add a text field into our view, but we're not sure about the length of the size of this text view that the text that might be in it, so maybe this is a response that we get from a server or maybe somebody enters it in manually and it can be anything. It can be any length, and we can't control that length, so what we would want to do is create a barrier over here, so that anything that we want to align on this side adjusts with the size of this TextView and the Button size. So this will automatically, if we add a barrier here, it'll automatically move the view along as we go. So let's see if we just added another TextView into our view. Okay, but now if I just align it to the button at the moment and I adjust the TextView size, so we can just change this to be a lot more text, we'll see that now we have this overlap on our view. So that's not really what we want. We want our TextView, our second TextView to move automatically with the size of both of these views at the same time. So I'm just going to delete all of that that we did there, just put this back to say Hello. Okay, so we know what the problem is, and we know that we need a barrier to fix it, so how do we create a barrier now? So what we're going to do is we're going to just right-click in Android studio, and we're going to click on Helpers, and we're going to say Add Vertical Barrier. Okay, and as, like the other objects that we've seen before, sometimes you won't see it visually in our design and editor view, but you'll see it added to the Component Tree. So here we can see we've got this barrier object. So we probably will want to give it maybe a better name, but we'll leave it for now, but now we can see this barrier doesn't reference anything in it, so it doesn't know what to form or how to form itself. So what we need to do is we need to select the two elements, so we want the Hello text, and we want this button, and then we just drag them into this barrier, and now it contains a reference to these IDs of these views that are inside this Component Tree, but this barrier we can see, if we look closely, it's actually on the left of these views and not on the right, which is a bit useless, so what we're going to do now is change the direction here to right, and now you can see the barrier is now formed on the other side of these two views, and what we then need to do is take this TextView and align it not to the button, but to the barrier, so we'll remove that constraint, and then constrain it to the barrier, and we can double check that that's correct by just switching to the TextView version, and let's see, constraintStart_toEndOf the barrier. That's perfect. That's exactly what we wanted. So now let's have a look. If we now increase the size of this text, so let's say Hello, now we can see that this TextView moved to the end of both of these views, and not just to the end of the button. So it really, really helps with things such as translations or user entered text or text that might come from the server. Even things such as like undeterministic size of images or a button that may change size depending on what a user inputs or something. So barriers are pretty powerful, and implementing this kind of thing without constraint layout would have typically been very difficult as well.

Using ConstraintLayout Ratios
A ratio shows the relative sizes of two or more values. With ConstraintLayout you can define one dimension of a widget as a ratio of the other dimension. Previously on Android you would have needed to create a custom view that would automatically decide on the width and height programmatically. Now with ConstraintLayout you can just set the ratio inside the Layout Editor. Having a look at the XML that is produced by the Layout Editor we can see that the attribute, layout_constraintDimensionRatio, is added when applying a ratio. Here we can specify if we want to use a 16:9 ratio or whatever ratio we want to use. Let's have a look at how to implement this in Android Studio. So taking a look at Android Studio and how we can use ratios inside Android Studio, the best example for using ratios is when working with ImageViews, but ratios work for any other kind of view as well, so it will work on a button, a TextView as well, but ImageViews is where it really kind of drives home. So I'm just going to add an ImageView into my layout, and I've got an image in my project already added, and it is a 16:9 image normally, so I'm going to set that one to that image, and now we don't have any constraints on this view, so it's going all over the place. So what I'm going to do is I'm going to add a lift constraint, as well as an end constraint as well, and I'm going to remove the default margin that's been added. So there's a few different ways in which we can use the ratio constraint. So the first way, and this is the most important, is that you need to sit one of these with the heights to match_constraint, as well as constraints need to be set on it in order for the ratio to take place. So as soon as I enable match_constraint you will see I get this little triangle in the corner, and this, when I click this, the aspect ratio toggle is turned on. So now I can say this should be a 16:9 ratio, and you'll see it does look a little bit strange, and we'll get onto why that is now, but basically because I've got this wrap_content set on the height the Android system typically has a few issues with wrap_content when using ConstraintLayout, and there are some ways to work around it, which we will get to in a later video, but what I want to emphasize is that there are two different ways in which we can use the 16:9 ratio. The first way is to set the height to a fixed height. In this case, let's say 200dps, and then we will see that the width is always calculated to attain the 16:9 ratio, taking into account that the height is set at 200dps. So the interesting thing you'll note here is that when you switch to the TextView version we have this constraintDimensionRatio set on it, but we also have this prefix of the w, so that means the width is the constraint to this dimension. So it takes into account the height that's been set, and it then calculates the width based on that height, but what if you wanted it to be automatically calculated to whatever size the phone is? You can also do that. So we don't have to set a height on the object. We can set this height to match_constraint as well. So we're going to get a bit of weird issues now because we haven't set any constraints on this view for the height. So if I now add a top constraint, I'm going to remove this padding as well, and I add a bottom constraint, now we will see that the 16:9 ratio is applied to both of them, the width and the height, and if we switch back to the text version we can then remove this w, and automatically our width and height is calculated at a ratio of 16:9. So automatically the width is the full width of the screen, and the height is then programmatically calculated depending on the width, but interestingly to note is if you'd like to rotate this into landscape mode you'll see the opposite applies. So the height is then used as the biggest amount, and then the width is calculated programmatically to say, okay, this is a ratio of 16:9 for this view, and you'll see there's now like a little bit of white space to be displayed, and that is the edges on the side here. So you can use any kind of ratio if you want, so let's delete this one from this view, and we can add another image view in, and this time we'll select the profile picture, so this is typically a 1:1 ratio, so I can also do that. So I will set a top and side, remove that padding, top constraints. You'll see a dozen come up when we've got it as wrap_content. We need to have it as match_constraint. Now we can enable it by clicking on that little icon, and it's automatically using a 1:"1 ratio, so our ImageView looks pretty perfect, but we want to make sure that we're setting this other to match_constraint, and then constraining it to the bottom of the appearance, or that we've programmatically set the heart maybe to something like 200dp, and that'll automatically remain with this 1:1 ratio, and the same thing here now. When we go into TextView version we will see now this 1:1 ratio has been added, although width is constraint because we've set the height programmatically. So if we didn't want to do that we could then just remove the width or we could just use the height as a variable as well if we wanted to. And that's it for using a ratio in ConstraintLayout. It's really, really simple. Doing it before, once again, if you were using something else behind ConstraintLayout it will be pretty difficult. You'd have to probably use another library or implement this yourself programmatically with a custom view.

Introduction to Circular Positioning
One of the lesser known features of ConstraintLayout is the concept of circular positioning. Circular positioning allows you to constrain a widget sensor relative to another widget center at a specified angle and distance. Having a look at these examples, the first example of a clock shows how we can use normal Android views to create a clock with circular positioning. Doing this kind of work previously on Android would have required custom canvas drawing. At the moment, circular positioning is not available as a design tool in Android Studio. It is only available via the Text Editor. As you can see in this example, we have a TextView and three new properties on it. The layout_constraintCircle indicates which view should be used for constraining. The next two properties indicate the angle and radius that we want this TextView to take from the reference TextView. Another great part about these ConstraintLayout properties is that they can be changed at random and animations can be easily created by transforming the properties. Let's implement this in Android Studio.

Creating an Arc Menu Using Circular Positioning in Android Studio
In Android Studio we're going to make use of circular positioning. So what I want to do is I want to create a kind of an arc menu that you may have seen before in different apps. So basically I want to create like one floating action button, and then a few that are circularly surrounding it. So in order to do this I'm going to head to the Palette and select on floatingActionButton and drag that into my project, and now this is asking for the resource that we want to use for this icon on this thing, so I'm just going to set it to the launcher_round icon, but we will generate one and use the correct one soon. So in order to generate one I'm going to right-click on the drawable folder, and say New, Vector Asset, and now we're going to select the clip art that we want to use. So we don't want to use this message icon, we want to use the share icon, so select that, leave all the defaults, and select Next, and Finish, and now we want to actually set this floatingActionButton to use that icon that we created. So we are going to say @drawable/iTunes Connect_share_black. Cool, but we also want this icon to have a white tint to it, so we will add the color here to the tint attribute. We should probably extract this color into our color resources file, but we will leave it here for now. Okay, so I've got one floatingActionButton, but now I want to add three more to our view, and then position them over here, over here, and over here. So I'm just going to create all these three different vectors that we want, so we want to be able to share something to email, we want to be able to download it, and we want to be able to send it as a message. Great. So now we have the share, the message, and the download. So if we go back to the example that we're working on I'm going to now drag in these three buttons that we want, and we want to now use the message icon with the tint the same, and we can remove this constraint that sits on it because we're going to be adding the circular constraints, and I'm going to drag in the other one, so we want to now email. Same thing here, and the last one we want must be to download. Cool. So now we've got our little buttons in our view, but we could see that these are just design time positions, and they actually are not going to be constrained when we run it on the device. So we're going to now switch to the Text mode, so that we can add those circular constraints. Remember, as I mentioned, currently at the moment there is no tool in Android Studio to automatically create circular constraints, so we're going to have to add them in the text version. So let's have a look at our layout. So this first one the share icon is this floatingActionButton4. We can rename this to Share, and now on the second button, which is the Message we are going to now constrain this button to that Share button. So we'll say app:layout_constraintCircle using the id of the floatingActionButtonShare. Okay, so now we've set that --- its constraint to that item, but we need to set the radius and the angle, so we will add that now, so Radius set at 100dp, and then angle we'll set that at 90 degrees, and now we see that that message icon is aligned 90 degrees to this share icon. So we're going to do the same for this email or message icon, and for the download one. So we can copy all of this just to make it a bit easier. So we'll copy all of that, and the only thing that we want to change now is this angle, so we want this not to be at 90 degrees now for the email icon, we want this to be at 135 degrees. Cool, and then for the last one we want to do the same, so we copy that, and place it here, and now we want this to be at 180 degrees. Awesome. So now we have a share menu with three buttons surrounding it in a circular manner, and that's it for creating a circular constraint. It's pretty simple. Just add these three different properties on an item. Like I mentioned, the downside is you can't do it through the graphic layout editor. One other thing to notice is Android Studio may complain about your views saying that they are not constrained and at random they will jump to a different position. In this case, it's mostly okay to ignore this warning, as it is using the circular constraint, and this warning does not seem to be suppressed when these kinds of constraints are used. So don't worry so much about this warning you see here. Just run it on a few devices to ensure that it works as expected. So now we can see this circular constraint running on here, and you can see that it is properly constrained and it forms this nice arc that we wanted, and that's it for implementing the circular positioning in ConstraintLayout.

Summary of Advanced Features
In this module we covered a few different advanced topics of ConstraintLayout. Looking into using barriers to create a virtual guideline around a few views, we also used ratios to calculate the height or width of a view easily, and lastly, we covered circular constraints, and how you can build some interesting views positioned with an angle and a radius to other views.

Tips and Tricks to Using ConstraintLayout
Working with WRAP_CONTENT in ConstraintLayout
Now that we have covered the basics of ConstraintLayout let's take a look at some tips and tricks to using ConstraintLayout that I have discovered after working with the layout for some time. We are going to cover a few small tips for working with ConstraintLayout, namely, using the wrap_content, and how that works in ConstraintLayout, using the pack horizontal and vertical tools, and the ConstraintLayout optimizer, and the convert to ConstraintLayout tool. Dealing with wrap_content can be quite difficult when using ConstraintLayout, as wrap_content was introduced before ConstraintLayout. You may run into some unexpected behavior with wrap_content that you need to be aware of. Let's take a look at the example in Android Studio. A common example of where using wrap_content with ConstraintLayout that may not work as expected is shown in the example here. I have an ImageView with a TextView that is constrained to the end of the image view. Now this layout might work mostly fine for a couple of different views that have very short example texts here, but what if the text gets a bit longer than this size of the screen? Well, let's have a look at what'll happen. So changing the text here to the long example text. Now we can see that the text is just completely gone off the screen, and that is because we haven't got a constraint set on the end of the view, so we would naturally want to go and then just add this constraint, right? So adding this constraint we can see that that's not exactly what we were going for, and now this view is overlapping not only the ImageView, but it's also running off the screen, which is not really expected behavior. So there are two different ways that we can solve this using ConstraintLayout. The first way is to set this to match_constraint, and now we kind of get what we were going for, and then set the bias to be 0. So if we had the short example text again, we would see that it would work correctly, but what if we wanted to actually use wrap_content instead of match_constraint? Well, we can. With versions 1. 1 and above of ConstraintLayout the wrap_content dimension will be taken into account considering constraints as well. Only if we have specified a certain property on it though, so I'm going to switch this back to using wrap_content, and we'll see that it's still overlapping on the view itself, so I'm going to now go back into the TextView version, and now we're going to add this property called constrainedWidth, and we'll set this to true, and that'll enforce the constraints as well as the wrap_content dimension. So now if I switch this back to using the short text we will see that the view obeys the constraints, as well as uses the wrap content dimension as well. This obviously will still work with the long example text that we were looking at initially as well. So that's one thing to keep in mind when using wrap content with ConstraintLayout. So you can either switch to using match_constraint if that's maybe easier for you, or you could switch to using this constrainedWidth or constrainedHeight property on the item itself, so setting that to true or false depending on what you need. So keep that in mind when using wrap_content on ConstraintLayout.

Diving into the Pack and Expand Buttons in the Android Studio Layout Editor
The next example I want to demonstrate is the usage of the pack button that is available in ConstraintLayout in Android Studio. Let's have a look. When you've selected more than one view in Android Studio you may start to see this Pack button that appears above the views. Now you need to be very careful and take notes of what changes when selecting one of these buttons, as they may not work as you may think. The concept of the packing button doesn't apply any constraints to any views. If views aren't chained then the packing moves the absolute position in the Layout Editor, so that they are adjacent to one another. So let's have a look if I click this Pack Horizontal button what exactly will happen. So now you can see that it's made these two buttons go next to one another, but there has actually been no constraint that's been set on it, so if we just switch to the text version we'll see that now there is some different absoluteX and absoluteY positions that have been added onto these views, so not very useful when we actually run it on a device because these are obviously going to be totally ignored. Another one of the buttons that can be a little bit tricky to understand and see how it works is the Expand Horizontal button. So if I now click on one of these buttons and select Expand Horizontally we will see in the Layout Editor that this button has now expanded horizontally, which is what we wanted, right? But the problem is that actually what happened is the view has now taken an absolute size of its width, so you can see here it's now got the value of 251dps, and it's not actually set any constraints on the view, so it actually hasn't made this view match constraint to the whole size of this view. It's taken an absolute value, which may not work as expected if we have a different size device. So if I had to change now to using a bigger device, maybe a Pixel 2, we will see that this button doesn't take up the full width of the device. So this is a problem. I've seen a lot of developers misuse these pack and expand buttons without checking what is changing in their layouts when they use them. So the same thing happens, unfortunately, when you click Expand Vertically. So it takes up the whole size of this view, but it doesn't take into account different size devices, so now you can see it's at a height of 587dp, which is very specific and not going to work well on smaller size phones or other size devices. So when using these buttons just be very careful to know and make sure once you've, like maybe if you've used this button just make sure that you've got your constraints set properly, and that your width and height are not set directly like this. You probably want to be rather using something like match_constraint, so if I had to change this to match_constraint, and then I set a bottom and a top constraint on this view, and remove this margin, and remove that margin, you'll see that now that takes up the whole view, which is kind of more like what we were expecting, and the same thing for the width. We would probably want this to be constrained to the side and constrained to the end of that button, and we want this to match_constraint, and not be a certain value, and now if we switch to a different size phone, maybe a Nexus S, we will see that it behaves as expected now by using the match_constraint. So I would advise just testing your layout in multiple size devices to ensure that the views are constrained as you expect them.

Layout Optimizer for ConstraintLayout
ConstraintLayout is based on an algorithm called the Cassowary algorithm. This algorithm basically creates a set of equations that describe how the views are positioned relative to one another. The algorithmic solver is running on layouts, and can get quite complex the more items and constraints you add to your views. ConstraintLayout also has the concept of an optimizer to help streamline the resolution of constraints to make the views more performant. This optimizer is automatically running by default without you needing to really do anything. For a lot of different cases the optimizer can do direct resolution, so doing exactly what a linear layout would do and giving performance gains like that. There are some things to note with using ConstraintLayout. The first is that wrap_content and a fixed dimension on a view is generally a lot cheaper than setting a match_constraint or a 0dp width or height on an item. As using one of the first two, the constraint solver doesn't need to solve or remeasure items in it's layout, whereas using match_constraint it can be a very expensive operation to perform, more especially if you are using text. Now this is not a hard rule, as there are certain cases where this could be different, but it's good to keep in mind when writing a layout with ConstraintLayout or maybe when you're dealing with some kind of performance issues. If you want to try to change the optimization level you can do so via the app:layout_optimizationLevel XML attribute. You shouldn't really need to be doing any changes to the optimizer, but this is good to be familiar with in case you experience any performance issues. The default optimization level is standard. This optimizes direct and barrier constraints only. You can specify if you want to try out some other kind of optimization, such as direct only or barrier only. The chain and dimension optimization levels are currently still in experimental mode, but they target chains and dimension constraints. If you want to turn off optimizations you can set the level to none as well. One thing to note is that the attribute is a mask, so you can decide to turn on or off specific optimizations by listing the ones that you want. Let's have a look at how this optimizer work in Android Studio. To make use of the optimization levels in Android Studio you will need to head to the Text section of your layout. So we can see in this layout we've got three buttons, and if I wanted to maybe change the optimization level for some reason, maybe I was experiencing some performance issues, on the ConstraintLayout element itself we would add this app:layout_optimizationLevel onto it. So, in this case, I've set it to direct, but I could also just set it to none to profile to see if the optimizer is what's causing some issues for me. I could also just set it to direct and barriers if I want, and I can start to just add different things onto here if I wanted to have all different kinds of optimizations. Like I mentioned, some of them are in experimental mode, but if you do want to try one or turn it off completely this is where you would do it in this line here. So typically you're not going to see much of a change if you just run this on a device right now, unless you're doing some profiling or this is in a massive layout with a lot of maybe in a recycler view, and it's repeated over and over again, but this is where you would do it. So just something to take note of and be aware of if you are experiencing any performance issues.

"Convert to ConstraintLayout" Tool
The last tool I want to talk about is the Convert to ConstraintLayout tool. This option is available in Android Studio, and what it aims to do is to take an existing layout, be it a relative layout or a linear layout, and convert it to a constraint layout. You need to be very careful when using this tool with complex layouts, as it may not work entirely as expected. Let's have a look at how it works in Android Studio. In this example I have a simple vertical LinearLayout that has three patterns in it. Now if I right-click on this LinearLayout we can see that we have got the option to convert a LinearLayout to ConstraintLayout. Once we click this button we are prompted with quite a big warning sign with some options as to what we can do to the layout. Read through these options carefully, but you probably want to leave them both selected, as one of the main points of using ConstraintLayout is to flatten a view hierarchy. We can see in this warning as well that it says that it will attempt to create constraints, and you may need to go and adjust these constraints once this has run. So let's run this tool, and we can see what the tool has done. Now we can see that the tool has changed the LinearLayout into a ConstraintLayout element, and has attempted to add some constraints to mimic the prior behavior of the linear layout, and has done a pretty good job for the simple case. We can see the constraints have been created in between these elements and to the side of the whole view, so it's done a pretty good job for this. Let's take a look at how it works on a more complex layout. In this layout we have a relative layout with a nested linear layout inside it. Let's try to run the tool and see the outcome. So we can see now that there are some weird constraints that have been added on these views, so this one has constraints to the side, which should be constraining to these two items. This item has a baseline constraint, which is not what we want at all, and this TextView is constrained to the end of this button, which is really, really strange, and if anyone has to set up a layout like this it's not really a natural way of setting up a layout. So, in this case, what I would suggest is to remove all the constraints on these views, and then manually do them or just delete these views and manually add them yourself again, with the correct constraints. So sometimes you can see the ConstraintLayout converts a ConstraintLayout that doesn't work as expected, and you've got to be very careful when you run it, so you've got to double-check that the constraints that you want are the actual ones added on the views. In this module we covered a few different tips and tricks to use in ConstraintLayout and its tooling. We covered how wrap_content works, how to use the pack tool, what the ConstraintLayout optimizer is, and how to use the Convert to ConstraintLayout tool.

Next Steps in Your ConstraintLayout Journey
Course Summary and Next Steps
We have now covered most of the different aspects of ConstraintLayout. Let's do a quick course recap and discuss what's next in your ConstraintLayout journey. We first learnt about the importance of ConstraintLayout, and a bit of history as to where the layout came from. Then we looked at how to get started with ConstraintLayout, and we added basic constraints and did a walkthrough of the Layout Editor. We then went on to looking at different types of constraints that can be created; normal or standard, top, bottom, start, and end constraints, center constraints, and baseline constraints. Finally, we looked at how we can use horizontal and vertical bias to position a view with a tendency towards a certain side of a view. We then looked into using chains by creating horizontal and vertical chains in our layouts. We also learnt about the different chain modes, such as packed and spread. We learnt how to optimize our layout files by grouping views together and controlling visibility of the group. We also removed duplicate margin values by creating guidelines and aligning views to the guideline. We then took a look at some of the more advanced features of ConstraintLayout, such as barriers, ratios, and circular positioning of items, and finally, we covered some tips and tricks to working with ConstraintLayout by working with wrap_content, the pack and expand buttons, the layout optimizer, and the Convert to ConstraintLayout tool. So where to next? Hopefully this course has given you more insight into working with ConstraintLayout, and you feel comfortable to create a layout using it. I encourage you to try and create more complex layouts using ConstraintLayout, and the different features that you have learnt in this course. Please take some time to rate this course on Pluralsight and share it if you have found it useful. Thank you very much.

Course author
Author: Rebecca Franks	
Rebecca Franks
Rebecca Franks is an Lead Android Developer. She has over 6 years experience in developing
 Android applications. In March 2016, she was awarded with the status of Google Developer Expert for...

Course info
Level
Beginner
Rating
5 stars with 69 raters(69)
My rating
null stars

Duration
1h 25m
Released
24 May 2018
Share course