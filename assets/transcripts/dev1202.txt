Infrastructure from Code: The Big Picture

by Jason Helmick

Infrastructure from Code removes human related problems by providing management and provisioning of the Data Center through machine read configuration files. This provides a repeatable, recoverable and often times, more secure Data Center.

IT Ops has traditionally managed servers and the infrastructure through human actions, which often causes delays and mistakes from updates to deployments. Infrastructure from Code removes the human related problems by providing management and provisioning of the Data Center through machine read configuration files. This provides a repeatable, recoverable and often times, more secure Data Center. In this course, Infrastructure from Code: The Big Picture, you'll learn about the concepts of DevOps, and the process and tools of Infrastructure from Code. You'll delve into learning about automating your processes with a Release Pipeline, how it can shift the performance of IT Ops, and finally a variety of tools to start building repeatable, safe, and reliable deployments. When you're finished with this course, you'll have a starting point to move past this overview and into building your own Release Pipeline for Infrastructure from Code.
Course author
Author: Jason Helmick
Jason Helmick

Jason Helmick is an author for Pluralsight. His IT career spans more than 25 years or enterprise consulting on a variety of technologies, with a focus on strategic IT business planning. Heâ€™s a...
Course info
Level
Beginner
Rating
4 stars with 48 raters(48)
My rating
null stars
Duration
1h 32m
Released
14 Jun 2017
Share course

Course Overview
Course Overview

IT Ops has traditionally managed servers and the infrastructure such as messaging and authentication through human actions, tying up valuable resources and causing delays. Humans also make mistakes and can be slow to recover from them. Hi I'm Jason Helmick, and I want to introduce you to a component of DevOps that can change all of that, known as infrastructure from code. You will learn how automating your processes with a release pipeline can dramatically shift the performance of IT operations, providing a repeatable and safe process for deploying and updating your servers and infrastructure services. In this big picture course, you will understand the four stages of the release pipeline, and be introduced to the available tools for each stage. Now if you're ready to improve your deployment time, and prove recovery time, and lower the failures due to change, this is the place to start. So from all of us here at Pluralsight, we love to learn, and I hope you do too.
Introduction
Introduction, DevOps, and Infrastructure from Code

I want you to think about something, let's say for a second that you had to release a security patch, maybe something like what just happened recently with WannaCry ransomware, you need to get this security patch out, and it needs to go out today. Do you have a way of releasing that to all of your systems, all of your servers, all of your applications in an efficient, fast way? Do you know that you are going to lose maybe a few of those systems, and do you have a way of rebuilding or replacing the systems that you lose quickly and reliably? Let's take the ultimate scenario, which would be let's say that you were to lose your entire infrastructure, I'm talking about everything from messaging to authentication, your database servers, your file servers, your web servers, everything got lost, maybe due to some malware, how long would it take you to replace it? Most companies say that it could take them anywhere from 6 months to even longer to replace all of that, well that's the problem that we want to be able to deal with, we want to be able to replace or rebuild or patch anything that we need to as quickly as possible, and to be able to prove it, to be able to prove that we can rebuild this stuff, maybe we prove it every month, or every week, or every day with daily builds, that's what this is all about, Infrastructure from Code. Now this, the big picture part is that this in an overview so there's going to be a lot of things that we're going to talk about that you can definitely drill much deeper into, but the idea here is to get started on a way that you can start to get yourself into a position where from writing a little bit of code, you can build your infrastructure. And here's what we're going to do in this course. We're going to take a look at the overarching concept here of DevOps, and that's what Infrastructure from Code comes from. DevOps, you've probably heard the term, it's not just a marketing term, it is something real, DevOps has a big impact on businesses and on our customers, and so we're going to start off taking a quick look at what that is, and some of the benefits to DevOps. Now part of DevOps is infrastructure from code, one of the working pieces to it, and while DevOps you're going to find out is difficult to get started with, Infrastructure from Code is not, you can actually start on that, and that's what our focus is going to be on is Infrastructure from Code, and we'll also take a look at what this course covers. So let's get started with DevOps business and our customers. The overarching goal of DevOps is really people, people and the culture in which they work in, because there's challenges there, so what DevOps does is it aims to break down the barriers that would prohibit us from delivering systems and products into production safely and rapidly, and I think you kind of know what I mean, especially between developers and IT operations. Take developers for instance, they want to use an Agile process by which they can deploy features to their application as quickly as they can, maybe it's a web application that they want to be able to roll these features out to customers both to benefit the customer and benefit the business, well but they can't do this in isolation, it requires the IT ops guys to provide the web servers, the database servers, and all of the little infrastructure pieces that are necessary in between, but what happens oftentimes is there's a breakdown, IT ops is not used to moving rapidly and doing rapid deployments, and a lot of times a developer they will release their application, there'll be some sort of problem as it goes into production, and if you've done this you know darn well what I'm talking about, and then the finger pointing starts where the IT guys say well it's a problem with development stuff, and the developers guys will say well it worked fine in test, it must be something with your network, and this is not what produces good results, both the customers and the business leaders, they don't care whose problem it is, they want it solved, and so wouldn't it be better if as a team, both developers and operators and security professionals, everybody that needs to be involved, wouldn't it be better that instead of having these silos that separate us, that we could break those down, have team-based communications, and solve the problems together. I know it might sound like a strange concept, but that is really what the goals of DevOps are. And I mentioned Agile, DevOps and Agile are, they go together, DevOps takes more of the side of how do we get the people to communicate so that we can do an agile approach, so if you're a developer and you're familiar with Agile, DevOps is all about that as well, but also steps back and says hey there's more to this than just you the developer. And as far as DevOps overall, when we move into Agile, what our focus is going to be is on Infrastructure as Code, and I'll get to that in a sec. DevOps is implemented in a top down approach, and I just want to kind of tell you that if you're in IT ops and you're thinking well I want to implement DevOps because it sounds really cool, that's not going to work, it's a top down approach that has to start with a leadership, because remember it's about the people and the culture and breaking down those silos, and only the leadership team can start that process and implement the changes that are necessary, so it's got to be top down. Again, the focus for DevOps is people and culture, and once that's handled we can start to move towards processes, processes like automation, and what we're going to talk about, Infrastructure from Code, and those processes that can move us forward. Now you're going to notice that as we start to move through Infrastructure from Code, that it's going to start to bring up tools, and we kind of like to position this that people come first, people are always first in DevOps, then those people, as they break down those barriers, can work on processes together, those processes then they can start to implement the tool sets that they need to make those processes work, and those tools are going to be a wide variety of tools, there's no such thing as DevOps in a box, so these tools are going to be a combination of things that might be more beneficial to the type of operating system that you're using, whether it's Windows or Linux, the types of applications, your infrastructure components, so these tools could be very unique to you, and that's why there's no DevOps in a box. Now the benefits to DevOps, and this might be one of the things that you really want to kind of focus on overall, what do you get? Well, it's what you and the business gets out of this, and I'm taking information out of a report, State of DevOps Report, done by Puppet Labs, and this is the 2016 report, and you can go to Puppet Labs and read the entire report for yourself where they go through and they interview companies to get these kind of numbers, but here's the kind of things that they found. Companies that are implementing DevOps, that have gone down this path, that are being successful at it, are 200 times more frequent with their deployments than companies that aren't. Now image that, image if you know your business says well we need to expand our web farm because we're going to release a new product and we need more web servers and more database servers, we need to support you know the websites to a greater number of customers, when can that be done, and traditionally the answer is weeks or months down the road, what if that could be, well we can have that done in a couple of hours. That's what I mean, 200 times more frequent deployments, 24 times faster recover from failures, and if you think about some of the failures that you may have experienced where if you lose a system and then you, it takes a, somebody troubleshoots it for a couple of days and then you have to decide to rebuild it and then when you finally decide to rebuild it you've got to through this run book that somebody wrote out that's out of date, and you try to rebuild it and it takes you know days and days to finally get it, what if you could recover from this in a reliable known way in minutes, or just a couple of hours? That's really what the point is to all of this. Three times lower change failure rate, in other words we need to send out changes, we know that there's going to be a certain failure rate to it, but we can constantly work on reducing that failure rate. Twenty-two percent less time on unplanned work, and you know exactly what I'm talking about here, you know it seems like every time we turn around our hairs on fire, something else went wrong, well as you gain more control over your environment, as you turn it into a controlled, reliable environment, that starts to decrease. And 50% less time remediating security issues, and as a security guy, boy that's a really big impact. So, you might want to kind of focus on DevOps, but I do want to point something out. When we take a look at our focus, first of all DevOps is a heavy lift, and you'll hear me mention this over and over again, a heavy lift I mean this is difficult, this is not easy, it's very hard to do, because it's a cultural change, it's not just a set of tools that you buy, it's a cultural change, and there's a detailed set of processes that it involved, and then you can add the tools, but that shouldn't prevent you from getting started on this. First of all, if you want to get more of a feel of DevOps overall, there's a great book in our industry that many of us have read several times, called The Phoenix Project, and what this is, is this is a story about a fictional company as they go through this process, and it really kind of impacts you with how important people and culture really is to making this work, but here's what we're going to do and what our focus is going to be. First of all, I'm going to mainly talk about this as the delivery of an IT infrastructure, but I want to point out to developers that might be listening, this is a, is almost the same process that you would be going through, if not the same process you'd be going through in the delivery of an application, such as if you were using Agile, so our focus is not going to be on DevOps, but a part of DevOps called Infrastructure from Code. Now I just want you to know you'll hear this from a couple of other titles, if you're surfing the web or whatever, you'll see Infrastructure as Code, or Configuration as Code, I prefer Infrastructure from Code myself, just because we're going to be able to write a little bit of code, and the infrastructure will be able to be built from that code. Now first of all I am an IT guy, an IT ops guys, and yes, I said I'm going to write code, that's my part and my contribution of being part of Dev and Ops, I'm actually on both sides of that fence. So here's what we're going to do in this course. First of all, we're going to start off with infrastructure from a code with something called The Release Pipeline, that's the process that's part of DevOps that we can actually start with today, and we can start building on. Now you're going to see that this is pretty extensive, and I'm taking this as an overview, so each time that we drill down on this, there's much more deeper information you can gain, but I want you to get the primary concepts out of what The Release Pipeline is, and it's broken into four stages that we're going to separate. It's broken into source, build, test, and release, and at each one of these stages, different things can occur, you can have different tool sets, different people may be involved in the process, and that's why this whole process together requires great communication. And then what we're going to do at the end of the course is I'm going to have a final word, and what I mean by this is yeah, it's a little bit of a review, and some kind of tips and all of this, but really what I want to focus on in the final word is how can you get started if you wanted to start with getting control over some parts of your infrastructure, what might be a strategy for you to get started with? And with that, we talked about the overarching concept of DevOps, and that our focus is really going to be on part of that called Infrastructure from Code, mainly from an IT perspective, but I'll also point out developer perspectives as well, so what do you say we get stared with our next topic, Infrastructure from Code: The Release Pipeline.
Infrastructure from Code: The Build Pipeline
Introduction

In the introduction of this course I started out with a scenario, you know what if you lost your entire infrastructure, how long would it take you to recover from it, and it doesn't have to be that, that drastic, that dramatic, it could just be things simply from okay you need to send out an update, or a security update, or you need a couple of new web servers, how long does it take to make changes, or to get changes, or to do new builds and to replace servers? That's where Infrastructure from Code, and The Release Pipeline is something that can start to help you with that today, and it's, the idea is this, is that we want to have a process of managing and provisioning our infrastructure using a machine readable definition, something that is something that we can, we can see, we know what defines our infrastructure, that can be applied through some automation service to the machines, the servers, which could be physical servers, they could be virtual servers, and some sort of hyper visor, or even a cloud service, maybe a cloud service could be Microsoft Azure, you know Amazon AWS, maybe Oracle, whatever that is, you can still deploy this infrastructure, you can still update this infrastructure, and that's what we kind of want to take a look at. So an overview for what we're going to do here is we want to look at what is a pipeline to begin with, what is the purpose to having this pipeline, this Release Pipeline, also, how does this impact customers? Now you probably already can imagine how this impacts customers, and we started with that, you know looking at DevOps overall and the impact that it can have, and then I want to start to break down some concepts for you. We want to take a look at something of, like the configuration, how do servers get configured in this new world and in this new way, and how would I deliver that configuration to them, what, in other words I'm going to write something in code, kind of code, it's not like programming in most cases, it's easier than that. I'm going to deliver, take this configuration, I need to get it to those target servers so they can get that configuration, how do I achieve that? Also, we want to start to take a look at the components of the pipeline, just a general breakdown of those components, and something called Continuous Configuration Automation, this is where we start collecting in the tools. And I also want to stop off and I'm going to do this twice, here and in the final word at the very end of the course, talk about a new view of the word failure, this word that sends chills up and down our spines, especially when we're doing any kind of change to our environments, let's take a new view of that. So let's go ahead and get started with The Pipeline.
The Pipeline

Let's start off with the concept of the pipeline, and really what the idea here is it's a workflow of moving a project through stages of work to completion, and the idea is by following this pipeline, which is a set of processes including tools that we've agreed on using, that we can work together with, we're going to able to consistently move projects through the pipeline out to release. Now if we're doing this correctly, this means that we're going to have tracking, we're going to have testing, we're going to have versioning, and we're going to talk about all of these components of it that you'll see that makes it so that we can be consistent and reliable every time we move something through this pipeline. Now I want to give you that there are some common names for this, I'm referring to the pipeline that we're talking about as The Release Pipeline, but in the industry you're going to hear some other names for this pipeline if you're surfing the web, you might hear the build pipeline, which is really common, or the deployment pipeline, the terminology for this isn't that exact, so I just want you to be aware of different ways you can hear about it. Now the benefits that you get from this, both to your business and your customers, first of all let's take a simple concept of change and release management, and I say simple because the concept is simple, but you know as well as I do that in practice this can get very challenging, the idea is that every time we need to make a change it needs to be you know, evaluated, validated, we need to track that the change you know it gets implemented, and we have to test the change, right, let's take that scenario. So we know we have a change that we need to make to let's say our servers, maybe it's some sort of update that has to go out, the first thing that we need to do as responsible IT ops is to test it to see if it's going to cause any failures, so we go out and we test it, and now I want you to think about this, this takes people, resources, and time to manually test this, and so we test, and we test, and we test, and we test and eventually we reach the point of saying okay, we're ready to you know move this along, this change can now get, be made. But think about this, what if I had 50 changes and all of them are high priority, how long it takes to do this, and you know although everybody has change and release management, this isn't necessarily something that's new to Infrastructure from Code or DevOps overall, think about the time involved to be able to supply these changes that get out, whereas if you had a more controllable and consistent process with automated testing, and you automated a lot of this structure, how much quicker this could be handled, which means if you get that security update that needs to go out today, it can go out today. So, that's a much better thing, but here's what the problem is that hard to break, because in our release management, because we've been pushed into waiting so long we've a lot of times done ad hoc changes, we just walked up to the server and made the change ourselves and that didn't get recorded and that's part of the process that if you have a release pipeline, that you break people from doing, and it, then everything gets recorded properly. And of course it, by improving change and release management you improve your overall security, you can get secured updates out and today, one of the most important things is, especially for a security team, is to be able to address those kinds of security things, those kinds of things that they need to handle. Now, an automated platform really brings that to the forefront of being able to achieve that. And then of course reduced recovery time. I want you to think about a just a really quick scenario, let's say that you know you have a web farm, multiple web servers, and one of the web servers, or maybe a couple of the web servers stop responding. Traditionally IT ops guys will take them offline, which puts you into a dangerous situation, you now at this point while you still have web servers up, you are not being able to handle the load, or any additional failures, they'll take them offline, they'll troubleshoot them, they'll try to fix them, they'll do, what if we could just blow them away and build brand new ones within minutes to replace them. In other words, I'm not sure I really care what the problem is, and if I do care I can take them offline but still make brand shiny new ones to replace them with. So, imagine how that helps the business, and certainly helps the customers. And just to reiterate what I'm talking about, Infrastructure from Code, we can build and control all of our infrastructure, and things like our authentication systems, our messaging systems can be configured, content distribution, customer service applications, all of this can be controlled in this pipeline by us and by code, and then when you have these failures that might occur, that will occur, that someday will occur, you can quickly rebuild and replace. And this is not a pipe dream, notice how I worked in pipe and pipeline, this is actually something real that companies have been doing now for years, and that you can get started on this process.
The Configuration

Well now I'm sure you're probably saying, well how is this magic going to work, and it really starts out with the configuration. So, here's the idea. You are going to be able to write a configuration, a simple configuration that defines what you want your infrastructure to look like, or components of your infrastructure to look like. Yes, this is coding, but it's not as hard of coding as you think it might be. Now, what happens is this, most operating systems, both Microsoft and Linux, can read this configuration, so, this configuration cause is read by an automated process that will then do what this configuration tells it to do. And I don't know if you had already known about this but this has been around for a while now, several years, and if you're on the Linux side it's been around for a very long time, but we can give a machine a configuration and it can do all of the work for us so I don't have to manually do it myself. And this has all of the properties that are needed to configure something, so if it was, let's say I wanted to configure a SQL Server, it would have the properties of what's the database server's name, what is the new database name, what tables does it have, but it makes it easier for me to write this configuration by not expecting me to know how to do everything. So, I could actually build a SQL environment, or any database environment, with not being a database expert on building it, that makes this even easier. Now, there is a traditional way of doing this, and we refer to this as imperative code, and what that means is you're writing line by line exactly how to do this, and don't panic I'm going to give you an example of this in a second, but what this means is, is that you need to be intimately knowledgeable about the technology that you're working with, and then you needed to choose an automation language that would let you do this, something like maybe Microsoft's PowerShell would allow you to line by line configure something, and it would be things like you know if the exchange person for messaging, they would know everything that had to get configured, every switch that had to be flipped, every value that had to be added, every component that had to be added, you would write those lines of code, but what we're looking at today is you can still do that, don't get me wrong, but what we're looking at today is a better way of doing this, this is a declarative way, in other words, I want you to think about something. If you were to write an imperative script on how to do something, about a technology you know about, don't you think other people already knew it? Don't you think it may have already been documented? Here's what we can do, instead of writing the imperative way, because it's probably already been written, we can write it a declarative way which says hey, I just want an exchange server, and it would call on the preexisting imperative code that already exists, to do the build for me. Let me take a simpler example of this. Let's say that I wanted to start a car. Now I know that this is kind of silly but this is the, this is the pseudo code way of me showing you how this, how these differences and languages will work. So I want to start a car, the imperative way would be things like this, step 1, open driver side car door, step 2, get in the car, step 3, locate the ignition switch, step 4, insert the key into the ignition switch, step 5, turn the ignition to start the car, slightly press on the gas pedal. So you can see what we're doing is we're going through this step by step by step by step, and it basically means that I need to have intimate knowledge of how to start a car, but take it from somebody that might not know how to start a car, but they just want the car running so they can get in it and be driven somewhere, a declarative way of doing this, on starting the car would be this. Start the car, now here's the best part, what actually happens is, is that when you do something declarative, such as start the car, it calls on the imperative resources that are available to do those individual things, it's just from my perspective, when I wrote the code, notice the difference in size of code. I just want the car to start man, that's all I want, so that makes it much easier, so you can tell that the configuration and how we're going to write this configuration is really the focus point of getting this done.
Push/Pull Target Delivery

So once I have this configuration, this document that describes what I would like a particular input structure component to be, and again, whether it be messaging, authentication, a web server, it's a document that will describe, that will go to an automated service on that box, that will then read and then do whatever that document says to do. Well how do I get it there? There's a couple of technologies in play here and while I'm not giving you specific tool sets yet, I'll do that in a little bit that you might choose from, there are different types of ways of deploying this configuration. So if you take a look, I've got a couple of targets, and those target machines are going to receive a document for, of a configuration, to configure them. We have some sort of deployment point, and this could be anything ranging from what we kind of refer to as an authoring box, which could be the computer that you're writing the configuration on, or a server that is going to hold the configurations that deployments can be run from; the question is how do we get it to the targets, because I don't want to manually copy this one by one, that doesn't scale well, I want some kind of automated process. Well one way is called a push deployment, and that's, first of all, that's great for testing, I do this from my machine when I'm writing a configuration document, I will push it to a test target to make sure that it's delivering the results that I want. However, you can also do this as a production level solution. This is something where you might decide that only when I want will these documents get sent to the targets, and that's great, that way you can queue up when you want deployments done, you can do them kind of in a manual way where it's kind of in a manual way where it's more of a push button way of deploying out to several targets, it's still scalable, but you get to control the exact time of when this happens. There's also another way that this can be done, and that's called a pull deployment, and this is just a great overall solution, it's not good for testing because it takes too much time, when what this involves is we have a deployment server, and the targets get taught, and what I mean by get taught is they actually have a built into the OS agent that can be told I want you to go to a specific deployment server, and every so often, 15 minutes, 30 minutes, hours, whatever that is, every so often I want you to go to that deployment server and I want you to grab this configuration document and run it. Now I have to say that it's not going to grab it and run it every single time, only if there's been changes made to it. So, the target might go to the deployment server and say oh that config doc is the same one that I already have, so I don't need to do anything about this, or it might go there and say oh look, this is a change, and now I will accept this new configuration document and run this new document to get the changes necessary. It's really common to do pull environments because think about it, all of the targets, they're not going to slam the deployment servers at the same time, so this scales really well, whereas a push deployment, I mean let's say you're installing big software packages and you did a push deploy, you really have to think about how many targets are you hitting and how many of those targets are suddenly going to try to grab source files, you know what that might do to network bandwidth. While it's all workable, some of it just requires a little bit more planning.
The Release Pipeline

For our purposes I want you to get an overview of what the release pipeline looks like for us. So it starts out with something called source, and this is actually where we start at the beginning of the pipeline, with our configuration document. Then that goes to build, where we actually produce whatever components we need that will be sent to production, so if you're a developer this could be executables, if you're an IT ops person, this could be whatever machine readable file comes from that configuration that we're going to need. Then we go to a phase in the release pipeline called testing, and obviously this is where we want to put as much automated testing as possible so that we can test that our configuration, or that our application if we're a developer, is going to work the way that we want it. And then we go to release, where we release it to production. Now I'm going to give you much more details about these four phases of the release pipeline in the remaining modules in this course, but just to get an idea, our configuration document will start in source, and then we'll go through this process, down this release pipeline, until it finally gets released. By doing this, you're going to see that we're going to get some things, benefits out of this. First of all, we're going to get multiple versions of this configuration file every time it gets updated, and it's going to go through this build, testing, and release process, which means we're improving a process, finding where there's problems in the process. Also, this is what's going to build for us a consistent, reliable release pipeline, so that if we need to make a change today, we know what's going to happen when it gets to release in the next hour, and that's part of it. Now all of this will be controlled by products that will help us with things like all of the automation and the orchestration, and I'll be talking about some of the tools that would be available to you for this, and this is kind of one of those rinse and repeat processes, it's not something that you do once a year or maybe once a month, this is something that you could do weekly, daily, or even several times a day, to get, to be able to make changes and to get a release out, you can even run this with existing known good configurations just to validate that your release pipeline is working, so this is a process with a collection of tools that will make our lives a little bit easier.
Continuous Configuration Automation (CCA) Tools

Since we just looked at the process overall that we're going to drill in a little bit more into, and we started to mention tools, I wanted to talk a little bit more about those tools. Now a term that you're going to hear that can refer to this is Continuous Configuration Automation Tools. Well, that's a lot to say but that's how you might see it as you're surfing the web, this is oftentimes referred to as the DevOps Toolchain, and what the idea is, is this. Remember with DevOps, people, they come first, and the culture, and tearing down those barriers. Then we move to a process, and the processes that are wrapped around things like Infrastructure from Code and a release pipeline. Well that process, which we want to automate as much as we possibly can over time, that's going to require a set of tools and toolchains, and the ideas is that these are the tools that will help you do the automation and the orchestration, but there's some things you've got to be aware of. People like to think that they're just going to be able to buy a product that's going to do this, and that's not the case, these tools are going to be specific to your platforms, in other words, if you're running Microsoft Windows, if you're running different versions of Linux, different tools will have a different impact, and not just the tools, but the languages that you write this automation in will have a different impact, that's one of the first challenges in building your tool sets, and then you need to make sure that those tools met your security and compliance needs, you might find a great automation tool that is clearly not going to meet your particular security and compliance needs, so that's one of the challenges in building out this toolchain when you're working with a release pipeline. Now, just to give a couple of examples, you want tools also that will scale, in other words you don't want a tool that you know, that gives you only the ability to modify one thing on one box at a time, you want to have tools that can get you to a release point, to as many servers in the case of IT ops as you need to be able to get to, I don't want to hit just 10 web servers, I need to be able to hit all the web servers, and so the tools need to scale. Some of the tools that you'll hear me mention as we start to drill down into the other components are tools like Chef, Puppet Labs, which I've already mentioned, Ansible, SaltStack, these are tools that can help you with different parts, or maybe multiple parts, of the release pipeline. Now, how are you going to evaluate what tools you need, well, that's part of the challenge is you should evaluate all of the tools, it doesn't take that much to evaluate those tools, to spend some time getting to know those tools, to figure out which ones would fit best for your environment, because everybody's environment, as it turns out, is unique. We were always told don't look at it that way, but it is that way, and so what might work for one person that you talk to might not work for you, you also already may have some of these tools in place, and so you want to build off of what's existing, so as we go through, looking at more details about the release pipeline, I'll give you some ideas on tools, but remember, I'm just giving you ideas, there's a lot more out there.
A New View of 'Failure'

I want to talk about a topic that's not going to be easy to talk about. If you're a developer and you've been practicing Agile already, you're probably more comfortable with this concept, whereas a lot of IT ops folks are not comfortable with this, and it's failure. And you know exactly what I mean, the reason you don't like to make changes and that it's so nerve wracking to make changes, is because you know things are going to break, and then you're going to have to recover from that, and so not only is it that things are going to break, but you have to make sure you have all the recovery procedures in place, that the recovery procedures are tested, that things will work, and then you have to schedule a maintenance window when this can occur, when it has the least impact to business and customers, and we always dread those weekends. This is really due to an inconsistent set of procedures, no automation, or very little automation, change control is haphazard, in other words we may have a change control board that we go to, but because changes through the board and through testing take so long, we still have admins walking up to servers and making changes directly that aren't getting tracked, so when we do testing we're not even sure if we're testing reality. When we go to real life, well we tested it and it still broke. Well yeah, because you've been doing ad hoc changes, so IT ops managers, we're slow to make changes because we're afraid of things failing. Well, this is where a new concept kind of comes in on this view of failure, and if you've been doing this for a while, you believe in this with great fervor. In other words, Infrastructure from Code provides you a reliable, repeatable process where you can get to release from a known configuration document that goes through testing and you can get to release. Now, you might be saying okay but what happens when things fail? Well that's just it, since as you're going to see, we have a previous configuration that did work, we can always roll back to that previous configuration. So recovery can be a lot quicker and easier, it can even involve, as you're going to see a little bit later, we don't care that it blew up, we just replaced the entire box or application with a new one from an older config that did work and then we can troubleshoot it. In other words, we raced to failure because we want to know what is not right in our pipeline. So for instance, if I make a change and it goes through testing, as you're going to see in a little bit, and testing approved it, and as it leaves testing it suddenly breaks in production, that means there's something wrong with one of my tests, I need to fix a test. It learns as I do this over and over again, my testing procedures get better, my rate of failure starts to decline, so I get faster, more agile, and the rate of failure gets less. Now I know it's still a hard concept, I don't want to send an update out to a messaging server in the middle of the day and risk shutting down email, but here's something I want you to think about, we've always caused failure, in other words, we've just been trying to hide it, and do it you know when nobody can see us or when we have the least amount of impact, but we've always broken stuff, the question is now can we break it and fix it faster and then learn from that failure and get that into the process, improve the process. I know it's a kind of a tough concept, it's one that even you know when I started it was like oh I don't know about this, but it actually works, however, until you get to this point of having a good release pipeline, it can be a little bit painful in the failure department. A term that you will hear often, rush to failure! In other words, when you start to trust this process and how it works, you'll actually take the attitude of yeah, I'm going to rush to failure because I'll be able to improve my failure rates quicker the more often I fail. Yeah I know it's a tough topic. Well anyways, so what we've done in this part is we looked at what a pipeline was and how that impacts your business, and some of the basic concepts of it, we're going to start with a configuration, a document, that we will write the code for that will define the configuration that we want when it gets released out to a server. We talked about some delivery mechanisms, being able to push and pull then push, I prefer for development, and I like both push and pull then in production. We talked about some of the components of the pipeline, and of course building up some of the tool sets, and a difficult concept is the new view of rushing to failure. Well having said all that, why don't we start to break the pipeline down and get started with some more details on the first stage in the pipeline source.
Stage 1: Source
Introduction

Let's say for a moment that you needed to write a document, a report for something that you were working on, when you were writing the report, do you occasionally you know write a couple of paragraphs and then maybe save that off, because that's really good, and then you'll edit it later and save off a different version, or let me put it this way, maybe you already do some automation, maybe you do some scripting, so you write a script that does something, and it works, it works great, but now you need to change the script to add something else to it, maybe a new feature that you want added in, do you save that original auth, just in case it breaks, so that you can roll back to it? This is the concept behind source, or really what we're talking about here is source control. Now, developers, they've been doing this for a very long time, this is a way for them to you know, roll back to things if something should go wrong, but IT ops has been a little bit slower to embrace this, and I'm really not too sure why, because as somebody in IT ops, my code, the code that I write, is just as valuable as a developers, and I want to be able to roll back to, and that's just one of the features of this, but this is the concept of what we're looking at, so when we're looking at creating our configurations, we're looking at the idea of putting them into source control, and so this is what we're going to do, define what source really is, and then we're going to talk about something, another term that you'll hear for it besides source control is version control, but specifically what versioning is, and then something that might be a part of source as well, which is code review. So what do you say we get started with defining what is source?
Defining What Is 'Source'

What goes into source? Well, your code. But it's not just code, it's also any supported files necessary for that code. If you're a developer, you've got additional maybe binary's or something supported for applications, if you're doing work with infrastructure, besides the configuration itself, that configuration document, you may have additional resources, maybe blocks of code that make that configuration work. So, it's not just the configuration document, it could be a lot of things, and this is going to be stored in, well, predominantly a database, it's going to be stored in a special place, not something like a file share, I know especially as IT ops we're used to, you know we'll set up a file share and throw some documents in there, we need more function and features to this, we need more capabilities than just a file share, because, when we store that code, we want to be able to be able to update that code and document those changes, that's what source control really is. Now we're going to talk about it from the, the term of version control, and I'm going to show you how that works, but the idea is, is every time I update it, I want a new version, that's really what I want to do. This way, if something breaks, I can always roll back. This isn't really a hard concept, I mean you may run across products like share point that on your documents, like a Word doc, will let you have different versions, but we're going to get more details out of this, because as you'll see, we can even store a history of document changes as well besides just the versions. Now some of the products that could be used for source control, some of these you may already have in your environment, so things like GitHub or Apache Subversion, Microsoft Visual Studio Team Foundation Server are examples of source control, and here's the way I like to look at it is, is tools are unique to your environment, if you already have a development team, and they're already using something like Visual Studio Team Foundation server, well then that's probably the source control product you're going to stick with and that you should start working with. If you don't have any source control products in your environment, then you're going to have to start to research some of these to see what would fit best with what you intend to do. And one way that I'm going to try to keep this picture moving forward for you is I want to throughout the next few modules show you the release pipeline and the part of the release pipeline that we're looking at, in this case source, and some of the products that you might consider looking at. There are more, you can do some research on them and see what might fit best with you, and so yes, as we continue through I'll be drawing out the entire release pipeline just so that you have a nice visual to keep in mind as you look at these particular phases of the release pipeline.
Version Control

So one of the primary concepts behind the idea of source control is a centralized place where we can put all of our documents and anything that is needed by out documents, and that we can start to do versioning on that document, from the very inception, or the very beginning of the document, throughout its lifespan, so that we can understand what the changes have been. So, here's an example, let's say this person creates the very first, in our case configuration document, when they check that in or commit that, and notice I'm using a couple of different terms, depending upon the product you work with, they'll have different terminology for putting it back, or putting it into version control, check in, commit, are great examples, that becomes, let's just say version 1, and I'm going to use very simple versioning. If you're into semantic versioning or something like that, I'm just using very simple versioning for this. Well let's say that this person originally created the configuration, but another person has now checked out, or gotten that configuration, and needs to make changes to it, so that person makes changes to it, and they commit it, or check it back in. That creates a new version. Now there's a couple of benefits to this. This is why this is better than just a file system, to have a true source control system. First of all, we're going to track who's making changes, so we know who these two people are, we know when these changes are made, and let's say that this document, version 2, continued down the pipeline and failed test, we know who to notify that the test failed, and not that this version should not be used. Or let's say that it did get approved by test, went into production and failed, again we can trace this back, not so that we can blame somebody, but so that we can solve the problem, and in a worst case scenario, let's say it went to production and something broke, we could go back to version 1 and release that out to production to get back up and running. Maintaining this history from the very beginning all the way through its current config is very important, but I want you to imagine something, you could imagine that with version control and with a source control system, since it supports having multiple people work on it, well what could possibly go wrong/ Let's say that two people are working on the configuration document, specifically on the same configuration action, it could be a group. 000 policy setting, they're both trying to change the same group policy setting, it could be, let's say it's a feature on a Windows Server, one person is saying I want to install a web server, the other person is saying I want to remove the web server, well this is an obvious contention point, and if you didn't have great source control, you might not know about this, it may not be realized in the change management when you go through your change management process, that you've created this conflict and that this document actually went out this way, or different versions of it went out this way, that would obviously cause problems, so along with a source control we can check for contention, and get alerts on this and resolve what would be contention so that we can resolve that and then get in the correct thing that we need for the versioning. The concept behind this is one of the most paramount parts of source control, is being able to roll back to previous versions, be able to have a history, be able to know who is making the changes in a controlled environment. This is directly different from what a lot of IT ops professional have experience when they've been writing their own scripts, maybe they've just been doing their own thing all by themselves, or maybe a couple of people have tried to write things together but they keep bumping heads with each other, that's what this is supposed to help you with. So when you're thinking about looking at source control or version control system, a couple things to keep in mind, it's definitely much better than just a plain old file share, and while you know there are products like share, Microsoft SharePoint, it may not have the granular control that you need so you want to have the ability of tracking changes, conflict resolution, maintaining a history of all of those changes from the very beginning, all the way out through the different versions that have hit production, and it needs to identify who made the change and when was the change made, again not as a finger pointing exercise, but when something does go wrong, we need to know who to see about it so we can get it fixed. And again, it wants to support multiple team members and in supporting multiple team members as I just mentioned, that it can help identify and resolve conflicts. But besides version control, there's something else you might want to think about in the source or source control stage.
Code Review

There's another concept that might be part of the source stage, and I say might be. It's actually an important concept, but it could also be done at a later stage, so I just want to give you the idea right now in case you start thinking about this. Something called code review. Now it's really common practice, especially a long time ago, that when a developer would write code it would get reviewed by let's say their manager. What this review is that it's being reviewed that the code is following proper best practices. There's a reason for the best practice, this includes how the syntax is written, any features about how the particular company likes to have parts of code written. The reason for this is for maintainability. It's kind of like handwriting, everybody's handwriting is completely different, well we don't want that when you're writing code, we want the structure of how you're building things to be the same because you're not going to be the only one working on that code, somebody else is going to work on that, and if everybody's doing things their own way, it's really hard to keep that code maintainable, so we want a certain structure to be followed, and this is what is checked with code review. Well of course today we have automated ways of doing a lot of basic checking for code review, if you happen to be somebody that works with PowerShell, we have a PowerShell best practices analyzer that'll do this, Visual Studio will do this, so there's a lot of ways to have automated check in. One of the things you might do is in this source control phase, before somebody is permitted to check in or commit a document, it might have to go through that code review stage where it's checked to see if it matches all of the patterns and practices that the company has established for a good piece of code. Then when it's checked in, that becomes the new version. If it didn't pass code review, it didn't get checked in, it got kicked back to whoever wrote it, with you know some messages on you need to fix this, you need to fix this, as I said it doesn't have to occur at this stage, it can occur at a later stage, but some people like to do some basic code review right up front. And just some notes about code review, it can be done prior to check-in or commit, it's checking for those best practices, it can be manual but boy that's really not how we want to do this in this pipeline anymore, we're trying to remove things that are manual and automate the most that we possibly can. It assures that the code is maintainable, so it is an important part of the process, but it can also be done commonly during the test phase that we haven't talked about yet, and you'll hear a common term about this known as linting, this comes from the Linux side of doing the code reviews, so you'll hear a couple of different terms about it, but like I said, it could be done here, it could be in testing, it could be a little bit in each. And with that that brings us to the end of this particular discussion on source and source control, including, specifically, what is version control and what's a code review. I think you'll find that working with a source control system is very beneficial, even if you're starting with something as, I want to say as simple as GitHub, or working with something that maybe your company already has in place to be able to start to put your things into source control, because your code is just as important as everybody else's. Also keep in mind that there are different positions in the pipeline that you can start working. You could start writing configs today, and pushing them out to test targets, and not have any source control in place yet, that's okay, the idea is though, once you're done doing some initial testing and you like what you see, you'll start to move to having source control, especially since that's the first stage where everything begins.
Stage 2: Build
Introduction

The build stage is where we're going to take what we put into source, our configurations that we have there, and turn them into machine readable, usable configuration documents. So, if you are an app dev, this would be where you would actually compile your code, your build server would make the executables or the finished product that could now go further down the pipeline towards release, and that's really what the idea is behind build. Now as an overview, of course yeah, we're going to take a look at turning code into product, we'll look at how the build stage might get triggered, there's a couple of different ways that you could trigger this besides manually, and we'll look at that, scheduled versus manual builds. So let's dive in with turning code into product.
Turning Code into Product

As I mentioned from the outset, the idea during the build process is to turn your code into your product. Now, this means that a simple build server might do very simple things, might just take your scripts, which as an example if you were making a config for Infrastructure from Code with something like Microsoft DSE, that would be a PowerShell configuration script, and it would then turn it into what the end result is, in this case it would be what we call is a MOF, is the machine-readable configuration. If you're an app dev, this is when you'll get your binaries, and be able then to continue down the pipeline. Now I just want to say that this can be a very simple build process, but it can also get quite complex. Part of this build process, before you move into the next stage of testing, might be to build an entire virtualized environment to run the configuration against so, in some cases while that's kind of bleeding into the test stage, some people look at their build as, for especially Infrastructure from Code is, yes, I'm going to get my machine readable config, but I want that config to run against a machine, which means you need to have virtual machines. That means you have a longer build time, and you need to take that build time into consideration. Now a couple of other components. Now the build server and the build process connects to source control, that's the whole idea, because I want you to think about this, as, as I'm making a change to a configuration for Infrastructure from Code, or if a dev is making a change, we want that change to then be built into a product so that it can then move down the pipeline and be tested. So, we want to detect this. So since it's connected to source control, it can certainly be triggered to start the build activity, and we're going to take a look at a couple of triggers in just a second. Before we do though, take a look at our release pipeline picture so far. We've got source, and now we're looking at build, I gave you some product ideas that you might use for source, but if you take a look at build, here's a few others, Team City, AppVeyor, Jenkins, Microsoft Visual Studio, and there are others that can be a part of your build process. Now a part of this build process, since build is connected to source, is how are we going to trigger this, how are we going to have the build process start in an automated fashion, rather than manually somebody going oh hey I noticed the source got updated?
Triggering Build Activity

Since the build stage is connected to source, let's take advantage of that, and trigger build whenever we can. Especially automated whenever we can. So I want you to think of the build process as part of the orchestration that can be controlled and triggered by you depending upon your needs. One of the ways is, is a WebHook, it's basically a web service call from source to start the build activity, so I want you to keep that in mind, it's coming from source to the build activity. So as soon as you update the source, that may get triggered. Another way, oh and a couple of products that will help you with that, AppVeyor, Travis CI, another way to do this will be to pull back to source. Now there might be a little bit of delay in this, so depending on what your polling interval is, but that also may not be a big deal, in other words, I've updated a configuration let's say, or I updated an application, I don't necessarily want this to build immediately, depending upon resources that are available, and we're going to talk more about those resources, so maybe I want this to be on a polling interval that may occur once a day, maybe twice a day, or once a week, whatever that polling interval is, and something like TeamCity and Jenkins can help with that, but there's another piece to that, and that's talking about doing this build activity based upon whether you want it manual, of if you want to have it scheduled. And this is kind of you know unique and challenging because all along I've been talking about the whole goal here is to automate as much as you possibly can in the release pipeline, and here I am talking about doing things manually. I want you to think about a couple of things, first of all, you can, builds can be regularly scheduled events, so you can schedule them to occur like I just said, once a day, once a week, once a month, and you can do that for different types of operations, maybe there are basic infrastructure things that you know that you're working with that you want to get builds more often of, there's other infrastructure pieces that don't change much over time, and you may not need to have the builds happen so frequently. What's making this decision? The resources required to do the build. So, builds can be manually triggered when required, here's the idea. If your build process means that you also have to spin up brand new virtual machines and apply a configuration document to it, that requires resources. Doing that every single day, or a couple of times a day, you may not have all those resources available, because think about this, you're not just doing one thing with the configuration document, you might have 50 different configuration documents controlling 50 different parts of your infrastructure, do you want all 50 building all of the time? So, this is why you can decide between when do you want to schedule it, or do you want to trigger it manually for things that might require larger builds, that require more resources, maybe they don't change often, you might want to do this manually. So this is one of those times when you know leaving it at manual might just be the best thing to do. And really, that's pretty much, for the build stage, as far as that we're going to take a look at. I've given you some products to take a look at for that, in that build stage, and it's really dependent upon what you're doing in this build stage, which depends upon how much processing, how many resources do you need, if you're just you know turning in a config doc and do a machine readable document, that doesn't require any resources, but if you're actually building up a virtualized environment to apply those documents to, if you're deploying, if you're setting up an app and you're building the app into executables and also want that into being deployed into servers so that you can move into testing, that may increase the process. I also want to point out that a lot of times the actual building of the virtualized environment for testing is done in the testing stage, so you know you may have it a little bit in the build stage, you may have it more towards testing, which is usually where I prefer to try to have that done.
Stage 3: Test
Introduction

The testing stage, this is the most important part, testing, yep testing. Think about what we were talking about earlier. You know when you're trying to make changes to your infrastructure environment, there's the challenge that we face is that we need to test those changes, so I go off and here's a change I want to make, maybe it's a patch, I need to test it, I try to test it on things that might be close to what's in production as best as I can, but I'm not necessarily testing every version of every OS and every patch level. Well that's one problem. The other problem is it's tying up a resource, a valuable resource, me, in doing that testing, and I have to go through and do all of this. Now, if I have 50 different changes, and I have to tell you, when I'm writing a configuration up, I might have 50 different changes, I have to go through each one of those, think about the amount of time that that takes to roll all of that out, so the bottleneck then becomes the testing, and as I mentioned, this is when out of frustration and out of maybe a fire that's going on, some failure, that an IT ops person will walk up to a server and make an undocumented change that is not a part of the release pipeline, it's not in source control, we don't' have a history of it, it's not getting documented, therefore, moving forward, we don't know what's going to happen to that environment, so it just turns into a mess. We want to take a look at ways of automating this as best we can, and that's really what the goal is, is to do as much automation as possible here. And so what we're going to do is kind of take an overview here of testing versus the concept of monitoring, not that monitoring is bad, it's just some people use monitoring instead of testing and that's not good. We also want to take a look at something called test driven development, and what that means, and the approach to test driven, just an example of it. So let's get started with testing versus monitoring.
Testing Versus Monitoring

Testing versus monitoring, and again I'm not trying to make one sound bad or something, they're both needed, but we'll talk about that. First of all, testing as I mentioned is the most important part of the process, and I'm pretty sure that you would agree whether being a developer or IT ops that the most important thing to do before you get to release is to test that you're not breaking stuff. That's part of reducing our failure rate as best that we can. The better our testing process is, the more comprehensive our testing process is, the better we'll detect when something is not right. And one of the things we can do during this testing phase is, well, we can have some orchestration in here, a little bit of workflow, if the test fails kick it back to the person that made the change and say hey look, this isn't going through. So this is a very fundamental important part of the process. Now there's a couple of concepts here, functionality is tested in isolation and then often moved into test environments for integration and acceptance testing, and what this means is, is that as I'm writing a configuration, let's just say for Infrastructure from Code, I'm going to write this configuration, and I'm going to send it to my own localized test environment. It's probably going to be a VM, I'm going to see if the feature or whatever it I'm trying to configure in infrastructure is getting configured properly, I may have some simple automated testing that I'm using to check for this at this point, I could even be manually checking, but this is a localized test environment. This is so that during development things go wrong and I can clean up as much as possible. The problem with this localized environment is it's probably, in the case of me doing it to a VM, it's probably one specific version of an operating system at a very specific patch level, and it may not necessarily have all of the other components on it, because I'm just not aware of those other components, I didn't write the full configuration, or other configuration components that may be applied to this in production. So then what we do is after localized testing, then we check in or commit to the source stage. It moves through build, and it goes to test for integration acceptance testing, and this is where we might be doing things, in this case of a configuration, of spinning up multiple versions of the operating system at multiple different patch levels that may also include additional configuration components to validate that this is going to work when I get to production, so it's important to understand the difference between localized, and then when we actually get to the testing stage. Now monitoring is great, we should always monitor, and there's a lot of great monitoring products out there, but the point to monitoring is, is that it's checking for problems after you've already made the updates, or the changes, and a lot of times, in leu of testing, this is how people, IT ops folks in the past, have known whether a change has worked or not, they'll send a change out and they'll watch their monitoring solution, if their monitoring solution says yeah it looks like everything still works, and it looks like email is still moving and it looks like this web server is still responding to user requests and we're not getting any errors from anything, that's how they assume that it worked, or just the opposite, they'll send out a change like to a web server, and the web server stops responding. Okay well don't send this out to any other web servers right now until we figure this out. Monitoring is great to find out if something is going wrong, but testing first is the proper way, and the better your tests are, the better off you're going to know how it's going to look in release. So, the point being is that monitoring all by itself, it shouldn't be a replacement for your test automation, and note the word automation, we want to automate these tests and we want these tests to be very thorough when we do it. And here's what this is going to look like in our release pipeline, source, build, and then we move to test, and the products that we've brought up some ideas for products for both test and languages for test, ServerSpec, Chef InSpec, a great language if you're working with Windows is Pester, one of my, I just personally like this product, Test-Kitchen lets me spin up full environments of multiple operating systems, test Vagrant, is a great testing platform, especially localized, so there's a lot of products out there for testing, and a lot of different ways of achieving this goal, but let's look at this idea though, especially if you're using a language, a test based language, to write tests for your configurations, let's look at something called test-driven development.
The Impact of Test Driven Development (TDD)

So let me throw a strange concept out to you. First of all, here's how normally people would think about this. If you've written any scripts, or any code, or if you're a developer, you have a tendency to have what functionality you want it to do in your head. So you write the code, and then you start to test the code, or you write code that will test it for you, that's automating it. This is actually the backward approach to this. Test-driven development means you write the tests first, then you write the code, it does sound strange to begin with, and I have to tell you, when I first started doing this it was kind of strange, so let me give you an example from my perspective. I want to do Infrastructure from Code and I want to write a configuration document that configures an exchange server for messaging. I would normally dive in, write the configuration for exchange, do some localized testing to see that it worked, and then I would write an automated test to test that automatically so that I don't have to do it again. That then would go into my test stage. Well that's kind of backwards, so we have a different way of thinking when we're developing this. The tests get written as small units before you start to code, so here's how I do this today, is I would write the test in Pester, it just happens to be, I would write the test first for the results that I expect, then write the code and then run that test against it to see if I got those results. And if I needed to, make modifications. So as, this is just an overview, but as you start to look at this, one of the important things to start to consider is how are you going to build your tests, and if you're going to look at a test-driven development approach. Now let me just kind of give you a breakdown to what the approach would look like in a simple kind of pseudo way of looking at it. The first thing you do is you add a test. Now, this may have been added to a series of tests that already exist, so you've got to check all the tests to make sure that the test that you added didn't break any of the other tests, or weren't in conflict with any of the other tests. Then you write the code for that new test that you added. So then you run the test against that new code and correct your code as needed, or refactor your code, clean it up, and then you repeat the process. Again, if for a lot of especially IT ops people that have been automating things with scripting platforms, this seems to be backwards, but actually when you start doing it, and you know at first it does feel backwards, but when you start doing it and you're writing the test, what you do is you learn whether you've really thought through how this code should work, and you really do want to start with really small units, you don't want to say you know I'm going to write a testing platform for all of exchange, no you just want to take one special unit at a time like the HTTP request to get into the OWA website, you want to write small tests one piece at a time. So as we said, the testing phase is the most important, that doesn't mean you don't monitor, but monitoring is what happens on the production side that can tell you if something else has gone wrong, and is an important piece to this, but we want to have a strong testing phase. And also consider this test-driven development approach for test-driven development. Now again the most important idea is in this testing phase this may include part of a build process, where you're building large virtual machines, so when you're thinking about this, you also have to think about the impact here of resources as well; just like we talked about in build, build might be really simple, but test might be getting really complex, gave you some ideas of some of the test products that are out there, that depending upon what you need to test and how you need to test it, those products can help you achieve those goals.
Stage 4: Release
Introduction

The last stage in our process is release, and this means different things for different people. For an app dev, a developer, release might mean you know copying files out to a web server and the new website comes alive, for an IT ops person, this might mean the same thing, or it might actually mean building brand new machines out in the infrastructure, and applying a configuration to them. So, this has a little bit different meaning, therefore there's going to be different processes that are going to be unique to everyone in part of this release stage, but that's what we want to take an overview of right now. And, what we're going to do is we're going to take a look at what does release actually mean to us, and we're going to look at a couple of concepts of Continuous Delivery and Continuous Integration. So let's get started with what does release actually mean?
What Does Release Mean?

Now the concept of what a release is at this point probably isn't that big of a deal, but achieving this can be because this is one of the situations where your situation is going to be unique, in other words it's going to be completely different, not only different from one company to another but different within your company, what a release may mean for a particular, in our case, configuration, for Infrastructure from Code, where it's going to be released, how it's going to be released, but here's basically what a release is. After the entire process has successfully completed, from the moment that we've checked something into source, that the change was made to the point that it went through the build process and that process completed, and of course the most important part is that testing has passed. Now just as a side note, if testing has failed, I expected it to have been kicked back to the original author, worked on again until it got rebuilt and went through testing again, and then it eventually passed testing, so there may be some circling back in this part of the process. What we end up with is a build artifact, ready to be deployed. For developers, this could be executables or binaries, other binaries and support files for IT ops people, this could be a configuration document that is now ready to go in its machine readable format and needs to be deployed. The question is, what happens to it then, and this is where it gets a little bit tricky. So let me show you the release pipeline here. First of all, our release pipeline, we've gone through the source, build, testing, we're now at build, or at release, and some of the products that we've talked about, but I want you notice what I have here for release, environment and situation dependent, and here's what I mean by this. I don't know what you're going to release to, and I don't know exactly what you're releasing. In the case of releasing a machine-readable configuration that I want to send out to machines, do you remember back when I was talking about how those configs could get deployed, we could have a pull or push deployment for those configurations? So you might be using that as a process, if you're sending out a machine-readable config you might be pushing it out to an existing machine, or you might have those machines triggered to be pulling it from a build server so part of your release is to, or excuse me a deployment server, so part of your release is to copy the files to that deployment server and allow the targets then to pick it up on their schedule. It also, release to you might mean building brand new VMs and making the server all over again, which I do a lot with web servers, so it's always you know, I'm not updating, I'm just making brand new ones; oftentimes it's faster. So, release may be different to you, and the location for the release. You might be going bare metal, you might be going virtualized, you might be going into the cloud and the cloud technology that you use will be unique for that cloud technology, so here's where your environment, you have to get creative with the tools. A lot of the tools we already mentioned will give some release capabilities, you just have to determine whether it works best for you and if you need to add something to it, dependent upon what you're doing, and the technologies that you're working with.
Continuous Delivery (CD)

Part of the release stage in your release pipeline is not just where you're going to put the product, but how are you going to get it there and what impact does it have, and there's some terminology that kind of defines some options that you have out there. It's Continuous Delivery, and something called Continuous Integration. In fact, you'll hear people talk about CICD, as they refer to their release pipeline and what they're doing. So let's kind of get some, an overview of what those terminology, what that terminology means. First up is Continuous Delivery. Now, you'll also hear another term for this, Continuous Deployment, and while as you dig into deeper details later on, there might be some differences that different people view about Continuous Delivery versus Continuous Deployment. I particularly find them pretty much the same, and I use the term Continuous Deployment most of the time, but I think as you're perusing the internet you'll see Continuous Delivery more often. But the idea behind Continuous Deployment or Delivery, is that we're going to be able to do this, it works best with something we call immutable servers. Now I know that's kind of a strange term, immutable servers, this is where every server is exactly the same and can be redeployed entirely whenever we want. Not just a failure occurs, but whenever we want, so I want you to think about this, I've got a bunch of servers in a web farm that are running the applications that my developers are developing, that my customers are accessing. If one of those web servers starts to you know, stops communicating, well, am I going to try to fix it? Well no, it's an immutable server that I have a configuration already written for, so what I'm going to do is I'm just going to destroy it and then build a brand new one. In fact, I can probably get a new one up, especially in a virtualized environment, faster than the IT guy could get to the server to even start troubleshooting it. Now that doesn't mean that I want to totally destroy the server, because if you're a security related person you're saying, well you know maybe that server was under attack and you want to know about that, I totally agree, so we could take that server offline, and then rebuild a brand new one, just so that we can get our business continuity back up. And then, at my leisure, I can then go through and try to troubleshoot in an isolated environment, that particular web server, or have the security team work with that server. So the idea here is that we can replace the entire server at any moment. This is something you want to shoot for, this is actually what you want when you are looking at Infrastructure from Code, you want to make as many servers as immutable as humanly possible, and I know what a lot of IT ops guys say, all of our servers are unique, they are all snowflakes, they are all precious, they really aren't all precious, they really aren't all unique, in other words, if you really took a look at them, there would be ways that you could make them immutable. But, if you do have unique servers, if you do have snowflakes, servers that can't just be destroyed and redeployed, part of the Continuous Deployment is this idea of incremental deployment, and this is for servers that have to be maintained over a long period of time. Now, while I would argue that I could probably make, and I'm going to use a Microsoft reference, a domain controller as, I could probably make that immutable, I already have, that would be something that you may start off with doing incremental, that's a server that needs to be maintained over a long period of time, maybe a particular database server, and the products that are installed on the server, you know it's going to take a long time before you ever get a complete config written for it, so right now it's going to be an incremental that you're going to keep around. So this is ones for servers that you just haven't gotten to the point to where you can easily redeploy, destroy and deploy, if you can't do it, then we'll do it incrementally, and this means that configuration changes are going to be delivered as updates, we're not going to destroy and rebuild, which is my preference, instead we're just going to update the machine. It could be a security update, it could be a product update, as long as it's gone through good testing, then we know we can bring it back. Now, here's the challenge, if it does fail in our configuration, we still need, since it's not redeployable, since it's not destroy and deploy, we still need, and I don't want to say old fashioned, but we still need our other recovery mechanisms where we can restore from backup as an idea, because again, we still are going to have failures, we just need to know how to bring those systems back. So those are a couple of examples of incremental deployment, so you're not locked into destroy and deploy, that's just one of the goals that I personally focus on, and then when you do have those snowflake servers you can still take care of them and work with them in the release pipeline, that's the best part, until you arrive at a time when you've gotten to the point of being able to evaluate and making them so that they're redeployable.
Continuous Integration

Continuous Integration is another concept for working with your release pipeline. The idea is that I want tighter workflow and orchestration as I bring all of these stages and these processes together. So it gives me the ability to basically add quality gates and either stop and do some additional testing, or get approval in order to continue on. So let me give you an example of this. Let's say that somebody puts in something, checks something into source, and it goes through testing and it fails in testing. Well, yes I want to notify the person that it failed in testing, but here's also what I don't want to have happen. I don't want anybody else to be making any other changes to that configuration document until the person that made the change that made it break, until they've had a chance to fix it. That's the Continuous Integration piece, the abilities that we can control with the orchestration, so that instead of allowing 10 people to make the problems get worse, we stop and we wait until we can clear that gate with the person that originally caused, I don't want to say they caused a problem, but you know what I mean, that's where the test originally failed, and that's the idea behind the Continuous Integration. And that pretty much brings us to the end of our last stage of release, both what it means for you, it's going to be completely different than anybody else, and the concept of Continuous Delivery or Continuous Deployment, and the idea that you know we can do this as a rapid deployment mechanism where we're deploying an entire server, you know destroy and deploy, but hey if you have snowflake servers, servers that you need to maintain over a long period of time, they can still be part of this release pipeline and take all of the benefits from the testing, the source control, going through the builds and the tests, and then through the release mechanism for them. Now, there's one last thing I want to talk about, it's a final word before we go, and that'll also, I also want to talk about how you can get started on this today.
A Final Word
Introduction

If you've been following along throughout this course, you'll kind of notice that yes, this is the big picture overview and you've gotten a lot of concepts out of this and even some ideas of products that you can start to research and you can start to look at these different stages, and I hope you really find this helpful, but I also know that there's more work to do. So I want to remind you about some key components or key parts of information, and also maybe give you a way that might be helpful to get started so you can start to work on building your own release pipeline. As an overview for this, I just want to remind you about the benefits and about the overarching concept behind this DevOps, and Infrastructure from Code, our release pipeline as it is, and remind you about that view of failure, I know that's a tough one but yes, and then how to get started. So why don't we start off with a quick review on the benefits, and put them into a new concept now that we've seen the entire release pipeline, and then look at how to get started.
Benefits

Now that you've had to see the entire release pipeline and get some of the base concepts from using that pipeline, and especially from Infrastructure as Code, let's take a look at those benefits again. Now I'm not going to walk through each one of these, because you can go back and take a look at them if you want, but here's why you're getting these results now. And it's not going to happen instantly, it's going to be immediate, this is a process that you're going to have to work through that requires you to do it over and over again, but the reason you're getting these particular benefits now is because you have a process, you are starting with, in a case of Infrastructure from Code, maybe a configuration that's getting checked into source, that's now working through build, that's now getting tested, and if tests should fail, we block everybody else from touching that config until I've had a chance to fix my part of it, then we release it and let everybody else make their changes and we test it again and it goes through to release. Because of that process, you're now being able to deploy faster, you're being able to recover from failures, think about it, in Continuous Delivery, being able to just destroy and deploy faster than you could probably even get to the server and sign into it some cases. So certainly much faster than you can troubleshoot it, because we are doing extensive testing our change, our failure rate for our change obviously is going to go down, and because we are having systems that we can replace, such as I use the web server example hey we're having a problem with the web server, that's not unplanned work for me anymore, what that is just kill it and replace it, it's easy. So now you can see why some of these numbers are coming together. And, just to remind you, DevOps, that overarching concept, is all about people and culture first, because if you try to extend this, if you try to take developers doing, pushing out applications, and ops people trying to make sure that the infrastructure's in place, security people trying to make sure that we're not getting any security vulnerabilities. If you're bringing these people together, they have to be able to communicate and not point fingers, we have to work as a team towards a common goal, then these processes will work for us, and we can start to use them together, and build better tool sets out of it, and we can apply better tools, we can share tools, we can enhance the tools that we have as we work towards DevOps. Now, Infrastructure From Code: The Release Pipeline, this is just a pure review reminder, and some of the products that I had mentioned, there are more out there, and there, but it's a great place for you to get started, taking a look, reviewing, seeing which ones work in different phases or stages of the release pipeline, and remember that view of failure, now you can start to maybe see why you know, I know why we're afraid to fail, because it's so hard to come back from failure, and sometimes failure would be obvious to people, we don't want people to know that we fail, but guess what, they know that we fail, we have a huge impact on that, so Infrastructure from Code and using this release pipeline gives you not only a repeatable process that is stable and repeatable, but that it learns, your testing gets better. If you forgot a certain test, oops, now you put that test in, now it'll always be there, so this is how you improve over time to the point to where I love making configuration changes because I have full confidence that they're going to get out to production, and I know my targets, I know that the targets that are ones that I can easily replace, destroy, and deploy, well I have no fear, I can just roll back to a previous configuration. If they're targets that are snowflakes, that I'm doing incrementals on, yeah, I'm going to be a little bit more cautious with those, but that's the beauty of the release pipeline, you get to make those exceptions.
Getting Started - Infrastructure from Code

You might be wondering at this point, well, it seems so big, so vast, there's so many products, how do I actually get started on this, and that's what I want to try to see if I can help you with, and basically, give you a couple of ideas of how I got started on it. First of all, it depends on who you are. If you're a part of leadership and you're looking at DevOps and what it can do for you, there's a different way you want to get started, I'd say start with the Phoenix project and go from there, because that's about breaking down the silos and the people, and there's more books that you can help you with that, more training, more guidance that you can get on getting that process started. If you're a developer that's already been working with Agile, you're probably pretty comfortable with the idea of the release pipeline and so you might find some products out of this to help you boost it up and make it better, make it more automated. If you're an IT ops person like I am, getting started, well, first of all, start small. In other words, don't look at replacing your entire infrastructure, take a small piece of your infrastructure, take a basic web server, a web server that you already know that your company is running that is pretty simple, that you might be able to write a configuration for. Now you have to decide what products you want to use, are you going to use Chef, are you going to use Puppet, are you going to use Microsoft's Desired State Configuration to do this, but at the same time it's a small project that you can then I can do, I can configure this web server, I can then make changes to my configuration and send it out to that web server. Now notice I said that I'm making changes now, so this is a great time for you to look at source control, in other words the first stage of the pipeline. I know I can send out this config and I know I can make changes to it, but how do I now start versioning this the proper way? And what you might simply do is create multiple versions, but still manually push this configuration out to that web server. Maybe the next part of the phase for you is to add testing, and so through testing, you might start by using, if you were using Microsoft DSC, I would start writing Pester tests for it, and start building the testing phase, and then you can build, you can have the build portion of the pipeline, and you can build out your pipeline with the tools over time, but if you start small, work on a part of the pipeline like configuration management, and then gradually build it out to more of a pipeline, this is something you can successfully do and make vast improvements to how your infrastructure is managed without having all of the DevOps stuff on top. Now, if you're going to have to work with other teams, now's a good time for DevOps, but at least you personally can start to make improvements to your areas if you'd like. And with that, that pretty much concludes everything that we've done. We took a look again, after seeing the entire pipeline, the benefits and what DevOps might just mean to you now, now that you've seen a part of it, Infrastructure From Code: The Release Pipeline, and that view of rush to failure, and I really wanted to spend the time on maybe getting you a couple of ideas of how to get started on your own Infrastructure From Code release pipeline, starting with basic configuration management, small unit, small environment, small things to start with and gradually start build upon, and gradually starting to build your pipeline. In no time you'll start getting improvements, just like all of those articles say you will.
Course author
Author: Jason Helmick
Jason Helmick

Jason Helmick is an author for Pluralsight. His IT career spans more than 25 years or enterprise consulting on a variety of technologies, with a focus on strategic IT business planning. Heâ€™s a...
Course info
Level
Beginner
Rating
4 stars with 48 raters(48)
My rating
null stars
Duration
1h 32m
Released
14 Jun 2017
Share course

