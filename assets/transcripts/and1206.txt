Android Gestures: Getting Started
by Mitch Tabian

Making use of the many Android gestures is absolutely fundamental to providing an excellent user experience. You'll learn how to detect gestures for touching, double tapping, scrolling, time delayed touching, swiping, dragging, and scaling.

At the core of every great android application is an intuitive, interactive design. In this course, Android Gestures: Getting Started, you will learn how to master the core concepts related to detecting gestures with an Android device. First, you will take a close look at the basic touch gestures, double-tap gestures, scroll gestures, time delayed gestures, swipe gestures, drag gestures, and scaling gestures. Then, you will build a draggable, scalable custom ImageView. Finally, you will explore how to use a RecyclerView for moving list items, swiping, and detecting changes to the scroll state. When youâ€™re finished with this course, you will have a foundational knowledge on detecting and responding to gestures that will help you as you move forward to develop mobile applications.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Beginner
Rating
4.9 stars with 14 raters(14)
My rating
null stars

Duration
2h 18m
Released
28 Mar 2018
Share course

Course Overview
Course Overview
Hi, my name is Mitch Tabian, and welcome to my course, Android Gestures: Getting Started. I'm a self-employed Android developer, and I'm going to teach you about detecting gestures with Android. Making use of the many Android gestures is absolutely fundamental to providing an excellent user experience. The Android SDK has a ton of built-in convenience classes that we can use to detect gestures. Things like touching, double-tapping, dragging, scaling, and even tracking movement around the screen. Some of the major topics we'll cover include detecting common gestures like touching the screen, removing a finger from the screen, detecting double-taps, and detecting a long press. We'll build a custom ImageView class that users can drag around the screen and zoom in or out. In the course, we'll customize a RecyclerView to allow user interactions like moving list items around, swiping, and detecting changes to the scroll state. By the end of the course, you'll have an excellent understanding of the most important concepts when it comes to detecting gestures. Your applications will be more interactive, intuitive, and therefore provide a superior user experience. The course is meant for beginners when it comes to gestures, but targets a more intermediate developer overall. You should be very familiar with RecyclerViews, ListViews, onClick events, fragments, and settings images to ImageViews. I hope you'll join me on this journey to learn about gestures with the Android Gestures course at Pluralsight.

Getting Started
Introduction
My name is Mitch Tabian, and welcome to my course Android Gestures: Getting Started. In this course, you'll learn how to build a shopping cart app that makes use of a wide array of Android gestures. We'll start simple by detecting touch gestures with the on-touch interface. The on-touch interface is great for detecting basic actions, like touching a finger to the screen, moving a finger around the screen, and lifting a finger off the screen. Then we'll move onto more robust gestures, like the OnGestureListener interface, OnDoubleTapListener interface, and OnDragListener interface. With these listeners, we'll be able to detect actions like single taps, scrolls, long presses, flings, double taps, drags, and the position of the draggable view. Once we've mastered the on-touch interface and the three gesture listeners that I just mentioned, we'll move onto more advanced gestures. For example, building a custom ImageView class that's draggable, scalable, and pannable. This is going to be very similar to the default Android gallery for viewing images. You'll be able to zoom in on an image, and then drag it around the screen. Building an interact RecyclerView. Users will have the ability to drag list items around and swipe to remove them from the list. When a user scrolls to the bottom of the list, a floating action button will be revealed. If they click it, they'll automatically be sent to the top of the list. The main purpose of integrating gestures is to improve the user experience. Gestures should be intuitive, aesthetically pleasing, and possibly save time. People have come to expect certain norms when it comes to specific app interactions. For example, when you're using an app and you double-click on an image, you expect the image to become fullscreen, be draggable, scalable, and pannable. Or at the very least, take you to a new screen where you can get more information on what you just clicked on. It's very important not to resist norms like this. As the developer, we need to recognize these expectations and conform to them. That will help us provide the most intuitive design possible.

Prerequisities
This course is meant for intermediate level Android developers who are completely new when it comes to using gestures. As I stated in the introduction, my goal is to keep things as practical as possible. The app we'll be building will showcase many different situations. We'll be integrating things like RecyclerViews, fragments, listeners, callbacks, custom object classes, toolbars, and much more. Now let's talk about the dependencies we're going to need for the course. Keep in mind these libraries will already be included in the source code files, so there's no need for you to add them yourself. We'll be using the recyclerview support library for implementing RecyclerViews, the design Support Library for coordinator layouts and consequently toolbars and other widgets it supports, the cardview support library for integrating cardviews, and the glide library for setting image resources to widgets. If you want to close or look at those libraries, just open the app level build. gradle file and take a look. Copy the dependency you're interested in and paste it into a Google search. That will direct you to a GitHub page where you can get more information on that particular library. I'll be using Android Studio v 3. 0. 1, and compiling and targeting an SDK version of 27. As I mentioned, I expect you to have an intermediate level knowledge of Android development with Android Studio. I won't be covering how to set up the Android emulator, or how to enable developer mode and run apps on a real device. I'm assuming you've already learned that on your own, so if you're completely new and you've never used Android Studio before, you'll need to do some minor research and get apps running on a virtual device or on a real device that you have.

The Story Behind the App
For the duration of the project, we'll be approaching app development from the perspective of a company called Coding With Mitch. Coding With Mitch is a small internet company that sells clothing merchandize online and makes programming courses. Currently, Coding With Mitch has an online store for selling merchandize, but they don't have a mobile application. They want to get an idea for what it would cost to build an Android app. You've been hired to build a shopping app prototype. The app must showcase the items they sell, be intuitive, and provide a great user experience through interactions, and have a shopping cart functionality.

Application Demo
Let's take a look at the app we'll be building in the course. Here's the screen that comes into view when we first open the app. This is a list of all the products that Coding With Mitch has for sale. The first thing you notice is the swipe refresh layout wrapped around the RecyclerView. If you drag downwards, the list of items is refreshed, and you see that nice, swipe refresh progress bar. Now I'll select an item. This view is where users can get more information about the product they selected. There is an image, a title, a price, a size, and a description of the product. If you swipe the image, it shows a different variation of the product. You can see the image changes, the title changes, and the price changes. These dots indicate which variation you're viewing and how many variations there are in total. If you double-tap the image, it inflates to occupy the entire view. This is a custom ImageView class that's draggable, scalable, and pannable. As you can see, I can zoom in, I can move around, and I can zoom back out. Also if I zoom all the way in, and then double-tap the image, it automatically resets the view. Next is my favorite part of the app. If you hold down a single finger on the image, this shadow image is inflated. Also notice the appearance of the plus sign in the toolbar. Once the shadow is inflated, I can drag it up onto the plus icon, and when I let go, the item is added to the shopping cart. Alternatively, you can just scroll down and click Add to Cart here. I'll add a bunch of these items to the cart. We'll add one, two, that should be good enough. Go back, choose another item, add that one, add another variation, and then just add one more. That should be enough. Now let's take a look at the shopping cart. Click on the shopping cart icon in the toolbar. Here we have all the items that we added to the cart. Scroll to the bottom. Notice the floating action button that comes into view when we scroll to the bottom. It only appears once we scroll to the bottom of the list. If we click it, we're scrolled back to the top of the list. This next feature is really cool. If you hold down a finger on the list items, they highlight and become draggable. I can then move the items into these categories. There's must have, maybe, and probably not. If I want to remove an item from the cart, I can just swipe it out. And there we see the message Removed from cart.

How to Use the Source Code Files
For your convenience, I have added the source code files to a GitHub repository, and I've also attached them to the exercise files for the course on Pluralsight. I recommend using the code on GitHub, since it's easy to switch between modules and clips. But if you want to get the code from Pluralsight, you're more than welcome to do that, too. Let's walk through how to get the code from GitHub. Launch Android Studio. Click on Check out project from Version Control right here. Here is where you're going to put the GitHub repository URL. Open GitHub, and let's get it. Navigate to github. com/mitchtabian, and then /CodingWithMitchStore. Click on the Clone or download button right here. Copy this URL. Now go back to Android Studio and paste the URL in right here. Click Clone. This message will pop up asking if you want to open the project that you just referenced. Click Yes. Another dialog will pop up asking if you want to add this vcs. xml file to Git. Just click No, and you can add it later if you want to. If you already had a project open, you can also import the Version Control by going to File, going to New, and then import project from Version Control. Then just paste URL right here. Notice the error message I'm getting down here. If you're seeing the same thing I am, go to File, and then select Invalidate Caches/Restart. Then click Invalidate Caches/Restart. If you have any issues with loading the source code while following with the course, the first thing I want you to try is invalidating the caches and then restarting again. Okay, now let's reopen the project. You should be greeted with a dialog that looks something like this. Make sure everything's checked and click OK. Notice I can't click the Play button yet, so there's still a problem. Open the Logcat. Android Studio is telling us we need to configure the SDK, so click on Configure. Choose build tools version 27. 0. 3, or whatever the most recent version is at the time that you're watching this course. Now click OK. At this point, you should be good to go. But if you're still having issues, make sure your Android Studio is the same version as mine, 3. 0. 1, and all the SDK tools are up-to-date in the SDK Manager. Now accessing the source code for each clip is very simple. Click down here where it says Git. Drag this one upwards to expand it. These are all the clips for the course. So if you wanted to open the source code for the start of the module named swiping through images with a view pager, then you select the branch named Module_2. 2_Start. If you wanted to see the code for the end of that module, you would just go to Module_2. 2_End. Click Checkout as new local branch, and then click OK. Now all the code is updated. Let's do another example. Suppose you wanted to open the code for the module named detecting common gestures. Once again, click down here, then select Module_3. 2_Start. Checkout as new local branch, click, OK. Now you're ready to start the module. If the naming of the branches is confusing you, let me explain by referencing one of the other courses on Pluralsight. At the time of filming this, this course is obviously not published yet, so I'll have to refer to a different one. Here's another one of my Android courses. It's called Implementing Effective Navigation. Pretend we're working on this course and that we've imported the source code from GitHub like I just showed you. This will be module 0, this will be module 1, this will be module 2, and so on. That's how I've named the branches for this project. Just keep in mind there's a module 0, and you'll have no issues getting the correct code.

Swiping Through Images with a ViewPager
Introduction
In this module, we'll implement the swipeable image functionality that we looked at in the application demo. For the duration of the module, we'll be working with the source code files in the directory Module_2/start_CodingWithMitchStore. If you imported the code from GitHub, you'll want to start with the branch named Module_2. 2_Start. For those of you who have no experience using a ViewPager and the FragmentStatePagerAdapter, you know it's actually not a gesture or a gesture listener. It looks like a gesture listener, because it responds to swiping left or swiping right. I chose to include it in this course, because in my opinion, it's the most effective way to swipe through images. For those of you who have no experience with ViewPagers, a ViewPager is a special type of fragment container that's swipeable. It's typically used to hold fragments in tabs. We're going to leverage the swipeability of the ViewPager and use it to swipe through product variations in our application. You can think of the ViewPager as the actual container holding the currently active fragment. Inside that fragment will be an image of the product, the title of the product, and the price. After the ViewPager is set up and we're able to swipe through the fragments, we'll introduce a tab layout and associate it with the ViewPager. That's what this is down here. These are the tabs that are associated with the ViewPager. The large gray circle denotes which fragment in the list we're currently viewing.

Preparing to Implement a ViewPager
Whenever you're dealing with lists of objects in Android, you almost always need to build some kind of an adapter class. In this case, we're adapting a list of fragments to a ViewPager widget. Before we build the adapter class, let's quickly look at how the selected product is being passed from main activity to ViewProductActivity. MainActivity holds the RecyclerView with the list of products. ViewProductActivity is the activity with the swipeable images. Open MainRecyclerViewAdapter. This is the adapter for the RecyclerView in MainActivity. In the OnBindViewHolder method, there's an OnClickListener attached to each cardView holding the images. If the user clicks it, they'll be navigated to ViewProductActivity. Notice the intent Extra. We're attaching the product object that was selected. Open ViewProductActivity. Scroll down to the method named getIncomingIntent. Here the method checks for an incoming intent. If there is one, and it contains the intent Extra from MainRecycleViewAdapter, it retrieves the incoming product and sets it to this global variable. Run the app and let's take a look at what's happening. Click on a product. So it's taking us to ViewProductActivity, but nothing is being displayed. This is where we're going to add the ViewPager, right here in this location. Compare with the completed version of the app. The ViewPager will contain a list of swipeable fragments. Each individual fragment will contain an image, a title, and a price. I've included the fragment and its corresponding layout in the source code files. First, let's take a look at the layout. Open fragment_view_product. It's a very simple layout. There is an ImageView occupying the majority of the space, then a TextView for the title, and a TextView for the price. Open ViewProductFragment. Here's the widget declarations for the image, the title, and the price. If you're familiar with fragment lifecycles, you know that the onCreate method is called before onCreateView, and this fragment's onCreate method, we're checking for the incoming bundle and retrieving a product object. This is the product whose properties will be set to the widgets in this class. You can see them being attached to their respective IDs in onCreateView, and then set the widgets in the setProduct's method. The BigDecimalUtil class is a convenience class that I created for converting a big decimal number to a string and then formatting it to represent a dollar value. Open BigDecimalUtil and let's take a look at it. There's just a single method named GetValue. It takes a BigDecimal object and converts it to a properly formatted string.

Building a ViewPager Adapter Class
Now that you have an idea of what we're going to do and how we're going to do it, we can start building everything needed to implement a ViewPager. If you're using the GitHub repository to get the source code, you'll want to check out the branch named Module_2. 3_Start. If you've already checked out as a new local branch, meaning it's present in this list right here, just click it, and then select Checkout. If you haven't checked out as a new local branch, meaning it's not present in this list, select it down here, then check out as a new local branch. If a warning pops up asking if you want to stash the changes you've made, click the Force Checkout button in the bottom left of the popup dialog. Now you're ready to start. Open activity_view_product. Scroll down to the ViewPager widget. I want to point this out before we start building the adapter. This will be our container for the fragments. It's inside a linear layout with a vertical orientation and a weight sum of 100. The ViewPager has a layout_weight of 70 set to it, so it will occupy 70 out of 100 of the total layout space. In other words, it will occupy 70% of the total space. Now let's build the ViewPagerAdapter. Right-click on the main package directory, go to New, Java Class, call it ProductPagerAdapter. If this is the first time you've tried making changes to the code from GitHub, you'll see this dialog. Just click No and don't ask again. First, extend the class will FragmentStatePagerAdapter. FragmentStatePagerAdapter is a convenience class used for managing lists of fragments. If you want more information on it, check out the Android documentation at developer. android. com. But to give you kind of a general overview of what it does, it's meant for holding lists of fragments. This one in particular is meant for holding lists of fragments and maintaining the state. So, when we navigate away from the fragment, it will be destroyed, but the state will be saved. The class has two required methods. Click the red light bulb and take a look. Choose getItem and getCount. Those are the only two methods required to use the class. Since we're going to be saving a list of fragments, create a global ArrayList variable that holds Fragment objects. Make sure to get the V4 support version, as it's backwards compatible with more Android versions. Insert the default constructor by pressing Alt+Insert on Windows Command+Insert on Mac, and then selecting constructor. We're almost done. In the getItem method, return the fragment at that position. And in the getCount method, return the size of the list. That's it. Open ViewProductActivity, and let's initialize the ViewPager and set the adapter. Under the Widgets heading, write private ViewPager mProductContainer, and then under the vars heading, write ProductPagerAdapter mPagerAdapter. Now attach the ViewPager to its ID. Below getIncomingIntent, create a new method named initPagerAdapter. Let's define what we want to accomplish with this method before moving forward. We have a ViewPager for holding and swiping fragments, the Fragment class we want to inflate is ViewProductFragment, so essentially all we need to do is inflate a new ViewProductFragment for each product variation. Open the Products class. For example, if the user selects a hoody from the list in MainActivity, we need to display all the different variations of the hoody product. There's navy, asphalt, black, gray, and purple. So, we need a ViewProductFragment for each one of those variations, and then we need to add that fragment to our ViewPager. At the top I've created a convenience HashMap for determining what list of variations our product belongs to. It's called PRODUCT_MAP. If you reference the product type, for example, a phone case, a hoody, a mug, or one of the other ones, it will return a list of those types of products. If we're talking about a hoody, it will return the hoody's list. Here's that list down here. Notice the hoody's list contains all the product variations for that particular type of product. Go back to ViewProductActivity. So now we just need to get that list of variations that this product type is associated with. Then attach each variation to a bundle and set the bundle to the ViewProductFragment class variable. Declare a new ArrayList variable for holding the fragment objects. Declare a Products object, so we can get the list of variations. Declare a new array of products and call products. PRODUCT_MAP. get and then reference the product type. Now loop through the variations and attach them to a bundle. Then attach the bundle to the fragment. So, for Product in the selectedProducts array, Bundle bundle = new Bundle, then bundle. putParcelable(getString) And reference the intent product, and then pass the product. Then write ViewProductFragment viewProductFragment = new ViewProductFragment, and then set the bundle to that fragment object. And finally, add the fragment to the fragment list. If you're unfamiliar with parcelable, it's just a way of packaging objects so they can be attached to bundles. You need to implement parcelable on a custom object class if you want to attach them to bundles. Open the product class in the models package and take a look. See? It implements Parcelable. If this looks confusing to you, don't worry. I'll show you how to do it. I'm going to delete everything to do with the parcelable implementation. So I'll delete the implementation, delete these two methods right here, and then delete these two at the bottom. Now all that remains is the constructors and the getter and setter methods. Scroll back up to the top and write implements Parcelable. Now click the red light bulb, and implement the methods. Click the red light bulb once again and select implement parcelable. That's it. That's all there is to making a custom object class parcelable. Go back to ViewProductActivity. We have our list of ViewProductFragments with the product variations attached to the bundles. Now we just need to instantiate the ProductPagerAdapter, and set the adapter to the ViewPager. Write ProductAdapter = new ProductAdapter, getSupportFragmentManager, and pass the fragments. Now set the adapter. So, ProductContainer. setAdapter and pass the adapter. Call initPagerAdapter in onCreate. Now we can run it and take a look. Click on an item. Now test the swipe. Looks good. I'm able to swipe through the item variations.

Leveraging a TabLayout to Improve the ViewPager
If you're using the GitHub repository to get the code, you'll want to check out the branch named Module_2. 4_Start. Here's the dialog I was talking about in the previous clip. If you see this, it's best to click Force Checkout. We don't want to save any changes from the previous clip. We have our ViewPager working, but there's no way for users to see how many variations there are of a product. Let's improve the aesthetics of our ViewPager by adding a tab layout. Before we write the code, let's clearly define what we want to accomplish. Notice these little grade dots down here below the images. The largest dot represents the fragment number in the list of fragments. So in the case of the snapback hats, there's six total variations. And we're currently looking at number three. Intuitively, this doesn't look like a tab layout, but it is. And it's surprisingly easy to set up. Open activity_view_product. We need to add a tab layout below the ViewPager. Make sure to get a TabLayout and not a TableLayout. I've accidentally inserted a TableLayout way too many times. Set the width to match_parent, the height to wrap_content, and give it an ID of tab_layout. Set the tabGravity to center, tabIndicatorHeight to 0dp, and tabMaxWidth to 10dp. That's going to position our tab layout right in the middle where we want it. Now set a tabBackground of tab_selector. Tab_selector is a drawable file that I've included in the source code files. Open it and let's take a look at it. It's a simple selector that defines two states. One for when the tab is selected, and one for when the tab is not selected. If the tab is selected, it uses the drawable file tab_indicator_selected. If the tab is not selected, then it uses a drawable file tab_indicator_default. Open tab_indicator_selected. It's a layer list with a single item, and a shape defined inside the item. The properties you want to pay attention to are the thickness and the color. Tab_indicator_selected defines when the tab is actually selected. So it's this larger, darker circle. Open tab_indicator_default. Here we have basically the same thing, except the thickness is only 2dp instead of 3dp, and then the color is a lighter shade of gray. It's hard to see, but you can make out the tiny circle in the preview. See? The default is smaller and lighter than the selected version. That's defining what our tabs will look like. Now we just need a way to associate the tab layout with the ViewPager. Open ViewProductActivity. Declare the TabLayout under the widget heading, associate the TabLayout with its ID, and now call mTabLayout. setupWithViewPager and pass the ViewPager and true for auto refresh. It's that simple. Now our TabLayout will swipe along with the ViewPager. Run it and let's take a look. Select the product, swipe through them. Great. Everything is working as we expect.

Module Review
This module was all about implementing a ViewPager for swiping through a list of fragments. Let's quickly review the whole process. Our goal was to use a ViewPager to inflate fragments for each product variation. Because of the built-in functionality of a ViewPager, the fragments are swipeable. The fragment class we inflated is ViewProductFragment. ViewProductFragment received the product variations through a bundle and its onCreate method. The product properties are then set to the respective widgets in the setProduct method. SetProduct was called in onCreateView. Like all Android lists, the ViewPager needs an adapter class to adapt the list of fragments to the container. The Adapter class we built is named ProductPagerAdapter, and it extends the FragmentStatePagerAdapter class. The FragmentStatePagerAdapter class is a convenience class designed to hold a list of fragments. The fragment state is saved in memory, but the actual fragment is destroyed when it's not being viewed. Our list of fragments was saved in an ArrayList named mFragments. GetItem returns the fragment at the position being viewed, and getCount returns the size of the list. In the application, each product is part of a category. There's t-shirts, half-sleeve shirts, trucker hats, snapback hats, phone cases, tanks, hoodies, and mugs. When the user selects a product from the main feed, that product is sent to ViewProductActivity through the bundle. In ViewProductActivity, we want to then display all the available variations of that product. In the case of snapback hats, there's six different colors, and therefore six variations. That means we need six fragments in the ViewPager. Users can swipe through the variations. The tab layout below the ViewPager will display which variation they're viewing. Once again, I want to mention that using a ViewPager to swipe through fragments isn't technically a gesture. But the ViewPager widget has built-in swipe functionality, and I believe it to be the most effective way to swipe through images or any other custom view that you want to define. Since we're swiping through fragments, you could theoretically build any number of custom layouts and swipe through them efficiently using this method.

Detecting Common Gestures
Introduction
A touch gesture occurs when a user places one or more fingers on the screen, and your application interprets the pattern of touches as a particular gesture. For the duration of the module, we'll be working with the source code files in the directory Module_3/start/CodingWithMitchStore. If you imported the code from GitHub, you'll want to start with the branch named Module_3. 2_Start. There are three phases for detecting a touch gesture. Phase 1 is detecting the initial touch on the screen, phase 2 is determining what type of touch the gesture was, and phase 3 is executing the desired methods for that gesture. To detect the initial touch to the screen, we'll be making use of the View. OnTouch listener interface. The interface intercepts touch to the screen, tracks movement, and detects when the touch ends. We can determine which of these actions are occurring using some if/else logic or a switch statement. To detect more complicated gestures, we'll take a look at two more interfaces. GestureDetector. OnGestureListener, and GestureDetector. OnDoubleTapListener. With these two interfaces, we can detect gestures like long presses, flings, scrolls, and double-taps.

Capturing Touch Events
As I stated in the introduction, detecting gestures and tracking movement all start with capturing a touch event. Once we have the touch event, we can detect more complicated gestures. Open ViewProductActivity. To intercept touch events, we need to implement the OnTouchListener interface. So write implements View. OnTouchListener. Android Studio is giving us a warning. Click the red light bulb and implement the OnTouch method. The OnTouch method will be triggered when a user touches the screen, moves their finger around the screen, or removes their finger from the screen. There's constants to determine which of those actions are being taken. Let's write a switch statement and handle each case. So, int action = motionEvent. getAction. That will give us an integer representing the action. Now let's switch the action and write a logic. The first case is when the user first presses their finger to the screen. Write Action was DOWN to the log. Next is ACTION_MOVE. This will trigger whenever there is movement on the screen, so I'll just write Action was MOVE. Now ACTION_UP. ACTION_UP will trigger when the last finger leaves the screen. So if there was more than one finger on the screen, it won't trigger until the last one has left. ACTION_CANCEL will trigger when the OnTouch event action has been overtaken by another touch event. The last action is ACTION_OUTSIDE. This will trigger if a touch event moves out of the bounds of the listener. For example, if we had two text view on the screen, one next to one another, and then we have an OnTouch listener on just one of them. If these are touches one and then moves our finger to the other, we'd see ACTION_OUTSIDE being triggered. Now we just need to set the listener to the widget we're interested in. In onCreate, write mProductContainer. setOnTouchListener, and then pass this. Now we can detect touch events on the ViewPage you're holding the product variations. Let's run it and take a look at the log outputs. If I click the image, you can see action was DOWN and action was UP. Now I'll swipe through one of the fragments. You can see it goes action DOWN, action MOVE, and action CANCEL. That's because the ViewPager gesture effectively took priority when the swipe was initiated. But there's a problem. Notice the ViewPager didn't swipe to the next fragment. The onTouch listener is interfering with it. The reason for this is the true value of onTouch. If you return true, you're telling the application you don't want any other views to handle the action. The action can only propagate through the rest of the switch statement in onTouch. In other words, you're disabling anything else listening for gestures. To resolve this issue, we need to return false for each one of these switch statements. Run it again and take a look. Now try swiping. There we go. Problem solved. Now I'll touch my finger to the image, and drag it downwards towards the description text. You can see the same progression. Action DOWN, action MOVE, and action CANCEL. I won't be able to trigger action OUTSIDE in this activity, because the container is in a scroll view. Action CANCEL will always be called, since another gesture is taking over. That's basically it. Intercepting touch events with the OnTouchListener interface is very simple to implement.

Detecting Gestures with Gesture Detector
We've completed phase one of detecting gestures, we implemented the onTouch interface, and wrote logic to handle the different actions. Now we can move onto phase two and detect more complicated gestures. Open ViewProductActivity. The first interface we need to implement is OnGestureListener. You can think of OnGestureListener as sort of the gatekeeper for the other gesture listeners we'll be looking at in the course. OnTouch is required to OnGestureListener. Then OnGestureListener is required to use the other listeners, like OnDoubleTapListener and OnDragListener. Click the red light bulb and implement all the methods. I'm going to add a heading to separate the OnTouch override method and the override methods associated with the GestureDetector. Copy that, paste above onDown, and change it to GestureDetector. We'll be implementing more interfaces in this activity, and I want to make it clear what methods are associated with what interface. To use a GestureDetector, we need to declare a GestureDetector object. Under the vars heading, write PrivateGestureDetector, mGestureDetector. Instantiate it in onCreate by passing this, referring to the context, and then this, referring to the interface. Scroll down to onTouch, and let's pass the touchEvent action to the GestureDetector. So if view. getId = product_container, then write GestureDetector. OnTouchEvent and pass the motionEvent. We can actually comment this switch statement out now. We don't need it anymore. It was only added to explore the different actions. This process of passing the action to the GestureDetector in OnTouch is what I mean by phase two. Phase two is passing the event action from the OnTouchListener to the GestureListener. Let's read some logs in the GestureDetector methods, so we can explore them. We have onDown, onShowPress, onSingleTapUp, onScroll, onLongPress, and onFling. OnDown does exactly what it sounds like. It's very much like the actionDown case from our onTouchSwitch statement. OnShowPress triggers when a user has performed an onDown motion event, but does not perform a move or an up event. OnSingleTapUp will trigger when a tap occurs, but more specifically with the up motion event. OnScroll triggers when a scroll occurs with the initial onDown motion event and the current move motion event. You'll see this being triggered when we scroll through the ViewPager. OnLongPress does what it sounds like. It's triggered when a long press occurs. I believe the default threshold time is about 500 ms. And finally, we have onFling. OnFling is triggered on a fling event. The first motion event corresponds to the down motion of the event, the second motion event corresponds to the move event that triggered the fling. These two float values are the X and Y velocity of the fling. I encourage you to pause the video and explore these different actions. The log outputs will let you know when you're triggering what. As we move forward with the course, we'll be focusing on the onLongPress method. We won't be looking at the other methods in very much detail. You might have noticed that there's no override method for detecting a double-tap. Double-taps require a separate interface, the onDoubleTapListener interface. Scroll up to the top and let's implement it. So write a comma and then implement the OnDoubleTapListener. Click the red light bulb and implement the methods. Just like before, I'm going to write a heading to separate these interface methods from the others. So I'll write DoubleTap, and now I'm going to write some log output so we know when it's triggered. One for onSingleTapConfirmed, one for onDoubleTap, and one for onDoubleTapEvent. OnSingleTapConfirmed will only be called after the detector is confident that the user's first tap was not followed by a second tap, which could potentially lead to a double tap. That sounded kind of confusing. Basically it will only trigger when it knows there will not be a second tap, or a double tap is not going to occur. OnDoubleTap is pretty self-explanatory. It triggers when a user double taps. OnDoubleTapEent will trigger when an event happens within a double-tap gesture. This could be a move, a down, and an up event. The beautiful thing about this is we don't need to do anything else. The GestureDetector will automatically associate itself with the OnDoubleTapListener interface.

Detecting Click Events for Multiple Views
Click events are the most widely used gesture of them all. Every application needs to detect click events. I'm going to show you a clean and efficient way to detect click events for multiple views in the same activity. Open ViewProductActivity. Start by implementing the OnClickListener interface. Click the red light bulb and implement the OnClick method. We need two OnClickListeners for this activity. One for the cart in the toolbar and one for the add to cart button at the bottom. Add two new RelativeLayout widgets under the widgets heading, one for the cart and one for the add to cart layout. Attach these widgets to their IDs, so add to cart and cart is cart. Attach onClickListeners to their widgets and reference the onClickListener interface. So, Cart. setOnClickListener to this, and then AddToCart. setOnClickListener to this. Scroll down to the onClick override moethod. We're going to write a switch statement to handle the clicks. So, switch view. getId, and then the first case is R. id. cart. And in that case, we want to open up cart activity. The second case is r. id. add_to_cart, and in that case, we want to add an item to the cart. I really love this method of handling clicks. It's so clean and organized. Now let's quickly write the method for adding items to the cart. We'll call it addCurrentItemToCart. Get the product variation that's in the view. We can use the pager adapter to get a reference to the fragment being displayed. Then get the product by writing mProduct, since it's a public variable in the class. So, ViewProductFragment, then reference the pager adapter, call getItem, and then reference that product object. Declare a CartManager object, CartManager cartManager = new CartManager. Call the addItemToCart method, and then pass the product. So cartManager. addItemToCart, and then pass the selectedProduct. Now print the Toast, letting the user know that the item was added to the cart. Now call the method in the AddToCart switch case. We're not going to take any action in the cart switch case right now, since that's going to be for when we work on the shopping cart activity. Run it and let's take a look. Select an item, click Add to Cart. Great! The item was added to the cart.

Module Review
We started the module by integrating the most basic form of gesture detection; the OnTouchListener interface. We explored the different motion event actions that can be detected using the interface. They were ACTION_DOWN, ACTION_MOVE, ACTION_UP, ACTION_CANCEL, and ACTION_OUTSIDE. The OnTouchListener interface is what we're referring to as phase one of gesture detection. We're calling it phase one, because it's required to use the more advanced forms of gesture detection, the gesture listener interface and the OnDoubleTap listener interface. To use a gesture detector and the other interfaces like OnDoubleTap, we need to pass the onTouchEvent to the listener. We had no need for the onTouchEvent actions, so we just commented those out. If the onTouchEvent is passed to the gesture listener, it's then handled by the OnGestureListener interface, and the OnDoubleTapListener interface. The OnGestureListener interface has six override methods, OnDown, OnShowPress, OnSingleTapUp, OnScroll, OnLongPress, and OnFling. We talked about the specifics of each override method in the clip named Detecting Gestures with Gesture Detectors. If you need a review, make sure to re-watch that clip. Passing the touch event to the gesture listener will automatically associate the double tap listener to the action. The DoubleTapListener interface has three override methods, onSingleTapConfirmed, onDoubleTap, and onDoubleTapEvent. Once again, if you're a little unsure about the functionality of those methods, make sure to re-watch the clip named Detecting Gestures with the Gesture Listener. I want to take a moment and mention that this module was meant to serve as introduction when it comes to detecting gestures. In the upcoming modules, we'll be coming back to View Product Activity and leveraging the gesture detectors to execute some practical functions like dragging an ImageView around the screen after OnLongPress and inflating an ImageView to fullscreen after double tapping. There's some really cool content to come. Make sure to keep watching.

Designing a Drag and Drop Operation
Introduction
When it comes to drag and drop operations, the possibilities are seemingly limitless. You can pretty much make any view draggable, moveable, and droppable. Even picking up a view and moving it to an entirely new location is not as difficult as you might think. For the duration of the module, we'll be working with the source code files in the directory Module_4/start/CodingWithMitchStore. If you imported the code from GitHub, you'll want to start with the branch named Module_4. 2_Start. Let's start by defining what exactly a drag and drop operation is. A drag and drop operation refers to the picking up and moving of a view in your application. A view can be anything from an entire fragment to an individual widget. When dragging a view, the position of the view needs to be constantly tracked in the form of X and Y coordinates on the screen. The Android SDK creates a Cartesian coordinate system out of the device display. The origin of the coordinate system is the top left-hand corner of the screen. The X axis goes from 0 to the total width, and the Y axis goes from 0 downwards to the total height. There are some things subtle there that I just mentioned that I don't want you to miss. The X axis is defined as positive from left to right, and the Y axis is defined as positive from top to bottom. I want to mention that, because it's very important to understand positive and negative directions when developing a drag and drop operation. You'll see some examples of why that's important later in the module. Now we know a drag and drop operation is basically just the act of tracking movement on the screen. But how do we initiate the drag? We're going to be using the OnLongPress override method in the OnGestureListener interface. When the user holds their finger down on the products container, after 500 ms a drag operation will begin. In other words, our application will begin actively tracking the position of the user's finger on the screen. What will we be dragging and dropping? We're going to be building something called a drag shadow. A drag shadow is probably exactly what you're thinking. It's a shadow of a view. In our case, we're going to make a drag shadow out of the image view of the product variant that's being selected. As you can see in the demo, the title and the price are left out of the drag shadow. All we see is the image view. The drag shadow is pretty cool just by itself, but it doesn't really add any practicality to our application. For that reason, we're going to design a drag and operation. Let me show you. Notice when the shadow is inflated, the cart icon is replaced by a plus icon in the toolbar. Then if I drag the shadow up to the plus icon, it looks like it's being pressed down. If I release the shadow by taking my finger off the screen while it's pressing the plus icon, the item is added to the cart. This adds a nice touch of practicality to the app. I didn't want to just add a shadow for the sake of adding a shadow, even though it does look pretty cool.

Buidling a Custom DragShadow
To create a shadow of an image view, we're going to build a custom class that extends view. DragShadowBuilder. It's a convenience class that will create a canvas of what we want to draw and make it draggable. Create a new package named Custom Views in the main package directory. In the Custom Views package is where we're going to put our drag shadow builder. Right-click on it, go to New, Java class, and call it MyDragShadowBuilder. Extend the class with View. DragShadowBuilder, press Crtrl+O on Windows or Command+O on Mac, insert the constructor with a view as an input, insert the onProvideShadowMetrics method, and the onDrawShadow method. You can delete the supers, except for the constructor. Leave that one. This class works by drawing on the canvas you see passed as an input on the onDrawShadow method. One way to draw on a canvas is to use a drawable resource. So that's what we're going to do to clear a global static drawable object named shadow. In the constructor at a second input parameter, this will be the drawable resource we want to draw. In our application, all the images are kept in the drawables folder. So we'll pass an integer and call it imageResource. If you're building a production application, you're most likely not going to have integer resources for images. You'll likely be retrieving images from a server in the form of string URLs. So if that's the case, you need to make an adjustment to the constructor to accept string resources, or whatever input type you're working with. Now instantiate our shadow. Since we have a drawable resource, we need to write shadow = getView. getContext. getResources, then getDrawable, then reference the image drawable. If this was a string resource, you'd need to download the image from the server and convert it to a drawable. Next we'll work on the onProvideShadowMetrics method. This method is for getting the dimensions of the resource. Declare height and width variables. Now assign the height and width by writing height = getView. getHeight, and we're going to want to divide it by 2. And then the same thing with the width. So width = getView. getWidth, and then divide by 2. We're dividing by 2 here, because we want the shadow to be at least half the size of the original image view. Set the bounds of the shadow, so shadow. setBounds, 0, 0, and then the width and the height. Define the width and height of the shadow, so Size. set(width, height), then define the position within the shadow image that should be underneath the touch point during the drag and drop operation. So we just do touch. set, then width divided by 2 and height divided by 2. Now in the onDrawShadow method, write shadow. draw and pass the canvas. We're done with the my DragShadowBuilder for now. This will work, but we're going to have an issue with the image dimensions. We'll come back and fix it after we test. Open View Product Activity. Now we want to draw the shadow when the user triggers the onLongPress method. But before we draw the shadow, we need to know what product variation the user is currently looking at. And to get the product variation, we need the ViewProductFragment object that's currently in the ViewPager. Write ViewProductFragment = and now we can get the fragment that's currently being viewed by writing ViewProductFragment, reference the PagerAdapter,. getItem, then productContainer. getCurrentItem. Now getting the product is simple. Let's declare the shadow, so View. DragShadowBuilder, we'll call it myShadow = MyDragShadowBuilder. Now reference our fragment, and reference the ImageView widget that's inside the fragment. We need to reference the ImageView in ViewProductFragment, but currently it's private. So let's go over there and change it to public. Open ViewProductFragment, change this to, say, public, now go back to View Product Activity, now we can easily reference the ImageView. And to get the product resource, we just write fragment. mProduct. getImage. Next we'll start the drag and drop operation. So once again reference our fragment, then. mImageView. startDrag, pass null for the data, since we're not dragging any data, then pass the shadow, pass null again, and 0 for no flags. At this point, we can run it and take a look. The shadow should be drawn after the OnLongPress is triggered. Trigger OnLongPress by holding your finger on the image. There we go. There's our shadow. But as I mentioned earlier, there's a problem. The image is skewed. That's because in our DragShadowBuilder class, we're using the width and the height of the ImageView for the shadow. So the ratios are off. So let's fix it. Open MyDragShadowBuilder. Add another integer variable named imageRatio in the OnProvideShadowMetrics method. This is going to be the ratio of the height and the width of the actual image resource. So imageRatio = getIntrinsicWidth / shadow. getIntrinsicHeight. Now alter the height variable, change it to height = width * imageRatio. So the width will be defined by the width of the ImageView widget, then the height will be a ratio of that. That's going to fix our dimensions. Run it and let's take a look. Select a product, press on the image. Cool! The dimensions are correct.

Implementing the OnDragListener Interface
We have our draggable shadow build. Now it's time to track the movements using an OnDragListener interface. Open ViewProductActivity. Scroll up to the top and let's implement the OnDragListener interface. Click the red light bulb and implement the method. I'll add a heading once again to separate the DragListener method from the other methods. So I'll wrote OnDragListener. Before we write the logic for the OnDrag method, scroll up and let's set the listener to the shadow. So myShadow. getView. setOnDragListener and then this. Now the DragListener interface is associated with our shadow. Scroll back down and let's write the logic. We want to do the same sort of thing we've been doing to handle different event actions. We'll write a switch statement and check for the various states available to OnDrag. For convenience, I wrote the switch logic out ahead of time so we can save some time. Open a new browser window and type this into the address bar. This is a Gist I made. Now copy everything here. Go back to Android Studio. Now paste this into the OnDrag method. If your dragEvent variable is named something other than event, make sure to change that. These are all the drag states available to the onDrag method. Let's quickly walk through what each one does. ACTION_DRAG_STARTED is triggered when the drag starts. It's pretty self-explanatory. ACTION_DRAG_ENTERED is triggered when a drag point on the shadow has entered the bounding box of the view. ACTION_DRAG_LOCATION is constantly triggered when the drag shadow is moving inside the bounding of the box. We're going to be using this to track the location of our shadow. ACTION_DRAG_EXITED is triggered when the drag shadow has moved outside the bounding box of the view, or into a descendant view that accept the data attached to the shadow. In our example, we don't have any data associated with the shadow, so this will not get triggered that way. ACTION_DROP is triggered when the shadow is released inside the bounding box of the view. If it's released outside the bounding box, it will not be triggered. ACTION_DRAG_ENDED is another one we'll be using. It's triggered when the drag has ended, regardless of the position on the screen.

Starting a Drag Operation
Before we write the logic for the drag operation, let's define exactly what we're trying to accomplish. The first thing we want to do is change this cart icon to a plus icon when the drag is started. That's pretty straightforward. We can use the action drag started action event for that. The next part is a little trickier. Currently we have a drag point that's representing the position of the shadow on the screen. When the shadow drag point enters the area occupied by the plus sign, we want to change the background color of the layout holding the icon. We're going to change it to a darker blue. That will give you the illusion of a button click. And lastly, we need to add the item to the cart if it was dropped within the designated area. This is going to be relatively straightforward. Since we're changing the background color when the shadow enters the designated area, we can just use that to add it to the cart. In the action drag ended event, we can just check to see if the background color is currently dark. If it is, then we know the shadow is within the designated area, and we can add it to the cart. If it's just the regular toolbar color, then we know it's not in the designated area, and we won't add it to the cart. Great. Now that we know what we want to do, let's implement it. Start with ACTION_DRAG_STARTED. Call setDragMode and set it to true. I've included this method to save us some time. Scroll up and let's take a look at it. If the Boolean is true, then the cart icon is set to invisible, and the plus icon is set to visible. If the Boolean is false, the opposite happens. Scroll back down to onDrag. We need a way to designate an area for the plus sign. Once that area is clearly defined, we can just check to see if the shadow drag point is within it. If it is, then we can change the color. But how can we define that area? We can use a rect object. Scroll up to the method named getCartPosition. The mCartPositionRectangle variable is a rect object. If you're unfamiliar with rect objects, they're basically just a rectangle. They're a rectangle you can use to define an area on the screen. It's essentially like defining a rectangular object in space. We can define where the rectangle lives on the screen by calling the getGlobalVisibleRect method on the widget we want to inherit the coordinates from. We want the coordinates of this rectangle holding the cart icon. The rest of this code is just fine-tuning. This section of code retrieves the width of the screen and saves it to a variable named width. Here we're extending the left-most side of the rectangle by 18% of the screen width. Remember the coordinate system of the screen goes from 0 to the screen from left to right. So by subtracting 18% of the screen width from the left-most side of the rectangle, we're extending the position of the left-most side of the rectangle by that amount. It's just a way of making the rectangle a little bigger, or more specifically, a little wider. Here we're setting the position of the top of the rectangle to be 0, because remember, the Y axis goes from 0 to the height from top to bottom. So this is defining the top of the rectangle to be the very top of the screen, the 0th position. Here we set the right-most side of the rectangle to be the width of the screen. And finally, we subtract 3% of the screen width from the bottom-most side of the rectangle. That's going to bring it up just a little bit higher. All these adjustments were made while testing, so don't be discouraged if it doesn't come to you intuitively; it didn't come to me intuitively either. When we test, I'll explain how I came to use these numbers. Great. So we have our drag and drop zone defined. Scroll down and let's figure out if the shadow falls within it. So in ACTION_DRAG_LOCATION, create a point variable named currentPoint. The currentPoint is going to be the X and Y positions of the user's finger. Now we need to determine if the point is within our drop zone. Since we have a drop zone defined as a rectangle living in space, this is simple. Write if the rectangle contains the points X and Y coordinates, then we know it's in the drop zone; otherwise, it's not. If it's inside, then we can just set the background color to blue, too. So mCart. setBackgroundColor(this. getResources. getColor and then reference the blue2 color. If it isn't, then we can just set the color to blue1. So we're going to do the exact same thing, but change this to blue1. Before we run it, scroll up to onTouch and call the getCartPosition method. You don't need to call getCartPosition in onTouch specifically; however, you can't call getCartPosition until the UI is done setting the widgets. So it's a good idea to put it inside onTouch, because by the time the user touches the screen, the UI will be loaded. Run it and let's take a look. Select a product. Now build the shadow and drag it into position. Notice the background color isn't changing until the shadow is about 25% into it. What I mean by that is about 25% of the shadow's width is over the background before it changes color, and from the top, about 10% of the shadow is overlapping the icon. If I hadn't extended the left-most wall of the rectangle, it would have to go even further to the right before the background color changed. Comment out the left wall adjustment on the rectangle and the run the app again to see for yourself. So I'll select a product and build the shadow. See? It doesn't change color until about half the shadow is overlapping it. That's why I extended the size of the rectangle. It's so the background color will change without having so much of the shadow have to overlap it. Uncomment this, and let's work on the last part. Adding the item to the cart. Scroll down to ACTION_DRAG_ENDED. When the drag ends, we want to check to see if the background color is dark. If it is, then we can add the item to the cart. Then we want to reset the background color and set the drag mode to false. So first start by getting the background color of the cart, so Drawable background = mCart. getBackground. Then if the background is a drawable color, we want to check it. So if(((ColorDrawable) background). getColor() == getResources(). getColor then reference blue2, then we know we can add it to the cart. Then reset the background color of the cart to blue_onclick_dark, and set the DragMode to false to show the cart icon again. You might be wondering why we didn't use the ACTION_DROP action event to add the product to the cart. We can't use that action event, because it will only trigger if the shadow is released within the box bounds of the image view. ACTION_DRAG_ENDED will trigger regardless of the position. Let's run it and take a look. Select an item, build the shadow, now drag over the plus icon, and release. Great! It was added to the cart.

Module Review
Let's quickly review everything covered in the module. We started by building a DragShadow for the product variation image view. We named the class MyDragShadowBuilder. There are two methods, and the default constructor. The constructor took a View object as an input, and an imageResource representing the drawable held in the image view. OnProvideShadowMetrics was used to get and set the dimensions of the shadow. The shadow was built to be roughly half the size of the original image. OnDrawShadow is used to draw the shadow to a canvas on the screen. Once we had our shadow builder ready to go, we used the onLongPress override method in View Product Activity to instantiate it and drag the shadow. To get the image resource and image view widget it lives in, we retrieved the fragment from the view pager, then referenced the image view and the product variation image resource. Once we had those variables, we called startDrag on the imageView widget, which initiated the drag operation. Next, we worked on tracking the movements of the shadow. Fortunately for us, Android has a convenient interface just for that. The interface is called onDragListener. All we needed to do was implement the interface in View Product Activity and set the listener to the shadow. Just like we've done in the past, we wrote a switch statement in the listener's method. There were six action events we discussed. If you need a refresher on the states and when they're triggered, review the clip named Implementing the OnDragListener interface. Next we worked on handling events during the drag. When the shadow is dragged onto the plus icon in the toolbar, we want to add that item to the cart. We define the drop zone by using a rect object. The rect object defines the position in the coordinate system of the screen. If the shadow moved onto the coordinates defined by the rect object, the background color would get darker. If we release the shadow while the background color is dark, the item is added to the cart.

Dragging and Scaling an ImageView
Introduction
Imagine you just downloaded a new photo sharing application. If you double tap on an ImageView, what do you expect to happen? I know what I expect. I expect the image to become fullscreen, be zoomable, and draggable. In this module, we'll build a custom ImageView class that has all that functionality. For the duration of the module, we'll be working with the source code files in the directory, Module_5/start/CodingWithMitchStore. If you imported the code from GitHub, you'll want to start with the branch named Module_5. 2_Start. Before we begin, let's define some terms. The first of which is draggable. What exactly does it mean if something is draggable? If a widget is draggable, it means we can move it around the screen and actively track its position in terms of X and Y coordinates. The second is scalable. What does it mean if a widget is scalable? If a widget is scalable, it means we can zoom in or zoom out. The image will become larger if we zoom in, and smaller if we zoom out. The last term is pannable. Pannable refers to the ability a widget has to move around in a panoramic manner. For example, if we were to zoom in on an image, it would be considered pannable if we could then scroll left, right, up, or down, depending on where you scaled. If I was to zoom in on this image, but leave some of the top and bottom still showing on the background, the image is only pannable in the left and right directions. I can't scroll up or down, because it hasn't occupied the entire view yet. But if I was to zoom way in, I can pan whichever way I like, any direction left or right, and in any direction up or down. That's what's known as pannable. Now that we understand the terminology, let's define what we want to build. This is the test application. This will be the end result of this module. If we zoom in, but leave background showing on the top and the bottom, the image can only be draggable in the positive and negative X directions. If we zoom in more, now the image can be draggable in both X and Y directions. So you can basically move it anywhere. However, once the background is no longer visible, dragging will not be able to reveal it. You can see here I'm trying to drag it upwards, but only the images visible. The only way to make the background visible again is to rescale and zoom out by pinching two fingers. If we zoom all the way in, then zoom out slowly, notice the image view adjusts itself so the left and right sides never show the background color of black. It always fits the screen perfectly. In other words, the image view needs to force the limiting dimension to fit the entire screen. Most phones have a height that's almost double the width, so 90% of the time the limiting dimension will be the width, which is what we see with this image.

Building a Scaling ImageView Class
We've looked at the onTouch, onGestureListener, onDoubleTapListener, and onDragListener interfaces. Now we're going to look at a new interface. The simple onScaleGestureListener interface. Right-click on the Custom Views Package. Go to New, Java Class, call it ScalingImageView. Extend by the ImageView class. Right-click the red light bulb. We just need the first two constructors. The thing to notice here is the constructor with the attribute set. You need to add a constructor with an attribute set to use this widget in a layout file. For example, open fragment_full_screen_product. This is the layout that will display our full screen image. This is where we're going to add our custom ImageView. We don't have any of the custom code in this class yet, but we can still add the widget to the layout. Start by typing ScalingImageView, and there it is right there. Give it a width and a height of match_parent, and an ID of image. If you look in the main package directory, you'll notice I've also added a new fragment named FullScreenProductFragment. That's the fragment associated with this layout. Open it up. There's nothing fancy here. Right now it's just inflating the layout and getting the product object from the bundle. In the setProduct method, we can set the image now since we've added the widget to the layout. So under the widgets heading, write private ScalingImageView mImageView. Now attach it to its ID. Now set the image with glide. So Glide. with(getActivity for the context, then. setDefaultRequestOptions to requestOptions,. load(mProduct. getImage and into the ImageView. Run it and let's take a look. Choose a product, double-tap the image. As you can see, the image is being displayed like we want it. But we can't zoom or do anything with it. Open ViewProductActivity. We're inflating FullScreenProductFragment with this method. We declare the new fragment, then set the product variation to the bundle. Add the transaction to the backstack and replace it in the container. The only thing you haven't seen is this fade animation. I added this to make it look a little better when the fragment inflates. The container the fragment is inflating into is a frame layout in activity_view_product. Open activity_view_product and take a look. If you scroll all the way to the bottom, there's a frame layout occupying the entire view. View priority goes from bottom to top, so this frame layout has the highest priority of everything in the layout. So when a fragment is added to it, that fragment occupies the entire view, which is what we see happening with our full screen ProductFragment class. Go back to ViewProductActivity. We're calling the inflateFullScreenProductFragment method in the onDoubleTap gesture right here. Now that you know how this is all working, let's build our scaling ImageView.

Custom ImageView Constructors
Open ScalingImageView. This warning won't cause the app to crash, it's just letting us know that we should use app CompatImageView instead, since it has more features. There's no harm in using it. The first thing we need to do is set up some variables in the constructor. The first things we need are we need the context, a ScaleGestureDetector, we'll call it mScaleDetector, a GestureDetector, which we're well-acquainted with already, a matrix for scaling and translating the image, and a float array for getting key points in the matrix representing the image. Since there's two constructors, we'll create another method to call in each one of them. Call it sharedConstructing. It just needs to accept the context. First write super. setClickable true, and that will allow us to engage with the image. If we don't add that, none of the gestures will register. Instantiate our ScaleDetector by passing the context and a new ScaleListener. We're going to build the ScaleListener in a moment, so that's going to be red for now. Instantiate the matrix. Instantiate a new float array with the size of 9. It needs to be a size of 9, because we're going to be getting 9 values from the matrix later on. Call setImageMatrix and pass the matrix. That's going to associate the ImageView with the matrix. Setting a matrix to an image is going to help us keep track of the position of the image in space. As we've talked about in the previous modules, the phone screen is a grid of coordinates. X goes from 0 to the width of the screen this way, and Y goes from 0 to the height of the screen this way. The matrix is going to keep track of the position of the image on this grid. We can then use matrix operations to scale and translate it. For example, I could do something like Matrix. postTranslate 10, 20. That would move our image over 10 units to the right and 20 units down. We'll get more into this later. I just wanted to clarify what the matrix is and what we'll be using it for. Set a scale type of matrix, since that's what we're going to be using to manipulate it, so set setScaleType(ScaleType. MATRIX). We need to implement the GestureDetector interface, onTouchListener interface, and onDoubleTapListener interface. So write those in up here. View. OnTouchListener, GestureDetector. OnGestureListener, GestureDetector. OnDoubleTapListener. Now click the red light bulb and implement the methods. I'm just going to rearrange this a little bit. Personally, I like the onTouch method above the rest. Then the onDoubleTap method's at the bottom. Now instantiate the GestureDetector, so GestureDetector = new GestureDetector context and this to reference the interface, and set the onTouchListener. So setOnTouchListener and then this. Call sharedConstructing in each of the constructors, and pass the context.

Custom ScaleGestureDetector
To save time, I've created a Gist containing the code for our custom ScaleGestureDetector. Alternatively, you could just view the branch for the end of this clip or the end of this module. That's up to you. If you want to use the Gist, open a new browser window and visit this URL. Scroll through the section titled ScaleGestureDetector. Now copy all that code. Go back to ScalingImageView, and paste it in. Take the variable and move them to the top. I'm just going to cut them. Scroll up and paste them below the shared constructing variables. Just like when we're using the GestureDetector, the onTouchEvent for the ScaleListener are captured by onTouch, so once again, we need to pass the TouchEvent in the onTouch override method. Now pass the TouchEvent to the GestureDetector, and then to the ScaleDetector. Scroll back down to the custom ScaleGestureDetector class, and let's walk through it. We have two override methods here, onScaleBegin and onScale. OnScaleBegin is called when you begin changing the scale. Pretty intuitive. The onScale is triggered every time there's a change made to the scale factor. A ScaleGestureDetector works by keeping track of something called a ScaleFactor. As you can see here in the first line, we can access the ScaleFactor by calling detector. getScaleFactor. If you zoom in, or in other words, make a reverse pinching gesture with your fingers, the ScaleFactor will return a value larger than 1. If you make a pinching gesture, it returns a value less than 1. Run it and let's watch the log for this onScale call. Choose a product. Inflate the scaling image view by double-clicking. Now watch the log carefully. I'm going to make a pinching gesture. Notice the numbers are ranging anywhere from 0. 95 to 0. 99. The faster I make the pinching motion, the lower they go. If I pinch very fast, you can see a low value of about 0. 8. Then if I make the reverse gesture, you see the opposite happening. If I move quickly, I see a high number of about 1. 2. So the ScaleDetector returns a value based on how quickly you're trying to pinch or expand the view. So how can we use that to scale our image? First, we set the previous scale value, the scale value from the previous pinch or expansion, then we get the new scale value. We do that by multiplying the previous scale value by the new scale value. If the user is trying to expand the view, the two numbers multiplied will be greater than 1, which will result in a number greater than the 2 numbers themselves. The overall trend is an increase. Here's an example. It could be something like 1. 05 multiplied by 1. 10, which equals 1. 155. So the overall scale would have increased by 0. 105. If the user made a pinching motion, the numbers would look something like this, 0. 95 multiplied by 0. 85, which equals 0. 8075, so the overall scale would have decreased by about 0. 1425. This bit of logic is for making sure the ScaleFactor never exceeds the maximum allowed value, or falls below the minimum. I've set the MaxScale value to be 4, and the MinScale value to be 1. This bit of logic is for actually scaling the image. When you're scaling the image, there's two cases when it comes to the focus point. If the image isn't occupying the entire view, then you want to zoom from the middle of the view, which is what you see here. Notice the focus point is very clearly in the center of the view. But if I zoom in some more, notice where it's zooming from now. My fingers are pinching in the top left-hand corner, and that's where the zoom is focusing. If I zoom out from that same point, the focus changes once the background is visible. That's what this logic is testing. If the image is not occupying the entire view, then we scale from the middle. If the image is occupying the entire view, then we scale from wherever the user is pinching or expanding. If this is still unclear to you, write some log outputs and take a look later when we finish the module. Write something like VIEW CENTER FOCUS for this case and DETECTOR_FOCUS for this case. Then you'll be able to clearly see what's happening and when.

Fitting an ImageView to the Screen
I'm going to run the app and show you what we're going to build next. Select a product, double-tap. When the fragment is inflated, the image view isn't centered or scaled properly. That's what we're going to work on. If you open the Gist we looked at earlier, there is more code snippets that we didn't use yet. Scroll to the FitToScreen. java section. Copy all that, open ScalingImageView, and paste it just above onTouch. This method is responsible for getting the dimensions of the drawable set to the ImageView, then scaling the matrix accordingly. The first thing we need to do is reset the scale. Remember the SaveScale variable is essentially the total ScaleFactor being applied to the image at any given time. So by setting it to 1, we reset the scaling. Next we need to get the width and the height of the drawable. That's these two integer variables right here. Once we have the width and the height of the image, we can get the appropriate ScaleFactor for each dimension. The ScaleFactor for the X component is the total viewWidth divided by the width of the image. Then the ScaleFactor for the Y component is the total viewHeight divided by the total height of the image. We're interested in the smallest of the two. We need the smallest, because we want to know whichever is the limiting factor. The side that's closest to fill the total height or the total width will be set to fill it, and be therefore the limiting factor. In our case, the limiting factor is clearly the width. The width is almost always going to reach its maximum before the height. The height has all this leftover space after the width is filled. This is going to be the case 90% of the time if you're dealing with square images, since modern device screens usually have almost double the height as compared to the width. But of course, this depends on the shape of the image. Our images are square. If your images were rectangular, it would be a different story. We can determine the minimum by calling Match. min, then pass scaleX and scaleY. Set the scales of the matrix by calling setScale on our matrix variable. Now it's time to center the image using the matrix translation. Remember, in our case, the drawable width is going to be set to the screen width. But the height has all this leftover space on the top and the bottom. We need to center the image between the empty space. So basically we need to get the total amount of empty space and then distribute it evenly on the top and the bottom of the screen. Then the image will be centered perfectly. That's what these redundant space variables are for. The redundantYSpace gets the total amount of empty space in the height dimension, and the redundantXSpace variable gets the total amount of empty space in the width dimension. In our case, the redundant space in the X dimension will be 0, because the width is our limiting factor. But the redundant space in the Y dimension won't be. Take a look at these logs when we test to see for yourself. Now that we have the total amount of redundant space, we can translate the matrix accordingly. Notice up here we divide the redundant space by 2. That's how we evenly distribute it to the top and the bottom. Then when we post the translation, the image gets moved upwards, half of the redundant space, meaning there's still half remaining below it. The last step is setting the actual width and height of the image. That's the origWidth and origHeight variables right here. We take the total width or height of the screen, then subtract two times the redundant space. That will give us the total space occupied by the image. And finally, we set the matrix to the image now that it's been scaled and translated. We want this method to be called before the drawable is actually set to the view. We can use the onMeasure override method for that. Press Ctrl+O on Windows or Command+O on Mac, and insert the onMeasure method. This method is used to calculate the space requirements for the view. First let's get the viewWidth and viewHeight. We can use MeasureSpec. getSize and pass the width and the height. If the total ScaleFactor is equal to 1, then we want to fit the image to the screen. So if mSaveScale = 1, then call fitToScreen. Run it and let's take a look. Select a product, double-tap, great! The image is fitting to the screen perfectly. And we can see the width is clearly the limiting factor.

Dragging a Custom ImageView
Now it's time to work on dragging and scaling the custom ImageView. Open the Gist we've been working with. Copy everything from the onTouch section here. Go to ScalingImageView and paste it over the current onTouch method. Take the variables and move them to the top of the file. We're going to use these variables to track the position of the image on the screen. Now we have three action event cases, ACTION_DOWN, ACTION_MOVE, and ACTION_POINTER_UP. Let's start with ACTION_DOWN. When the user first presses their finger down on the screen, the point named last is set to where they pressed. You can see current point is defined by wherever the user is pressing. Then the starting point is set to last. So at this point, both start and last are set to the same location on the screen. Then the DRAG mode is set to DRAG, meaning the image can now be dragged around the screen. In ACTION_MOVE, the first thing we check is if the DRAG mode is set to DRAG. That means the image won't be draggable unless ACTION_DOWN is first called. This is just a way to make sure the proper initial conditions are captured with mLast and mStart. As the user drags their finger, onMove will continue to trigger. Dx and dy represent the relative movement in the X and Y positions respectively. To actually move the image, we use the postTranslate method once again on the matrix. When the translation is complete, we need to set mLast to the current point. That way we're ready for the next move. Lastly, we have ACTION_POINTER_UP. All we're doing is resetting the drag mode to none. After the switch, we need to call setImageMatrix to post changes to the image. This isn't going to work 100% correctly, but let's run it and take a look. Okay, now I'm going to try scaling. That works. Now I'll try dragging it around. It mostly works, but there's not boundaries. That's really the only issue. The image is draggable anywhere, but we only want it to be draggable under certain conditions. So that's what we need to work on. We'll start with setting some boundary conditions for when the image is occupying the entire view, or in other words, when the image is in its default starting position. Create a new method named getFixDragTranslation, and have it return a float. This method is going to be responsible for deciding whether or not to allow translation in the X or Y direction during a drag. We need three input parameters, float delta, float viewSize, and float contentSize. Delta is the translation magnitude. That's going to be either dx or dy. ViewSize is the size of the view. That's going to be either the viewWidth or the viewHeight. ContentSize is going to be the original scaled width of the image, or the original scaled height of the image. We just want to know if the contentSize is less than or equal to the viewSize. If it is, then we shouldn't allow a translation because it's not occupying the entire view. We only want it to be draggable if the image is occupying the entire view. So if contentSize is less than or equal to viewSize, then return 0. If it is occupying the entire view, then return the delta and allow the translation. Inside ACTION_MOVE, we can adjust the logic now. Declare a variable for the X translation and call our new method while passing all the required width parameters. Do the same thing for the height, but change the variable to represent all the height parameters. Then post the translation to the matrix. So matrix. postTranslate, then fixTransX and fixTransY. Run that and take a look. Okay, right now I'm trying to drag the image around and it's not working, so that's great. We achieved what we wanted to. But now I'll zoom and see what happens. Notice I did not zoom and pass the redundant space in the height. Right now if I try to drag vertically, nothing happens. But I am able to drag horizontally, and that's not correct. I shouldn't be able to drag past the width of the image. So that's what we're going to need to fix next.

Correcting Image Translations
We've set some restrictions on the draggability of the image, now it's time to correct the rest of the matrix translations. Refer back to the Gist we've been using. Go to the FixTranslations section. Copy the code and paste it into the scaling ImageView class. I'm going to put mine just below the FitToScreen method. We need to call fixTranslation after we post a translation to the matrix. Scroll down to the onTouch method and call fixTranslation right here. Scroll back up and let's walk through the code. FixTranslation is going to be our ImageViewTranslationCorrection method. To start, we get nine values from the matrix representing our image. These nine values are some important defining our ImageView matrix. The two points we're interested in are in the second and fifth positions of the array. The value in the second position defines the most recent translation in the X direction, and the value in the fifth position defines the most recent translation in the Y direction. These two values MTRANS_X and MTRANS_Y are just constants representing the numbers 2 and 5. If you hold down Ctrl and hover over them, you can see this one is 2, and this one is 5. I'll say it again so it's clear. These positions in the matrix represent the most recent translations done to the X and Y components. For example, if we scroll down to onTouch and look at the ACTION_MOVE case, if there was just a translation posted here to the matrix and we call to FixTranslation, we would get these values from the second and fifth position in the matrix. So if I moved 5 units over to the right and 10 units downwards, the values in the second and fifth positions of the matrix with 5 and 10 respectively. Scroll back up and let's continue. Now we're going to do the same sort of thing we do with the drag. We're getting two values representing the translations in the X and Y direction, but the getFixTranslation method will return if the translation doesn't meet the boundary conditions. Let's look at the getFixTranslation method. First let's talk about the minTrans and maxTrans variables. I want to clarify something about these variables before we move on. I couldn't really think of a better way to name them, so I used minTrans and maxTrans, but they don't really correspond to mininums and maximums, it's more like negatives and positives. MinTrans ranges from negative viewSize minus contentSize up to 0, and maxTrans ranges from 0 up to viewSize minus contentSize. Basically these two if statements define two possible scenarios. This case is for when ImageView is not zoomed, and this case is for when it is zoomed. If it's not zoomed, the variable viewSize is going to be greater than or equal to the contentSize, since contentSize is the actual size of the image. In the most extreme case of not zoomed, the contentSize will be quite a bit less than the viewSize. So this maxTrans variable will be very positive. If we consider the zoomed case, the contentSize will be a lot larger than the viewSize, making minTrans negative. That's essentially what this logic is doing. It determines if there's any portion of the ImageView not being displayed in the X and Y coordinates of the screen. Now let's move onto this part of the logic. I'm going to use examples to explain this, and in order to use examples, we need to insert a couple more logs. Scroll to the onTouch method, write fixTransX, and then output fixTransX, and then fixTransY and output fixTransY. Scroll back up to getFixTranslation. Now run it and take a look. The first thing to notice is that none of these logs are being called right now. I'll try and drag it and none of these logs are printing. That's because the fixTransX and fixTransY values are 0. I'm sure that's confusing, but don't worry, we'll come back to that. Now I'll scale the image slightly by zooming in. Now that it's zoomed in, I'll drag the image to the left. Notice now we see some log output. Let's analyze what's happening. The most recent translated is denoted by the fixTransX value right here. Notice it's the exact negative of the return value. These values are meant to cancel out. They're meant to cancel out, because I've dragged the image to the edge of the screen. I shouldn't be able to translate it anymore. So what's happening here is a translation in the X direction is applied to the matrix, then the fixTranslation method applies another translation of the exact same magnitude in the opposite direction. That's how we impose limitations on the drags. A translation is done, then the fixTranslation method checks to see if it's valid; if it isn't, another translation is applied to correct it. If it is valid, then it returns 0. Now let's consider an example of a valid translation. Watch what happens when I drag the image to the right. I'll make sure not to reach the edge. We don't have any of the logs printing. That means the translation is within the allowed bounds, and no correction is necessary. If I dragged it all the way to the right, you see the correction log start printing. Once again, we have the fixTransX and then the return value canceling out. This is hands-down the most confusing part of the ScalingImageView class. Don't be discouraged if you don't get it right away; keep playing around with the scaling and keep dragging and looking at the log outputs. I'm sure you'll have a moment when you think to yourself, aha, I get it! We're almost done with our ScalingImageView class. If we look at the app, there's only one thing not quite working properly. If I zoom in and then drag the image over and zoom out, the image isn't centered as I scale. Lucky for us, we've already done all the heavy lifting needed to solve this problem. Scroll to the onScale method. Just call fixTranslation before the return statement, now run it, and let's take a look. Okay, select a product, and double-tap. Now I'm going to zoom in and drag it over. Now zoom out. Great. The image stayed within the bounds we've defined. Our ScalingImageView class is almost complete. The last piece of functionality is an overall reset of the translations and scaling on the image. Scroll down to the onDoubleTap method. Call fitToScreen. Now when we double-tap the image, it will reset and fit to the screen, just like when it's first inflated. Run it and let's test. Select a product, double-tap, now I'm going to zoom in, and double-tap. There we go. So everything is working as we expect at this point.

Module Review
I'd consider this module the most difficult of the entire course. Let's quickly review everything that was covered. We started the module by creating a new Java class named ScalingImageView. ScalingImageView is a custom class that extends the AppCompatImageView class. We used it to inflate a scalable, draggable, and pannable image. To start, we added two default constructors to the class. Then we added the widget to the layout file. Next we built the sharedConstructing method. This method is meant to be an extension of the default constructors. It contains many of the variables willing to scale and translate the ImageView. At this point, we also implemented the required interfaces for the class. We needed the OnTouchListener interface, OnGestureListener interface, and OnDoubleTapListener interface. Next we built a custom ScaleGestureDetector class named ScaleListener. The ScaleListener is responsible for returning a numeric value when the user zooms in or out on the screen. The value can be accessed by calling. getScaleFactor on the ScaleGestureDetector object in the onScale override method. We kept track of the total scale factor applied to the ImageView using the mSaveScale variable. To scale the image, we multiply the current scale factor by the scale factor returned from the listener at any given time. If the user is making a pinching motion with their fingers, the detector will return a scale factor in the range of 1, 2, 0. 8. Suppose we had a current scale factor of 1. 2 and the scale detector returned a scale factor of 0. 8. That means the new scale factor would become 1. 2, multiply it by 0. 8, which equals 0. 96. Therefore, shrinking the overall scale by 1. 2 - 0. 96, which is 0. 24. The opposing thing happens when expanding the view. Suppose we had a current scale factor of 1. 2, and the scale detector returned a scale factor of 1. 05. That means the new scale factor would become 1. 05 multiplied by 1. 2, which equals 1. 26. Therefore, expanding the overall scale factor by approximately 0. 06, which is 1. 26 - 1. 2. When zooming in or out on the image, we can define a focus point. The two focus points we looked at were the center of the screen and the current focus point of the detector, or in other words, where the user has their fingers on the screen. At this point, if we viewed full screen product fragment, the image looked like this. It wasn't getting centered properly. To resolve this, we added a new method called fitToScreen. FitToScreen calculates the redundant space in the width and height of the view. In our case, there's only redundant space in the height because the image is a square, and the screen is much higher than it is wide. So it fits the width to the width of the screen and then translates the image using the redundant space. Next we worked on the dragging of the image. We wrote logic in the onTouch method to detect when a drag is starting and then detect the changes as the user moves their fingers around the screen. The variables dx and dy represent the change in the X and Y values respectively. The getFixTrans method is responsible for determining if the image can be dragged. It just checks to see if the image has been scaled. If it has, then it returns the delta. If it hasn't, then it returns 0 and no drag is allowed. At this point, we could scale the image and drag it around the screen, but there were no boundaries. You could drag it anywhere. This is obviously not ideal. To improve this, we built two new methods. FixTranslation and getFixDragTrans. The explanation is pretty detailed in that clip, so if you're still confused, I suggest watching it again. But here's a brief summary. We call fixTranslation after translation is applied to the matrix, but before the changes are posted to the image. That way we have a chance to correct the translation before changes are sent to the ImageView. We get the most recent translations done to the width and the height by getting the values from the matrix. Then we used the getFixTranslation method to determine if the translations were valid or not. GetFixTranslation starts by determining if the image was scaled or not scaled. If it's not scaled, this if statement runs. The maxTrans variable will then represent a number between 0 and the viewSize - the contentSize. The most important thing to notice here is that it's positive. If the image is scaled, then this if statement runs. This is the opposite of the above case. The minTrans variable will represent a number from negative viewSize - contentSize up to 0. The most important thing to notice here is that it's negative. At this point, we went through some examples, and I showed you the getFixTranslation method would always return 0 if the drag operation was valid. Or in other words, if the ImageView wasn't at the edge of the view. So there was no fix applied to the translation. However, if the ImageView was at the edge of the view, either on the top, the right, the bottom, or the left, a correction value would be returned. The correction value would be equal to the magnitude of the last translation, therefore resulting in a net translation of 0. You'll likely find this the toughest part of the course. I encourage you to watch the clip again and watch the log outputs if you're having trouble understanding.

Leveraging RecyclerView Scroll Gestures
Introduction
In this module, we're going to increase the interactability of RecyclerViews by implementing a custom OnScrollListener and a SwipeRefreshLayout. For the duration of the module, we'll be working with the source code files in the directory Module_6/start/CodingWithMitchStore. If you imported the code from GitHub, you'll want to start with the branch named Module_6. 2_Start. So, how exactly does a scroll listener improve interactability? Well, it doesn't directly. But you can use it to listen for events when users are scrolling, and then trigger custom methods, and that can improve interactability. We're going to explore the various RecyclerView scroll states that you can leverage in your applications. We'll be able to detect when a user begins to scroll, when a user stops scrolling, when a user is actively scrolling, and when a user makes a flinging motion on the list. Have you ever used a swipe refresh layout? If you have, I'm sure you love them. I know I do. And it's for good reason. They look good, and they're so easy to implement. Not sure what it is? This is the mobile app for YouTube. See this circular loading animation? That's a swipe refresh layout. You can trigger it by dragging downwards on a view. In this case, it's a list of videos. We'll be implementing this same thing in our application to refresh a RecyclerView.

Building a Custom OnScrollListener
If you're following along with me, make sure you get the updated source code for this module. If you need a review on how to use the source code files for the course, go back and watch the clip named How to Use the Source Code Files. As I mentioned, I made a lot of changes to the code since the end of the previous module. Now if we click on the cart icon in the toolbar, we're navigated to a list of cart items. Right now the list is kind of boring. To improve the interactability, we're going to build a custom RecyclerView on scroll listener. Open ViewCartActivity. There's not much going on here. We have a RecyclerView, a list of products being displayed in that RecyclerView, and a method for setting the visibility of a floating action button. Currently the floating action button is invisible to the user. What we want to do is set the floating action button to visible when the user scrolls to the bottom of the list. Then if they click on the button, they're automatically scrolled back to the top. Seems simple enough. Let's get started. First, we need to build the custom OnScrollListener class. Write class CartScrollListener extends RecyclerView. OnScrollListener. Get the override methods by pressing Ctrl+O on Windows or Command+O on Mac. Select onSCrollStateChanged and onScroll. Those are the only two we need. OnScrollStateChanged is used for detecting state changes to the RecyclerViewScroll state. It triggers at specific times. You can see it gives us an integer state variable to use in our custom logic. The states we can test for are SCROLL_STATE_IDLE, SCROLL_STATE_FLING, and SCROLL_STATE_TOUCH_SCROLL. We're not actually going to be using the scroll states for anything in this course, but let's explore them anyway so you know where they are for your other projects. The first one is SCROLL_STATE_IDLE. SCROLL_STATE_IDLE will be called when the user stops using the RecyclerView scroll. So we know when it's being called. Just write a log that says stopped. Next is SCROLL_STATE_FLING. I bet you can guess when this one's called. A fling is defined by the action of moving a finger downwards or upwards on a RecyclerView very quickly. The finger must leave the screen at the end of the fling motion. The log for this one can just say fling. The last state is touch scroll. Touch scroll will be called as soon as the user touches the RecyclerView and scrolls it. Basically it's the state that opposes idle state. Touch scroll will trigger when the user first touches and begins to scroll. Then when they lift their finger, the state idle is triggered. At the end of the clip, we'll experiment with the RecyclerView and take a look at the log outputs. But for now, let's work on the onScroll method. OnScroll is a callback method that's invoked when the RecyclerView has been scrolled. It's called when the scroll is completed. Dx is the amount of horizontal scroll, and dy is the amount of vertical scroll. Since we're working with a vertical RecyclerView, the dx value will always return 0. Now, how do we decide to either show or hide the floating action button? We want to show it when the user reaches the bottom of the list. Lucky for us, RecyclerViews have a method called canScrollVertically that we can use just for that. Then call the method setFABVisibility and pass true; otherwise, setFABVisibility and set it to false. CanScrollVertically will return true or false, depending on if the user has reached the end of the list, given the direction passed as an input. If positive 1 is passed as an input, the method will return true if the RecyclerView can be scrolled downwards. If -1 is passed as an input, the method will return true if the RecyclerView can be scrolled upwards. So here we're checking to see if the list can be scrolled downwards. If it can't, we set the floating action button to visible, and if it can, then we set it to invisible. This will work, but will run into a few problems. Set the listener to the RecyclerView up here in the init RecyclerView method, and let's run it and highlight the problems. I'm going to quickly add some products to the cart. I'll just add three hats. Now I'll navigate to ViewCartActivity. Notice the floating action button is visible, even though the list isn't large enough to be scrollable. This is problem number one. The floating action button should never show if the list is not scrollable. I'm going to add a few more items, so I can show you the next problem. I'll just add some more hats. Now go back to the cart. Notice the floating action button was visible for a second when the activity was first coming into view. I'll go back and do it again so you can see. Now clicking the cart again. See? It was there for about a second before disappearing. This is not what we want. What's happening here is the listener is being set to the RecyclerView before the list item views are populated. So the listener thinks we're at the bottom of the list, it sets the floating action button to visible, then the rest of the items load. That's problem number two. And one last thing I want to mention. When I click the floating action button, nothing happens. So we'll need to add an onClickListener to the button and scroll the user to the top of the list when it's clicked. Let's work on problem number one first. Go to the cart listener's onScroll method. Before we set the floating action button visibility, we need to check and make sure the list is scrollable. Just above the cart listener, create a new method that returns a Boolean named isRecyclerViewScrollable. Right return mRecyclerView. computeVerticalScrollRange > mRecyclerView. getHeight. Now if the RecyclerView is scrollable, or in other words, if it has enough items to be scrollable, then this will return true. Surround the if else block in the onScroll method with another if statement and call isRecyclerViewScrollable. Problem one solved. Now for problem number two. Scroll to the init RecyclerView method. We're going to use something called a view tree observer to listen for when the layout views are done loading. Then we'll set the listener to the RecyclerView. So write RecyclerView. getViewTreeObserver, then addOnGlobalLayoutListener, and new GlobalLayoutListener. We weren't doing it before, but let's add some extra logic to handle the deprecated case for RecyclerViewScrollListeners. Before Android version Marshmallow, you set RecyclerView OnScrollListeners by writing RecyclerView. setOnScrollListener, and then new CartScrollListener. But as you can see, that's deprecated now. So, we'll surround this in an if else block and check for Android version m, which is Marshmallow. Then if it's greater than Marshmallow, we use addOnScrollListener. Last problem. Let's add the onClickListener to the floating action button. Scroll up to the top and implement the onClickListener interface. Click the red light bulb and implement the method. Scroll up to onCreate and set the listener interface to the floating action button. Scroll back down to the onClick override method. Write if(view. getId() == fab, then RecyclerView. smoothScrollToPosition 0. That should resolve all of our issues. Run it and let's take a look. First just add three hats to the cart. We don't want the list to be scrollable yet. Now navigate to the cart. Great! I didn't see the floating action button when I first opened the activity. Now go back and add some more hats to the cart. I'm just going to finish adding them all. There's six hats in total. Now navigate to the cart. So far so good. No floating action button. Now I'll scroll to the bottom. There's the floating action button coming into view. Now I'll click the button. Cool! It scrolls me to the top of the list.

Implementing a SwipeRefreshLayout
SwipeRefreshLayouts are my favorite way to let users know a view is refreshing, or a list of items is refreshing. If you have a Gmail account, you've definitely seen a SwipeRefreshLayout. It's also used in the YouTube app, and many others. It's kind of the standard Android way to refresh lists. Open ActivityMain and let's add a SwipeRefreshLayout to the view. Scroll down to where the RecyclerView is. We want to put the RecyclerView inside the SwipeRefreshLayout. Open a new tag and select SwipeRefreshLayout. Give it a width of match_parent, height of match_parent, and an id of swipe_refresh_layout. Now cut the RecyclerView and paste it inside the swipe_refresh_layout. Open MainActivity. First we need to implement the SwipeRefreshLayout on RefreshListener interface. So write SwipeRefreshLayout. OnRefreshListener. Click the red light bulb and implement the OnRefresh method. Scroll up to the widgets heading and declare a SwipeRefreshLayout object named mSwipeRefreshLayout. Now attach the object to its id in onCreate. Set the onRefreshListener to the object. Now scroll down to the onRefresh method. Now, since this isn't technically a real application, we just want to make it look and feel like the list is being refreshed. So we'll just randomize the order of the list and reload it. Typically when refreshing a view or a list using a SwipeRrefresh view, I make a method named onItemsLoadComplete. The method doesn't actually take any inputs; its job is to notify the adapter that the list has been changed, and then tell the SwipeRefreshLayout to stop the refresh animation. Now in the onRefresh method, we do whatever it is we need to do to refresh the list. In this case, that's going to be shuffling the order. Then call onItemsLoadComplete. Of course, if this was a real application that was communicating with a server for data, you'd likely make a server request here and get the new relevant data. We should be good to go now. Run it, and let's take a look. Pull downwards on the RecyclerView, and there we see the SwipeRefresh animation, and the list items being shuffled.

Module Review
The goal of this module was to improve the interactability of RecyclerViews by implementing a custom OnScrollListener and a SwipeRefreshLayout. We started the module by talking about the changes to the source code. Now users have the ability to navigate to an activity holding a list of items that they've added to the cart, but it's kind of boring. There is really no interactability other than simply scrolling the list. To improve on that, we built a custom OnScrollListener for the RecyclerView. The custom OnScrollListener had two override methods, OnScrollStateChanged, and OnScrolled. In OnScrollStateChanged, we wrote logic to check for the three possible states of a RecyclerView; STATE_IDLE, STATE_FLING, and STATE_TOUCH_SCROLL. STATE_IDLE is triggered when users stop scrolling. STATE_FLING is triggered when they make a flinging motion with their finger. And STATE_TOUCH_SCROLL is triggered when they first begin scrolling. We didn't use OnScrollStateChanged to execute any methods. It was just for exploration. OnScrolled is where we wrote logic pertaining to the application. OnScrolled is triggered whenever the list is being scrolled. If the user reaches the bottom of the list, the floating action button layout is set to visible. If the user isn't at the bottom of the list, the floating action button is made invisible. When the user clicks the button, they're automatically scrolled to the top of the list. The only interaction on the RecyclerView at this point in MainActivity was scrolling. We started by adding a SwipeRefreshLayout to ActivityMain. xml. Remember, you must surround the view you want to refresh with the SwipeRefreshLayout. We only want to refresh the list items in the RecyclerView, so we put the RecyclerView inside. In MainActivity, we implemented the interface, set the listener to the layout, and wrote a method for shuffling the list items in the RecyclerView. The actual shuffling of the list items was done in the onRefresh override method. We wrote a second method for telling the SwipeRefreshLayout to stop refreshing, and then notified the adapter that the list items had been updated. Personally, I love the way SwipeRefreshLayouts look, and they're so easy to implement.

RecyclerView Interactions with ItemTouchHelper
Introduction
In this module, we're going to implement an ItemTouchHelper class for the RecyclerView in ViewCartActivity. For the duration of the module, we'll be working with the source code files in the directory Module_7/start/CodingWithMitchStore. If you imported the code from GitHub, you'll want to start with the branch named Module_7. 2_Start. So what exactly is an ItemTouchHelper? ItemTouchHelper is a utility class used to add swipe to dismiss and drag and drop support to RecyclerViews. It works with the RecyclerView and a Callback class. The Callback class is responsible for configuring what type of interactions are enabled and also receives events when the users perform these actions. That was the technical jargon. Now let me show you what we're going to be doing in a practical sense. The ItemTouchHelper class will help us build this interactive RecyclerView. As you can see, I have a bunch of items added to the cart, and there's different headings in the list. There is Must Have, Maybe, and Probably Not. Since this is a shopping app, it's meant to assist the user in deciding what products they're going to purchase. We'll add these headings to the RecyclerView list by inflating different views in the RecyclerView adapter. If I hold my finger down on a list item, it highlights. The highlight signifies the ability to move the list item around. Notice I can now drag the list item into a new position. We'll also be using the ItemTouchHelper to make the list items swipeable. Notice if I swipe to the right, the item is removed from the list and a toast prints out saying removed from cart.

Inflating Different Views in a RecyclerView
Probably one of the most common questions I get about RecyclerViews is how do you inflate different layouts for specific list items? The answer is surprisingly simple. RecyclerView adapters are actually built to accommodate different layouts. We'll start by taking a look at the two different layouts we want to inflate in the RecyclerView. Open layout_cart_list_item. List is the layout we've been inflating already. It has an ImageView for the product image, a TextView for the product title, and a TextView for the product price. The second layout we'll be inflating is layout_cart_section_header. This is what we'll use to display the section headers. It's a very simple layout. It's just a TextView wrapped in a relative layout whose background color is set to a shade of gray. Now open CartRecyclerViewAdapter. This is where the logic is written to inflate the two different layouts. The first thing I want you to notice is the two constants defined at the top, PRODUCT_TYPE and HEADER_TYPE. We'll be using these two integers constants to determine which layout to inflate in the onCreateViewHolder method. As you can see, there's a switch statement with these two cases and a default. Case one is the PRODUCT_TYPE integer. If the ViewType which we get from this input field is PRODUCT_TYPE, then the layout_cart_list_item item is inflated. If the ViewType integer is HEADER_TYPE, then the layout_cart_section_header layout is inflated. The default is set to inflate the cart_list_item layout. But how is the ViewType set? How does the onCreateViewHolder method know which is PRODUCT_TYPE and which is HEADER_TYPE? If you scroll down, there's a method named getItemViewType. This is what I meant by the RecyclerViewAdapter class is built to accommodate different layouts. This is a method from the RecyclerViewAdapter class. Whatever's returned from this method will get passed as an input to the onCreateViewHolder method. Just to be clear, I'll say it again. Whatever is returned by this getItemViewType method is passed as an input to the onCreateViewHolder method right here. So for each list item, getItemViewType is called and then the return value is passed up here. Take a look at how we're using it. The if else logic is checking for the presence of the type variable in the product. If no type is present, then it returns a HEADER_TYPE. If there is a type variable, then it returns a PRODUCT_TYPE. Now you're probably thinking, but all products have a type, and you're right. But if you open ViewCartActivity, you'll understand what's happening. Take a look at the getProducts method. We're adding three new products to the products list. Where the title should be, we're referencing the ProductHeaders class and adding the HEADER_TITLES. The image resource is set to 0. The type is blank, the price is 0, and the serial number is 0. The type field being blank is the key here. Remember, the getItemViewType method is checking for the presence of something in the type field. If there isn't, it means the header view will be inflated. So the rest of the items in the cart will be added as usual by the addAll method call, and the headers will be added just before. Go back to CartRecyclerViewAdapter. Now take a look at onBindViewHolder. Once again, we have two cases for the view. A case for the product view and a case for the header type view. The PRODUCT_TYPE view is exactly the same as we were doing before. It's using the ViewHolder class we define below. But in the HEADER_TYPE, there's a different ViewHolder class. It's called SectionHeaderViewHolder. Scroll down and take a look at it. The ViewHolder class has a single text view, and it's referring to layout cart section header layout. Scroll back up to onBindViewHolder. That's it. That's all the logic necessary to inflate two different layouts in a single RecyclerView. Run it, and let's see if the headers are showing. Go to the cart. There's our headers.

Leveraging ItemTouchHelper.Callback
We have our two different layouts inflating in the RecyclerView. Now it's time to build the ItemTouchHelper class that's going to help us move and swipe the list items. To keep things organized, we're going to create a new package just for the ItemTouchHelper code. Call it touchhelpers. Right-click on the new package, go to New, Java class, and we'll call it CartItemTouchHelperCallback. As the title of the clip implies, we're going to be extending the helper by ItemTouchHelper. Callback. Click on the red light bulb and implement the required methods. This is a good start, but we're going to need a few more methods for the class. Press Ctrl+O on Windows or Command+O on Mac. We need clearView, isItemViewSwipeEnabled, isLongPressDragEnabled, and onSelectedChanged. Okay, now let's talk about what each one of these does. IsLongPressDragEnabled is for enabling draggability on the list items. We want to drag the list items, but we're going to implement the onGestureListener interface in the cart RecyclerViewAdapter for that. Enabling the drag here doesn't quite have the flexibility that we'll need to provide a seamless user experience. So set this return to false and disable this feature. IsItemViewSwipeEnabled is for enabling the swipe functionality. We want to return true here for this one. This is going to allow the list items to be swipeable. ClearView is called when the list item is let go, or in other words, when the user removes their finger from the list. In this method, we want to set the background color of the viewHolder to white, since that's the default color when the user isn't touching the screen. Write viewHolder. itemView. setBackgroundColor and pass white. OnSelectedChanged is called when an action is performed on the list. For example, we're going to be dragging list items around, so we can check for a drag state. Write if action = ItemTouchHelper. ACTION_STATE_DRAG, then it's being dragged. Then if it's being dragged, we want to set the background color to a light gray color. GetMovementFlags is the first of the required methods for the class. This method is responsible for setting the allowed movement flags on the viewHolder. Since we have more than one viewHolder, we'll also have to take that into account. So write if(viewHolder instanceof CartRecyclerViewAdapter. SectionHeaderViewHolder). Then return 0. We want to return 0 here, because we don't want to move the headers. We only want to move the products in the cart. The headers are going to be static. So if the logic is able to pass this return statement, then we know the viewHolder is of the PRODUCT_TYPE. We can get the allowed dragFlags by writing final int dragFlags = ItemTouchHelper. UP, or ItemTouchHelper. DOWN, and the swipeFlags by writing final int swipeFlags and then ItemTouchHelper. START or ItemTouchHelper. END. Then return the flags by writing return makeMovementFlags(dragFlags, swipeFlags). That's going to enable dragging and swiping on the list items holding products. OnSwiped will be called when a list item is swiped. We actually need the help of an adapter class to take action when the items are swiped. So I'm going to leave this blank for now. OnMove is the same. This is going to be triggered when a list item is moved to a different position in the list. However, our ItemTouchHelper class doesn't keep track of the positions of the products in the list. It only moves them around. So we'll need to use a helper class here to take action in CartRecyclerViewAdapter when that item's positions are changed. I'm sure you're a little confused about what I just said. But don't worry, it will make 100% sense by the end of the module. That's pretty much it for the CartItemTouchHelper callback class. We just need to build our helper class for taking action in the RecyclerViewAdapter and then it's all done. Right-click on the touchhelpers package, go to New, Java class. Make sure to change this to an interface. Call it ItemTouchHelperAdapter. We need two methods; one to help us take action when the items are moved, and one to help us take action when the items are swiped. So write void onItemMoved(int fromPosition, int toPosition) then void onItemSwiped(int position). And that's it. Go back to CartItemTouchHelperAdapter. We need to add the helper to the class. So start by declaring the object. So private final ItemTouchHelperAdapter mAdapter. Now insert a default constructor, so Alt+Insert on Windows or Command+Insert on Mac, at least I think it's Command+Insert on Mac, and insert the constructor. Now scroll down to the onSwipe method. Now that we have our Adapter class, we can call adapter. onItemSwiped and write viewHolder. getAdapterPosition. So now any class implementing our itemTouchHelperAdapter interface will get notified when a list item is swiped. Now for the onMove method. Write mAdapter. onItemMoved, and then viewHolder. getAdapterPosition and then target. getAdapterPosition. Now any class implementing the ItemTouchHelperAdapter interface will be notified when a list item is moved. But right now nothing is implementing the interface. Open CartRecyclerViewAdapter and let's implement it. Write implements ItemTouchHelperAdapter, click the red light bulb, and implement the two methods. There is onItemMoved and onItemSwiped. Great. Now our CartRecyclerViewAdapter will be notified when items are swiped or list items are moved in the list. Before we move onto the next clip, let's add the itemTouchHelper object to CartRecyclerViewAdapter. Scroll up to the top. Declare the ItemTouchHelper object named mTouchHelper. We need a way to set the helper. You can pass it through a constructor if you like, but I'm going to create a new method for setting it. Scroll down to just above the ViewHolder class. Write public void setTouchHelper. Take an ItemTouchHelper as input, and then write mTouchHelper = touchHelper. Open ViewCartActivity and let's set the ItemTouchHelper to the Adapter class. Scroll to the init RecyclerView method. It's very important you write this before setting the adapter to the RecyclerView. If you don't, you may run into problems. Start by instantiating the ItemTouchHelperCallback, pass the CartRecyclerViewAdapter object to the constructor, and that will associate our ItemTouchHelperAdapter with the callback, since now we've implemented the interface in CartRecyclerViewAdapter. Next instantiate the ItemTouchHelper object and pass the callback to the constructor. Now we have our custom ItemTouchHelper callback associated with the ItemTouchHelper object. And we have our ItemTouchHelper adapter associated with CartRecyclerViewAdapter. Set the ItemTouchHelper to CartRecyclerViewAdapter using the method we just created, and finally, attach the ItemTouchHelper to the RecyclerView. So ItemTouchHelper. attachToRecyclerView.

Rearranging List Items with ItemTouchHelper
Open CartRecyclerViewAdapter. In case you're unclear, let me explain what we're about to do and why. Right now as it stands, if an item was moved in the list, the actual list of products isn't updated with the change. This isn't good, because if a user was to arrange the items in the list, the positions of the items would become shuffled. We want to get the product at the fromPosition, remove it, and then add it to the toPosition. Then we want the entire list to shift downwards to accommodate the change. Write Product fromProduct = mProducts. get(fromPosition). Create a new product out of the old one, so Product product = new Product, and pass the old product. Now remove the old product from the list. So Products. remove(fromPosition). And add the new one into the toPosition. Now notify the adapter that an item was moved. So notifyItemMoved(fromPosition, toPosition). Pretty simple. The list of products will update accordingly when we move them around, but currently we don't have a way to actually move them around. Remember, we disabled the drag functionality in the cartItemTouchHelperCallback class, so we need to implement an interface in this class to facilitate movement. Scroll up to the top and implement the OnGestureListener interface. Click the red light bulb and implement the methods. Scroll back up to the top. We need to declare a few new global variables. The first, of course, is the GestureDetector. So private GestureDetector mGestureDetector, and we'll need a reference to the ViewHolder that the user is trying to move. So write private ViewHolder mSelectedViewHolder. Instantiate the GestureDetector in the class constructor. We need to set an onTouchListener to the list items, so we can detect gestures. Scroll down to the onBindViewHolder method. In the PRODUCT_TYPE case, reference the ViewHolder and set an onTouchListener to the parentView variable. ParentView is referring to the relative layout encapsulating the list item layout. This is going to give us a warning, because we're not calling the performClick method. Don't worry about this warning; it won't affect what we're trying to do. We're interested when the user first touches the list item. We can check for that with the ACTION_DOWN MotionEvent action. Then set the selected ViewHolder, and then send the touchEvent to the GestureDetector. We want the list item to become draggable when the user holds their finger on the screen for an extended period of time. OnLongPress is perfect for this. Scroll down to onLongPress. To start the drag operation, write mTouchHelper. startDrag, and then pass mSelectedHolder. I want to stop and mention here that what we're doing is going to work, but it's going to yield a poor user experience. We're going to do some fine-tuning towards the end of the clip. If you like a challenge, see if you can figure out what the issue will be and try to come up with a solution. Run the app and let's take a look at what's happening. Click on any product, add it to the cart. Now go to the cart. Touch an item and try to move it around. Great. That seems to be working. Go back and add some more items to the cart. I'm just going to add a bunch of hats. Three or four should be fine. Then once you get all these hats added to the cart, go back to it. Now try to scroll the list. You see what's happening? No matter how you try to scroll, the list items highlight and the drag operation is started. This will obviously yield a poor user experience. The list is basically not scrollable. So what can we do? Open ViewCartActivity. Declare a new Boolean object called mIsScrollable. So private boolean mIsScrollable. Scroll down to the onClick override method. Write one new method for setting the value of IsScrolling, call it setIsScrolling, and write another method for getting the value of IsScrolling. Call it IsScrolling. We're going to use this Boolean to keep track of whether the user is currently scrolling the list or not. If they are scrolling the list, then we won't start a drag operation. If they aren't, then we can set our drag operation. Scroll down to the CartListener class. In the onScrollStateChanged method, call setIsScrolling and pass true. In the onScroll method, call setIsScrolling and also set it to true. Now open CartRecyclerViewAdapter. Scroll through the OnTouchListener in onBindViewHolder. Right here, before the down action is sent to the GestureDetector, write ViewCartActivity Context and then setIsScrolling false. Whoops! Looks like I forgot to make this public. Go back to ViewCartActivity. Make both of these methods public. Now go back to CartRecyclerViewAdapter. Now scroll down to the OnLongPress method. Here we can check to see if the user is scrolling. Because remember, this OnLongPress method won't be triggered for at least 500 ms after the touch event is passed to the GestureDetector. So if the ScrollListener in ViewCartActivity hasn't set the scrolling Boolean to true yet, then we know we're good to start the drag operation. Run it and let's take a look. I'm going to add a bunch of hoodies first, so I'll add every single one of these to a cart. Now go back and add some more products. I'll choose hats, since I know there's a lot of them. We need to make sure there's enough items in the cart to make it scrollable. Now navigate to the cart and try scrolling. That looks good. The floating action button is showing at the bottom, and I'm able to freely scroll the list with no issues. If I hold my finger down on an item, it highlights, and I'm able to move it around.

Swiping List Items with ItemTouchHelper
At this point, we're able to move items around in the shopping cart, but there's no way to remove them. I'll show you what I mean. Choose a product, add it to the cart, now go to the cart. Try to swipe it out. If I go back, then to the cart again, that item is still there. To remove items from the cart, we need to write some new code in the OnItemsSwiped method. Open CartRecyclerViewAdapter. We just need to remove the item from the RecyclerView list and then also remove it from the actual shopping cart in shared preferences. Let's first remove it from shared preferences. Instantiate a CartManager object, call it removeItemFromCart, and pass the product in question. Now remove it from the products list in the adapter, and notify the adapter that an item has been removed. Run it and let's take a look. Add an item to the cart. I'll just add this one. Now go to the cart. Now swipe to the right. Looks like it was removed. Let's double check by navigating back, and then to the cart again. Great! The item was removed.

Module Review
In this module, we started dabbling in some of the more advanced concepts when it comes to using gestures. The first concept we looked at was inflating different views in a RecyclerView. And it turns out this is surprisingly easy with the RecyclerViewAdapter classes that are actually built in with that functionality in mind. We specified two different cases for a view type, product type or header type. The getItemViewType override method passes an integer variable to the onCreateViewHolder method. The integer variable is either HEADER_TYPE or PRODUCT_TYPE. It decides which integer to use by checking for the presence of the type field in the product object. The getItemViewType method passes the integer to the onCreateViewHolder method as an input. Then the onCreateViewHolder method can execute logic statements and decide which layout to inflate. Next we worked on a custom class that extends itemTouchHelper. callback. ItemTouchHelper. callback is a convenience class that helps developers build interactive lists. We use the itemTouchHelper to implement a few functions. Number one is to highlight items in the list when OnLongPress is called. Number two is to make the items rearrangeable under the three headings. And number three is making the items swipeable. When the user swipes to the right or the left, the items will be removed from the shopping cart. In the next module, we'll do a comprehensive review of everything covered in the course.

Tying It All Together
Review Swiping Through Images with a ViewPager
In the first part of the course, we worked on implementing a ViewPager for swiping through product images. But technically we didn't actually swipe through the images. We swiped through the fragments containing the images. Using a ViewPager like this isn't technically a gesture. But I believe it to be the most effective way to swipe through a bunch of images or any custom view for that matter. To improve the overall look and feel of the image swipe experience, we added a tab layout below the ViewPager. The tab layout will highlight the current position of the ViewPager by displaying a large gray circle. The smaller circles denote the positions of the remaining fragments in the list.

Review Detecting Common Gestures
We started the module by integrating the most basic form of gesture detection, the onTouchListener interface. We explored the different MotionEvent actions that can be detected using the interface. They were ACTION_DOWN, ACTION_MOVE, ACTION_UP, ACTION_CANCEL, and ACTION_OUTSIDE. In general, detecting any gesture, other than onTouch, is essentially a three-step process. Take the onDoubleTapListener interface, for example. Step one is capturing the TouchEvent using an OnTouchListener, step two is passing the captured TouchEvent to the GestureDetector, and then step three is implementing the OnDoubleTap listener interface and detecting the gesture that you're looking for. The same goes for any of the other gesture interfaces that we looked at. OnDoubleTap listeners, OnDrag listeners, and OnScaleGesture listeners.

Review Designing a Drag and Drop Operation
In this part of the course, we designed a drag and drop operation using a drag shadow of an image. The drag shadow was a miniature version of the product variation that users were currently viewing in the ViewPager. The shadow inflates when the OnLongPress override method is triggered from the OnGestureListener interface. The drag shadow can be dragged anywhere on the screen, as long as the user keeps their finger touching it. If the drag shadow is dropped on the plus icon in the toolbar, the product variation that's currently being viewed will be added to the shopping cart.

Review Dragging and Scaling an ImageView
The objective of this module was to build a draggable, scaleable, and pannable ImageView. having the ability to take a closer look at a product in a shopping app is a key piece of functionality. The custom ImageView class will zoom in or out, depending on if the user is making a pinching or an expanding gesture with two fingers. The ImageView is draggable in any direction, but it's only draggable if the actual image is occupying more than the allowed view. For example, if there's still some redundant space showing above and below the image, then it won't be draggable up or down. But if there's no redundant space showing, like the horizontal components of this image, then it will be draggable. To make the ImageView zoomable, we used a scale gesture listener interface. The interface returns the ScaleFactor value between 0. 8 and 0. 2, depending on if the user was making a pinching gesture or an expanding gesture with two fingers. If the ImageView is double-tapped, the view will reset to its original size and center on the screen. I consider this module to be the most difficult of the entire course. I encourage you to re-watch it if the concepts are unclear.

Review Leveraging RecyclerView Scroll Gestures
The goal of this module was to improve the interactability of RecyclerViews by implementing a custom OnScrollListener and a SwipeRefreshLayout. To improve the user experience, we added an OnScrollListener interface to the RecyclerView in ViewCartActivity. The OnScrollListener interface listens for changes to the RecyclerView scroll state. It can detect when a scroll begins, when it ends, and when the user is actively scrolling the list. We build a method that checks when the user has scrolled to the bottom of the list. When they have, a floating action button becomes visible in the bottom right-hand corner of the screen. If the button is clicked, the list automatically scrolls to the top. SwipeRefreshLayouts are an excellent way to give users the ability to refresh a RecyclerView. The refresh is triggered by dragging downwards on the list. When the refresh begins, a circular loading animation will be displayed here. I think this animation looks really good, and the implementation is so simple. I recommend always using a SwipeRefreshLayout in your lists.

Review Custom RecyclerView Interactions with ItemTouchHelper
In the final module, we worked on implementing some of the more advanced functionalities when it comes to gestures. The first concept we looked at was inflating different views in a RecyclerView. And it turns out this is surprisingly easy. RecyclerViewAdapter classes are actually built with that functionality in mind. We specified two different cases for the ViewType, product type and header type. All the logic for handling which view to inflate is handled inside the RecyclerViewAdapter class using the GetItemViewType override method. Next we worked on a custom class that extends ItemTouchHelper. callback. ItemTouchHelper. callback is a convenience class that helps developers build interactive lists. We used the ItemTouchHelper to implement a few functions. Number one is to highlight items in the list when OnLongPress is called, number two is make items rearrangeable under the three headings, and number three is making the items swipeable. When the user swipes to the right or the left, the items will be removed from the shopping cart.

Final Thoughts
If you're completely new to using gestures with Android, you've come a long way. Now that you have some foundational knowledge, integrating gestures or even creating custom ones should be no problem. Detecting gestures always works the same way, you implement the OnTouchListener interface, capture the touch event, and then deal with the touch event with a GestureDetector of your choice. Using gestures is a great way to increase the interactability of your applications. If we weren't able to detect gestures, you might as well be using an old mobile phone from the early 2000s. For those of you who don't remember, most of them look like this. There was no touch screen, and everything was done with a keypad. If we didn't have gestures, the use cases for a touch screen drop dramatically. Something with a keyword is probably more practical, like an old Blackberry. Thankfully that's not the case, and we're able to build beautiful, intuitive, interactive applications that have a touch screen. If you enjoyed the course and thought it provided a lot of value, please leave a rating on Pluralsight. I would really appreciate that from you. Afterwards, send me a Tweet to say hi, or leave a comment on my YouTube channel. As of right now, I read every single comment. Mention the course so I know where you're coming from, and I can personally thank you for watching. My name is Mitch Tabian, and thanks for watching!

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Beginner
Rating
4.9 stars with 14 raters(14)
My rating
null stars

Duration
2h 18m
Released
28 Mar 2018
Share course