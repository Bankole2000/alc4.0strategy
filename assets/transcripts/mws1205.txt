Semantic UI 2.0
by Nate Taylor

In this course, you will learn the ins-and-outs of Semantic UI, a natural language alternative to Bootstrap. You will walkthrough all the Semantic UI components including real-world examples of how to implement them on a website.

Building a response UI can be tricky at times. Often times, after it's complete, the markup is difficult to read. Semantic UI is a framework that aims at beautiful, responsive layouts using human-friendly HTML. In this course, Semantic UI 2.0, you'll learn how to style your HTML using natural language concepts such as word order, or noun/modifier relationships. First, you'll learn why you would want to use Semantic UI, how it approaches styling and responsiveness. Next, you'll learn about the 6 Semantic "Collections" (Breadcrumbs, Forms, Grids, Menus, Messages, and Tables) and you'll integrate them into your demo application. Finally, you'll learn about the Semantic API, which allows developers to use their controls to interact with data on the server and not just data that is already stored client side. After finishing this course, you'll have the knowledge to use Semantic UI 2.0 in order to help you develop more consistent, readable, styling for your HTML.

Course author
Author: Nate Taylor	
Nate Taylor
Nate's first program was written in QBasic on an 8086 clone his dad built. Since then he's written applications in C++, .NET, and Node.js. He spent the first 12 years of his career writing Windows...

Course info
Level
Intermediate
Rating
4.5 stars with 32 raters(32)
My rating
null stars

Duration
4h 10m
Released
16 Jun 2016
Share course

Why Semantic UI?
Why Semantic UI?
Hi. Thanks for watching Semantic UI 2. 0. I'm Nate Taylor. We'll get you into what makes Semantic UI impressive in a couple of minutes, but before we do, are you A developer who enjoys making applications, but often struggles with layout and design? Does your website look like it was designed before the advent of CSS? Would your dream job be to do all of the application logic and then turn it over to another developer to nail down the pixel perfect layout? Then Semantic UI is for you. Do your websites look like this? It has all the right information, it shows the description of the event, the ratings, the comments from people who have visited the event, but it's messy, it doesn't pass the eye test. People who land on this page are likely to bounce off the site and find their information elsewhere. What if instead we could make our application look like this? Again, it has the same information, but it's presented in a much nicer way. It looks like a real website, something that was done by a professional team. I can almost hear what you're saying, it sounds like, yeah Nate, that second site looks better, but I don't have time to tweak and adjust to make it look perfect, and even if I did I wouldn't know where to start. That's where Semantic UI is going to come in and help. From their website, Semantic UI defines itself as a development framework that helps create beautiful, responsive layouts using human-friendly HTML. My goal for this course is to get you comfortable with Semantic UI. At the end of this course, you should have a good understanding of the basic Semantic concepts and building blocks, good enough that you should be able to implement Semantic on your website, instantly improving the look, feel, and interaction of your application. To do that, you are I are going to be on a hypothetical team. Our team is building a rating and review application. We want to let users rate an event that they attended and provide feedback about it. We'll learn more about the application as we go through the course making feature enhancements.

Natural Language
As we saw in the last clip, Semantic is a framework that assists in providing components and styles to make laying out a site an easier task, but it's not the only framework to do that. We know that there are competitors such as Bootstrap and ZURB foundation, so what makes Semantic stand out from those? One of the first things you'll notice when you use Semantic is that it strives to use natural language to describe the markup. When we speak, we build up sentences with nouns, adjectives, and word order. Why does it have to be different with our CSS? For example, if you were to describe a dog you saw walking down the street, you'd likely say that you saw a large, brown dog. What you wouldn't say is dog, dog-large, dog-brown. Now some frameworks expect you to use the latter syntax for specifying CSS styles. If you wanted a large warning button, you'd likely see this CSS, ‘btn btn-large btn-warning', but not so with Semantic. In Semantic, to create a large warning button you'd simply specify this for your classes, ‘ui large red button'. It reads exactly like what you want. In addition to word order, Semantic UI uses the plurality of objects to express concepts. For example, if you wanted a group of buttons somewhere in your application, you could tell Semantic that by specifying the classes ‘ui buttons', with each button in that group having a class of ‘ui button', once again, using natural language constructs to express what is intended. Also note that out-of-the-box Semantic UI doesn't use abbreviations. This is a minor point, but it's one that I really enjoy. Many modern IDEs provide support for CSS IntelliSense, which means while we're typing we're only a few short keystrokes away from having our IDE autocomplete button. Much like the industry has moved away from database fields named CUSID, and instead replaced them with the full-blown Customer ID, we need to do the same for our CSS classes. Finally, let's look again at our large red button. I want to point out something else. Neither large, nor red, are specifically tied to the button, that is it's not button-large, nor is it red-button, instead these are three separate class names. What that means is throughout Semantic UI large has a meaning, as does red. If you wanted to highlight an input in red, you could just as easily have large red input, or a small blue input, and reading that you'll have a pretty good idea of how that input we'll look. Additionally, you'll know just from looking at some HTML that if you pair a large input with a tiny button, it's probably going to look a little off. It could be deliberate to put emphasis on the input, or it could be a mistake and the button shouldn't be that tiny. However, you don't have to wonder if a btn-lg is the same relative size as an input-lg. Instead, you'll know that large is independent of both buttons and inputs, and instead modifies them. All of this helps to make our HTML better express the intent. It reduces the impedance between the markup and your understanding of the markup. This is a philosophy that permeates all of Semantic UI. Once the intent of the HTML is expressed better, it becomes easier to read the HTML and anticipate what the layout should look like. Additionally, it should become easier to identify bugs because the HTML will be clearer.

JavaScript
We just discussed how Semantic attempts to make the language used in the layout more clear, direct, and readable, but it doesn't stop with the layout. The JavaScript the components use is also clear and readable. For example, let's assume that we have a dropdown on our page. Our HTML might look something like this. We have our ‘ui selection dropdown', and inside the menu class we have a list of items with John Snow, Roger Boisjoly, and F. Lee Bailey listed as items in our dropdown, and we want to know what the currently selected text is. We could issue a call to the dropdown like this. First, we'd get the dropdown using our normal CSS selector,. dropdown. Then we'd call the dropdown function on that item and pass in the string ‘get text', once again showing the prevalence of English throughout the framework, this time by simply specifying ‘get text' as a command to receiving the specified text back. And just like with the HTML, if the JavaScript is more clear with its intent it'll be easier to understand at a glance, and easier to spot potential errors when dealing with Semantic components. Notice here in this JavaScript we're using jQuery to get our element. You can see that with the $ at the first of the line. jQuery will allow us to pass in CSS-style selectors, like. dropdown, to find all the elements with a dropdown class. jQuery allows you to do much more than that, of course, but for the purpose of this course and Semantic UI, all we'll really be using jQuery for is to retrieve the elements that we want to apply Semantic logic to. However, the readability of the JavaScript is not the only benefit. Semantic UI gives you, the developer, complete control over the functionality of the components you use. Let's go back to our dropdown example above. The default behavior when you see a dropdown is that it expands its menu when you click on it, but what if you wanted to expand the behavior when you hovered over the item, like in a menu? Semantic exposes that through the same dropdown function, only this time when you set up your dropdown you pass in the event you want for the on action. In our case it's hover, and it would look like this. Again, we get our dropdown, and then we call the dropdown method, and we specify on, and we just give it the event hover. But with Semantic it's much more than just being able to determine when your control displays on the screen. From their home page, Semantic boasts that any arbitrary decision in a component is included as a setting the developers can modify. Imagine for a moment that you're building out a site that allows users to provide tags for their posts. You have some predefined tags, and you list those in the dropdown, but how do you let your users add new ones? One way would be to use the allowAddition setting on the dropdown when initializing. This tells Semantic that the list isn't static, it can be added to. It would look like this,. dropdown allowAdditions: true. These are just a few examples of the configurability of the Semantic components via their JavaScript API, and in this clip we actually only highlighted the functionality for the dropdown module, but there are many other modules within Semantic that give the same type of control, such as the Dimmer, Accordion, and Transition. We'll see some of these in detail as we progress through the course, but know that there are so many possible configuration options that it would not be feasible to show them all in this course. The point, however, is that with Semantic UI you get more than just a nice-looking control, you get the freedom to customize the behavior of the control as well.

Components
Now that we've looked at the natural language of both the HTML and JavaScript, as well as the configurability of so much of Semantic, let's look at one final reason that you should use Semantic UI on your next web application. That is its components library. Semantic has over 50 different UI components ready for you use in your application. It has all the basic UI elements that you would expect in a UI framework, such as forms, buttons, inputs, dropdowns, icons, etc., but it also provides you with several more complex elements as well. For example, have you ever needed something to show your users what step of a process they were on, like when they're buying something on your site? Semantic anticipated that and has a Step element that can be used to show the users that their order is currently in the processing phase and that shipping is coming up soon. In addition to several building blocks, Semantic also starts putting some of those blocks together and forming bigger chains. For example, as we saw on our before and after slides, Semantic provides, out-of-the-box, a Feed view. We used this view to show the comments that people were making about our _____ all-city festival, but that's just one use of a feed. It can be used for all sort of displays and purposes. Beyond the building blocks that Semantic has, it also has quite a few pre-build modules. These are components that combine the layout with functionality, for example, accordions, tabs, progress bars, and ratings. They're all Semantic modules, and this means that there is a lot of out-of-the-box functionality that is readily available to you to make your website as rich as you can imagine. Or, as the creators of Semantic UI state, the only dogma for this framework: everything arbitrary is mutable.

Where You're Going
Let's review why you should use Semantic UI. First, it utilizes natural language for its markup. You've got a lot on your plate. You're writing an application using a backend framework, JavaScript, HTML, CSS or less. You've got customer demands and features to implement, why should you have to learn a pseudo language to be able to apply styles to your HTML. With Semantic UI, you won't have to. The next reason to use Semantic is the amount of configurability you get. Going back to their dogma, everything arbitrary is mutable. They want you to have control over your components and controls. If you need a different behavior, you can access it via their JavaScript API. Next, the amount of components available. Yeah, they've got the basics like form elements, but there's so much more than that. Do you need ratings on your functionality? There's a component for that. How about the ability to _____ notes in the margins? Yep, there's a component for that one as well. Semantic is more than just a framework that makes writing markup easier, it's a framework that provides you with prebuilt components to make building your app easier. And while I love these reasons, especially natural language, they're not the best reason for using Semantic. The best reason is, quite simply, that it helps your application look good. It makes it easy for you to build an application that looks like what your customers expect. It helps you have a consistent look and feel throughout the application. After all, which of these would you rather have, this or this? That's what we've covered so far, but where are we going? In the next module we'll look at getting started with Semantic UI. This will cover some of the basic definitions inside of Semantic, for example, how is a view different from a collection, and we'll walk through how to get Semantic into your application. Once we're done with this module, we'll be up and running, ready to start implementing features. Next we'll move onto module 3 where we'll discuss all the elements of Semantic UI, like buttons and inputs and steps, and then after that we'll tackle collections here in Semantic. Here we'll see items such as forms, and grids, and breadcrumbs. We'll improve our application by implementing a few of the collections into our app. Next we'll look into views at module 5. Here we'll see items such as comments, feeds, and statistics. As we implement various views into the application, it will start to gain that rich look and feel, separating it from other apps. In module 6 we'll move on to Semantic UI modules. This is some of the real fun of Semantic as we look at modals and dropdowns and ratings, among other things. it's really the pinnacle of the UI styles, combining a little bit of everything we've learned to this point. Finally, in module 7 we'll examine how to wire up an API so that your controls can be dynamic and data-driven, for example, having a _____ dropdown that uses data from your backend. That's a little bit of a foretaste of where we're going and how we can give our applications that professional look.

Getting Started
Terms and Definitions
At the end of this module, we'll have Semantic UI up and running on a site. This will be the site that we'll work with for the remainder of the course as we apply various styles. In this module we're going to cover three main things. First, we're going to look at some common terms in Semantic UI. This will allow us to have a common vocabulary as we explore the ins and outs of Semantic. Next, we'll get Semantic UI installed. There are a couple of different options for using Semantic. If you've already got Semantic installed, I'd still recommend at least watching the first clip to get a common vocabulary that we'll use for the rest of the course. Finally, we'll take a quick look at some of the integrations that are available for Semantic, so that you can get Semantic support in the framework of your choice. To start with, let's look at elements. In the Semantic world, elements are the basic building block. Elements have a single function. They can exist either alone or in groups. The button, which we talked about in the last module, is an element. It can appear by itself as a UI button, or it can appear in a group of other buttons as part of UI Buttons. Other examples of elements are dividers, labels, images, and icons. We'll look at a deep-dive of elements in the next module. Next up the chain, so to speak, are collections. Collections can be thought of as usual suspects, that is they're groups of components that are often found together. Semantic identifies six collections, breadcrumb, form, grid, menu, message, and table. Collections can include other components, for example, a form could contain dropdowns and icons and labels and buttons. We'll cover collections in module 4. After collections come views. Views are a convention for presenting specific types of content that's usually consistent across a website. There are six views in Semantic, an advertisement, card, comment, feed, item, and statistic. These are different from collections in that, while Semantic collections were groupings of other components primarily in a functional sense, think of a form, views are focused more on the presentation. We'll examine views in module 5. The pinnacle of Semantic components are the Semantic UI modules. In Semantic UI, modules are components that include both a definition of how they appear and how they behave. From that description, we can see that modules are, in some ways, a combination of elements, collections, and views. Remember, elements have a single function, but modules provide more than one function, and unlike views, which focus only on the look, modules have a consistent look and behavior. Some examples of modules in Semantic UI are accordions, dropdowns, ratings, and sidebars. We'll look at the modules in module 6 of this course. Those are the type of components that we'll be dealing with in this course. I want to look at some of the terms, however, that apply across components. The first term that we want to look at is types. These are attributes of an element that alter the appearance of the element, but you can only have one type on each instance. For example, a button can be either a button or a basic button, both are pictured on the left, but it can only be one of those at a time. While you can only have one type per element, you can have many variations. These modify the quality of the element, things like size, color, menu directions, those are all types of variations. As we can see in the picture, we have a mini red button and a large green button, both exercising multiple variations on the button. Next is Content. Content are items that have meaning inside the context of a component. For example, a dropdown might have a header or it might have icons, those would be examples of content. Another term that we should be aware of is States. States are modifications to an element that help indicate a change in affordances. Affordances is a fancy way of saying that the appearance of an element indicates its functionality. For example, a dropdown could have an error state to indicate that the value needs to be selected, like the dropdown pictured here. Some of the common states in Semantic are loading, disabled, active, and error. Why did we take this time to go through the definitions? Are they really necessary? I think so. In my experience, looking at a UI framework in this light helped me understand better how to apply styles to my controls. Much like understanding nouns, adjectives, and verbs helps you understand a sentence, knowing that a massive, red, disabled button will be a normal button that has been changed so that it's big and red, and will also not be clickable, helps keep the CSS separated. Additionally, these terms come in even more handy as you start creating your own custom styles on top of Semantic. They serve as gentle reminders to break up your variations, such as size, color, etc., from the states and types. I know it's a lot to cover in one clip, and I don't expect you to have it all memorized right away. My goal here is to familiarize you with the concepts, so that when you see them in the wild later on they'll start to sink and click.

Feature Request: Change Styles
This has been the first time that we have received a feature request. UP until now, we've been talking about why Semantic UI, or terms and definitions, but now it's time to get down to work. Let me introduce you to our product owner for our application. Her name is Chocolate Chip, and she's going to appear throughout our course telling us changes she wants to see on the app. She'll communicate with us through Trello. The first story we see in Trello is, I want to be able to easily alter styles on our site. As we look at the description, we see that the product owner had this to say. Our site is very ugly. I don't want you guys to have to spend a lot of time working on custom designs. See if there's a library we can use to make styling it easier. Now one thing before we move on. Chocolate Chip will not tell us how to make any of the changes in our course. She's only going to tell us what she wants as the final output. So we've got our marching orders, and we need to figure out a way to get something that will make our site look better, so we're going to have to figure out how to install Semantic UI, and we'll start that in the next clip.

Installation: CDN
There are a few ways to get Semantic UI into your project. The simplest is to just use a CDN. That's how we'll pull it into our sample project. The CDN that we'll use is MaxCDN, and for the purpose of this course we want the entire library, so we'll use this link for our CSS and this script tag for our JavaScript. This will bring in the styles, as well as the behavior. In addition to the entire library, that CDN also provides the ability to bring in just select components. For example, if you wanted just the accordion, you could bring in components/accordion. min. css, and components/accordion. min. js. There are a couple of benefits for using a CDN and bringing in the library. To start, it increases the likelihood of caching. If someone visiting your site has already visited a site that uses the CDN version, it'll already be cached in your browser. Next, a CDN makes it easier to do version control. A CDN typically has multiple versions of the library, and it's possible to set it to always use the latest or to easily switch between versions when it's time to upgrade. That said, there are some downsides to using a CDN for something like Semantic, the main downside being that you lose the ability to customize the components easily. That's a decision I've made for this course. The focus of our course is to get you familiar with the Semantic UI concepts and start applying them, so were going to limit any customization in this course.

Installation: NPM
As we just talked about in our last clip, using a CDN makes customization of the styles and themes a lot more difficult, however, in your project you're most likely going to have a reason to customize the default styles, so if that's an option you need, Semantic provides a very nice way of integrating. In order to bring down the files and build a custom implementation of Semantic, you'll need NPM and Gulp installed on your computer. If you don't have Node installed yet on your computer, pause the video, go out to node. js. org, and install the latest version. Now that that's complete, open up a terminal and type npm install -g gulp. NPM is node's package manager, the -g means install globally so that it won't have to install it for every project on your computer, and gulp is the name of the package that we're installing. It's a build tool for JavaScript. It will allow you to convert the LESS files to CSS, minify JavaScript, and a few other tasks. Once that's done, create a new folder for your project. For me, the folder name for this module is Users/taylonr/Google Drive/Pluralsight/SemanticUI/Module 2 -- Getting Started/sample. Once you're in that folder, start by typing npm install semantic-ui. This is going to run for a couple of seconds, and then it will prompt you with a menu, and we're going to choose the automatic option. The other two options provide you the ability to not only select what folder you want it installed in, but what components you want installed as well. I'd encourage you on your own time to play around with those and see which one works best for you. After we've selected automatic, it's going to ask us to confirm the project folder, or specify the folder you want to install it in, and we're going to select the default that's shown there. Next, it asks what folder inside of your project you want to place Semantic in. If the folder doesn't exist, it will create it, and the default is semantic, and once again we're going to go with that. Once the last question is answered, it'll install and configure Semantic for you. Now that the install is done, let's take a look at the file structure that installing Semantic created for us. The first folder you'll see inside is node_modules. These are the modules needed to build Semantic. We're not going to spend any time looking at these files, because you won't modify them during any customizations. The next folder you see is semantic. As we drill down, we can get into the source/site/elements. In here we'll see several pairs of files, for example, there's the button. overrides, as well as the button. variables files. These files are ready for you to start making changes to the button element. For an example of how these files can be used, check out the button. overrides and button. variables in the source, themes, amazon, elements folder. Note that all the files that Semantic is using are LESS files. If you're unfamiliar with LESS, you should check out, A Better CSS: LESS and SASS, by Shawn Wildermuth, in the Pluralsight library. Underneath Semantic, you'll also see the file gulpfile. js, and this provides the tasks to build various components for Semantic. For example, if you were to call gulp watch in your project, it would watch for any changes to the styles, and then rebuild the CSS file anytime you added a new style. To see where the built files will be placed, check out semantic. json. The default is that the files will be placed in the dist folder. As we said earlier, for this course we're going to sue the CDN version, so we won't be modifying or building custom styles, however, as you become more comfortable with Semantic and start customizing your styles, you'll want to use this functionality.

Integrations
One final thing to cover before we really get in and start learning about elements in our next module is integrations. There are a lot of frameworks and libraries available on the front-end today. The Semantic community provides some integrations so that you can use Semantic in a native way with other frameworks. The frameworks that the Semantic community has provided are React, Meteor, Ember, and Angular. For example, with Ember, if you wanted to use an accordion, your markup would look like this. This would create an accordion with Semantic UI as the title, and Accordion Component as the data. Or, if you were in Angular and you wanted to create a Disabled button, you could use this directive. Keep in mind that these integrations are optional. It is possible to use Semantic UI in Ember, or Angular, and other libraries, without using these specific packages. In fact, in at least one large production Angular application I've done just that. Also keep in mind that these libraries are a work in progress, so while they might get you started, they won't have everything you need. However, they are open source, so if you're so inclined you could issue a pull request into their projects to increase their functionality. Since we're not using any frameworks in this course we won't continue this discussion anymore, but I wanted you to be aware of them, if for no other reason than being able to see how various frameworks put Semantic UI to use.

Summary
We just covered some of the basic terminology for Semantic UI. We looked at various examples of elements, collections, views, and modules, and we also discussed some of the Semantic concepts, such as types, variations, and content. While it is possible to use Semantic without understanding these terms, it does greatly help us in understanding how and why Semantic works the way it does. We also got the first of many feature requests for this course, and we used that feature request as motivation to install Semantic so that in the upcoming modules we're ready to go. Then we discussed how you can bring in Semantic in a way that allows you to customize the themes and styles specific for your application, and we followed that up by briefly discussing that there were integrations with other frameworks. Now that we've done the hard work of understanding why Semantic UI and understanding the terms and definitions and getting it installed, we're ready for the fun part, and that's what's coming up in the next module when we start looking at Semantic UI elements.

Semantic UI Elements
Introduction
In this module we're going to look at the most basic building blocks of Semantic UI, Elements. However, we're not going to do that by just discussing each element. Instead, we're going to start overhauling a website. The first part of the website that we're going to overhaul will look like this. You probably recognize it as our before image from the first module. Keep in mind we're not going to apply all elements to this page, as that's pretty unrealistic. Most pages on your applications will not contain all the Semantic elements because the page will quickly look too busy and covered in too many distracting elements. But just because we won't be using all the elements on this page, doesn't mean we won't look at each element, It simply means that we won't be implementing some on our sample page. Here's a list of all the elements in Semantic 2. 0 that we'll be covering in this module: Containers, Segments, Buttons, Icons, Flags, Images, Inputs, Labels, Lists, Dividers, Headers, Loaders, Rails, Reveal, and Steps. There will be a clip for each element, and this will allow you to come back to the video at any point in time to look at a specific element without trying to hunt through the whole video for the part you need. Throughout this course, I'll be using codepen. io for the types, states, and variations of the Semantic UI components. It'll allow us to see the HTML and the output side by side. So, let's get started.

Containers
The first element we'll cover is containers. The reason this is number 1 is because adding a container will likely be one of the first things you do on your site. It helps set the tone, so to speak, for how your site will look. In Semantic UI, containers are elements that work to limit the max width of the rest of your page. It does this based on the width of the user's screen, and Semantic comes with four default breakpoints for controllers. Here is a table from Semantic's website that shows the breakpoints that exist by default. Let's look at some example containers. The first one we see is the standard ‘ui container'. We see that there is some whitespace on both the left and right side, and as we expand or collapse the width of the visible space, we see our container adjusting the white space. Next we see the only other type of container, and that is a ‘text container'. Notice a couple of things with this type. First, the left and right margins are wider than a standard container. Also, the font size is a little bit larger. This is because the text container is meant to provide an easy way for displaying a single column of text on a page. As we move down, we can see a couple of the variations of containers. First we see a Right Aligned container. As the name implies, it has the text aligned on the right margin instead of the left. We also have a Justified container, which will display the text in a left and right justified, or fully justified manner. There's also Center Aligned, as well as Left Aligned containers, and since the alignment is a variation, you can apply them to both ‘ui containers', as well as ‘text containers'. So let's see this thing in a real setting. Here's our page with no styles yet applied. As you can see, there is no real consistent look yet. The text takes up the entire screen, and the whitespace is totally inconsistent. To clean this up, we'll apply the _____ classes ‘ui container' at the top element. In our case, that's the body tag. Then we'll refresh our page. Notice now we have whitespace on both the left and right-hand side of the pages, and with that one class our page is already just a little bit more visually appealing. Obviously we still have a lot of work to do, but we're off to a nice start.

Segments
The next element we'll look at are segments. This element will help you group the content that's related. There's five types of segments: Segment, Raised, Stacked, Piled, and Vertical. Here we see some samples of a few of the segment types. At the top is the vanilla ‘ui segment'. Next we see a raised segment. The difference between the vanilla segment and the raised segment is subtle. There is a shadow around the segment to give it a floating sensation. Next we have a piled segment. The goal of this one is to appear as if your segment is on top of a pile of papers. As we talked earlier in the course, you can group components together, and segments are the first instance that we'll see. If we wanted several segments grouped together, we use the class segments, plural, with each segment in the group below having a segment class. Here we see a group of horizontal segments. Other segments groups can be just segments, stacked segments, raised segments, piled segments, or nested. Segments have two states, which we see here. The first state is disabled, and as you can tell, the text is still visible, but it's grayed out. The other state segments have we see here, and that's loading. It displays an animated circle over the content. This can be useful if you have multiple segments on your screen that load data asynchronously, as you can toggle the loading state until the data is present. Segments also have many different variations, and they can be combined with the types, groups, and states that we've already mentioned. The first variation that we'll look at is inverted. It inverts the colors on the segment, so instead of a black text on a white background, you get white text on a black background. But it doesn't have to just be black, you can invert with any color you specify. For example, here we see a red inverted segment. As with any variation, we can combine multiple variations to change how the segments look. For example, on our red segment we have also specified that the text be center aligned, and we wanted more space around the text, so we specified that it be very padded. One way to provide emphasis to different segments is to slightly alter the color. Here we see a group of stacked segments that are all green, however, the segment at the top is lighter than the segment at the bottom. This is because we're using the tertiary and secondary classes to alter this color. Next we see that we don't have to invert our segments to provide a splash of color, as we can see here. Neither of these segments are inverted. They have the normal white background with the black text, yet both apply the green class to provide just a touch of color to the segment. Also note that they're floated, one to the right and one to the left. And finally, we can see that our segments don't even have to be rectangular. We see that here specifying the segments can be circular. In this case we have a red inverted circular, a green inverted circular, and a blue inverted circular segment, again highlighting that multiple variations can be applied, creating almost endless style possibilities. In addition to the variations we showed here, there are also some other variations that you can apply to segments, for example, attached. This ties a segment to other elements on the page, for example, you can attach a segment to a header, or even other segments. We'll see this variation used in the buttons clip. Compact, which will make the segment smaller, and more compact, as you would probably guess. Clearing, this will clear floated content. For example, if a segment was in a section of the page that is floated to one side, and then you applied clearing to the next segment, it would not follow the page floating. Text alignment, as we saw with containers, and basic. A basic segment will have no special formatting, such as borders or other styles. Notice that one variation in this lest is Text Alignment. We saw that with containers, and we see it again here with segments. That highlights one of the key principles of Semantic UI, and that is that variations apply across multiple elements and components, and they're typically not limited to a single component, and we'll see that more and more as we go into more elements in this module.

Feature Request: Buttons
We have our first feature request for elements. Let's take a look. Here we see Chocolate Chip telling us that she doesn't like the links we have on our screen. She wants us to find a way to make them look better than just plain HTML links. What links is she talking about? Well, let's load the page and look. First, at the top of the page there is a link to Add Event, so that our users can add a rating for an event that isn't yet in the system. Next, right underneath our description we're asking users to share the events on social media. The final place on the page is at the bottom, asking our users to like our Facebook page and follow us on Twitter. As with all feature requests, it's up to us to figure out what we should do. For this feature, we're going to look at the Semantic element button to handle the request, and we'll see that in the next clip.

Buttons
Semantic provides several different button types. The vanilla version is simply ‘ui button', and you can see it looks pretty basic, about what you would expect a plain button to look like in Semantic UI. The next type are emphasis buttons. Here we see a Primary, Secondary, and Tertiary button. The colors for these classes can be specified in the site. variables file. So if you have a site in which your primary color is green, you could set it in that file so that when you use primary it would come out green. These classes are very helpful if you've got a page with a lot of forms, as you can make the save action be a primary button, and it will look consistent across the application. Let's look at our page. Remember from the last clip we wanted to convert our Add Event link to something more presentable, so let's make it an emphasis button. We could make it a primary button, but as we've discussed before, we want to make our classes have meaning here, and the primary action on this page is not to add an event. Instead, on this page we want the user to fill out the review for this event, so we shouldn't use primary here. Instead we'll make this a secondary button, and to do that we'll convert our link to a button and give it the _____ classes ‘ui secondary button'. It looks a little out of place at this point, being a single button in a list of links, but as we progress through the course we'll get that all cleaned up. Another type is the animated button. As we see here, we can specify one button, in this case Follow Me, and then have it do an animated transition to a second state, in this case my Twitter handle. Let's take a quick look at how this is accomplished. Here we have a ui button, and underneath that we have a a div with the class ‘visible content'. This div contains what the user sees initially. There is a second div, this time with the class ‘Hidden content', and when the user hovers the mouse, this is the content that is displayed. Apart from the segment groups that we saw a couple of clips back, this is the first time in which we've really looked at nested elements that Semantic will use to create its rich visuals. The next type is another example of that. Here we're looking at a labeled button. This will be a button combined with a label. On our screen, we've got a button that allows the user to vote, as well as a label that shows how many people have voted. Similar to the animated button, we have a ‘ui button' with two nested elements. The first one is a div with the class ‘ui button' applied to it. The second is the label, in our case it's the number of votes that this item has received. You can see that there are multiple variations on the label that we can apply. Here we've applied the left pointing variation. For more detail on the label variations, check out the label clip later in this module. After labeled, we have an icon button. As the name implies, this is a button that is just an icon. Here we've chosen a Save icon. This would be useful for something like a toolbar or a group of icons. Notice that the icon is created using an i tag with the class ‘save icon' applied. Combining the last two types into a new type, we have labeled icon buttons, and this will allow us to show both an icon and text. The label text is specified on the button, and the icon is applied in the same manner as the previous button. There are two more button types left to be discussed. The first is simply a basic button. It looks a lot like a vanilla segment that we talked about in the last clip. There is a black border and text on a white background. The final type is an inverted button. This is accomplished using an inverted segment, that we've already discussed, and applying an inverted button class on the button. As with segments, this means a white border and white text on a black background. Earlier in the course we talked about how Semantic components can have content. Buttons are the first component that we'll look at that have content. Here we see a set of either/or buttons, but we don't have to limit it to just two buttons. Here we see three buttons in our content block. Next let's look at some variations on buttons. We're not going to look at all the variations, but rather some of the more interesting ones. The first variation we'll look at will likely help us with our feature request that we just got from Chocolate Chip, that is, Semantic provides some social network variations. Notice something here, by specifying Facebook or Twitter it created the button with a specific background color, but that's it. We still need to supply the Facebook icon or the Twitter icon, and this modular way allows us to use different icons, or even variations of icons that we'll see in a later clip. These button types might be a good candidate for the bottom of our page, so let's add them there now. We'll convert these divs into ‘a' tags, and note that while we do that we're defining the look and feel so we can apply the button class to a link, it doesn't have to be just an HTML button. Then we'll add in our icon for each button. Now let's refresh our site and scroll to the bottom. That's already looking better. But what can we do about the Share buttons in the middle of the screen? Perhaps we can combine some variations on our button content. Let's start by finding the section of our page with those links. We'll create a buttons group, and underneath that we'll create three separate icon buttons, one for facebook, one for twitter, and one for google plus. Let's make sure to put an icon inside each button. We refresh the site, and we can see that all the areas that Chocolate Chip called out are now cleaned up, So let's go back to the variations and see what else we have. In addition to the variations we demonstrated on the page, there are a couple more interesting ones as well. You can attach your buttons to other elements on your page. Here we have a top attached and bottom attached button. We specify where the buttons are attached as classes, and we specify what they're attached to as a separate class. Here we have a ‘ui attached segment'. As we mentioned in the end of the segment clip, variations often apply across multiple components. That's true with buttons, which can take advantage of size and color variations. Where this starts to get interesting is that you can apply these variations on groups of buttons as well. For example, if you want a massive group of red buttons, you can place the classes massive and red on the group, and it will format the children button elements. You can also apply a vertical style to the group to convert from horizontal to vertical buttons. We've cleaned up our links, and arguably made the site look better, so we can move the Trello card to the Done pile for Chip's feature request. We've also already started our introduction to icons, but we'll dig into them deeper in the next clip.

Icons
As we saw in our last clip, we were able to incorporate icons into our buttons. The icons we used were specifically for social media platforms, but those are far from the only icons available to us in Semantic. There are icons for brands, payment options, ratings, messages, user types, and more. In fact, Semantic has a full _____ port of the Font Awesome library version 4. 3. Here are a few of the pages from the icon library. In Semantic, each icon is an element, the same as a segment, container or button. What does that mean for us? It means that like the other elements, icons can have states, variations, and groups. Notice, however, that there are not multiple types of icons, there's just the one, Icon. As we saw with buttons and segments, we can have a disabled icon, which we see here next to an enabled icon. We also have a Loading state. Here we see a couple of normal loading circles, but we also see a dollar icon loading. Now the likelihood of needing a spinning dollar icon is probably pretty low, however, the point here is that any of the icons can be converted to a loading or spinning icon, and that's a good principle to remember. In Semantic, a state can be applied to the element as a whole. If you wanted to create a new icon state, perhaps active, you should do so in a way so that all the icons can use that state. There are also a handle of variations that we can apply to icons as well. The first one that we'll look at is the ability to alter sizes. Here we see a ticket icon that ranges from mini all the way up to massive in size. As with other elements, icons can be varied by color. For example, here we see an orange fire icon, a red fire extinguisher icon, and a green leaf icon. Two more interesting variations are Circular and Bordered. These wrap the icon in a circle or a rectangle, respectively. Combining these with other variations, we can see an inverted large circular flag icon that is green and an inverted large bordered rocket icon that is purple. As with other elements, we can put icons in groups, and if you're like me, at this point you're thinking of something like a button bar, like we see here. But that's actually really more of a variation on buttons than it is on icons. In fact, as you can see in the markup, the way we got to that point was with a group of icon buttons. Instead, when it comes to icons, you can group multiple icons together to form a new icon. To start, we can create a group of icons the same way we create other groups, and that's by making the class name plural, so in this case icons. Then we place the icons that we want to group together, for example, here we've combined crosshairs and bug. This might indicate to the user that by clicking this they can report a bug in the system. Or we have the ubiquitous ban icon with the telephone, indicating that calling isn't supported. We can even place our other icon in a corner by using the corner class. Here we can see two icons, one indicating that the user can refresh their notifications by using the mail class and the inverted corner refresh class, or we can indicate that options are locked with the options class and the red corner lock class. There are two other variations that we didn't cover in this clip, and that is Flipped and Rotated. These allow you to flip your icons either vertically or horizontally, and rotate them, either clockwise or counterclockwise, again, giving you more control over the customization of your icons. As we've seen with other elements, once we start combining multiple variations on our icons, they start to look more and more custom, and less and less boilerplate, that is it doesn't take a lot of work on our part to make a site that uses Semantic UI, but doesn't have that default Semantic UI look, because customization is so easy.

Flags
The Semantic library has a flag library included with it so that you can place flags anywhere that you need to in your application. To do this, you apply the country's two-character code with the class flag on it, like we see here. Because of how flags are implemented in Semantic, they are the only element that doesn't have type, state, or variation. The Semantic team looked at various SVG libraries, and saw that they often render poorly, or blurry, at low resolution, so instead, they went with sprites for each of the icons. While this does produce a better quality image, it unfortunately means that we are unable to alter their size or other properties. We will not be using flags in our application.

Feature Request: Images
It looks like Chocolate Chip has been reviewing our changes. She's got another feature request for us. Let's see what she wrote for us. Here we see the card, and she writes, the picture on our events page is big and blocky. Can we make it look nicer? It's been a few minutes since we really looked at the site, so let's load the site as it is right now, and see what she's talking about. That's a fairly big image, not huge, but depending on the screen resolution it definitely takes up some space, and there's a tone of whitespace on the right-hand side as well. From the looks of it, the image isn't the main thing on this page either, instead we want people to focus on the description and ratings, but that's hard because they're not the first thing your eyes see. I think we can make this look a lot nicer. To do so we'll have to dig into the images in Semantic, so let's look at those now.

Images
As with buttons and icons, images don't need a lot of explanation of what they are. They're the images that you display on your site. In Semantic there are two types. The first is probably the most common, and that's just ‘ui image'. We can see that here. If you notice, the source on this image is pointing to placeimg. com, which is a site that will generate images at the size you specify. So this image is a 640 x 480 image. At that size, it looks a little bit like the image on our application. The second type of image is the image link. This allows you to specify an image as an HTML link. If we click on the nature picture here, it takes us to a new tab for the Google query, nature. Images also have two states. The first one is a new one for us, and that's the state Hidden. I specified that this image is hidden, and we can see that it's not here at all. In fact, instead of seeing the image we see our next element in the document, which is simply a p tag with the text of Next element. The second state that images can have is disabled. Notice that this image has a gray film over it. Much like the disabled segment is grayed out, the image also has a gray overlay on it. This is especially noticeable when it's among other images that are enabled. In Semantic, images have a handful of variations as well. We'll start with size so that we can use that throughout our other examples. Notice here that it's Semantic doing the sizing. Each image's source specifies the same size, 640 x 480, but the size variance on each image is what's resizing it. Another variation is the Avatar variation. This has the potential to get a lot of use on your site, as it takes any sized image, converts it to a small circular image, and allows you to place text beside it using a span element. Here we've taken a 640 x 480 image of nature and turned it into our avatar. After Avatar, we come to Bordered. This is the only image on our page that does not use a source image. Instead, this is an icon from the Pluralsight library. The reason for this is that in order to best see Bordered, the image needs to have a white background, and that's not something I can control with place img, but I can with this icon, and we can see the border providing a nice delineation between the image and the whitespace. Next we come to the Fluid variation. Fluid images will consume the space of their container. As we can see in this case, this picture takes up all the space we give it. If we resize the site, the picture is resized, but it still takes up all the allowed space. The next two variations are related. They are Rounded and Circular. They change how the image is framed, so to speak. The first will provide slightly rounded corners to the image, and the second class will display the image in a circle. When we looked at the Avatar variant, we saw that any text we placed in a span element aligned to the middle of the avatar image. We can control that with our next variation as well, and that is the Vertical Alignment variation. We can specify top, bottom or middle, which we have here. This allows you to align text specifically with the image, while still applying other variants as well. The next three variants are also related. This time in where the image appears on the screen. The first variation is Centered, and this will center the image horizontally on the screen. Next is the Spaced variation. This allows you to place an image in a block of text. Here we see the plain Spaced variation, but there are also variations for left and right-spaced as well. If we had not applied this style, the text here would stop after the word engagement. Then there would be a line break, then the image, and then another line break, and we'd resume with the word digital at the start of that line. The final variant is Floated. Here we see a right-floated image, but the left-floated option is also available, and this is pretty similar to what we saw with left and right-floated segments. That's all the variants that we can have on an image. In addition to the variants, there's one type of group for images, and that is sizing. We see the same thing with this group that we saw with buttons, and that is if we apply the class small to the images group, all the images underneath are the same size. Now that we've taken a quick walk-through of the possible options for our image, let's apply some of those for our site. Let's start by applying the style, ‘ui medium circular image' to our image. This will control the size of our image, as well as the shape. Once we refresh our site, we see that it looks better, but still not great. Also note that the image we're using as our source is not one that converts to a pure circle, so we have a flat top and bottom. What else can we do to make our image look better? Let's apply the left-floated and middle-aligned styles as well. Before we refresh though, we need to wrap our description in a span element. Once we refresh it looks better, but that ratings text is popping up and bothering me, I don't like it there. Let's hop back to the source code and wrap our social media buttons with the classes ‘ui clearing basic segment', and while we're in there let's delete the text Share On as well. We refresh one last time, and that really starts to clear things up. Our image is no longer dominating the screen. Instead it's a nice visual of what the festival looks like. By removing all that space, we're able to bring the Ratings and Comments up higher, which lets our user start to see more information. I think this takes care of the image being big and blocky, as Chocolate Chip put it, so we can now move this card into the done pile.

Feature Request: Inputs
We've got another feature request from Chocolate Chip. It seems that now that we've cleaned up the top of our page, Chip is directing her attention to more of the page. The next item on her list of things for us to do is address how the inputs look. She also calls out our Ratings text box. She says it needs more details. In my experience this is a pretty common phenomenon, that is, as you start dedicating attention to how a page looks, more and more things stick out as needing attention. In order to address this card, we're going to need to look at inputs, which is what we'll do now.

Inputs
As with images, there is just one type of input, and that is ui input, which we see here. Let's take a minute to look at this input, because it might not be what you'd expect. On other elements, like buttons, we placed the Semantic classes directly on the element that we wanted to style, but here we aren't applying the classes to the input element, instead we're applying it to a div that wraps around our input. We'll get into more detail a little later in this clip when we look at input variations, but it has to do with combining multiple items into a single input presentation. Inputs have four states, two of which are familiar to us, and two of them are new. The first one we'll look at is the Focus state. By default, it will place a blue border around the input box that has Focus, which we can see here. This can be useful if you want to force an input to have focus, but you don't have to worry about setting this every time someone starts typing in one of your inputs. That's because when a user starts typing, that input gets the focus from the browser and highlights the input for you. The next state we'll look at is Loading. We saw this state on Icons, but this one is a little bit different. Here, by applying a loading class, it automatically applies a circle. This could be useful for something like a search field or type-ahead field. Notice here that the input has an i element with a class icon on it. Without this element, applying the loading class will not alter how your input looks. The next state is another familiar one, that is Disabled. Since we've seen this one on several other items, we'll not spend any time discussing it here. The final state is a new one for us, and that is the Error state. We can see it used here. This would be a great state to apply on a form if the data was invalid, for example, an incomplete phone number or invalid email address. Now we're ready to look at the variations on inputs. To me, these are pretty interesting, as they start to combine multiple elements to make it look like more than just an input. To start, let's look at the Icon variation. This allows you to place an icon inside the input box. As you can see with the two examples here, you have the ability to place the icon on either the right or left-hand side, and as we talked about in our clip on icons, there are numerous variations for icons that can be applied here, for example, placing a border, applying a color, or inverting the icon. The next variation is a labeled input. Here we see a couple of examples. The first one uses a corner label combined with an asterisk icon to indicate that a field is required. We also see a textbox for entering monetary amounts. That one is actually composed of three elements. First a label on the left with a $, then the text box, and then finally a label on the right with the. 00. We saw labels a bit on the Buttons clip, and we'll dig into them deeper in an upcoming clip. One thing to keep in mind, is just as there are many variations on icons that can be used with icon inputs, there are also many label variations that can be used with label inputs as well. One more variation that allows us to combine multiple elements with inputs is the Action variation. Here we see an input with a button applied. The first instance is just a primary button, which we could use to sign people up for our newsletter. The second instance is actually a labeled icon button, which was one of the button types. Here we see the username, the action, delete, and a trash can icon, all to indicate that clicking this button will delete the user. When we first started talking about inputs, I highlighted that we're not applying styles to the input, but instead to a div surrounding the input. These last few examples have highlighted why. The div contains an input, a button, and an icon inside. With the style of ui input, it knows to group these elements into one single entity. As we talked in the Icons clip about the ability to customize, I hope that you're starting to realize the power that's out your fingertips by using Semantic UI. The last variation we'll look at is Transparency. We see an example here. In this example, we've made an icon input transparent, which makes it blend into the background. There are three other variations that apply to inputs, but that we've already discussed on other elements, so we won't be discussing them here. They are Fluid, Inverted, and Size. Now that we've explored several different input styles, let's go look at our page and see how we can clean up the inputs that we already have. Let's start with the name input. We'll place a div around the input and apply the class ‘ui input', then remove our label and replace it with a placeholder text of name. Next, we'll wrap the input for Rating in a div, and we'll apply the class ‘ui right labeled input'. Then we'll add a label element underneath our input with the class ‘ui label', and we'll fill it with the text, ‘Stars', to let our users know how they're rating the event. We'll also delete the text Rating, because the labeled input should provide enough info about what that field is doing. When we refresh, our site looks better, but the Comments section seems to be a bit out of place, so let's go back to our source code. Let's start by removing the label and placing a placeholder in the text area. Refreshing the site reflects our changes. The text area still looks different from the inputs, and they're all bunched together, but that's something we'll address in the next module when we look at forms. For the time being, we can at least be satisfied with the work we've done on the inputs, so now we can move that card over to the Done pile with the others.

Labels
After seeing them attached to buttons and inputs, it's now time to take a look at what all labels can provide us in Semantic UI. To start, we'll look at their types. Labels have the most types that we've seen so far. Let's start with the easiest. As with other elements, that's simply ‘ui label'. Here we've got a label with the text of Name. It doesn't look super impressive, but as we go through this clip we'll see some ways that we can dress up. The second type is an Image label. Here we've got a picture that matches our text. Notice that the image doesn't contain ui image as we saw in our images clip, instead that's applied to the label. That makes Semantic fill the left-hand side of the label with our specified image. The third type is actually a type we saw in our Buttons clip, and that is Pointing. There are four different directions you can point, as we see here. The default, with no modifier, then there's left pointing, right pointing, and bottom pointing. These would make great error messages on a form, so that it's clear which field the error message applies to. We also saw the fourth type when we were looking at inputs in our last clip, and that is corner label. There we used an asterisk to indicate that the field was required. Here we're using a heart icon to indicate that the user could favorite the image. While it's not displayed, the corner label can be on the left or right corner, and it doesn't need to be an icon. The next type is a Tag label, and this makes the label look like a Tag. Here we've got an example of tags you might see on a blog, or even a site like ours where you're able to specify tags that apply to your information. Another type of label is shown in these pictures, and that is a Ribbon label. As we see on the screen, you can have both a left or right ribbon. Similar to the ribbon is the Attached label, which we see here on two images. We first saw the attached concept earlier in the course when we looked at attaching buttons to segments. Here we can attach the label to the top or the bottom, and we can specify if we want it to be only on the left or right. As we see on our second image, we specify that it be top right attached. Next we have a Horizontal label. Here I've used them to label a list of links. This puts the label on the same line as the other elements on your page. The final type we have is a Floating label. To show this functionality, I brought in the concept of menu. This is not an element, but is instead a collection, and one that we'll examine in the next module, but looking past that we see that we have a link for our users, and we float over that item with a label, indicating that there are 15 users. A big part of the label is the content inside of the labels. The first content we can have is simply Detail. I have applied the massive size to this icon to help demonstrate what the Detail content does. At first glance it appears as if it is just a wider label, but if you notice, the 15 has a different colored font. On this label, 15 is our detail. It's telling us that there are 15 users, and depending on the context that could even mean 15 users online. The point here is that your label will contain the big heading, and the detail section will provide more info. Another content that we can apply to our labels is an Icon. Here we see an example where the image is labeled as Animals, with a gear indicating that we can alter the settings on this label. Note here that we're able to apply classes to the i tag in our label, which means we can customize and style our icon like we saw in the Icons clip. Similar to Icon, we have Image content as well. At first blush, you might wonder what's the difference between an image label and image content, I know I did, and if we look at this example I think we can see some of the differences. To start, remember that on the image label the class was applied to the div, not the label, whereas here our styling is applied to our nested image. That allows us to move the image to the right, make it circular, and control how the text is aligned, all styles we learned about in our Image clip. The final piece of content we can have is a Link. Here we have a label of nature, and we have the detail of that element with the text of See Results. We can see that we've made the detail section a link. If we were to click on that, it would take us to the Google search results for nature. There are four variations that you can apply to labels, and these variations are Circular, Basic, Color, and Size. We've discussed each of these variations on other clips, and so we will not devote any more time to them here, other than to say that this is one of the benefits of Semantic. Once you understand what massive means in Semantic, you don't have to learn what it means specifically for labels. There are also four groups that you can apply to labels. Those four groups are Size, Color, Tag, and Circular. The first two we looked at on Buttons, so we won't look at them again here. The last two, though, we've not seen before, so let's take a closer look. Applying the Tag group formats all labels underneath that group as tags. Earlier we had several individual tag label elements. This time we repeat the same labels, but specifying tag, not on each label, but instead on the labels element. The Circular group is very similar to the Tag group. In fact, when creating this group of circular labels, I copied the tag group and changed the classes from ‘ui tag labels' to ‘ui circular labels', and instantly all of the labels underneath updated their styles. As we saw on the Input and Button clips, we can combine labels with other elements to provide a richer experience. Now that we've looked at the different styles that we can apply to labels, you can begin to imagine all the combinations that you can create for your application.

Lists
The next element that we'll look at are Lists. As with all other elements, there is a plain ui List like we see here. At its core, it's a simple list of items. Additionally, there are two more types that are common to web developers. That is a bulleted list, which we see here. We have a similar markup as before, a div with the class bulleted, and each list item as a div with the class ‘item'. You could also accomplish this same list with a ul tag and a class of ‘ui list'. Also note that we created a nested list by simply placing a new div with the class ‘list' underneath an item. This allows us to nest lists as deep as we need to. The second type is an Ordered list, which we see here. As with the bulleted, we can replace our nested divs with ol and li tags to achieve the same effect. And if we really wanted to, we could even use the value attribute on the li tags to specify the value to display. The last type, Link, is an approach that has been around for quite some time to create menus. While you can still do this with a ul element, Semantic handles some of the niceties for you. For example, it removes the bullet, and provides an active class to indicate what the current item is. At this point, there's really not much on lists that you haven't already been able to do with standard HTML markup, specifically, ul and ol tags, but as we go on a little further in the clip, we'll see that Semantic makes some stylings a lot simpler by their use of lists. In previous clips, we saw how buttons and labels made use of content, but nowhere is content more important than on lists. After all, it's what's on the list that makes it valuable to the user. The first type of content that we'll see is Icon. Here we have a list of three different technologies, HTML5, CSS3, and RSS. We've used their icon from the Semantic icon library and displayed it alongside the text. We could do the same thing with images as we see here. We've provided an image and text describing the image. Notice here that the image is a standard Semantic image. That means we're able to provide modifiers on it, in this case I made them mini rounded images. The other variations and types that we saw in the Image clip are also available. The next type of content we can provide in our list is a Header. Here we have a list of definitions for three Semantic UI terms. The term itself is given the ‘header' class. This bolds that element and makes it stand out more from the rest of the list. Related to headers is the description content. As we look at this list, it looks very similar to our last one, but look closely at the difference between the definition for types and the definition for the other two terms. It's subtle, but applying the description class makes the text a little bit lighter than not applying the class. Before we get into variations of List, let's take a second and look at an example from the Semantic UI website that combines several of the concepts we've already talked about. Here we have a list with nested lists, each of which uses an icon, as well as a header and description content to easily create a directory tree. As with most other elements, there are a series of variations that you can apply to lists as well. The first is Horizontal. Here we've taken our icon list, applied the Horizontal class, and changed it from the vertical list. The next variation is a Selection. Looking at the list now, we see that all the text is gray. As we start to hover our mouse over each element, we see a few changes. First the text becomes black, next there's a gray bar highlighting the current item, and third, the mouse pointer changes to indicate that the item can be clicked on. A similar variation to selection is Animated. This time, when you hover over the list we can see that the list item moves to the right to indicate which item is currently under the mouse. The variation we see on our screen now is a Divided list. Again, we see our terms and definitions, but instead of only using headers to break them up, we've used dividing lines in addition to the headers and descriptions. Dividers are a semantic element that we'll look at more in a later clip, but this is a very basic use of dividers. A slight change on that variation leads us to a Celled list. Here, instead of just having the dividing line below the list item, each list item is placed in a cell with a top and bottom border. Unlike dividers, however, there is no celled Semantic UI element, it's only a variation. This last list variation we'll look at is the Relaxed variation. This allows us to provide more spacing around our items. As we see three copies of our terms list here, the first one provides no variation, it's the same list we saw earlier. The middle list is relaxed. Notice that there's a bit more space between the description of one item and the header of the next item. The third list is very relaxed, and it has even more space between the list items. This isn't the first time we've seen the very modifier on a variation. In the Segments clip, we saw that we could make the spacing very padded, again, highlighting the natural language approach that Semantic takes. As with other elements, lists contain two variations that we've discussed elsewhere in this module, and those variations are Inverted and Size. Unlike other elements, lists are the first time that we have discussed content variations. As the name implies, there are not so much variations on the lists themselves, as they are on the content inside that list. The first variation is Vertical Alignment. We saw this earlier with Images, and here we see that we can apply the Vertical Alignment styles to the images that are part of the content of our list. Here are three images, one with the top aligned, one with middle aligned, and one with bottom aligned text. The other content variation is Floated. Here we have a list much like our image content above, but we have three pictures with a description of each category, only this time we placed our description in a content class and instructed that the content float to the right. One example use of this would be to place a trash icon all the way to the right so that the user has to make a concerted effort to remove an item from the list. At this point, it might be tempting to take what we've learned about lists and apply it to the Comments section of our event, but we're not going to do that. Instead, once we look at views we'll see that there is a Comment view and we'll use that style for our Comment section.

Feature Request: Dividers
Looking at Trello, it appears that Chocolate Chip has some more work for us to do. As we look at the card we see that the title is Element are running together. That in and of itself isn't super descriptive, but it looks like she left us a comment as well. Not only does the ratings form run into the bottom of the description, but all the previous feedback runs into the ratings form. Notice that this time she also attached a screenshot to save us the trouble of pulling up the app. Looking at this, we can see that the Ratings form, and the Comments section could use some help setting themselves off from the surrounding elements. To do that, let's take a look at Semantic UI dividers.

Dividers
We first saw dividers when we were looking at lists. We used them there to distinguish between one list and another, and we also used it as a variation, which had dividers between individual list items. In this clip, we'll look at the different divider possibilities. The first type is the standard ‘ui divider' that we see here. The second type is a Vertical divider. Here we see it used between two images. Perhaps we're asking our users to choose which image they like better. Once thing to note here, in order for the Vertical to work, the surrounding element needs to have a position: relative style applied, and I've already done that on our CSS. Also note that this uses a grid. Grids are a Semantic UI collection, and we'll see those in the next module, but it's used here just to make sure the layout looks like what we want. Another use for a vertical divider could be when the user hits your page unauthorized, they could be prompted to either login or sign up, but note here that the text in the vertical divider is something you specify, so it doesn't have to just be or. In fact, you don't even have to specify text. The next type of divider is the opposite of Vertical, Horizontal. Here we have a couple of different examples where we've placed an icon and text inside the divider. To do this we used the header class, and we'll look at Semantic UI headers in the next clip, but note how we did it. We simply embedded our <i> tag underneath our divider tag. Those are the only three types of dividers. Dividers have no states, content or groups. They do have a handful of variations. The first two should be familiar to us by this point, Inverted and Clearing. Let's look at the new variations. The first one is Fitted. As we saw with our default divider example above, when we specified a divider there was whitespace above and below the line. If we wanted to eliminate that, we'd specify Fitted, like we did here. Notice that now there really is no whitespace between the text and the line. The next variation does just the opposite. Instead of eliminating whitespace around the dividing line, it expands it. This variation is called a Section. The final variation doesn't impact the whitespace, but it does hide the line. This variation is Hidden, and you might be wondering why you would use a divider that wasn't even displayed, but one thing it does provide is a consistent whitespace, and since these are variations, you could even combine Hidden with Section to provide even more whitespace between elements. So how can we apply these concepts to our application to make our sections stand out a bit more? Let's start with our Ratings header. Let's turn this into a horizontal divider. We'll change the text from Ratings to Tell Us What You Think, and we'll add a comment icon as well. Then let's go down below our submit button. Here we'll add a horizontal divider with a star icon and the text of Ratings. This will help split the page up into three sections. The top tells us about the event, the middle allows our users to tell us their opinion, and the bottom section will display ratings from our previous users. It not only adds some space, but it also helps provide some definition to our application. Let's consider this feature request complete and add it to our Done pile.

Headers
A few clips ago we looked at Lists, and one of the things we noticed was that while we could do a lot of the same things with standard HTML, Semantic made it a little bit easier for us by providing some convenience classes. We also saw some variations that were in line with the rest of the Semantic library, essentially guaranteeing that how we handle lists isn't fundamentally different from how we handle buttons or inputs, or any of the other elements. We're going to see that again in this clip with Headers. We encounter headers quite frequently in HTML. It's often one of the first tags that people learn when they're learning HTML. In Semantic there are four types of headers. The first one we'll look at is ui header or page header in Semantic, and it's applied to our normal HTML header elements. As you'd expect, h1 is bigger than h5. One interesting note here is that the size of the ui header elements is in rem. rem size is based off the font size of the root element. If the font-size of your HTML tag is 12 pixels, and you have an element with a font-size of 10 rem, then its calculated font-size is 120 pixels. Let's take a look using a real example. We'll add an html rule to our CSS and specify the font-size as 24px, and we'll see all of our elements grow. In Semantic, h1 is defined as 2 rem, so if we added a div with a font-size of 48px, and specified the text to be First Header, we see it's the same size as our h1. As we mentioned a minute ago, Semantic calls these types page headers. Regardless of how far they're embedded on the page, they'll still get their size from the html font-size. In contrast to that, Semantic UI also has content headers. These are in em and not rem. This means that they're going to take their size based on the font-size of their containers, and not the page size. These content headers use a lot of the sizes that we're familiar with. Here we see a Huge, Large, Medium, Small, and Tiny header. They're placed in a segment. If we apply a custom font-size to our container, we'll see our content headers change as well. The next type of header in Semantic is an icon header. This behaves about like what you'd probably expect. It places an icon in the header and sizes it correctly. Here we've used an h3 combined with a circular icon variation to indicate that what follows will be Beta Features on our site. The last type of header we see is a sub header. This type is useful when you have important information, but but it's not as important as your full header. Here we've specified the phrase, Try these features out, as our sub-header. It's shown on the screen below an h3. It's using all capitalized letters, and its overall size is smaller than the other headers. A sub-header in and of itself probably isn't the most useful. Where it starts to get useful is when you can incorporate it into the content of your header. Here we've combined a large header with a sub header inside of it. This ties the two headers together. We could have just as easily applied this sub header content to a page header or icon header. There are two other content types as well, and they're related to each other. They are the Image and Icon content types, which we see here. The difference between an icon header and icon content is subtle. It's similar to the difference we saw between an image label, and image content on a label. With the content, it's just part of the header text, as we see here. The only state that exists for headers is Disabled, and we've covered that in other clips. There are two variations that we'll look at examples of. The first is drawing from our last clip of dividers. It's a dividing header. It draws a dividing line underneath your header before the next element. In this case we've got a paragraph of text below our header, and we can see it's separated by the dividing line. The other header variation we'll look at is a block header. Here we surround our header in a content block. This can provide more of an offset for the header than simply a larger font, and of course, since it's a variation, you can apply it to different header types. In addition to these variations, there are also five variations that we've covered elsewhere that also apply to headers, and those are Attached, Floating, Text alignment, Color, and Inverted.

Loaders
In the Input clip, we saw that we could set the state of an input to Loading, and it would place a circle over our textbox to indicate that the application was busy. In this clip, we're going to look at the Loading element. There are two types of loaders in Semantic. As with many other elements, the first type is simply ui loader, and we see it here over a segment. Note that in our markup we placed it inside of an active dimmer element. If it's not placed inside of an active dimmer, or specified as active itself, a loader will not show up. The next type is simply Text Loader. Here we specify text inside of our div, and it gets displayed underneath our loader. In our case, we've told our users that our data is rendering. As we just mentioned, if a loader is not placed inside an active dimmer, then in order to show it, the loader needs to specify that it is active. That is the first of three states that a loader can have. The second state is also shown here, and that is Disabled. This state will hide the loader. The third state is indeterminate, and it's best shown next to a plain loader. The top loader here is the same that we saw with our standard ui loader. The bottom one has the indeterminate state applied. The difference here is that it's spinning in the opposite direction. This can be used if you either don't know how long something is taking, or if you're still calculating how long it will take. Google Chrome takes this approach when loading new tabs. It spins counterclockwise while resolving the address, and then converts to clockwise once it starts loading the page. There is one new variation on loaders that we've not yet seen, and that's Inline. Here we see a loader inline with our header. This doesn't have to be used exclusively with the header, the point here is to show that the loader can be inline with some other element, and it doesn't have to overlap it like we‘ve seen elsewhere in this clip. There are two other useful loader variations that we've covered elsewhere in this module, and those are Size and Inverted, and they behave as they do elsewhere in Semantic.

Rails
If you need to display content outside the main viewport of your website, then Rails are the elements to use. They provide space for optional content, such as ads. Semantic has specified the default size of rails as 300px, in part because it will fit most ad sizes. One thing to note here, in order to get rails to appear in our demos, I've created a couple custom styles, the first one is Narrow, and you'll see that on some containers. I've also added a Tall class to the segments. These are not default Semantic variations, but one I created specifically for this demo. There are three types of rails in Semantic. All three types can have left, or right, or both rails. The first type is a plain rail. In this example we see a center container with both a left and right rail. The second type of rail is an internal rail. Here we see our left and right rail inside of our segment, instead of on the outside. The third type of rail is a dividing rail. It's similar to the dividers element, as well as the dividing headers that we've seen in previous clips, only this time the divider is vertical, and we see this example here. There are two variations for rails. The first one is Attached, which we've seen with segments and other clips. The second variation is the Close variation, and this is similar to our padded or relaxed classes that we've talked about in other clips. This will bring the rails in closer to the main content. We see an example here. Notice how there is now space on the outside of the rails, between them and the edge of the screen. This is because the space between the container and the rails is smaller, or closer. Rails are often seen on sites that have a single column often _____ long form, so think of something like a blog post or an article, and then you can use rails on the right or left to handle things like ads or related links.

Reveals
When we looked at buttons, we saw an animated button. In that clip, we used a button that said Follow Me, and when we hovered over it it showed my Twitter handle. In this clip, we're going to look at something similar, and that is the Reveal element. This element works by having two pieces of content, a visible and hidden, and when the user moves over the element it will transition between the visible to the hidden. There are three types of reveals, and each type describes how the hidden content is revealed. The first type is Fade. Here the visible content fades out as the hidden content fades in. The second type is Move. This time, when the user moves the mouse over the image the visible content moves out to reveal the hidden content. While they're not technically variations, you can specify left, right, up, and down on your move element to indicate the direction the reveal should move. The third type is Rotate. Here the visible content rotates out to expose the hidden content. Also note with this example that you don't have to use images in your reveal, and as we see here, the visible and hidden content don't even have to be the same type. Here our visible content is a header, and our hidden content is a div. As with the Move, you can specify that the visible content rotate left to display the hidden content. There are two states for Reveal, and the first one allows you to programmatically show the hidden content, and that is the Active state. If you apply the Active class to the element, it will show the hidden content. The flip side of that, you can disable the hidden content, which we see here. When this state is applied, hovering doesn't show the hidden content. There is only one variation on Reveals, and that is Instant. This will set the transition delay to 0 so that the transition happens instantly.

Steps
The last element that there is for us to look at in this module is one of my favorites, it's the Step element. It's very useful when you want to walk your user through a workflow or process and show them where they're at in that process. There's only one type, and that is Step. We see that basic type here as a list of three steps. By themselves, steps really aren't all that interesting. Where they get interesting is when we start grouping them. The first group we see is the Ordered group. By specifying the Ordered class on our group, Semantic will automatically number the steps for you. We can see here that we have three steps, and that we did not specify the numbers ourselves, but instead that this was done by Semantic. We can also have vertical steps by using the vertical group, and we saw something very similar when we did a vertical group of buttons in the Buttons clip. There are three familiar content types that we have seen on other elements. We will look at them here so that we can see how steps look with the content. The first is Description, and we see it here providing some detail to the Steps title. We can also put an icon inside of a step. We see an example of that here, and we'll see more as we look at the rest of the examples in this clip. Icons can be a very useful content for steps. The final content type is shown here as a Link. As with other link elements, it alters the appearance, indicating that the user can click that step. This would be a useful way to allow your users to jump back to a step that they've already completed and check their work. There are three states for steps as well. Two of them, active and disabled, should be familiar by now, and they behave as you would expect. The third state, though, is more interesting, and that is the Completed state. Here is an example of some completed steps that had icons. As we can see, the icons have been replaced with a green check to indicate that that step has been completed. In addition to the states, there are a couple of variations that we'll look at. The first is Stackable, and this will convert the steps from horizontal to vertical if the window is not wide enough to show the steps. We can see that here by resizing our window. As soon as the window gets small enough that one of the steps would be cut off, Semantic converts it to a stacked list of steps. Another interesting variation is the evenly spaced steps. Note on the group of steps that we specify how many steps we'll have, in this case three. Doing this stretches the steps to fill the entire horizontal space, and it makes each step one-third of that size. As with other elements, there are some familiar variations that we've seen in the past. These are Fluid, which will make the steps fill the entire container, Attached, and Size. One thing to note about Size, however, is that there are only two options, either small or large.

Conclusion
Whew, we covered quite a lot of information in this module. We looked at every single element in Semantic 2. 0. We started with containers, and we just wrapped up with steps. For some of those elements, we were able to apply them to our sample app to make it start to take shape. Others, we only looked at examples of how to implement them using CodePen. There were a few themes that came up over and over as we looked at the various elements. The first one was the consistency that exists throughout Semantic UI. For example, the following elements have an inverted variation, Header, Icon, Input, List, Loader, and Segment, and for each element it means the same thing, it's white text on a black background. Next we saw the customization that you can accomplish with Semantic. You can add icons to several different elements, such as buttons, lists, labels, inputs, and more, but you can also combine multiple icon variations to essentially create a new icon. As we saw in the icons clip, we created this icon by adding an inverted refresh icon to the corner of the mail icon, essentially making a refresh my messages icon. The third big concept that we picked up in this module is the way that Semantic uses natural language. For example, on the Segments clip we saw the way to make a segment more padded was to specify very padded. Similarly, when we looked at lists we saw that a list could be very relaxed. As we read the classes applied to the markup, we can have an understanding of what it will look like without trying to translate between the CSS language and English. While we didn't discuss any custom variations, I hope that you were able to see the pattern that you could follow to create your own classes. For example, if you needed an even bigger button, you could create a new class named Enormous that was even bigger than massive. Now that we've discussed elements, we can see the basic building blocks used to build sites. We've also nailed down several key concepts of Semantic using real-world examples. We're now ready to grow some more, and step out of the world of elements. In the next module, we're going to tackle collections, which are defined on the Semantic website as heterogeneous groups of components which are usually found together. They describe a list of "usual suspects" which appear in a certain context. That is things like menus and forms. Once you've caught your breath, move on to collections in the next module and we'll make our site look even better still.

Semantic UI Collections
Intro
In this module, we're going to move past elements and into collections. As we saw in the last module, collections are defined by Semantic UI as heterogeneous groups of components which are usually found together. They describe a list of "usual suspects" which appear in a certain context. Think of the common parts of your application. Oftentimes you'll have forms and menus, and grids. Occasionally you might see data displayed in a table form. Each of these is an example of a collection. In Semantic UI there are six types of collections. They are Message, Form, Menu, Grid, Breadcrumb, Table. In this module, we'll take a look at each of these type of collections. I imagine Chocolate Chip will want us to implement at least a couple of them in our application to clean up how it looks. In addition to collections building off of elements, they have some of the same concepts as well. Most of the collections we'll look at will have Types, States, Content, and Variations. In fact, we'll see more content with collections than we did with elements, and that makes sense, because part of what makes a collection is the content inside of it. As we did with elements, we'll make each collection its own clip. This way you can use the clips as a reference later, for example, if you want to come back and look at menus once again. Alright, let's get started.

Messages
Let's get started with collections by looking at one of the simpler collections in Semantic, and that is the message collection. While messages may not contain a lot of types and variations, they are very useful for modern applications. A great example of when to use a message is to notify users of an upcoming outage. There are four types of messages, and as we often saw in the Elements module, the basic type is simply ui message. So far this doesn't look all that special, in fact, we can probably imagine that it's a variation of the block type of header that we saw in the elements module. The next type, however, is the first real instance that we see of a collection combining elements. This is a list message, and it takes a ui list, which we saw in the last module, and places it inside of a message. Here we see the same ui message, but this time inside we've placed a ui list. It's still pretty boring, really, but since we're using an actual Semantic list here we can make variations on it if we wanted to. In fact, here we've created a message with an icon list inside of it. This is because of the component nature of Semantic. We take the building block of our list and combine it with our message. It's not that we have a list subset with messages, but instead we're using the actual list elements that we saw in the last module. Our next message type also builds on an element that we learned about in the last module. Our new type is an icon message. Here we see a blue Bitbucket icon next to our message. As with the list message, this is a fully-functional icon inside of this message, so we can customize it however we want. The last type of message allows you to give your user a little bit of control over when they see the message, and that is a dismissible message. This places a close icon in the upper right. If we hover over the icon, our cursor changes, indicating that we can click on it. However, in order for that to work we need to write some JavaScript to handle that click event. Here we're using jQuery to grab our message. We do that by passing in the two classes, message and close. Then we listen for the click event. When that happens, we find the closest message. In this case, it's the one we clicked on, and then we hide it. This allows our users to dismiss our messages. There are two fairly self-explanatory states for messages, and those are hidden and visible. These can be useful if you want to place a message on your page, but only show it once a specify condition is met. In that case, you could apply the hidden class until you're ready to show it, at which point you would apply the visible class. Messages do have several variations for us to alter how they look. The first variation will provide a bit of a shadow underneath the message to make it look like it's floating over the screen. We see an example here. This isn't to be confused with the floated variation that we saw in the elements, and had the element floated to one side of the screen. Sometimes we might not want our messages to take up the entire horizontal real estate. We can have it only take up the space that it's required to display the message. For example, we see this message is about a quarter of the horizontal space, and we accomplish this by using the Compact variation. There are a handful of variations that express the intent of the message, and we see all of these here. They are Warning, Info, Success, Positive, Negative, and Error. At first glance you're probably wondering why I showed both Success and Positive, since they are clearly the same style, and the same with Negative and Error. The answer is that by default they're the same style, but in Semantic they actually use different variables, so you could alter the success colors to make it look different than the positive colors, if you wanted to. In addition to these variations, we can also alter the appearance using Attached, Color, and Size. So there we have messages, one of the simpler collections, but they are a good example of what a collection is. We saw that they can have full-featured lists or icons, taking advantage of all of the variations and types we saw in the last clip. We also saw that collections have types, states, content, and variations in the same way that elements do.

Feature Request: Forms
We have our first feature request from Chip for this module. Let's see what she wants us to work on now. In the last module, we cleaned up some input fields, but we couldn't do much with our text area. Chip has noticed that it sticks out like a sore thumb. She's got this to say. The comments block and submit button look completely out of place, and she's right too. Our name field looks good, and even our Ratings field looks good, and then we hit the comments input and that just looks bad. That section of our page is a form where we accept input from our users and send it to the server, so to clean up that section let's take a look at Semantic forms and see what we can do.

Forms
The next question that we'll look at is the Form collection. Forms are pretty familiar to us. They're how we get information from our users. Semantic has just one type, and that's ui form. In the last clip, we saw how messages had visible changes on the screen. With forms, we won't actually see the form on the screen. Instead we'll see changes to the appearance of the content of our form. The first type of content that we see is simply a field. This is nearly ubiquitous with our forms. It defines some standard styles. As we see here, we've placed an input inside of the field, having the field class provides some styles to the elements inside of it, for example, line height. Also, we can see by default that our input takes up the entire width of the page. This is in contrast to a plain HTML input. If we wanted to have several fields grouped together, we can do this with the ‘fields' class. Here we see our fields all on the same line. We also see that our last field, birthday, is an icon input. We originally saw this in the input clip from the last module. We create the input here in the same way that we did there. Also note that when we use the Fields group it behaves responsibly. As we shrink our screen size, we can see our fields get closer and closer, and if our screen size is small enough it'll simply be a vertical section of fields. Next we see the Text Area content. As with inputs, we place this inside of a field. We can see that our text area takes up the entire width of the field. We can also specify the number of rows for our text area. So here we have a regular, large, and small version of our text area. The next type of content in our form is pretty common, and that is a Checkbox. Here are three variations on our checkbox. We have a normal checkbox, a slider, and a toggle. Note that in order to make our checkboxes work we need to add some JavaScript. I've done that here where we grab our checkboxes using the. ui. checkbox selector, and once we grab that we call checkbox on it to tell Semantic to enable the checkbox functionality. Now when we click these the buttons will toggle. checkboxes are considered modules in Semantic UI, and we'll look at them in more detail in our module on Semantic modules later in the course. If you wanted radio buttons instead of checkboxes, you can also do that. Here we see a list of possible source code repos. Note that we've added the radio class to our checkbox. As we click through the list, they operate as you would expect, only allowing one item to be selected. The next piece of content is also pretty common, and that is a dropdown. Here we're using the dropdown module, which will take an HTML select and make it a dropdown. As with the checkboxes, we need to add some JavaScript to allow Semantic functionality to be applied to the dropdown. In addition to the plain dropdown, we can also provide a multiselect on our form. This is a type of dropdown that we'll see in a later module. Here we've got a list of technologies. As we click on a language, it adds it to the box to show which languages have been selected. If you don't want to use JavaScript or UI dropdown, you can still place a dropdown in your form. Here we see a bare-bones example. It styles it as a plain HTML select. As with checkboxes, dropdowns are also considered modules, and will also be taken care of in the module on Semantic modules. This last piece of content is a message. As we talked about in the first clip, collections are groups of related content. Even though messages are themselves a collection, they can also be used inside of other collections. Here we've got a password field and a ‘ui error message'. Notice, however, that we can't see the error message. That's because by default messages that are Info, Error, Success or Warning, are hidden when displayed on a form. In order to show the message, we need to add the visible class to the message. Now we can see our error message showing what was wrong with the password that was entered. Just as we've seen with several elements, like segments, a form can also have a loading state, and it behaves like all the other loading states that we've seen and discussed. There are three states that you can apply to a form to indicate its status. Those are Success, Warning, and Error. These are similar to the states that exist on Messages. One thing to note, however, is that if you have a message embedded in your form, Semantic will only show the message that lines up with the state the form is in. For example, here we have both a Success and Error message on our form. by applying the Success state to the form, we only see the Success message. This allows you to place potential Success, Error, and Warning messages throughout the form, and then set the state on the entire form to show the correct message. You can also apply error states that don't apply to the entire form, but to fields as well. Doing this will highlight the field to indicate that that field is in error, and you can apply this to multiple fields. For example, here we see that both First Name and Email are being set to Error, and they're highlighted in red. There are two other states that we can apply on the fields. The first of these is Disabled, which we've seen in the past, and it performs like you'd expect. The second is readonly field. We make a field readonly not by applying a class to the field, but instead by applying the readonly attribute to the element. Here we see it on an input box. This does not alter the appearance, the input box still looks like a normal input, however, it does prevent the user from clicking in the field. Additionally, when we hover over the field the cursor remains a pointer and does not shift to the text entry cursor that you might expect. Now we're ready to look at variations. There are actually three classifications of variations. We have Form, Field, and Group variations. We'll look at the Form variations first. The first variation is Size, and we typically don't look at size because it's applied to so many different elements in Semantic, but since the actual form isn't a visual element, we need to look at what setting form size does. On the screen we have a Small Form and a Large Form. Notice that applying the size variation to the form actually alters the fields. That is, the fields on our second form are much larger than the fields on our first form. The second form variation is equal width variation. When we apply this, each field inside of the group of fields will be the same width. To demonstrate this, we created two groups. The first has two fields, and the second has four fields. This variation makes each field inside of a group be the same size, and when you look at the screen you can see that our Address and City are each one-half of the size of the First Name field. The final form variation is an inverted form, and this behaves like you would expect, turning the background to black with white fields inside the form. There are also three field level variations. The first one is Inline. Here we see an example of an inline field. It moves the label from on top of the field to next to it, and since this is a field level variation and not a form level variation, it means we can actually have some fields be inline, and others not. The next field variation is width. These widths take advantage of the Semantic grid, which we'll see later in this module. The grid is 16 columns wide. In order to set the width, you simply specify the number of columns you want the field to take up. For example, here we have three fields. One is eight wide, one is two wide, and one is six wide. This gives us control over how wide each field is, so that we can give the City field more real estate than the State field. The final field variation is the Required variation. Here we have the same form as our last example, only this time we specified that the Zip Code must be entered. We do that by specifying the required class on the field, and this applies the red asterisk to our label. Keep in mind that there are field variations, so even though we've just been using textboxes here, you can apply these variations to any form field, such as a checkbox or text area. The final modification to forms that we'll look at are Group variations. The first group variation is also one we saw on Forms, and that is equal width. The Form variation applied this variation to every group, but since it's also a Group variation, we're able to apply it to only one group if necessary. Another variation that is similar is the evenly divided variation. This will make a group split its real estate equally between all of its fields. To accomplish this, simply specify how many fields will be in a group. As we see on the screen, we've specified that this group will have three fields, and as we see, the three fields are all the same size. Semantic does this automatically, without you needing to think about how much space to allocate each field. As the screen resizes, the fields also automatically resize, while ensuring that each of the fields are the same size. The next group variation we can apply is the grouped class. This will take our fields and group them together. For example, here is a list of radio buttons that we saw earlier in this clip. If we do not apply the group class to our fields, these radio buttons would not be vertical, but would instead be horizontal. The last group variation is similar to what we see with field variations, and that is inline. This would let us apply the inline style to the entire group, instead of needing to apply it on each field. We see an example of this here with our Name fields. Now that we've seen what Semantic can do with forms, let's apply it to our page. Let's start by finding our form element and applying the classes ‘ui form' to it. Next let's create a fields div and place both our Name and Ratings fields inside that group. Then we need to make our Name field wide enough to accept a first and last name, so let's set it to be eight wide. Then we'll place our text area inside of a field, and this will give us a nice appearance in whitespace on the top and bottom of the text area. Finally, let's apply the classes ‘ui primary button' to our Save button. Now there was nothing about this button that kept us from applying these styles back when we looked at the buttons, we just didn't do it. So we'll apply that style now to finish cleaning up the appearance. As we refresh the page, we notice that the form for our user reviews looks a lot better. There is no longer the difference between the inputs in the text area, and there's whitespace around our elements. I think it's safe to say that we've satisfied Chip's requirements, so we'll move that card to the Done pile.

Feature Request: Menus
As we've seen in the past, cleaning up one part of our page exposes another part of our page that needs attention. This time, Chip is pointing out that our header doesn't look right. In fact, in her comments she says, There's really only one or two things left to pick on for this page. The top of the page is a big on, however. It looks out of place and not at all like the rest of our site. See the attached screen shot. Well, let's look at the screen shot. Here we can see a few links at the top and then this black button for adding an event. If you remember, when we styled that button we said it looked out of place, but that we'd address that later in the course. We're now ready to address the ugliness that is the top portion of our page, and we'll do that with menus, which we're ready to look at in the next clip.

Menus
When we looked at messages, we noted that we started with them because they were one of the more simplified collections. As we look at menus, we'll see that they have the most options of all the various collections we'll look at. As with all components, we'll start with the menu types. There are seven different menu types. The simplest is ui menu. We see an example of that menu here, it has a menu item for each type of Semantic component, and the standard style visually spreads all the way across the screen. The next type is a secondary menu. This provide the menu functionality, while at the same time deemphasizing the menu elements. Gone is the border around the entire menu, as well as the border around each individual menu item. This allows it to almost blend in to the background. The third type is a Pointing menu. This looks fairly similar to the standard menu. The difference here is that the active item will point to the content. Here we see it pointing to a segment with some text inside. You can also have a secondary pointing menu, which is the second menu on our screen. This time, instead of explicitly pointing down, it has a darkened bar underneath the active item. Up next is the Tabular menu style. This is probably a familiar look, especially for some of us older developers. It resembles the old tab panels that both Windows and Web Frameworks used to have. There are alterations that apply only to the tabular menu style, and those are top, left, right or bottom. We see an example of the left tab menu style. If you look at the detail of this menu, you see that it's actually combining multiple components. First there's a grid that we'll look at later in this module. then there's a vertical menu, and finally the left tabular style. Next we see a Text menu. This menu doesn't place any border around the element, and indicates which item is selected only by bolding the text. This is an even more stripped-down version of our secondary menu that we saw a minute ago. The next to last menu type is Vertical. we saw a glimpse of this a minute ago with the tabular menu type. Here we see two vertical menu types, the plain vertical menu, as well as the vertical secondary. While they're not shown, it is possible to combine vertical with every type that we've seen so far. The last type of menu is one that we've all seen before, and that is Pagination. This is targeted specifically for allowing users to jump to a specific page. Note that we've used the disabled state on the menu item with the ellipses. This prevents the user from being able to click on that item. Now that we've seen all the various menu types, it's time to move on to content. As we've already discussed in this module, content plays a big part in collections, because it's what's inside the collection that really starts to get interesting. The first content type that we'll look at is Header. We see it here on a vertical menu where components and and terms are our headers. Next we see another vertical menu, and this one also has a header like we just saw, but now we've added some more content to our menu. Now we've placed some text inside that provides some detail to what our menu items are. Note here that the header and text are visually different. The header is bolder and bigger, while the text appears unstyled. There are also some elements that we can place in our menu for content. In this example we've got an input element pulled to the right of our menu, allowing users to search. Another element that we can place in our menu is a button. Once again, we pulled this element off to the right. This time, however, instead of having an input we have a ui primary button, allowing our users the ability to log in. We can place more than elements, however. We can also place a dropdown module. As we saw in the Forms clip, in order to make our dropdowns work, we have to have JavaScript enabled for the dropdowns. In this vertical menu, we've got two dropdowns that pop out to the right with menu items in them. Another module that we can use is a popup. This one has to be demonstrated outside of CodePen. That's because CodePen renders our code inside of an iFrame, and when clicking on the popup, an error would appear that it couldn't appear in the viewport, so I've excluded it from CodePen and just did it in an HTML page. Here we see we specify the popup is two columns, and our two columns provide us the same information that we've seen in other vertical menus in this clip. Both popups and dropdowns are modules that we'll see later in this course. As we saw with placing messages inside of a form, you can place collections inside of another collection, and we can do this also with menus. Here we see a right menu in addition to the other menu. This allows us to organize our menus in a way that matches our needs. The final piece of content is a Sub Menu, and this is very similar to the menu item we just saw. In this example we take our vertical menu of components and Terms. This time we turn our Terms menu into a sub-menu, which allows that menu to expand to the right. One more content type that we didn't explicitly show is the type Link. We didn't specifically call this out because we've been using links in all of our menu examples. There are a couple of states for menus that we have already seen in this course. The first is active. We've seen this throughout the clip. By default, it provides a gray background to the active item. Similarly, hover will change the styles of the hovered item to look active without actually clicking on it. Menus have several variations that we've not yet seen, and quite a few variations that we've already covered. Let's start with Stackable. Stackable menus will adjust to the screen's size, and might be a good style to use if you anticipate mobile use on your site. Here we've got an inverted blue stackable menu. When our screen is wide, like on our computer, the menu is horizontal. As the screen shrinks, however, the menu resizes and stacks on top of itself to become vertical. Next we see the Icon and Labeled Icon menus. These are similar to icons we've placed on buttons. As we talked about on the Messages clip, the icons here are full-blown icons, so whatever you can do with an icon element you can do on icon menus. We see that with our top example sizing all of our icons, as well as coloring our sign-out icon red. As we've seen, our menus provide padding around the items. If we wanted to eliminate that padding, we could do so by applying the Fitted variation. As we can see here, there is no padding. As soon as one menu ends, the next one starts. We can also remove the borders from our menu items that are placed there by default. We do that by adding the Borderless class, which we see an example of here. There is one more variation that we'll look at, but we'll look at that on our application. Before we do, however, let's go over the available variations that are similar to other components that we've already discussed. Those are Attached, which we first saw in the Buttons clip, you can attach a menu to another item; Compact we saw on the Messages clip at the start of this module, and that makes the menu much more compact, taking up only the space it needs to display its items; Evenly Divided, which we just saw on the Forms clip will make our menu items all be the same width; Fluid, which we saw on Images, and by default our horizontal menus are fluid, and they take up the entire width of the screen, you can apply that to vertical menus as well; then there's Inverted and Colored, which we've seen on several different components, and even a couple of examples throughout the clip here; and finally there's Size, and as we saw on Forms, there's only two sizes that apply to menus, large and small. Remember, with all of the variations that we talked about, you can combine them in all sorts of various ways to suit your needs. That is, if the need arose you could have a blue borderless fitted labeled icon menu. We've covered just about everything we can with menus, so let's apply that knowledge to our website. Let's start by applying the classes ‘ui gray inverted menu' to the div that contains our links. Then we'll need to add the item classes to each of the menu items. Next we'll move our Add Event button to the right by applying the right menu class. Underneath that we'll have to add an item and place our button inside that item. Let's refresh the page and take a look at what we've got. We see now that the menu is more prominent, but that black button is still out of place. Perhaps instead of button we should make it an icon. We'll make our right menu a labeled icon menu, and then we'll place a calendar icon inside of our menu with the description Add Event. Now when we refresh it looks much better. Notice, though, that when we scroll our menu goes off the top. This is where the last variation of menus comes into play, and that is the Fixed variation. This will fix the menu to an edge of the screen, whatever edge you specify. We want ours to be at the top, so we'll apply the top fixed to our menu. As we refresh we see a couple of things. First, now our menu is all the way across the screen, and as we scroll everything scrolls underneath it, which is good, but we also see that our title is now underneath our menu, and that's not any good. We need people to know what event they're looking at. So let's go back and make one more tweak. Underneath our menu let's add a basic padded segment to the rest of our page. Now when we refresh the title drops below our menu and the page looks pretty good. One final thing to note. So far everything we've done on our site has been using Semantic out-of-the-box. Well that's not likely going to happen on a production app. It is good to see how you can get a basic styled page up with minimal effort, just by combining the default components. We've now cleaned up the menu style, and I think what we did really satisfies what Chip wanted, so let's move that card to the Done pile.

Grids
The next collection that we'll look at is a familiar one, and that is Grids. Grids are collections of rows and columns, and in Semantic UI there are also collections of other elements. Before we get into the types, states, contents, and variations of grids, let's nail down some basic understanding of how grids work in Semantic UI. To start, we divide our grids into columns. This splits our grid into equal horizontal chunks. Semantic uses 16 columns for its grid by default. While we're not demonstrating any theming in this course, know that you can adjust the number of columns by overriding variables in the default theme. While columns are horizontal chunks, rows are vertical dividers. Without specifying any rows, Semantic will automatically create a new row when there is no more space horizontally. However, you can also explicitly specify rows. For example, if you wanted a row that was only 8 columns wide, and a second row that was 10 columns wide, then you would specify a row using markup similar to what you see on the screen. The final concept to discuss before we get into the styling of the grid is that of gutters. Gutters are whitespace between columns. The negative space improves the readability of the content in the grid. The gutter width is constant, even when the size of the grid or the number of columns inside of the grid changes. Now that we've talked about some of the concepts of grids, let's get into the details of how we can apply them to an application. There are five types of grids in Semantic UI. The first is, as always, a ui grid. In our example, we can see that each of the 16 letters takes up the same space. The next type of grid is the Divided Grid. This will provide vertical dividers between columns. We see that same grid, but now there's a divider between each letter. We can also specify that our grid by Vertically Divided. In order to accomplish this, we'll break up our grid into two rows. Our first row has seven letters and our second row has nine letters, and there's a divider between the rows. This also demonstrates the concept that we discussed when we first looked at rows a minute ago, and that is, if we want to control when our row breaks happen, we can specify a div with the class row. Next we can tell our grids to show the individual cells. This type is called a Celled Grid, and we see an example here with each of our letters being inside of a cell. If we wanted to show our cells, but not wrap the entire grid with a border, we can accomplish that with the final type, and that is Internally Celled. For this example, we reuse our two-row grid and specify that it is internally celled, and we can see each cell shows its internal borders, but not the borders on the outside of the grid. As with other collections, grids also have content. For a grid, there are only two types of content, both of which we've already seen, and those are rows and columns. Without those two pieces of content, a grid doesn't really do anything. A lot of the variations that can be applied to grids are ones we've already seen elsewhere, but we'll cover them here quickly, as using a grid will help us review these concepts and perhaps show them a little bit better than other components. The first one we see is Floated. Here we only have two columns. Normally these would be side by side, but because we specified one to be left floated and one to be right floated, they're on separate edges of the screen. We can also specify our column width. To accomplish different widths, just specify how many grid columns you want that column to take up. Here I've specified a cell type so that we can see the width of the columns. A similar variation is, instead of specifying column width you can specify how many columns you'd like the row to have. As we see in our example, we have two rows. One is specified as a three column row and one is specified as a four column row. Again, they're celled to show how wide each column is. Notice that columns in each row are all the same size. If you don't want to specify how wide a row is, but you want all the columns in that row to be the same size, you can specify equal width on the entire grid. We see an example of that here. I personally like this variation because it allows me to add or remove columns to a row without changing the row's class. The grid will auto-adjust the widths for me. The next variation is one we've not yet seen before, and that is Stretched. It can be seen here using segments inside of the columns. We can see that the A and D segments expand vertically to fill the space. By default, the left-hand gutter of the first column and the right-hand gutter of the last column are trimmed. However, by specifying that the grid is padded you can add those gutters back in. The two grids we see here demonstrate the difference. The first grid does not have the gutters. The second grid, however, does have the gutters on the first and last columns. You can also specify only vertical or horizontal padding if you desire. Also note that here we specified the color of the columns, and we could also specify the color of an entire row, if we so desired. The next variation that we see is the Relaxed variation. This will add space between our columns. As with other instances of the relaxed variation, we can also specify a very relaxed variation. Again, we see our normal grid, then relaxed variation, and finally a very relaxed variation. We can also center our content in our grid. For example, here we have a ten wide column, and have specified five columns. By default, those five columns will be on the left, as we see on the top grid, but by specifying Centered on our row, we see that our five cells are centered in the grid. We can also control how our text is aligned. On the screen we see the default, which is left aligned, as well as the center aligned and right aligned. We have them specified here on the grid, but we could actually specify this variation on the row or column as well. We can align more than just our text. We can also align the elements inside of the cells. We see three possible options here. We have the top, middle, and bottom aligned rows. There is another entire section of variations that are specific to grids, and those are responsive variations. These variations handle how the grid will display on various devices. The first variation is Doubling. This will double the width of a column on a mobile site. Here we see four columns, and as we shrink our screen to a smaller screen size we can see that they actually double in size. This is the first option that can be utilized for responsive handling of a grid. The next option is to have the columns stacked on top of each other at mobile breakpoints. To do this we apply the Stackable class to our grid. This time, as our screen shrinks we see our cells fill the entire width and stack on top of each other. This keeps your grid cells in view even on a tablet or cell phone. You can also have the columns reversed based on the screen breakpoints. As we see on our screen, we have three breakpoints specified, computer, tablet, and mobile. We are currently seeing the computer resolution. As such, we see that that row is reversed. As we shrink, we see our middle row reversed, and then finally our last row reversed. In some cases you might want more control over the responsiveness of your application. Instead of just stacking and reversing, you can handle that by specifying that the columns show up only on specific breakpoints. Here we have four columns. Three of them specify the screen size to show, computer, tablet or mobile, and one doesn't specify at all, so it'll show up on all resolutions. As we shrink our screen, we can see our first column change from Computer Only to Tablet Only to Mobile Only. If necessary, we could also specify the tablet mobile only if we wanted it to be on both devices. Finally, it is possible to take complete control of the responsive nature of the cells. You can do this by specifying how many columns each screen resolution will have. For example, you could apply the ‘sixteen wide mobile eight wide table four wide computer column'. While this is possible, it is recommended to utilize stackable and/or doubling variations and allow Semantic to handle the sizing. As we've seen in this clip, grids can be very powerful in laying out your screen, not just for one resolution, but for multiple resolutions, and as we've seen so often with Semantic, you are in the driver's seat. There are ample customizations that can be made to make your layout uniquely yours. And while we didn't explicitly show it, it is possible to use grids as containers for all sorts of other various Semantic components.

Breadcrumbs
The next collection that we'll look at is Breadcrumbs. As with many other components, breadcrumbs are fairly commonplace these days. There is only one type of breadcrumb, and that's the basic ui breadcrumb. There are three pieces of content that breadcrumbs can have. The first is the divider that separates individual elements of the breadcrumb. We see that here with the class divider and a slash. We can place whatever text we want inside of that div. We can also change our div to be an i element and specify some icon. For example, we could have a ‘right arrow divider icon' or a ‘double right angle divider icon'. We can see the example of each of these on the screen. We also see the next piece of content, and that is section. Here our sections are the individual breadcrumb items. While looking at our sections we see a third piece of content, and that is a link. Note that our sections can be either a link, like Home or Local, or a div, like All City Carnival. This allows us to style them slightly different to indicate which items can be navigated to and which ones can't. While we're looking at our breadcrumbs, we can see the one state that breadcrumbs have, and that is active. This is a state that we've seen on other components. Here it indicates where we're currently at in our breadcrumb chain, in our case, All City Carnival. There's only one other variation on breadcrumbs, and that is Size. Here we see examples of tiny, large, huge, and massive breadcrumbs. That's all the customization available on breadcrumbs. There are no other variations or states that were uncovered. They are clearly the collection with the fewest customizations, and one of the least customizable components in Semantic at all, but you do still have the ability to make then not look like the default breadcrumb.

Tables
A couple of clips back we looked at grids and how we could use them to handle layouts. The final collection we'll look at is tables. While tables used to be utilized for layout, that's largely considered a bad practice now. Instead, tables should be used only for displaying tabular data. There are three types of tables, and like always, we start with the default ui table. Notice that we've placed this on an HTML table element. We've specified the header and data content. The second type of table can be used to emphasize the first column of data. Those are called Definition tables. We see one here providing definitions for the type and variation terms of Semantic UI. The third table type is Structured. We see an example here pulled directly from the Semantic UI website. This table type gives more control over how the table is formatted. Here we have cells that specify colspan, as well as cells that specify rowspan. All of this allows you to have custom table structures. There are a handful of states available for tables, all of which have been covered in other clips. All of these can be applied at either the cell or row level. They are Positive and Negative, that indicate the status, Error, which will show that the data has an error in it, then there's Warning, Active, and Disabled. As with grids, there's quite a few variations for tables. Some of them will be familiar to us, others will be new. The first one is Single Line. This will prevent a row from wrapping its content. We see an example here where we specify notes, and the last person, Josey, has much longer notes than the the other two. If we did not specify a single line, by default the description would wrap around and make the third row taller than the other two. The next type is Fixed. Here the table does not grow horizontally to accommodate the space. In our example on the screen, the first table is a default ui table. As the description gets more data, it shrinks together columns to make sure the description content can fit. The second table, however, is a Fixed table. On this table the columns don't shrink, instead the height of the row increases. By default, tables in Semantic UI are stackable. We saw how those worked in the clips on grids. If you do want your table to stack, then you can specify the unstackable class. The on-screen example shows one table without the class and one table with the class. We can see with the latter table that it will reduce whitespace and start wrapping, but it won't stack. If we want to indicate that a row can be selected, we can apply the Selectable style to the table. Then, when a user hovers over a row it will style that cell differently. In our case, that means a gray highlight over the entire row. If instead of an entire row you wanted to make an individual cell selectable, you can do that by applying the selectable style to any cell that you want to be able to select. Cells that don't have that class will not have any change when the user hovers over them. If you want your table to have a ledger look where alternating rows are colored, you can use the Striped style on the table. We see an example of that here. In our example we have an inverted orange table, and we can see that rows 2 and 4 are slightly lighter than rows 1 and 3, providing that striped look. If you want a cell to only take as much space as is required, you can specify the Collapsing style on that cell. On the screen we have a basic table so that the header is not shaded. We have specified that our Age cell is collapsing, and we can see it only takes up the space that it needs to show _____ age. If you'd like to have that same style on all your cells, without applying it to every single cell, you can also apply the collapsing style to the table as a whole. In this example, each column only takes up the minimal space required by the data and header. One common use for tables is the ability to sort the fields. This can be handled with Semantic's Sortable style. In order to do this, we had to include the tablesort library from the link on the screen. Now when headers are clicked, the table is sorted and indicates to the user the direction that the column is sorted on. The final variation that we'll look at is the Full Width variation. This can be applied to the header and/or footer. A good example is our definition table from earlier in the clip. The original table did not have a heading over our first column, but by specifying full width it will fill in that cell. There are some other variations that we've already covered in other clips. To start, there are four variations that we saw in the grid clip. Much like grids, tables have 16 columns by default. These variations are Column Count, Column Width, Vertical Alignment, and Text Alignment. They behave the same as what we saw in the Grid clip. In addition to the grid variations, there are also other variations we can apply to tables that we've seen elsewhere in this course, and these are Basic, Size, Inverted, Colored, Padded, and Compact.

Conclusion
In this module, we looked at each collection that Semantic UI has. We saw how Semantic builds upon its elements. For example, in the Messages clip we saw that we can have a full-fledged icon in our message. Or, in menus we saw that we can add an input box and style it the same we could elsewhere on our page. This highlighted how Semantic approaches customization. As we saw with elements, terms like inverted had consistent meaning. That was true in collections as well. Inverted grids behave the same way as inverted segments. We can expect, as we move into views and modules, that inverted will behave the same there as well. We were also able to start to see how Semantic handles responsiveness. In forms, grids, and tables, we saw that Semantic provides classes that will convert the collections to stacked versions if the screen is a mobile size. Part of this was using either the column width or number of column variations to describe how many elements should be across the screen. Another thing we saw here was the prominence of content. With elements we saw very little content, but collections without content are basically useless. For example, with a form, all that we see is the content. The form itself does not display anything. Now that we've seen how we can handle the usual suspects, we'll move onto views in the next module. Semantic defines a view as a convention for presenting specific types of content that is usually consistent across a website. That is, while elements are the basic building blocks, and collections are combinations of elements, views are the consistent look of an application, and we'll dive into those in the next module.

Semantic UI Views
Intro
At this point we've turned the corner, and have started down the home stretch. We've seen Semantic's componentized approach to styling, and we've seen how variations and types apply across components. Now we're getting to see how to put all those pieces together. In this module, we're going to look at Semantic UI views. Remember, in Semantic, a view is a convention for presenting specific types of content that is usually consistent across a website. Think of a blog that has a section at the bottom where you can leave a comment. Each place on that blog that you can leave a comment has the same look and feel. In Semantic's lingo, that is s view. Semantic has six views out-of-the-box. These are Comment, Card, Feed, Advertisement, Item, and Statistic. In this module, we'll again have a clip for each view. We'll also take a look at implementing a few of these views on our website. Our current page is just about complete, so we'll take a look at some other pages that would exist in an application like this one.

Feature Request: Comments
It's been some time since we've had a feature request to clean up our event page, but we've got one now. Chip is ready for us to wrap up the event page, and in order to do that she wants us to address the Comments section. In fact, in the comment of her card she writes, Looking at the events page, it looks as if we forgot to style the comments section. Let's make sure that it fits in with the rest of the page. Since it has been a while since we touched that page, let's take a quick look and see what the comments section looks like. As we can see, this section looks very plain. I'm sure we can make Chocolate Chip happy by styling the Comments section so that it's more in line with our other styles. We'll do that with a Comments view, and we'll look at that in the next clip.

Comments
If you remember back to the List clip in the Element module, we discussed that we did not want to use lists to display our comments. Instead we wanted to wait and use the comments view. So let's start with the single type, and that is ui comments. We see a pretty plain example of comments on the screen. While it is plain, let's look at a few things. First, we have a collection of comments which we see with the ‘ui comments' class. Then we see two individual comments. This should be a familiar idiom at this point, having groups of items. Next we see the ‘content' block. We'll look at that section in more depth in just a minute, but note that at this point it has an ‘author' piece of comment which bolds the name, as well as a ‘text' section which has the actual comment. As with collections, views get a lot of their meaning from the content inside of them. We've already seen a bit of content in our comment, but there are more pieces of content than just author and text. The first piece of content to look at is an avatar or image. If you notice, while this is a piece of content, it's placed outside of the content div. This allows the avatar to be placed to the left of the entire comment block. The image here is normally much larger, but by applying the ‘avatar' class it scales it down to be an appropriate size. While we have an avatar as a div, it could easily be a link that takes you to the user's profile page or posting history. The next piece of content that we can specify is metadata. This is useful if you want to supply some information about either the user or the comment. In our example here, we see that Frank left the comment yesterday and that five other users have started. Also note that our metadata contains an icon, and more than that it contains the yellow variation of our icon. Again we see that we can apply variations to our elements, even inside of views. Another type of content available to us is the actions content. As we see with this version of our comments, actions have some similarity in style with metadata, in that they're gray. We've placed ours underneath our entire comment, but they can be placed wherever you want. Also, while we didn't show it here, actions can also have icons. The final piece of content is a reply form. The example we see on the screen is a thread reply, that is the reply will be made to Frank. It was accomplished by placing the form inside the content section. If we wanted to provide the ability to reply to the original post and not to another comment, then we would move it outside of the content section. In contrast to the numerous pieces of content we've seen, comments only have one state, and that is collapsed. You can think of this as hidden. Here we see in our code that there are two comments, one by Frank and one by John, but on the view portion of the screen we don't see John's comment. That's because it's in the collapsed state. There are only two variations for comments. The first one we see here, and that is threaded comments. This is a pretty familiar approach to comments in which you can reply directly to someone. Let's look at how we accomplish this. The first thing we have to do is create a comments section in our first comment. Then inside of that comments group we place our second comment. Essentially what we've done is embed a brand new group of comments inside of our first comment, and since there's not anything special about that group, we could keep embedding comments inside of comments. The final variation is a minimal approach to comments. This variation will hide the actions of a comment until the user hovers their mouse over the comment. As we see on the screen, all we can see is the name, metadata, and comment. As we move our mouse over the comment, however, the actions appear in the upper right. This can give your comments a cleaner look by removing the extraneous actions. Now that we've seen what can be accomplished with comments, let's apply that knowledge to our site. Let's start by creating a comments group with each of our divs inside the new group. Then add a content div inside of that comment. Now let's replace our h4 elements with an author element. Then let's remove the h5 element that has the label comments underneath each comment, and we'll remove the span and wrap that text inside the comment with a ‘text' div. Now let's take our ratings and place them inside the metadata content. And finally, let's add a Reply action on each of our comments. Now that we've done all that work, let's refresh our page. We can see that that looks more in line with our styles. And since we've styled our comments we've satisfied Chip's desire to improve the comments section, so we can move that card to the Done pile.

Feature Request: Cards
We've made some great progress on our events details page, but we've neglected the rest of our application. Chocolate Chip has been looking at the Google analytics, and she sees that we've got a crazy high bounce rate from our results page where we list all of our events. She wants us to find a way to make our list of events presentable so that, at the very least, people stop bouncing off of our site. Let's take a look at why people might be leaving. As we can see here, there's not much that's appealing on our results page. Sure, we have a list of events that people can look at, and even have some information about the event, but it's a big, ugly mess. To clean up this page, we're going to look at cards and see how they can help us make this page more presentable.

Cards
In Semantic, a card is a view that displays content similar to what you might see on a playing card. There are two types that are very similar to each other. The first is ui card. Here we see an example where we have a picture of a possible avatar. It has a title, or header, as well as some other metadata text and a description. In some ways the content is similar to what we saw a few minutes ago when we were discussing the comments view. A single card might be useful on a user's profile to show their important information. A lot of times, however, we'll want to have several cards together, and to do this we'll use ui cards. Here we see two cards, one with an orange architect and one with a green architect. The cards themselves are identical, apart from the image, of the first card that we just saw. With these cards we've got several pieces of content that we can use to shape how they look. As with comments, there are a few pieces of content that are the same, and these are Content Block, Header, and Metadata. There are, however, several other content types that we can incorporate into our cards. The first one we've already seen in our other examples, and that is an image. What we haven't seen, though, is the use of Reveal. Remember back to the Elements module, a reveal allows us to have visible and hidden content that we alternate between as we hover. If we want to have links from different pieces of data, we can add a link to various elements. Here we've linked our header to the Pluralsight website. When we go to the variations, we'll see a way to make the entire card a link. There are other ways to provide actions to cards besides just using links. The next one we'll look at is providing a button. Here we have our familiar card, but this time we've attached a button to the bottom so that a user could add this icon to their cart. We actually see several concepts at play here. We have our card, of course, and we also have a button content, and now we see the attached variations that we've talked about on other components. Another way to allow users to take actions on cards is to apply the Approval content. Here we see a text card that describes this course. By providing the icons we allow someone to mark the card with a star or a heart to indicate that they like the content. The final piece of content allows us to specify extra information. For this reason, it's called Extra Content. Here we see that it draws a horizontal line below our card and then places the content in the new section. In our case we've supplied some metadata information about the image, but we could have just as easily provided an icon. We could also provide buttons, which we've done in our second example, to allow someone to approve or reject our icon. Now that we've seen the possible content of a card, we can now turn our attention to variations. The first variation we'll look at is Fluid. This will allow the card to take up the entire container. The example we see here has the card inside of a column, and the card takes up the entire column's width. The next variation we'll look at also controls how the card is laid out. In this case we can center the card on the page by placing the centered class on the card. Earlier we talked about putting link content on the card. With the next variation, we can take the entire card and make it a link. Here we've taken one of our earlier cards and changed the parent div to an a tag. Now, if we click anywhere on this card we'll be directed to Pluralsight. com. We've seen the floated variation in the past. You might expect it to float the card, but it doesn't, it floats the content of the card. Here we see our header floated to the right. Similarly, we can adjust the text alignment of the data on our card, for example, the card on the screen has the description content center aligned. As with so many other components, card can be colored, but probably not like you would expect. Instead of coloring the entire card it's much more subtle. On the screen we have a red colored card. Notice that the only red on the card is the shadow at the bottom. The final variations we'll discuss all handle how the cards are laid out on the screen. We also saw these when we looked at grids. We'll look at the first one here to get a better understanding of how it works, and that one is Column Count. Here we specify that we want four cards per row. We then specified eight cards. Semantic took care of grouping them for us. If we were to change that from four cards to six cards, we wouldn't have to regroup any of the cards. As we refreshed, we'd see that our first row now has six cards, and the final one has two. The other two variations that we also saw in grids are Stackable, which will handle stacking the cards as the screen size shrinks, and Doubling, which will double the size of the card as the screen size shrinks. Now that we've talked about the details of the content and variations for cards, let's see how we can use them in our application. To start, let's place a group of cards on the screen, and we'll make it have three columns. Let's add stackable and doubling as well. Next we'll replace our li elements with card divs and place a content div inside each card. Then let's replace the h1 elements with our header divs. Next let's put the ratings in a metadiv, then we'll place our descriptions inside of a description div. Now let's put the final two pieces of data in extra content. When we do that, let's have the two pieces of data floated to the left and right. With all that done, let's refresh and take a look. It looks better, but still looks kind of bland, so let's jump back to our code. How about we start with our ratings. Let's get rid of the /5 and put a yellow star icon in each of them. Then for the data let's add a calendar icon and a map icon for the location data. Let's refresh again. It looks better, but I don't think Chip is going to be quite happy with it. Let's go back one more time and add pictures to our cards. Now that we've added the photos, let's refresh. Now that they have photos they look much better, and when the screen size changes the cards auto-adjust for us. I think Chip is going to be pretty happy with these changes, so let's move that card to the Done pile.

Feeds
The next view that we're going to look at can be seen on several different sites around the internet, and that is a feed. This view will allow you to show recent activity in a sequential format. There's only one type, the Feed, which we see on the screen, and here we see an example of people reviewing the All City Carnival, but it's pretty basic. Feeds only have a few pieces of content. The first one is a label. Note that this is not necessarily a ui label, instead, with feeds a label is an area to the left of the event which allows you to supply additional information. You could put an image for the user's avatar, or you could add a ui label like we have here, or you could even place icons inside of that label area. The next piece of content that you can have on a feed is a date. We see that on each of our feed elements here. It makes the font lighter, and we've placed it to the end of our feed title. The final type of content that we can have is a bit generic. It's simply Additional Information. The fact that it's generic gives you the opportunity to customize it as you see fit. Here we see a couple of different examples. The first one has an ‘extra text' div, in which we show that Janice liked Dan's review. Then we see that Janice also reviewed the carnival, and she has uploaded a couple of images of her experience at the carnival. These are examples of how we can use content to make the feed items different. The only variation that feeds have are Size. Here we've duplicated our last feed, and have varied it by making one small and one large. We can see the difference in size on the screen. While we're not implementing feeds on our application, they are useful for displaying activity that has happened, but they can also be used to display data, such as news stories or articles.

Advertisements
One area of your application or website that is critical to have a consistent view on is if you choose to bring in ads. By having them consistent, you're able to show ad content in a well-defined space without having the ad impact the rest of your layout. The first type is a ui ad. Notice that you place the ad code inside of the ad element. This will allow you to wire up your application to your ad provider, for example, ad sense. For this clip I will be using the test variation that we see here. This will give me the layout of an ad without needing to have an ad service, which I don't have. The second type of ads that we can see are the Common Units. We see in the example of each unit here, Medium Rectangle, Banner, Leaderboard, Large Rectangle, and a Half Page. It might be tempting to think of these as variations instead of types, but remember, types are mutually exclusive, so we couldn't have a half page banner, it has to be one or the other. Next we can see the Mobile ad type. Notice that while our browser is wider than a mobile resolution, we don't see them, however, when we shrink our screen to be on a mobile resolution, they appear. Up next we have our rectangle ads. We can show either a vertical or horizontal rectangle, and we see an example of both of them here. We also have button ad types. We see an example here of a Button, a Square Button, and a Small Button. Next, we also have Skyscraper ads. These will be long vertical ads that resemble a skyscraper. We can have either the standard or wide variation of the ad. If we were to turn our skyscraper sideways, we would have the ever-present banner ad. Here we have Banner, Vertical Banner, Top Banner, Half Banner examples of this ad. Next we have three examples of leaderboard ads. The examples ads are a Leaderboard, Large Leaderboard, and finally, a Billboard ad, which takes up considerable space. We could have our ad use a panorama size as well, which is slightly different than the banner or leaderboard ads, and we see an example here. The final type that we can have is a Netboard ad. This is a larger ad, both vertically and horizontally, than we've seen with the other types. There is just one other variation, other than the test variation that we've been using, for ads, and that is the centered ad. As you'd expect, this allows you to center the ad on your screen. We didn't spend a lot of time on ads, mostly because the differences from one type to the next is almost exclusively size. We won't be placing any ads on our application.

Items
If you display groups with a lot of data, but you don't want to use a card, then an item might be what you need. If the term sounds generic, that's because it is. An item can be just about anything you want it to be. There is only one type of item, and that is an item inside a group of items, and we see an example of that here. We've got two items, both of which display an image and have a sample description off to the right. As with our other views, particularly comments and cards, items also use content to shape how they look and feel. The first type of content is one we see in this example, and that is an image content. Notice that even though the URL specifies that the image should be a 640 x 480, simply by placing it in the images content, Semantic auto-resizes the image for us. The next type of content that you can apply to an item is the rating content. Here we've copied that content from the Cards clip and placed it inside of an item. We have the same like and favorite icons that allow the user to mark the item. In the next module we'll look at the ratings module in more depth. Note here that the fact that we could copy content from one view, the card, to a different view, an item, shows how well Semantic handles components. The content, icons, headers, and all of that, all show up underneath an item in an appropriate way. They're independent of the card that we looked at. In fact, the content is so interchangeable that there are no other pieces of content for items that we haven't already looked at. The common types are Content, Header, Metadata, Link, Description, and Extra Content. There are also a handful of variations for items, but there are no new variations. You can alter items with the following variations, Divided, to draw a horizontal line between items; relaxed, to provide more spacing between the items; Link, to turn an entire item into a link; Vertical Alignment, to align text to the top, middle, or bottom of the item; and finally, Floated Content, to float any of the content inside of an item. As we said at the start of this clip, items are a bit generic, in some ways it's like a card without the defined size, however, it gives you the freedom of how you layout your content, while at the same time utilizing content and variations that are standard in Semantic UI.

Statistics
The final view that we'll look at is a Statistic view. This view can be useful when you want to emphasis a value, even more so than its label. There are two familiar types of statistic. The first is a ‘ui statistic', and we can see that on the screen here. We're showing that our site has 318 unique events reviewed. The other type is also common, and that is a group of statistics, or ‘ui statistics'. For this example we've added another statistic. This time it's the number of users on our site. As we see with both our statistic and statistics type, there are two pieces of content, they are label and value. They perform the expected formatting. There are a handful of variations that we can apply to statistics. The first is Horizontal. Here this places the label and value on the same horizontal line, instead of moving the value underneath the label. The other variations, that we'll look at in a minute, are all familiar to us from other components. Keep in mind that we can provide custom content to our elements, for example, statistics don't have anything specific for icons, there's not an icon type or icon content, but we can add them ourselves. We see an example of that here where we've placed a user icon inside of our label. As we said a minute ago, there are several variations available for statistics that have been covered elsewhere in the course, and these are Colored, Inverted, Evenly Divided, Floated, and Size. Statistics like this can be used inside of an admin section or even on a dashboard screen to highlight the values that you want the user to see.

Conclusion
In this module, we discussed the various views that are available in Semantic UI. What we found was that with views we were able to provide a nice, consistent look and feel to complex pieces of data. We took our comments section and cleaned it up, and even provided some actions so that people could reply to other reviewers. We also tried to reduce our bounce rate by taking our ugly ul elements and adding some style to them in the form of Semantic UI cards. We continue to be reminded of how reusable styles of Semantic are, and how several different pieces of content and variations are almost universal. One thing we saw that really excited me was the ability to reuse _____ full-blown Semantic components. The other thing we learned in this module is one of my favorite things about Semantic, and that is the several ways it handles layout and responsiveness. For example, we were able to specify four cards and let Semantic handle laying those four cards out, even as the screen sizes changed. Or we specified stackable cards on our application, and knew that if someone visited our site on their phone, that they would be presented with a nice-looking application, all without us defining custom breakpoints or writing media queries inside of our CSS. Now that we've wrapped up views, there's only one more type of Semantic component to discuss, and those are modules. In Semantic lingo, modules are components that include both a definition of how they appear and how they behave. In our progression we've seen elements, which did one thing, like divide the content, then we grouped those elements into collections, like forms and menus. In this module, we saw how to present a consistent look, and in the next module we'll bring behaviors into the mix, which means we'll get to control not only how the component looks, but also how it acts. When you're ready, go onto the next module on Semantic UI modules.

Semantic UI Modules
Intro
Up until this point we've been focusing on using Semantic components to impact the look of our application. The focus has been almost exclusively on CSS styles, but an application needs more than just consistent styles. In order to be useful, it needs to have the controls on its screen behave in a consistent way. That's what we're going to focus on in this module. Semantic modules are components that include both a definition of how they appear and how they behave. These include components like accordions, dropdowns, and popups. Modules control both the look and behavior of a component. Modules have some of the same definition as other components, such as types, states, and variations, but they also have behaviors, for example, you can show or hide the component. There are also settings. These have more of an impact on how the component interacts with the user, for example, on a popup you're able to configure what event triggers the popup. The default is hover, but if you wanted to fire that popup on click, you could configure it. If you remember back to the first module of this course, we talked about the mantra of Semantic UI, which is everything arbitrary is mutable. This becomes very powerful as it gives us incredible control over our components. There are 15 different modules, and they are accordion, checkbox, dimmer, dropdown, embed, modal, popup, progress, rating, shape, sidebar, sticky, tab, transition, and search. As with elements, collections, and views, we'll look at each of these modules in their own clip. I'm sure there will be some feature requests that come in from Chip, and we'll use those to upgrade our application. Once we're done with this module, we'll cover all the components of Semantic UI. Let's get started by looking at accordions in the next clip.

Accordions
As we go through various modules, we'll look at the definitional features first. This part of each clip will be familiar as it covers the types, states, content, and variations that modules have. After that we'll look at the behaviors that give modules their functionality. to start, accordions have two types. The first, as with all other components, is the simple ui accordion. We see an example here. It's not much to write home about. It's a title with a dropdown icon and some content to go with each title. The other type of accordion is a styled accordion, and we see that example on the screen now. This probably looks a bit more like what we're used to seeing with accordions. Notice that all we've changed was adding the styled class, the content itself is identical. There are only two variations for accordions, and those are Fluid, to have the accordion fill the space of its container, as well as Inverted to make the accordion have white text on a black background. These are the same as we saw on other Semantic UI components. The accordions we had on the screen before didn't have any accordion behavior, that is we could have clicked on the dropdown arrow a thousand times and it wouldn't have done anything. That's because we hadn't yet initialized the accordion behaviors on our markup. To do that, we need to write some JavaScript. Specifically for our example we're going to grab all the markup that has the classes ui accordion. Once we grab this with jQuery, we're going to tell it to fire the accordion function. In our JavaScript section here we have this running as soon as the page is ready, so now when we click on the accordion elements it expands the one we clicked on, and collapses the other. This paradigm of grabbing the component and enabling its module will be a familiar one that we use throughout the rest of this module as well. Let's now turn our attention to behaviors. To start with, we're going to look at one or two behaviors on accordions, and after that we'll just look at the definitions of what the other behaviors are. The first behavior that we'll look at is the open behavior. This will open an accordion at a specified index. You'll see on the screen that we've added a button, and in our JavaScript we've added a click event handler, so that when our button is clicked it will call the open action on the accordion and specify the index 2. When we click our button, no matter what index is expanded it'll expand the second accordion. There are similar behaviors for close and toggle that will close a specified index or toggle between open and close, respectively. This allows you the ability to programmatically control what part of the accordion is seen. The other two behaviors for accordions are Refresh to refresh the selectors and the data that has been cached on selecting the accordions, and Close Others to close all accordions that aren't active. Another feature of modules that is related to behaviors are settings. Settings have more to do with how the module is configured, independent of user action. The way to use settings is to pass them in as an object when the module is initialized. We'll see an example with our first one, and that is exclusive. By default this setting is true, which means by default you can only have one accordion content open at a time. Setting this to false will make it so that when a user opens an accordion content, the other content that's already open will stay open. We see an example on the screen of how to make an accordion not be exclusive. Other settings specific to accordions are on, this is the name of the event that triggers the opening or closing an accordion. By default it is click, but it can be set to hover, keypress, or whatever event you would like. animateChildren, this determines if the opacity of the child content should be animated. It defaults to true. Close nested, this will close nested content when the element closes, and by default this is true. Collapsible, determine if the sections can be collapsed are not, it's default is true. Duration, set the time in milliseconds for the animation to happen, the default here is 500 ms. Easing, this will configure how the animations will ease in and out, the default is ease in out quint. If you'd like other easing options, you'll need to include the jQuery easing plugin. The settings that we just talked about can be thought of as behavior settings, that is they're configuring how the accordion behaves. There are also a set of callback settings. These are events that will fire at certain times. The available callbacks for accordion are onOpening, onOpen, onClosing, onClose, and onChange. OnOpening will fire when an accordion start to open, onOpen will fire once it's completed opening, onClosing will do the same, but when it's closing, and onClose will only fire once the accordion is closed. And then there's onChange, that regardless of whether it's opening or closing will fire. To capture the callback for when an accordion is open, you would pass in an object like the one shown on the screen. Note that for accordions no parameters are passed in to the function. In addition to these settings, there are a few global settings that we'll look at in the next clip. With these definitions, behaviors, and settings, we can control how our accordion looks on the screen, and how it behaves when our users interact with it.

Global Settings
As we just saw in the Accordion clip, there are settings that can be supplied to modules. In addition to the module's specific settings, there are also global settings that can be applied to any module. These settings define how the module interacts with the DOM. The available settings are name, used in log statements, and it'll default to whatever module you're talking about, for example, accordion; namespace, the event namespace used to make sure when this module is torn down it does not impact other modules; selector, this is an object that is used to find parts of the module, for example, for the accordion you can set the accordion, title, trigger, and content selectors. To do so, you'd pass in an object like the one on the screen; class name, this is an object that sets the class names used by the module, for example, you can configure the active and animating class names on an accordion; debug, when set to true this will log debug information to the browser's console, and it defaults to false; performance, when set to true, which is the default, it'll log out performance metrics using a console table; verbose, when set to true, the debug output will include internal behaviors of the module. By default, this is set to false; and error, this can be used to set error messages for the module. These settings are global through all modules, however, some options might be different from module to module, for example, the class names are different for the accordion and checkbox modules.

Checkboxes
Checkboxes are a very common control in a lot of applications. Often when users are logging into an application, they'll be greeted with a checkbox indicating that the app should remember them in the future. In Semantic, there are four types of checkboxes. The first one, ui checkbox, is the common type. When the checkbox is clicked, it toggles the box selection. The next type is a radio checkbox. This control is typically used to only allow the user to select one option, for example, selecting a primary phone number or payment type. The third type is a slider checkbox, and this behaves like a ui checkbox, but is visually different. Here, when the slider is on the left the value is unchecked, and when it's on the right it's selected. Additionally, when it's selected the label is darkened. This will be particularly helpful when there are multiple sliders it will further indicate which options are selected. The final type is a toggle checkbox. This will show when the option is selected. A checkbox like this is often used in a config section to turn on or off multiple config options. Checkboxes have four states, and the first one is readonly, which prevents it from being selected. The next state is the checked state. By applying this state to the checkbox, it will select the item. The third state is indeterminate, and can be used to indicate an unknown state. This is often seen when using checkboxes as part of a file tree, where the indeterminate state indicates that it's unknown if the boxes below are selected. In order to accomplish this state, JavaScript must be used, and we accomplish this by calling the ‘set indeterminate' behavior. The final state for checkboxes is the Disabled state, which performs the same as other elements when the disabled state is applied. The only variation checkboxes have is the fitted variation. This variation does not have a space for a label, and in fact the best way to display a fitted checkbox is inside of a segment, which we see on the screen. Checkboxes have several more behaviors than accordions did, specifically they have toggle, which sets the checkbox to the opposite of its current state; check, which will make a checkbox checked; uncheck, which will make it unchecked; indeterminate, which will set the checkbox as an indeterminate checkbox; or determinate, which will set the checkbox as being able to be determinate; enable will allow the users to interact with the checkbox; set checked, this will set the state of the checkbox to checked, but it does not call the callbacks; set unchecked will set the state to unchecked without calling any callbacks; set indeterminate will set the indeterminate state without callbacks; and set determinate will set the determinate state without callbacks. Similarly, the set enabled and set disabled will either enable or disable user interaction, again, without calling callbacks. The attach events behavior allows you to attach checkbox events to another element. You do this by specifying the selector of the other element and the behavior that you would like to attach. Is radio will return if the checkbox is a radio button. Similarly, is checked and is unchecked will return true if the checkbox is in that state. There is a can change behavior, which will return true if the checkbox ca be changed by the user, and there is a should allow check, which returns true if the checkbox can be checked. Similarly, there is should allow uncheck, should allow determinate, and should allow indeterminate. All of these will return true if the checkbox can accept the state that is being asked for. And finally, there is a can uncheck, and this returns true if a checkbox can be unchecked. So these are a list of behaviors that we have at our disposal when we're interacting with checkboxes. In addition to the behaviors, there are two settings that are available for checkboxes. The first is uncheckable. If you set this value to true, it'll allow a box to not be selected. If you set it to auto, it'll prevent a radio button from being unchecked. The other setting is the fireOnInit, and this setting determines whether the check and uncheck callbacks should be fired during the initialization phase, and it defaults to true. As we saw with accordions, there are also a handful of callbacks available to checkboxes. The first is onChange, and this is fired when a box is either checked or unchecked. Then of course there's onchecked, onIndeterminate, onDeterminate, and onUnchecked, and these fire when the checkbox state is set to checked, indeterminate, determinate, or unchecked. Similarly, we have the beforeChecked, beforeIndeterminate, beforeDeterminate, and beforeUnchecked. These are fired when the checkbox is making a transition into that state. If we return false, we will cancel out of this action. And the final two callbacks are the onEnable and onDisable, and these are fired when a checkbox is either enabled or disabled.

Dimmers
In Semantic, a dimmer allows you to deprioritize background content to allow you to emphasize specific content. For example, when uploading a file, you might want to dim the upload image to show that it was successfully uploaded. There are three types of dimmers in Semantic. The first type is simply a dimmer, we see an example here. We have a segment, and a button, that when clicked will find our segment element and call the dimmer class on it. As we can see, it only covers the segment. The next type of dimmer allows us to supply content for our dimmer. Our setup is similar, we have a segment, but this time we have placed a dimmer inside of our segment, and inside that dimmer we've placed some content. Now when we click on our dim button we tell it to show the ui dimmer, and we can see that it gives us a success message telling us that the data has been updated. The final type of dimmer will cover the entire page, and it's appropriately called a page dimmer. For this type we don't have to place the dimmer inside of a segment, instead we create a div with the class ‘ui page dimmer'. Our button grabs that div and calls the dimmer function on it. We see our content displayed. There are only two states for our dimmers, and those are active and disabled, and they behave pretty much like you would expect. We have two variations for dimmers, and the first is a blurring dimmer. For this example, we placed the blurring class on our segment and then clicked the button. We can see that it blurs the content as it dims, however, it's not the easiest thing to see. To get a better glimpse of what's going on, let's look at the other variation, the inverted variation. We see when we click the button this time that it blurs the content the same as before, but since the dimmer is inverted it doesn't blacken the entire segment, instead it lets you see the blurred content easier. There are quite a few behaviors available to use for dimmers. The first is the add content behavior. This detaches a given element from the DOM and reattaches the element inside the dimmer. To do this, you would specify the element you want to add to your dimmer. Then there's the show, hide, and toggle behaviors, which will show, hide, or toggle the state of the dimmer. Next is the set opacity behavior, which changes how dim the dimmer becomes. Then there's the create, which will create a new dimmer. There is the get duration, which returns the current duration for showing or hiding an event, depending on the current visibility. There is the get dimmer, which returns the DOM element for your dimmer, and there's has dimmer, which returns whether the current dimmable has a dimmer or not. Then there's a whole bunch of basically Boolean behaviors such as is active, is animating, is dimmer, is dimmable, is disabled, is enabled, is page, and is page dimmer. The difference between is page and is page dimmer is that is page will return whether the dimmable section is the body tag, and is page dimmer will return whether the dimmer is a page type. So if you don't have the dimmer on the body tag, is page will return false, even if you have it set up as a page type dimmer. Finally, there are several set behaviors that we have such as set active, set dimmable, set dimmed, set page dimmer, and set disabled. Each of these will set the dimmer to that status. For example, set dimmed dims the entire section that you're setting it on. As with checkboxes, there are fewer settings than there are behaviors for dimmers. The settings that we have are opacity, and this goes from 0 to 1, and it defaults to auto, which will use tour CSS-specified opacity. Variation, which defaults to false, will specify a variation to add when generating a dimmer, like inverted. The dimmerName, which also defaults to false, and this can be used if you're initializing a dimmer on a dimmable context you can provide a dimmerName to distinguish it between multiple dimmers in that context. Closable, this determines whether clicking on the dimmer should hid the dimmer. It defaults to auto, which is closable only when the settings. on is not hover. So if you've got a dimmer that is triggered on a click, and your closable is set to auto, then when you click on the dimmer again it'll disappear. On, and this can be set to either the hover or click to determine when the dimmer should be shown. useCSS, which defaults to true, this determines whether we dim dimmers by CSS transitions. There's a duration object that you can pass in with properties of show and hide, and those both default to 500 milliseconds. This is the animation duration of the dimming. And the final setting is transition. This is a named transition used when animating the dimmer in and out. Fade and slide-down are available without including any kind of ui transitions. There's three callbacks available on dimmers, and those are onShow, onHide, and onChange.

Feature Request: Dropdown
We've got our first feature request for this module. As we pull up Trello, we can see that Chip has added a card to our backlog. The title is simply, Don't let state selection be free form. As we expand the card, we see that Chip is talking about our settings page for our user. The reason it's important not to allow freeform entry is that this application will take a user's location and use it to find nearby events, which means that the difference between NE, Nebraska, nebr, and different variations will alter what the user gets. This is a screen we haven't seen before, so let's take a look at what it looks like now. As we see, we have four very basic fields in our form, First Name, Last Name, City, and State, and they're all just plain input boxes. In order to get better data from our users, we're going to need to convert our state input box to a dropdown, and we'll look at dropdowns in the next clip.

Dropdowns
As with checkboxes, dropdowns are controls that are very familiar to us. It is rare to see an application, particularly a business application, without at least some form of a dropdown box. Dropdowns are also excellent examples of Semantic UI modules. They define the look and feel of how a list is displayed, as well as the behavior of how the items can be selected. There are quite a lot of types of dropdowns in Semantic. We see an example of the plain ‘ui dropdown' on the screen. It lists several different languages. Let's also look at the syntax there. We have a div that displays the currently selected text, we also have a dropdown icon, as well as a menu. Inside the menu are several items. Each item is an option in the dropdown. This will be true regardless of the type of dropdown. The next type is a selection dropdown. With this type we see a border around the dropdown box. Additionally, when we click on the control and type a letter, in this case J, it jumps to the first option that starts with that letter. Notice, however, that the only difference between this markup and the other dropdown is the class selection. A similar type is the Search Selection dropdown. This time, when we type J, not only does it highlight Java, but it filters out all the items that don't have a J in their name, and at this point we're still just using the basic JavaScript code that enables the dropdown on our control. That is, there's no custom JavaScript that we have had to write to enable the search functionality. The next type is also a selection type, in fact it is the Multiple Selection type. Now when we expand our dropdown we can click on multiple items. As we do, the selected items are placed in the box with an x that lets us remove them. As with search, we needed no custom JavaScript, simply the multiple class on the dropdown. We can combine the last two types into another type, the Multiple Search Selection. We see an example here on the screen. It combines the functionality of both the dropdowns. We've looked at various types of selection dropdowns, but we also have a search type. This is the dropdown that adds the search class, but not the selection class. As a result, it looks like our first dropdown without its border, yet as we type we can see it filtering our choices. We can make our searching a bit more explicit when we use the Search-In Dropdown. This is different than a Search Selection dropdown. To start, notice that the classes that define the dropdown are, once again, ‘ui dropdown', but now there's a search box inside of our menu. When we expand, we can see that it has a search box inside, and when we type inside it behaves the same as our search selection. Another type that we have at our disposal is the inline type. This allows you to place a dropdown on the same line as your text. As we see here, we can place it so that a user could complete a sentence with a dropdown. The next type that we have is a Pointing Dropdown. This is especially useful when you're placing a dropdown inside of a menu, however, it doesn't need to be used solely for that. We see here that when we expand our options, that there is an arrow pointing to the dropdown above. You can also move that arrow. Your options for a combination are top and bottom and left and right. When not specified, it defaults to top middle. The next to last type is the floating dropdown. This has the menu items disconnected from the combo box. To see this better, I have displayed our dropdown as a button, and when we click on the dropdown our items are floating, as if they are independent of our button. The final type is a Simple Dropdown. From looking at it, it doesn't appear any different than our dropdown, but the simple class allows it to operate without needing any JavaScript. Now that we've seen all the types of dropdowns, we need to talk about the content. There are almost as many pieces of content available to us as there are types. The first piece of content that we can use is a header. For our content we're going to reuse our selection dropdown. We've added a header div inside our menu. When we expand our dropdown, we can see the language is bolded, and is unable to be selected. This is our header. We can expand on our previous example by placing a divider after our label to give it more of a _____ standoff look. Now our languages label stands out even more. And we can make our header pop even more by adding an icon, which we've done here. The last two examples have focused on our header, but keep in mind that we could apply them to any part of our dropdown, including our items. They aren't limited just to the header. If we wanted to provide some more detail about our menu items, we can add some description items for our content. Here we've added what could be counts of the number of repos using the specific language. Notice it is gray and pulled over to the right. It's accomplished by placing the text inside of a span with the class description. We might want to provide more emphasis on each of our individual items. We could do this by applying labels to them. Here we supplied some labels to provide more information about the item. This was accomplished by placing a label item inside of the item. We can also use messages inside of our dropdown. In our example, we're displaying a message that states we were unable to connect to our service to get the necessary data. Notice that we have provided a ui message, just as we saw on the collections module inside of our menu. We can also float our content. In our example, we make our dropdown a fluid selection dropdown to have it take up our full space. We then add a floated icon to our items and have the data pulled over to the right. Finally, we can place an image beside our items. Here I've used the same image and formatted it by placing the avatar class on it. There are four states of dropdowns, but they're pretty standard and we've seen them elsewhere. They are Loading, Error, Active, and Disabled. There are a couple of variations that we haven't seen yet. The first is the scrolling variation, and this will allow the menu to scroll. In our example we've added a lot more languages, and now when we expand the menu we can scroll inside of our menu. The other variation is the menu direction. You can specify a left or right submenu. Notice this time that we have switched to platforms. On the top, opening to the left, we have the CLR with C# and VB underneath it. On the bottom menu, opening to the right, we have the JVM with Grails and Scala. Now that we've talked about the definitions of dropdowns, let's look at the behaviors for them. To start, we're going to look at our config options for determining what happens when something is selected. The default action when an item is selected is the activate. This will select the current item, adjust the dropdown value, and change the dropdown text. The next action is combo. This behaves the same as activate, but instead of updating itself it updates the previous element's text. Then there's select, which selects the current item from the menu and stores the value, but doesn't change the dropdown text. There's hide, which hides the dropdown menu and stores the value, but again, doesn't change the text. Then you can provide your own custom action by using a function that receives the text supllied and the value selected. Or you can have it do nothing by specifying the nothing action. All of these can be configured by specifying the action config property when the dropdown is initialized. As with the other modules, there's quite a few behaviors for dropdowns. The first one is setup menu. This recreates the dropdown menu from the select options value. There's also the refresh behavior, which will refresh all the selectors and the data for the dropdown menu. Then we have toggle, show, and hide, which will toggle, show or hide the dropdown list. We also have the clear behavior, which will clear the dropdown of any selection. We can hide all the other dropdowns that are not the current dropdown by specifying the hide others behavior. We can restore what our dropdown was when we loaded the page by specifying restore defaults. If we want to just restore the default text, we can do that by specifying restore default text. Similarly, we can restore default value, and that will restore the dropdown's value to what it was when the page loaded. If we want to update the default values on a dropdown, we can call save defaults, and that'll save the current text and value as the new default. We can select a specific value by calling the set selected and passing in the value. If we want to add multiple items to our selection, we can call set selected and pass in an array of values. If, however, we want to set exactly that list and remove anything that's not in our list, we would call set exactly and pass in an array. Again, any item not in that array that is currently selected would be unselected. If we want to set the text of the dropdown, we can do that by specifying set text with the text passed in. If we want to set the value of the dropdown, we can do that by calling the set value, however, this will not update the display state, so it's only going to set the current value of the dropdown, it won't update your UI. We can also perform several gets, such as get text and get value or get item, and if we pass in the value to get item it will return the DOM element that matches the given input value. If we want to make sure that our dropdown can handle touch events, we can use the bind touch events behavior, and we can also do similar things with the bind mouse events. By calling bind intent, we are binding a click to the document to determine if you click away from a dropdown. And similarly, we can unbind that by doing an unbind intent, and we can check the state of that by calling determine intent, and that will return whether an event occurred inside the dropdown or not. Next up we have a couple set actions, for example, we can set whether the dropdown is active by using set active, or we can set that it's visible by using set visible. We can also remove these with the remove active and remove visible behavior respectively. Then we have several Booleans, as we've seen on other modules. We have the is selection, is animated, is visible, and is hidden behaviors that we can get information about the dropdown from. Finally, we can perform the get default text and get placeholder text to get those values that are set on the dropdown. Dropdowns have lots of settings as well, and we're going to start with the most common ones. The first setting is on, and its default is to click. This will be the event that you want to cause the dropdown list to open. Next is the allowAdditions setting. This is defaulted to false, but when set to true it'll allow the user to add new items to the dropdown when they're searching for them. As we saw earlier, we can set the action setting by specifying what actions are allowed on the dropdown. We can also configure how searching is matched. By default, the match value is set to both, which will match against either the text or the value, but if we wanted to we could specify only value or only text, and have our matching check only those items. There is a forceSelection setting, which is defaulted to true, and when this is true it says that when the dropdown is blurred the currently selected item will be selected. There is an allowCategorySelection which defaults to false, but when it is true it will allow the user to select the categories. And the final common setting is the placeholder setting. This defaults to auto, which means that if you provide an option with blank string for the value, then the text there will be used as the placeholder text. If you set the value of placeholder to a value, then it sets the string value to the placeholder text, and if you set it to false it'll leave an empty string value as a selectable option. There are also multi-select settings, used for when your dropdown is a multi-select. The first one is useLabels, and this defaults to true. This tells whether the multi-select should use labels. There is maxSelections, which is set to false, but when it's set to a number, that's the maximum number of selections that that dropdown will allow. There's the glyphWidth, which is the maximum width used to calculate search size. And finally, there's a label setting, and this allows customization of multi-select labels, you can specify transitions, durations, and variations. The final group of settings we're just going to call general settings. These are settings available to us to use on our dropdown, but aren't necessarily common. The first setting is direction. It defaults to auto, and this allows Semantic to determine whether the dropdown pops down or up, based on where it can fit on the screen. The next setting is keepOnScreen. This defaults to true, which tells Semantic to try to keep the element on the screen when it's being expanded, as opposed to expanding off the screen. The next setting is context, and it defaults to window. This is the context that Semantic uses when trying to determine if it can keep the component on the screen. The next is fullTextSearch. It defaults to false, but when it's set to true it'll allow the users searching to happen anywhere in the item's string, as opposed to just in the beginning. The next setting is preserveHtml. When set to true, it'll keep the HTML that's specified for an item. The next setting is the sortSelect setting. This defaults to false, but when it's set to true it will sort the values when creating a dropdown automatically from a select element. The next setting, showOnFocus defaults to true. This will show the menu item when the dropdown becomes focused. The next setting is allowTab, and it defaults to true as well. This allows the element to be navigated by the keyboard by creating a tab index on it. Another setting that's available to us is the transition. It defaults to auto, which is slide down/slide up, but we have the ability to alter that transition by using ui transitions. Then we have duration, which will set the animation duration on the component. You can also configure the key codes used to represent various keys in the dropdown navigation, for example, you can configure enter to be something besides the default enter key. And finally, there's the delay, which has an object that contains hide, show, search, and touch, and these are times in milliseconds to debounce the show or hide behavior when the onHover is used or when a touch is used. Finally, we have an entire list of callbacks that we can utilize in our dropdowns as well. The first is onChange. Then there's onAdd or onRemove, and these are called when the items in the dropdown list are changing. We have an onLabelCreate and onLabelRemove, and onLabelSelect, as well as onNoResults, onShow, and onHide. Now that we've covered all the types and configs of the dropdown module, let's go to our page and add the state dropdown. To do this, we'll replace our input box with a ‘ui selection dropdown'. Then we'll place each state as an item underneath it. I'll just paste the code in so that you don't have to watch me type it all out. Next we'll add a script tag at the bottom of our page and place a call to enable the dropdown. We refresh the application, and verify that the state is no longer free text. We've met Chip's request, so we can move that card to the Done pile.

Embeds
Sometimes on your application you'll want to embed other content in your application. This can be something like a how-to video that is hosted on YouTube, or even directions to your office hosted on Google Maps. Semantic accomplishes this with the Embed module. There are three types of embeds. The first is a Youtube embed. We can see on our element the first use of a data element. In this case it's data source, and the value is Youtube. This tells Semantic that it will take our data id and fetch it from YouTube, as opposed to some other service. The data id is the final part of the YouTube URL. When we click on the video, we see that it starts playing for us and gives us all of the video controls that we would expect on a YouTube video. The next type of embed is similar, it's the Vimeo embed. The structure is the same, but they are two separate embed types. Here, when we click on play button, a time-lapse video of the milky way starts to play. The third type available for embed is a custom embed. Once again, we have a ‘ui embed' class. This time, however, we specify a data url instead of a data source. For this example, there's a URL pasted in for an embeddable Google map. Once it's clicked in, it can be interacted with the same as if the user was on Google Maps. As we saw in the last module, Semantic handles responsiveness for us quite often. This is the case with embed as well. We can shrink our screen, and the size of the embeds we looked at all resize appropriately for us. There's only one variation for embed, and that is the aspect ratio. To accomplish this, we place the ratio as one of our classes. We see that here where we've specified that our Rick Astley video should be a 4:3 video. While only two sources have been specified out-of-the-box, it is possible to define new sources as well. Remember, every arbitrary setting is configurable. The code on the screen shows how YouTube and Vimeo are set up. To add a custom source, just extend this setting. This tells Semantic where to pull the content from, as well as settings, such as the icon to overlay the embed with. There are several behaviors available to us for embed. The first is change. For this behavior you pass in a source, id, and url, and it changes the iFrame to the new source. Then there's the reset behavior, which removes embed and shows placeholder content if it's available. Then there's the show and hide, which will either show or hide the embedded content. We have several get functions, such as get id, get placeholder, get sources, get type, and get url. Then there's the has placeholder, which returns whether or not the embedded content has placeholder information. And finally, there's a destroy behavior, which will destroy that instance and remove all the events of that embed. Additionally, there are settings that can be configured specifically for the embedded content. These settings are the icon, which specifies the icon to use with the placeholder content. Then there's source, which specifies a source to use. If no source is specified, it'll determine what the source is from the domain of the specified URL, which is the next setting, url, and that then specifies the url for the embedded content. Then there's id, which specifies an id to value to replace with the parameterized id value found in the templated URLs. And finally, parameters. These specify an object containing key value pairs to add to the iFrames get parameters. All of these default to false or not supplied. There are also five settings that are available for specifically video embeds. These are autoplay, which defaults to auto, and that means it'll autoplay content when a placeholder is specified. Setting to true or false will force the autoplay. Then there's color, which specifies a default chrome color for the Vimeo or YouTube videos; url, which specifies the URL to embed; hd, which is defaulted to true and it determine whether or not it should try to stream hd content; and then brandedUI, which is defaulted to false, but when set to true shows the networks brandedUI, like title cards or after video calls to action. Finally, we see the available callbacks. The first one is onCreate, then there's onDisplay, onPlaceholderDisplay, and onEmbed. This one will be called back when the module parameters are determined, and it allows you to adjust parameters at runtime by returning a new parameters object.

Modals
Oftentimes in an application it will be important to stop a user from performing any action until they handle a specific situation. For example, you might want to force a user to confirm that they do want to delete a record. One of the simpler ways of accomplishing this is to use a modal. In Semantic UI, there are two types of modal. The first is a ‘ui modal'. The example on the screen has some familiar concepts. Even if we haven't necessarily seen all the content before, it should no longer be surprising. For example, we have our header, which is the title of our modal. We also have an action section that has our yes and no options. Also note that the background of our page is grayed out while our modal is shown. This indicates to the user that they are unable to take any other actions until they address the modal that's in front of them. The second type of modal is a basic modal. This time the modal will not have a dialog, but will instead create a modal that covers the entire page. For our example, I simply copied our first modal and gave it the extra class of basic. When we click on the button, this time it covers the entire page. As we saw with each of our examples, modals can have content. We demonstrated three of the four types of content already. The only one we haven't seen is image content, which provides a picture on the modal. The entire list of content is Header, Content, Image Content, and Actions. There are two variations available to us on modals. They both revolve around size. The first is full screen. Applying this to a modal will have the modal still be a dialog, but will now take up the entire width of the page. The other variation that we have is a size variation. A modal can be specified as either small or large. Again, this has to do with how wide the modal is. There is only one state for a modal, and that is the active state. When a modal is active, the modal will be displayed. There are 12 behaviors that modals can have. As we might expect, there is show, hide, and toggle. Then there's a refresh, which will refresh and center the modal on the page. There is the show dimmer and hide dimmer, which either shows or hides the associated page dimmer with the modal. There is hide others, which hides all the modals that aren't currently selected. There's hide all, which hides all visible modals. There's the cache sizes, which caches the current modal size, a can fit behavior, which returns whether the modal can fit on that page, and then there's the is active which returns true if the modal is active, and a set active, which will force the modal to be active. Additionally, there are several modal settings. The first is detachable, and it's set to true. When it's set to false, it prevents the modal from being moved inside of our dimmer space. There's autofocus, which is also defaulted to true, and when that is set to true the first form input inside the modal will receive focus when the modal is shown. There is the observeChanges setting, which is defaulted to false, and it checks whether any change in the modal DOM should automatically refresh cached positions. There is allowMultiple, which defaults to false, and if this is set to true it won't close other visible modals when opening a new one. There's offset, which is defaulted to 0, and it's a vertical offset to allow for content outside of a modal, for example, a close button, to be centered. There's context, and the default there is body, and that's the selector or jQuery object specifying the area to dim when the modal is shown. The closable setting is defaulted to true, and when it's set to false it won't allow you to close the modal by clicking on the dimmer behind it. There is dimmerSettings, which has an object including the closable and _____ useCss properties, and you can specify custom settings for extending the dimmer. There is a transition setting which defaults to scale, and as we've seen on other modules, these are name transitions to use when animating the modal in and out. There is duration, which is in milliseconds, and it's defaulted to 400 ms, and that's the duration of the animation when showing the modal. And finally, there's the queue setting which is defaulted to false. This determines whether additional animations should get in a queue for the modal. Finally, there is some callbacks available for the modal as well. These are onShow, onVisible, onHide, onHidden, and then there's an onApprove, which will fire when the Approved button is clicked, and the onDeny, which will fire when the Deny button is clicked.

Popups
In the last module when we were looking at menus, we saw an example of a popup menu. It utilized the popup module, and since we hadn't yet covered modules we didn't discuss it much, but now is a good time to go into more detail. There are four types of popups in Semantic. The first type is a content popup. We see an example on the screen, and it probably looks a bit off since there is not a popup element anywhere on the screen. Instead, we've called the popup function on the icon class. By default, this means that when the user hovers over the icon the popup will display. Since it's a content type, it will use the data content text as the text for the popup. The second type of popup is a title popup. This is very similar to the content type. We again specify the content with a data tag, and this time we also specify the title using the data title element. Once again, when we hover we see the popup. It's also possible to use HTML for a popup, which is exactly what the next type does. In the data html attribute we specify a list of options that someone could possibly perform on an item. When we hover, we now see a bulleted list as the popup. The final type of popup allows us to specify a sibling element as a popup, and have it displayed by default. The example we see on the screen has our standard button, but this time it doesn't contain any data attributes. Instead, we have a ‘ui popup' element as a sibling to our button. Inside of our popup we have a large image. Now when we hover the button it displays the image. No custom JavaScript was needed for that. It used the same icon popup event that other examples used. There's a handful of variations that we can apply to our popup, however, only two haven't been used on other elements, and we'll start by looking at those. The first is Width. As with other aspects of our popup, we can specify this with a data attribute. Here we have two plus icons. One has the data variation of wide and one has the data variation of very wide. The text is longer this time, and we see that the first popup takes up more lines than the second popup. The other variation that we have not seen before is the flowing variation. The example we have on the screen is the same text as before, but because we specified flowing for the popup, the popup doesn't wrap at all, but instead flows to be as wide as it needs to. The other variations that have already been covered in this course, but can be applied to our popups are Basic, Fluid, Size, and Inverted. There are several behaviors available to us on popups. There is the show and hide popups; there's hide all which hides all visible popups on the entire page; there's get popup, which returns the current popup DOM element; there's change content, where you specify some HTML and it changes the current popup's content; there's toggle to toggle the visibility of a popup; and then there's checks, such as is visible or is hidden. There is an exists behavior, which returns whether a popup is created and inserted into the page; a reposition behavior, which adjusts popup when the content size changes; there's the set position where you specify a position and this will position the popup; then there is the destroy behavior, which removes a popup from the page and removes all the events associated with that popup; and there is a remove popup, which removes the popup from the page. There's also quite a few settings available to us for popups. The first one is popup, and this can specify a DOM element that should be used as the popup. This is useful for including pre-formatted popups. There is exclusive, which can set whether or not popups should be hidden when a particular popup is opened. There is the movePopup, which is defaulted to true and it determines whether to move the popup to the same offset container as the target element when the popup already exists on the page. There is the context, which is defaulted to body, and that's the selector or jQuery object specifying where the popup should be created. There is jitter, which defaults to 2, and it's the number of pixels that a popup is allowed to appear outside the boundaries of its content, and this allows for permissible rounding errors when an element is against the edge of its context. There's position, which defaults to top left, and that's the position that the popup should appear. There's inline, which defaults to false, but if a popup is set to inline it'll be created next to the current element, allowing for local CSS rules to apply. There's preserve, which defaults to false, and this determines whether the popup content should be preserved in the page after being hidden, allowing it to reappear slightly faster on subsequent loads. There is the prefer setting, which is defaulted to adjacent, and it can be either adjacent or opposite, and this determines where the popup should prefer to be displayed when it can't fit on the screen. There is lastResort, which is set to false, and when it is set to false a popup will not appear and produce an error message if it can't entirely fit on the page. When you set it to a position, such as right center, it forces the popup to use this position as a last resort, even if it is partially off the page, and setting this to true will use the last attempted position. There's the on setting, which defaults to hover, but could be easily configured to click or some other event. There's the delay setting, which has a delay object of show and hide, and it's the delay in milliseconds before showing or hiding a popup on the hover or focus. The transition setting is set to slide down, and as we saw with other modules, it is a name transition to use when animating the popup. There's the duration in milliseconds, defaulted to 200 for how long it should take to animate the popup. There is the setFluidWidth, which is defaulted to true, and it determines whether the popup should set the fluid popup variation with _____ onLoad to avoid the width 100%. There is hoverable, which is defaulted to false, and it's whether or not the popup should close on hover. There's closable, which defaults to true, and when using the click event on the on, it specifies whether clicking the page should close the popup. The addTouchEvents setting is defaulted to true, and when using the hover event to show the popup, it allows touchstart events to trigger the popup. There is hideOnScroll, which defaults to auto, and determines whether the popup should hide on scroll on touchmove. Auto only hides for popups that don't use the click event to show. There is the target setting, which is defaulted to false. This is if a selector or jQuery object is specified, it allows the popup to be positioned relative to that element. There is the distanceAway setting, which defaults to 0, and it's the offset for distance of the popup from the element. There's also the offset setting, which defaults to 0, and it's the offset in the number of pixels from the calculated position. And there's maxSearchDepth, which is defaulted to 10, and it's the number of iterations before giving up searching for a popup position when a popup can't fit on the screen. As opposed to specifying content using data attributes, like we saw at the beginning of this clip, it's possible to specify it via content settings. These are variation, which is the popup variation to use, and it can use multiple variations with a space delimiter, there's the content to display, there's the title to display, and there's the html, which would be the html of the popup. And of course there are callbacks available for the popups as well. There's onCreate, onRemove, onShow, onVisible, onHide, onHidden, and onUnplaceable. This last one will be called if a popup cannot be placed on the screen.

Progress
The next module available to us in Semantic UI is a progress bar. There are two type of progress bars available to us. The first is a standard ui progress, and we can see that our progress is 43%. How is that calculated? We actually have two choices. We can either specify percent when we initialize our progress bar in our JavaScript, or we can use the attribute data-percent and specify the number there. The next type of progress bar will provide more indication of the status of the progress. For that reason, it's called an indicating progress bar. Here are four progress bars, and they have used the data attribute to specify their status. As we can see on the screen, 25% is red, and it transforms the color until it gets to green at 100%. There are three pieces of content with the progress bar, and we see each of them in our current example. The first piece is the bar itself. Next is the ‘progress' content. If we were to not specify that, then we would not see our percentage inside the progress bar. The final piece is the label. On our first progress bar we didn't supply a label, but here we specified that we are uploading images. As with other components, progress bars have several states that we can apply. They have the standard active and disabled states that perform as expected, but they also have three other states, Success, Warning, and Error. These three states are used in our indicating progress bars. Success is green, warning is _____ yellow, and error is red. All the variations for progress bars are ones we have seen elsewhere in the course. They are Inverted, Attached, Size, Color, and Inverted Color. Unlike other modules, progress bars do not have specific behaviors, however, there are still settings that we can alter. The first setting is autoSuccess. It defaults to true, and it determines whether the success state should automatically trigger when the progress is complete. The next is showActivity, which also defaults to true, and this determines whether progress should automatically show activity when it's incremented. There is the limitValues, which is also defaulted to true, and when it's set to true, values that calculate to above 100% or below 0% will be adjusted. When set to a false, inappropriate values will produce an error. There is the label setting, which defaults to percent, and it can be set to either display progress as percent or ratio, and it matches up to the corresponding text template with the same name. When we're incrementing without a value, we can set the range for random increment values using the random setting. This takes a class name object where you specify the active, error, success, warning classes. There's the precision setting, which has a default value of 1, and this is the decimal point precision for calculated progress. There's a total setting that when set, each call to increment the progress gets closer to this total, for example, one-tenth, two-tenths, three-tenths, etc. There is the value setting that sets the current value when the total is specified. This is used to calculate the ratio of the total. With percent, this would be the overall percent. Additionally, it's possible through DOM settings to alter the label underneath a progress bar. This is accomplished with the text setting, as you see here on the screen. We see an example of the templating that can be accompanied on the ratio text. Similar templating can be used for each of the text settings. As with other modules, there are a few callbacks available to us as well. There's the onChange, onSuccess, onActive, onError, and onWarning callbacks.

Feature Request: Ratings
We've got our second feature request. This time Chip has gone all the way back to our first page. She notices that for ratings on that page we just have our users specify a number, but our users are familiar with other applications that allow you to give ratings. Her comment states, we let people give ratings, but we only let them give us a number. I think it would be better if we let them give us stars like Netflix and Amazon do. Here we see that chip has moved a bit out of just how something looks and gotten more into the experience of the site. Of other sites that do ratings, none of the notable ones do it by just providing a number. Instead, they have the user give a number of stars, or something similar. Now that we're looking at modules, we can tackle that pretty easily with the ratings module, and we'll look at that in the next clip.

Ratings
As we talked in our last clip, the ratings module is useful for when we want our users to provide us feedback. We'll start with the basic ‘ui rating', and we can see it here, and so far there's not much to it. We have an attribute, data-max-rating, which tells us how many stars the best rating can be. Notice that the default rating has a black star filled in. The next type, star, alters that. It now provides yellow star icons as the rating. We can also use a third type, which is the heart rating, There's no states or content for ratings, and the only variations are size. Since we've seen size so often, we won't look at them now. As we've seen with our other modules, we can either use data attributes, such as data-max-rating, or data-rating, or we can use behaviors. We have the following behaviors available to us: set rating, with the rating specified, we'll set our rating programmatically, get rating will return the current rating, disable and enable will either disable or enable the ratings module, and clear rating clears out the current rating, as if it was never supplied. In contrast to other modules, ratings don't have many settings. We have the following three to play with: initialRating, which defaults to 0, and it's the number representing the default rating to apply; clearable, which is set to auto, and by default the rating will only be clearable if there is one icon, setting to true or false will allow or disallow a user to clear their rating; and interactive, which defaults to true, and this sets whether or not a user is able to perform a rating. And there's only one callback, and that is the onRate, which receives a value, and it is called after a user selects a new rating. So now let's revisit our event page and provide a ratings module for our users. Currently we've placed the rating in a metadata element. The first thing we want to do is replace that class with the classes ‘ui star rating'. Then we'll add an attribute for our rating on each element. So for Dan Green we'll provide a data-rating of ‘5'. Then we'll go into our script section and we'll initialize our ratings with a max rating of 5. This makes sure that all of our ratings have the max value of 5, without needing to set an attribute on each block. Now that we've updated our ratings, we'll refresh the page and see that our ratings look pretty good, however, one thing to note is we can update any of the ratings we want, and that's not something we should allow. A user should only be able to update their rating. We'll go back to the script and set the interactive value to false. Now we refresh, and when we hover over the ratings nothing happens, which is good, because now users can't change each other's ratings. Since we've updated our ratings, the page looks much better, and we can move that card over to the Done pile. And with that, I'm pretty sure Chip is going to be done with this page.

Shapes
In Semantic, a shape is a 3D object that we can display in 2D space. What does that mean? It means that we can define multiple sides of our object and rotate between them on the screen. in Semantic there's three types of shapes, and as we so often do we'll start with ‘ui shape'. The code on the screen starts with a shape and then contains a group of sides. In our case we've placed three pictures on our shape, and we've added a button to transition between the states. We're using the ‘flip up' behavior, and we'll see more behaviors later in the clip. The second type of shape is a cube. This is formatted so that each side specified is a face of the cube. For our cube we placed several different languages as our sides. This time, instead of doing a ‘flip up', we're using the flip left' behavior. Now when we click our button it will turn our cube to the left, revealing the next side. The final type is a text shape. This allows us to place text on a shape without needing a cube as a background. We've copied the text from our cube and made it a little bit bolder by placing it in an h3 element. Now, when we click our button the text shape rotates to show us the next block of text. There are no states, variations or pieces of content for shapes, but we can still configure shapes. Here is a list of behaviors available to us. We have the flip up, flip down, flip right, flip left, flip flip over, and flip back transitions. We saw the flip up and flip left in our demo. Next is the set next side with a selector, and it sets the next side to a specific selector. Regardless of where you're at in the order of sides, if you use this, you can say skip the next one and go to side 4 instead, for example. There's the is animating flag, which will return true if the shape is currently animating. There's the reset behavior to remove all inline styles. You can queue up animations by calling queue and passing in an animation with it. You can force the shape to repaint by calling the repaint behavior. You can set the default side of the shape. You can set the size of the next side by calling set stage size. You can refresh the entire object, and you can get a list of transforms, for example, there's get transform down, get transform left, get transform right, and get transform up. There's only one setting, and that is duration. It defaults to 700 milliseconds, and it specifies the duration of the animation when changing sides. Finally, there are two callbacks for shapes, and the first one is the beforeChange, and this is called before the shape changes sides, and then there's the onChange callback, and this will be called after the visible side has changed.

Sidebars
When we looked at menus, we saw one variation was a vertical menu. That menu was always available. If we wanted to have some content off the side of our page, but accessible when needed, we could use a sidebar. There is only one type of sidebar in Semantic, and that is ui sidebar. In the example on the screen, we've taken a vertical icon menu and made it a sidebar. We've also added a button that, when clicked, will show us a sidebar. As we can see, when the sidebar is visible it dims the rest of the page, giving the focus to the sidebar. The dimming is the result of one of the two states available to sidebars, and that is the Dimmed state. It's applied to the pusher class. The pusher element on our screen is the content that we want pushed when the sidebar is open. In our case, that's our entire page. The other state is Visible. This is applied not to the pusher, but to the sidebar, and it forces that to be visible, even before calling the toggle behavior. It's a great way to make the sidebar visible on page load. There are two variations for sidebars. The first is Direction, and this can be top, right, bottom or left, and that's the direction that the sidebar is going to come out, and the other variation is width. A sidebar can be thin, very thin, wide, or very wide. A sidebar has several behaviors available to us. The first is attach events, where you pass a selector and an event, and this attaches the sidebar action to the selector for the event specified. If none is specified for an event, the default will be toggle. Then there is the show, hide, and toggle behaviors, as well as is visible and is hidden. There's a push page behavior, which pushes the page content to be visible alongside the sidebar, there's get direction, which returns the direction of the current sidebar, and pull page, which returns the page content to its original position. There is an add body CSS. This adds a stylesheet to the page head to trigger sidebar animations, and the opposite remove body CSS. And then there's the get transition event, which returns a transition event for the sidebar. There are also several general settings for a sidebar, such as context, and this is the context with which the sidebar will appear inside of, in our case it was just the body. There's exclusive, which sets whether or not multiple sidebars can be open at one time. There's closable, which determine whether the sidebar can be closed by clicking on the page. There's the dimPage setting, which tells sidebar whether or not to dim the page contents when the sidebar is visible. There's scrollLock, and that determines whether to lock the page scrolling when the sidebar is visible. There's returnScroll, which determines whether to return the page to the original scroll position once the sidebar is hidden, and there is delaySetup. Using this, when the sidebar is initialized without proper HTML it will defer creation of the DOM element to use the requireAnimation frame. There are also several animation settings. There is a transition animation, which defaults to auto. This is a name transition to use when animating the sidebar. The possible transitions are overlay, push, scale down, uncover, slide along, and slide out, with the last three being available only for vertical sidebars. There is a mobile transition, which is the same as the transition, but only for mobile devices. There is a defaultTransition object, which you can use to set the default for different sidebars, for example, the left sidebar has a default transition of uncover. There is a setting for useLegacy, and that defaults to false. When it's set to auto, it'll use legacy animations only for browsers that don't support CSS transitions. There is the duration setting, which defaults to 500 milliseconds, and this is the amount of time it takes the sidebar to animate. And there's the easing setting, which defaults, as in other places, to easeInOutQuint. And, of course, there are callbacks available to use as well. There's the onVisible, onShow, onChange, onHide, and onHidden callbacks.

Sticky
In Semantic, you can specify that content be sticky. This will make sure the content stays fixed to the browser viewport while another column of content is visible. On the screen we have a segment that has a menu inside of it. Underneath our menu we have placed several paragraphs of lorem ipsum text, enough that it scrolls off the screen. Below that segment we have another segment with two separate images. As we scroll down the first segment, our menu stays with the text. As soon as we go to the next segment, however, the menu disappears. It was only stuck to the first segment, not to the page. While the example here shows that it's stickied to its own content, a common use case is to combine the sticky with a _____ rale, which we saw in the last module, and fix the content on the left or right-hand side of the main content. There are no variations, states, or pieces of content to a sticky, its power lives in its settings. The first setting is pushing, which defaults to false. This determines whether an element should be pushed by the viewport, and attaching to the bottom of the screen when scrolling up. There is the jitter setting, which we've seen elsewhere. It defaults to 5. The sticky container height will only be set if the difference between the heights of the container and the context is larger than the jitter value. There's the observeChanges setting, which defaults to false. That determines whether any change in the context DOM should automatically refresh the cached sticky positions. There is the context setting, which determines what element the sticky should be stuck to. There is the scrollContext, and this is the context which the sticky should attach to on scroll events, and that is defaulted to window. There is the offset setting, which is 0, and it's the number of pixels from the top of the screen when fixing an element to the viewport. And similarly, there is the bottomOffset, which also defaults to 0. As always, there are several callbacks available to us for stickies. The first is onReposition, and that's a callback when the element is repositioned from a layout change. There's the onScroll, the onStick, which is called when the element is fixed to the page. There's onUnstick, which is called when the element is unfixed from the page. There's the onTop, which is when an element is bound to the top parent of the container, or there's the onBottom, which is the callback that's called when the element is bound to the bottom of the parent container.

Tabs
Similar to accordions, which we saw at the start of this module, tabs allow us to have different content accessible by a menu item. We see an example on the screen here. We have a tabular menu with three items, Animals, Nature, and Tech. We also have three separate UI tab elements below that menu. Notice that each menu item has a data-tab attribute which corresponds to a tab element below. When we enable the tab functionality on both the menu and its items, we're able to click through the menu, seeing different images. The only two available states for tabs are ones we've seen in the past, and they are Active and Loading. There are several behaviors available to us on tabs. The first is attach events, with a selector and event. This attaches the tab action to the given selector, and if no event is specified, then the default event is toggle. The next few are going to deal specifically with tab paths. Tabs are able to use Semantic's API functionality, which we'll see in the next module, to source their data, and that path can be specified for a specific tab. For example, we have the change tab where we give it a path, that will cause the tab to update to the path specified. There is the set state where you give it a path, and that sets the current path to the state you supplied. There's the get path, which returns the tab's current path. Then there's the is tab check. Then there's the cache read behavior where you supply a path, and it'll return the cached HTML for that path. Additionally, there is the cache add where you specify a path and its html to add HTML to the cache. And then there's the cache remove, where you also supply a path, and it removes the cached HTML from the path. Additionally, there are quite a few settings available for tabs. The first is auto, and this is set to false, and this determines whether or not the tab should load remote content with the same URL as its history. Then there's the history setting, which is also defaulted to false, and it determines whether to record history events for tab changes. There's the ignoreFirstLoad setting defaulted to false, and it will not load content remotely on the first tab load. It's useful when the open tab is rendered on the server. There's the evaluateScripts setting, and that's default value is once, and it determines whether or not inline scripts in the tab html should be parsed on the tab load. It can also be set to true or false to always parse or never parse inline scripts. There's the alwaysRefresh setting, which is defaulted to false, and that determines whether the tab should reload content every time it's opened. The cache setting is set to true by default. It instructs the tab to cache content after loading it locally so that it doesn't have to hit the server a second time. There's an entire settings object for apiSettings, and that's used when we interact with the API. Like I said, we'll see that in the next module. There is the historyType setting, which is defaulted to hash, and it can be set to either hash or state. Hash will use an in-page link to create history events, whereas state will use the DOM history and load pages from the server on refresh. The path setting defaults to false, however, when using the historyType of state you have to specify the base URL for all internal links. Context is also set to false by default. Tabs are limited only to those found inside the supplied context. ChildrenOnly defaults to false, however, if it's enabled it limits tabs to children of the current context. And finally there's maxDepth, which defaults to 25. It's the maximum number of allowed nested tabs. And of course we have several callbacks available at our disposal. There's onFirstLoad, onLoad, onRequest, and onVisible.

Transitions
When working with elements, particularly images, it's sometimes useful to use animation to draw attention to the element, much like how a presentation might have several different animations, such as fly in or fade out. Elements in Semantic UI also have that ability. It's accomplished using transitions. There are no types, states, variations or content for transitions. It's accomplished solely through the JavaScript. On the screen we have an image. We also have several buttons, each listing a different type of transition. Also note that they have an onClick event, which is here solely for demonstration purposes. It's not a best practice, by any stretch of the imagination. We see the onClick function defined below in our JavaScript, and it accepts the type of transition, and calls that transition. Then, after a second a timeout will happen and it'll restore the image. This is because some of the transitions will wind up in a hidden state. As we click on different buttons, we can see the image behave differently based on each transition. The transitions listed on the screen aren't the only ones available, however. There is also Drop, Swing, Browse, Slide, Flash, Shake, and Bounce. Also note that it's possible to chain multiple transitions together. On the screen now we have an image that will do two horizontal flips, then two vertical flips, and finish with a tada, once again, giving you the power to customize your application and how it looks and behaves. There are a lot of behaviors available for us to use on transitions. The first is stop, and that will stop the current animation, but it will preserve any other animations you have in the queue. Then there's stop all, which stops the current animation and kills all the queued animations as well. There's the clear queue, which will rid the queue of any animations that are in it. And we have the show, hide, and toggle behaviors as well. We can force it to repaint by calling the force repaint, or we can trigger a repaint by just calling repaint. The difference here is that force repaint uses a more expensive, but stable method to cause the repaint. And then there's reset, which resets all the conditions and changes during the transition. There's looping, which enables the animation to keep looping as opposed to stopping at the end. The opposite of that is remove looping, to kill any of the looping. There's a disable and enable behavior. You can set the duration of the animations by calling set duration and passing in a duration. You can save the class names and styles to a cache so that they're retrieved after the animation by calling save conditions. You can undo that by calling restore conditions. There is get animation name and get animation event to determine what animation is being used. There are the is visible, is animating, is looping, and is supported properties as well. There are also various settings we can use while we initialize our transitions. Those are animation, which defaults to fade, and it's the name of the animation that should be used. There is interval, which defaults to 0, and it's the interval in milliseconds between each element's transition. There is reverse, which is set to auto, and this will reverse only animations that are hiding. There is displayType, which is set to false, and it specifies the final display type, such as block or inline block. There is the duration, which defaults to 500 milliseconds. There is useFailSafe, which defaults to true, and if it's enabled, a timeout will be added to ensure that the animation end callback occurs even if the element is hidden. There is the allowRepeats, which defaults to false, but when it's enabled it will allow the same animation to be queued even while it's already occurring. And then there's the queue, which defaults to true, and it's whether or not to automatically queue animation if another one is occurring. And there are four callbacks available to us as well. There's the onShow, onHide, onStart, and onComplete calls.

Search
The final module in Semantic UI is the Search module. This one is a bit out of order form the alphabetical approach we just took, but it's a nice segue into our next module on the ability to use APIs. Since there is another module on APIs, we won't dive into too many of the details now, but we will have to reference it some in our discussion. To start, there are three types of searches. The one we're looking at on the screen is a local search, that is its content does not come from the server, but instead a JavaScript array. As we type, it searches the array, finding items that match. The second type is a standard search. It behaves much the same, with the exception that it pulls data form the server by default, using the endpoint /search/query. The third type is like the second, but it includes categories. I've included a screenshot of an example from the Semantic UI website that shows the results broken up by category. The only state available for searching is the loading state. Additionally, the two variations available we've seen in previous clips as well, and those are the fluid and aligned variations. There are several behaviors available for the search module. They are query, which will search for the value currently set in the search input, display message, that takes a text and type, this displays a message in the search results with a text using the template matching the type. Cancel query will cancel the current remote search query. Search local, with a query, will search a local object for the specified query and display any results. Has minimum characters determines whether or not the search has the minimum characters specified. Search remote, with a query, searches the remote endpoint for the specified query, and displays the results. Search object, with a query, object, and searchFields specified, will search an object for the specified query, and return results. Cancel query cancels the current remote search request. Then there's the is focused, is visible, and is empty Booleans, as well as the get value, which returns the current search value, get result, which passes in a value, and that returns the JSON object matching the search title or id. You can also call set value, where you pass in a value and it sets the search input to that value, or read cache, with a query, and that reads the cache results for the query you specified. You can also clear the cache for a specific query, or write to the cache with a specified query. You can add results passing in html, and it will add html to the results, and display them. The show results behavior will show the results container, meanwhile the hide results will, obviously, hide that container. The generate results accepts a response parameter, and it generates results using the parser specified by the settings. template value. And then there's the destroy behavior, which removes all events from the search. Additionally, there are several settings available as well. The apiSettings defaults to having an object with the action key equaling search. This is the settings for the API client. The minCharacters setting defaults to 1, and this is the minimum characters required to query for results. There's a transition setting which defaults to fade, and it's the name transition to use when animating the menu in and out. Duration defaults to 300 milliseconds, and it's the duration of time to do the animation. maxResults defaults to 7, and it's the maximum number of results to display when using local and simple search, or the maximum category to count for the category search. Cache is defaulted to true, and that will cache the results locally to avoid re-querying the server. Source defaults to false, and this would specify a JavaScript object which will be searched locally. So by default your search is going to be remote, unless you specify the source property. searchFullText is defaulted to true, and it will return local results that match anywhere inside your content. Then there's a fields object, and this handles mapping the display from the JSON that's returned form the server. As we see on the screen, by default the categories will map to ‘results', the categoryName will map to the ‘name' property coming back, categoryResults will map to ‘results', description will match to ‘description', image to ‘image', price to ‘price', results to ‘results', title to ‘title', action to ‘action', actionText to ‘text', and actionURL to ‘url'. These are the defaults. You can override them to match what's coming from your API. SearchFields is an array that specifies what fields on an object should be searched. By default, it is title and description. hideDelay defaults to 0, and it's the delay before hiding the results after the search blur. searchDelay defaults to 100, and it's the delay before querying results on the input change. And easing defaults to easeOutExpo, and it's the easing equation to use when using fallback JavaScript animation. Of course, there are also callbacks that will fire for the search module. The first one is onSelect, which will pass in a result and a response, and it's the callback whenever the element is selected by a user. onResultsAdd is called back after processing the element template to add HTML to the results. The rest are onSearchQuery, onResults, onResultsOpen, and onResultsClose.

Conclusion
Much like the Element module, we covered a lot of ground in this module. We looked at every Semantic UI module, and we saw that almost all of them had types, states, content, and/or variations, and once again, we saw that variations, such as inverted, that were used elsewhere in this course, had the same meaning with modules. We were also able to see firsthand that the mantra of Semantic UI truly is, everything arbitrary is immutable. The sheer number of configurations available to us on dropdowns, for example, is a great illustration of this mantra. Also in this module, we were able to wrap up our individual event page by applying the ratings module to it. It's be a few minutes since the start of the course, so let's take one last look at the before and after shots of our application. We've come a long way just using some basic styles from Semantic. We also mentioned that there are some API integrations with Semantic UI. That's what we'll look at in the next and final module. Once you've digested all the information from this module, check out the API module and see how to customize your app even more.

Semantic API
Why Use the API?
Up until this point in the course, everything that we've talked about has had a visual component, which makes sense because Semantic UI is a UI library after all, however, as we saw in the last module, there are some components that benefit from the ability to use an API. For example, when searching, it makes sense to hit an actual API to get the results. It's possible to put the Semantic UI library into place on a production application and still not use the API, that is, if you want just to use the look and feel of Semantic UI and capitalize on its readability and modularity, that's entirely possible. In fact, that's exactly what I did with the first two applications that I used Semantic UI on, and even though it's an incomplete application, it's what we did with our sample application in this course. So if we can implement Semantic UI without needing the API, why would we want to use Semantic's API functionality? There is a couple of reasons. First, if your main goal is to provide a UI to a ReSTful API, then the API behaviors would be a good fit as it allows you to specify routes and actions that are taken on different Semantic elements. Admittedly, this case is not very likely. It's fairly rare that an application would have next to no logic on the front end and while it's possible to perform a lot of logic with Semantic's API behaviors, it's not intended as a replacement to other's JavaScript frameworks such as Angular or Marionette. A more likely situation would be there are certain aspects of your application that are fairly lightweight on the front end. For example, if your application allows users to prioritize information from other users by favoriting them, that's a fairly lightweight action that would typically not require much of a response from the server. In a situation like that, Semantic's API behaviors are a perfect fit. Additionally, using the API behaviors is fairly straightforward as we'll see in the next clip. Applying the API function to an element will auto-trigger the API call. For example, when a button has an API behavior and it's clicked, the API call will be made. This makes calling the API very easy in Semantic. While the lighter weight scenario is a better fit for Semantic's API behaviors, they do provide quite a lot of control. For example, it's possible to shape the response data that comes back from the API, and this way, if you don't have control over the format of the response data, you can still translate it into a format that makes sense for Semantic. So these are reasons why we would use the Semantic API behaviors. In the next clip, we'll look at an example of how to use Semantic's API behaviors.

API by Example
Before we dig into the behaviors and settings of an API too much, let's take a look at a couple of examples. For the following demos, I'm using the JSONPlaceholder API. It's a fake ReSTful API that's useful for prototyping, and it can be found here at jsonplaceholder. typicode. com. The first example on the screen has a primary button with a text Get Posts. Below the button, we have a div with an empty ul element. We'll use this ul element to place our data in once we retrieve it. As you noticed on the HTML element, we haven't specified anything out of the ordinary, that is, it's a plain UI button. Below in the JavaScript, we call the API function on our button. We have specified an action of get posts as well as an onSuccess function. The onSuccess function is a callback that'll happen when the API returns successfully. The response parameter is the payload. In our case, it's an array of blog posts. We'll talk about the other callbacks later in this clip. The get post action though might be a little confusing. How does Semantic know to translate get posts into a valid get request to our specific API especially because we're hosting the UI at CodePen and the API is being used over from Typicode? We define the URL above where we create a hash of API actions to URLs. In fact, we have three separate action there. We have the get posts, get user, and search user, and we'll look at each of these URLs as they come up in the examples. When we click our button, we see that Semantic automatically shows it in a loading state, and then once the data comes back, we display each results in an li item. This is because of the code we've written in our onSuccess function. Here we get a response, which is an array of blog post titles back from our server. We loop over each one of those. We find our ul element, and we append an li element to it with our ID and title of the blog post. The next button is similar. This time, we're declaring that we're going to fetch a specific user. In this case, we're going to get the data for Ervin and then we'll populate a card that's hidden below the button. As we look at the JavaScript, we see that we're calling our get user action. Additionally, we have a new object in our JavaScript and that is the urlData object. Inside of that object, we have an ID key with a value of two. If we look at our URL above for the get user action, we see we have a template value of ID in our URL. When we click this button, Semantic will make a call to get the user with the ID of two, that is, Semantic knows to take our ID from urlData and to place it in the ID template variable of the URL. Once the data comes back, we populate our card. The previous two examples were both on buttons and the event fired whenever the button was clicked but what about other elements? This third example has an input box. With Semantic, when an input has an API action, it will fire on the onInput event. In our case, we want to find a user by their username. As we look at our search user's URL, we see that it's using a templated variable of value. Value is a special variable. For inputs, the data that's typed in will automatically be placed inside the value variable, therefore, we don't need a urlData specifying what our value key will be. Semantic does all of this for us. Now when we type in the username Bret, it'll fetch us the user whose name is Bret. Notice however that since it's triggered off of the onInput event, it'll actually fire once for each of our letters so as we type B, it issues an API request, and then R issues a second API request, and then E issues a third API request, and finally T issues a fourth API request. As we'll see in the settings later, we can set a throttle rate so that it doesn't make a request for each letter but now that we've typed that in, our API has returned the user based on the username and we've populated the card data for this user. Similar to the modules that we saw in the last module, APIs have behaviors and settings. The behaviors we have are query, which will execute a query using the existing API settings. Add URL data that takes a URL and data parameters and adds data to an existing templated URL and returns the full URL string. Get request gets the promise for the current API request. Abort aborts the current API request. Reset will remove loading and error states from the element. Was canceled returns whether or not the last request was canceled. Similarly, we have was failure, was successful, and was complete. Then we have our is checks such as is disabled, is mocked, and is loading. The first one, is disabled, checks whether or not the element that our API is tied to is disabled. The other two deals specifically with the API behavior. Next, we have a couple setters such as set loading and set error. Then we can remove the loading from our element or remove the error from our element. If we want to know what event will trigger API call, we can issue the get event behavior. If we need the URL encode a value, we can call the get URL encoded value and pass in our value. We can read cached response by passing in a URL. We can write cached response passing in a URL and a response. We can create a cache and we can destroy, removing all the events from our element. Additionally, there are several general settings available to us. There is the on settings, which is defaulted to auto, and this dictates when an API event should occur. Like we said for buttons, that defaults to onClick. For inputs, that defaults to onInput. But you can set it whatever you want. Cache defaults to true. This determines whether or not to cache successful AJAX response saving you a trip to the server later. If you set this value to false, Semantic will automatically add cache-busting parameters to the URL. You can set the stateContext. This will set the element that the state will be applied to. By default, it's the element that you're triggering the API off of. You can set the encodeParameters, which defaults to true, and that determines whether or not to URL encode parameters in your URL string. You can specify whether or not to include default template parameters such as value and text by using the defaultData setting, which is set to true. The serializeForm setting is defaulted to false and this determines whether or not to serialize the closest form to your element and include it in the request. Here we've got our throttle setting, which is what we talked about in the input example. It defaults to zero but its setting is how long it should wait before issuing an API request. There is the throttleFirstRequest, which defaults to true. There is interruptRequests, which defaults to false, and this determines whether an API request can occur while another request is still pending. There is the loadingDuration, which is the minimum duration to show the loading indication and it defaults to zero. There is the hideError setting, which will automatically remove the error state after the error duration period unless of course the element is form in which case, the error state will stay. And then there is the errorDuration that we just talked about and that defaults to 2, 000 milliseconds and that's how long the error should appear before it disappears. As we already seen some with our action setting, we can also specify request settings. The first one is action and it defaults to false, and it's the named API action for the query. In our case, we used get post. There is the url setting, which defaults to false, and this will be a templated URL query. There is urlData, which defaults to false, and its variables to use for your template URL. There is the response setting, which defaults to false. If you set this to a JavaScript object, then that object will be returned from the API call without actually hitting your server. There is responseAsync, which takes settings and callback, and it defaults to false, and when this is specified, this function can be used to retrieve content from a server and return it asynchronously instead of the standard AJAX call. There is the mockResponse, which is defaulted to false. This is an alias of response. There is mockResponseAsync, which is also set to false, and it's a alias of responseAsync. Then there is the method setting, which defaults to get, and it can be either get or post. There is the dataType, which defaults to JSON, but it could be XML, JSON, JSONP, script, HTML, or text. And there is the data, which defaults to an empty object, and it's the post or get data to send. And finally there are several callbacks that we can capitalize on. We've already seen the onSuccess callback. There is beforeSend, beforeXHR, onRequest, onResponse, successTest, which determines whether or not the completed JSON response should be treated as successful. There is onSuccess, onComplete, which fires whenever the request is complete regardless of whether it succeeded or failed, onFailure, onError, and onAbort.

Course Wrap-up
You made it. You're now equipped to bring Semantic into your application and begin styling your app. Let's go over at a high level what we learned in this course. We started the course by talking about Semantic's approach to using natural language. For example, we might describe this dog as a large brown dog but we would not describe the dog as dog, dog-large, dog-brown. It doesn't make sense in English yet often we do that with our markup. We didn't talk about this too much more throughout the rest of the course but we saw it time and time again. For example, when we looked at cards, we saw that we had three stackable cards, or when we placed our men at the top, we noticed that it was a gray inverted top fixed menu. We also talked early on about how configurable Semantic is. Not only does the JavaScript use natural language such as get text but it gives us nearly unlimited options as to how we configure our application. This really came to light in module number six when we saw Semantic UI modules. In that section, we saw over and over again that everything arbitrary is mutable. After wrapping up the general information on Semantic and how to get it on our computers and in our applications, we turned our attention to the first components in Semantic, namely elements. This was the first time we start to see the power of Semantic UI really come to life. We were able to provide quite a lot of instantaneous cleanup to our application. Using containers, dividers, images, and other elements, we were able to make a noticeable difference on our site. This is also where we started learning the common language of Semantic UI. It's during our study of elements that we learned about types, states, content, groups, and variations. For example, we began to see that inverted in Semantic means a black background with a white foreground and that's true whether it's an inverted segment or an inverted button. We did spend a lot of time discussing these items because it's essential to understanding how Semantic works. It's important when styling to think if the change you're making is a variation or a type because that has implications for the other types of your element. Because we were able to understand these concepts, we were able to easily customize icons to make them look like what we wanted. We saw that we could combine an icon with a circle and a plus sign and instantly make an icon that's not in the standard library. After elements, we looked at collections. Here we continue to see the power of combinations and customizations that Semantic has. For example, we looked at messages, which combine several elements, and we saw that we had a full-blown UI icon available to us inside of a message. This serve to reinforce the learning that we had done in the previous module. What we learned about icons was still applicable even though we were adding them to messages. We didn't have to deal with a subset of prototypes for message icons. While that's powerful in and of itself, collections demonstrated even more of the power of Semantic UI. Again we come back to the common language of Semantic. Just as we saw with elements, collections can also have types, states, content, and variations. Additionally, the loading state means the same thing to a button as it does to a form, and even more importantly, it's visually similar whether it's on a segment, container, or form. There will be a spinning icon indicating that the application is busy. It was also in the collection module that we began to see Semantic's power for responsiveness. This is where we first looked at the grid and table components, and how applying some standard classes allow Semantic to resize the page when the screen size shrinks. We didn't need to specify breakpoints ourselves and oftentimes we didn't even need to worry about what it would look like on mobile versus tablet versus computer versus widescreen. Semantic took care of that for us. While we first saw Semantic's responsiveness ability in grids and tables, it really shined for us in the views module. Here we took a listing of events on our application's main page, and turned them into cards, then we made those cards stackable so that if the screen size shrunk, Semantic would automatically adjust our cards for us. It was also at this time that we saw the power of Semantic's layout. For example, even though we had five cards, we simply needed to tell Semantic that we wanted three stackable cards and it is sure that they were three cards per row. We didn't have to define what a row was nor create the groups ourselves. The framework handled it for us. Again we continue to see how common the language of Semantic is. Just like elements and collections before them, views also have types, states, content, and variations. The next module that we looked at was Semantic UI modules. Here we got into not just the look but also the behaviors of our components. While we talked about mutability early on in the course, it really hit home on this module. Every module had so much that we can configure. There were behaviors, which could trigger actions on the module. For example, on a dropdown, we can get the currently selected text by performing the get text behavior. Additionally, each module had several settings available to us. These would allow us to set up the module the way we want it. For example, on accordions, we were able to pass in a parameter during initialization that told the accordion whether or not it needed to be exclusive, that is, when opening an accordion, did the currently open one need to close or could it stay open? While there are sensible defaults for these settings, we do have the power to configure them as we see fit. Again we saw the common language. First, modules also have types, states, content, and variations just as the other components do in Semantic but additionally, we saw that the behavior section of modules also has a common language. Many of our modules have an isEnabled flag and we retrieve the state of the module in the same way for each module. All this goes to say that while there's a lot of content that we covered in this course, it has largely been broken down into a few key concepts. We can talk about our elements, views, collections, and even modules using the same language. Then in this module, we looked at the API behaviors of Semantic. We saw that the API integrations allow us to fetch data in a relatively easy manner. In our example, we pulled posts and users, and displayed them on the screen giving our UI framework more power than just making things look good. Additionally, we saw how easy it is to wire up the API to our Semantic components. We can accomplish it by simply placing an API call on our element. For buttons, Semantic knows that when the button is clicked, it should fire the API call, and for inputs, it knows to fire that event when the input changes. Finally, we saw the configurability even on the API. For starters, we saw that we could templatize our URLs and pass in data to make our calls that much more dynamic but we also saw that behaviors and settings available to the API. For example, we could change what event fires the API call. We could do it on hover instead of click, or we could tell the API to throttle the number of requests so that it wouldn't constantly be hitting the server. All of these modules come together to fulfill Semantic UI's goal of allowing us to build beautiful responsive layouts using human-friendly HTML.

Course author
Author: Nate Taylor	
Nate Taylor
Nate's first program was written in QBasic on an 8086 clone his dad built. Since then he's written applications in C++, .NET, and Node.js. He spent the first 12 years of his career writing Windows...

Course info
Level
Intermediate
Rating
4.5 stars with 32 raters(32)
My rating
null stars

Duration
4h 10m
Released
16 Jun 2016
Share course