Building Apps with Android Architecture Components
by Omri Erez

Programming Android apps can be a complex process and lack of knowledge in architecting your app can result in spaghetti code and dead ends. This course will teach you to utilize the ARCH components libraries and master building Android apps.

At the core of developing Android apps is a thorough knowledge of architecting your code with an effective structure. In this course, Building Apps with Android Architecture Components, you’ll learn foundational knowledge of ARCH components in order to implement your app with a well-structured architecture with minimum development effort. First, you’ll learn why architecture is important and the most commonly used architectural patterns in Android. Next, you’ll explore the new ViewModel component, LiveData, and Room frameworks. Finally, you’ll discover how to write basic tests in order to verify the functionality of your new app’s architecture components. When you’re finished with this course, you’ll have a foundational knowledge of utilizing the different ARCH components that will help you as you move forward to build well structured Android apps with an enhanced and robust structure.

Course author
Author: Omri Erez	
Omri Erez
Omri is a software engineer and award-winning Android developer. His first introduction to programming was learning C at the age of 12. While starting his bachelor’s degree in Information...

Course info
Level
Beginner
Rating
4.6 stars with 31 raters(31)
My rating
null stars

Duration
2h 24m
Released
15 Feb 2018
Share course

Course Overview
Course Overview
Hi everyone, my name is Omri Erez, and I'd like to welcome you to my Pluralsight course, build well-structured apps with Android Architecture Components. I've been a professional software engineer for over 10 years now focusing on the Android platform. Developing Android applications is a complex task and sometimes we forget about the structure and architecture of our code. In order to deliver an extendable, maintainable, and testable code base we have to think about the architecture of our application from the very first stage of our development. In this course, we are going to learn together how to write Android apps with a robust structure and we will utilize the various art components, which will result in architecture with well-defined layers. Specifically we will learn about the following subjects, the SOLID principles and commonly-used architectural patterns on Android, the ARCH, ViewModel, and lifecycle-aware components, the LiveData framework, the Room persistence solution, and how to test your architecture using various test types. By the end of this course you will know how to utilize the various ARCH components and how to produce Android apps with a robust architecture, which will be both extendable and testable. This course is specially designed for beginners. Before starting this course you should have basic knowledge of Android development and Android Studio. I hope you will join me on this exciting journey to learn about Android Architecture Components with build well-structured apps with Android architecture components course, here at Pluralsight.

The Importance of Software Architecture Planning
The Complexity of Software and Android Apps
Welcome everyone, I'm super excited that you decided to join me at this course, Building Apps with Android Architecture Components. My name is Omri Erez. I started my Android journey back in 2009 and since then I have been involved in a large number of projects. We all know that writing well-structured Android apps can be a very complex task. In this module we are going to talk about the importance of software architecture. In order to figure it out we need to ask ourselves a couple of questions. Why is software architecture so important? And, what characteristics does our software need to embrace? Let's start with the characteristics. Our software needs to be maintainable and extendable, testable, and understandable for new developers or stakeholders. Let's go over each point in detail. Maintainable software is a piece of software that has the ability to fix a bug without introducing a new one, to fix a bug without it reoccurring again and again, and the ability to fix a bug with editing a low number of components. Extendable software on the other hand means, a piece of software that has the ability to add a new feature with a minimum change of current components and has the ability to add a new feature without changing the shape of the original architecture. Testable software means a piece of software that has the ability to test each component separately that costs low-maintenance effort in order to improve or update our testing code. Last, but not least, efficiency in terms of testing effort and code coverage. Understandable for new stakeholders, or in our case developers. This is a very important point, it means that we can benefit from the fact that there is a low barrier of entry for new developers to start developing for the project. New stakeholders can understand the project structure quickly and the code is self-explanatory, or easy to explain. All developers can easily explain the structure of the software without confusion. Remember, truth can be found only in one place, the code. This quote was spoken by Robert C. Martin, as well known as the father of the clean coder and the clean architecture. We will talk about Robert and these concepts a little bit more in detail later. Let's evaluate together the complexity of a typical Android application. As we all know Android applications can become very complex. From the outside, or for our users, our application seems fairly simple, but often under the hood it consists of a fairly complex structure. It can contain a high number of components and a high number of library/frameworks. Android applications have restrictions from the operating system. As we all know, in the mobile operating systems the resources are strict and components have to comply with these restrictions. A typical Android app will contain maybe around 10 activities, 2 services, 10 interfaces, 5 data adapters, 4 fragments, helper classes, content providers, and a database. As you can see, the number of components can vary and can be high. And we're not done here. In addition, a typical Android app will contain a dependency injection framework, widgets, API-related logic, data models, custom views, and custom transitions, and the list can go on and on. Do you see where I'm going here? Another important characteristics of an Android app is their interoperability between components. They need to be highly decoupled from each other, and able to consistently communicate with each other.

Code Jedis and Trolls
Let me introduce you with two new terms, Code Jedis and Trolls. Code Jedis are the ones that follow all the best practices and design patterns. These are the good guys, and hopefully we will be part of the code Jedis. And the code trolls are the ones that don't. These are the bad guys, they don't follow best practices, they write very messy code, and untestable code. We don't want to be associated with them. I'm going to use these terms over and over again. So how can I find out if the code was written by a troll or by a Jedi? There are some indications. Indications for Code Jedi's. Easy readable code, at best with no comments, clear naming for classes and variables, and following the SOLID principles for object-oriented design. We will cover these principles in the next section of this module. Another indication is small classes. Now that we covered the Jedis let's move on to the trolls. Indications of code trolls, not readable code, which is equal to a code with a high number of comments, because if your code is not readable of course you need to explain it with comments, confusing structure in naming, and very long classes. Code trolls are producing code that looks like that, AKA spaghetti code, where the different app components are highly coupled, cannot be tested separately, and just a mess. On the other hand, code Jedis produce code like this layered cake. When looking at this cake it is obvious that this cake is composed from separated layers. Each layer, or in our case, each component of our code is highly decoupled from the different components, is separately testable, and not dependent on a high number of components. For example, if we would want to cut out the green layer and replace it with a different layer it would be fairly easy to do. On the other hand, in our spaghetti case it would be impossible, or will require a high effort. An important point to remember is, the transformation from a code troll into a code Jedi is very much possible and just require persistency and training. Imagine that after revealing the true power of the force, or in our case, well-written software, it's very hard to go back to old habits. So I encourage all of you to start your journey to become a code Jedi if you didn't start yet. Our main goals are well-defined structure and layers, well-defined components, and our code should be extendable, maintainable, and testable. Remember good architecture saves valuable development time, and as we all know, time is money. And in that positive notion let's go over more in detail to talk about the SOLID principles of object-oriented programming.

The SOLID Principles Part 1
Who doesn't like a joyful Jenga game? I know I do. The problem is that if we are going to write our software as a Jenga tower it is inevitable that in the lifetime of our software the tower will collapse and we are going to end up with something like that. This is why we are going to talk about the SOLID principles. A little bit of background. The SOLID principles were firstly introduced by Robert C. Martin known as Uncle Bob. They also referred as the first five principles for object-oriented design, and they make it easy for us developers to write maintainable, extendable, and testable code. Sounds familiar, right? I believe that if you are writing object-oriented software following and knowing the SOLID principles is very important. We are writing Android apps, and we are using either Java or Kotlin, which are both object-oriented languages. The SOLID principles are very important, and I will try to convince you why. The main goal of this section is to get you familiar on the basic level with the SOLID principles without going into too much detail. Our first principle called the Single responsibility principle. According to that principle every class should have only one responsibility, a responsibility defined as a reason to change the class. Following this principle will result in short components and classes. Let's go over an example. Let's say we want to program something like that, a multipurpose knife. Looks pretty complex, right? One approach would be to write a class called multipurpose knife, and to include all the different functionalities in one class. In this case we would probably end up with a very long class that has multiple responsibilities. What we want to do, and if we want to follow this principle, is to split our class into smaller classes. We will write one class of the light, one class for the hammer, one class for the magnifier, and one class for the calculator. In that case, each class will have one main responsibility, and the length of the classes will be shorter. Our second principle is the Open/close principle. According to that principle classes should be open for extension, but closed for modification. We should add new features using inheritance, but shouldn't change their existing class. For example, Let's say we have a class called ArrayProcessor, which contains the process method. As you can see here, we have an input of a multidimensional int array and we are iterating through the array. We are going to process differently each line of our input according to its first digit. As you can see here we have the switch/case block. If the first digit is 0 we will do something, if the first digit is 1 we will do something else. This is violating the open and close principle because of the fact that if we want to add a special handling for the digits 2, 3, or 4 we need to modify this class. In order not to violate a principle we will change the class in the following way. We will define an interface called DigitProcessor, which contains the method process. It takes as an input one of our input. Then we will modify our ArrayProcessor class in the following way. It will contain a HashMap of an Integer and a DigitProcessor, and we will add a method called addProcessor in order to add all the different processors, one processor for each digit. You can see our other process method, which now contains the same loop, but with a different execution. Here we are just calling the right processor according to the first digit. For each digit we have a different processor, in that way if we want to add new handling for new digits we don't need to modify our ArrayProcessor class, but just add a processor with the desired digit.

The SOLID Principles Part 2
Our third principle is the Liskov substitution principle. According to that principle a method that takes class Y as parameter must be able to work with any subclass of Y. In that example we have an interface called Phone, and it contains a dial method, pretty intuitive. Then we define two classes, one is an AnalogPhone and the other one is a SmartPhone. The difference between the two is that in an analog old phone we can just dial whenever we want, but on a smart phone we first need to unlock the keys. In addition, we have a PhoneManager that takes in as an input a phone object and we dial the number. In that case, if our phone is a smart phone and the keys are locked we wouldn't be able to dial. One solution to be to add a handling for the SmartPhone, so we did the following modification. We check if the phone is an instanceof a SmartPhone, then we will check if the keys are locked we will unlock it and dial the phone number. The problem is that here we are violating our second principle, the open/close principle, because if tomorrow we want to introduce a new kind of phone we will need to modify our PhoneManager class. So this solution is not good enough. A better solution would be to alter our SmartPhone class and alter our dial method. Here you can see that in case our keys are locked we will internally unlock the keys and then dial the number. In that case our PhoneManager logic would be more simple and will work for both phones. Pretty simple, right? Our fourth principle is the Interface segregation principle. According to that principle complex interfaces should be split. Complex interfaces makes it harder to extend smaller parts of our system, makes sense, right? An example of that would be if we go back to our multipurpose phone or knife, here we defined a very complex interface that has multiple methods. If we would want now to implement a calculator class that implements this interface we will end up with some empty implementations for the dial lightOn and lightOff methods, which is violating the interface segregation principle. Instead, to be more flexible we can break the interface for three different interfaces. One interface would be a phone, one interface would be a calculator, and the third one would be a flashlight. In that way, the desired class can implement one or more of the simplified interfaces. Our last, but not least principle is the Dependency inversion principle. According to that principle we should have no hidden dependencies, and I will show you soon an example. In addition, we always need to let the calling class create the dependency, instead of letting the class itself to create the dependency. An example of dependency inversion violation, let's say we want to present a bank with this class. The Bank has three components, Management, ClientsManager, and AccountsManager. As we can see in the constructor we are creating new instances of the three components. These are hidden dependencies. Why? Why are they hidden? Because the calling class, which calls the constructor of the Bank cannot see the hidden dependencies. It cannot see that our Bank object is dependent on the different components. Instead, in order to correct that we want to implement the following. This is our altered Bank class. Instead of having an empty constructor we will pass this parameter as the three components. In that way the calling class will provide with the dependencies. This is very helpful for testing as it gives us the opportunity to provide more components for our Bank class and test every component separately. As I told you before, we covered the SOLID principle subject only on a basic matter, and I encourage you to go watch the course by Steve Smith at the Pluralsight library. The course is called SOLID Principles of Object Oriented Design. This course will provide you with a deeper understanding of the different SOLID principles. Please join me at the next section where we are going to examine our demo app.

Your Demo App at Its Initial State
Our demo app is called Crypto Boom App. It contains a list of Crypto-currency's market data. It's only one list, it's pretty simple. The code consists of one God Class. I will talk about the term God Class a little bit more later, but it means that all the logic for our app is concentrated in one class, in our case in activity, and we will examine its initial state. Okay, so let's open Android Studio and open our demo app. Our demo app consists of only two classes, CryptoCoinEntity and MainActivity. Let's first open our Gradle file to see which kind of dependencies this project is using. Here we can see that we are using some support libraries from Google. In addition we are using a JSON parsing library called Jackson. For network access we are using a Google library called Volley. Last, but not least, we are using Glide in order to load images in our app. If we open our CryptoCoinEntity class we see the following. Here we can see some JSON annotations from the Jackson JSON parsing library. It has a pretty simple syntax. Here, for example, you see that we define the JsonProperty with the key id and it will be mapped to our String id. We are going to use an external API in order to get the list of these entities. You can see that this class contains getters and setters as well. This is pretty standard. The important part of our demo application is our main activity. If we run our app on the emulator we can see the following. Here we see a list of Crypto-Currency's market data. This API data is taken from the coinmarketcap. com open API. The functionality of our app is pretty simple, our user can scroll the list and see some market data regarding different crypto currencies. He can click the fob in order to scroll back up, and he can pull the refresh in order to get fresh market data. In our MainActivity we can see that it has multiple components. We have a RecyclerView and our adapter where we load the data into, the swipe to refresh layout, which is a standard part of the Android support library, and a tracker. We use our tracker in order to send some lifecycle activity events to a bogus tracking service. If we look at our own create method, we can see that we are loading the layout, binding the view, fetching the data from the network, initializing our components, and tracking the on create method. If we scroll a bit down we can see that we defined the divider for our RecyclerView and the definition of our MyCryptoAdapter. Our adapter contains a list of the type CoinModel. CoinModel is a lighter version of our entity. Now let's take a look at the network logic. As I said before, we are using a library called Volley. This is a library developed by Google and it's open source. We set up our HTTP request queue and we define two callbacks. In case of a successful response from our API we are going to save the response in our local storage and parse the API response into a list of CryptoCoinEntity. In addition, we defined an async task that will map our entity into our lighter CoinModel. In case of a network error we just take the last version of the data, save it to the local storage, and show it under UI. If that wasn't enough, we also define the tracker in its own class within the MainActivity. Last, but not least, we have our location-related code. At the end or our activity we have a pretty boring logic, which is related to writing and reading our API data into our local storage. As we said before, our activity contains all the logic of the app. This is a bad idea, there is no reason in this world that this simple activity would be 550 lines long.

Summary
Let's review the current architecture of our demo app, if we can call it an architecture. Now our demo app contains a huge activity, and within it all the different components. We can see components related to loading the data on the UI, we can see the network logic, we can see our tracker, our runtime permission logic, and we can go on and on. This is obviously a God Class, which we want to avoid. During the modules of this course we will transform our architecture list demo app into this piece of work. Our demo app in its final state will contain three imaginary layers. our first layer will contain our activity, and only the logic which is related to the UI. Our second layer will contain the ViewModel and LiveData objects. LiveData is a useful framework, which lets us developers to stream data into the UI asynchronously. In addition, we will define lifecycle-aware components. These components are aware of the different lifecycle events. Our third layer will contain whatever is related to loading the data. We will define a repository interface, which will have two sources of data. The first source is the network with our API-related logic and the second source would be an SQLite database, which we will initialize using the Room framework. We can annotate our different layers as presentation layer, a business logic layer, and a data layer. Remember, long-lived software always has legacy code and without well-structured architecture the technical debt will always grow. Let's summarize this module. First, we talked about why architecture is important, and thus we want to produce maintainable, extendable, and testable code. In addition, we talked about the five SOLID principles for object-oriented design and we reviewed some examples in order to demonstrate violations of these principles. Last, but not least, we went over our Crypto Boom App, we reviewed our starting point, and our final goal, which is well-structured architecture. Please join me in the next module where we are going to talk about common architectural patterns on Android.

Understanding Common Android Architectural Patterns
Overview
Welcome back everyone. After reviewing the basic concepts of object-oriented design and understanding why architecture is important, in this module we are going to talk about common Android architectural patterns. These patterns are being used every day across many Android applications and it's important for us to understand them. Before we start with the patterns I want to emphasize this term, the God Class, or a God Object. It's an object that contains a high number of components, the components logic is coupled, usually it's a very lengthy class, and we should avoid them at all costs. As we stated before, God Classes are very bad for our architecture, or you can even call them architectureless. In our demo our activity is a God Class because it contains all the logic of our application. All the components of our application are implemented within our activity, this is a very bad idea. Let's go ahead and talk about the architectural patterns we are going to review. The first one will be MVC, AKA model-view-controller. The second one would be the MVP pattern, AKA model-view-presenter. And last, but not least, we are going to talk about the MVVM, model-view-ViewModel.

MVC: Model View Controller
Model view controller. The first component in the MVC pattern is the model. The model represents our data models, it manages the data states, includes the business logic of our application, and often used across different parts of our application. The view is essentially our layouts and views, it's the way we represent the data on the screen, and it renders our UI. The last component, and the most important one, is the controller, which is essentially our activities and fragments. It includes the user's interactions with our app and it's the communication channel between our views and models. Let's try to draw a flow diagram of the MVC. So we have our view, which is essentially our XML layouts and views, and our controller. The view will notify the controller on user interactions, and the controller will update the data state on our model, in our case, our data entity. If the UI needs to be updated, the controller will send UI updates to the view. Looks pretty simple, right?

MVP: Model View Presenter
Our second pattern is MVP, AKA model-view-presenter. The model in our MVP is exactly the same as in the MVC pattern, so no change here. Our view is our XML layouts and views, but, as well as our activities and fragments. In the Android world, activities and fragments are strongly bonded with the views. Our view will implement an interface for the presenter's actions. And I will soon show you what I'm talking about. The third component on the MVP pattern is the presenter, and this is again the most important one. Our presenter has no relation to our views, unlike in the MVC pattern, the operations will be invoked by our view, and the view's update is done via the view's interface. Let's try to draw the MVP flow diagram. We have our model, in our case our entities, and our view. Our view will implement a screen or a view interface. And our presenter will have an instance of this interface. We will need to bind the view and the presenter together. Our view will notify the presenter on user interactions and our presenter will update the data state of our model. If any UI need to be updated our presenter will update the view. In addition, here most of the business logic will be contained within our model. Many developers follow a more stricter rule that states that the presenter shouldn't use any Android APIs. Following that rule the presenter will be more decoupled from the Android world. The interface, which has been implemented by our view, and bound to our presenter is often called a contract. So don't be confused if you see the term contract anywhere online.

MVVM: Model View ViewModel
Last, but not least, our third pattern is the MVVM, model-view-ViewModel. When the MVVM pattern was introduced by Google it was directly associated with the usage of the Data Binding Library from Google. It minimizes the view binding code in our activity and view's binding logic is implemented in the XML layout. I want to show you a very simple example of using the Data Binding Library. So usually without using the Data Binding Library we will have something like that. We have our ViewHolder, which will facilitate an item in our list. Here we have some views. In order to bind our views we need to call the findViewById method, it's pretty standard. But when we want to bind the data to the views we will have something like that. We will need to set our model attributes on our views. Now, refusing the Data Binding Library this is not necessary. A simple example would be, here we don't really need our old code, we just need to define that the model that we want to use is our coin model and define the attribute within the layout itself. Of course there is a small tradeoff because in this case our XML layout can be a little bit more complex. This is the most simple usage of the Google Data Binding Library. Of course, it contains a lot of different features, but it is a subject of its own, and it's outside the scope of this course. If you want to learn more about the Data Binding Library I encourage you to check out the Pluralsight course, Android Fundamentals: Data Binding by Richard Cirerol. Let's go back to our MVVM. The model and the view are the same as in our MVP pattern, so there is no change here. The third component is our ViewModel and the most important one. Our ViewModel will contain the model, will use observable variables to update the values, and on each value update the relevant views will be updated. This is of course using the Data Binding Library. Let's try to draw the MVVM flow diagram. So we have our model, our view, and our ViewModel. Now, our ViewModel will contain an interface and our view will notify it on user interactions. Next a method will be invoked, and then our ViewModel will update our model, and in parallel our method will update our observable, which will invoke a value change. Finally, our ViewModel interface will update the UI directly on the XML layouts.

Comparison
Let's compare the three. Here we have a simple comparison. As we understood before, the main components here are the controller, the presenter, and the ViewModel. The first criteria would be the dependency on Android APIs. The Controller's dependency on Android APIs is very high because our controller is our activity, and most of the logic will be implemented there, comparing to a low dependency using the MVP pattern, and to low or no dependency using the MVVM. The XML complexity on both MVC and MVP is relatively low, and compared to the MVVM, which it can be medium or difficult, as we introduce more binding logic within our XMLs. For this criteria, low complexity is positive as we don't have any hidden functionality within our layouts. The next criteria will be unit testability. In case of an MVC the unit testability of each component is relatively difficult because most of the logic will be implemented within our activity, which can result in a very lengthy class. As we stated before, we want to avoid a situation like this. In our MVP we have an additional component, our presenter, which is separated from our activity. And for that reason our presenter can be tested separately. In case of our ViewModel unit testability is great because each component can be separately tested. Our last criteria is the modularity of the pattern and if the pattern is following the single responsibility principle. In case of the MVC the clear answer is no, because most of the logic will be implemented in our activity of fragments. In contrast, using MVP or MVVM, the answer is yes, as the components are more modular and decoupled.

The Clean Architecture
Let's take another step and talk about a more complex architecture, which personally, is one of my favorites, the clean architecture. We introduce the idea of the clean architecture when talking about the SOLID principles and Robert C. Martin, the father of the clean architecture, and the clean coder. This architecture is enforcing the SOLID principles. In this architecture our code will have three different layers, presentation layer, a domain layer, and a data layer. Sounds familiar, right? Our presentation layer will contain Android components, AKA activities, services, fragments, and so on. In addition, it will contain any custom views and presenters, assuming that we're using the MVP pattern of course. Here you can use any one of the patterns we talked about before. Our domain layer, and maybe the most important layer, will contain our data entities, our screen interfaces, our use cases, and it will be clear from any Android APIs. This model will be defined as a pure Java or Kotlin library. Our data layer will contain any external API access, local storage components, and any memory or disk caches. Let's try to draw this architecture. So we have our presentation layer, our domain layer, and our data layer. Our presentation layer will contain our activities, services, presenters, or ViewModels, and the ViewPresenter contract. Our domain layer will contain some use cases, which will be in charge of fetching the data and loading it on the screen, our data entities, and our data repository. For each data entity we will have a repository. This makes it a very entity-centric architecture, which has multiple advantages. Our data layer will contain any API web services, SQLite database, and the implementation of our data repository. Our presentation and data layers will communicate with our domain layer. In addition, our presentation layer will contain the data layer as well. As you can see here, the domain layer is unaware of the different layers. In that way it's very easy to test it separately. The advantages of using the clean architecture is a modular approach. Each module can be tested separately and the domain layer can be reused for other JVM applications. It means that theoretically you can take the code of our domain layer and reuse it on a JVM-based web app, for example. That's a huge advantage. If we go back to the end state of our demo app we can see that our architecture is very similar to the clean architecture. Here as well we can break our code to three imaginary layers, a presentation layer, a business logic layer, and a data layer. The clean architecture is a complex topic by its own. If you want to learn more about it, I highly recommend you a course in the Pluralsight library by Matthew Renze. This course covers the basic concepts and patterns of the clean architecture.

Summary
Let's summarize this short module. In this module we talked about three common architectural patterns and we revisited the term God Class. We also understood why we should avoid God Classes. And we reviewed the differences between the MVC, MVP, and MVVM patterns. In addition, we briefly talked about the clean architecture and its advantages. I want to invite you all to join me in the next module where we are going to slowly shape our architectureless application to have a well-structured architecture by using the Android Architecture Components. See you soon.

Implementing Life Cycle Aware Components
Why Should You Use Life Cycle Aware Components?
Hello everyone, and welcome back. After we understood the basic concepts of object-oriented design and reviewed common architectural patterns in Android development, this module will be all about hands-on development of lifecycle-aware components. First, we will understand why do we need them and what are the advantages of using them. Before jumping into hands-on development Let's talk about the activity lifecycle. A usual scenario, if a user will open our app, our launch activity will be started. The first callback on the activity lifecycle events would be the onCreate method, where we usually initialize our views. The next callback would be the onStart and the onResume. At that point our activity is on the foreground and running. Now, in case our user will navigate to a different activity the following will happen. The current activity will be paused and stopped. At that point the Android operating system can decide to destroy our activity in order to free some resources for other activities or apps. This is maybe the most important callback and I will talk a little bit more about it later. After the onDestroy is called our activity is shut down. Another scenario will be that the user will want to go back to our first activity. And in that case, the following will happen. The onRestart callback will be called and we will go back to the onStart method. This is a very simplified overview of the activity lifecycle. Of course, the full activity lifecycle is more complex, but this is enough in order to give us some context of why do we need the lifecycle-aware components. So usually, application components will be bound to lifecycle events. Often we will need to override lifecycle callbacks, and usually it will be either the activity or a service lifecycle callbacks. Now, the reality is, many of our custom application components often have lifecycle-related code. It can result in long lifecycle-related methods. There are a couple of problems involved with that. Bad implementation of lifecycle-dependent events can result in our application crashes, us losing the user's state and progress, and not handling configuration changes gracefully. In addition, not releasing resources properly can result in memory leaks, which are really bad, runtime crashes, and inconsistency in application state. I want to emphasize this point why memory leaks in your code are bad. The second that your application contains memory leaks your code will start to behave unpredictably, and your application will start to have random crashes, which are really hard to detect and fix. If you would like to learn more about memory leaks I produced a whole module about it in my course, Overcoming Common Android Performance Barriers. I encourage you to go and watch this course. I really love this topic and very passionate about it. For my personal experience you will find out that after you dig into memory leaks you are going to start being obsessed about it, and you will try to find all the memory leaks in your applications, and I can ensure you that if you weren't aware of the topic of memory leaks you will definitely find some.

How Does It Work?
So how can we handle these problems in a more structured approach? Recently, Google released as part of its support libraries a framework called android. arch. lifecycle. We will soon implement these components in our demo app. This framework gives us the possibility to make components be aware of lifecycle events, for example, activity lifecycle events. In addition, it's a simple and powerful implementation that gives us the opportunity to handle releasing of resources in an easy way. Using the lifecycle-aware APIs will result in decouple lifecycle events' logic, shorten the activity lifecycle methods, and transfer the lifecycle logic to be per component. This framework has two implementations. If we use the AppCompat library prior to version 26. 1 it will look something like that. We have a lifecycle activity, which is as well a lifecycle owner. In addition, we have a lifecycle-aware component, which is a lifecycle observer. In our LCA component we will implement the OnLifeCycleEvent annotations in order to state which lifecycle events we want to handle. We will call the addObserver method in our LifeCycleOwner class in order to let the operating system know that we want to get updates on the different lifecycle events. Each time a lifecycle event will be invoked the method with the respected annotation will be invoked as well. It's a pretty simple flow. If we're using AppCompat 26. 1 and later the flow is even more simple. Here we don't need to use the lifecycle activity anymore and we can just use the normal AppCompat activity, and here the flow will be the same.

LCA Demo 1
Now we will go over to our demo. We have our Crypto Boom App, we will identify components, which have activity lifecycle-dependent logic and see how we can refactor them in a way to simplify our activity and to make them lifecycle-aware. We will implement the LCA APIs and the LCA logic. If we take a look at our onCreate method in our activity we can see something similar to that. We have our bindViews code and we are initiating our tracker. After our tracker is initiated we will call the trackOnCreate method, which will invoke the logic of sending the tracking event related to this method. In addition, we do some initialization regarding our location services. Both of these components have lifecycle events-related logic. This would be a good start. We will refactor our Tracker component and our location component. Let's open Android studio and open our demo application. I did some initial refactoring steps in order to simplify this demo. The first thing I did I added an abstraction level, which called the TrackingActivity. This activity will contain our Tracker component and our MainActivity will extend this TrackingActivity. In this way we could use the TrackingActivity for all future activities we want to implement, and they would be able to use our tracker. Another refactoring step I did is to take our tracker code from our MainActivity and put it in its own class. In this way we follow the single responsibility principle, as you remember is the first SOLID principle. Let's go ahead and open our new Tracker class. Here we can see that the code is the same as our old code. In order to take advantage of the lifecycle-aware APIs first we need to implement the LifecycleObserver interface. Then we will use our context, cast it to our AppCompatActivity and call the lifecycle. Then we will register our Tracker with the addObserver method. Next, we will add the respective annotations for the respective lifecycle events. Here we have the ON_CREATE, ON_DESTROY, ON_START, ON_RESUME, ON_PAUSE, and ON_STOP. The annotations are pretty simple to understand, right? In addition, if we go back to our MainActivity we want to delete our Tracker component and make sure our activity extends our new TrackingActivity. In addition, now we can get rid of all the code related to our activity lifecycle as the only method we call there is tracking our lifecycle activity events. As you can see, we already saved a lot of lines of code in our MainActivity and our code is more structured. In addition, we will add some logging for our tracking methods in order to check and locate that the methods are really called. Let's run our code and check that it is working as expected. As we can see, our tracking methods are invoked properly. Of course we are getting some error response from the network because we are trying to post to the tracking information to the Google website, as a dummy. If we were to send our app to the background we see the following, our OnPause and OnStop methods have been tracked. If we click it again, we can see the corresponding activity lifecycle events. So, we achieved our goal, our implementation is working and we implemented the new lifecycle-aware component. But did we forget something? Yes, we did. Please don't forget to clear the reference to our lifecycle observer by calling the removeObserver on the onDestroy method. This is very important in order to make sure that our activity won't be leaked. Another feature of the lifecycle-aware component APIs is we have the possibility to query the current lifecycle event from our lifecycle owner component by simply calling the getCurrentState method of the lifecycle object.

LCA Demo 2
Welcome back. So after we finish to refactor our tracker using the lifecycle-aware components we will do the same with our location-related code. First I did some prerefactoring steps in order to make our activity a little bit shorter. I defined the following classes in their own file. I moved the CoinModel, the Divider, and our MyCryptoAdapter. This is another baby step in order to make our activity shorter and more readable. Next, I created a new class called MyLocationManager and put it under the location package. This class will represent all the location-related logic and will be lifecycle-aware. Let's open our MyLocationManager. Here we can see that our MyLocationManager implements the LifecycleObserver interface, same implementation as our tracker. As you can see I moved all the location-related components to be part of our MyLocationManager. Here we have our location client, our GoogleApiClient, and our LocationRequest. In addition we have the reference to our tracker instance because we want to track the location changes of our user. Next, we are using the OnLifecycleEvent annotations. In this case, we use the ON_START annotation in order to do some location-related initialization code. And the ON_STOP annotation in order to disconnect the API client and remove our lifecycle event observer. I took the rest of the code from our original MainActivity. Here we have the location callbacks and our buildGoogleApiClient method, which is in charge of the connection of our GoogleApiClient. Every time the location of our user will be changed the onLocationResult method will be called and we will call our tracker in order to track our user's location. Next, I created a new activity called LocationActivity. This activity will contain all the logic related to the runtime permissions, which we need in order to ask for the user for its location. This class will extend our TrackingActivity and later on our MainActivity will extend this LocationActivity. In that way we can use the location functionality in future activities as well. It's just adding another abstraction level, which will be more useful for later use. Here we can see that we have our myLocationManager component and we initialize it with our tracker. In addition, we call the runtime permission logic in order to ask for the user for its location and we will use the getLifecycle method in order to add an observer for our activity's lifecycle events. The rest of the code was taken from our original MainActivity, nothing interesting here. We check if the user gave us permissions to track his location, and if he did we will call our myLocationManager initialization code. Last, but not least, we will change our MainActivity to extend our new LocationActivity and not our TrackingActivity. If we want to create a new activity in the future and we want it to use location logic we just need to extend our location activity. It is very useful to add multiple abstraction levels in order to reuse our functionality and make our code more modular and readable. At that point I want to bring to your attention that our MainActivity is only 200 lines long. As you saw, we didn't do major changes and the refactoring was pretty simple. If we run our code on our emulator, and we will simulate a location change, we can see that if we open locate our MyLocationManager go to the location of it and our tracker is sent to the web. In addition, we could see it locate that our myLocationManager init was called, which indicates that our on lifecycle event annotations are working and their respective methods are called.

Comparison and Summary
Let's go ahead and try to have a basic overview of the changes we did in our app's architecture. At the beginning of this module, we started with one activity that looked something like that. We had only the MainActivity which contained all the different components of our application. The activity was very lengthy. It had approximately 500 lines of code, and it contained all the different application components. It didn't have any architecture really because we implemented all the application's logic in one class. After learning about how to implement the lifecycle-aware components and adding some obstruction levels, our app's architecture looks similar to that. We created a TrackerActivity, which contained our Tracker, and it is an LCA component, aka lifecycle event aware component. This activity is in charge of tracking the activity lifecycle events. In addition, we implemented a LocationActivity, which extends our TrackerActivity, and this activity contains our MyLocationManager, which is also an LCA component. In addition, this activity is in charge of tracking the location changes of our users and contain the runtime permissions logic, which is needed in order to ask the user for its location. Finally, our MainActivity extends our LocationActivity and contains all the other different components of our application, mostly related to the UI, to our views, and to our network logic. This is the basic structure of our application currently. By doing this refactoring, we assure that if we want to implement future activities that they're using, the LocationActivity or the TrackerActivity functionality, we can do that without writing any additional code. Please pay attention of how our application's architecture is evolving during the next modules of this course. Let's summarize this module. During this module, we learned how to use the lifecycle-aware components library from Google, and you understood its advantages. We learned that using the lifecycle-aware component will decouple the lifecycle logic per component, and it made our activity lifecycle methods to be shorter. In particular, we learned how to implement the LifecycleObserver and how to use the different OnLifecycleEvent annotations. In addition, we learned how to query the current lifecycle event and how to register and unregister the LifecycleObserver. In addition, we did some additional refactoring to our God class. At the beginning of the module, our MainActivity contained all the logic of our application, and we broke it down into multiple activities. We added some obstruction layers, including our TrackingActivity and our LocationActivity. These were the first steps towards a well-structured application architecture. I welcome you to join me in the next module where we are going to learn about the ViewModel and how to use the live data framework, which will give us the benefit of having the asynchronous data updates in our application.

Using ViewModel with the LiveData Framework
The ViewModel Component
Hello everyone, and welcome back to the next module of our course. In this module we are going to talk about and demonstrate how to use the ViewModel from the Arch Components library and how to implement the new LiveData framework. When we learn about their advantages, we will compare our old implementation with our new implementation that contains the new architectural components. Let's start. First, we are going to talk about the MVVM pattern that we mentioned before and the ViewModel component. Usually our MVVM pattern includes a ViewModel component. We will first self-implement it without using the Data Binding Library from Google in order to simplify and isolate the advantages of this component. In our case our activity will be in charge of updating the views, in contrast to the case when we are using the Data Binding Library. Our initial MVVM implementation will work the following way. First we will implement the simple ViewModel, which will be in charge of fetching the data from the network or from the local storage. Then we have our view, in our case our MainActivity, which is charge of updating our views on the screen. Our activity will notify our ViewModel on user interactions or on the situation where it wants to fetch new data. In our ViewModel class a method will be invoked and will refetch the data from the network, and it will notify our activity to update the UI via our screen interface. Our MainActivity, of course, will implement the same screen interface and we will bind it to our ViewModel component. Let's go back and talk about the activity lifecycle. As we demonstrated before, our activity lifecycle will start with the onCreate method. Then our ViewModel will be created. We will continue with the onStart and onResume. And, if the user is going out from our application, eventually our activity will be destroyed. As long as our activity is not destroyed, our ViewModel will be alive. It can be a disadvantage because sometimes our ViewModel will hold large amounts of data, will contain other components, and will have a large memory footprint. When our activity will be destroyed, our ViewModel will be destroyed as well. The next time our activity will be launched we will need to reinitiate our ViewModel with all its related components, which is of course wasteful in terms of memory. On configuration changes the activity is destroyed and is being recreated by the operating system. There is a native mechanism for saving the data state using the onSaveInstanceState and the onRestoreInstanceState. The problem is that it's not meant to be used with large datasets. Our problem is that on our activity recreation our ViewModel instance will be recreated as well. It is very wasteful in terms of memory. So how we can we optimize the problem? Google came up with a new architectural component called lifecycle. ViewModel. We will demonstrate and implement that too. This new component will be initiated with a scope and very importantly will be initiated only once. The ViewModel instance will survive configuration changes, such as screen rotations. The advantage in this case is that after the activity is recreated the old ViewModel instance will be used, all the UI-related data will be saved, and the ViewModel will be bound to the lifecycle scope passed into it.

Demo: The ViewModel Without ARCH
Let's go ahead and start with our demo. We will go back to our Crypto Boom App and implement our own ViewModel. We will call it CryptoViewModel. Next we will examine our self-implemented ViewModel, see its reaction to configuration changes, and finally, we will add the arch ViewModel component and compare both implementations. Let's go ahead and open Android Studio. I went ahead and defined a couple of new classes. First I defined an interface called MainScreen. Our MainScreen interface is a pretty simple interface and contains only two methods. The first method is updateData, which will be used by our activity in order to load the data in our adapter. And the second method is called setError. In case if our ViewModel generated some errors we will propagate it to the activity in order to show a toast on the screen. Next I defined a class called CryptoViewModel. This is going to be our self-implemented ViewModel. Here we can see we have the bind method, which will bind the ViewModel to our activity. And we will use the MainScreen interface in order to call methods within our activity. Next, we have our unbind method. This method will just make sure to clean the activity reference in order to prevent a memory leak. At the next step I moved all the network-related code into our ViewModel. Here we can see that we have the fetchData method, which will be called from our activity. It's the same call from before. We have one callback for a successful response and one callback in case of an error. Last, but not least, I moved the storage-related code into the ViewModel as well. Here we have the two methods from before. Here we are just writing the API response into the local storage and reading it in case of a network error. Same as before, if our API response is successful we will call the EntityToModelMapperTask in order to map our API response into our CoinModel. And if everything ended without any error we will call the updateData method in our MainScreen interface. The last modification I did is to our MainActivity. Here you can see that our MainActivity is implementing our MainScreen interface. In our onCreate method we will initiate our ViewModel and use our MainActivity in order to bind it. Next, we will fetch the data. A very important point is that we have to unbind our ViewModel from our activity before the super. onDestroy is called in order to prevent our activity from leaking. At the bottom or our MainActivity we can see the two MainScreen interface callbacks. The first callback is our updateData, which is receiving as an argument the list of our CoinModel. Every time our updateData method will be called we will then set the items on our adapter and show it on the screen. In case of an error the setError method will be called and we will show the error message on the screen using a toast. As you can see, after adding the ViewModel and encapsulating most of the logic within this class our MainActivity is very compact and it has around 100 lines. The only responsibilities of our MainActivity currently is to bind the views and show the data on the screen, as well as to register all the view's listeners. One example for listeners is where set the on refresh listener in case the user is swiping the SwipeRefreshLayout. In that case we will call our ViewModel and call our fetchData method in order to fetch fresh data from the network. If we run our code and launch our Emulator we see the following. We can see that after launching our activity our ViewModel was created. If we rotate our emulator in order to trigger the configuration changes, we observe the following. (Working) As you can see, every time the Android operating system will destroy our activity and recreate it, our ViewModel has been recreated as well. This is of course not efficient in terms of memory. This situation leads us to the question, is there a different way of implementing the same thing, but in a more memory-efficient way. As I assume that you are familiar with the software world, the answer to this question is almost always yes. We will now implement the new ViewModel component from the Android Architecture Components new libraries.

Demo: The ViewModel with ARCH
Let's go back to Android Studio. Let's open our app's build. gradle file in order to add the necessary dependencies. Here we will just add one dependency, which is the arch. lifecycle:extensions library from Google. This library contains both the ViewModel component and the LiveData framework, which will we use later on in this module. Next, we will sync our project. After the project is synced we will open our CryptoViewModel class. Next we will modify our CryptoViewModel class to extend the new ViewModel component. In addition we will override the onCleared callback from the ViewModel class and add the log entry. In this way we can see when this method is being called. You will understand what I'm talking about in a couple of minutes. In the ViewModel's documentation, it's clearly written that we should avoid any references of Android components in our ViewModel because the lifecycle of our ViewModel can be longer than the lifecycle of one activity or fragment. Here we have a reference to our MainScreen interface, which is our MainActivity class. But don't worry; we will get rid of this reference after we will implement the LiveData APIs. In this case, we just need to make sure that we are clearing the mView reference before the activity is being destroyed. Next we will modify our MainActivity by deleting the CryptoViewModel constructor and add the new call for initializing our new ViewModel component. Here you can see that you are calling the ViewModelProviders class in order to initialize our ViewModel. We will define it with our lifecycle owner, in this case our activity, and define the ViewModel class we want to initialize. It's as simple as that. If we run our code we can observe the following, I added another floating action button that will just exit our application. This will be needed in order to demonstrate when the onCleared method is called. If we do the same operations as before, and we will change the orientation of our screen, we observe the following. If we look at Logcat we can see that our ViewModel constructor was called only once. In addition, we can see that during the on configuration changes our activity was destroyed and recreated, but our ViewModel wasn't recreated. This gives us the benefit in terms of memory. In addition, if we click the exit fob we can see that the onCleared method was invoked. Currently our onCleared method is empty, but it's a useful callback for us developers and we can use it in order to release all unnecessary resources. Another observation is that the onCleared method of our ViewModel class was called before the onDestroy method of our activity. This makes it safe in order to release all the resources related to the activity as well. Another advantage of the new ViewModel component is that it lets us the possibility to share data with different Android components. For example, we can create a fragment and initialize it with the same ViewModel component from our activity. And in that way we can share data between the different components. Please join me in the next section of this module where we are going to incorporate the new LiveData framework for asynchronous data updates within our ViewModel.

The LiveData Framework
Welcome back. In this section of the module we will talk about how we can handle data updates asynchronously. Of course, no Android app is interesting without data. We have different ways to get data updates in our application. In this part we will talk about the LiveData framework from Google. Let's talk about the typical situation we often need to deal with in our applications. Android apps often need to fetch data asynchronously. In our demo app we are fetching the cryptocurrency market data for different cryptocurrencies. And we need to handle all the resources related to our data manually. The problem is that it often involves maintenance code in order to release our resources, our components often need to be lifecycle aware, and our resources are newly allocated on every configuration change. In order to easily handle these problems, Google recently released a framework called LiveData. So what is LiveData? LiveData is an observable data holder, it utilizes the observer pattern, which you are probably familiar with, and it's a lifecycle-aware component. The advantages of LiveData are that we no more need to manually handle lifecycle events, the data is always up to date, and using LiveData we will share resources, which will not be wasteful to memory anymore. You can think about it like a light version of RxJava. Our LiveData objects will survive configuration changes because they will be part of our ViewModel component, and when we get updates only for active foreground components. You can think about LiveData in the following way. LiveData allows async data access and decouples the access to our data from the component who consumes it. You will soon understand what I'm talking about. In our demo we have our Crypto Boom App, we will wrap our data fetching with a LiveData object, we will add a update interval logic in order to define what is the interval we should fetch the data from the network, and use the transformation util classes in order to map our data to different data objects. Finally, we will use our ViewModel component in order to share data with a UI list fragment.

Demo: Utilizing LiveData Inside Your ViewModel
So let's open our demo app and open our CryptoViewModel class. In order to utilize the LiveData objects we first need to define them. Here you can see I defined two LiveData objects, one for our market data and the second one for any error messages that we want to send to our activity. In addition, I defined here an ExecutorService with a pool of 5 nThreads. We will use this in order to demonstrate the usage of LiveData objects from a background thread. In addition, we will use a background thread in order to read the cache data from our disk. At the next step I defined three methods that will return our LiveData object. The first method is getCoinsMarketData, which will return the LiveData object, which will contain our market data. The second method is getErrorUpdates, which will return the LiveData object with our error messages and finally, another method called getTotalMarketCap. Now this is where it gets interesting. Often we have a situation where we want to input a LiveData with one object type and output it with a different map data structure. In this case, we will use the transformations util class from the LiveData framework. Here you can see I'm using the map method in order to input our LiveData of type list CoinModel and map it into a double variable. Here we just calculate the totalMarketCap of all the cryptocurrencies. Please note that every time mDataApi will get a new value this method will be invoked. It's important to remember that the code within the map method will be executed on the main thread and you want to make sure not to do any heavy calculations there. If you have a very big dataset you probably want to avoid and move this execution to a background thread in order not to block the UI thread. If we open the implementation of the transformation. map method we can see the following. The map function will get this input a LiveData object of type X, which will be the source and another function that will be in charge of the mapping. Then a MediatorLiveData object will be initiated and the source has been added to it. The MediatorLiveData class is just a LiveData object with multiple data sources. If we add multiple sources, the MediatorLiveData class will propagate the new value, as long as one of the sources had it at the update. As you can see here we only want sources being added and when the data is changed we are calling our mapping function and propagating the new value to it. Finally, the MediatorLiveData object result will be returned. This will be the LiveData object that we are passing to our fragment. Remember, every time you want to learn more about other's _____ implementation don't hesitate to dig into the code. Don't be afraid, just remember that all this code was implemented by people like you and me. Finally, we modified our fetchData method. Here, if we get a successful API response we're just going to write the response into the disk, like before, then we will map our entities into our models and use the setValue method in order to set the fresh data into the LiveData object. This callback will be called from the UI thread, this is why we are using the setValue method. In case of a network error or an API error we have our error callback. This callback as well will be called on the UI thread. Unlike before, if there is no available API data to show in our application we will here first set the value of our error LiveData in order to show it on the activity using mError. setValue and we will input it with the error message from the API. In addition, we will want to rid the last cache data from the disk in order to show in our list. Here we will call our mExecutor. execute method in order to call a background thread, read the last cache data from our local storage, map it into our model, and update the value in our LiveData object in order to show it in our activity. This code will run on a background thread. This is why we have to use the postValue method and not the setValue method from our LiveData object. Remember, if you want to update the data in the LiveData object, from the UI thread you have to use the setValue method. But, like here, if you want to update the data from a background thread you will have to call the postValue method. This is very important to note. If you will try to update the LiveData object from a background thread using the setValue method an exception will be thrown. In order to consume the data from our

Demo: Utilizing LiveData Inside Your Activity
LiveData object we will do the following. Let's open our new MainActivity to see the modifications I did. In our MainActivity we initialize our ViewModel component as before, but in addition, we will initialize two observers. One observer that will consume our List CoinModel data and the second observer of type String that will consume our error messages. In our onCreate method we will call our getCoinsMarketData method, which will return our LiveData object of type list CoinModel and we will call our observe method with our lifecycle owner, in our case our activity and our data observer. As we stated before, LiveData objects are lifecycle-aware as well, which means that our observer will get data updates from our LiveData object only if our activity is in an active state, which means only if the activity is in the foreground. This is very useful because if the operating system decides to move our activity to the background, our data observer won't get any more data updates. And we don't need to take care of any clearing of resources. In addition, we will call our getErrorUpdates method, which returns a LiveData object of type String and we will observe it using our errorObserver. In this case, if we get any errors from our ViewModel class we will show a toast on the screen. Another modification I did is to our setOnRefreshListener callback. Here I defined a timestamp and updated every time newly fresh data is fetched from the network. And if the user pulled to refresh the data before this interval is reached we won't do any network requests. This is kind of a caching mechanism in order not to abuse the API you are requesting the data from. In contrast, if the user will pull to refresh after 10 seconds have reached we will just fetch the data freshly from the network. The last component I added is the UILessFragment class. On the onActivityCreated method we will initialize our ViewModel component, which will be the same instance that the activity is using as well. Please make sure that where you are calling the ViewModelProviders class and provide it with the current lifecycle owner you will use getActivity in order to get the same instance that the activity is using as well. If you will call the of method with providing it with this, which means that the lifecycle only reserves our fragment, two different ViewModel instances will be created, and we won't get the data updates If we run our code, we can see the following. We can see that our ViewModel was created and we got an API response with the different cryptocurrencies. If the user now will swipe to refresh, the same will happen. But if the user will swipe to refresh before the 10 second interval we can see that we are not fetching a new data. If we now activate flight mode and restrict our emulator from having any internet connection we can swipe to refresh again. We can see that we got a network error and we loaded the last cache data from our local storage. We can see as well that this code snippet was executed on the background thread, one of our threads from our executor service. If we give the emulator internet access again and pull to refresh we will fetch fresh data from the network again. If we look at our UI list fragment we can see that every time the LiveData object of our list CoinModel is getting new data, our transformation. map code is invoked and we recalculate the total market cap of all coins. Let's go ahead and compare our old and new implementations.

Comparison and Summary
The structure of our MainActivity before and after the modifications we did with our activity, which implements our main screen interface. then we had our old ViewModel component, which had the reference to our main screen interface our activity. Then when our activity was loaded on the screen we would call the data loading logic. The fetchData method would be invoked and we would call some asynchronous API call. Then we would do some more mapping logic in the background and we would call a method from the screen interface in order to update the UI on our activity. With this implementation we had the following disadvantages. We had to call the unbind method within our ViewModel in order to clear the screen interface reference. In addition, we had handle clearing resources manually, our ViewModel instance would be recreated every time the configuration changes, and every time the activity would be destroyed and recreated, last, but not least, it was pretty inefficient in terms of memory. As we observed, this picture is not yet so optimal. After our modifications it looks something like that. We still had our activity, but here we implemented the new ViewModel from the arch. lifecycle package. We would call some data fetching logic, and the only difference is that now we utilized the LiveData objects. Every time it would fetch new data from the network we would update the stream in our LiveData objects and our activity will observe changes using observers. Every time we would call the setValue or postValue methods from the LiveData object APIs the onChanged method in our observers would be invoked and the data would be updated on our screen. The advantages of these implementations are we have no need for unbinding code, it's a lifecycle-aware component, our ViewModel doesn't contain a reference to our activity in this case, and it's more efficient in terms of memory. Let's go ahead and summarize this module. First we changed our app's architecture by introducing and implementing the following components, arch. lifecycle. ViewModel and arch. lifecycle. LiveData. In addition, we combined these two components together. We learned that the ViewModel component, it's a lifecycle-aware component, it's created only once per lifecycle owner, in our case our MainActivity, last, but not least, it contains our data access logic and other application-related logic. The advantages of the new ViewModel components are, it survives configuration changes, it's efficient in terms of memory, and we can share it between different components. In our example, our ViewModel was shared between our activity and our fragment. The second component we utilized is the LiveData framework. It's a lifecycle-aware component as well, when using it we will get data updates via observers, in particular we learned how to update the data inside our LiveData objects from different threads, and how to share the data between multiple components. We observe that the advantages of the LiveData framework are the following. It's a lifecycle-aware component, it decouples data access logic from the one who consumes it, and it's bound to a lifecycle owner. If we go ahead and compare the architecture of our application, before and after our refactoring and modifications during this model we can see the following. Our MainActivity contained most of the logic of the app. In addition, it was a couple of hundred lines long, and the most of our application components were contained within our MainActivity. After our modifications our app's architecture looked a little bit different. We still had three activities, which we can look at it as our presentation layer, but with one main difference. Our MainActivity now contained a new ViewModel component, which had lifecycle data objects within it. In addition, it contained our persistence logic and our external API logic. Alongside with our ViewModel we had the lifecycle-aware components that we implemented on the previous model. We can look at these components as our business logic layer. We observed that we have more components, but each component is shorter, much shorter than the first version of our MainActivity, at the beginning of this course. Please join me for the next module where we are going to learn about the persistence solution room and learn how we can use a database with only 20 minutes of learning. See you soon.

Persisting Your Data with the Room Persistence Solution
Persistence Introduction
Welcome back everyone. After we have learned how to use the ViewModel and the LiveData framework, in this module we will go deeper into our data layer, we will define it on its own module, and we will learn how to utilize the new Room persistence solution from Google in order to simplify the data access in the demo app. Let's start with some background. Usually, Android applications handle quite a lot of data. The common approach is to use the native SQLite database, which involves quite an implementation effort and contains mostly boring details. Let's talk about the advantages of persistence for a second. If our user's device has no internet access our application's data will be available. In addition, the loading of data will be faster, and it can save a huge amount of network traffic if the data is static. It means that in a lot of use cases the data doesn't change. And we need to load it from the network actually only once. Many developers ignore persistence solutions because they think that the amount of data under the device is unlimited and pretty cheap. But please remember that in some counties mobile data packages can get quite expensive. As we develop a universal app we need to think of all of our users. I produced a nice module about it regarding analyzing your app's network consumption. If you find this subject important I encourage you to go to my course Overcoming Common Android Performance Barriers and review the network module. In general we have two types of caches, a memory cache and a disk cache. Let's do a quick comparison between the two. Usually the memory cache is more expensive, it uses RAM, random access memory, and it's limited to the RAM available on the device or to a portion of it. It has faster access, and utilized for objects which are often used in our application. On the other hand, this cache is less expensive, usually uses local storage or a database, limited to the storage size on the device or to a portion of it, and it has slower access. And typically it will be used for the majority of our app's data. Let's give an example of a memory caching our demo app. Our app is using Glide for image loading, our app saves last-shown images in a memory cache for faster loading, and persists all loaded photos on disk to prevent undesired network activity. Using this memory cache we will fetch every unique image only once from the network. This will save our application huge amounts of network traffic, if our app is using imagery heavily, which is the case in a lot of apps. An example of this cache in our demo application is our app is loading data from the cryptocurrency API, its saves the last-fetched data on a LiveData object in memory, and it persists the data on the device's local storage. Again, it's very useful because we defined an interval for fetching fresh new data from the network. And if we didn't reach this interval we will always load the data from the local storage. Again, it will cut down our app's network usage. Let's review the code snippets related to the data storage in our demo application. Here we have our write data method. This method is doing nothing, but saving the JSONArray from the API response into our local storage. And the second method is in charge of reading the data from the local storage. It's a pretty primitive and inefficient solution, which we will soon optimize.

Demo: Data Layer Refactoring
Let's start with the first part of our demo. We have our Crypto Boom App, we will create a new module in order to separate our data layer from our presentation layer. In addition, we will move all the data-related classes to this new module, and we will create an abstraction layer, which will contain a repository and multiple data sources. Let's open Android Studio. As you can see here I created a new module named data. This module will be the data layer of our application. Let's open its build. gradle file. I moved the dependency or our Volley library for networking to be part of this module, but I used the keyword api in order to expose its API to our main apps module. If we take a look at the Jackson dependencies we can see that they are not being exposed to our app module, and we want to keep it that way. This is how we can use Gradle in order to hide some implementation details from our presentation layer. I did some prerefactoring and moved some classes into our new module. You can see that I moved our CryptoCoinEntity and our CoinModel to be part of our new data module. In addition, I defined a mapper called CryptoMapper that contains all the different mapping functions. This class will be used by our different data sources and our repository later. Then I defined an interface called DataSource. You can see that it's defined as generic and takes in type T. Here I defined two main methods, one for getting the data stream and the second one for getting the error stream. Our data sources will implement this interface, in that way we are abstracting the idea of a data source. Let's move on with our data sources. Our first data source is our RemoteDataSource. You can see it implements that interface from before. Here I just took all the API-related code and moved it to our new RemoteDataSource. You can see that I defined two LiveData objects, one for errors and one for the data itself. This code is very similar to our old code. Here, for example, you can see that we are using our mapper object tin order to map the JSON response from the API into our coin entity. And then we are setting the value in the LiveData object. Our second data source is our local data source, which is currently our local storage. Same as before, I moved our old code, which was related to saving the data and reading the data from the local storage into this class. Similar to our RemoteDataSource here we have as well two LiveData objects, one for the data itself and one for the errors. The only difference is that in our LocalDataSource our LiveData object is from type JSONArray and in our RemoteDataSource our LiveData object for our data is a list of CryptoCoinEntity. Now comes the interesting part. I defined another interface as our CryptoRepository.

Demo: The Repository
Here I defined multiple methods. The first method is for getting the LiveData object, which contains the data for our list. The second method is getting the LiveData object, which contains any errors that occurred in the process of fetching the data, and the third method, which returns the LiveData object with the total market cap, same as before. In addition, I defined here the fetchData method, which will invoke our data updates. Last, but not least, I defined a class, which will be the implementation of our CryptoRepository. Here you can see that this class, including the two data sources, remote and local, our CryptoMapper, and two MediatorLiveData objects. As you probably remember from the modules before, we introduced the MediatorLiveData class, which is very useful if you have multiple data sources and you want to merge them all together into one LiveData object. This is exactly what we are doing here. If we are looking at our class constructor we can see the following. We are adding the different sources to our mDataMerger LiveData object in the following way. First, we are adding our RemoteDataSource and defining the onChanged callback. Here, same as before, we are writing the data to the local storage after we have a successful API response. Then we will map our entity into our CoinModel and update the value in our LiveData object. This data will be streamlined and our UI will get the updates. The second data source we are adding is our LocalDataSource. Here we need to do some more mapping. If our repository decides to fetch the data from our local storage the following will happen. We will get the data update, then we will map our JSONArray into our coin entity and, and our coin entity in our CoinModel. Finally, we will update the value of our LiveData object. You can see that we are doing the same with our mErrorMerger mediator LiveData object. Using this mechanism is very useful in order to make decisions regarding where to load the data from. Here you can see, for example, that if our RemoteDataSource threw a new error we will send the message in order to streamline it to our UI, and in addition we will ask our LocalDataSource to fetch the data from our local storage. Using the MediatorLiveData class is very useful as it will get updated each time one of the sources has been updated as well. Next, I defined the create method in order to make sure that we are exposing only the CryptoRepository interface and not its implementation. In that way we can hide more implementations detail from our ViewModel and presentation layer. The last class I modified is our CryptoViewModel. Here you can see that I enhanced our implementation by extending the AndroidViewModel class. Using the AndroidViewModel class gives us the opportunity to get the reference to our application context, as we need it for our repository. For example, our LocalDataSource needs a context object in order to access the local storage. Our new ViewModel contains our CryptoRepository, which has been initialized once our CryptoViewModel constructor has been called. As you remember from before, this constructor will be called only once, which is pretty useful in terms of memory. If we run our code with our modifications we can see that the behavior didn't change. If we set the emulator to flight mode again our device doesn't have any internet connection, you can see that the error is being shown on the UI, and after the connectivity is available again, and we press the pull to refresh, freshly new data will be fetched from the network. So, our functionality is the same, but our implementation is much more robust because now we have an additional module which contains all the data layer of our application. This module contains really short classes that follow the single responsibility principle, and they are very compact. In addition we hide a lot of implementation detail from our presentation layer, AKA our app module.

Transitional SQLite vs. Room
Before we jump into our new persistence solution let's talk for a minute about the traditional SQLite implementation. Usually in our Android apps we are going to define our SQL database in the following way. Here, for example, we define our database schema. Then we will have to create an SQL helper and define what our database will do on onCreate, onUpgrade, onDowngrade, and so on. In addition, we need to implement mapping code between our cursor objects into our Java objects, we might need to create custom content providers, and we'll have to take care of migration in case of data structure changes. The problems with that approach are, we are dealing with low-level APIs, which are time consuming to implement, no compile writing verification of raw SQLite queries, so for example, if we define our custom query ad our SQL syntax is wrong, we will only know about it after our application is running and it will throw an SQL exception, and can cause problems and runtime errors after the data is changed. The fact is that using this approach we have fairly a high amount of boilerplate boring code and we will need to implement our SQL components over and over again, although they have the same functionality. So what is our alternative? Recently, Google released a persistence solution called Room. Room gives us the opportunity to define the local database using a simple abstraction layer that utilizes annotations. The advantages of Room are it's a lite persistence library, it uses powerful annotation to define our database scheme and objects, and it uses compile-time verification to show syntax errors, mostly SQL syntax errors. Using Room we can write less code for implementing core functionality, it's an entity-centric approach, and we don't have to deal with low-level components likes cursors, which can be quite painful. By default, Room restricts the access to our database from the UI thread, which is a huge advantage as database operations can take a quite a while and we wouldn't want to block our UI thread as it can influence our user experience. It supports async queries using LiveData and RxJava, and it has an easy approach for defining migration in case of schema changes. The Room database contains three main components. We have our app and we have our room database. Then we will need to define a data access object, AKA the D-A-O or DAO, and we have our entities. Our data access object will communicate with our Room database and will define which functionality we want to implement. The DAO object is the gateway to our database. And our app will use the entities for our UI. Our DAO will fetch the entities from our database and will update them as well. Let's talk about the first component, entities. As mentioned before, Room utilizes powerful annotations in order to define our entities. We will use the entity annotation in order to define an entity. Here, for example, you see that we defined the idea as a primary key. The primary key, of course, has to be unique. In addition, we can let Room know we want to ignore some attributes in order for them not to be stored in our DB. Using our Entity annotation we can specify some custom parameters. Here, for example, we define a tableName as players, using the ColumnInfo annotation we can define the name of the column, and we combine more than one field as a primary key And there is more. We can use the Index annotation in order to define indexes for faster access from our database, we can define relationships between entities. Here, for example, we defined a ForeignKey within our player entity, which will be the id attribute in our CryptoCoinEntity. This is a typical functionality in a relational database as we know it from SQLite. There are more annotations available and I encourage you to go check the Room documentation.

Demo: Room Entities Implementation
Let's talk about our demo. In this part of the demo we will define our entity, define a table, and define indices. In addition, we will define our column names and use some other annotations. Okay people, so let's open Android Studio and see how we utilize the Room Persistence Library. First things first, let's open our data model Gradle file. As you can see here, I added the necessary dependencies of the Room library. We have two dependencies. First is the Room runtime environment and second is the Room compiler. As you can see here we don't expose any Room APIs to our app module, we want to keep it that way because we want to hide the implementation details of our data layer, our presentation layer or app module has no idea that we are using the Room database. Next, let's open our CryptoCoinEntity. As you can see here, I use the Entity annotation and define the tableName as coins. In addition, I defined multiple indices. We have an index on the field symbol, and index on the total_supply attribute, and an index that will combine two attributes, id and symbol. In addition, I defined some column names, and our PrimaryKey. In this case, our primary key will be the symbol as it is unique for each coin. Please note that there are some attributes of our entity which don't contain the ColumnInfo annotation. These attributes will be stored with a column name as the attribute name. Next, I decided to ignore some of the attributes as we don't want to store them in our database. Depending on the use case you will determine which attributes need to be saved and which not. If I change the string id to be blah, for example, the following will happen. If we run our code the Room Persistence Library will throw us an error. This is very powerful because Room lets us discover errors before our app is running. Now we will learn about Room's data access objects.

Room Data Access Objects and Database Definition
After we defined our entity the next component we are going to talk about is the data access object. The DAO object is the way how we access our database. It uses simple annotations as well. Inside a DAO object we define the functionality of our database. This is an example of a simple DAO object. As you can see we use the Dao annotation and we use the insert, update, and delete annotations in order to define simple SQLite operations. In addition, we define a conflict strategy. I will explain a little bit more about the conflict strategy in our demo. Using the DAO object we can define raw queries using the Query annotation. It lets us pass parameters to the queries as well, and it runs real-time syntax checks. As you can see here, we have a typo in the SELECT keyword, then the compiler will find the error and show us with a red line. Finally, we need to define our database. We do that by defining an abstract class extending the RoomDatabase. Here we define the database name and we simply build a database as a singleton. Here we use the Database annotation and we define the entities. In our case, the only entity is our CryptoCoinEntity. And we define the version as well. The version number is useful later on if your data scheme changes, then we can define a data migration strategy. In our database definition please don't forget to define a public abstract method, which returns our DAO object. Room will automatically know and generate the necessary SQL code in order for our coinDao to be available. This is going to be the method we are going to use in order to access our coinDao object.

Demo: Room Dao and Database Implementation
At this part of this demo we will do the following, we will define our CoinDAO object and define the way we access the data in our database. We will define the conflict strategy, define our database, and connect all the components together. Let's open Android Studio and go to our CoinDao class. Here you can see that I used the Dao annotation. The first method I defined is insertCoins. Here you can see that I used the Insert annotation in order to notify Room that I want it to generate the respective SQL insert statement. This is all done for us automatically. This is very useful because instead of defining the queries ourselves, Room is doing all the hard work for us. This is very powerful. Within the Insert annotation I defined an attribute for the conflict policy. Here I used the conflict policy REPLACE, which means that if there was any conflict when Room is trying to insert our entities it will just replace the old entities, which are already in the database with the new ones. There are different conflict policies, and I encourage you to check the Room's documentation to learn more about the various policies. The second method I defined returns a LiveData object with the list of our entities. This LiveData object will be later used within our repository. The next method will just return a list of coins. We will use that in case our RemoteDataSource will return an error and we will need to fetch our entities directly from our database without using the LiveData object. I defined some additional methods, which take some parameters in. As you can see, Room lets us to define a query with input a parameter like limit or symbol. In this method you can see that I'm fetching the coins with a limit of objects, or here, for example, I'm fetching only the coin with a particular symbol. Please note that if we are entering an SQL statement with an error Android Studio will indicate that we have a syntax error. After our DAO object was fully defined we still need to define our database. Let's open our RoomDb class and inspect my modifications there. As you can see, I created an abstract class, which extends the RoomDatabase class. This class has to be abstract. Here we just defined a database name and expose a public abstract method that returns our CoinDao object. As written in the Google documentation, initializing the Room database can be a costly process. This is why you are defining it as a singleton and making sure that the DB has been initialized only once. Last, but not least, I modified our LocalDataSource. Instead of implementing a DataSource of type JSONArray, now our LocalDataSource will implement a DataSource of type List of our CryptoCoinEntity. In addition, our local DataSource will now contain an instance of our RoomDatabase. As you can see, on our getDataStream method we are calling our coinDao object and returning our LiveData object, which contains the data from our Db. Here, if you write new data to our database we will again call our coinDao object and call our insertCoins method. In case of an exception occurring in that process we will just catch it and update our error LiveData object with the exceptions message. In addition, I defined another method in order to get the data from our database directly, without wrapping it with a LiveData object. This will be used later if we get some errors from our API. If we run our code again we can see that our functionality is the same. If we look at Logcat we can see that the onChanged callback is called multiple times, once for the RemoteDataSource, and once for the LocalDataSource. This is redundant. What actually happens here is that once we are fetching the data from the API we are as well updating the data on our database. And for any change of our data our mDataMerger onChanged callback is called. We can actually comment out the second call of our addSource method, because in the situation where the API returns an error we will fetch our data directly from the database and update our mDataMerger LiveData object. If we run our code again, we can see that the onChanged method is called only once.

Data Migrations with Room
So now that we have a fully-functional database in our application, let's talk about how we can do data migrations with Room. It's a typical situation where our data scheme is changing and we need to do some data migrations. Room is offering a simple mechanism in order to deal with data migrations. It will throw exceptions if something is wrong or if the migration is missing, and we will need to define a migration for each database version. For example, let's say we take our CryptoCoinEntity and we want to add a new attribute to it. Here I added a description attribute. If we were run our application again we get the following exception. Room will throw an IllegalStateException and will state that it cannot verify the data integrity. It will even give us a hint and say that we forgot to update the version number. In order to solve that we will need to update the version number in our RoomDb class. If we will try to run out code again we will get another exception. This time Room will complain that we didn't provide a migration from version 1 to 2. Now we have two options. Either we want Room to destroy the old database and create a new one with our new modification by adding the fallbackToDestructiveMigration to our builder class; in that case our users will lose their data. That is probably not the optimal solution. Or we need to specify the migration between version 1 to 2. Here, because we added the description attribute, we will need to alter our table and add a description column. In addition, we will need to add the migration by using the addMigrations method in our builder class. Now if we run our code again our application will run and no exception will be thrown, and our data scheme will be updated with no problems. In case of more complicated migrations I encourage you to check out the data migration section in the Room documentation. Let's go ahead and summarize this module.

Summary
We started by talking about data persistence in Android. We talked about the advantages of persistence and the differences between memory and disk caches. Then we continued with refactoring our demo application and structured a proper data layer. In addition, we talked about the traditional SQLite implementation. We did all that in order to introduce the new Room Persistence Library. We talked about its different components, we learned how to define the Room entity, data access objects, and how to define the Room database, and we learned how to leverage annotations in order to create common database functionality in two lines of code. As we saw before, room offers us a simple abstraction layer for database functionality without dealing with any low-level APIs. In addition, we learned how to utilize Room and combine it with the LiveData APIs, and we learned how Room deals with data migrations. If we compare the architecture of our demo app before and after this module we see the following. Before this module, where there are activities this was our presentation layer, and where there are ViewModel, which contained our LiveData objects, where the remote API code and the local storage logic. Last, but not least, we had some lifecycle-aware components. All these components could be defined by our business logic layer. After we did the data layer refactoring and integrated the Room Persistence Library the architecture of our application looks something like that. We still have our activities in fragments, then we have our ViewModel, with some LiveData objects, and our lifecycle-aware components. Until now everything is the same. The only difference is that now we have our CryptoRepository and it contains two different data sources. One a RemoteDataSource, which contains the remote API's logic, and the LocalDataSource, which contains our model, our Room implementation, which communicates with a low-level SQLite instance. Now we have three obvious layers, our presentation layer, our business logic layer, and our new data layer. Please join me the next module of this course where we are going to learn how to use the new paging library in order to fetch our data more effectively. See you soon.

Testing Your Architecture
Introduction
Welcome back to the last module of this course. After modifying our architecture list application into specific layers and integrating the arch components now our application has a clear architecture. Last, but not least, in this module we are going to talk about on how we can test our architecture. Testing is a very important subject and sometimes developers forget that. There is no doubt that writing automated tests can minimize the manual testing effort, especially if we are talking about very complex applications, and if you are working with a continuous integration environment. At the beginning of this course we talked about testable software. Let's recap that for a second. What does it mean? The ability to test each component separately, low maintenance effort of test code, and efficiency in terms of testing effort and code coverage. Maybe you are already familiar with the following pyramid. In general, we have three kinds of tests. The first type is unit tests, the second type is integration tests, and the last type is UI tests. I want to bring it your attention that there are many more test types and that software testing is a discipline by itself and a very broad subject. Some people are specializing in testing software and the subject shouldn't be trivial, but in the scope of this course we are going to concentrate specifically on these test types. Let's overview in particular each one of these test types. Unit testing is used in order to test the functionality of one component. If this component needs to interact with the operating system we will need to mock the Android operating system, and sometimes we will need to mock other components. In our application we are using a lot of interfaces, which can be really useful because if we need to mock one component we can just provide with an empty implementation of the interface in order to make sure our component is functioning. Integration tests are used in order to test multiple components and to inspect the interaction between them. Often we run the integration tests on an emulator or on a real device. Last, but not least, we have the UI testing. UI testing is used to make sure that the UI flow is working as expected, makes sure the user sees what he's supposed to see, and these kinds of tests are always run on an emulator or on a real device. Now we are going to talk about testing in the context of our arch components. The fact that we are using arch components in our application implies that we can test each component separately. Our components are small and relatively easy to test, and or components are modular. In addition, it's simple to mock other components if needed.

UI Testing
The first type of testing we are going to talk about is UI testing. In general, there are two kinds of UI testing in the Android world. The first kind is specific app's UI testing and the second kind is random UI testing. For a specific app's UI testing there are multiple frameworks we can use such as, Appium, Calabash, and Espresso. Espresso is a framework from Google for writing automated UI testing. If app-specific UI testing is interesting for you I encourage you to watch the Espresso Fundamentals course in the Pluralsight library. This course is great and contains all the important bits and bytes for you to start writing automated UI tests using the Espresso framework. The second type of UI testing is random UI testing. We are going to demonstrate how, with minimum effort, you can run some random UI testing on your application. Google provides with a very easy tool in order to run random UI scenarios on our application. It's called UI/Application Exerciser Monkey. Using the Exerciser Monkey it's possible to run random UI tests using a command line tool, and it's very easy to use. It can run on the emulator and it's usually used in order to perform stress tests on our application. This tool can be configured, in particular we can define the number of events we want the Exerciser Monkey to perform, the frequency of events, and the distribution of events. In addition, it has some debugging options that can help us to get more information in case of crashes or other problems.

Demo: Exerciser Monkey
In the first demo of this module we are going to use the Exerciser Monkey on our Crypto Boom App. We are going to run the Exerciser Monkey in the following way. We are going to define the number of events we want it to perform, run it, and inspect the result. Let's open Android Studio and see how we can, with really minimum effort, utilize the Exerciser Monkey in order to perform stress UI tests on our application. Let's open Android Studio and open our terminal. In order to use the Exerciser Monkey we need to type the following command, adb shell monkey, then we are going to define our package name, and define the number of events we want the Exerciser Monkey to run. If we just press Enter you see that the Exerciser Monkey is performing random events focusing on our app. This is a great way to run some stress UI test, which gives us the opportunity to find out all the problems in our application in a very early stage. As you can see, this kind of test with the Exerciser Monkey is given to us for free, we don't need to write any code we just need to use the Monkey tool in order to run these tests on our application. I highly recommend you to use this tool as it gives us testing insights with no effort.

Unit Tests
After we talked briefly about random UI tests let's talk about the next type of tests, unit tests. Generally, on Android we have two types of unit tests, JVM unit testing using JUnit, usually these kind of tests will be located under the test source directory, and the second type of tests are Android unit testing, or instrumentation tests. These kinds of tests will be located under the androidTest source directory. If some of our tests need interaction with the Android framework we will use the AndroidRunner in order to simulate the Android framework or frameworks like Robolectric, which provides us with a simulated environment of the Android operating system. During the following demos we will not use Robolectric, but it's very useful to know it. As we stated before, sometimes when writing unit tests for one component we will need to mock some objects. We will use the framework Mockito in order to do that.

Demo: Unit Test
In our first demo we will write a unit test for our CryptoMapper class. We will write a very simple test using the JUnit APIs and learn about how we can see code coverage in Android Studio. Let's open Android Studio. If we open our data model we can see that we have different source directories for the different tests. Here under sharedTest I define some helper classes that will both be used by our tests under the test directory and under the androidTest directory. In order for the sharedTest directory to be visible for both test and androidTest directories, we will need to add a shared resource directory in our build Gradle file. We did that by adding a sourceSets entry in our build Gradle file and defined for which packages we want this directory to be visible. Let's go back to our test code. As you can see here, I defined a CoinEntityGenerator that will create some datasets for us. In addition, I defined a CoinEntityMatcher that will help us to compare different datasets. For the sake of this demo our matcher class just takes an input of a list of CryptoCoinEntity and compares all the ideas of the coins to second dataset. If all IDs are the same it will return true, and if not it will return false. For our test I defined a class called CryptoMapperUnitTest, let's open it. Here you can see that I defined two tests using the test annotation and I defined a helper method that will compare a list of CoinModel and a list of CoinModelEntity. In the first test, mapperFuncJsonToEntity, we will check if mapJSONToEntity method in our CryptoMapper class is working as expected. We start here with initiating our CryptoMapper instance. Then we will read a dataset that I defined in our Coins. json file. It's a simple JSON file and it's equivalent to the API response. Here I just took the top 10 coins. We will use our CoinEntityGenerator in order to create a list of our entities. Next we will call the mapJSONToEntity method, which will result in a second list of our entities, and last, but not least, we will initiate our matcher instance and compare the two lists. The last call will be the assertTrue that will check if the two lists are the same or not. If they are the same the tested function is working as expected. As long as our matchers method will return true, our test will pass. Similarly, I defined the second tests will check if the mapEntityToModel method is doing what it's supposed to do. And here we will use our helper method in order to compare the list of coin models and the list of crypto coin entities. It's important to state that this type of JUnit tests will be run locally as it doesn't require any interaction with the Android framework. In order to run these tests we will just right-click on our test class and then click Run CryptoMapperUnitTest with Coverage. We will talk about the coverage part in a second. As we can see here both of our tests ran and both of them passed. As we mentioned before we ran our test with coverage. Android Studio has a code coverage tool that shows us the code coverage of our tests. If we double-click on our package name and expand the mappers package we can see our CryptoMapper class. As you can see here, 75% of our methods are covered by our tests. In addition, 87% of the lines are covered. This is a very useful tool in order to get an idea how much of our code is covered by our tests. Ideally, we want to maximize our total code coverage to be 100%. In practice it's sometimes time consuming, but you can decide for yourselves which code coverage do you want to achieve. Another indication to check in order to find out which code is covered by our tests and which not are the green and red lines. The green areas indicate that these code snippets are covered by our tests and the red areas indicate not covered.

Demo: Instrumentation Unit Test - DAO
In our next demo we will write an instrumented unit tests for our coinDao class. We will use Mockito in order to mock some objects, use the JUnit APIs, and use our emulators. As we mentioned before, these kinds of tests are usually run on a emulator or on a real device because these tests need some kind of interaction with the Android framework. Let's go back to Android Studio. All instrumentation tests will be located under the androidTest resource directory. Let's open our CoinDaoTest. As you can see in our CoinDaoTest class we have an instance of our RoomDb and an instance of our CoinDao. In addition, we will use the Mock annotation in order to mock an instance of our observer. Before we define the tests let's first define what needs to happen before and after the tests. We are doing that by stating the simple annotations. Before the test run starts we will initialize the Mockito framework, get the reference to an instrumented Android context, and initiate an instance of our RoomDb. For test purposes we can use the inMemoryDatabaseBuilder for faster results. This function will build our database memory, which means that our database will react faster. In addition, we called the allowMainThreadQueries function in order to let Room know that we don't care if the queries will be done on the UI thread. These two function should never be called on the production code. Finally, we will get the reference to our CoinDao object. After the test run we of course want to close our RoomDb in order not to leak anything. Next, I defined the createRandomCoins method that will just return a random list of coins. This is another helper method as we are going to use our tests. The first test I defined is insertCoinsEmpty. This test will do nothing, but insert in an empty list to our database and then check if our database is still empty. We will start by calling the observeForever method in order to make sure our observer will get the data updates, then we will insert an empty ArrayList to our database, wait 15 milliseconds, and then call the verify method in order to make sure that our observer's onChanged method returned in empty list. Pretty simple, right? It's important to state that all Room operations are done asynchronously and this is why we are using the latch in order to introduce a small time delay and let Room enough time to finish its operations before we check the results. The second test I defined is insertCoins. Here we create a random list of coins, register our observers before, then insert the coins into our database, and then verify that the onChanged method of our observer is returning the same list. Here we are using our CoinEntityMatcher from before. After we run our tests, first we need to define on which device the test needs to be run on. In this case we will use our emulator. After the tests have finished to run we can see that both insertCoins and insertCoinsEmpty ran without problem, and both of them passed. With this example we demonstrated how to write a simple instrumentation test, use the Mockito framework to mock some objects, and use the AndroidRunner in order to instrument the Android framework. Let's continue with our next example.

Demo: Instrumentation Unit Test - ViewModel
In our next example I wrote the test in order to test our CryptoViewModel class. As before, we defined some logic in order to initiate the required components. In this test we will need an instance of our repository implementation and an instance of our ViewModel. Here I defined one test. This test will check if the total market cap of all the inserted coins is correct. As before, we created a list of random coins with random market caps. Then I wrote a helper method that will help us to calculate the total market cap of all these coins. Next, we will register our observer to the getTotalMarketCap LiveData object, delete all coins in the database, and insert the new random coins. Finally, we will verify that the onChanged method of our observer contains the same value for the total market cap. Let's run our test. In our test results we can see that our test passed and everything works as expected. Please note that software testing and writing automated tests is a very broad subject and I encourage you to get comfortable with this subject as it's very important, and sometimes not give it enough attention. This was our last demo, let's summarize this module.

Summary
First we have learned why our architecture is convenient for testing. Our code consists of defined layers, our components are short, components are mainly decoupled from each other, and this is why they are simple for mocking. In addition, we have learned about the different test types, we demonstrated the different UI tests, and specifically we talked about Espresso, a framework that lets us define UI tests for specific scenarios on our application, and we demonstrated how to use the Exerciser Monkey command line tool in order to run stress UI tests on our UI. Last, but not least, we learned about the different types of unit tests and demonstrated how to write a JVM unit test, AKA instrumentation tests, which runs on our emulator. In addition, we utilized the Mockito framework in order to mock desired components. Here is a nice diagram that summarizes the different test types. First we have our pure JVM unit tests, our instrumented unit tests, and our instrumented UI tests. While the JVM unit tests runs always locally, the instrumented unit and UI test usually run on an emulator or on a real device. please note that the JVM unit tests are much faster. As we mentioned before, software testing is a discipline by itself and I encourage you to get comfortable with the different subjects of testing as it can save you a lot of manual testing effort and will result in a higher quality app with no problems and crashes. That's it. I want to personally congratulate you for finishing this course and I hope you now have a better understanding of how to utilize the different arch components and how to build your next Android app with a well-structured architecture. Please join me for the summary of this course.

Course Summary
Let's summarize the course. So what have we learned? We learned why is architecture important, why architecting our software in a clear way we have the benefits of creating a maintainable and extendable software, testable software, and readable for new developers. We continued by talking about the SOLID principles for object-oriented design, and we demonstrated common patterns in the Android world. In particular we talked about the MVC, MVP, and MVVM patterns. At the starting point of this course our demo application had no structure and all the functionality was implemented in one very, very long class, we called it a God Class. Then, in each module we slowly started to refactor and replace the functionality by using the arch components, or Android Architecture Components. We learned what the benefits of using them are and how to utilize them in our application. We started by implementing the lifecycle-aware components and learned how to use the OnLifeCycleEvent annotations in order to get lifecycle event callbacks. We continued by explaining the ViewModel and the LiveData framework, how to combine them together, and how to decouple our application logic from our activities. In particular we introduced the following flow. Our activity had a ViewModel instance, which was created only once, then we would do an asynchronous API call, which will be returned to our activity using our LiveData object and observer observing it. We learned that another benefit of using the LiveData framework is that it gives us a solution that decouples the data access of our application from the component consuming it. Our next subject with the Room persistence solution. We've learned that Room provides us with a simple abstraction layer on top of the traditional SQLite implementation and we have learned how to use its powerful annotations for inserting, updating, deleting, and querying of objects. In particular we have learned about the different components in the Room persistence solution. We demonstrated how to create a Room database and how to access its data using the data access object, AKA our DAO objects. In addition, we learned how to define the Room entities and how to use our DAO objects in order to access and fetch the data in a very simple way with minimal implementation effort. Last, but not least, we have learned how to test our architecture by covering the following subjects. We have learned how to use the UI Exerciser Monkey tool in order to run random stress UI tests on our application and have the benefit of finding problems in a very early stage of our development, how to use the Mockito framework for mocking objects, and how to write JVM and instrumentation unit tests for different components in our application. Before the first demo of our course our application had absolutely no architecture, and as I stated before, it consisted only of one very long activity. At the end of this course our application had the world structure architecture, which consisted of multiple layers. With our activities and fragments, our activities communicated with the ViewModel object, which contained LiveData objects as well, in addition, our activities contain some lifecycle-aware components. Our ViewModel communicated with our CryptoRepository, which had two data sources, one RemoteDataSource, which communicated with remote APIs, and a LocalDataSource, which communicated with our Room database. As we mentioned before, we can divide this architecture to three different layers, presentation layer, a domain layer, and a data layer. Except for the fact that now our application consists of three separate layers, there is another very positive benefit. Our high-level components like our activities and fragments have no idea about which technology we use for our low-level components. Theoretically, if tomorrow we want to change our Room implementation to use a different database technology we can do that and our activity will never know about it. This give us the flexibility to be more agile for the long-term and the ability to exchange different frameworks without needing to change our app structure. If you think about it, that's great, especially in the mobile world and in the world of open-source software, it's not uncommon that maybe in one or two years we will use some different frameworks. The pace of adopting new technologies and frameworks is very fast, and it's good to have the flexibility to change that with no big development overhead. Remember, you want to avoid implementing very long classes, which are rich in functionality and of course, you want to avoid ending up with spaghetti code. As we learned, it's much better to architect your application into different layers and smart components in order to get an architecture, which can be compared with this layered cake. Each layer is separated from the other layers and they are clear interfaces, which we use in order to communicate between the different layers. In addition, we can test each layer separately. That's it, it's time to say goodbye. I hope you enjoyed this course and learned something new. Now you can go ahead and utilize the different Android architecture components in your applications. If you have any questions, please don't hesitate to open a discussion under the discussions tab, here at Pluralsight. If you like this course, please rate it here at Pluralsight and help me to expose it for new students. Last, but not least, if you are interested in finding out how you can optimize your Android application's performance, I produced an additional course called, Overcoming Common Android Performance Barriers and it's available here at Pluralsight. I encourage you to check it out and learn how you can optimize your Android application's performance and make sure your users have a smoother user experience. I want to personally thank you for your time, and I hope you enjoyed this course.

Course author
Author: Omri Erez	
Omri Erez
Omri is a software engineer and award-winning Android developer. His first introduction to programming was learning C at the age of 12. While starting his bachelor’s degree in Information...

Course info
Level
Beginner
Rating
4.6 stars with 31 raters(31)
My rating
null stars

Duration
2h 24m
Released
15 Feb 2018
Share course
