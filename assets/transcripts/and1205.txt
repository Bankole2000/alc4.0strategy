Android Keyboard Inputs: Getting Started
by Mitch Tabian

Making use of keyboard inputs is fundamental to providing an excellent user experience. You’ll learn how to use Android with keyboard inputs, keyboard method actions, autocomplete suggestions, soft keyboards, and support hardware keyboards.

At the core of every great Android application is a seamless user experience. In this course, Android Keyboard Inputs: Getting Started, you will learn how to master the core concepts related to the Android SoftKeyboard, in addition to supporting hardware keyboards. First, you will take a close look at keyboard input types such as number pads. Then, you will manage the soft keyboard, keyboard method actions, and autocomplete suggestions. Finally, you will see how to support hardware keyboards for navigation. When you’re finished with this course, you will have a foundational knowledge on capturing inputs that will help you as you develop mobile applications.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Beginner
Rating
0 stars with 8 raters
My rating
null stars

Duration
1h 58m
Released
23 Apr 2018
Share course

Course Overview
Course Overview
Hi, my name is Mitch Tabian, and welcome to my course, Android Keyboard Inputs: Getting Started. I'm a self-employed Android developer and I'm here to teach you about keyboard inputs with Android. Making use of keyboard inputs is absolutely fundamental to providing a seamless user experience. Keyboard inputs refers to a wide array of functionalities built around the soft keyboard and connecting an external keyboard. All applications require user input. Some require passwords, phone numbers, emails, location information, and many others. Using keyboard inputs, we can customize how that information is captured and how the user interacts with your application to retrieve it. Some of the major topics that we've cover include input types, the specific type of information captured by a view. A great example of this is specifying a phone number input type. The keyboard changes to a number pad and the numbers are formatted in a specific way as they're entered. The soft keyboard is an excellent tool for touch screens, but sometimes it exhibits strange behavior. It can distort the view and often becomes visible when it's not supposed to. You'll learn how to manage those potential issues. Connecting a hardware keyboard to a mobile phone isn't very common, but connecting one to a tablet is becoming more and more common every year. For that reason, it's absolutely necessary to make sure our applications can be navigated using a hardware keyboard. By the end of the course you'll have an excellent understanding of the most important concepts when it comes to keyboard inputs. You'll be able to specify input types, effectively manage the soft keyboard, and support navigation using a hardware keyboard. The course is meant for absolute beginners when it comes to keyboard inputs, but targets an intermediate developer overall. I hope you'll join me on this journey to learn about keyboard inputs with the Android keyboard inputs course, at Pluralsight.

Getting Started
Introduction
My name is Mitch Tabian, and welcome to my course, Android Keyboard Inputs: Getting Started. In this course you'll learn how to handle keyboard inputs with Android. You may be wondering how many things could you possibly do with a phone keyboard? And you're right to be skeptical. The course topic is somewhat misleading. Keyboard inputs actually refers to quite a wide array of Android functionalities. For example, changing the input method type of an edit text widget can alter the options available on the soft keyboard. Specifying an input type of email changes the keyboard so there's an at symbol in the bottom left, or specifying an input type of phone changes the keyboard to represent a number pad. Other input types like password will cause all text entered into the widget to be represented by circles. Sometimes the soft keyboard can do strange things to a view. It can squish widgets down or stretch them to incorrect lengths. Later in the course we'll take a look at how to control this behavior. Text auto suggestions are a form of keyboard input. We'll be implementing a custom array of auto suggestions that users may want to take advantage of when chatting with other users. We'll take it a step further with auto suggestions by implementing what's called a search view. A search view is basically an advanced version of auto suggesting. You can associate it with a recycler view and perform customized searches for the content in the list. In addition to the on screen input methods, Android also supports hardware keyboards. A hardware keyboard refers to any external keyboard attached to the device. Although most handheld devices, such as phones, use touch as a primary mode of interaction, tablets and similar devices are growing in popularity and many users like to attach keyboard accessories. The trickiest part about this is ensuring the app is easily navigated using a keyboard. We need to build the app in such a way that touching the screen is not needed if you have a keyboard attached. That means doing things like sending chat messages, opening navigation drawers, tabbing through widgets in a view, and swiping through tabs. In the course I'll be using a Bluetooth keyboard for testing, if you don't have one, don't worry, you'll be able to use the Android emulator.

Prerequisites
This course is meant for intermediate level Android developers who are complete beginners when it comes to using keyboard inputs. We'll be using the finished version of the source code from another one of my Pluralsight courses named Android Fundamentals: Implementing Effective Navigation. It's going to be much more realistic to essentially go back and improve the user experience of something that's already built. Since we'll be using the finished version of that course, I obviously recommend watching that course first. But it's not necessary. If you're already familiar with things like RecyclerViews, fragments, listeners, callbacks, custom object classes, and toolbars, then you'll be totally fine. If you take a look at the Build. Gradle app file, you'll see a handful of external dependencies. We won't actually be using any of these in course, they're all used in the implementing effective navigation course. So if you want more information on these, check out that course, or do a Google search on the dependency you are interested in. Since we're talking about the Build. Gradle app file, I'll take a moment to mention that I'll be targeting and compiling to an SDK version of 27. And I'll be using Android Studio version 3. 0. 1. As I mentioned, I expect you to have an intermediate level knowledge of Android development with Android Studio. I won't be covering how to set up the Android emulator or how to enable developer mode and run apps on a real device. I'm assuming you've learned that on your own, so if you're completely new and never used Android Studio before, you'll need to do some minor research and get apps running on a virtual device or on a real device that you have.

The Story Behind the App
For the duration of the project we'll be approaching app development from the perspective of an imaginary company, Tabian Dating. Tabian Dating is a small startup company that wants to build the next big dating app. The app is still early in the development stages, but it's beginning to come together. Our project skeleton has been completed, and now it's time to work on improving the user experience. You've been hired to improve the user experience through the use of handling keyboard inputs. Your only criteria is that you must improve the user experience and ensure the application can be used with a touchscreen or using only a hardware keyboard.

App Demo
Let's go through the application we'll be building in the course. When the application is launched, you'll see this screen. This is a list of all the users registered with the Tabian Dating app. Of course, this is just some dummy data. This isn't actually pulling anything from a database. I'm going to be doing this demonstration using a Bluetooth keyboard that's connected to my phone. Every action I take will be using that keyboard. First we'll open the navigation drawer. The key I've found to open the navigation drawer is Control and Tab. Now I'm going to press Tab until Settings is focused. Now I'm going to click Enter. This is a fragment where you just can get some personalized account properties. Something I want you to notice here is that I can focus every widget in the layout just by pressing Tab. There's a profile picture, the name field, the email field, the phone number, the gender, interested in, status, and the Save button, and now the back arrow. Additionally, I can use the up or down arrow keys to change the focus. Let's take a closer look at the name field. I'll just type Mitch Tabian. Notice the soft keyboard is the standard one used for the edit text fields. Notice the first letter of each new word is automatically capitalized. So this edit text field isn't just any old edit text, there's a special property set to it forcing capitalization. Next, take a look at the email field. When it's focused, the keyboard changes to include an at symbol in the bottom left. That's to make it easier for users to type in their email address. And finally, the phone number field. The first thing I want you to notice here is the soft keyboard has changed to show only numbers. Now watch what happens when I type in a phone number. The phone number is automatically formatted this way. Now I'm going to move the focus to the profile picture. I'm going to click Enter on the keyboard, that takes us to a new activity where users can select a new profile picture. If I move the focus to this spinner, a list of directories becomes visible. These are some of the common directories that are likely to contain images on the phone. If I select one, you can see the grid view containing images changing at the bottom. If I press Tab a few times, I can move the focus to the grid. Notice when the focus is on the grid items they get highlighted. This behavior isn't default. This is something we'll be implementing in the course. If I want to swipe to the next tab I can press Control+right, then Control+left to go back. If I press Escape on the keyboard, I'm navigated back to Settings. If I press Escape again, I'm navigated back to the main feed. Just like in settings, I can press Tab here and navigate through the list items. If I press Enter on one, I'm navigated to their profile. If I press Escape, I'm taken back. To access the bottom navigation, I need to use the left and right arrow keys while holding Control. If I navigate to the middle icon, I'm taken to a fragment containing the users that I've liked. To remove them from the list, I need to open their profile and then remove the like. Let's explore the last portion of the app. I'm going to press Control+right to navigate to the last portion on the bottom navigation. The first feature I want you to notice here is the search view. The search view is this widget in the toolbar. Because the search view is in the toolbar, I need to bind a special key to focus it. I've bound Control+S. Now that it's focused, whatever I type will filter the RecyclerView below. It searches for names and also for messages. To demonstrate, I'll search for a name. Great, there's a match. Now I'll search for the message that that user sent. So we expect the same result to show. And there it is. A search view is basically a more advanced version of auto suggesting. You can customize it to fit the needs of any list you might have. I love to use them whenever I can. If I focus one of the users and click Enter, I'm taken to a private chat room. Once again, every widget on the screen can be focused using Tab. If the focus is moved on this edit text field in the bottom, I can type a message. I'll start typing wh and see what it suggests. To enter the message, I can either move the focus to the Send button or I can just press Shift+Enter while the focus is on the edit text field. That's it for the application. Believe it or not, it actually requires a lot of fine tuning to get an application working correctly with a hardware keyboard. And as you'll see in the course, there's a ton of versioning issues, but it's absolutely necessary to achieve an excellent user experience.

How to Use the Source Code
For your convenience, I've added the source code files to a GitHub repository and I've also attached them to the exercise files for the course on Pluralsight. I recommend using the code on GitHub since it's easy to switch between modules and clips. But if you want to get the code from Pluralsight, you're more than welcome to do that too. Let's walk through how to get the code from GitHub. Launch Android Studio, click on the check out project from version control option right here. Here's where you're going to want to put the GitHub repository URL. Open GitHub and let's go get it. Navigate to GitHub. com/mitchtabian/TabianDating. Click Clone or download right here. Now copy this URL. Go back to Android Studio and paste the URL right here. Now click Clone. This message will pop up asking if you want to open the project you just referenced. Click Yes. Another dialog is going to pop up asking if you want to add this vcs. xml file to Git. If you already had a project open, you can also import from version control by going to File, going to New, import project from version control, select GitHub, and then paste the URL right here. Notice this error message I'm getting down here. If you get any kind of a weird error message at this point, you're going to need to go to File, Invalidate Caches and Restart, then Invalidate Caches and Restart. If you have any issues with loading the source code while following along with the course, the first thing you're going to want to try is invalidating the caches and restarting. Now reopen the project. You should be greeted with a dialog that looks something like this. Make sure everything's checked and click OK. We have one more thing to fix. Open the logcat. Android Studio is telling us we need to configure the SDK. So click Configure, choose Build Tools version 27. 0. 3 since that's the newest version, and now click OK. At this point you should be good to go. But if you're still having issues, make sure your Android Studio is the same version as mine, 3. 0. 1., and all the SDK tools are up to date in the SDK Manager. Now accessing the source code for each clip is very simple. All you need to do is click down here where it says Git, you can drag this window upwards to expand it, and these are all the clips for the course. For example, if you wanted to open the source code for the start of the module named specifying the input method type, then you'd select the branch named Module_3. 2_Start. If you want to see the code for the end of that module, you would just go to Module_3. 2_End, then you click check out as new local branch and click OK. Now all the code is updated. Let's do another example. Suppose you wanted to open the code from the module named providing auto complete suggestions. Select Module_4. 2_Start and then check out as new local branch and click OK. Now you're ready to start that module. Keep in mind that once you've checked out a local branch, it's going to be added to the local module section up here. If you want to open that same branch in the future, just click it and then select Checkout. You don't need to use checkout as new local branch since it's already a local branch. If the naming of the branches is confusing you, let me explain by referencing one of my other courses on Pluralsight. At the time of filming this, this course is obviously not published yet, so I'll have to refer to a different one. Here's another one of my Android courses, it's called Implementing Effective Navigation. Pretend we're working on this course and we just imported the source code from GitHub like I just showed you. This will be module 1, this will be module 2, this will be module 3, and so on. That's how I've named the branches for this project.

Specifying the Input Method Type
Introduction
For the duration of the module, we'll be working with the source code files in the directory Module_3/Start/TabianDating. If you imported the code from GitHub, you'll want to start with the branch named Module_3. 2_Start. In this module we'll work on what I consider to be the basics of keyboard inputs. We'll work on setting specific input types for the edit text widgets. Things like the email address, phone number, and text. These aren't the only input types available. These are just the ones we'll be working on in the application. There's many more available and you'll likely find them useful in your other projects. There's things like passwords, number decimals, dates, date time, and text capitalization. We'll explore some of the others by referring to the Android documentation, but we won't actually be using them in the project. Properly formatting a phone number when entered into an edit text field is something you should be doing in all your applications. Lucky for us, the Android SDK has some convenience classes that we can use just for that. One way you can customize the soft keyboard is by using what's known as an IME option. IME options will change the way the Return key looks and also change its functionality. We'll explore some of the other options like actionNext, actionDone, actionSend, and actionSearch. Each IME option will look different so users will know what's going to happen when they press it. Sometimes when the soft keyboard is displayed, it can distort the view. We're going to take a look at how we can resolve that problem by setting something called the soft input mode.

Specifying Inputs Types
SInce some of you likely haven't taken my Implementing Effective Navigation course, make sure to watch the clip named App Demo. The app demo is where I take you through the full application demo of what we'll be building. We're going to start by specifying input types for some of the edit text fields in SettingsFragment. To get to SettingsFragment, you first need to click Login, open the navigation drawer by swiping left to right on the screen, and now select Settings. This is SettingsFragment. It's essentially a user profile. Users can enter information like their name, their email, their phone number, their gender, what sex interested in, and their status. Our first job is going to be improving this by specifying inputs types and properly formatting their email and phone number. As you can see, when I click on the edit text field next to the phone, a regular keyboard opens. This will obviously result in a poor user experience. We want a number pad. Also, when I type a number in here, it's not being formatted in any way. When I try to enter the email, the at symbol is on the second page of the keyboard. It would be much more convenient to have it on the first page. Open fragment settings and let's take a look at what we can do. Scroll down to the edit text field for inputting a name. A name doesn't generally require an input type, but I like to use text cap words. Text cap words will capitalize the first letter of every new word entered. Next, scroll down to the email field. Here we want to use textEmailAddress. TextEmailAddress won't actually change the text, it just changes the keyboard. When a user clicks on this EditText field, the keyboard will display an at symbol on the first page. That's going to make it easier for you just to fill in their email address. Next is the phone number. Here we want an input type of phone. Once again, this doesn't actually change the text that's entered, it only changes the keyboard. Run the app and let's take a look. Click Login, open the drawer, go to Settings. Now I'll enter my name, so Mitch Tabian. Notice I never press the Shift button on the keyboard. The letters were automatically capitalized. Next is the email. Watch the keyboard as I enter the email in the edit text. Notice the appearance of the at symbol in the bottom left. So now I'll enter my email, mitch@tabian. ca, and now for the phone number. Now it's only showing numbers and a few other special characters commonly associated with phone numbers. I'll just enter a random phone number of 604-855-1111. This is only three options when it comes to specifying input type. The entered SDK has somewhere around 32 options at the time this video is being filmed. You'll find a lot of them very useful in your other projects. If you want to take a look at what's available, go to developer. android. com/reference/Android/widget/TextView. html, and then just scroll down to the Android input type heading. Here you can see all the different input types available and a short description of what they do. Go back to Android Studio. The name and email look good, but the phone number doesn't. Ideally we want it to look something like this: 604 space 855-1111, or something along those lines.

Formatting a Phone Number
Open SettingsFragment. Formatting a phone number is surprisingly simple. As of Android version lollipop, there's actually a new interface that does all the work for us. Not that it was difficult before, but now it's even easier. In onCreate write if Build. VERSION. SDK_INT is greater than or equal to Build. VERSION_CODES. LOLLIPOP and then else. Inside the if statement we want to write mPhoneNumber. addTextChangeListener and then new PhoneNumberFormattingTextWatcher, then Locale. getDefault. getCountry. PhoneNumberFormattingTextWatcher is the new interface I was talking about. That's literally all we need to do for the phone number and that's going to format it properly just as the user enters it. Inside the else statement, we're going to use a TextChangedListener, so write PhoneNumber. addTextChangedListener then new TextWatcher. We're interested in the afterTextChanged method. So in the afterTextChanged method, write editable. replace, then 0, editable. length, PhoneNumberUtils. formatPhoneNumber and then editable. toString. That's it. Run it and let's take a look. Click Login, open the drawer, go to Settings, now click on the phone number field and try entering a number. I'm just going to enter 1 604-855-1111. Cool, everything is working exactly as we expect.

Handling Input Method Visibility
I'm going to choose a profile picture because I'll need it for the next demonstration. To choose a new profile picture, you can click on this camera icon. If you haven't given storage permissions, you'll have to do that. Then we can choose a photo from memory or take a new one with the camera. I'll just choose this one. Now I'm going to press back and navigate back to home fragment. I'll need to add someone to my favorites for the demonstration. I'll just click on this user. I can save them to my favorites by clicking on this heart. Now I'm going to press back and now navigate to the middle icon in the bottom navigation. As you can see, there's the user that I just liked. Now navigate to messages fragment by clicking on the icon in the far right of the bottom navigation. As you can see, there's the user I just liked. Now click on. This is called chat fragment. Here's where I can chat with users that I've liked. I'm going to click on the edit text field down here. Notice the view is being distorted. The keyboard is cutting off the edit text and the send button. This is due to a configuration problem. It's surprisingly easy to fix. Open the manifest, the problem is this setting right here, windowSoftInputMode=adjustPan. Specifying a Windows soft input mode here tells Android Studio what to do when the keyboard is opened in that particular activity. Adjust pan means the activity's main window will not be resized to make room for the soft keyboard. We're going to change it to stateHidden. If you want to know what states are available for windowSoftInputMode, visit the Android documentation here, developer. android. com/guide/topics/manifest/activity-element. html and then #wsoft. Let's read what it says about stateHidden. The soft keyboard is hidden when the user chooses the activity, that is, when the use affirmatively navigates forward to the activity, rather than backs into it because of leaving another activity. Basically all stateHidden will do is hide the keyboard when the activity is opened. It's solving our problem because it's not trying to resize the window like adjust pan does. I encourage you to explore the different states available here. You can use them to control the soft keyboard visibility and also whether you want it to be resizable or not. Go back to Android Studio, run it and let's see if the problem was solved. Login, go to messages fragment, select a user, click the edit text. As you can see, it's not being distorted.

Specifying Input Method Actions
Input method actions refer to methods that are executed when a user clicks on the button in the bottom right hand corner of the soft keyboard. By default, a method will be assigned based on the input type you define in the widget. For example, in these fields, the method will cause the focus to jump to the next widget when pressed. I'll show you what I mean. I'll click on the button in the bottom right and see, I was jumped to the next input field. To override this default behavior, we can specify an input method action. Open fragment_settings, start with the name. We're going to override the default input method action by writing imeOptions and then actionDone. Run it and let's see what's changed. Login, go to Settings, click the name field. Notice now it's a checkmark. It used to be an arrow, just like this email field. So it looks different, let's see if it behaves differently. Remember when we click the button in the bottom right of the keyboard, it brought us to the next input field. I'll click it now and see what happens. It closes the keyboard and didn't bring us to the next input field. That's not all you can do with imeOptions. Open SettingsFragment, we're going to use an OnEditorActionListener to listen for click events to the keyword button. Implement the OnEditorActionListener interface, click the red light bulb and implement the method. Inside the OnEditorAction method, write if i = EditorInfo. IME_ACTION_DONE, then save preferences. So when they click the button, their preferences will be saved. Scroll up to onCreate and let's set the listener. Write mName. setOnEditorActionListener and then pass this. Run it and let's test. Login, go to Settings, now I'll edit the name field, now I'll click the action button in the bottom right. Cool, it says my preferences were saved and the keyboard was closed. Action done is just one of the many imeOptions available. Take a look at the Android docs if you want to see what other options are available. Visit developer. android. com/reference/Android/widget/TextView. html and then #attr_android:imeOptions, or just go to the TextView. html page and scroll down to where it says Android imeOptions. As you can see, there's a whole bunch here. Take a look and see what you can find to fit your project's needs.

Module Review
We started the module by exploring the various input types available in the Android SDK. In SettingsFragment we set an input type of textCapWords for the name field. TextCapWords will capitalize the first letter of ever new word, making it perfect for a name field. Next was the email field. Having an input type of textEmailAddress will alter the soft keyboard so it displays an at symbol in the bottom left hand corner. The last widget we looked at was the phone number field, specifying an input type of phone will change the soft keyboard to a number pad. It displays the numbers and a few symbols you might need when entering a phone number. If you want more information on the input types available, check the Android documentation at developer. android. com/reference/Android/widget/TextView. html and then scroll down to the heading titled Android:inputType. At the start of the module the phone number didn't look like this when we entered it. There was no spaces or dashes when entering a number. To format the number as the user enters it, we used a PhoneNumberFormattingTextWatcher. We can use that with Android versions lollipop and above. For versions below lollipop, we used a TextWatcher and the PhoneNumberUtils class to format the input as it was entered. The result is what you see here. Every input type has a default method action that's executed when users click the button in the bottom right hand corner of the soft keyboard. Usually clicking the button results in jumping to the next widget in the layout. If you want to override this default behavior, you can specify an imeOption attribute on the widget. We set an imeOption of actionDone to the name field in SettingsFragment. That resulted in a different button being displayed on the soft keyboard in the bottom right. When you click the checkmark, it closes the keyboard and does not skip to the next widget, like it did with the arrow. We took it a step further by listening for the imeOption execution. In SettingsFragment we implemented the onEditorActionListener interface and checked for the actionDone imeOption. If it's captured, we saved the new preference changes. This was just a demonstration, but hopefully you can see the power here. You can use the imeOptions on widgets and capture specific clicks to the soft keyboard and execute methods. Pretty useful stuff. If you want more information on the imeOptions that are available, take a look at the Android documentation at developer. android. com/reference/Android/widget/TextView. html and scroll down to the heading named Android:imeOptions. In the last part of the module we fixed a problem the soft keyboard was causing to the view. In chat fragment, this edit text field and this button were being cut off by the soft keyboard. This was a very simple fix. All we needed to do was set the windowSoftInputMode to something other than adjustPan in the manifest. Specifying the windowSoftInputMode can be used to show or hide the soft keyboard under certain circumstances. You can also force the view to resize and scale like it did with adjustPan. Although as you just saw, it's not very useful in most situations because it can result in the view being distorted. If you want more information on the windowSoftInputModes available, check the Android documentation at developer. android. com/guide/topics/manifest/activity-element. html, and then #wsoft.

Providing AutoComplete Suggestions
Introduction
For the duration of the module, we'll be working with the source code files in the directory Module_4/Start/TabianDating. If you imported the code from GitHub, you'll want to start with the branch named Module_4. 2_Start. Sometimes it's convenient to provide text suggestions to users. Some fields where text suggestions are appropriate are entering a city name, entering a country name, entering a greeting message, or maybe entering an age. Currently we don't have a city, country, or age field in our application, but we do have a chat. So we're going to predefine some greeting messages that users might want to take advantage of. The message suggestions will pop up if the user starts typing the first two characters of the greeting, then they can select the one they want to use. Of course they can also choose to not use the suggestions. Next we'll work on implementing a search view. A search view isn't technically part of the handling keyboard inputs guide in the Android documentation, but I think it's worth covering since it's basically an advanced version of auto suggestions. We're going to be using a search view to filter a list of chat messages. So if a user can't remember who they were talking to, but they remember what they were talking about, they'll be able to find that user. They'll also be able to search by name. This is going to work in basically the same way as the default texting application on your current device.

Implementing AutoComplete Suggestions
Open fragment_chat. The first thing we need to do to implement auto complete suggestions is add a special widget to the layout. Scroll down to the EditText that accepts input from the user, copy it, comment it out, now paste it in again. Now change it to an auto complete text view. Everything else is going to be the same. Now open strings. xml. Scroll down to the bottom. As you can see here, I've added a bunch of suggestions to a string array. The string array is named message_suggestions_array. Feel free to add anything else to the array. These are just some suggestions that I came up with on the spot. Now open ChatFragment. The first thing we need to do in ChatFragment is change the EditText widget declaration to an AutoCompleteTextView. Now all we need to do is build a method for associating the list of suggestions with the AutoCompleteTextView. Scroll down below onCreate, we're going to call our new method setupAutoCompleteTextView. When building a custom list in Android, you almost always need an adapter of some kind. This is no exception. So declare an array adapter object of type String and call it adapter. As you can see, the constructor accepts three inputs, the context, a list item layout, and an array of objects. We can write getActivity for the context since we're inside of a fragment and Android. R. layout. simple_list_item_1 for the layout. We're going to need our list of suggestions from the Strings file for the third parameter. Above the array adapter write String messages = getResources. geStringArray and then R. array. message_suggestions_array. Now pass the messages to the adapter. Now just set the adapter to the widget. Call the method in onCreate. Now run it and let's take a look. Login, go to Messages, select a user, I'll just type wh, and there's some suggestions. If I touch one of them, it's added to the widget. If I press send, the message is posted.

Implementing a SearchView
In the application's current state, it's actually already implementing a search view. However, the search view is only filtering by name, not by messages. We're going to walk through the process of implementing a search view, then improve it by adding the ability to search by message. Open FragmentMessages. Implementing a search view starts with adding a search view widget to the layout. As you can see, I've placed it inside the AppBarLayout and a Toolbar. Other than that there is nothing special here. Open MessagesFragment. Scroll down to the initSearchView method. Here's where the search view is set up. This code at the top is for getting some basic configuration preferences for the search view. Below that is the more interesting stuff. By setting an onQueryTextListener, we can listen for changes entered into the search view. We then send the query to a filter in the RecyclerViewAdapter class. Open MessagesRecyclerViewAdapter. Scroll down to the getFilter method. Here's where the filtering is done using the query passed by the search view. As you can see, it loops through the list of users and looks for any character matches. If it finds one, the user is added to the filteredList. The performFiltering method returns the list of filtered results to the publishResults method. The publishResults method then does exactly what it sounds like, it publishes the results and notifies the adapter that a change has been made to the list being displayed. As you can see, it's currently only filtering by name. But we want to be able to filter by name or message. Scroll up to the top and let's make some changes. The first thing we need to do is create a messages array. Just like the users array that holds a list of all the messages and which user is associated with that particular message. Open the Message class in the models package. We're going to create a list of message objects since they hold a user object and a string object representing the message that that particular user sent. Go back to MessagesRecyclerViewAdapter. Delete the filteredUsers ArrayList and create a new ArrayList that holds a Message object. Call it mFilteredmessages. Since we'll be filtering on the messages, we'll also need a reference list of messages. Write private ArrayList Message mMessages = new ArrayList. That's going to be our reference list. In the constructor, delete this line. We need to build a new method for setting the messages to the list. Call it setMessages. Loop through the list of users using a for loop. Now add a message object for each user in the list. So messages. add new Message, reference the user, and then reference a message. After the loop set the FilteredMessages to Messages. Call setMessages in the constructor. Now we have a list of messages and a user associated with each message. Scroll down to onBindViewHolder. We need to get the user object from the FilteredMessages list, so write final User user = FilteredMessages. get position and then getUser. And we need the Message object from the messages list. So write final String message = FilteredMessages. get position and then getMessage. The only other thing we need to change in onBindViewHolder is here where the message is set. Change this to message. Okay we're ready to make the changes in the getFilter method. First change this to say mFilteredMessages is Messages. Just delete everything inside the else statement. We're going to make a lot of changes. Start by declaring a new ArrayList variable that holds message objects. Call it filteredList. Now we want to loop through the list of messages and check for matches to the name or matches to the messages. We'll start by checking the messages, then check the names. So if the message toLowerCase contains charString toLowerCase, then we want to add the message to the filteredList. That's how we check for message matches. Now let's check for matches to the name. So else if Users. getName toLowerCase contains charString toLowerCase, then add the message to the filteredList. Once we have all the matches, set the global filteredList to our new filteredList. Now set the filteredMessages to the results and return them. In publishResults, set the filteredMessages to the results and make sure to change the object type to Message right here. And finally, we just need to change the variable down here in getItemCount. Run it and let's take a look. Login. We need to like a bunch of users so we have a big enough list to search. I'm just going to pick a handful of them at random, it doesn't matter who you like. Now navigate to MessagesFragment. First I'll try to search by message. Great, so that's working. But there's a problem. It looks like the navigation view is sitting on top of the toolbar. This is obviously not what we want. We're going to take a look at resolving that problem in the next module. Now I'm going to try and search for that user's name, so I expect to see the exact same filter results. Cool. Everything is working as we expect.

Module Review
We started the module by implementing an auto complete text view. An auto complete text view is a special type of widget we can use to display text suggestions to users. Using this widget is great for things like asking for location information, like country or city, asking for age information, or suggesting common phrases in chat interactions. Since we have a chat portion in the application, we used it for suggesting common phrases in chat interactions. In the strings. xml file, I added a handful of common phrases people use when greeting one another. Next was actually adapting the list of suggestions to the AutoCompleteTextView. We got the list of messages, declared the array adapter, and then set the adapter to the widget. Pretty simple stuff. The end result looked like this. When a user starts typing some text, the widget will list suggestions they can choose from. Next we worked on implementing a search view. Search views are kind of like an advanced version of auto suggestions. They're great for searching through lists of data and returning relevant results. The best thing about them is you can search for whatever you'd like. We filtered the list on both the user's names and the messages. There's quite a bit of detail involving the setup of a search view, so if you need a review, I suggest re-watching the clip named Implementing a Search View.

Detecting if SoftKeyboard Is Visible
Introduction
For the duration of the module, we'll be working with the source code files in the directory Module_5/Start/TabianDating. If you imported the code from GitHub, you'll want to get started with the branch named Module_5. 2_Start. Sometimes you just can't get the view to do what you want, especially if the soft keyboard is popping up and distorting it. As I mentioned in the previous module, the navigation view is sitting on top of the soft keyboard in messages fragment. This obviously doesn't yield a good user experience, it does not look good. I don't know if you noticed, but at the start of the course this wasn't happening. Do you what's changed? We changed the windowsSoftInputMode in the manifest to stateHidden. It used to be adjustPan. AdjustPan actually solves this problem. If we set the windowSoftInputMode to adjustPan, the toolbar will not be sitting on top of the keyboard, but unfortunately then we'd have the overlap issue in chat fragment. Ah, the joys of programming. But don't worry, we have options. We always have options. We're going to build a custom listener that detects when the keyboard is showing, if it is, we'll hide the bottom navigation.

Listening for Changes to SoftKeyboard Visibility
As I stated in the introduction, our goal here is to detect when a soft keyboard becomes visible, then hide the bottom navigation. At first glance this might seem like a simple task, but unfortunately there's no out of the box solution for detecting when the soft keyboard is visible. The Android SDK doesn't have any classes or interfaces specifically for that. But remember, we always have options. Open a new browser window. I've created a gist so we don't have to write so much code. Go to this URL. Copy everything you see here. Now go back to Android Studio and open MessagesFragment. I'm going to paste it at the bottom of the file. As you can see, there's a few new variables here. Cut them and scroll to the top. Paste them under the vars heading. While we're up here, call setKeyboardVisibilityListener in onCreate. Now scroll back down and let's walk through it. Here's a general overview of how this method works. The GlobalLayoutListener will listen for changes to the view. As you can see, I've applied the LayoutListener to the root view element, a variable named contentView. ContentView is assigned to the root view by referencing Android. R. id. content. This is the default id given to the root view element. You can access this in any fragment this way. To help you understand what's happening here, I've inserted some logs. Comment out the methods down here and run the app. If a change is detected to the layout, i. e. the soft keyboard becoming visible, onGlobalLayout is triggered. As you can see, I haven't opened the keyboard or touched the view at all and we see some log output. It says the new height is 1857, the current orientation is 1, which is this log right here, the app height is 0, which is this log, and the app height is 1857, which is this log. The first log is self explanatory. The new height is just the height of the display. My device has a resolution of 1920 x 1080, but then you need to subtract that small portion above the app, that leaves me with 1857 for the height. Next you probably noticed that this if statement is running and that means the screen orientation is different than the current orientation variable, but that's meant to happen. If you scroll up to the top, I set the currentOrientation variable to -1, I did that because I want this if statement to run when the view first inflates, no matter what. Setting that to -1 will ensure that. Then the currentOrientation is set to what it actually is and the appHeight variable is set to 0. Setting the appHeight variable to 0 is what I wanted to make sure happens when the view first inflates. That way this if statement will also run when the view first inflates. As you can see, the new height variable is definitely larger than 0. In my case it's 1857, so the app height will get set to the starting height of the view, which is 1857. So at this point we have the app height set to the starting height of the view and now let's open the keyboard. Notice this if statement doesn't execute this time. That's because the screen orientation hasn't changed, only the height is changed. So new height is set to 1116, as you can see from this log output. Also notice the second if statement doesn't run, that's because the new height is less than the app height. If we moved onto the bottom section, you can see how we're using that information to either hide or show the bottom navigation. If the AppHeight is greater than the newHeight then hide the navigation because that means the view is being squished. Otherwise we want to show the bottom navigation. Close the log and let's build these methods for showing and hiding the bottom navigation. Open IMainActivity. Create a new method named setBottomNavigationVisibility and have it take a Boolean. Now open MainActivity. The interface is already being implemented, so we just need to write the method. Scroll down to the bottom, press Control+O on Windows or Command+O on Mac, type setBottomNav and there's our method. Now write if visibility, then show the BottomNavigation, else hide the BottomNavigation. Now go back to MessagesFragment. Uncomment these. Before we run it, we need to instantiate the IMainActivity interface variable. Press Control+O on Windows or Command+O on Mac, type onAttach. In the onAttach method write mIMainActivity equals IMainActivity and then getActivity. You always want to instantiate an interface in onAttach because it's called first in the fragment lifecycle. Run it and let's take a look. Navigate to MessagesFragment, now click the search view. Great, the navigation is hidden.

Setting SoftKeyboard Visibility
In the last clip we worked on detecting whether the keyboard is visible, then hiding or showing the bottom navigation view. In that circumstance we wanted to hide the bottom navigation view if the keyboard was showing, but what if we wanted to hide the keyboard given different circumstances? Let me give you an example. I'm going to navigate to SettingsFragment and select one of the text fields, that's going to open the keyboard. But now I'm going to press the back arrow. That takes us back to home fragment, but look, the keyboard is still showing. This is another variation of the same problem. We have the bottom navigation view sitting on top of the keyboard, but the keyboard should never really be visible in this fragment, there's no input fields, so there's no reason to show the keyboard. Open IMainActivity and let's implement a fix. Create a new method named hideKeyboard. Open MainActivity. Press Cotnrol+O on Windows or Command+O on Mac. There's our new method. To close the keyboard in an activity, which is what we're in right now, we want to first make sure the view is not null. So write if getCurrentFocus does not equal null. To access the Android soft keyboard we need to reference an inputMethodManager object. So declare one and call it inputMethodManager. So inputMethodManager getSystemService, and then INPUT_METHOD_SERVICE. Now to actually close the keyboard write inputMethodManager. hideSoftinputFromWindow, then getCurrentFocus. getWindowToken and 0. But as you can see, we have a potential null pointer exception here. So surround this in a try catch and catch the null pointer. I'm just going to print the stack trace if there's an error. Keep in mind that this will not work if you call this from a fragment and use getActivity here for the context. I'm going to write out what you need to do in a fragment just for your reference. I'm going to comment it out after. So public static void hideKeyboard, get the context and get the view, and then do inputMethodManager = InputMethodManager context. getSystemService Activity. INPUT_METHOD_SERVICE, hideSoftInputFromWindow, view. getWindowToken and 0. I'm just going to comment this out because it's actually only meant for a fragment, that's just for your reference. If you want more information on the soft keyboard, I encourage you to check out this stack overflow post, it's really good. The API surrounding the soft keyboard is kind of a sensitive topic in the Android developer community, and for good reason. I find it much more complex than it needs to be. Having something as simple as keyboard. hide would obviously be much easier to deal with. Now we want the keyboard to close when a user is pressing the background, just like it does when we press the back button. See, what I press the back button, the click is intercepted and the keyboard closes. Then if I click it again, it goes back. We want it to behave in a similar way when we press the back arrow. Scroll up to onBackPressed, call hideKeyboard at the bottom. Now when the user clicks the back arrow, the regular processes will be executed, then the keyboard will be closed. You might be wondering why we bothered to make an interface method if we're just going to call closeKeyboard in MainActivity. It's just for convenience, so now you can close the keyboard in any of the fragments hosted in MainActivity with a simple method call. You won't have to worry about whether you're in a fragment or an activity, you just call one method and it makes things simple. Run it and let's take a look. Login, go to Settings, open the keyboard, press the back arrow. Great, the keyboard is closed.

Module Review
In the first part of the module we addressed a problem that was introduced when we set the windowSoftInputMode to stateHidden in the manifest. It was causing the bottom navigation view to sit on top of the soft keyboard. This is obviously not a good user experience. We used a global layout listener to listen for changes to the layout. If the keyboard is opened, that will trigger the global layout listener. Then we get the new view height and compare it with the view height of the screen. If the new view is less than the total height of the screen, then we hid the bottom navigation. That solved the problem of hiding the bottom navigation when the keyboard is showing, but what about hiding the keyboard when the bottom navigation is showing? Remember, if we're in SettingsFragment and the keyboard is open, then we press the back arrow, the keyboard would remain open with the bottom navigation sitting on top. This is another scenario yielding a poor user experience. To resolve this, we built a method named hideKeyboard. HideKeyboard does exactly what it sounds like, it hides the soft keyboard. We called the method in the onBackPressedOverride method in MainActivity. Since the back arrow is routed through onBackPressed, the keyboard will be closed when it's pressed. We're done with the soft keyboard. In the remaining modules, we'll work in everything required to support a hardware keyboard.

Supporting Keyboard Navigation
Introduction
For the duration of the module, we'll be working with the source code files in the directory Module_6/Start/TabianDating. If you imported the code from GitHub, you'll want to start with the branch named Module_6. 2_Start. As you probably already know, by default the users have the ability to navigate applications using an attached keyboard. Keyboards aren't very popular with mobile devices, for obvious reasons, but they're growing in popularity with tablets. That being said, by default navigation will likely be clunky and far from perfect. It's up to us as the developer to anticipate problems and define an intuitive navigation system. Additionally, there's going to be some significant versioning issues. I'm going to be testing on two devices, one is running API version Oreo and the other is running API version Marshmallow. That's API level 26 and 23 respectively. I have two major goals in this module. Number one is I want to show you there's no absolute way for defining keyboard navigation. There's going to be a lot of things that don't work and you'll need to be creative and come up with solutions. Number two is to convey enough different situations and examples so you get an idea of what you'll likely run into in your other projects. I'll describe my thought process and how I solve the problems that I run into. Remember, our goal is to design effective keyboard navigation for the most versions possible. So all the solutions here will have that major goal in mind. Here's an example. When a users pressed the Tab key on an attached keyboard, what happens? That's the type of navigation we need to customize. Additionally, how do you open the navigation drawer? You can't get to it using Tab. For things like that, we need to bind specific keys. I'm going to be using a wireless Bluetooth keyboard to test, but if you don't have one, you can just use the Android emulator.

Handling Configuration Changes
Some device configurations change during runtime. Things like connecting Bluetooth and changing the screen orientation are considered configuration changes. So why are configuration changes significant to this course? Configuration changes trigger an app restart and when an app restart is triggered, it can cause your application to become distorted or irregular. I'll show you what I mean. Here's our Tabian Dating application. Everything is working fine, I haven't changed anything yet. Now I'm going to connect my wireless Bluetooth keyboard. There it's connected. Now that the keyboard is connected, I'm going to click on this user and navigate to their profile. See what happened? Now I'll open the navigation drawer and go to Settings. Same thing. What's happening here is the application actually stacked on top of itself. When the app restarted, the previous fragments didn't get destroyed, so they're still visible. That's why you can see home fragment in the background and also the user's profile we navigated to. Every app is going to be distorted differently. The way this one is coded, it just happens to stack the fragments. But it's all due to the configuration change that's triggered when the Bluetooth is attached. If this happened to your application, panic is likely going to ensue. But there's actually no reason to panic. The fix is very simple. Open the manifest. All we need to do is tell the activity what to do when a configuration change occurs. So in the MainActivity tag write configChanges keyboardHidden keyboard, and navigation. This is telling the application not to restart when these configuration changes occur. There's many different configuration changes to watch out for. This particular combination is the one that solves our problem. I actually don't understand why we need to include the navigation configuration change, but it doesn't work properly without it. We'll come back and talk about the others, but for now, run it and let's see if we're still seeing the problem. Click Login. Remember we only specified configuration changes for MainActivity, not LoginActivity. So we need to make sure to login before connecting the keyboard. Now I'll connect the keyboard, and click a profile. Great, so it's not causing any issues connecting the keyboard. But what about disconnecting? There we go. That's also fine. So that solves our problem. Back to what I said earlier about the navigation configuration change, I don't understand why we need to include this, but we do. If we refer to the Android documentation at developer. android. com/guide/topics/manifest/activity-element and then go down to the configuration change section, next to navigation it says the navigation type (trackball/dpad) has changed. This should never normally happen. It says it should never normally happen. But it does. If anyone has an answer to this, please leave a comment in the discussion section of the course so we can all benefit. Anyway, as you can see, there's many different configuration changes to watch out for. If you're seeing some strange behavior in your application when connecting a keyboard or doing something else, you might want to check the configuration changes. Go back to Android Studio. I'm going to copy these configuration changes and paste them into the other activities. That way if the user is in another activity other than MainActivity, and they connect the keyboard, the app isn't going to act strangely.

Identifying Issues with Tab Navigation
As I stated in the introduction, the primary method of navigating when a hardware keyboard is attached is by pressing the Tab key. But the default behavior is usually far from perfect and as you'll see, we're going to run into some issues due to different Android versions. The three fragments we need to specify keyboard navigation in our SettingsFragment, MessagesFragment, and ChatFragment. You can get to SettingsFragment by opening the navigation drawer, then selecting Settings. You can get to MessagesFragment by navigating to the icon on the far right of the bottom navigation. And you can get to ChatFragment by selecting a user to chat with in MessagesFragment. Before we start writing anything, I want to point out the versioning issues I'm aware of. These two phones are made by the same company called Oneplus. On the right is a Oneplus Five running Android Oreo, which is API 26, and on the left is a Oneplus Two running Android Marshmallow, which is API 23. Let's explore the differences. On the phone running Marshmallow, notice the focus starts on the name field. On the phone running Oreo, the focus also starts on the name field. Now I'm going to press Tab until the focus reaches the Save button on the one running Marshmallow. Other than the keyboard staying open, that was fine. Now I'll do the same thing on the phone running Oreo. Everything appears to be the same, but now watch what happens when I press it one more time. On the phone running Marshmallow the focus jumps back up to the name field. Now I'll do the same on the phone running Oreo, the focus jumps to the profile picture. Let's talk about the issues. First we'll talk about the phone running Marshmallow. For starters the toolbar isn't focusable. Currently pressing Tab never lets the user get to the toolbar, which means they can't press the back arrow. Same thing goes for the profile image. It's not being focused at all, that's a problem. The user needs to be able to press Enter on the profile image, in case they want to change their profile picture. Next, the keyboard shouldn't be showing when they select a spinner. Now we'll talk about the issues on the phone running Oreo. Like the phone running Marshmallow, the back arrow is never focused. Also like the phone running Marshmallow, the keyboard is still showing when the spinners are focused. Let's start by addressing the issue where the image view is focusable on the phone running Oreo, but not focusable on the phone running Marshmallow. On old API versions, by default, only edit text fields and buttons will be focusable. But on newer versions, like Oreo, a lot of other widgets are also focusable. That's why we can focus the image view widget on the phone running Oreo. In most cases there's an easy solution for this. Open SettingsFragment. In the CircleImageView widget, add the focusable attribute and set it to true. That will allow the widget to be focused on the older versions like Marshmallow. While we're here, let's also add the focusable attribute to the layout containing the back arrow, since both the versions weren't able to focus it. Now I'm going to run the app on both devices. We'll start with the phone running Marshmallow. First notice the profile image still doesn't appear to be focused. Now I'll continue to press Tab until I get to the Save button. Now I'll press Tab one more time. Now this is interesting, the focus doesn't appear to be anywhere, nothing has been highlighted. I'm going to press Enter and see what happens. Choose photo activity has been opened. That means I actually did have the focus on the profile image widget, it just wasn't highlighted. This is another version difference. On the phone running Oreo, the focused widgets are highlighted, but on the phone running Marshmallow, they get focused but they aren't highlighted. So the user can't tell what's being focused. So in summary, by adding the focusable attribute, we were able to make the profile image focusable, but it doesn't highlight. And the focusable attribute did not make the back arrow focusable at all. Now let's move onto the phone running Oreo. Looks like now the focus is starting on the name field, which is fine, as long as it still goes back to the profile image later. So now I'm going to tab down to the Save button. Now I'll press Tab one more time. Looks like the profile image was focused. If I press one more time, I get back to the name field. Alright so that's mostly good. The only thing is we're not able to focus the back arrow in the toolbar. Let's start by fixing the issue with the Marshmallow version not highlighting what's being focused. Remember, we're able to focus the profile image now, but it's not highlighting. In SettingsFragment, scroll down to the profile image, write Android background? android:attr/selectableItemBackground. That's going to highlight the widget when it gets focused. Scroll up to the back arrow. Add it here also since eventually we're going to need to focus it. Now I'm going to run the app on both devices and see what happened. First I'll make sure the phone running Oreo is still working. Yep that looks good. Now I'll make sure the phone running Marshmallow is also working properly. Great. The focus is now being highlighted. So at this point both phones are working almost correctly, everything except the back arrow is being focused.

Using NextFocusForward to Navigate
Now that you understand what we're dealing with, what we're trying to accomplish, and what the differences are, let's look at the Android documentation and see what they recommend. Go to developer. android. com/training/keyboard-input/navigation. html. Scroll down to where it says Handle Tab Navigation. According to the documentation, we can add the nextFocusForward attribute to the widgets to specify their order. However, unless you have a completely linear layout without nested relative layouts, nested linear layouts, toolbars, or any other layouts, it won't work properly. So in other words, it's probably not going to be very useful in 90% of the situations that you'll run into. I'll show you what I mean to prove it. Open SettingsFragment. Let's try to apply what the documentation says. Let's add the nextFocusForward attribute to the save button and set it to the back arrow. Now let's see if the back arrow is focused when we press the Tab on the Save button. I'll run it on both devices. First we'll test on the phone running Marshmallow. I'll tab down to the Save button and then I'll press Tab again. That's great. The back arrow is focused. Now I'll press Tab again. So it skipped the profile image now. Now let's try on the phone running Oreo. I'll tab down to the Save button, now I'll press Tab again. Nothing happens. No matter how many times I press Tab, nothing is happening. So the focus is essentially lost with no way to regain it with Tab. This is a perfect example of the versioning issues. One on phone nextFocusForward works, but on the other the focus is lost and essentially makes tab unusable. And this is just one example. Every layout is going to give you different results based on how it's built. That makes it almost impossible to design tab navigation in such a way that most Android versions will work properly. After playing around with this layout and a few others from the other projects of mine, I've come to the conclusion that the best way to use nextFocusForward is to pretty much not use it at all. Defining tab navigation in XML is too unpredictable, so instead, we're going to define tab navigation programmatically in the fragment and activity classes. Before I end the clip, I'm just going to delete this nextFocusForward attribute. We aren't going to be using them at all in this layout.

Implementing Programmatic Tab Navigation
As you saw in the previous clips, the most reliable way to implement proper tab navigation is going to be programmatically. Instead of defining what happens in XML, we're going to intercept when the user clicks the Tab button and force the focus exactly where we want it. Open MainActivity. The first step in this procedure is intercepting the click events. To capture the click events, we need to implement the KeyEvent. Callback interface. Now scroll down to the bottom and let's implement the methods. We're interested in the onKeyDown method. We want to intercept the click before anything happens. OnKeyDown will ensure that. Now there's only three fragments we want to manually handle the tab navigation in, SettingsFragment, ChatFragment, and ViewProfileFragment. So before we intercept the click event, let's make sure we're in one of those fragments. Create a new method named isChildFragmentVisible. Have it return a Boolean. Now check to see if one of those fragments is visible, first check ViewProfileFragment, so if ViewProfileFragment does not equal null, then if ViewProfileFragment isVisible, return true. Now copy that and change it to ChatFragment. So just paste it below and change those to ChatFragment. Now copy one more time and check SettingsFragment. Now inside the onKeyDown method, write if isChildFragmentVisible and then if keyCode = KeyEvent. KEYCODE_TAB, then we're going to create a method named moveFocusInFragment. We haven't made this method yet, but we're going to in each one of the fragments. MoveFocusInFragment is going to be our generic method for moving the focus to the next widget. Let's build it. So private void moveFocusInFragment, and the first case is if the fragment is viewProfileFragment. So we've got to do the same thing if ViewProfileFragment does not equal null, and then if ViewProfileFragment isVisible, we want to write ViewProfileFragment. moveFocusForward. Of course we haven't built the moveFocusForward method yet, we'll get to that shortly. Copy that and change everything for ChatFragment. Now copy that once more and change everything for SettingsFragment. First let's build the method for SettingsFragment. So open SettingsFragment. I made a gist to save time, visit this URL. Copy the contents from the one named SettingsFragment. java. Now go to SettingsFragment. Paste it in at the bottom of the file. Now each time Tab is pressed, this method will be called. It works by determining what the current focus is, then setting the next focus accordingly. For example, if the current focus is the back arrow, then it sets the focus to the profile image. If the current focus is the profile image, then it sets the current focus to the name field. The only thing that might seem confusing to you is this bottom case. If the current focus is the Save button, then the next focus is the background. As you can see, this case is a little different than the others. There's a line here that says BackArrow. getParent. requestChildFocus and then BackArrow and BackArrow. We need to add this line because the back arrow is nested in the toolbar. In a way it's forcing the focus up there. I couldn't get it to work any other way. If you know of another way, I'd love to hear it. Leave a comment in the discussion section of the video so we can all benefit. But that's generally it, that's the game we need to play to get the focus where we want it. I'm going to follow basically the exact same process for ViewProfileFragment and ChatFragment to accomplish our tab navigation needs. Go back to the gist, copy the contents of the method in ChatFragment, now go to ChatFragment, scroll down to the bottom and paste in the method. I'm not going to explain this as it's exactly the same, except it's using the widgets in ChatFragment. So now open fragment_chat. Add the focusable attribute to the back arrow and also set the background. Copy those two attributes, paste them into the relative layout whose id is relLayoutTop. Scroll down to the AutoCompleteTextView. We don't need to add anything to the AutoCompleteTextView because it's already focusable by default, but this text view we do. Just set focusable to true and since it already has a background, we're good to go. Now go back to the gist and copy the contents of the method in ViewProfileFragment. Go to ViewProfileFragment, scroll down to the bottom, and paste it in. Now open fragment_view_profile. Go to the back arrow, add the focusable attribute and set the background to what we've been setting them to. Copy those two attributes, scroll down to the LikeButton widget and paste them in. I'm going to run it on both devices now and take a look. We'll start on the device running Marshmallow. I've connected the keyboard and I'm currently viewing SettingsFragment. I'll tab down to the Save button and now I'll tab once more. Awesome. We're on the back arrow. Now I'll press Tab again. The profile image is focused. And one more time for good measure. We're back at the name field. Great, so that's all working perfectly. Let's check out the phone running Oreo. I'll tab down to the Save button, now I'll press Tab once more and we're up on the back arrow. I'll press Tab again, the profile image is being focused. One more time, we're back to the name field. Awesome. So both devices are exhibiting the exact same behavior. Before we move forward, I want to address one more issue with the focus. I'm going to navigate to HomeFragment on both devices. Watch the device with Oreo on it. As I press Tab, the focus jumps to this next list item. If I press Enter on any of them, ViewProfileFragment inflates in the same way as if I touched it with my finger. All I want you to notice here is that it's working correctly. Nothing is wrong with that. Now watch the phone running Marshmallow. I'm pressing Tab and nothing is happening. We're running into the same situation as we did in SettingsFragment with the profile image. We need to make the list items focusable. Open layout_main_feed. This is the layout for the recycler view list items in HomeFragment. Add the focusable attribute to the card view and set it to true. Now the list items will be focusable. But remember what happened in SettingsFragment? We need to make the profile image focusable, when we made the profile image focusable it still wasn't highlighting. So we need to take care of that. In SettingsFragment we set the background like this, Android:attr/selectableItemBackground, but unfortunately that won't work for list items. We'll need to change the background color manually, and to do that we're going to use something called an on focus change listener. We'll take a look at that in the next clip.

Implementing an OnFocusChangeListener
Open MainRecyclerViewAdapter. This is the device running Marshmallow. Now that we've set the list items to focusable, when I press Tab, they're actually being focused, just not highlighted. I can tell because if I press Tab and then Enter, I'm navigated to a profile. That means the focus is working, the list items just aren't being highlighted. Scroll down to the onBindViewHolder method. At the bottom of the method write holder. cardView. setOnFocusChangeListener and then new OnFocusChangeListener. Now when the focus changes, this listener will be triggered. We just need to change the background color. So write if view. hasFocus and then we want to change the background color. Otherwise we just want it to be white. So write holder. cardView. setCardBackgroundColor and then Context. getResources getColor and then reference the lightGrey color. Else, holder. cardView. setCardBackgroundColor and just set it to WHITE. Now I'm going to run it on both devices and take a look. I know the phone running Oreo was working fine, but let's test it anyway. The keyboard is connected and I'm current in HomeFragment. As you can see, tab is working correctly and I'm able to navigate through the list items. Now let's check the device running Marshmallow. As you can see, the focus is being highlighted and I'm able to tab through the list of items. If I select one, I'm taken to their profile. And that's another problem solved. If you recall from earlier in the module, I mentioned the soft keyboard was staying open in SettingsFragment when the spinners were focused. This is not ideal. There's no reason for the keyboard to be open on a spinner. Let's use what we've learned about an onFocusChangeListener and close the keyboard when it's focused. Open SettingsFragment. Scroll up to the top and implement the onFocusChangeListener interface. Click the red light bulb and implement the method. Remember when tabbing through views, it's the focus that's changing, so we just need to listen for when the focus is on one of the spinners and then close the keyboard. Before we write anything, I want to point something out. Open IMainActivity. Notice the interface method named hideKeyboard. Open MainActivity. I'm going to press Control+F and search for the hideKeyboard method. So there's already a method for hiding the keyboard in MainActivity and since SettingsFragment is hosted in MainActivity, we can just reference this through the interface. Go back to SettingsFragment, write a switch statement on the view id. The first case is the gender spinner, so case R. id. gender_spinner, and then Interface. hideKeyboard. Next is the interested in spinner, so just copy the one above and change this to interested_in_spinner. And finally the relationship_status_spinner. Scroll up to the getSavedPreferences method and let's set the listener to the spinners. First the GenderSpinner, then the InterestedInSpinner, and finally the StatusSpinner, and that's it. I'm going to run it on both devices and take a look. I'll check the device running Marshmallow first. So I'll connect the keyboard and go to SettingsFragment. Now I'll tab through the views. I'm on the phone number field now, so the next tab should close the keyboard. Great, everything is working as we expect. Now for the device running Oreo, I'll tab through the views, and awesome, everything is working correctly.

Handling Directional Navigation
Using Tab isn't the only way to define navigation with a hardware keyboard. We can also define navigation using the arrow keys. Let's take a look at the Android documentation and see what kind of options we have. Scroll down to the heading that says Handle Directional Navigation. Once again, the Android team has given us some XML attributes to specify what widget should be focused, depending on what arrow key is pressed. You've probably already realized, but this is going to put us in pretty much the same situation as we were with the nextFocusForward attribute. Defining movements in XML is going to yield some pretty unpredictable behavior. For that reason, I'm not going to use any of these attributes. In my experience, using the arrow keys will mostly work, as long as you add the focusable attribute to your widgets, which we've already done. Before we move forward, I just want to point out a few details about navigating with the arrow keys and how we're going to fix them later in the course. Here we have the current version of the application running on both devices. The first thing I want to point out is in HomeFragment. On the device running Marshmallow, I can navigate the list items using the arrow keys or Tab. That's all great, but there's no way I can select the bottom navigation view, no matter what I press. If we compare with the device running Oreo, all I need to do to focus the bottom navigation view is keep pressing the left or right arrow key until it's focused. Basically I can freely focus the bottom navigation whenever I want by pressing the left or right arrow keys. Because of this versioning issue, we're going to bind certain keys and trigger the movement of the bottom navigation. More specifically, we're going to bind Control+Right and Control+Left to shift the bottom navigation. That way it won't matter what version the device is running. The user will be able to use the bottom navigation.

Navigating a GridView Using a Keyboard
As I'm sure you've already realized for yourself, there's a ton of exceptions and special cases we need to watch out for when navigating with the arrow keys and Tab. We're going to take a look at a very difficult layout to navigate with a keyboard. Actually I should say, difficult to navigate consistently across API versions with a keyboard. This is GalleryFragment. You can get to this fragment by clicking on the profile image in SettingsFragment. As you can see, there's two tabs, one for selecting a photo from the phone's memory and one for taking a new photo using the phone's camera. In GalleryFragment there's a spinner for browsing the directories in the phone. The user can choose a photo in the grid view below, then click the Choose button here and set it to their profile. This layout is extremely difficult to define keyboard navigation for a number of reasons. Number one, it has a view page of our hosting tabs. The view pager will compete for the focus when we press the right and left arrow keys. Number two, it has a grid view. The grid view will also compete for the focus. And if we wanted to build something custom, like we did for SettingsFragment, ViewProfileFragment, and ChatFragment, it would be very complicated. So where does that leave us? Open fragment_gallery and let's take a look. Because the grid view would make it very complicated to design a custom focus navigation system, we're going to use the focusable attribute and the nextFocusForward attribute. Since we don't have a toolbar and the layout is pretty linear, we can get away with that. To make sure the widgets look focused on devices running API versions earlier than Oreo, I've set the background to selectableItemBackground, just like we did in the previous clips, because, remember our device running Marshmallow doesn't highlight the widgets that are focused, so we need to set the background like this. Each widget I want focused has the same thing. There's the spinner, there's the Choose button, that's actually a text view that looks like a button, and there's the GridView. Now I'm going to run the app on both devices and show you the problems. We'll start with the device running Marshmallow. If I tab once, I'm taken to the X, and if I tab again I'm taken to the spinner. And one more time takes me to the Choose widget. That looks all good, but watch what happens now. You can't tell what image I have selected. The focus is actually right here on the first image. The next problem has to do with the view pager. Watch what happens when I press the right arrow key a bunch of times, the view pager swipes over. I don't like this behavior. I think the only way a user should be able to swipe with the keyboard is by pressing a special key, something like Control+Left or Control+Right. I just wanted to point that out. We'll be fixing that in the next module. Now let's take a look at the device running Oreo. There's the first tab and the second and the third, and the fourth. So once again, the grid items aren't being highlighted. And if I press the right arrow key a bunch of times, I'm taken to the next tab. So we have the exact same issues as the device running Marshmallow. That's actually a relief. At least both versions have the same problems. Now that you know what's going on, let's fix that highlighting problem. Scroll down to the GridView widget. First set the choiceMode to single, that's going to ensure only a single image can be selected at a time. Now set drawSelected on top to true. This will make sure the highlighted color is placed on top of the image and not behind. Later I'll set this to false and show you what I mean. And the last attribute is setting the actual highlight color, it's called listSelector. We haven't added this color yet, but we're going to call it transparentGrey. Open colors. xml and let's add that color. Copy one of the other colors, now change the name to transparenGrey. If you don't know how hex colors work, the format is alpha alpha red red green green blue blue. The first two digits represent the alpha, but if you don't specify them then the default is fully visible, or in other words ff. That's what you see with these colors. I didn't specify the alpha, so they're all fully visible. But with this color, we don't want it to be fully visible. We want it to be partially transparent so we can still see the image in the grid. If you still don't get it, here's a demonstration. I'll copy one of the hex values from one of these colors. This shade of red is fine. Now if I add 00 to the front, that sets the opacity to 100%, or in other words, it's 100% see through, and that's what we see over here on the left, there's no color. On the other end of the spectrum I can set it to ff. Now it's opacity is 0%, making it 100% visible. And it's exactly the same as the original color I copied it from. For our transparentGrey we want it somewhere in the middle so it's not completely see through, but it's not going to block the image either. Let's use 5f. See the color is showing, but it's faded. Now to make it grey, we can just change the hex color to 000000, that's the hex color for white, but since grey is technically a color somewhere in between black and white, this will work. And there's our transparentGrey. Run it and let's take a look. We'll test on the phone running Oreo first. So I'll tab down to the grid view, and there, as you can see, it's much easier to tell what image is being selected. Now for the phone running Marshmallow. I'll tab down to the grid view, the list items are being highlighted, but there's another issue. If I press Tab while I have a list item focused, it moves the focus down to the tab layout, see, there's the focus. It doesn't do that on the device running Oreo, so here we have yet another version issue. However, I wouldn't say this one is a deal breaker. Because if I have the focus on the grid, I can still use the arrow keys to navigate the grid items. See, I can effectively navigate the grid without using Tab. Go to fragment_gallery and remove the drawSelectorOnTop attribute. Or just set it to false. I want to show you what I was talking about. It doesn't matter what device we look at, they're both going to exhibit the same behavior. Now I'll tab down to the grid view. See, it's like we didn't even add a selector. That's because the image is being displayed on top of the selector. So we don't see any color change. Set the drawSelectorOnTop attribute back to true, now we'll be able to tell what GridView item is being focused.

Module Review
We started the module by talking about the configuration change triggers. Some examples of configuration change triggers are connecting a Bluetooth device, rotating the screen orientation, and disconnecting a Bluetooth device. We saw when connecting the Bluetooth keyboard, the app began to behave strangely. The fragments were stacking due to the configuration change. Lucky for us, the resolution is actually very simple. In the manifest, we specified the configuration changes to watch out for, by adding these to the activity the app will no longer restart when the configuration change is detected. Next we talked about some of the difficulties you'll likely run into when defining tab navigation. I'm testing on two devices, one running Oreo and one running Marshmallow. By default, the phone running Marshmallow did not focus any widgets other than the edit text fields and the buttons. The phone running Oreo focused almost everything. The only thing it had difficulty focusing was toolbars or widgets within toolbars. The first problem we had to solve was making up for this discrepancy. For each widget we wanted focused, we added the focusable attribute and set it to true. We also added a background attribute and set it to Android:attr/selectableItemBackground. That will ensure devices running API versions earlier than Oreo will be able to focus the widgets you want and the background color will highlight once they're focused. The next problem was getting the back arrows to focus in the toolbar, and as I mentioned, both the device running Oreo and the device running Marshmallow were unable to focus the back arrow. We consulted the Android documentation and it said to use nextFocusForward as an attribute. So we added the nextFocusForward attribute to the Save button in SettingsFragment. Surprisingly the attribute worked on the device running Marshmallow. We were able to focus the back arrow after pressing Tab on the Save button, but unfortunately it didn't work on the device running Oreo. I'm sure I don't need to tell you, but this is an absolute nightmare for developers. Versioning issues are zero fun to deal with. Because of this discrepancy, we decided to build a custom navigation system for managing the focus programmatically. That way there shouldn't be any versioning issues. In MainActivity we implemented the KeyEvent. Callback interface and intercepted the click events on the keyboard. We listened for when Tab was pressed and moved the focus programmatically. Next we worked on implementing an onFocusChangeListener. The onFocusChangeListener was used to fix two main problems. Number one was the RecyclerViewListItems in HomeFragment were not being highlighted on the device running Marshmallow. Number two was the soft keyboard was still showing even when the spinners were being selected in SettingsFragment. To resolve the focus not being set in HomeFragment, we set an onFocusChangeListener to the list items. When the focus was changed, the background of the list item would be changed. To hide the keyboard in SettingsFragment, we wrote a switch statement in the onFocusChangeOverride method. Inside this switch, we looked for the id of the spinners and closed the keyboard. By default, a GridView's list items don't highlight very well when focused. You literally can't tell what item is currently focused. To resolve this issue, we created a partially translucent grey color and set it to the listSelector attribute in the GridView. We also set choiceMode to singleChoice so only a single list item can be focused. And we set the drawSelectorOnTop attribute so the color is set on top of the image and not below it. If this attribute is set to false or not set at all, the color will not show on top of the image, making this whole process pointless. In the next module we'll work on binding custom keyboard actions, like opening the navigation drawer, swiping through tabs, triggering the SwipeRefreshLayout and focusing the SearchView widget.

Handling Keyboard Actions
Introduction
For the duration of the module, we'll be working with the source code files in the directory Module_7/Start/TabianDating. If you imported the code from GitHub, you'll want to start with the branch named Module_7. 2_Start. So far we've defined how a user can navigate widgets on the screen by pressing Tab and the arrow keys. But some things aren't accessible using Tab and the arrow keys. In our application, widgets that aren't accessible are the navigation drawer, the swipeRefreshLayout and the SearchView. Another thing that could use improvement is swiping through tabs. In choose photo activity, the arrow keys are the only way a user can get to the tabs. It would be much more convenient if they could do something like press Control+Left or Control+Right to swipe. In ChatFragment, when a user presses the Enter key on the keyboard, a carriage return is executed, or in other words, they're taken to the next line. I actually like that functionality, but it introduces a problem. How do they actually send the message? Of course they could tab over and press the Send button, but it would be nice to be able to press a key and then just send the message. Something like Shift+Enter would be great for this, that way they can press Enter to move to the next line or Shift+Enter to actually send the message.

Binding Custom Keyboard Actions
We're going to start by listening for key presses on the keyboard and opening the navigation drawer. Open MainActivity. As you already know, to listen for button clicks to the keyboard, we need to implement the keyEvent. Callback interface. Currently we're using the onKeyDown method to intercept clicks to the Tab button, but there's another method we can use, the onKeyUp method. Press Control+O on Windows or Command+O on Mac. We want the onKeyUp method, that way the method will trigger when the user lets go of the key they pressed. The first piece of functionality is actually opening the navigation drawer. You combine whatever key you want, but I'm going to use Control+Tab to open the drawer. Start by writing a switch statement for the keyCode. So switch the keyCode and then for the first case write KeyEvent. KEYCODE_TAB and return false. Then make sure Control is being pressed by writing if event. isCtrlPressed. Now we need a method for actually toggling the navigation drawer. We're going to build a method and it's going to be called toggleNavigationDrawer. If the drawer isn't open, it will open. If the open is open, it will close. And of course, write a default case for this switch statement. We can just return super. onKeyUp and pass the keyCode and pass the event. Let's build the toggleNavigationDrawer method. Write private void toggleNavigationDrawer, check to make the drawer isn't null, now check to see if the drawer is open, so DrawerLayout. isDrawerOpen and GravityCompat. START and then else, then we want to close it. So DrawerLayout. closeDrawer and GravityCompat. START. If it isn't, then open it. So DrawerLayout. openDrawer GravityCompat. START. Run the app and let's take a look. Connect the keyboard and login, now press Control and Tab. Great, it opened. But the navigation drawer isn't focused. If I keep pressing Tab, it's moving through the recycler view in the background. We need to fix that. Scroll to the top of MainActivity. We need to make the NavigationView object global. Write private NavigationView mNavigationView. Now inside onCreate, replace the local NavigationView with a global one. Now scroll down to the toggleNavigationView method. After opening the drawer write NavigationView. requestFocus. Run it again and let's take a look. Connect the keyboard and login. I'll press Control+Tab. Notice the focus is on the first item in the list. If I press Tab, it navigates through the list items. Now I'll test Control+Tab again and it closes.

Triggering SwipeRefresh with a Keyboard Action
Currently the only way to refresh recycler views in the application is to drag your finger downwards on it, that will trigger the swipe refresh layout to refresh the list. But we need every action in the application to be accessible with a keyboard, so we're going to bind a key that refreshes the recycles views. Open MainActivity. Let's start by actually building the method for executing the refresh. Write private void refresh. There's three lists we want to refresh, the recycler view from HomeFragment, the recycler view from SavedConnectionsFragment and the recycler view from MessagesFragment. So the first case we just write if HomeFragment does not equal null and then call HomeFragment. onRefresh. The next one is if SaveConnectionsFragment does not equal null, then we want to do SaveConnectionsFragment. onRefresh. And finally, is MessageFragment does not equal null, MessagesFragment. refresh. The last key we bound was Control+Tab. For the refresh, we're going to use Control+R. So the KeyEvent is KEYCODE_R and then we want to check if Control is pressed once again and then just call refresh. That's it. Let's give it a try, run the app. Connect the keyboard and login. Open all the fragments so we can tell if the refresh is actually occurring. Now go back to HomeFragment, select a bunch more users at random and like them. I'm just going to like these ones. It doesn't matter what you choose, we're just testing here. Now navigate to SaveConnectionsFragment. Notice the list has not been updated. Now if we press Control+R, we see that the list is refreshed. Now check the other one, and that one has also refreshed.

Sending Chat Messages with a Keyboard Action
Currently in ChatFragment, if you press Enter it returns to the next line. We want the message to send if the user then presses Shift+Enter. Open MainActivity. We'll start by building a method for actually sending the message. Write private void sendChatMessage. We need to check if the fragment is null before calling any of its methods. So if ChatFragment does not equal null, then if it's not null, we can check to make sure it's in view. So if ChatFragment isVisible, after all that we can call a method for sending the message. We haven't made it yet, but it's going to be called postMessage. Open ChatFragment and let's build postMessage. Just below onCreate write public void postMessage. Note that this is a public method. Basically we want to copy everything done when the user clicks the button to post the message. So copy all of this right here. Now scroll up and paste it in postMessage. This isn't going to work properly, but we'll come back and fix it later. Go back to MainActivity. Now because we're going to be pressing Shift, this is going to be a little different. I'm going to start by separating the Shift key from the non-Shift keys, so if not event. isShiftPressed else. Now copy the switch and put it inside both the if logic and the else logic. But delete everything except the default and one of the switch cases in the else section. Now change the key to KEYCODE_ENTER and the method to sendChatMessage. Run it and let's see what's happening. Login, connect the keyboard, go to messages and select a chat. I'm going to type a message. Now press Enter and go to the next line. Now I'll press Shift+Enter. As you can see, the message was sent, but a second return was executed just before it got sent, which doesn't look good. That's what I was talking about when I said it's not going to work perfectly. Go back to your ChatFragment and let's fix it. Start by declaring a string object named message. That's going to make things a lot easier for us to organize this. Now if the message contains a new line at the end, we want to remove it. We can check for a new line like this. So if message. charAt message. length -1 equals System. getProperty line separator. We need to add this empty string to the front because otherwise Android Studio will think it's a character. So if it contains a line separator at the end, we just need to snip it off. Message = message. substring 0, message. length -1. Now pass the edited message to here, run it and take a look. Go to messages and select chat. I'm just going to type a message, then press Enter and go to the next line, and now type another message. Now I'll press Shift+Enter, and that looks good.

Customizing Tabs Using Keyboard Actions
Currently if we want to navigate to the next tab using a keyboard, we need to use the left or right arrow keys. This functionality is clunky to say the least. The user needs to move the focus to the right or the left most widget, then press Right or Left to access the tab. And this can be done at any focus height. So if I'm at the top in the toolbar, or if I move downwards to the grid view, then move the focus all the way to the right, I really don't like this. It would feel much cleaner if you couldn't swipe the tabs that way. And the only way to swipe would be to press Control+Right or Control+Left. Of course that's just my opinion, but that's what we're going to be implementing in this clip. We're going to disable the default behavior of the view pager and then bind keyboard actions to swipe left or swipe right. Open ChoosePhotoActivity. This is the activity that hosts the two fragments in the tabs, GallergyFragment and PhotoFragment. Right here we're using a plain old viewpager to hold the fragments and therefore host the fragments. We want to build a custom viewpager class that doesn't allow the right and left arrow keys to swipe the tabs. I'll show you what we need to disable. Hold Control and click on the viewpager object. This is the default viewpager class provided by the Android SDK. Press Cotnrol+F and search for the method named executekeyevent. This is the method that causes the viewpager to swipe when the left or right arrow keys are pressed. If this wasn't here, then it wouldn't be able to swipe using the arrow keys. So basically all we need to do is build a custom viewpager class that doesn't have this method. Close the viewpager class, right click on the settings package, to to New, Java Class, and call it MyViewPager. Extend by the ViewPager class, now click the red light bulb and add the two constructors. Remember all we need to do is alter the executeKeyEvent method. So press Control+O on Windows or Command+O on Mac and search for the executeKeyEvent and insert it. Now return false here. Now the default behavior with the arrow keys is disabled. Open activity_choose_photo. Comment out the old viewpager, now add the one we just created. Give it a width of match_parent and a height of match_parent and give it the same id as the old viewpager. Open ChoosePhotoActivity. Now we need to write our own custom keyEvents, just like we did before, implement the KeyEvent. Callback interface. Now scroll down and insert the onKeyUp override method. Since there's only two tabs, the logic is pretty simple. We either want to tab left if we're currently on the right tab, or tab right if we're currently on the left tab. We'll make methods for both cases. So write private void tabRight, then if ViewPager. getCurrentItem = 0 ViewPager. setCurrentItem 1. Now for the tabLeft method, copy the tabRight method, paste it below, change it to say tabLeft, change this to a 1 and change this to a 0. To save some time, go to MainActivity and copy the switch logic for onKeyUp. Just copy this switch statement and make sure to include the default. Now go to choosePhotoActivity, paste it in on KeyUP, change the first KeyEvent to KEYCODE_DPAD_LEFT and then call the TabLeft method. change the second KEYCODE to DPAD_RIGHT and then call the tabRight method. That's it. Let's run it and take a look. Connect the keyboard, login, go to settings, click the profile picture. First let's make sure the default behavior was disabled. Click the right arrow key a bunch of times. Notice it's not swiping over. That's good. Now press Control+Right, now press Control+Left, and that works too. That's a much cleaner way to swipe through tabs with a keyboard.

Focusing a SearchView
In MessagesFragment on the device running Marshmallow, we can focus every widget in the layout very easily. We just need to keep pressing Tab and we can get to anything. But in the device running Oreo, there's currently no way to focus the search view. No matter what I press, I can't focus it. If you recall from a couple of clips ago, we were having trouble focusing toolbars on the device running Oreo. The only consistent solution we were able to come up with was implementing a custom focus navigation system. The system would move the focus programmatically, but unfortunately we can't do that here because of the recycler view. It would make things very complicated. Because everything works so perfectly on older versions, I want to change this as little as possible. So we're going to bind a specific key for focusing the search view. Open MainActivity. Scroll down to the onKeyUp method. We're going to start by binding a key to target the search view. Just below the onKeyUp method, create a new method named focusSearchView. Now check if MessagesFragment is null, if it's not null we want to check if it's visible. Open MessagesFragment. We need to make the search view visible so we can reference it from MainActivity. Now go back to MainActivity. Now write MessagesFragment. SearchView. requestFocusFromTouch. Now create a new case for the switch statement in onKeyUp. Just copy the one above, paste it in, and now change the key to KEYCODE_S and call the focusSearchView method. Normally that's all we'd have to do, but search views are a little tricky. Open fragment_messages and now set iconifiedByDefault to false. That's going to prevent the little animation when focusing the search view. Unfortunately we need to disable that to use the keyboard. Run it and let's try it out. Connect the keyboard and navigate to MessagesFragment. It looks like the search view is focused right away. Having the search view focused is similar to having the soft keyboard open. To get the focus away, we need to press Back or Escape. I'll press Escape. Now press Escape one more time. Now the recycler view is focused. Now to get back to the search view I can press Control+S and there we have the search view focused.

Shifting a Bottom Navigation View
The last piece of functionality we're going to implement is navigating the bottom navigation view using keyboard actions. Open MainActivity. Scroll down to the onKeyUp method. Copy the KEYCODE_S case and paste it below twice. Change the first one to say KEYCODE_DPAD_LEFT, and the bottom one to KEYCODE_DPAD_RIGHT. Now inside the if statement, checking for the Control key, write shiftLeft and then shiftRight for the bottom one. We haven't made these methods yet, but they're going to be responsible for shifting the bottom navigation view left and right. But before we build these, we need a way to check if the bottom navigation is even visible. It's only going to be visible in HomeFragment, SaveConnectionsFragment, and MessagesFragment. So we can just check to see if any of those are visible. Create a new method named isBottomNavigationVisible and have it return a Boolean. First check if HomeFragment is visible, start by making sure the fragment isn't null, and then check the visibility. If it's visible, that means the user is currently looking at it. Copy that case and paste it below twice. Change this one to SavedConnectionsFragment and this one to MessagesFragment. Now we're going to make the shiftLeft and shiftRight methods. Write private void shiftRight, now first check to make sure the bottom navigation is visible. Now write the logic for making the transition. So ifBottomNavigationViewEx. getCurrentItem = 0, then mBottomNavigationViewEx. setCurrentItem 1. Else if BottomNavigationView. getCurrentItem = 1, then BottomNavigationView. setCurrentItem 2. Copy the shiftRight method and paste it below. Rename it to shiftLeft. This is going to be mostly the same, we just need to change this number to a 1, this number to a 0, this number to a 2, and this to a 1. Run it and let's try it out. There's no need to test on both devices here. I have logged in and connected the keyboard, now I'm going to press Control+Right, now Control+Right one more time. Okay let's try the other way, so Control+Left and Control+Left again. So everything is working as we expect.

Module Review
We started the module by pointing out some of the design flaws regarding the app navigation and the hardware keyboard. In the apps current state there was no way to open the navigation drawer, refresh the recycler views, send a chat message using a keyboard, efficiently swipe through tabs, use the BottomNavigationView, and focus the SearchView. To capture key events from the keyboard, we implemented the KeyEvent. Callback interface in MainActivity. The override method we were interested in was onKeyUp. OnKeyUp will trigger when a key is released from the keyboard. In onKeyUp we wrote a switch statement to capture the different key events we were interested in. To open the navigation drawer, we used the Tab key and required Control to be pressed. To refresh the recycler views in HomeFragment, SavedConnectionsFragment, and MessagesFragment, we used the R key and also required Control to be pressed. In ChatFragment when a user presses Enter on the keyboard, it takes them to the next line. There was no way to actually send the message when the focus was on the edit text field. The only way was to move the focus to the button and then press Enter. To improve the user experience, we added another switch statement in the onKeyUp override method. This switch statement is for detecting when the Enter key is pressed and requires the Shift key to be pressed. So by pressing Shift+Enter, a message can be sent from the edit text field. We worked on improving the tab navigation functionality in ChoosePhotoActivity. In the apps current state the only way to navigate to another tab was to move the focus to the far right or the far left of the view, then press the right or left arrow key. I think this is clunky and needed to be improved. To disable the default keyboard swipe functionality of the viewpager, we built a custom class that extends viewpager. The executeKeyEvent method is responsible for swiping when the arrow keys are pressed. We returned false, so the functionality was effectively disabled. Once we had our custom viewpager class, we added it to ActivityChoosePhoto. We commented out the default viewpager. Now that the default behavior was disabled, we implemented the KeyEvent. Callback interface in ChoosePhotoActivity. We listened for when the user pressed Control+left arrow or Control+right arrow on the keyboard and that became the only way to swipe through the tabs with the keyboard. In MessagesFragment the search view was not focusable on the device running Oreo, however it was focusable on the device running Marshmallow. This is yet another troublesome version difference. Because the tab navigation worked so flawlessly on versions older than Oreo, I didn't want to make any changes. So we bound a key specifically for focusing the search view. On the device running Marshmallow, we're completely unable to focus the bottom navigation view, but on the device running Oreo we can focus the bottom navigation view using the arrow keys or tab to the bottom of the screen. To resolve this discrepancy we bound a keyboard action for using the bottom navigation view. We used the left and right arrow keys accompanied by the Control button. That will ensure a consistent user experience when using the bottom navigation view. In the next module we'll quickly review the most important concepts covered in the course.

Tying It All Together
Review Specifying the Input Method Type
The Android SDK has special attributes you can set to text fields to improve the user experience. This part of the course was all about implementing and exploring those attributes. Some of the attributes we implemented were capitalizing the first letter of every new word in the name field, adding the at symbol to the front page of the keyboard in the email field, and altering the keyboard to only displaying numbers in the phone number field. Of course these aren't the only options available, there's a ton more helpful attributes. For more information on those, make sure to check out the Android documentation at developer. android. com/reference/Android/widget/TextView. html and then scroll down to the Android:inputType heading. After setting the custom attributes, we worked on formatting the phone number field properly. In the app's previous state, a phone number looked like this when it was entered. There were no spaces and no dashes. We made use of a PhoneNumberFormattingTextWatcher and a PhoneNumberUtils class to properly format the phone number as the user enters it. After the implementation, it looked like this when entering a phone number. The Android SDK also offers something called input method actions for some widgets. Input method actions are probably exactly what you think they are. They're methods that are executed behind the scenes when the action button is pressed on the soft keyboard. Like specifying input types, we just need to add a special attribute to the widgets we're interested in. The attributes are called imeOptions. The only one we implemented was actionDone. ActionDone changes the action button to a checkmark, when the user presses it, the keyboard is closed and the focus remains on that widget. If we hadn't added this attribute, the default behavior is to jump to the next widget and not close the keyboard. Take a look at the Android documentation if you want to see other options available, developer. android. com/reference/Android/widget/TextView and then scroll down to the heading labeled imeOptions. In the final part of the module, we address the problem with the view in ChatFragment. When the soft keyboard is open the view was being distorted. This was due to a setting in the manifest in MainActivity. The windowSoftInputMode was set to adjustPan. AdjustPan will force the view to resize when the soft keyboard is shown. We changed it to stateHidden, which resolved the problem. It resolved the problem because the view was no longer trying to resize. For more information on the other options available for windowSoftInputMode, visit the Android documentation at developer. android. com/guide/topics/manifest/activity-element. html.

Review Providing AutoComplete Suggestions
This part of the course was all about improving the user experience by providing search results and auto complete suggestions. Since ChatFragment is essentially a one on one private chat, it would be nice to provide some common greetings to choose from. We implemented an auto complete text view and provided a handful of common greetings. Next we worked on implementing a more advanced version of auto complete suggesting, a search view. Personally I love using search views. They're customizable to any recycler view and can filter large amounts of data efficiently. We customize it to search through the messages and the actual names of the users.

Review Detecting if the SoftKeyboard Is Visible
Sometimes you just can't get the view to do what you want. Especially if the soft keyboard is popping up and distorting it. This part of the course was all about resolving view distortions due to the soft keyboard. The view distortion we addressed was due to the windowSoftInputMode being set to stateHidden. Changing it to stateHidden solved the problem in ChatFragment, but unfortunately for us, it introduced a new problem in MessagesFragment. The navigation view was now showing on top of the soft keyboard. To solve this new problem, we built a custom method for detecting when the soft keyboard becomes visible. If the keyboard is visible, we hid the bottom navigation view. The Android SDK doesn't have any out of the box solution for detecting when the keyboard is visible, so building that method required a bit of heavy lifting, but we got it done.

Review Supporting Keyboard Navigation
We started this part of the course by talking about the configuration change triggers. Some examples of configuration change triggers are connecting a Bluetooth device, rotating the screen orientation, and disconnecting a Bluetooth device. We saw when connecting the Bluetooth keyboard, the app began to behave strangely. The fragments were stacking due to the configuration change. Lucky for us, the resolution is actually very simple. In the manifest we specified the configuration changes to watch out for, by adding these to the activity, the app will no longer restart when the configuration change is detected. Next we talked about some of the difficulties you'll likely run into when defining tab navigation. I'm testing on two devices, one running Oreo and one running Marshmallow. By default the phone running Marshmallow did not focus any widgets other than the edit text fields and the buttons. The phone running Oreo focused almost everything. The only thing it had difficulty focusing was toolbars or widgets within toolbars. The first problem we had to solve was making up for this discrepancy. For each widget we wanted focused, we added the focusable attribute and set it to true. We also added a background attribute and set it to Android:attr/selectableItemBackground. That will ensure devices running API versions earlier than Oreo will be able to focus the widgets you want and the background color will highlight once they're focused. The next problem was getting the back arrows to focus in the toolbar, and as I mentioned, both the device running Oreo and the device running Marshmallow were unable to focus the back arrow. We consulted the Android documentation and it said to use nextFocusForward as an attribute. So we added the nextFocusForward attribute to the Save button in SettingsFragment. Surprisingly the attribute worked on the device running Marshmallow. We were able to focus the back arrow after pressing Tab on the Save button. But unfortunately it didn't work on the device running Oreo. I'm sure I don't need to tell you, but this is an absolute nightmare for developers. Versioning issues are zero fun to deal with. Because of this discrepancy, we decided to build a custom navigation system for managing the focus programmatically. That way there shouldn't be any versioning issues. In MainActivity we implemented the KeyEvent. Callback interface and intercepted the click events on the keyboard. We listened for when Tab was pressed and moved the focus programmatically. Next we worked on implementing an on focus change listener. The on focus change listener was used to fix two main problems. Number one as the recycler view list items in HomeFragment were not being highlighted on the device running Marshmallow. Number two was the soft keyboard was still showing even when the spinners were being selected in SettingsFragment. To resolve the focus not being set in HomeFragment, we set an OnFocusChangeListener to the list items. When the focus was changed, the background of the list item will be changed. To hide the keyboard in SettingsFragment we wrote a switch statement in the onFocusChange override method. Inside the switch we looked for the id of the spinners and closed the keyboard. By default a grid views list items don't highlight very well when focused. You literally can't tell what item is currently focused. To resolve this issue, we created a partially translucent grey color and set it to the listSelector attribute in the grid view. We also set choiceMode to singleChoice, so only a single list item can be focused. And we set the drawSelectorOnTop attribute so the color is set on top of the image and not below it. If this attribute is set to false or not set at all, the color will not show on top of the image, making this whole process pointless. If you are to take one thing away from this module, remember this, versioning issues, versioning issues, and more versioning issues. Be ready to get creative and design custom systems for navigating your project using the keyboard.

Review Handling Keyboard Actions
We started this part of the course by pointing out some of the design flaws regarding app navigation and the hardware keyboard. In the app's current state there was no way to open the navigation drawer, refresh the recycler views, send a chat message using a keyboard, efficiently swipe through tabs, use the BottomNavigationView, and focus the search view. To capture key events from the keyboard, we implemented the KeyEvent. Callback interface in MainActivity. The override method we were interested in was onKeyUp. OnKeyUp will trigger when a key is released from the keyboard. In onKeyUp we wrote a switch statement to capture the different KeyEvents we were interested in. To open the navigation drawer we used the Tab key and required Control to be pressed. To refresh the recycler views in HomeFragment, SavedConnectionsFragment, and MessagesFragment, we used the R key and also required Control to be pressed. In ChatFragment, when a user presses Enter on the keyboard, it takes them to the next line. There was no way to actually send the message when the focus was on the edit text field. The only way was to move the focus to the button and then press Enter. To improve the user experience we added another switch statement in the onKeyUp override method. This switch statement is for detecting when the Enter key is pressed and requires the Shift key to be pressed. So by pressing Shift+Enter a message can be sent from the edit text field. We worked on improving the tab navigation functionality in ChoosePhotoActivity. In the app's current state, the only way to navigate to another tab was to move the focus to the far right or the far left of the view and then press the right or left arrow key. I think this is clunky and needed to be improved. To disable the default keyboard swipe functionality of the viewpager, we built a custom class that extends viewpager. The executeKeyEvent method is responsible for swiping when the arrow keys are pressed. We returned false, so the functionality was effectively disabled. Once we had our custom ViewPager class, we added it to ActivityChoosePhoto. We commented out the default viewpager. Now that the default behavior was disabled, we implemented the keyEvent. Callback interface in ChoosePhotoActivity. We listened for when the user pressed Control+left arrow or Control+right arrow on the keyboard and that become the only way to swipe through the tabs with the keyboard. In MessagesFragment, the search view was not focusable on the device running Oreo. However, it was focusable on the device running Marshmallow. This is yet another troublesome version difference. Because the tab navigation worked so flawlessly on versions older than Oreo, I didn't want to make any changes. So we bound a key specifically for focusing the search view. On the device running Marshmallow, we're completely unable to focus the bottom navigation view, but on the device running Oreo, we can focus the bottom navigation view using the arrow keys or tab to the bottom of the screen. To resolve this discrepancy, we bound the keyboard action for using the bottom navigation view. We used the left and right arrow keys accompanied by the Control button. That will ensure a consistent user experience when using the bottom navigation view. Just like the module on defining tab navigation, this module was all above navigation issues and alternative solutions to overcome them. Once again, versioning issues, versioning issues, and more versioning issues. Be ready to get creative and design custom systems for navigating your project using the keyboard.

Final Thoughts
The importance of keyboard inputs should not be overlooked. I think it's convenient for developers to brush them off because your application will still function without them. But collectively, making use of keyboard inputs will dramatically improve the user experience. Let me paint a mental picture for you. Imagine you just installed a new application onto your phone, you get to the login screen, go to create a new account and start typing your password. Then you discover the password isn't hidden as you're typing it. Although this isn't a deal breaker, I guarantee it's going to make you question the application. Here's another example, imagine you've now created an account and you've logged into the application. You navigate to the profile section, you click on the name field, and to your surprise the view is distorted in some strange way. You can still enter your name, but the view just looks really weird. Between the password not being hidden and the view being distorted, you might just uninstall the application right there. That's why making use of keyboard inputs is so important. With so many apps out there, something as silly as a view distortion and a password not being hidden could easily decrease your user base by like 10%. And I think that's being conservative. Now get out there and improve your applications by making use of keyboard inputs. If you enjoyed the course and thought it provided a lot of value, don't forget to leave a rating on Pluralsight. I use the ratings to gauge my courses against others, if a course gets a good rating, I know I'm on the right track. Afterwards, send me a Tweet to say hi or leave a comment on my YouTube channel. As of right now, I read every single comment. Mention the course so I know where you're coming from and I can personally thank you for watching. My name is Mitch Tabian, and thanks for watching.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Beginner
Rating
0 stars with 8 raters
My rating
null stars

Duration
1h 58m
Released
23 Apr 2018
Share course
