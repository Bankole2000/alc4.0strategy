Understanding Android Application Basics
by Jim Wilson

Start learning the skills necessary to become a successful Android developer by developing your understanding of Android application development and the creation of interactive user experiences with Android Activities.

The key to becoming a successful Android app developer is getting the basics right. Android is a component-based platform that has a different programming model than many other platforms. Understanding this component model, especially the familiar UI components known as Activities, is essential to success. In this course, Understanding Android Application Basics, you'll get a better understanding of the Android application basics. First, you'll start by deploying a simple Android application to become familiar with the environment. Next, you'll walk through the process of designing the user experience for a more involved application. Finally, using the Android Studio designer, you'll layout an interactive activity and connect it to Java code. Throughout the course you'll continue enhancing the app to become a multi-activity user experience that provides interactive editing features and proper Activity lifecycle management.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Beginner
Rating
4.5 stars with 161 raters(161)
My rating
null stars

Duration
3h 51m
Released
31 Mar 2017
Share course

Building a Simple App
Introduction
Welcome to the course, Understanding Android App Basics. This is our first module, Building a Simple App. My name is Jim Wilson. Now as you probably know, this is the first module of the first course in a series of courses, and this series of courses is targeted towards two primary goals. The first goal is skills. We want to provide you with the skills necessary to be an effective Android developer. The other goal is certification. We want to provide you with the knowledge necessary to pass the Android Associate Developer exam. And these two goals are complementary. With the appropriate skills, you can be an effective and valuable member of an Android development team, and with the certification you'll have the clout that shows that you've demonstrated proficiency in the skills necessary to be an effective Android developer. Now of course achieving those goals requires that we cover a number of topics, which is why we've spread this out across multiple courses in a series. So let's now just take a quick high-level look at each of the courses in the series. Now the first course is the one you're in, Understanding Android App Basics, and this is really just intended to get you started in the most fundamental aspects of Android App development. The next course is Working with Android Tools & Testing. Now this one we explore the features in Android Studio and the core components of the Android tool chain. Then we dig into Android Studio's build process, and Android Studio's app testing capabilities. The next course is Enhancing the App Experience. In this one we understand how to use some of Android's richer UI capabilities such as RecyclerView, CardView, and navigation drawers. We'll also look at how we can incorporate testing those features into our app development cycle. The fourth course in the series, Broadening App Appeal and Reach. Here we look at how to give our apps broader reach and appeal. We'll look at creating custom views, customizing our app theme, localization and device adaptability, and how we can add support for users with accessibility needs, and how to allow users to personalize the app experience. In our next course, Managing App Data with SQLite, well as its title implies, we're going to use a SQLite relational database, and we'll see how we can provide our apps with persistent storage using the SQLite relational database, and we'll see the appropriate way to incorporate the database interaction into our activity lifecycle. From there we move into exposing data and information outside your app. And one of the greatest powers of Android is its ability for apps to provide functionality beyond a user's direct application experience. In this course, we'll look at those features, the ability for apps to share data with other apps using content providers, and the ability for apps to have the system display notifications that when tapped will take the user directly into specific parts of their app. And then our final course, Leveraging the Power of the Platform. So we'll finish up with a look at a number of the powerful features of the Android platform. Things like the threading model, the ability to perform background work with services, triggering work in response to alarms and system events, as well as the ability to provide user experiences from within the Android App Launcher using widgets. So as you can see, there are a number of things that we're going to learn throughout this course series. So that's the big picture. But you know one of the challenges that I have when I start working with a new platform is that although I know there's a number of things that I'm going to need to eventually understand to work effectively, the first thing I want to do is just build and run something and see it work, and that's our goal in this module. So in this module, we're just going to cover how to download and install Android Studio, and then we're going to create a new Android project. We'll do some simple design of the user interface layout, we'll add some functionality with code, and then we'll set up an Android emulator and test our application with it. So going through this module, once we have Android Studio installed, in about 20 minutes you'll go through the entire development cycle from creation, to UI layout, to functionality, to testing within an emulator, and so let's get started with that in our next clip.

Downloading and Installing Android Studio
To get started developing our first Android application, we of course need the tools that we use. In the case of Android, that toolset comes in Android Studio. Now getting your machine setting up with Android Studio is super simple. Simply visit the URL that I currently have on screen, click on the box here where it says Download Android Studio. It will then prompt you to accept the Terms and conditions. You download that file, run the file, and then simply follow the on-screen prompts and it will take care of everything you need. Now if you've ever spoken with someone who years ago got started developing for Android and they kind of share these stories about, wow, getting their machine set up was really difficult. I want to reassure you that that's ancient history. With Android Studio, in one install you get everything you need, all the Android-specific tools, the Java support you need, everything. So once you have this install completed, we'll be ready to start building our application, and that's what we'll start doing in the next clip.

Creating the Android Project
Once you have your Android Studio installed, and then go ahead and launch Android Studio, you'll find yourself at a screen similar to the one here, and what we're going to do is use this screen to go ahead and generate our new Android Studio project. As I've mentioned, as we go throughout this course and throughout this course series, we're going to cover a lot of different details about Android development and really build a broad set of Android skills for you, but for me personally, whenever I'm in a new environment, the first thing I want to do is just build a simple application, get her running, and just see the pieces all come together and all work together. So that's what we're going to do throughout this module, is that we're just going to generate a project, step through some pretty much default options and everything, do a little bit of code, and then see it run. Now you can be assured that as we go throughout this course and the course series, we're going to go much deeper on all these different topics, but our goal here is just to see all the parts work, and see kind of the whole Android development process just come together in a really simple example. So to get us started, we just want to go here and just say Start a new Android project. That takes us here into the Create New Project wizard, and all we're going to do is just change our application name. So why don't we just take our application name and we'll just call it First App. So I'll just highlight the My Application and change it to the text, FirstApp. And we'll go ahead and take our default for the Company Domain here. Now you'll notice that because of the resolution we record at, the buttons along the bottom of the wizard here are off the screen a little bit, so I'm just going to go ahead and resize this. So now we can see all the buttons. So I'll go ahead here and click Next. Now the next thing we're going to do is choose the minimum version of the Android SDK we want to run on, and let's just choose API 23: Android 6. 0. Now, as you probably know, there are a lot of different versions of Android out there, and Android runs on a lot of different kinds of hardware, and this Minimum SDK level indicates what's the lowest version of Android you want it to support. And we'll talk a little bit later more about the best way to make that choice. Now one of the nice things that Android Studio does for us is that if you specify an SDK here that you don't have installed on your machine currently, it'll go ahead and take care of doing that for us so we're good to go there. So we go with our API 23, and we'll choose Next again. Now the next thing we need to specify is the Activity. Now an Activity in Android terms is kind of like a screen. Now, as we will learn shortly, activities are much more than just simply a screen, there's a lot of lifecycle and stuff associated with them, but fundamentally, for now, we can think of it as just kind of our application screen. So what we want to do here is just choose this Basic Activity, and that will give us kind of a modern-feeling activity, a modern-feeling screen, with a nice little button in the lower right-hand corner, and that sort of thing. Okay, so we'll go ahead and choose Next here. And now it's asking us about some naming options and so forth, we'll just defaults on all those, and we'll say Finish. Now once you finished the wizard, Android Studio began generating the code for us, doing some initial building and so forth, and then finally lands on a screen like this one. Now I do want to warn you that when you first do this in your first Android project, you may see some errors displayed inside of Android Studio during the initial part of the building process, but once it all settles, you end up with a screen like this with no errors. So now with our project fully generated, we're ready to start working in our application. So in our next clip, we'll start making some minor changes to our application screen's layout.

Review the App Layout in Android Studio
So here we are now in Android Studio after our project has been generated. Now you may notice one thing I've done since the last clip was that I actually just repositioned some of these windows just so they were easier for us to see everything on there. I haven't opened any new windows or anything like that, I've just kind of resized them a little bit. If we take a look at what's here, on the left-hand side there's that tree-like layout, and that actually shows us some of the files and folders that are involved in our project. We'll get into that in much more detail as we go on throughout this course series. Now if we look at the center part here, where you see those two things that look kind of like a screen, that's our design view of our activity's layout. So in the center to the left is a representation of how it might actually look on a screen, and the center to the right there actually represents the components that we're using to create that layout. And then you see there's a section here called Palette, which indicates just a list of different, what we call widgets or views, or sometimes we even say controls, that we can use in our user interface, and we can actually just drag them from the Palette onto our Design View. And you notice under the Palette there's a thing called the Component Tree. The Component Tree just gives us a tree-like representation of how the views are arranged on our layout. Now what we're looking at right now is just the layout information. Now I want to show you something. Down here at the bottom you see some tabs. One tab says Design, and that's what we're looking at right now, and the other one says Text. So we're looking at the Design View of the UI layout right now. If I choose the Text, you might recognize that as XML. That's the XML view. So what we're actually doing is using XML to describe our user interface, and what that does is that gives us a lot of power, is that it allows us to describe our user interface's layout using this XML format, but that's totally separate from the code that actually interacts with it. As we go on throughout the course series, we'll see that that gives us the ability to have one set of code deal with a lot of different layout type scenarios. But now we do do most of our work in the Design View, so we'll just stay over there for now. So now what do we want to do in our application? Let's just do something that's kind of really simple. What we'll do is we'll take up top there where it says Hello World, that's a text field, what we'll do is let's change that to a number, like the number 1, we'll say. And then what we'll do is we'll take that button down there on the bottom right, and let's just do something like each time the user taps on that button we'll just double the number that's in the TextView. So what we'll need to do as we go through this module is we'll change the layout so that it has the proper appearance for what we're trying to do, and then what we'll have to do is go in and add the code to create that experience. Alright, so in the next clip let's actually start working on our layout and changing the way it looks to work with our application's needs.

Modifying Our App Layout
So let's go ahead now and change our user interface layout so it will work a little bit better with this simple application we're building. Now, you'll notice here on the right of Android Studio there's a window that says Properties, and currently there's nothing in it. But now if I go over here to my TextView, the thing showing the Hello World, and I select that, you'll notice that it actually shows me a bunch of properties, and these are properties I can set on this particular view. Now one thing to note is that the Properties window right now is displaying the properties that people most commonly need to interact with. You'll notice that to the right of the word Properties there's arrows there. If we click on those, it will actually show us all of the properties that are available, but right now we can stay with this more highlight view of the properties. Now one of the things that's really important is that any views that we want to interact with from our code will need an ID value, because that ID value is how we find it. Now there are a number of different ways people like to name the ID values. Some people like to use Pascal case, but a really common way to do it is just do everything in lowercase with an underscore separating the words, so that's the one we'll use. So what we'll do is go up here to our ID field, and we'll just give it a value of text_value. So once we do that, text_value is the ID of this particular view, and we can use it to locate the view from our code. Now underneath the ID value are these two properties, layout_width and layout_height, and they indicate how the layout manages the sizing. Now they both have values of wrap_content, and what wrap_content means is, we'll just have them take up whatever space they need. So a layout_height of wrap_content is good for us, but why don't we go ahead and make our layout_width, why don't we make it the full width of the screen. So what we can do here is just choose match_parent. And now if you'll notice when I did that, in the Design preview here, we can actually see that that view takes up the full width of the screen. Since we want to actually have our application double the value in the view each time, rather than having a string like Hello World, we should probably make it something like a number, so let's make it the number 1. So we'll go down here to our text property, and we'll change Hello World into the number 1. And let's do a couple more cosmetic things here. So now what we'll do is take our textAppearance, and right now you see it has a textAppearance of MaterialSmall. And we'll see if I click this dropdown there's a whole bunch of values here, and we'll talk a lot more about how values get into this box as we go throughout the course series. What we want to do is change MaterialSmall to MaterialLarge. So if we start scrolling down here, and then we'll just chose MaterialLarge, that makes our font a little bit larger now. And then let's do one last thing, and go ahead and center the text inside the field. So we'll go down here where it says textAlignment, choose that, and so now that number 1 is centered inside of our view. So that was pretty simple. So now what we'll need to do is start adding some code, so that when we click that little button down there at the bottom we can start doubling that value each time. And we'll start looking at how to add that code in our next clip.

Adding Some Java Code
So now we're ready to start adding some code to our application, and again, remember that what we want to have happen is each time the user taps on that button at the bottom right, we want to go ahead and just double the value that's displayed in that little TextView. So what we'll do is just to make it kind of interesting, let's go ahead and just create a helper class, or what we'll call a worker class, that actually handles that detail of receiving in a number, and giving us back double that number, in other words, the number times 2. So what we'll do is head over here the left-hand side of our Android Studio in our Project View. Now everything we've been doing up until now has been down here under that res section of the tree, which is called the resource section of the tree. What we want to do is head up to the java section. So up here where the node says java, let's go ahead and expand that. Now notice that there's actually three groupings of files underneath here. The two that are in green, that's our test-related code, we'll talk a lot more about those a little bit later in the course series. We want to be in this very first one, that's really where our application code is. So if I expand that, right now there's one there that's called MainActivity, and we'll take a look at that in just a minute. For now, let's go ahead and create a new java class that we'll use as our worker. So I'm going to just right-click here on our package name, say New, and I'm just going to choose Java Class. Now it's just a plain old class, so I'll just give it the name MyWorker, and I'll accept all of the defaults and everything else here, so I'll just go ahead and say OK, and that puts us inside the class. So what we're doing here now is we're just programming in regular old Java at this point. So let's go ahead and make this a public static method. We'll make its return type int. Let's call it doubleTheValue, and accept a single int as a parameter. And we'll go put our opening closing brackets, and so now this method has a very simple job. It simply takes the value that was passed in, multiplies times 2, and returns that value. So we'll put a return statement, and then simply value * 2; And so with that we now have a java class that we've added to our project that can accept an integer value, multiply it times 2, and pass it back. So now in our next clip, we'll start hooking all the pieces together in our application by taking our layout, tying it into the code that's responsible for the layout, and then using our worker class we just put together to actually give our application functionality.

Adding Code to Create the UX
So let's add the code now that'll actually give our application our desired functionality. So what I'm going to do now is go again over to this project view, and I'm going to go into this class MainActivity, so I'm just going to double-click on that, and that puts me into the code for MainActivity. And, again, this is the main screen of our application, so this is going to be the part of our application that's responsible for tying together the UI layout, and our behavior. Now what I want to take a look at is this idea of why is this code called Mainactivity actually connected to the layout that we have put together. Now there is no magic to it. You'll notice here that in the source code there's a function called setContentView, and it refers to a layout called activity_main. And that's actually what happens is the code actually goes out and loads up the layout for this UI described in that layout file. Now one of the nice things that Android Studio does for us is that you notice here next to the class name this little angle bracket looking thing, that'll let us see some of the XML files, if I click on that, you'll see there's actually one here activity_main. xml, and that's a layout, so let's go ahead and choose that. Now when you see this you'll notice that it looks just like the layout that we put together, that we actually designed a little bit earlier. But you'll notice what happens if I try to click on the number 1 here in this TextView, you'll notice that it's not showing me the TextView, it's actually showing me something in the properties that doesn't really have anything associated with it. But you'll notice that here in the Component Tree on the left it's actually an include statement. And if I go down there, you'll see it's actually including content_main. And that's the one I actually did my work in, because if I go over here to content_main, and double-click on that, notice that I now can select that TextView. And we'll talk a bit more about the way all of these layout files tie together, but what's happening here is the activity_main layout file handles some of the general ideas about our layout, it kind of gives us some basic positioning, some of the content at the top, that button, and then it loads in the content_main, which is our more application-specific content. And, again, we'll talk a bunch more about that later. The key thing that we know now, though, is that this MainActivity class is the one that actually runs the code that interacts with this UI layout that we've put together. Now I could double-click on the tree over here, or you'll notice that I have source code listed across these tabs across the top here, so let's just go back that way instead so we'll get it there. So now we want to add our code, and what we want to do is remember call that function we created for our worker class each time the user clicks a button. And you'll notice there's some source code here for that FloatingActionButton, and there's a setOnClickListener, so that is the code that's going to actually run whenever the user clicks. So what we'll do is we'll add our handling inside of there. So we'll go in here and we'll just add a blank line, in fact let's add two for now, go back up. Now the first thing we need to do is get a reference to that TextView that we created. So I'm going to declare a variable here that's of type TextView, and I'll just call it textValue. And you'll notice now once I've typed that, Android Studio is telling me that I actually haven't imported the class Textview yet, so I can simply hit Alt+Enter and it'll do the import for me, so let's do that. So now it's been imported. Now there's a function we call quite a bit when we're doing Android development, called findViewById, so let's go ahead and add that. And it wants to know the ID of the view that we want, and that's our text_value view. So that's actually in a generated class called R. id, so we're going to add in here R. id. text_value. Now one thing you'll notice is that that line is now underlined in red, so it's telling me there's something wrong, and you see it's got a red light bulb off to the side. If I click on that, notice the first option here, cast to 'android. widget. TextView'. And what it's saying is that findViewById has a return type of a class called View, which is a base class of TextView, and it says, do you want me to do the cast, and I'll say, yeah, please go ahead and do that cast for me, and now it takes care of adding the appropriate cast in there for me. And we'll see some other ways too that we can actually add cast, or at least get Android Studio to add cast and such for us as well, as we go along throughout this course series. Now one thing that you might notice here is that when we actually gave an ID to the TextView inside of our layout, we used that text_value, well here inside of our application, for the variable we're using Pascal case, in other words, no underscore. And that's a very common thing to do, it's just a common pattern that people often follow, and that's just what we're using. So now what happens is that once we call this findViewById, and we get back that reference in text_value, we can now interact with that TextView. So we can do things like get its current value. So let's add another line here. Now the value will come back as a string, so let's declare a variable of type string called stringValue, and then what we want to do is go ahead and assign it the result of our textValue. getText. Now getText returns back a type which is an interface called cara sequence. so we're going to go ahead and call the toString method so we actually get it back as a string. So what happens now is we'll have whatever value is currently in that TextView, we'll have it as a string. So what we need to do is go ahead and convert that string into an integer, so let's go ahead and create an integer variable called originalValue, and since this is actually just kind of regular old Java code, in the sense that Android uses Java, we can use things that are available to us in Java, so what we'll simply do is call Integer. parseInt on stringValue. So originalValue will now have the value as an int. So now, of course, what we want to do is get a new value, in other words the result of what our myWorker class's doubleTheValue does. So we'll have another Android variable called newValue, and we'll simply call myWorker. doubleTheValue, passing in that originalValue. And so what that will then do, of course, is call that function we wrote, doubleTheValue, and it will return back whatever the originalValue is times 2. So now we want to just take that and just set it back to the value of the TextView. So what we'll do is we'll go to our TextView variable, and just like we called getText to get the value, we'll call setText to set the value. So now we need to convert the int back to a string, so what we'll do then is just use the Integer class's toString function and pass in newValue. Alright, so now that block of code went out, got reference to our TextView, got its current value as a string, converted it to an integer, called our function, doubleTheValue, to double that value and put that in a newValue, and then writes it back being converted as a string. And that gives us our basic functionality. But let's go ahead and do one more little bit fun thing. You notice that inside this click handler there's a call to this thing called a Snackbar, and it actually displays text that kind of slides up from the bottom. So why don't we actually have that Snackbar actually write a message out saying something like 'change value 1 to 2, and then change value 2 to 4. Alright, so what we can do is we'll take the text here, that currently just says "Replace with your own action", and let's change that to the text "Changed value ", and then we can simply concatenate onto the end of this string the originalValue, the word "to", and then the newValue. And now we have our complete functionality. Each time a user taps on the button, we'll double the value that's displayed in that TextView, as well as display a message that slides up from the bottom saying that we've changed one value to another value. So in the next clip let's go ahead and run this inside an emulator.

Testing Our App in the Android Emulator
So here we are ready to test our application, and we'll go ahead and do that inside of an emulator. Now just a note, whether I say emulator or we say AVD, or Android Virtual Device, all those mean the same thing, which is a software representation of an Android device. And so now when we run it, we're going to go ahead and run it within the debugger, so let's use the button here that says run it inside the debugger. And when we do that, it asks us to select our Deployment Target. So now if we actually had a physical phone plugged into my computer that would show up here, or if it had any existing emulators they would show up here. Now I don't currently have any emulators, so let's go in here where it says Create New Virtual Device. So now the first thing it wants us to do is say, well tell us what version of the hardware you want this virtual device to use, and I'm going to say go ahead and use the Nexus 6, and we'll choose Next. And now it says, well, what version of Android do you want to put on there? And what I'm going to do is I'm going to choose the one that says Marshmallow, which is API level 23, and it's x86, because I'm running on an x86 machine here, of course. Now if you see the word download next to the word Marshmallow there, just go ahead and click on that, and actually download and install the files you you need to proceed from here. Once you have those, you'll be right back here in the wizard. So we'll go ahead and say Next. And now it's basically asking us to change any other settings, and we're going to accept all the defaults there, and we can also set the Name for it, and we'll accept the name that it gives us, which is a hardware platform followed by the API level. So now we'll go ahead and click Finish, and when we do that it might take a few seconds before we see anything happen. But when it's done it puts us back here in Android Studio and we're now ready to actually run our application, and our new emulator image is now selected as our target. So let's go ahead and say OK. Now once you said OK, you had to go ahead and start the emulator image up and go ahead and boot it up. And now once that came up it's now actually launching our application inside of the emulator, and here we are now with our application. You notice there's the number 1 at the top, the initial value we set on it. Let's go down here to our floating action button, and I'll click on that. And you notice the 1 became a 2 on the top, and we had some text slide up from the bottom. So let's watch the bottom now, and let's go and click on this button again, and it says Changed value 2 to 4, and our text at the top is 4, so it's doing exactly what we told it to do. Each time we click the button, it doubles the value, displays that back in the view, and we have that Snackbar sliding the content up from the bottom, and we just keep doing that. So what that means here now is that in just a few minutes we started out with a brand-new Android Studio install, and now we've actually written an application, customized a UI layout, hooked up the code to make it all work, and we're testing it inside a brand-new emulator image, and so we were off and running in just a few minutes.

Summary
Alright, so that wraps up our first module, and how cool was that, that once we had Android Studio installed, in about 20 minutes, even if you had never built an Android application before, we were able to build our app and get it up and running on an emulator. Alright, so the key things we want to take away from this module are first of all, Android Studio. Android Studio provides a complete Android development environment, it provided everything we needed to start working with Android development. Then we saw that there were layout files, and they were responsible for describing our user interface, and that's distinctly separate from the code that manages the user experience. And that's where activities came in. They provide the code and the functionality to present the user experience. And then we saw the Android Emulator. That's where we can actually run and test our apps from our desktop, because it actually provided a software representation of an actual device. Now one thing to always remember about the Android Emulator, people often call it an Android Virtual Device, or an AVD. Alright, so that completes the very first module of our course. So let's just take a quick look at what else we have in the course. Well, the module we've been in right now is Building a Simple App. So now from here we'll go into Designing and Planning Our App. What we'll do now throughout the rest of this course and throughout the rest of the series is we'll introduce a brand-new application, actually design out that application, and as we go through the series keep making that application more and more sophisticated, so by the time we get to the end of the series, not only have we learned how to do Android development, we'll actually have experience building an entire, relatively complex application from start to finish. So once we have that design worked out, as we go forward in this course we'll then look at more about the idea of understanding how activities and their layout interaction works, and then we'll look more at activities and the activity lifecycle. As I mentioned briefly before, activities are not just a screen, they actually have a lifecycle to them, so we'll start to understand that. And then for the last module of this course, we'll take a look at Option Menus, and then dig even deeper into activity lifecycles. Alright, so that's it for our first module. So join me now in the next module as we start planning out the application that we'll be building throughout the course series.

Designing and Planning Our App
Introduction
Welcome to the Designing and Planning Our App module of the Pluralsight course, Understanding Android App Basics. My name is Jim Wilson. in this module, we introduce the app we'll be building throughout the remainder of this course series. So let's first take a quick look at the high-level view of the app that we'll build throughout this course series, and also some of the long-term plans we have for that app that will really leverage the power and capabilities of Android. We'll then dig into and design the specific features we'll be implementing in this particular course. So we'll first take a look at the rough design of the work we're going to do throughout this course on our app, and then we'll take a look at the more polished design of the work that we're going to do on that app throughout this course. And then finally, we'll create the Android Studio project we'll be using to work on our application throughout this course series. Alright, so let's jump into our next clip and start looking at the app we'll be building.

Our App - The High-level View
Now if we're going to build an application, we of course need to fundamentally understand what that application is trying to do. Now, the application we're going to build throughout this course and throughout the remainder of the series, is based on a fairly simple idea. But you'll see as we go along that the features and capabilities that we can build into that application using Android can become pretty significant. So, fundamentally, what we're going to build is an application that serves as a note keeper, or the ability to keep notes, and specifically the ability to keep notes about Pluralsight courses you might be watching. So what we want this application to do in its most fundamental form is be able to display a list of notes, allow you to edit any existing notes, and then create new notes when you want to. Now, of course we need to understand what a note is in this context. So in the case of our application, our note is going to have basically three parts to it. The first part is the course that it's associated with, and that will be displayed simply as the name of a course, but that course needs to correspond to a real course that we're going to have to have the user may pick from a list or something like that. A note has a title, and that's just any user-entered text that the user uses to identify that particular note. Then the note will actually have the note text itself, the note content, and that's just the user-entered content that serves as their note, and that could potentially be some substantially long text. Okay, so that's our high-level idea. In our next clip, we'll just take a look at some of the features we're going to build into this application over time.

Our App - Some Long-term Plans
So as we've seen, our application is being built based on a fairly simple idea, the idea of just taking notes or keeping track of notes. What I wanted to show you here quickly is some of the higher level or some of the more advanced features we're going to be able to build into this application throughout this course series using the capabilities and features of Android and Android Studio. Now one of the things we'll want to add is automated testing, and not just of our logic, but also of the user interface and the user experience, so we'll see how to do that a little bit later. We'll want to give the application a rich look, so we'll use card-style lists. We'll use slide-out drawer navigation. Some of the other things we'll do is we'll eventually add in the ability to track which modules have been completed in a course. We'll give the app a branded appearance, in other words, we'll create a custom theme that lets us use our own colors and that sort of thing. We'll build in adaptability into the application so we can deal with device differences, and so we can deal with different language requirements like English, or Spanish, or French, that sort of thing. We want to make sure that our application supports users who have accessibility needs, for example, if a user has visual difficulties or visual challenges, we want to make sure that any tools they use like Android TalkBack that can read the screen content to the user, works with our application. And we want to build in user customizable behaviors into the application, so the user can have preferences and make the app behave the way they would like, or show things that they would like. And then finally some of the other long-term features we're going to put in are SQLite support, so actually be able to store and access data persistently using a relational database. We'll be able to make our note data available to other applications in a controlled manner. Our app will support notifications so we can give the user reminders, so maybe we can set a time and have that reminder show up at some point later to remind the user to read that note, and then when the user taps on that note it'll take them directly into our application so that they can view and interact with that note. We'll add background capabilities for the application so the user can do things like read and save data in the background. And then we'll even have support for displaying note information in the home screen using an Android features known as Widgets. Okay, so that's our long-term plans for this application. In our next clip, let's design out what we're going to specifically do in this course.

Rough Design of Our App Starting Point
Alright, so let's begin designing the part of the application that we're going to implement throughout the remainder of this course. Now we'll start out with just a rough app design here. And one of the ways we commonly do our rough design is we just take something like a post-it, and we might stick it on a whiteboard, or we'll stick it on a piece of paper, and we basically just use each post-it to represent a screen. So the first screen we'll look at is the screen that represents an individual note. Well, we know the information we need to have on a note, which is a course, a title, and then the note body text. So we'll put on here Course, because there's going to be a field for the Course for the note. Now remember, the course has to come from a specific list of courses, so we'll probably use this as some kind of dropdown or something like that, so we'll go ahead and indicate with a little down triangle. And now the Note title is just a field the user is going to type into, so we'll put that there. And then our body text is just another field the user types into. And now this post-it represents the screen for an individual note, that's pretty simple. Now we also said that we want to have a list of notes. Now as I mentioned, eventually we'll actually move into having a kind of rich card-based list of notes, but for now we're going to just use a really simple list. So we'll need another screen for that, so let's go ahead and slap another post-it down there. And then that list for each note that we have will display the course that that note applies to, and then we also want to show the note title, but let's say we want to have the note title be maybe a little bit smaller text. And since it's a list, we'll have just a separator, and then we'll repeat that for each note that we have in the list, and that will just carry on until we have all the notes available in that list. And then, simply, we now actually have our screens designed, certainly at a rough standpoint anyway. But now from a feature standpoint, one of the features we want to implement during this course is that if a user selects one of the notes in the list, then it should go ahead and transfer control over to the screen for that note, and just show the note in our note screen. Now, another feature we want to have is in addition to being able to show existing notes, of course, is we want the users to be able to create new notes. And what we'll do there is maybe we'll just use a floating action button with like a plus sign in it, so we'll just kind of draw that on our list screen. And when the user taps on the floating action button, we'll transfer control to our note screen, but in this case it'll be to create a new note, so the user will use that same screen to create a brand-new note that they use to edit an existing note. And that simply now, we have our rough application design.

Polished Design of Our App Starting Point
Alright, so in our next clip, let's see how we can take this rough design and turn it into a more polished design. Alright, so we have a rough design of the work we want to do on our app during this course. Let's look at a more polished design now. Let's first look at our note screen, so let's go ahead and get rid of that post-it, and see what a mock-up of the screen might look like. So we have our screen there, our Edit Note screen, and notice that our first field there lists the courses, it has a dropdown on it so the user can actually tap on that and then select a particular course. Then we have a field for them to type in the title and then type in the note, so we're doing pretty good there. Let's go ahead and get rid of the post-it now for the list, so we'll pull that guy out of there and see what our screen mock-up looks like, so we've got our mock-up there. We've got the name of our app on top there, NoteKeeper is what we'll call it. So we have an entry for each of our notes, and each note shows the name of the associated course, and the title for the note itself, and that's in smaller print and even in lighter print in this case. So now if we look at our functionality, a user can go ahead and tap on a note, and that'll show our note screen. Now as we get to this point in the design, we have to think about our full functionality. Now, of course, if the user taps on the note to show the note screen, if the user makes changes to that note they'd want to save it. Well, the Android way of doing things is that you the user doesn't have to tap the Save button. Simply doing something like hitting the back button should automatically save that note, basically leaving the note should automatically save it, because that's normally what a user is going to want to have happen. But now we do have to think about the fact is, well, what if they don't want to save it? Now that is an exception, but we'll give them that ability. So what we need to do is maybe up at the top here we'll put an option in that allows the user to leave the note without saving the changes. Now another feature we might want to think about is that when they tap on a note, they're typing on that note in a list, but they might want to look at the next note in the list without having to go all the way back to the list. So we want to have another feature on here where the user can tap on that, and just move to whatever the next note in the list might be. Alright, so now we're getting a better lifecycle around our notes. Alright, so they could select a note from the list, save changes, exit without saving changes, or move to the next note in the list. Now we also have our new note requirement. So we've got our floating action button down there at the bottom with the plus sign. If the user taps on that, that'll go ahead and take us into the note screen so the user can create a new note. And, of course, you want those same kind of events of, well, if the user hits the back button it should save that newly created note, but if they use our menu at the top there it should exit the note screen without saving that note. Alright, so that gives us a pretty polished design. So now in our next module, we'll start building the note screen.

Creating the Android Studio Project
So this is a great time for us to go ahead and create a brand-new project, and the project that we create now will be the project we use throughout the remainder of this course, and throughout the remainder of the course series, so we'll just keep building on the work we do in each course until we get all of the features into our application. Now when you launch Android Studio, you may not come into this welcome screen that I currently have up here, you may go back into the project that you worked on earlier, such as our first app project back in the very first module of this course. If that's what you're looking at right now, you have a a couple of choices. One thing you can do is just go to the File menu and just choose Close Project, and that'll take you into the welcome screen I'm looking at right now, or you can just go File, New, New Project, and that'll go ahead and launch the same wizard that launches from here when I start a new Android project. So let me go in here and just choose Start a new Android project, and that brings me up into the Create New Project wizard. What I'm going to do is call my project NoteKeeper, and this NoteKeeper project will be for the application we described earlier for keeping track of notes. So we're now giving the Application name NoteKeeper, my project location, I'm actually putting it under a folder I have called PSDemo, you can make it whatever folder you want to put your projects in. Alright, from there I'll just chose Next. And when it get in here, I now need to decide what the Minimum SDK I want to target is. In other words, what versions of Android do I want my application to support? And it's kind of an interesting challenge, right, because on one hand you want to support every device that was ever made. On the other hand, you want to have as many features available from the operating system as you possibly can. So that's always kind of the balancing act we play. We want to go ahead and reach as many users as we reasonably can, at the same time we want the newest version of Android that we need in order to get access to as many features as we'd like. One of the things we often do is we can go here to where it says Help me choose. I'm just going to go ahead and click on that. Now the screen that opens up when we click on that Help me choose link is designed to do exactly that, help us decide what version of Android we want to target. Now if we look at this screen, you notice on the left-hand side there there's a graph, and that graph has colored bars, and each of the bars are labeled with two different numbers. The number on the left-hand side is the version of the Android platform, effectively the Android operating system version, alright, so 2. 3 is the very first one or the very topmost one there. And notice that it has a corresponding API level, in that case, API level 10. Android version number is what we talk about when we're talking about the operating system. The API levels indicate to us the actual features that are available to us as developers. So that if I want to target Android 2. 3, I'm targeting a minimum API level of 10. If I want Android 4. 0, that's an API level of 15, Android 4. 1 API level 16, and they just keep going up. So as we think about this idea of what's the minimum version of the SDK we want to target, we're going to be choosing an API level, and that's going to correspond to some version of the operating system. So let's say we're in here, and I go, I heard a lot of good things about Android 4. 4, so I'm going to go ahead and just click on that. And when I click on that, all the way on the right-hand side of the screen it just gives me some highlights of some of the key features that become available in Android 4. 4. And I take a look at that, and I go, wow, there's a couple of features there I'd really like to use. So now the question is, do enough devices out there support Android 4. 4? So you'll notice that just to the right of the colored bars there's a column that says Cumulative Distribution. That tells us how many users are using Android devices that have that API level or higher. So in the case of Android 4. 4, API level 19, this says that 73. 9% of Android users have Android 4. 4 or higher, or devices supporting API level 19 or higher. And you look at that and you go, well, gees, that's really right on the bubble. I was really hoping I could hit at least 80% of the devices out there. I'm targeting really cutting-edge users, but geez, 73. 9%, that's not even 3 out of 4, so maybe I'm not comfortable with that. So when we look at these numbers inside of Android Studio, they're a really good general indication of what's a good version for us to target. But sometimes when we're right on the bubble like that, just kind of, wow, if it was 80% I'd do it, but 73. 9 I don't think I want to, there's another place we can look to get a very, very up-to-date distribution, something with just a little bit newer information. So what I'm going to do is I'm going to go back here to my Google search screen, and I'm going to actually search on the term android dashboard. So I type in that term, android dashboard, and I start my search, and when it comes up, there's a match here that says Dashboards|Android Developers, so I'm going to go ahead and click on that. Now the Android Dashboards gives us information on the distribution devices that are out there, but it's very current information. And one of the things I want to look at right now is Platform Version, so I'm going to just scroll down so I can see the whole table under Platform Versions. And if we look at that, again, we see very similar information to what we saw inside of Android Studio, the version number, the Codename, the API level, and the Distribution. But if we take a look at these numbers here in Android 4. 4 and above, if we look at this most recent information, it says 4. 4 has 20. 8% of users, 5. 0 has 9. 4%, and that goes all the way up to 7. 1 with 0. 4%. Well, if we add all of those up, that actually totals to 87. 4% of users, so that means that 87. 4% of users out there using Android devices have devices running 4. 4. or newer, and that was way past my cut-off of 80 or 85%. So that means I could go ahead in this case and go ahead and use Android 4. 4 and hit my target of 80 or 85% of the users out there. So I'm just going to go ahead and minimize this. So the way I use these features is that the capability inside of Android Studio and the information that's in there gives me a really good general indication, but on those cases where I'm just not quite sure what version I want to go with, do I want to go with maybe 1, or maybe the one just above it or just below it, that's when it's great to go ahead and go out there to the Android Dashboard and get that really, really up-to-date information. Okay, so let's go ahead and cancel out of here. So now we are back in here, and it's time for us to pick our Minimum SDK. Now what I'm going to do, since this is a class, and it's just great for us to have fun here and just see as many features and capabilities as we can, I'm going to go down here and I'm going to actually choose API 24, which is Android 7. 0. Now even though there aren't a lot of devices running Android 7. 0 at the time I'm recording this course, people are getting new devices all the time, so for the purpose of this course, let's see those latest and greatest features. Alright, so I'm going to go ahead and click Next here. So now I want to choose what kind of activity I want to have, I'm going to go ahead and choose a Basic Activity, because a Basic Activity serves as a great just kind of general starting point, so I'll go ahead and choose Next. And so now I've got to provide some information about that activity. So the first thing it wants to know is the activity class name, so I'm going to change it from MainActivity to NoteActivity. So now once I change the class name to NoteActivity, you'll notice that the layout file name changed as well to be activity_note. The next thing is the Title, and that's the title I want to appear across the top of the activity. So let's go ahead and make the title Edit Note, so that's the title now that will appear across the top. We'll talk about the Menu Resource Name a little bit later in this course. So we're all set to go there. We've given the wizard everything it needs to go ahead and generate our project. So we can go ahead and click Finish now, and that'll go ahead and create our project and give us everything we need to do to start working and building our NoteKeeper application.

Summary
Now to wrap up, remember that this application that we designed, our NoteKeeper app, will be the app we work on throughout this entire course series. And although it starts very simply, we're going to keep building on it, and as we leverage the various features and capabilities of Android, we'll be able to make this into a very rich application with a very rich set of user experiences. Now, as we saw, Android Studio allowed us to generate our application stating point, and it gave us a lot of flexibility. There were a number of different type of activities we could choose from inside of there, and it allowed us to select our minimum supported SDK. Now this idea of selecting the minimum target for our application, remember this creates a bit of a challenge for us, because if we want to support as many users as possible, we support older versions of Android, but if we want to get the most features, then we support newer versions of Android, and we're responsible to balance those two needs. So what we need to really understand at any point is the Android versioning distribution, so we can figure out how many users we're picking up or losing by choosing one version or another. Now as we saw, Android Studio provides some really good information on the versioning distribution, and in most common scenarios it provides everything you need, but remember that there's also the Android Dashboards, and they give us the latest and greatest information about distributions. Now the other thing we want to remember is that Android has two versioning identities. Now the platform versions use "dot" versioning, 4. 0, 4. 1, 5. 0, that sort of thing, and that's what we generally talk about when we conversationally refer to Android, but as developers, we're really interested in the SDK versioning, remember, that uses integer versioning, so SDK version 15, SDK version 16, and so forth. And each platform version has a corresponding SDK version, and as developers, it's that SDK version that we're really thinking in terms of. Okay, so now in our next module we'll dig into activities, activity layouts, and start to understand how they interact with one another.

Understanding Activities and Activity Layout Interaction
Introduction
Welcome to the Understanding Activities and Activity Layout Interaction module of the Pluralsight course, Understanding Android App Basics. My name is Jim Wilson. In this module, we're going to start out by answering the question, just what is an Activity? From there, we'll look at what's used to construct an Activity user interface. We'll then take a close look at the classes called Layout classes that we use to actually organize the layout of our Activity user interface. We'll then dig into one of the newer layout classes called ConstraintLayout. From there, we'll take a close look at the relationship between an Activity and its Layout, and we'll finish up with populating a Spinner. And that's interesting for us in this module, because Spinners are views that actually leverage layouts to control their appearance.

What Is an Activity?
So if you've been around Android programming for any length of time, you've definitely heard the term Activity, in fact, you even heard me use it going back in earlier modules. So the big question then is, what is an Activity? And as so often is a good idea, let's start with what the documentation says an Activity is. And according to the Android documentation, an activity is a single, focused thing that the user can do. Now that is absolutely an accurate definition, but it doesn't quite tell us enough to really know what to do with it. So let's look at a little more detail about exactly what is an activity. Now one of the key things that activities do is they serve as a place to present the user interface, because an activity will provide a window for us. And then what we do is we then build the UI within that window using a series of classes derived from the base class View. But now, activities are more than just a place to present our UI. Activities actually have a lifecycle, in other words, activities are kind of living, breathing things in the concept of being inside the computer, right, they're really alive. So they're really more than just a screen. Now that lifecycle is represented in our programs by a series of methods that get called. Now in this particular module, we're going to focus more on the UI aspect of activities. In the next module, we'll dig into this lifecycle concept. But one of the key things that we need to understand about the lifecycle in order to build our UIs is a method called onCreate. The onCreate method is where the lifecycle tells us that our activity is being created, and that's generally where we're going to start initializing our activity, and therefore initializing our user interface. In our next clip, let's take a look at exactly what is involved in creating that Activity user interface.

Activity UI
So now as we look at what is involved in building that Activity user interface, a few key things we want to understand. Now one, of course, is the View class, because Views are the basic building block of our user interface. And fundamentally, Views are responsible for drawing the user interface and dealing with any event handling. And there's a bunch of specialized View classes, we'll see some momentarily, as well as throughout this whole course series. There's a special kind of view called ViewGroup. Now a ViewGroup is a special view that holds other views. Now we don't do a whole lot of work directly with the ViewGroup class, but there are some classes that derive from it that we work with a lot. A bunch of those fall into a family of what are called Layouts. Now Layouts are special invisible ViewGroups, and what they're responsible for is dealing with positioning Views, in other words, they provide positioning behavior for Views, how they get arranged, and there's a number of specialized layout classes, and we'll see some examples of those shortly as well. Let's take a look now at some of the View classes that are available. So what I have here is the Palette from the Android Studio Designer. You can see there's a bunch of different views here, and let's take a look at a couple. Now ones that we'll often interact with fall into the Widgets category, and some examples of those are things like the TextView, which allows us to present text, there might be something like a ToggleButton, which is a button that shows an on or off state, or a Spinner, which gives a dropdown list to the user, or even a Switch which is a slider with our on or off state. Now other ones we'll deal with a lot fall into this Text category, and they all are based on a class called EditText, and EditText allows us to have interactive text, text the user can type in. It can be plain text, there are also variations that have password-specific behavior, or e-mail-specific behavior, those sort of things. So I really encourage you to explore the different kinds of View-based classes that are available, but as I mentioned, we're going to see a whole bunch of them as we go throughout this course series. Now in our next clip, let's look at some of the Layout classes.

Layout Classes
So let's look now at this idea of something called Layout classes. Now here's the issue, when you build your user interface for your application, it needs to be responsive, because one of the cool things about Android is, you're not locked into a small set of devices, right, there are lots of different devices out there with lots of different display characteristics, so our user interfaces must adapt to those different display characteristics. We don't want to be hard-coding for a very particular physical screen size, because to do something like that would be really limiting, so we want our user interfaces to be adaptive so that we can design either one, or at least just a small number of them and have them work effectively across many different devices. And that's where the Layout classes come in. They provide positioning flexibility. Layout classes are responsible to arrange their child Views, and those child Views can be other Layout classes in some cases. Now the specific positioning behavior depends on the layout class we're dealing with. Now let's take a look at some of the common Layout classes that have been around for a while. One is one called FrameLayout, and that provides a blocked-out area, and generally that just has one direct child. And that's useful for creating a predictable area of the screen that something else might go into. There's a special kind of FrameLayout called a ScrollView that provides, as its name implies, scrolling capability or scrollable area, so that you can have a display item that's too big to fit on a screen or a specific area of the screen, and have scrolling behavior for it. LinearLayout, that provides horizontal or vertical arrangement, in other words it puts things in line either vertically or horizontally. You can have it distributed evenly, or you can have weighted distributions. You can even have some items take up a specific amount of space, and then remaining areas be divided up so forth. And then there's a powerful one called RelativeLayout, and that provides relative positioning. So a view positioning could be relative to another view, in other words to the right of it or below it, or it could be relative to the parent, the RelativeLayout itself, as a top edge, bottom edge, center, that sort of thing. So to get a sense of what it's like working with these types of Layout classes, in our next clip, let's just go through working with RelativeLayout.

Demo:Working with RelativeLayout
Here we are in Android Studio inside the UI Designer, and let's see what it's like working with a RelativeLayout to design a screen for our notes. Some of our notes are going to have a selection for the course, a title for the note, and a note body. Alright, so if you notice here that in the bottom left, here on the Component Tree, I've already got my RelativeLayout, I've got my Palette up there in the top left. Let's get rid of the Palette and let's go over and just choose Widgets, and I want to go ahead and first put the Course Selection in. So I'll go ahead and use what's called a Spinner for that, again, a Spinner is a dropdown selection. So I'm going to just go ahead and grab this guy, and I'll drag it over here, and you see where I've got that green dotted line it's showing me where there's some margins. Let me just go ahead and release it right there. And that puts my Spinner there. So now, a couple things I need to do. I just want to go ahead and give it an ID. Now a naming style that I tend to use for my IDs is the first part of the ID indicates the kind of View it is, in this case a Spinner, then underscore, and then something to describe it. So in this case, I'll call this spinner_courses. So we've got that there. Now you notice there are a couple of values here, a layout_width and layout_height, and this indicates how we want to size our view within the RelativeLayout. So now layout_width with a value of match_parent says we'll take up whatever space the parent allows you to, so in other words I want to just go fully from the left edge to the right edge. But then layout_height is wrap_content, and that indicates that I want the height to take up whatever space is needed to display the content, so that would be effected obviously by the height of the font, and that sort of thing. Now something that's not noted here is that how is positioning being controlled? If we look at this Properties window, let me just pull my mouse out of the way, there's nothing there that indicates how that View was positioned, and remember that we're looking at kind of a Summary View of the properties. Let me go in here and look at a more detailed view. Now get into the detailed View, and you notice there's two things here, alignParentEnd and alignParentTop. Now alignParentTop is obvious, it's saying that I want to position this View against the top edge. Now alignParentEnd actually indicates that I want it against the right edge, and we've got an alignParentStart it's kind of implied. So what we're saying then is that we're against that left edge to the right edge. This concept of start and end versus left and right is used because in some languages things go right to left instead. As just kind of a note, there is a layout alignParentRight and alignParentLeft, and generally we don't use those anymore because we want to build our programs to work for both left to right languages and right to left languages. Okay, so that's our first thing, that's our Spinner which is at the top edge. Now let's look at the next thing, our Note Title. Now for our Note Title we want to go ahead and use a textValue. So I'm going to go over here and just choose Text in the Palette, and there's a number of things that I might use, and I might use something like plain text, but we don't want to limit people to having just short titles. They might want ot have longer titles. So maybe what we'll do there instead is we'll go ahead and choose Multiline Text. I'm going to go ahead and grab the Multiline Text. Now I could just drag it directly onto the screen layouts, or I could drag it down to the Component Tree, so let's try dragging it down to the Component Tree. So I'll bring it down there, and that line indicates where it's going to be, so that means that it's actually at the end of my hierarchy. If I select it, you see it's still kind of pushed up in that top left-hand corner of the relative layout, which is a default. What I want to do is I want to put it below that Spinner, so I'm go ahead and grab it, drag it down here, and now it indicates that it's below the Spinner, and that little arrow between the two indicates that it's being positioned relative to that one with the margin. So let's do a couple of things here. Let's go over here first to our id. Of course we want to go ahead and give this an appropriate id, so I'll call this text_note_title. So let's flip over to our Summary View for just a second, and again notice that we've got our ID value in there that I just typed, and we've got our layout_width and our layout_height. Now a layout_height of wrap_content, whatever sizing you need, is fine. For the layout_width, though, we don't want really wrap_content in this case. In other words, it would make it only as long as the text is typed, so if it was 2 characters long, it would be as wide as two characters, if it was 20 characters long it would be as wide as 20 characters. We want this guy to go ahead and be match_parent again, so I'm going to choose dropdown, say match_parent, and now you notice it takes up the full width of the parent. Now another thing to look at here is if I look at my spacing between these two views, yeah, they're kind of a little bit further apart than I might like, so I want to go ahead and change that. Now that spacing isn't showing up here in my Summary Properties View, so I'm going to go back to the Details Property View, and you notice this section here called Layout_Margin. I'm going to go ahead and expand that area, and you see that we can set a margin either for the layout_margin value, which means it would be the same on all sides, or a specific side. And you notice that we've got a layout_margin of Top, and the Top margin is 28dp. Now dp may not be a measurement you're familiar with. dp stands for device independent pixels. One of the challenges we have, because there are so many different devices out there, and device resolution vary by so much, we don't want to size things in terms of pixels. A given device may have many more pixels per inch than another device does, so device-independent pixels are kind of a universal measure, and there are always 160 device-independent pixels per inch, no matter what the actual resolution of the device is. So if you want things about half inch apart, you would use 80dp, about a quarter inch apart you might use 40 dp. We want just a small one there, and a common measurement we'll often use is 16dp's, about a tenth of an inch apart. So we want to change this to 16dp. So once I do that, they actually move a little bit closer together. So now we've got that arrangement. Let's just flip back to our Summary View again. Now I want another TextView underneath the title for the body of the text, the body of the note text I should say. So now we could go ahead and do the drag and drop again, but one of the things we often end up doing as we deal with these kind of traditional layout classes is sometimes it's just quicker to do something in the XML itself. So what I'm going to do is go down here to my bottom left, I'm going to choose this Text tab, and I'm going to switch to the XML view and I'll scroll down. And basically, I want the body of the note to follow a very similar pattern to the title of the note. I want it to be multiline, I want spacing to be similar. The only difference is, I want it to be under the title as opposed to under the course selection. So what I'm going to do to do is I'm going to go over here and just highlight the EditText for the title, I'm going to go ahead and copy that, and then what I'll do is I'll just go in here, I'll paste it in, and I'll change the things that matter. So, for example, the id, I don't want to have two views with the same id, so what I'll do is change this from note_title to note_text, so I've got that there. The other thing I want to do is I want it to be below the title. So you notice here where it says layout_below, and it's the spinner_courses, well if I left that there, then the title and the note text body would be over top of each other. So what I'm going to do is change the spinner_courses to be the ID of the title_text, so I'm just going to go ahead and copy that, and then paste it down here for the layout_below, and then once I do that if I switch back to my Design View, you see now I've got all my different views there. I've got the spinner at the top for selecting courses, I've got a place for the title, and a place for the body text. So this is what it's like working with our RelativeLayout. Now RelativeLayout has its own unique capabilities in the sense that it manages positioning in relative terms, but it gives us a sense of what it's like to work with a number of the different layout classes. So in our next clip, let's look at a layout class called ConstraintLayout, which you'll see actually gives us a lot of really, really rich capabilities.

ConstraintLayout Class
The Layout classes we've seen so far, what I'll call our traditional layout classes, working with those can sometimes present some challenges, and much of that comes out of the fact that user interfaces have become much richer since those layout classes were first created. They actually date back to the early days of Android. Now the challenges of working with these traditional layout classes are twofold, both on the run-time side and on the design-time side. Now on the run-time side, it's not uncommon to actually have to nest one layout class inside of another in order to get a desired result. So you may have a relative layout that contains a linear layout inside of it, and sometimes it can be multiple of those going on, multiple nestings like that going on. And deep/complex nesting actually impacts rendering speed. But even beyond the run-time challenges, these traditional layout classes can present design-time challenges. Sometimes, achieving the desired layout result with the Designer is just really, really challenging, and what you end up doing is you end up just dropping down the XML to get the layout constructed the way you want to. And if you've ever edited XML files manually, you know that that is not a productive way to work, so we need something better. So in early 2017, Google released the production edition of a class called ConstraintLayout. It is an extremely flexible layout class, in fact, it's often the only layout class needed, even for very, very rich user interfaces. And the cool thing about it is that it has a first-class design-time experience. It is closely integrated with the Android Studio Designer, in fact they're actually developed side by side, the ConstraintLayout class and the Android Studio Designer for it, and because of this we rarely need to resortt o the XML to do things. Now as the name implies, the ConstraintLayout class uses constraints, and so the children within a ConstraintLayout leverage those constraints. And using constraints, we can get things like relative size or positioning for children. We can have ratio-based size and positioning, a particular view that takes up 30% the width of the screen, that sort of thing. You can have group size/position distribution, something known as "chains". In other words, I've got three different views, and I want them distributed evenly across the horizontal width of the display. You can do weighted relationships. So I want something sort of centered, but slightly to the left. And there's even a concept called guidelines, where you actually have view elements that aren't visible at run-time, but they are actually used to allow you to control positioning within your screens. Now when we use the ConstraintLayout, each view should generally have at least one horizontal and one vertical constraint, because if you don't set those, the View ends up positioned at 0, 0, in other words just kind of stuffed up in the corner. Now although we need to have at least one of each of those, we can have more than one in some cases. For example, it might have a horizontal constraint on the left side, and one on the right side, and that might cause the view to be centered. Now as I mentioned, the ConstraintLayout is very designer friendly, so when working in the designer, and say we're looking at the Blueprint View, the view we're interacting with will actually have this box around it, and that box allows us to interact with it easily within the Designer. So, for example, if we want to set a constraint within the designer, you'll notice that the box will actually have these circles at the mid-line, and you can drag from those circles to another point inside the designer to create a constraint relationship. So, for example, if I drag a circle over to the edge of the ConstraintLayout, that relationship is tied to the ConstraintLayout itself. But I also can drag a circle over to another view, and then that would create a constraint relationship between the two views. Now you can also set fixed sizing within the designer, because that box around the views will also have squares at the corners, and so if you drag those squares then you would create fixed sizing on that view. Okay, so in the next clip let's jump into Android Studio and start using ConstraintLayout to actually build the user interface for our note activity.

Demo: Working with ConstraintLayout
Here we are in Android Studio and we're looking at our NoteKeeper project, the project that we generated at the end of the last module. If you remember that when we created that project we said that we wanted the activity inside of it to be called NoteActivity, and so that created some layout resources for us, and the main one we're working in is this one called content_note. And so content_note is the one we're looking at right now, and if you look at the Component Tree you'll see the root of that tree is a ConstraintLayout. So that means that as we build this UI for this particular activity, we're going to be doing it using ConstraintLayout. And so now before we get started, I'm just going to go over here and just close the little project window so we have a little bit more space on our screen and it's not so cluttered. And the other thing I want to do is I want to go ahead and just get rid of this Hello World guy here, so I'm just going to go ahead and highlight that and hit the delete key, so he's gone. So now we're ready to start working and start building our UI. So we'll go over here now in the Palette, let's choose Widgets and just narrow that down, and again, we're going to use the Spinner view to represent the list courses. Let's grab our Spinner view, and we'll just go ahead and drag it onto our design space, drag that there. And so when we drag that there, it's actually showing as if it's positioned, but it's not actually positioned quite yet. What we want to do is actually set some constraints to control the positioning. The positioning we see right now is just being held to help us out with designing it. If we didn't actually set any constraints on it, as we mentioned in the slides, it would actually just go into the 0, 0 position. Okay, now before I do that, you'll notice over here in the layout_width, it's given me a width of 368dp, and that's just using a sizing that was used to drop it. I don't want to actually use a fixed sizing. What I want to do instead is let constraints set the sizing for me. So I'm going to go over here where it says layout_width, and I'm going to change that from 368dp to 0dp. Now basically what that says by setting that to 0 is in effect we're going to say that we want the width to match constraints, in other words, the width that this spinner will take up will be based on how the constraints size and position it. Okay, now what I want to do is I want to go ahead and have it near the right edge, so I'm going to go ahead and grab the circle here on the mid-line, and drag that over to ConstraintLayout, so that now sets a right constraint. You may notice that when I did that over in the Properties window, there's a little area there that actually shows the constraint values, and so we now have a right constraint with a value of 8, that's 8dp. Now I also want to go ahead and set a left constraint, so let's go ahead and do that. So we'll go ahead and drag the circle from the left side over here to the left edge, and so now we have both left and right constraints, each with a value of 8. So what that means now is that the sizing of the Spinner is based on these constraints. The right edge of the Spinner will be 8dp from the edge of the screen, and the left edge of the Spinner will be 8dp from the edge of the screen, and it will occupy all the space in between there. Now remember, we also want to have a vertical constraint. So we've got two horizontals, we need a vertical, so I'm going to go over here and just grab the dot up top here and drag it up to the top edge of the screen. So now we have a top constraint as well. Now they all have values of 8, and let's go ahead and change those up. Let's go ahead and make our top constraint 16, so I'll go over here and just click on that, and there's a dropdown where I can say 16. I can type in a different value if I wanted to. And let's go ahead and make our right and left ones 32 for now, so that's going to be 32dp. So 32 for the right, 32 for the left, and so now that's our Spinner. Our Spinner is now going to be sized such that there's 32dp of space on the right side, 32dp of space on the left, and its positioned 16dp from the top. And now we want to go ahead and make sure we go ahead and give it an id value, so we'll give it an ID value of spinner_courses. So let's go ahead now and create a field to enter our title. So what I'm doing is go ahead and choose Text on our Palette, and then I'm going to go ahead and use the Multiline text. Now for fun this time, rather than dropping it on the design space I'm going to go ahead and drop it on the Component Tree. So let's just drag it down there, switch to Component Tree, so that puts it down there. Let's go ahead and select it. So now you notice that it's up in that 0, 0 position, and what I want to do this time is I want to set all the constraints relative to that Spinner I have there. So one of the first things I want to do is have this text field be positioned below our Spinner. So what I'll do is go up here and grab this top edge to the dot there, drag it down to the bottom dot of the Spinner, so that says I want it below it, and it gives it a default value of 8 for now. And let's go ahead in here where it says layout_width, rather than having wrap_content which says take up whatever space you need to, I'm going to go ahead and make it 0dp again because I want to, again, tie it to the constraints. And what I'm going to do this time is rather than make the right and left edges relative to the ConstraintLayout, I'm going to make them relative to the Spinner. So I'm going to go ahead and grab the right edge of my text field, drag it up to the right edge of the Spinner, and I'll do the same thing for my left edge. Now you notice that the text field has indented slightly, and that's because those constraints have, again, values of 8dp. So I'm going to go over here to the right and left ones and change them from 8, in both cases, to 0, which will cause them to line up. Now you notice that because I have the right and left edges of this text field tied to the right and left edges of the Spinner, if I change the constraints on the Spinner, which the right and left edges are relative to the ConstraintLayout, this text field would go ahead and change its edges with it, and we'll see that momentarily. But now we need to go ahead and set the ID value on this guy as well, and so for this guy we'll go ahead and give it an ID value of text_note_title. And we have one other thing we want to do. When we have a text field like this, the user needs to know what it's for. Now sometimes we use labels to do that, or just read-only text, but more commonly we use things like hints, so there's actually some light-colored text in the field until the user starts to type something. So you'll notice here in the Properties window down the EditText area there's a field called hint, and so let's go ahead and put the hint there and let's just say Note title. And so now you notice that in the design space you see that there's some light-colored text in there that now says Note title to indicate to the user that they're supposed to type the title for their note into that text field. So let's go ahead and create one more multiline text, and this will be for our note body. We'll do it just like we did for the title, so let's go ahead and just drag it onto our tree down here. And once we have that, we're going to go over here and select it, put it underneath the title, so we'll create that constraint. We'll set it to a width of 0dp again, and we'll go ahead and align the right edge of this text field with the right edge of the one above it, so create that constraint. Do the same thing for the left. And so we will again make those 0 again so they line up perfectly, so we'll go ahead and choose 0 on each side. So we have that there, and we'll go ahead and change its ID value to text_note_text. And we'll go ahead and give this guy a hint of, we'll say, note_text. And so now we actually have our basic layout for our note activity. Now one thing you will notice here that if we look at the preview view there on the designer, notice that I've got those edges maybe a little too broad. If you look at the right edge of the note_title field and the left edge of that field, there's a lot of white space there. Now remember that each of the text fields have their right and left edges tied to the right and left edge of the Spinner. So what I probably want to do is go over here to my Spinner and maybe change those values from 32 to something like, let's say, 16. Now because each of the text fields have their right and left edges tied to the Spinner, when I change the Spinner's right and left edges, which were tied to the ConstraintLayout, each of those fields will move with it. So if I go over her and I change this 32 to a 16, you notice that all the fields move closer to the right. Same thing if we go over here on the left edge and change that to a 16, all the fields move closer to the left as well. So by linking all of those constraints together where I had one particular field, in this case the Spinner had its right and left edges tied to the ConstraintLayout, and each of the fields underneath of that were tied to the right and left edges of the spinner, changing just the Spinner's spacing changed everyone else's as well. Alright, so we're good with our design there, so now in our next clip we're going to take a look at how this Layout file that we've put together is associated with an interaction with the code used for our activity.

Activity/Layout Relationship
So now as we build our activity and we want to create a user experience, we're obviously going to have to write Java code to create that user experience. And that user experience is going to tie to the user interface that we put within our Activity. Now when we create a user interface for our Activity, we could do it programmatically, in other words, we could use Java code to create all the class instances for our Views, and then programmatically create all of the relationships between the views and the layouts and all those sort of things. But in general, we don't do it that way, we tend to use layout files, what we've been doing so far. And the layout files, remember those are XML files that describe our view hierarchy. And we create those using the Android Studio Designer, and what happens is that layout file becomes a resource. But now here's an interesting question. How do we create the relationship between that layout resource and the Java code within our activity. Well, something that's very important to understand, there is is no implicit relationship, there is no kind of magic way that the layout files we create get tied to an activity. An activity must explicitly load the layout resource it wants to use. It does that using the setContentView method. Now once that layout is loaded up, how does that activity get access to the views within that layout? Well, the activity must request reference to those views. It does that using the FindViewById method. The findViewById method returns a reference of type View, and then we generally cast that to the specific type of View class we want. So now, though, if we have to load all that stuff up in Java code, how do we actually find all these things? How do we find the Layout file research? How do we find these ID values? Well, they rely on a class called R, and that's actually a generated class. And the R class contains nested classes, and it actually contains quite a few nested classes. But two of the ones that are interesting to us are one for the Layout files or the Layout resources, and that class is called R. layout, and another one for id values, so that's R. id. So now to see what that looks like, the Android environment generates a class called R. Now for our layout resources, there's that nested class, the static final class called layout. And so we're working in our project. If we have a layout resource called activity_note. xml, that actually becomes a constant within that layout class called activity_note, and it's actually just assigned an integer value. And an integer value is an index into the resource system within Android that allows it to find that layout. We'll talk a bunch more about the resource system later in the course series. Th key thing we need to understand here is just that R. layout. activity_note will load up the layout resource that we've created using the Android Studio Designer. And that Layout class will just have values for all the different layouts inside of our project. Now similarly, we have that class for id values. So when we were working inside the Android Studio Designer, and we gave one of our views an id, like this one here, spinner_courses, inside the id class, is a constant called spinner_courses. So using that value of R. id. spinner_courses, would then be used to search the view hierarchy, find that particular view, and then give us back a reference to it, and that would be true for all the id values used throughout our program. So to get a little better picture of this, in our next clip we'll just take a look at this inside of code.

Demo: Activity/Layout Relationship
Here we are back in Android Studio, and let's think about a couple of things from our layout that we might want to initially deal with with our Java code. Now one thing is that we've got this control here, Spinner, and a Spinner has got to be loaded up with data, and we haven't talked about how to do that yet, but we're going to at least need to reference that spinner in order to load it with data. Another thing is this fab down here. We don't really need this fab button on this particular screen. But now there's an interesting issue, if I click on the fab, nothing happens. id select the other views that are on here, but I can't actually select the fab. And in fact, if we look at the Component Tree there, there's no fab on the Component Tree. Well, let's take it over here, let's go over to our project, expand that out, and I want to go ahead and find this layout resource file in the project. Now I could expand all the nodes inside there and try and find it, but there's actually a really helpful button up here at the top. If I click on that button, it'll actually locate the current file in the tree. So let me go over and just click that. Now currently you're in content_note. Notice that there's an activity_note just above it. So let's go to activity_note and let's double-click that. Now that takes us to another screen that looks very much like what we were just looking at, but if we look at the Component Tree, the fab is actually in there. Also notice that there is an include node. If I hover over the name there, notice the include is layout/content_note. So basically this is one resource file that has the basic structure of our screen, but then includes another resource file that has that detail layout that we were working in, and you notice that this one has the fab in it. So I can go over here and select the fab, and in this case I'll just go ahead and delete it. Now before I delete it though, take note of the ID, the ID for this fab is fab, and again, fab is what we often call floating action buttons. I'm going to go ahead and delete that one from here. We'll have other fabs, or floating action buttons, in other activities, but we don't need one in this one. So now we've removed that floating action button, fab, and we're going to want to get a reference to our Spinner. So what we want to do now is take a look at the Java code. So I'm going to go up here to the Java nodes here, expand that down, go to the very first package name underneath here, expand that, go to my NoteActivity. I'll just double-click on that. So that now puts me inside of the NoteActivity Java code. Now remember we said that there was no automatic relationship between a layout file and the Activity class, that actually has to be brought in, and that's what that setContentView method call does. So the R. layout. activity_note that loads up the layout resource called activity_note, which then includes our layout resource content_note, so that brings up that UI. But now notice here that there's a place where we say findViewById for the R. id. fab, where we just deleted that guy, so that guy is gone. So we don't want to run this code because it would actually fail, because there is no view with an ID value of fab on there, we'd actually get a null reference exception. So let's go ahead and remove that code, so everything to do with the floating action button I'll just go ahead and highlight, and then I'll delete. So that's gone, but now we say we're going to need a reference to our spinner. So what we'll want to do here is that in order to actually interact with the Spinner in our code, we're going to need a variable that references it. So we're going to declare a variable here of type Spinner, and you'll notice that when I type Spinner, a message pops up asking me to Alt+Enter android. widget. spinner. What this is saying is that you have not imported the package for the spinner, do you want me to go ahead and automatically import it, and I do, so I'll just go ahead and hit Alt+Enter. So I went ahead and imported the package for that. I need a variable, and I'll call my variable spinnerCourses. So now I want to go ahead and assign that to the result of a call to findViewById. But remember that findViewById's return type is View, and we need to actually cast this into a Spinner. Now we could manually cast it, but one of the cool things Android Studio does for us, if I put a parentheses, and then I hit Ctrl+Shift space, it will actually put the right cast type inside the parentheses for me. So now I can call findViewById, and I want to pass it in, remember, again, we're going to use the R class, so it's going to be R. id, and it'll be dot, and that's our spinner_courses. And when that method findViewById returns, our variable, spinner_courses, will then have a reference to the Spinner in our layout. Alright, so now in our next clip let's see how we can actually load a list of items to choose from inside of our Spinner.

Populating a Spinner
Now when we put our NoteActivity together, we put a spinner on that NoteActivity. Now a Spinner has two identities. it has one part that we look at that shows the current selection, but when the user taps on the triangle, an area opens up to show the available selections. So what that means is that somewhere in our program there's some data that we want to then use to populate the selections within the Spinner. There's actually a bit more to a Spinner than that. Spinners also need to have layouts associated with them. One Layout is used to format the current selection, another layout is used to format each of the available selections. So there's three tasks involved in populating the Spinner, getting the data across, and then managing each of those layouts. And that's where Adapter classes come in. Adapters are responsible for doing the work of moving the data over and managing each of those layouts. Now there are different kinds of adapters available. Some manage in-memory data sources like a razor list, others manage database sources that use cursors, and we'll see different kinds of adapters throughout this course series. In this particular module, we're going to use an adapter that populates a Spinner using in-memory information.

Demo: Populating a Spinner
So here we are back in Android Studio, and let's go ahead and add some code in to populate our Spinner. Now before we can do that we're going to need some data to put into the Spinner. Now if you look in the before folder that comes with this particular module, you'll see that there are actually four source code files in there. And this is our in-memory data model that we'll be using throughout the early part of this course series. A little bit later in the course series, we'll actually switch over to using a database, but this will give us the things we need to start working with other aspects of Android before we get to that. Rather than spending a lot of time going through the details of that model right now, we'll just explore different pieces of the data model as we need them, as we're building the application. So what I can do here is I'm going to go ahead and just copy all of these files, and I'll return back here to Android Studio, and I'll just go to the package name where my project is, and I'll just go ahead and paste them in. Let's just do a regular paste. Basically, Android Studio will confirm some things like, do you want it to copy to a particular folder, if the package name doesn't match up, do I ask if you want to change the package name. But once we say OK, we'll be all set and we'll have those files as part of our project now. Now let's look first here at just the CourseInfo. Now CourseInfo class describes a course, and it's things like a string identifier for the course itself, the title of the course, and then there's a list of modules. And one thing that I just want to point out here if we scroll down in the CourseInfo, we go down to the toString method, notice that the toString for CourseInfo simply returns back the course's title. Because what we're going to actually do is take these CourseInfo instances and associate them with the Spinner, and when we do that, it's actually the result of toString that the Spinner will actually display for each of the instances of CourseInfo that are inside of that Spinner. Now the way we actually get to that CourseInfo instance is we're going to go to this class here called DataManager. Now DataManager is a singleton, and all that means is that there's just one instance of DataManager throughout the entire application. So whenever we want that instance, what we do is we go to the DataManager class, it has a static method called getInstance, which will give us back that one instance. And if you look at our getInstance implementation here, what this does is it goes ahead on the very first call, creates that instance, it then initializes the list of courses that are available to the application, and it also just puts some example notes in there, and we'll kind of interact with those a little bit more as we get further into the course. Now one of the important methods here in DataManager, if I scroll down a little bit more, you'll see there's one here called getCourses, and that returns us back a list of courses. So the results of that getCourses call is what we're going to actually associated with our Spinner. Okay, so let's return back to our NoteActivity here, and there we have our Spinner reference. Remember we called findViewById earlier to get that reference. So what we need to do now is go ahead and create the adapter we're going to use with that. Now before we create the adapter, let's go ahead and get that list of courses back. So what we're going to do is go ahead and declare a List. The list _____ generic so I'm going to go ahead and specialize it on CourseInfo. Now you see once I do that, Android Studio is telling me that I haven't imported that package yet, so I'm going to go ahead and do an Alt+Enter to import the package. And then I'm going to go ahead and give it a vb, which will just call courses, and then from there, I'll simply go to DataManager. getInstance. getCourses. So there we have our list of courses. What I want to do now is go ahead and create the adapter that I'm going to use to associate that list with the Spinner. Now there's a few different kinds of adapters. What I'm going to use here is ArrayAdapter, and the ArrayAdapter is a class I can use with either arrays or lists. Again, I'm going to go ahead and give it a generic argument of CourseInfo. You notice again it prompts me to do the Alt+Enter to bring in the package. So once I have that now, I'll go ahead and give it a variable, and I'll simply call this variable adapterCourses. So from there I'm going to go ahead and new up the ArrayAdapter. So when it comes to constructing the ArrayAdapter instance, there's actually several different overloads of the constructor. Now the standard Android Studio settings would actually show you various parameter lists that are available. When we're recording our videos, we turn those off, just so they don't get in the way while you're watching. But anytime I want to see the list of available parameters for any method call or constructor, I can simply do Ctrl+P. So when I do Ctrl+P, that shows me some of the different overloads that are available. Now the one we're going to use accepts three parameters. It accepts a context, a resource, and then the list we want to pass in there. Now we'll talk more about the idea of context in the next module. For now, let's just go ahead and pass this. We're just going to pass our current activity as the context. So now when it comes to the resource, as I mentioned, we could use a custom resource of our own, but Android also provides some standard resources that we often use for common scenarios. Now they are also in an R class, just like our own custom resources are, except it's called android. R. And android. R has a layout class within it, and one of the built-in layouts that's available to us is called simple_spinner_item. So that simple_spinner_item is the resource we're going to use to format the selected item in our Spinner. So now we give it the information we want to go ahead and put into the Spinner, which is our list of course. So once we construct the ArrayAdapter, we have the resource for formatting our selected course, as well as the list of courses. So now we can go ahead and associate the resource we want to use for the dropdown list of course. So that's going to be a separate method call. So we're going to call the setDropdownViewResource method on our adapterCourses. And we're going to pass it another one of the standard Android resources, which is going to be android. R. layout. simple_spinner_dropdown_item. And with that, our adapter is all set up. It knows how to get the information, our list of courses, and the two formatting layouts that we want. The only thing left for us to do is go ahead and associate that adapter with our Spinner. So to do that we're going to call our spinnerCourses. setAdapter, and pass in adapterCourses. And with that, our Spinner is now all set to go. So let's go ahead and run this now, and see what it looks like. So we can go up here and just click on the Start Debugging. That brings up my Select Deployment Target. Now notice here under the Available Virtual Devices, the adapter we created earlier is grayed out. The reason being is that that Emulator targets API 23. We created this with API 24. So we're going to go ahead and create a new virtual device. We'll click that button just like we did earlier. When that comes up, we'll go ahead and choose our device definition. Now I love my Pixel, so let's go ahead and choose Pixel, choose Next. We'll go ahead and use the API 24 as the System image, and we'll say Next. And we'll go ahead and take the default names, and we'll go ahead and finish that up. And with that, we'll go ahead and click OK to start our program running. So here we are now running inside the Emulator. If I click on my little triangle, I see the list of courses that are available. If I choose one of those courses, it now becomes a selected course. I can click on the triangle again, choose a different course, and that now becomes a selected course. Alright, so that easily now we've been able to populate our Spinner with our own custom data, and it was very easy for us to give it any kind of customized formatting if we want to. In this case, we wanted standard formatting so we used the built-in Android layouts, but again, we could have easily used a custom layout of our own to give it our own customized appearance.

Summary
To wrap up, here's one of the key things to remember from this module. Remember that activities are what present our user interface, and the key building blocks of that user interface are our View classes, and there's a wide variety of View classes available. One very special and important type of View class are our Layouts, and remember our Layouts handle our positioning behavior, they're responsible for arranging the children within them. And they are a really important part of creating a responsive user interface. Remember that there are a wide variety of Android devices available, and they have a wide variety of display characteristics. Layout classes are a key part of being able to meet the needs of those different characteristics. Now although there are many different Layout classes available, we want to tend towards a class called ConstraintLayout. It's a very powerful and flexible Layout class, and it's often the only one we need. And it's also very closely integrated with the Android Studio Designer, making it very easy to work with. Although we can build an Activities user interface entirely in code, we tend not to do that, we tend to use Layout resources, and it's important to understand the relationship between an activity and its layout resource. And the important thing to remember is, there is no implicit relationship between an activity and its layout. You must explicitly load that layout, and that's where that setContentView method comes in. Now once you've got a layout loaded, if you want to get references to the views within the layout, you have to request those as well, and that's where the findViewById method comes in. Now an important part of interacting with our layout resources and our views is the R class. Now remember the R class is a generated class that contains a bunch of different constants. The ones that are really interesting for us in this discussion is the ones related to the layout resources, which are constants in the R. layout class, and for our View Id's, there's an R. id class. And those classes, again, contain constants that allow us to get access to either our layout resource, or our individual views. Okay, so that wraps up this module. in the next module, we'll start digging into the Activity Lifecycle.

Working with Activities
Introduction
Welcome to the Working with Activities module of the Pluralsight course, Understanding Android App Basics. My name is Jim Wilson. We'll start out looking at how activities interact. We'll then dig into the role of Intents and describing Android operations. Now an important part of describing operations with Intents are what are called Extras, and we'll dig into the special challenge that reference types play when passing them as Extras. We'll then see how to implement an interface called Parcelable, a very important part of passing reference types as Extras. As we discuss each of these topics, we'll also be adding some great features to our app. We'll add an activity that displays our list of notes, and we'll make that activity our app startup activity, we'll add handling to display a note in the NoteActivity when the user selects a note from the list, and then we'll finish up by hooking up our new note behavior. Okay, so let's get started.

Activity Interaction
In our last module, we created our NoteActivity, but as you'll recall, the NoteActivity is not where we want people to start in our application. We want the application to start by showing the user an activity containing a list of the available notes, and then when the user selects one of those notes from the list, that then launches our NoteActivity displaying the information for that note. Similarly, when the user taps on the New Note button that should also take us to our NoteActivity, allowing them to create that new note. So what that means now is that we want to have one activity or NoteListActivity, and that's going to need to interact with our NoteActivity. Now in order to understand the way activity interaction works, we need to understand one really important point about Android. Android is a component-oriented platform, and Android has a number of different types of components, Activities are just the most familiar Android component. We'll see the other component types throughout this course series. Activities, just as with other component types, are distinct from one another. What that means is that an activity cannot directly create another activity. Instead, it relies on something known as an Intent. Now Intents are something that is very fundamental to the Android platform. Think about when you're sitting with your Android device, and you have the launcher screen up, well, when you tap on an icon on the Launcher screen to actually get into an application, what you're really doing is getting to an activity. So when you tap on that icon on the Launcher screen, that actually sends an Intent. Android will then look to see if the process associated with that activity is running already, if it's not, it'll go ahead and start it up. It then goes ahead and creates that activity, passing it in the Intent. Well this Intent model works very much the same inside of our own applications. So if we have one activity that wants to start another activity, what we need to do is create an intent, that intent will identify the desired Activity. Now within our applications, generally the only thing we need to identify that Activity is the class information for that Activity. We'll see a little later that there are other ways that we can identify a desired Activity, but the class info is generally all we need inside of our own applications. Now once we have that intent, we call a method called startActivity, and we pass it the intent. And just by doing that, that will then launch your activity that matches the intent. So then when we're in our application, and the user is looking at the NoteListActivity, when the user then goes and taps on one of the notes in that list, what our note list activity will do is go ahead and create the Intent and call startActivity, which will then start our NoteActivity. In our next clip, we'll go ahead and implement all of this in code.

Creating the NoteListActivity
Here we are in Android Studio. Now the first thing we'll want to do is go ahead and create our new activity, our NoteListActivity. Now there's a couple of ways we could do that. One way to do it would be to go over here to the File menu, choose New, and then down there is a selection for Activity, and that would certainly work. An alternative is, and this is the one I usually use, is just go to the package name, right-click, choose New from there, and it takes you to the same selection. So I can just go down here to Activity, I can then pick a particular Activity, or I can choose the Gallery. Let's use the Gallery. You can see when we go into the Gallery, this basically gives us the same kind of wizard screen we had when we were creating a new project. Let's go ahead and create a basic activity, just as we did when we originally created the project. I'll choose Next, and now I need to go ahead and name it. So I'll go ahead and call this guy our NoteListActivity. Now once I change the name of the Activity class, it creates an activity layout name for me of activity_note_list. It also sets the Title. Now we could change the Title, but let's leave it for what it is right now as NoteListActivity. We'll change it a little bit later. Now I also want to choose this option, Launcher Activity. In other words, I want it to have an icon in the Launcher screen. So that gives it all the information it needs. Let's go ahead and click Finish, and once that wizard finishes it takes us into our Designer screen here. And you'll notice that if we look at the Component Tree it's actually ConstraintLayout again, that's what we'll be using. Now one thing you'll want to do is go over to the Project window and just close that so we have a little more room to see things here. Now the only thing we want to add to this Activity is the ListView. So what we want to do is go into Palette, and we want to choose Containers, and we want to choose ListView, I'm just going to go ahead and drag that onto my Activity, and then once that's on there, what I want to do is have it fill the whole screen, so I want to go ahead and set constraints to all of the parent edges. So I'll grab the top, put a constraint to the top edge, grab one to the right edge, and the same thing to the left and to the bottom. Once I do that, I have constraints around all four edges, so basically the ListView is going to fill its parent area. You notice that in the Properties that the constraints each have an 8 dp value, so it just gives me a little bit of spacing around the edge. And remember that one thing I want to do is whenever I'm using constraints for sizing I want to set the layout_width and layout_height to be 0dp. By setting this to 0, I now am basically saying match constraints. I want the width to be whatever the constraints cause it to be and I want the height to be whatever the constraints cause it to be. Okay, now I also want to make sure I go up here and give this an ID value, and I'll give it an ID value of list_note. So we've got our ID value there of list_note, in fact, why don't we put an s on the end of that since it's going to be showing a list of multiple notes, so now we're list_notes. So now we got our ListView all set up, so let's go back over to our project window now and let's go into the actual code for the activity. So I'll go ahead and expand my tree out here, go down here where it says jave, go to package name, and I'm going to go here over to my NoteListActivity. So once we open up the NoteListActivity, we can see that our setContentView loads up our activity_note_list, so we know we're good to go there. So now we want to go ahead and populate our ListView. So what we're going to do is work inside the onCreate method, that's a method that gets called as part of the process of creating the activity, and I don't want to put the code directly inside of here. Let's say I want to go ahead and put it into a method called initializeDisplayContent. Now I could go ahead and just create that method, or one nice thing Android Studio can do for me is create the method body for me. So the first thing I'm going to do is just type in the method call. So now once I type in the method call it's highlighted in red because there's no method with that name, but notice there's also this little light bulb off to the side here, and when I click on that it says, hey, do you want to create this method initializeDisplayContent, so I'm going to choose that. And you'll see it automatically creates the method declaration for me. Now the void is highlighted in blue. Basically it's saying that it has inferred that I want to return a type of void, but maybe I want to change that. And I don't want to change it, though, so I'm just going to hit the Tab key. And it says, go ahead and use what you inferred, the void. So now I've got to call to my method, initializeDisplayContent, and I'm right here inside the body. So now I want to start doing the work. So what I want to do is inside the ListView add a list of all the notes. Now in order to do that, the first thing I need to do is get a reference to the ListView, so I'm going to declare a variable called listNotes of type ListView. Now you notice once I do that Android Studio is saying, hey, do you want to go ahead and import the package for ListView, and I do, so we're going to go ahead and hit Alt+Enter. Now I want to go ahead and call findViewById, but I need to do a cast, so I'm going to go ahead and put the parentheses in place and do Ctrl+Shift space. And so now I just call findViewById with R. id. list_notes. So now I've got to reference the list notes, so now I'm going to need to get the content that I actually want to put inside of there. And I'm going to use the Data Manager, much like I did with Course Onfo to get references to what are called NoteInfos. Let's take a look at our NoteInfo class here. So now here inside of our NoteInfo class it's got members for the Course, the Title, and the Text for the note. It's got methods to go along with that. And if I scroll on down here, you see I've got my toString implementation, and it calls a method called getCompareKey, and that's just a method I provided that just concatenates the ID for the course, a vertical bar, the title of the note, vertical bar, and then text. It's just a way to find identifying information for it. And initially to get us started, we'll go ahead and rely on that toString method to populate the list items for us for each note. A little bit later we'll just want to make it look a little prettier, but for now we'll just go ahead and rely on the toString to give us back the representation of each note. Okay, so I'm going to go back here into my NoteListActivity, and so the first thing I want to do is go ahead and get the list of notes, so I'm just going to create a variable called notes of type list with a generic argument of NoteInfo. And again, I'll do Alt+Enter to bring the package in. And then I'm going to use the DataManager. getInstance to call getNotes, just as we in a previous module called getCourses. So, again, I'm using the DataManager singleton, getting the instance back, and then getting the list of notes back from it. So now I can take those notes and put them into the ListView with an adapter, very much like we did with the Spinner in the previous module. So let's go ahead and use an ArrayAdapter, just as we did in the previous module. So I want to create an ArrayAdapter that holds NoteInfos called adapterNotes, again we'll do the Alt+Enter. Then we'll go ahead and new up the ArrayAdapter. So the ArrayAdapter will go ahead and pass in this, and that's just the context that it's being created in. And then it needs to know the layouts. And for now we're going to use another one of the built-in layouts called simple_list_item_1. So that's just another one of the built-in layout resources Android provides, and I'm going to pass it in the list of notes. So that gives us our ArrayAdapter, so now I'll just call listNotes. setAdapter to associate it with the ListView. And with that, our ListView is now populated with all the notes in very much the same way that our Spinner was populated with the Courses in the work we did in the last module. Now that will go ahead and display the last of Notes, but now we want to handle the user selection, so when the user taps on a note, we want to go ahead and launch our NoteActivity showing that note.

Handling ListView Selection with an Anonymous Class
So one of the first things we need to do is actually handle the user making a selection. Now if you check out any of the view-based classes, they all have methods allowing you to associate handlers for the events that are appropriate for that kind of view. So now in the case of a ListView, we want to actually handle an item click. So if we check it out here, the listNotes variable will support a method called setOnItemClickListener. This method, setOnItemClickListener, actually accepts a reference to an interface. Now that interface can be implemented on our NoteListActivity, you could even add another class in since you've already created the _____ interface. But one of the things we commonly do in Android situations like this is take advantage of Java's ability to create anonymous classes. In other words, we have situations where we just need a method body to implement one or two methods on an interface rather than clutter up a class having lots of different interfaces it's implementing, we just create an anonymous class right in place. So I'm going to scroll down here a little bit to give us a little more room underneath there, and what we actually need to implement is the interface adapterview. onItemClickListener. So what I'll do now is I'll just call New, but rather than newing up a class, I'm actually going to new the interface itself. So I know the interface starts out as onItemClick, but let's say I'm not quite sure what the entire interface name is. What I can do here is just do Ctrl space, and when I do that, Android Studio actually asks me, oh, are you trying to implement the onItemClickListener interface that's inside the class adapter view, and I say, well, yes I am, so I'll go ahead and choose that. And you'll notice that once I chose that, Android Studio took care of properly qualifying the interface name, as well as putting all the anonymous class body in place for me. It put all the brackets after the interface name, and it overrode the appropriate methods. So what that does now is that technically this anonymous class is a nested class, in other words, its instances exist within instances of the NoteListActivity class, and that's just the way anonymous classes work in general in Java, it's not an Android specific thing. The body of this method, onItemClick, will now get called each time the user makes a selection from the ListView. So in our next clip, we'll go ahead and implement this method to show instances of our NoteActivity.

Implementing Activity Interaction and Startup Behavior
So now remember that each time a user selects something in our ListView, this onItemClick method gets called, and when that gets called we want to go ahead and show our NoteActivity. Now remember, we said that the first thing we need to do is create an intent that identifies the activity we want to start. So I'm going to go ahead and declare a variable called Intent, of type intent. I'll then do an Alt+Enter to bring the package in. I'll go ahead and new up the Intent. Now there's a few different constructors for Intent, so I'm going to go ahead and do a Ctrl+P. This is a list of parameter options I have. Now the one I want is the next to the last one on the list, the one that accepts a context, and then class information. Activities are actually a type of context, so we can actually pass the this reference for the activity for that context parameter. So I'm going to go ahead and put this here, and then it wants the class information for the activity I want to create, and that's my NoteActivity, so I'm going to pass NoteActivity. class. So I have my parameters there, but notice that the parameters are underlined in red, so let me go ahead and hover over the red line. And notice it says it cannot resolve constructor, and it says the first argument is 'anonymous'. Well, remember that my interface implementation is an implementation of an 'anonymous' class. What I actually want is the this reference to the NoteListActivity, so what I need to do is qualify the this reference to be NoteListActivity. this, and then that takes care of the error we are receiving. Now one thing I'll just point out, if you're not familiar with working with things like anonymous classes and so forth, you might want to just browse up on your Java skills, so just check out our Java Fundamentals courses we have, and it'll actually give you all the information you need in terms of understanding the Java skills that are required to work in Android. Okay, so we've got the Intent created, so now remember the next thing we need to do is called startActivity, so we're going to go ahead and call the method startActivity, and we just pass in the Intent. And that's all the code that's required to start our activity. We created an Intent that identified which activity we want to start, and then we call startActivity, passing that intent. So let's go ahead and run this and see how it all works. I'll choose my Emulator. Now my program came up in my Emulator, but it's actually still showing our NoteActivity, not our NoteListActivity. Now I remember that we actually checked to make our NoteListActivity a Launcher so something is going on there. So let's go ahead and close down this Activity, I'll click on the X to kill that, and let's go here into our list of programs. So now you'll notice there's an icon there for NoteKeeper. we're going to scroll down, and notice there's also one there for my NoteListActivity. So we can try and launch that guy. Okay, that brought up my NoteListActivity. Now each of my list entries aren't very pretty, but that's because we're using our toString method. If we look at the first one there, the android_intents is actually the identifier for our course, the Dynamic intent resolution is the title for our note, and then the Wow, intents allow components to resolved at runtime is the body of the note. So it's doing the right thing there in terms of populating our NoteListActivity. So let's go ahead and just pick that very first one, and when I did that it launched my NoteActivity. So that's all working just fine. Our implementation of our NoteListActivity in terms of handling the selection and launching the NoteActivity is working fine. So the only thing we need to understand then is why didn't our NoteListActivity start when we ran the application from inside of Android Studio. So let's return back to Android Studio. Now notice over here in the Package window there's a folder for something called manifests, let me go ahead and expand that. And there's one called AndroidManifest, and the AndroidManifest identifies the components that are in our application and information about those components. So let's double-click on AndroidManifest and see what's inside of there. So now if we take a look at this guy, we see that there's an application section at the top, and then if I scroll down here a little bit there are two activity entries, one for our NoteActivity, and then one for our NoteListActivity. And you notice that each of those activities have a label. The label for NoteActivity is string/app_name. The label for NoteListActivity is string/title_activity_note_list. Now those are string resources, and they actually identify values that are stored as resources inside of our application, and we'll talk a bunch more about resources later in the series. I want to point out something. You notice that the application entry also has a label, and if I click on that, notice that that's also string_app_name. So maybe the reason that NoteActivity started instead of NoteListActivity is that it uses that label app_name. So maybe if I did something like change NoteListActivity to have a label of app_name instead of NoteActivity, maybe that would work. So let's do something here. Let's go to the title_activity_note_list, and we know we're going to change this guy's label to be app_name, but let's go here and right-click and say Go To Declaration. And when I clicked Go To Declaration, it took me into the string values that are associated with that resource, so title_activity_note_list had a value of NoteListActivity. Well, we're not going to need this string resource anymore, because we're going to go ahead use the app_name for our NoteListActivity. So why don't we use this resource for the label for our NoteActivity instead. So I'm going to change the name here from title_activity_note_list to just title_activity_note. Now I could just go ahead and make the label NoteActivity, but this is actually the value that will show up at the top of the activity, and what we would really like to have the NoteActivity say is Edit Note. So I'm going to change this to the string value Edit Note, so now Edit Note is associated with that string resource. So let's go back into our Manifest here. So what I'll do now is I'm going to change the label for NoteListActivity to be app_name, and then I'll go ahead and change the label on NoteActivity to be the other string resource we just created. So NoteActivity will now have a label that corresponds to title_activity_note, which is Edit Note, and our NoteListActivity will have a label of app_name, which is the same label the application has. So let's try running it again. So here in the Emulator you see it has still launched the NoteActivity and not the NoteListActivity. So let me go ahead and get rid of this guy again. Let's go back to our Launcher, and you notice here if I scroll down a little bit that there's the NoteKeeper icon, and there's also the Edit Note icon. And if I look at the NoteKeeper icon, if I click on that guy, that takes us into our NoteListActivity. So that label was being used to identify the name of the activity inside the Launcher. So it's not just the value at the top, but it's also the value inside the Launcher. So if I click on this first ListItem again, there's our label at the top is Edit Note. So let's go back to the Launcher, and so you're looking at the Launcher that means that both of our activities are showing up in here, the NoteKeeper, which is our NoteListActivity, and our Edit Note, which is actually the NoteActivity, and we don't really want both of those here in the Launcher. So there's something else going on. It wasn't just changing that label, that label was really just that, a label. So let's go back in Android Studio. So here we are in our Manifest, and we notice that if we look at both activity entries, each of the activity entries have an intent-filter element within them, and the intent-filter is a part of how activities advertise what they're capable of doing. And the intent-filter that has an action whose name is the android. intent. action. MAIN, and the category whose name is android. intent. category. LAUNCHER, that's used to indicate that this activity can be a Launcher activity, in other words, a startup activity, and we don't want both of these to be startup activates. We only want the NoteListActivity. And because we had had multiple activities marked as Launcher activities, when we ran our program from within Android Studio, it was simply picking the first one it encountered, which was our NoteActivity. So what I'm going to do here is go ahead and just delete away the intent-filter from within the NoteActivity. So now only our NoteListActivity is marked as a Launcher activity. So let's go ahead and run this guy again. And now when we run it, we go right into the NoteListActivity, and if I choose one of the entries, it opens up my NoteActivity, so we're making some good progress. In our next clip, we're going to see how we can actually pass information to the NoteActivity about which note we want it to show.

Describing Operations with Intents
Let's look a bit more closely now at this idea of intents. Now intents describe a desired operation. Now as part of an operation we're describing a desired target like an activity, but we often need more than just a target, we may need to provide some additional information, think of our application. We had our NoteListActivity where when the user selected a note in that list we wanted to start the NoteActivity, and what we really need to do now is actually pass information about the selected note into the NoteActivity. And this idea of providing additional information is where intent extras come in. Now intent extras are really nothing more than name value pairs, and there's no magic pre-defined set of names or name value pairs, it's simply something that's operation-defined. You can use whatever names you need to for your operation, you can handle whatever values that you need to. Now the extras are attached to the intent, and the Intent class has an extra on it called putExtra that has a series of overloads that handle varying data types. And then once that intent is sent, the target needs to be able to access the intent. And the Activity class can actually access the intent that started it, by simply calling the getIntent method. When it calls getIntent, it will receive back a reference to the Intent, and then that returned Intent has a series of getXXExtra methods on it that will retrieve extras by simply requesting the extra by its name. Now the geteXXExtra methods actually include the return type in their name, and that's simply a factor of the way Java overloading works. PutExtra doesn't need to type in a name because the values are being passes as parameters, and Java overloading allows methods to vary by parameter type, but the getExtra returns the value as a return type, and Java overloading does not allow methods to be overloaded based on return type, so that's why we have to include the type in the getXXExtra method names. Now look at the diagram we've been using throughout this module. If we think about our application, our first activity, our NoteListActivity sent an Intent to our other activity, NoteActivity, and that Intent travelled entirely within our application process, because both those activities were in the same application. But let's think about how a user would start their application in the first place. Well, they would go to the Launcher screen, choose the icon for our application, that would send an intent, and that intent would ultimately start our initial activity or our NoteListActivity, but that intent actually started out outside of our application process and then travelled into it. And that same idea of intents travelling across process is not something limited to the system. If we need to, we can have an activity in our application send an Intent to travel to outside of our process, and out to an activity in a different process, and in fact we'll see an example of that a little bit later in this course. So if we can send Intents that leave our process and go into another process, that means that Intents must be cross-process friendly. What that means is that that's going to somehow limit the allowable extras, because the extras have to somehow be cross-process friendly. Now some of the supported extra types are ones you would expect, things like primitives and strings are supported because they're easily passed across processes. Arrays of those types are also supported. A few variations on ArrayLists are supported, and there's a few other special types. But fundamentally, most reference types are not directly supported, because reference types are not inherently cross-process friendly, so they're going to require some kind of special handling. In our next clip, we'll look at how we can provide that special handling.

Reference Types as Intent Extras
In order to make our reference types cross-process friendly and therefore be allowed to use them as intent extras, we have to have a way to flatten our reference types. When we say flatten, all we really mean is converted to a bunch of bytes. Another term people sometimes use is make it wire-friendly. What that really means is that you take the object, convert it into a stream of bytes that you can pass one process to another and then somehow put it back together from that stream of bytes. Now one option for doing this is Java serialization, and Java serialization is supported for intent extras, but it's not really preferred, and the reason is that serialization is very runtime expensive. So Android provides an alternative called Parcelable, and a Parcelable API is much more efficient than serialization. And what it really come down to is that where serialization takes very little coding on your part to support, you basically can just implement a marker interface and then the runtime does all the work for you, well doing that takes a lot of work. Well in the case of Parcelable, we have to explicitly implement the behavior. So you can think of it as Java serialization is really easy to implement, but it's a lot of work to actually do. Parcelable is a little bit of work to actually implement, but it's much more efficient to actually do, and since you may need to pass object instances frequently, it's really good to have an efficient way to do that. Making a type parcelable is pretty straightforward. The first step is implementing the Parcelable interface. And it has just two methods on it. The first one is, describeContents, and that's used to indicate any special behaviors our parceling may require. In most cases, we don't have any special behaviors, so most implementations just return 0. The other method is writeToParcel, and that'll receive a reference to a Parcel instance, and the Parcel class has a series of write methods on it, and those write methods are what we use to store the data from our object into that parcel. Now once we implement the interface, we also need to provide a public static final field called CREATOR to our type, and CREATOR field must be of type Parcelable. Creator, and so basically it's an implementation of the interface Parcelable. Creator. And, again, this is a pretty easy interface to implement. The first method is createFromParcel, and this is the one that's actually responsible to create a new instance of our type. So it'll receive a reference to a parcel instance, and then we'll use the parcel. read methods to get that content back from the Parcel and set the values inside of our type. And the other method we need to implement is one called newArray, and it receives a size, and as its name implies, it's simply responsible to create an array of our type on the specified size. In our next clip, we'll jump into the code, and we'll actually make our NoteInfo type parcelable.

Implementing Parcelalable
Here we are in Android Studio working in our NoteInfo class. Remember we said we want to take a NoteInfo and be able to pass it as an extra in an intent from one activity to another. So to do that we're going to make our NoteInfo class parcelable. Now if we look at the members of NoteInfo it's got three, a Course, a Title, and Text. Now Title and Text are straightforward, they're strings, so we know we can parcel those directly. The Course member is actually another class, CourseInfo, so we're going to have to do something about that. Because we're going to make NoteInfo parcelable we're going to have to be able to pass all the things that reference it, so we'll take a look at that in just a second. Now to get started, we're going to go ahead and implement our Parcelable interface, so let's put implements Parcelable. So when I save implements Parcelable it underlines it in red, because I don't have any of the members yet, but that little red light bulb will do the work for me, so I go over here and I say implement Methods. It says, well, do you want to implement both the methods on interface, and I say yes I do, and I just click OK. And that goes ahead and stubs out the method for me. So let me just scroll down here a little bit. Now describeContents is stubbed out to return 0. Again, describeContents is used when we have kind of special parceling needs, but we don't have any of those, so we'll just go ahead and return 0 as what we want to do, so we'll leave that guy alone. Now writeToParcel is responsible to write the member information for the type instance into the parcel, and it receives a parcel as a parameter. So what we want to do is go through and write each of the members in there. Let's start out by writing just the Title and the Text, because those are both strings. I was going to say destination, or dest. writeString for Title, and the same thing for Text. So that takes care of those two fields, but now what about the course. Remember the course itself is a reference type. Well, course is going to have to parcelable, so there's actually a method to write other parcelable types into the parcel. We'll call destination, or dest. writeParcelable, and we need to pass in the thing we want to write, which is a reference to our Course, and then there's another parameter for a flag for any special handling, and again we'll pass 0. So that takes care of the saving side of parceling, describeContents, and then the writeToParcel writes all of our content into the parcel. But now we also need to be recreatable from a parcel, and that's where that field called CREATOR comes in. Go down here and add a couple of lines. Remember, the field needs to be named CREATOR, all caps, it's got to be a final static, and its type has to be parcelable. creator. Now the information returned back from this field is going to be used to create new instances of our type, so the parcelable. creator interface is actually generic, and so we actually have to provide our type name as a generic argument. So that indicates now that our CREATOR is able to create instances of NoteInfo. Now once we have that in place, we need to go ahead and create an implementation of a class that can provide the Parcelable. Creator behaviors. So generally the way we do that is, again, we just use an anonymous class. So we're going to go ahead and just new up a Parcelable. Creator, and again, since we're doing this as an anonymous class we'll go ahead and just put the class body right here. Now we'll implement the methods, again, we'll use our little light bulb over here, so we'll just click on that and say implement methods. Yep I want both the methods in it, let's scroll down a little bit here. So now it's stubbed out our createFromParcel and newArray. Now let's look at newArray first. Now newArray is responsible to create an array of our type of the appropriate size, and notice the size is a parameter. So all we need to do here is where this stubbed out code says new NoteInfo size 0, we want to make that a new NoteInfo of size size. So that takes care of our newArray part, now we want to do the createFromParcel. So createFromParcel is where we want to go ahead and create a new instance of our type, and then set all the values inside of it. One thing that's important to remember is that whenever you're setting the values from createFromParcel, they need to be the same order that you wrote the values and writToParcel, because there's no real identifiers here, the values are simply written in and read back out in order. Now commonly what we do is when we're implementing createFromParcel, rather than actually set all the values directly in createFromParcel, we'll often just go ahead and use a private constructor. So what we'll do here is I'm going to say newNoteInfo, and I'm going to pass in the parcel as a constructor argument. Now, of course, I don't have a constructor of that signature, again, you notice we've got our light bulb over here, so I'm going to go ahead and click on that. And I say, yep, go ahead and create that constructor for me. So it creates a constructor, it confirms that I want the argument type to be parcel, I want that, so I'll hit Tab. And I want the parameter name to be source, which I do as well, so I'll hit Tab again. So that goes ahead and now stubbed out that constructor for me. Now it's made it public, but let's go ahead and switch that guy over to private. And one of the reasons it's helpful to use a private constructor to populate our instance from a parcel is that if we have any fields that are marked as final, remember if a field is marked as final we want to go ahead and set it inside its constructor so that takes care of that issue. Now NoteInfo doesn't have that situation, but it's just kind of a standard we tend to follow. Okay, now just as we wrote the values into the parcel, we're going to read them back. Now we know the first we want to read back is the Course, because that was the first one we wrote. but let's come back to that one. Let's just go ahead first of all and read the Title and the Text, and those are both strings, so we're simply going to do a readString to get each of those. So that takes care of those two, so now let's go ahead and populate our Course. So we're going to add a line for that, because remember we want to get that one first. So we're going to say mCourse=, and what we're going to do is use our Parcel, and we're going to say readParcelable. Now this is the part that gets a little bit funky. When we read back a Parcelable, we have to pass in the class loader information for that type. So we're going to start out with courseInfo. class, and that gives us access to the class information for the type CourseInfo, and then we're going to call a method on there, getClassLoader. So now we have all the code inside of our NoteInfo class to actually be able to save it into a Parcel and retrieve it back. But now you notice there over in the package window you notice that NoteInfo is underlined in red indicating there's an error. Now let me go ahead and scroll down to the bottom here and see what's going on down there. And you'll notice right near the very end I've got a little red squiggly line there indicating that's where there's an error. Always make sure these cases where you're using these anonymous classes, you need to still go ahead and mark the end of the statement with a semi-colon, because it is an actual statement even though it looks more like a class declaration, well it is a class declaration, but it's being used as a statement, so we needed that semi-colon there. Now one other thing to notice, let's go ahead and scroll back to the top, and remember we said that one of our members here, Course, is of type CourseInfo, which is also a reference type, so that means it had to be parcelable as well. now I actually took care of doing that in advance. So if we go over her and look at courseInfo, notice that CourseInfo implements Parcelable and so it has all the methods that go with that, including a private constructor that set the values. But notice that CourseInfo has a member which is a list of modules, and that's of type ModuleInfo, so that's also a reference type, which means that ModuleInfo also has to implement parcelable, which I also did in advance. So you notice ModuleInfo implements Parcelable as well. And that's just one of the things to be aware of. Although taking any particular type and making it parcelable is pretty easy to do, it's just kind of standard boilerplate steps, you just always want to be aware that when you start down that road, because you're often dealing with what we call object graphs, one type that points to another type that points to another type, you've got to make sure that that entire graph is Parcelable, so that's just always something to be aware of. Okay, now in our next clip we're going to see how we can take our NoteInfo that's now parcelable and now pass it from our NoteListActivity into our NoteActivity.

Passing the Selected Note Through an Intent
So now we're ready to pass our NoteInfo instances with the intent that we're going to pass from our NoteListActivity into our NoteActivity. Now, of course, one of the first things we need to do is actually get a reference to the NoteInfo that the user selected. So here we are inside of the handler for when the user selects an item in our ListView, and that's the one that gets called whenever that user makes that selection. So what we want to do is get the NoteInfo that corresponds to their selection. So to do that we'll need to have the position information. You'll notice here that our implementation of setOnItemClickListener here actually receives the position as an argument, and then we need a reference to the ListView. Now we have a couple of choices. One way we could get a reference to the ListView is take the parent parameter and cast that into a ListView, or since we actually are an anonymous class contained within this initializeDisplayContent method and that method actually has a local variable that's actually a ListView, if we mark that variable as final, we can reference it from inside this anonymous class. So what I'm going to do is go up here is take this guy and mark it as final. So now with that marked as final, we can reference it inside of our anonymous class here. So what I'll do is declare a local variable here called note of type NoteInfo, and I want to assign it the result of getItemAtPosition from the ListView. Now that'll return back an object type, so we need to go ahead and cast that into a NoteInfo so I'll put the parentheses into place and do my Ctrl Shift space so it goes into the cast for me. And so now I'll simply call ListNotes, the ListView. getItemAtPosition, passing in the position. And so with that I have a reference to the note that corresponds to the user selection, so the next thing I want to do is go ahead and put it as an extra into my intent. Now one of the things to remember is that Intent extras are name value pairs, and those names, of course, are strings, and when we use those strings, we generally want them to be constants. Now we can set those constants in a couple of different ways. We could have a class for all of our constants in it for our extras names, or another thing we commonly do is that whatever activity is going to be the destination of that extra, we often just go ahead and put the constant inside of there. So what I'm going to do is go ahead and get rid of my NoteActivity and I'm going to create a constant in there, and I'm going to call it NoteInfo. Now as a constant, it's static and final, and I want to give it some value. Now one thing I can do here I just simply give it the string value NOTE_INFO. and that would technically be right, and in many scenarios it would work, but one thing we want to be aware of is that the information contained in something like the Intent extras and there are some other scenarios we'll see shortly, can often come from multiple sources, and because of that we always want to make sure that our names are unique. so we generally do as we go ahead and qualify these concepts inside of our package name. So since my package name is com. jwhh. jim. notekeeper, I'm going to actually qualify the constant with that same package name. And that way our constants value is unique. So now that we have that constant set up, let's go back to our NoteListActivity and let's go ahead and put the the extra in place. so what we're going to do is take our Intent and all putExtra. We'll then use the constant from our NoteActivity. and then we can go ahead and pass the note. And that way now, whenever the user makes a selection from the list, the note that they selected is now packaged up in that Intent, and then sent over to our NoteActivity. So now in the next clip we'll actually see how the NoteActivity can interact with the note that's contained inside the Intent.

Handling an Intent and Displaying the Content
So here we are now inside the NoteActivity class, and here's where we want to actually get the note out of the Intent that was passed to us, and then display it in the screen. Now I usually like to go ahead and put the work, in terms of getting values out of the Intents, and so forth, into their own methods. So what I'm going to do is go ahead and add a method here called readDisplayStateValues. So now of course I'm calling a method that doesn't exist, but let's give it to our lightbulb, click on that and say createMethod. It creates the method for me, I've going to accept a void return type so I'll hit tab. So now of course the first thing I need here is the Intent. So I'm going to declare a local variable called Intent of type Intent, and I'll call the method getIntent. Now of course I do the Alt+Enter to bring the Intent package in. so now I've got a reference to the Intent that was used to start this activity. so what I can do now, of course, is to get the Extra containing the not from it. So I'm going to go ahead and declare a local variable of type NoteInfo called Note, and I will assign it the result of intent. getParcelableExtra, and it of course needs to know the name of that Extra, and that was our constant, NOTE_INFO. And so now the local variable, note contains a reference to the note that was selected over in our NoteListActivity. But now if you think about this, probably making that note a local variable wasn't very useful, I probably want that to be a class field. Now I, of course, could go ahead and manually move that into a class field, or I could use Android Studio to do the work for me. So what I'll do is go ahead and go up here and right-click on this note, I'm going to choose the Refactor option. Then there's another option after that called Extract, and Extract has an option Field, so I'm going to go ahead and choose field. Notice I could have used the shortcut Ctrl+Alt+F, so I'll go ahead and choose field, and it says, well, do you want its name to be mNote, and that's exactly the name I want, so I'm going to go ahead and hit Tab. And now you notice it now assigns the result of that into mNote, and if I scroll back to the top I've got my field called mNote of type NoteInfo. And that's one of the things you want to learn when you're using Android Studio there's just tons and tons of great short cuts for refactoring your code, and so you always want to check that menu option out well. We'll talk more about that as we go along. So now we have the reference to the notes, and now we're ready to go ahead and populate our note information inside the activity. So let's go back up here to the onCreate method, and what I want to do first of all is get references to the two EditTexts that are inside of the activity, because we know there are two there, there's one for the Title and one for the Text. So now we have references to both of those EditTexts, one for the title and one for the text. and we did it the same way as we always do, we simply called findViewById, passing in the ID values. Let me go ahead and scroll a little bit here. And so what we'll do now is I want to call a method, I'll call it displayNote, and I'll pass in the local variables that reference the Spinner and then each of the EditTexts. So I'll go ahead and let Android Studio create the method for me, hit Tab to accept the return type, and notice that it will also now go through to the parameters. Is that the parameter type you want and name, and I want all of these, so I'll go ahead and just tab my way through them. So now it went ahead and stubbed out that method for me, and so inside of here I'm going to take the Note member variable, mNote, and set each of the values. Let's start out by setting each of the EditTexts. So first we'll take our textNoteTitle, and we'll call setText, passing in the Notes title, and then we'll do the same thing for the notes text. So that sets the Title and the Text, but it still leaves the course information we have to set. Now remember, though, the course information is a Spinner, so we can't simply assign to it, we've got to actually tell the Spinner which one to select. So let's go back up here before these guys and let's add a few blank lines, and then what we'll do here is first of all let's get the list of courses from our DataManager. So that gives us our list of courses. So now the next thing we want to do is get the index of this notes course from within that list, because remember this is that same list that was used to populate our Spinner. So what I'll do is go down here and I'll create a local variable called courseIndex that calls courses. indexOf, and it wants to know the index of the course from our notes, so I'll call it mNote. getCourse. And so when that's done, I'll have the position of the course that's contained in this note within that list. And since our Spinner was populated from that same list, we can go to our Spinner and tell it to setSelection, passing it in that index. And so now we have all of the fields in our NoteActivity populated with the selected note. So let's go ahead and run this guy now and see if it works as we expect it to. So here we are running in the Emulator, and let's just pick the first note here, and notice it's from a course whose ID is android_intents, the NoteTitle is Dynamic intent resolution, and then we see the NoteText, Wow, intents allow components to be resolved at runtime. So let's go ahead and select that guy. And notice that looks pretty good is that our course is Android Programming with Intents, we have that title Dynamic intent resolution, and we have the NoteText, Wow, intents allow components to be resolved at runtime. So let's go ahead and jump back here. So let's try another one. The fourth one down has a course ID of android_async, the title of the note is long running operations, and then it says Foreground Services can be tied to a notification icon, so let's select that guy. So let's see, the course is Android Async Programming and Services, Long running operations is the title, and Foreground Services can be tied to a notification icon. So it seems to me that's working well. Let's do one more just for luck. So the second up from the bottom says java_core, Compiler options, and then it says something about the jar option, so let's choose that. Now we see the course is Java Fundamentals: The Core Platform, Compiler options, and then the jar option isn't compatible with the -cp option. So there you go, we're now able to take an instance of our NoteInfo class, pass it as an extra on an intent from our NoteListActivity into our NoteActivity, and have the NoteActivity access it and display the content. In our next clip, let's see how using the new button feature on our NoteListActivity fits in with all the work we've done so far.

Handling New Note Creation
So let's go ahead now and hook up our new note behavior. Now to do that we're going to send an Intent, very much like we do when the user selects a note from the list, the key difference, of course, being is, we don't have any extra to attach to it, so we're just going to send the intent directly using startActivity. So let's go up here to our FloatingActionButtons code, let's delete out the code that was put in there by default, and then basically we just want to create an Intent and call startActivity. Often in situations like this where I know I'm not going to have any extras to add to the Intent, actually let's go ahead and create the new Intent right directly in the call to startActivity. And so there we have the call to startActivity, and we create the new Intent right there inside the startActivity call, passing in the this reference for the NoteListActivity, and then of course the class information. Alright, so that'll send the Intent that actually shows our NoteActivity, so now let's go over into our NoteActivity and set up our code there. Now here in our NoteActivity, we've got this method, readDisplayStateValues, and that's the one that actually gets the note from the extra. Well, in the case of the new note, we're not passing any extras, so the return value from that is going to be null, so our note will be null. So that'll be our indicator that we're creating a new note. So why don't we do this, after that let's go ahead and set a field called isNewNote that's a Boolean based on whether the note is null. Now if there's no note passed, isNewNote will be true, but if there is a note passed isNewNote will be false. We probably want this to be a field too, not a local variable, so let's go ahead and right-click on it. We'll choose Refactor, we'll go up to Extract, and we'll choose Field. And it says, how about the name of mIsNewNote, and I like that, so I'll just hit Tab. So now that is actually a field in my class. Let me just scroll up a little bit, and here in the onCreate method where we call dislayNote, we only want to display the note if there's actually a note, so what we'll do is we'll go ahead and put an if statement before this for if! mIsNewNote. So that takes care of that, and let's just go ahead and indent the line below it. And that should now give us our appropriate behavior. When we select a note we'll display that note. If it's a new note, meaning that there's no note passed, then we don't display the note. So let's go ahead and run this guy and see what it looks like. Here we are in the Emulator, and you see we have our floating action button down there at the bottom. Now it still has the default image of an envelope, and we'll leave that for now. A little bit later in the course series we'll change that over to a plus sign. But let's just see if our functionality works correctly. So let's go ahead and choose the floating action button, and that brings up our NoteActivity, and it's empty. There's no Note title, there's no Note text, and the Android program with Intents class is just the first one in the list, so that works correctly. So let's go back to our NoteListActivity, and let's just choose one of the notes in that. So I'll choose this third one here, Android Async, and it brings that one up correctly. So everything is working just like we want it to. When the user selects the New Note button we show an empty note screen, when they select a particular note, we show the note that they selected.

Summary
To wrap up, here are some of the key things you want to remember from this module. Remember that Android is component-oriented, and although there are a number of different types of components, activities are the most familiar type of component. And components cannot directly interact, so that's where intents come in, and components interact through intents. Now an intent describes an operation target, and it can pass additional information as what are called extras. Now when we're dealing with activities, we start an activity by passing an intent to the startActivity method, and an activity can get the intent that started it by calling the getIntent method. Remember that Intents can be sent cross-process, which means any extras on an intent must be cross-process friendly, and this presents a challenge for reference types. Reference types that are passed as intent extras must be Parcelable types. What that means is that they must implement the interface Parcelable, and by implementing that interface it allows the type to save its instance state to a Parcel. And remember that Parcelable types also have to have a CREATOR field, and that CREATOR field is how new instances of a type are created from a Parcel. In our next module, let's start looking at the activity lifecycle.

Taking a Deeper Look at Activity Interaction
Introduction
Welcome to the Taking a Deeper Look at Activity Interaction module of the Pluralsight course, Understanding Android App Basics. My name is Jim Wilson. In this module, we're going to look at how we can create more sophisticated applications by leveraging the interaction capabilities of activities. And to do that, we're first going to look at the application activity relationship, something called implicit intents that will allow us to actually launch activities based on characteristics, how do we use activities that return results, and how activities are organized in something called tasks. Okay, so let's get started.

Application Activity Relationship
As we've talked about, Android is a component-oriented platform, but of course those components run within a process. Now when programming Android, we don't think a whole lot about processes, we tend to think much more in terms of components, but there are some important aspects about process lifetime that we need to understand. Now process lifetime is driven by component lifetime. When the first component that a process will be responsible for is accessed, that process is started up, and that process will then terminate after the last component within it exits. Now processes are organized around applications. Basically, each application has its own process. And the components from that application run within that application's process. So what that means is that if two components from the same application are running at the same time, then we can rely on the fact that they're in the same process. But it's important that we understand that these processes will stop and start, so we can't rely on a given application process just running forever. To visualize how this all works, imagine that we have an application activity, and the user takes an action that causes that activity to need to be launched. Well, before the activity itself can be launched, I think of it as kind of like a ghost activity, it's an activity that's about to be launched, but it's not actually running yet, because before we can run it the process has to actually be started up, and Android takes care of doing that, and then once that process for the application is started up, then it goes ahead and creates the actual activity. If the application then launches another activity, that activity is running in that same process. If the first activity that was started exits, the process continues running, containing that second activity. Then even if a brand-new instance of the first activity is created, it's still going to be created in that same process, because the process hasn't exited yet. But then as those activities exit and there's no more components running, then the process itself will exit. But then if something occurs where one of the activities needs to be started again, again, we have this concept of what I think of as the ghost activity, it hasn't quite started yet, but the system knows it needs to be started, so the system will then go ahead and launch the process and then create that activity instance. And then from there other activities when the application is there created are now created in this process. And this cycle continues. Now understanding this is important, because it helps us design our applications effectively. Let's think about the application we're working on, where we have our NoteListActivity, and then it uses an intent to pass information over to the NoteActivity. Now we know that when we pass intent extras that are reference types, those types need to be parcelable so we can actually put them in the intent, and that behavior is important when intents are going to travel across process boundaries. But in our case, it didn't travel across process boundaries, we know this was all in our application. So let's think about how the NoteListActivity actually got access to a given note. Well, remember we have our DataManager class, and the NoteListActivity actually got that list of notes from the DataManager, and then with the user made a selection from the list there was a position involved. It then got that particular note, and then using Parcelable it put it into the intent, and it passed it over to our NoteActivity. Since our NoteActivity is in that same process, it can get access to that exact same DataManager. So rather than having to actually parcel the NoteInfo instance into the intent, we could have done something like simply pass the position through the intent, and then let the NoteActivity go out to the DataManager and get it. Now this doesn't mean that using Parcelable is always a bad idea. What it means is that there is a right time to use Parcelable, and there are other times where there are other solutions or simpler solutions. So now let's go to our application and let's implement all of this to actually take advantage of the fact that both our NoteListActivity and our NoteActivity are running in the same process.

Demo: Simplifying Activity Interaction Within the App
Here we are in Android Studio and we're looking at our NoteListActivity, and our application is in the exact state it was left in at the end of the last module. Now just as a reminder, the way we actually populated our NoteListActivity is we went out to the DataManager, got all the notes, and then we loaded that into an adapter which then populated our ListView. So then when a user makes a selection we get the position passed into us, and then using that position we get the actual NOTE_INFO, and that's what we put into the intent, in that used Parcelable. But now we know that if the NoteListActivity can access our DataManager, because remember it's a singleton, then the NoteActivity can also access that exact same instance, right, that's the power of singletons. There is one instance shared throughout the process. So why don't we go ahead and change our application now to take advantage of that fact. Now before we do that, one of the things I always like to do is that whenever I'm using naming for the extras, I like to use really meaningful names. So right now we actually name the extra NOTE_INFO because we're passing NOTE_INFO. So let's go ahead and change that to NOTE_POSITION. So what I'm going to do here is go over into our NoteActivity and up here at the top where we actually define the constant, the first thing I'm going to do is change the value from NOTE_INFO to NOTE_POSITION. And once I do that, I'll go ahead and change the name of the constant itself. Now I could just go over here and just edit it and change it, but then I have to change it everywhere it's used, so what I want to do instead is I want to refactor it. So I'll right-click on it, I'm going to choose Refactor, and then I'll choose Rename. And basically I'll just change it from NOTE_INFO TO NOTE_POSITION, and then once I do that I'll hit Tab. And then by doing that anywhere I used it, NOTE_INFO is changed to NOTE_POSITION. So if I scroll down here a little bit where I get the intent Extra it now says NOTE_POSITION, and if I jump back over here to NoteListActivity it also says NOTE_POSITION, so refactoring just made that job easier for me. So now what I want to do is change here where I actually set the Extra to instead of passing the note in is to change it to pass the position in. Now once I do that, I don't need to even get the NOTE_INFO back anymore, so I'm going to actually do Ctrl+/ to comment that line out. So now when someone makes a selection from our list, the position is passed into us, we simply put it into the intent Extra, and then send that intent to start the other activity. So now if we go over here to our NoteActivity, and we look at the code here where we actually get the note back, let me just scroll down a little bit so we can see that better, right now we'll still saying getParcelableExtra. But our position was actually an integer, so what I want to do here is change getParcelableExtra to getIntExtra. Now getIntExtra actually returns an int, not an actual note, so what I want to do is of course change this variable from the note field to a local integer variable. Now notice the call to getIntExtra actually has a red underline there, and it's telling me there's something wrong. And if I go ahead and hover over this, basically it's saying that our signature doesn't match. What happens is that when we have extras that are not referenced types, right, they're value types, we have to provide two parameters, because the issue is that when we have a getExtra that is a reference type, well if there's no value there it can just return null. But value types don't have a concept of null, so what we have to do is give this a second argument, which is what do you want to return if there's no Extra here by that name. And usually for things like this I just use -1 to indicate that the Extra wasn't actually actually found in the intent. Basically now our local variable position will have whatever was passed in the intent Extra if it exists, otherwise, it'll have -1. But if we think about this, putting literals in is what we often call magic values, that -1 has some magic meaning, is generally a bad idea. We want to use named constants. So let's go up here and let's right-click on this guy, and let's choose Refactor and Extract, and let's choose Constant. Again, we could have used Ctrl+Alt+C as a shortcut. And when we do that, it says, okay, well what expression do you want, do you want 1or -1? I'm going to choose -1, I'll select that, and it says, okay, well what do you want its name to be? And I'm actually going to have to set the name to be POSITION_NOT_SET, and so that's showing me that I make that a public static final int, POSITION_NOT_SET, and I like that, so I'll hit Tab, So now I have a constant position that's set, which is our -1, and that's the value the position will have if that intent Extra isn't set. Now with that being the case, what I want to do here is that my field, mIsNewNote, instead of checking mNote for null, what it should do instead is check to see if position = POSITION_NOT_SET. So now what I can do is I can check to see, well, if it's not a new note, then I know I can go get a note with that position. so let's start with our if(! mIsNewNote), and then what I'll do is I'll say that mNote =, and then I'll go out and get my DataManager instance, and then I'll say getNotes, and then I want to get the one at that position, and that should do it. Is that now I get the position from the intent Extra, I go ahead and check and make sure that it was actually set. As long as it was, I now just reach out to our DataManager and get the note at that position and put it into my field. Alright, so let's go ahead and run this guy, and we'll run it in the Debugger. But why don't we do this this time. Let me go ahead and put a breakpoint here, and I can do that by just clicking in the gray area here off to the left, and we'll talk much more about things like the Debugger and other aspects of the tools in our next course, but for now we'll just start simply setting that breakpoint and go up here and click on the button that actually launches me in the Debugger, choose my Emulator. So here we are in the Debugger, so I'm going to go up here and just select the first one. You can see in the background here the Android Studio stopped us in the Debugger, so let's go ahead in there. And you notice we're stopped at the line just after we set the position, if I hover over position. It says the position is a value of 0, and that's right because it's a 0-based list. So if I have that there, let me go ahead and step through the next one, so I'll just step. Now my mIsNewNote is false, which means it's not a NewNote, which means we can just go out here now and just go to the DataManager and get our note. I'll go ahead and let it run from here then. It shows the note that we selected, the 0-based note. Alright, so there we have the exact same functionality we had before, but now we're doing it much more simply because now we understand that both activities are running in the same process. So in our next clip we're going to look a little more closely at this idea of activity lifecycles.

Late-binding Activities
As we've talked about, intents describe a desired operation, and one of the key things we do in that is identify the operation target. Now up until now we've been using what's referred to as an explicit intent, which means that our target is explicitly identified. In other words, we are providing the specific activity class we wanted to be the target of that intent. There's another kind of intent known as an implicit intent, and in that case the target is implied, and it's implied based on a set of characteristics. What implicit intents do for us is they provide late binding, in other words the specific activity we're going after is not determined until runtime. So, basically, we provide these characteristics, and the system then finds the best match. Now it often comes from another app, so it actually allows us to build after leverage capabilities provided by other apps, using something like maybe Gmail to send a mail message, or the contact activity to actually get contact information, that sort of thing. Now the specific match for a given implied intent may actually vary depending upon what the user has installed in their device. So if I send an intent targeting a mail system, well if I've got Gmail set as my mail, then it may match that. If I use Outlook instead, then for another user that same exact implicit intent may match up to Outlook. And in cases where there's a tie, in other words more than one component can actually meet the characteristic, then in that case it actually prompts the user. What implicit intents do for us is that they decouple senders and receivers. Very often the sender may not know who the receiver for an implicit intent is going to be, it just knows it fulfills certain characteristics, and in the same way a receiver may have no knowledge at all about a sender. it just knows it's got an intent that matches its own characteristics. So there are four available characteristics for intents, and the first one is what's called action. That's just a string that identifies some kind of action, and there are many standard constants available to identify actions, and applications can also define their own. For example, the intent class has an action, ACTION_VIEW, which identifies the view action, and we'll see examples of how to use these characteristics a little bit later. Now the action is commonly set in the intent constructor. There is a set action method on intent, but most commonly we just use a constructor. An action is the only required characteristic of an implicit intent. Now another characteristic is what we call category. Category provides some kind of extended qualification over that intent. Now normally we don't specify categories as the senders of an intent. Categories are much more important to components that are receivers of implicit intents. Then we have the data characteristic. The data characteristic provides the URI of the data to be acted upon. A very simple example is something like https://Pluralsight. com, and there are other URIs for contact data, that sort of thing. And you set the data with the setData method of the Intent class. Now when you specify data, you may often have to provide the mime type, in other words, you need to identify what kind of data is being associated with that URI. And it uses a lot of the common mime types, as well as application-specific mime types. for example, something like text/html, which would identify the html text mime type. You set the mime type with the Intent class's setType method. It's important to understand that sometimes you may have a data characteristic without a mime type, or you might have a mime type characteristic without a data characteristic, but anytime you have both a data characteristic and a mime type, you need to set both of them together. So there's a method called setDataAndType, because if you use setType and setData separately, they'll cancel each other out. So anytime you're setting both the mime type and the data, be sure to use the setDataAndType method. Now to see some examples of implicit characteristics, check out that URL that we currently have on screen, and you'll see a whole bunch of examples of the commonly used implicit intent characteristics.

Implicit Intents
To get a better understanding of how implicit intents work, let's think about how it would work in our application. Now we know that our application shows up on the launcher screen, so when the user chooses it from the launcher we get the intent, and it goes ahead and starts up our application, and then goes into our NoteListActivity. Our NoteListActivity then creates an explicit intent identifying that we want to launch our NoteActivity. So when we send that, it goes ahead and starts our NoteActivity. Well let's say now we want to add capability to our application to allow the user to send an email containing that note to another user. Well, in that case we would need an implicit intent, so what we would do then is create an Intent that describes eh characteristic required to send an email, we would go ahead and call the startActivity with that implicit Intent. The system would then ensure that the appropriate process for the email application was running, and then it would start the activity to handle that implicit intent, and then it would present that activity to the user. So conceptually that's what happens. Remember that our application has something called the AndroidManifest, and the AndroidManifest identified the components in our application. As you remember, our NoteListActivity has an Intent filter that identifies that we want that on the launcher. In other words, that intent filter identified characteristics of that NoteListActivity, one of which is to actually appear on the launcher screen. Well, all applications have an AndroidManifest file, so something like the Gmail application would identify which of its activities should appear on the launcher, and it would also identify that it has an activity that has the characteristics to handle an implicit intent to send an email message. So what happens then is as Android applications are installed onto the system, each of these manifests get loaded up into the Android system. So what ends up happening then is that the Android system has all this manifest information about all the components that have been installed onto a particular device. So, again, in the case of our application, since our NoteListActivity actually has an icon on the launcher screen, when the user chooses that, it sends the Intent, the system makes sure our process is running, our NoteListActivity is started. We then send our explicit intent to start our NoteActivity, but now when the NoteActivity creates an implicit intent identifying that it wants to send an email message, that's actually routed into the Android system. The Android System looks through all that manifest information, identifies who the receiver of that Intent should be, makes sure that process is running, and then routes the intent into the appropriate activity to handle that request. So in our next clip, let's go ahead and implement this behavior in code, add the ability to email a note to someone.

Demo: Adding Email to Our App with an Implicit Intent
Here we are in Android Studio, and we're looking at the designer for the menu that appears on our NoteActivity. Now we're going to talk a whole bunch about menus a little bit later in the course series, but right now we'll just focus on adding a simple menu option. Now this menu resource is located, if you look in the Project window, under resource, under menu, and its name is menu_note. Now by default the activity was created with a menu option marked as Settings. So let's go ahead and change that. So I'm going to go over here and click on that, and when I do you'll notice the Properties window comes up and notice that Menus have an id, because the default one has an id of action_settings, and let's change that to action_send_mail. And for the title, let's just change that to say, Send as email, and that's all we need to do here for right now. So let's head over to our NoteActivity, and in the NoteActivity there's a method called onOptionsItemSelected, and this is the method that gets called each time a user selects a menu option. So you notice there's an if statement there checking for an id of action_settings, let's change that to action_send_mail. And then inside the body of that if let's call a method we're going to write called sendEmail. And we've got our red light bulb there so it can get created for us, so I'll go ahead and choose that. And we'll accept the return to void, so I'll just hit Tab. Now what we want to do in this sendEmail is obviously we want to send an email, and we're going to use an implicit intent to do that. Now what the email should contain is, I would say, maybe a subject, which is the title of our note, and then a body message that talks about what course our note comes from, and then the note itself. Now what we need to do to do all that is get the value of the course, the subject, and the text, from the screen. We don't want to use the note reference itself inside of our class, because maybe the user has changed the information on the screen and we haven't saved that into the note. Now we know that we already get references to the views on our NoteActivity up in our onCreate method, so let's scroll up there for a second. So here in our onCreate method we've got a reference for the Spinner, and two references, one for each of the EditTexts. Now these, of course, are local variables. One thing we could do is copy the code to get these references down into our new method, but maybe it makes sense now to go ahead and promote these up to class fields, because we're obviously using them in more than one place. So we can go ahead and promote these just like we did earlier, right-click, choose Refactor, Extract, and then Field. Then it says mSpinnerCourses, and I like that, so I'll hit Tab, and then we'll do the same thing for both of the EditTexts as well. Now we have mSpinnerCourses as a field referencing our Spinner, mTextNoteTitle and mTextNoteText getting each of our EditTexts. Let's scroll back down now to our new method. Now we know of course that we need the course information so let's go ahead and get back the selected item from our Spinner and store it in a local variable called course. So now let's go ahead and set up the subject of our email. So we'll create a local variable, type string, named subject, and we'll assign that back the value of our EditText for our noteTitle. So we call the getText method, but that doesn't actually return a string, it actually returns something called an editable, but we just want its string value, so we'll just call ToString against that. So our NoteTitle is now going to be the subject of our email, and now we want to go ahead and give our email a body. So I'll declare a local variable here called text of type String, and let's say we want the text of our email to something like check out what I learned in the Pluralsight course, give the name of the course, and then provide our actual note content. So first thing we'll do is assign the literal string, Check out what I learned in the Pluralsight course, and let's say we want to go ahead and quote the name of the course, we'll just do a backslash quote so that appears inside our string. And then what we'll do is concatenate the course title into the string, so let's just put a plus sign. And we'll just say course. getTitle, and then we'll concatenate onto the end of that another quote and then a new line. And then let's concatenate onto that the actual text from our note. And so now the body message for our email is check out what I learned in the Pluralsight course, the quoted name of the course, a new line, and then whatever our note actually is. So that gives us all the information we need to send the email, so now we can start creating the intent to do the sending. So let me just scroll down a little bit here so we can see a little better. So what I'll do now is go ahead and create a local variable named Intent of type Intent. Then I'll create a new Intent that I assign to this variable. When I create this Intent, since it's going to be an implicit Intent, I'll go ahead and provide the action. So now the action associated with sending an email is Intent. action_send. So that identifies we want to create this Intent and associate with it the ACTION_SEND. Now it's important to understand that actions don't necessarily have a one-to-one correspondence to a particular component. You often need multiple characteristic to do that, there are different kinds of things we could send. So in order to provide the characteristic that says I want to send an email, I'm going to associate a type with this intent. So what I'm going to do is associate the type message/rfc2822. Now you might be looking at that going, what the heck is that, and basically message/rfc2822 is just a mime type for email messages, it's just a standard internet mime type. You can also support things like text/html for sending email, and there are some others as well, and these are all documented, particularly if you check out that URL I gave you earlier about common intents. So now that identifies our target. What I want is a component that handles the ACTION_SEND for that mime type. So now I've got to put the extras in there. Now one of the available extras is the email address, so I could actually provide an email address here as the extra. But what I'll do is I'll let the user type the email address into the email when they actually look at that screen. What I want to do is just provide a subject and the body. So now for the subject I'm going to provide an extra called Intent. EXTRA_SUBJECT. So that provides the extra, called the EXTRA_SUBJECT, with the value I have for subject, which in our case is our noteTitle. And then we're going to provide an extra called EXTRA_TEXT, and this will be the body of our email. With that now my intent is fully created. The only thing left to do is to call startActivity and pass in that intent. So notice there that whether we're sending an implicit intent as we are here, or an explicit intent as we did earlier, we still just call startActivity. It's the Intent itself that makes the differences. Let's go ahead and run this now, and see how it behaves when we select that Send as email option from our NoteActivity. Here we are inside of our application, so let's go ahead and just choose one of our Notes. That brings up our NoteActivity. Let's go over here to the Menu options, and we'll see our menu option Send as email, and let's go ahead and choose that. And you'll notice that when I chose it, it gave me the option of using Gmail or I could actually use a Goggle Drive because they both understand this idea of a action called send for that mime type. I'm going to go ahead and use Gmail, so I'll choose JUST ONCE, and you notice right there the user is inside of the Gmail Send an Email screen, let me just get this keyword out of the way, but you notice that we've got our dynamic intent resolution as the subject, that was the title of our note, the body of the email, Check out what I learned in the Pluralsight course 'Android Programming with Intents", Wow, intents allow components to be resolved at runtime. So all that worked, and it even put the cursor in the email address field and even had the keyboard open so the user could just start typing the email and send it, and so if we send it from here it'll go ahead and send that email. Now, again, we've actually left our application's process, but from the users perspective, this is a continuation of our application. They chose an option from our application that took them right into this email screen. So what these implicit intents are allowing us to do is lace together components on the system to provide very rich behavior within our applications. And again, what you need here too is that, in my case I'm using Gmail. If another person preferred Outlook as their email, well Outlook could handle that same Intent as well, and that would allow them to send an email through the UI they're familiar with. Alright now if I go ahead and choose Back button here, notice it takes me right back into my application, so it's a very, very consistent continuous experience for the user. That takes care of adding send email behavior to our application. In our next clip, let's see how they interact with activities that return results.

Activities with Results
As we've seen, our applications can leverage activities from other applications to provide features within the experience of our own application. Well, some of those activities can actually return results. For example, we can leverage a camera activity, and that'll present a camera functionality to the user that will save the picture into a file, but can return a thumbnail directly back to our activity or the contact activity. We can present the standard contact activity to the user, and when the user makes a selection that selection is passed back into our application. And there are many other examples of activities that can return results. When we start an activity that's going to return a result, we start it differently than other activities. Rather than calling startActivity, we call startActivityForResult. Now startActivityForResult has two parameters. The first one is an Intent, and it's an Intent just like we would pass the startActivity, and the second parameter is just an integer identifier. And that's really just a way to differentiate calls within your application because your application may call startActivity for result for one purpose at one point, and startActivityForResult for a different purpose at a different point, and as those results coma back in, you want to be able to tell them apart. When we start an activity expecting a result, the way we get those results back is by a call being made back into our activity. The Activity class has a method called onActivityResult. And when you've called startActivityForResult, when that other activity completes and passes back those results, those results are passed into your activity's onActivityResult method. And we get back three parameters in onActivityResult. Now the first one is our integer identifier, in other words, whatever integer we passed to startActivityForResult is then passed back into our onActivityResult to tell us what those results are, where those results are coming from. Then there's a result code to basically just tell us how it went. So what we want to do is look for a result code that matches the constant, RESULT_OK, and that means the thing succeeded. And then the last parameter is an Intent, and that Intent that's passed into onActivityResult, contains the results from the other activity. So now in our next clip, let's walk through an example of using startActivityForResult.

Activity with Result Example
To see what it's like working with startActivityForResult, let's walk through an example, and let's use the camera example. So the camera activity takes care of presenting the camera user interface to the user, gives them the features that it provides. When the user takes a picture, the full quality image is saved into a file, and then a thumbnail of that image is passed directly back to our activity so we can present that thumbnail to the user if we want to. To start the activity, we of course need an Intent, and that Intent will have an action, and the action that acts as the camera activity is in the class MediaStore, and it's ACTION_IMAGE_CAPTURE. The Camera activity is an activity that only needs an action, that's the only characteristic it needs, but it does require an Extra, and that Extra's name is in the MediaStore class as well, and it's EXTRA_OUTPUT, and it's the file that we want to save the full quality image to. So we basically say that I want to take a picture, and here's where I want the full quality image to go into, and that's passed as a URI. So let's see that in code now. So say I have an Activity class called MyActivity, and I'm going to have a method in it called showCamera, and it accepts the Uri of the file in which I want to save the full quality image. So what I'm going to do now is go ahead and create an Intent, but I'm creating the Intent with just an action, the ACTION_IMAGE_CAPTURE, and I'm putting the Extra in. So the Extra is that EXTRA_OUTPUT and it's the URI of the file I want the full quality image to go into. Now remember, before I call startActivityForResult, I want an integer identifier so I can identify what results are coming back. So I've just defined a constant here called SHOW_CAMERA, and I've given it the value of 1. And the idea here is that whenever you call startActivityForResult, each unique purpose for which you call startActivityForResult said to use a different integer identifier. So then we'll call startActivityForResult, passing in our Intent, and then that integer identifier. So from the user experience now, once I do this, the user is now looking at the camera. The user can use the camera as they always do, and it can be the built-in camera, or if they've added a camera app that has an activity that supports the characteristic ACTION_IMAGE_CAPTURE, it could be that camera instead. Once the user actually takes the picture, we want to go ahead and get our results back. So what's going to happen now is that when the result come back it's going to be in our onActivityResult method. The first thing we want to do is check the request code to make sure it's SHOW_CAMERA, and that tells us that these are the results for our request. We then want to check the result code for RESULT_OK. That indicates that it succeeded, if it failed, that would not be a result code. And that tells us that that full quality image is going into the file that we passed. And if we want the thumbnail, we can then retrieve the thumbnail back from the result, so it's going to be stored in the Intent as a bitmap that's passed into our onActivityResult method, and it happens to have a name in that Intent called "Data". So to see accessing our results in code. We're still in our MyActivity class, where we're going to override the method onActivityResult, and remember it receives those three parameters. Our class still has that constant in it for SHOW_CAMERA. The first thing we're going to do in onActivityResult is first check that the requestCode matches SHOW_CAMERA, in other words, onActivityResult is being called with our results, and then we check the result code to make sure it actually succeeded, And then once we know it succeeded, we can actually go to the passed in result Intent, access the Extra in the Intent called "data", and that will give us back the thumbnail bitmap, and then we can do whatever we want to with the thumbnail bitmap. And if we want the full quality image, we can go out and read the file that we passed when we initially called startActivityForResult. If you want to see all this information documented that we just walked through, just check out that URL I have on screen, this is the same one I showed you earlier, that just shows some of the common Intents that we often use in our applications. Right now in our next clip let's look at how Android manages activity lifetimes as we move from one activity to the next.

Application Experience and Tasks
As we've looked at all these different ways we can interact with activities, something has become very clear. Generally, our application experience is going to be composed of multiple activities. Now most of those activities will probably come from our own apps, but as we saw with using email, other activities may come from other apps. So that presents an interesting challenge, because Android needs to manage this flow that could potentially cross applications somehow, and what does that are what are called tasks. So, of course, the question then becomes, well, what is a task? So, again, let's look at what the documentation has to say. The documentation says that a task is a collection of activities that users interact with when performing a certain job. Now that may sound kind of vague, but honestly, that's probably the most accurate definition. It's just that there's some series of activities that tie together somehow to provide an application experience, and that's what a task is. So if we look at how a task actually does its job, basically, a task is managed as a stack, and we commonly refer to it as the back stack. So as we're launching activities within our application experience, these activities are being added to the task. Well, then when the user hits the back button it then removes an activity from the task, and as we hit the back button to remove an activity from a task, that actually destroys the activity. So to look at this visually, say we have our launcher screen and we're going to use it to launch our application. That launcher screen is part of the task, when the user selects our icon for our application it sends the Intent, and we know of course that Intent then takes care of making sure the process is running, it starts our activity, and then our activity is added to that task. So in the case of our NoteListActivity, when the user selects a note from the list, we know our NoteListActivity sends an intent which started our NoteActivity, and that adds our NoteActivity to that same task. And then when the user wants to send an email we know we send an Intent, the system makes sure the email process is running, started the email activity, and that activity was added to the task. So collectively now the system is managing this whole flow of interaction within this task. So then what happens? Well, if a user then hits the back button, it means they want to leave that activity, the system takes care of cleaning up that activity, removes it from the task, the system of course will manage the process lifetime. Now if they're back into our NoteActivity, the user hits the back button, our activity is cleaned up, it's removed from the task, and then we get back to our NoteListActivity. And, again, if the user hits the back button, our activity gets cleaned up, it's no longer in the task, of course, our process is cleaned up, and this continues on all the way back to our starting point. We're going to look a little more closely at this idea of activity lifetime within a task a little bit later in this module, but there's one initial thing that comes up. Now if the user is using the back button to leave each of their activities, well, what happens when it comes to managing our persistent state? Now what we mean by that is things like, in our application, what happens to dealing with changes a user might make to a note, because if you use Android apps much, you know that you generally don't use something like a Save option. Instead, what Android tends to use is what we call an edit-in-place model. In other words, changes are saved with no special action. So how are changes saved? Well, basically we write to our backing store whenever we're leaving the activity, often that's the back button. So what we do is we handle a particular method in the activity class called onPause, So that's when we actually write into our backing store. So in our app, that's when we would write changes the user has made to the note, into our note instance. But what about the case of a brand-new entry, like in the case of the user creating a new note? In general, the way we handle that in Android is that rather than waiting until it's time to save the change to write the backing store, we actually create the backing entry right away. So, generally, what we do is that in the case of creating a new note, we would go ahead and create that note in our activity's onCreate method. So in our next clip, let's start implementing this behavior of saving changes within our application.

Demo: Implementing Edit-in-Place for Note Changes
Here we are in Android Studio, and we're looking at our NoteActivity code, and we want to implement the behavior so that our activity saves any changes to the note when the user leaves the note. And as we mentioned, the onPause method of our activity will get called when the user is leaving the note, so what we need to do is override that. So what I'm going to do is go over here to my Code menu, I'm going to choose Override Methods, and you see that shows me a list of the methods that are available to override. So I'm just going to start typing onPause, and you see it went ahead and highlighted onPause for me there, so I'm going to say OK. And it goes ahead and stubs it out for me and calls the base class implementation. And remember, the thing I want to do in here is I want to go ahead and just save my note. So I want to call my method called saveNote, so of course I haven't implemented that yet. Now I can click on the light bulb and implement it, but what I'm going to do instead is use the keyboard shortcut Alt+Enter. I want to create the method, so I'm going to hit Enter, so that goes ahead and puts it in place, and I'll hit Tab and say I want to accept that return value. Now all I want to do is go through and set each of the values in the note I have a reference to. So what I'll do is set the value of the course in the note to whatever the currently selected course is in the Spinner. So we're simply passing the result of getting the selected item directly to the setCourse method on our note, and similarly we're going to go ahead and just get the value of each of the text fields and set the Title and the Text on the note. And then easily now we're saving our note. When the user moves away from the activity, onPause will automatically be called, onPause calls saveNote, which then takes all the values from the fields on the screen and puts them into our note. Now the other thing we want to do is handle the newNote case. Remember that following the Android style of programming, what we want to do is create the backing store for that new note as soon as our activity starts up. And we're just going to go over here to our method, readDisplayStateValues, and remember that readDisplayStateValues is called from our onCreate method, and what it does currently is it gets the Intent Extra for the NOTE_POSITION that needs to be displayed, and as long as it's not a new note it actually gets that note and loads that into the note reference. So this is a great place for us here to actually handle the case of a brand-new note being created. So what I'm going to do here is take the if statement where it currently says if(! IsNewNote) and change that to if(IsNewNote), and I'm going to go ahead and put brackets there. and I'm going to take the case where we actually assign the note from the Extra, the else side of my if. so if it's not a new note, we'll do just like we did before, get the note information directly from the DataManager, but if it is a newNote what we need to do is create that new note. So we want to have a method here, createNewNote. Of course, that method doesn't exist yet, so I'll do Alt+Enter, and then hit Enter to go ahead and create it, Tab to accept the result type. So now in order to create a NewNote I'm going to need a reference to the DataManager, and I'm going to have to do a couple things with the DataManager, so I'm going to go ahead and create a local variable called dm as a reference to our DataManager. So we've got a reference to the DataManager, and DataManager has a method on it, createNewNote, so let's go ahead and call that. Now createNewNote creates that NewNote, but I'm not sure what the return type is. So I'm going to go over here to the yellow light bulb, click on that, and notice that one of them is Introduce local variable, so I'm going to choose that. So it goes ahead and looks at the return type, and it actually says that, okay, it returns an int, so I'm going to create a local variable of type int. What I want to do is I want to call this variable notePosition. So now I'm taking that return value, which is an integer, and assigning it to the local variable, notePosition. What that tells me is what is the position of the newly created note. Now as I think about this is I probably want that as a field, not a variable. So what I'll do is I'll go over here, and we know that we can actually extract this with refactoring as a field. I'll use the keyboard shortcut, Ctrl+Alt+F, and I'll go ahead and accept that name, mNotePosition. So now we've assigned that into a field. So now I've got that position of the note, so now I can go out and get the note at that position and assign it to my field, mNote. And now you notice here where I actually get the NotePosition. Now my variable that I'm passing to the get method is in red. Now mNotePosition, now that's spelled right, so there must be some kind of problem. So now if you look here at where I actually initially assigned the mNotePosition from createNewNote I've actually spelled it wrong, I've left out the i. But you know what, we can fix that easily enough with Android Studio's Refactor. What I'm going to do here is right-click, choose Refactor, and I'll choose Rename, and then what I'll do is I'll go back here and just put that i in that I missed, and now I went ahead and renamed it, so now it's named correctly, and the places I referenced it are correct as well. So let's get ready to test this out, so let's put some breakpoints in there. So I'm going to put a breakpoint right here after I create the NewNote, and I'm also going to scroll up to my saveNote method and put a breakpoint in there. So let's go ahead and run this guy. Okay, so here we are inside the emulator, so let's go ahead and pick the first note. And notice if we look at the note, the current title, of course, is Dynamic intent resolution, and we can see there's a note body, Wow, intents allow components to be resolved at runtime. So let's go in here and let's add some text to this. So we've added the text How Cool! to that. So let's go ahead and use the back button now to exit out of here. So hit it once to bring the keyboard down, let's hit it again. And notice that we stopped inside of Android Studio, and it's inside of our saveNote method, so that means it's going to go ahead and save it for us. So let's let this guy pick up and continue running. So now let's go ahead and select the note again. And our text change, How Cool!, now appears with the note, so that part worked. So let's go back to the main screen, and of course when we exit here it wants to save, so we'll go back to Android Studio and release it. Alright, so let's try clicking that newNote button now. When I click that, you can see we stopped in the Android Studio Debugger, go back there. Notice we've got our NotePosition, and our NotePosition is 8, so it's actually created a new note, so I'm going to let it release here. And there we have our Edit Note screen for the new note. Now one thing I'll mention is that if we actually hit the back button right now, we would actually run into an error. Not because it can't save the note, but it's actually going to run into an issue on the Note List screen. And we'll talk about what that issue is a little bit later in this module. Before we do that, let's look at one other issue. The way we've got the program written right now, when the user leaves the activity, we automatically save the note, well what if they didn't want to save the changes they had made, so in our next clip, let's add the ability to cancel out of the activity without saving changes.

Demo: Implementing Note Change Cancellation
So now we want to add the ability for a user to leave the activity without saving changes, and we'll do that using a menu. So I'm here in Android Studio, I'm looking at our NoteActivity menu, and again, that's under resources under menu, and its name is menu_note, and all I'm going to do here is up in our palette I'm going to grab Menu Item and drag it onto our menu, we drag it there. I'm going to give it a title of Cancel, and I'll give it an id of action_cancel, so that takes care of adding my menu item. So let's go back to our NoteActivity, and remember we mentioned earlier that when a user selects a menu item the method onOptionsItemSelected gets called and notice we've already got our if statement there for the menu item id of action_send_mail. What we want to do here is add an else if here for our new action_cancel. So we've got that in place, let's put some squiggly brackets so we can write the body. So now what we'll do here is we'll go ahead and just set a flag to say that we're canceling. So I want to create a local Boolean variable called isCanceling and set it to true. So now let's go ahead and promote that up to a field, so I'll select it and hit the hotkey. We'll accept that name mIsCancelling, I'll hit Tab. So that sets the flag. So now when the user is cancelling, what we want to do is go ahead and exit the activity. So there's a method called Finish, and when an activity calls Finish it basically signals that it should actually end. So let's go ahead and call Finish. So now when the user selects that menu option, our activity will exit and will return back to the previous activity. So in the case of our NoteActivity, they will return back to the NoteListActivity. Now as part of this exiting process, our onPause method will get called, and remember, that's where we save our notes. So let's scroll up to our onPause method. So here we are in our onPause method, so let's put an if statement in there to check and see that if we're cancelling. So if we are cancelling, we're going to want to do something, and we'll see what that is in just a moment, but we know if we're not cancelling we want to go ahead and save our note, so we'll make that the else side. Okay, so if we're not cancelling we save our note just as we were before, but what do I do if we are cancelling? Well, remember that when we created a new note, we automatically created the backing store for it, but now we would have an empty note if the user cancels out in the process of creating a new note. So what we want to do is remove the note that we created from our backing store if the user is canceling out after selecting NewNote. So what we'll do here is inside of our IsCancelling, I'm going to go to the DataManager and get the instance, and the DataManager has a method called removeNote that accepts the position we want to remove. And remember, we stored the position of our new note in our field mNotePosition, so we'll call removeNote with mNotePosition. So now we've handled a case of removing the note if it is a NewNote, but there's an interesting thing we haven't done yet. We're saying we want to remove the NewNote every time we're cancelling. Remember, we only want to remove the NewNote when we're cancelling if we've actually created a newNote. So what we actually want to do is make sure we wrap this removeNote in an if(isNewNote). So we'll just put that if in as well, and so there now we have our completed behavior. If we're not cancelling, we'll save our note, but if we are cancelling and we're in the process of creating a NewNote, then only in that case do we remove the NewNote. So let's go ahead and test this out, so we'll put a breakpoint here where we actually check to see if we're cancelling, and let's go ahead and run it. So here we are in the Emulator, let's go ahead and pick our first note. Now it has our original note in it, Wow, intents allow components to be resolved at runtime. Now remember that our application currently doesn't have any permanent storage, so each time we run the app we start out with the same data each time. That's why the change we made earlier is not there. We'll take later in the course series how to make these changes persistent between _____ and executions So let's put some information here at the end. So we've added some text, Run Run, but let's go ahead and cancel it now. So we'll go to our menu, we'll choose Cancel. We're in our onPause, Cancelling is true, so let's go ahead and step through that, so we'll step. Okay, cancelling is true, but IsNewNote is false, so we just exit out of here, so let's let it run. So now let's go ahead and select that first one. And our change didn't stick, so that worked correctly, so let's go ahead and exit out of here. Release it from the Debugger. So now let's go ahead and click our new note. So we'll choose new note, and let's go ahead and cancel out of here. So we choose the Menu, Cancel, stop in the debugger. So now IsCancelling is true, so let's go ahead and step. IsNewNote is true, so we'll then go ahead and remove that newly created note that was created when the user entered into our activity. And there we have it, our application now allows us to save our changes when the user leaves the screen, but also gives the option of canceling those changes if they don't want to save them.

Summary
To wrap up, here are some of the key things you want to remember form this module. First, as we saw, application components run in the same process, as long as they're simultaneously active. So knowing that fact allows us to simplify their interaction. Now the kind of intents we were using previously were what were called explicit intents, where we actually identified an explicit target type. As we've seen, Android also supports what are called implicit intents, where we identify the target based on its characteristics. In that case, the system finds the best match, and in fact, the specific match may vary depending on what apps a user has installed on their device. As we saw, some activity types can return results, and in those cases, we use startActivityForResult to launch the activity, and then we get the results back in our onActivityResult method. And then we talked about activity tasks. An activity task is a collection of activities to perform a job. Basically, they're our back stack. As we create new activities they're added to the task, as we hit the back button they're taken off of the task. And as we saw, this activity task can actually create continuity for the user because activities can come from our application directly, or they can come from other applications that we're leveraging, and the task creates that continuity of experience. Remember, when we deal with persistent state we use an edit-in-place model, and that means that we actually write to our backing store when the user leaves the activity, and new entries are created right away. But the content for this new entry is saved into the backing store when the user leaves the activity, just as it has done with existing entries. In our next module, we'll look at the activity lifecycle and activity state management.

Understanding Activity Lifecycle
Introduction
Welcome to the Understanding Activity Lifecycle module of the Pluralsight course, Understanding Android App Basics. My name is Jim Wilson. In this module, we're going to start out looking at the Activity lifecycle, which are the phases of existence that Activities go through from creation, to their trip to being in the foreground, and then eventually being destroyed. We'll then take a look at the methods that we use to appropriately handle each of these lifecycle phases. And then finally we'll go to Activity State Management. As we'll see, Activities can often be destroyed and recreated, and we have to manage Activity instance state throughout that process. Alright, so let's get started.

Activity Lifecycle
Let's take a closer look at the Activity lifecycle, and as with pretty much any lifecycle, part of the life of an Activity is its death, or what we'll call its destruction. Now there are a few common causes of an Activity's destruction. Now as we've talked about, leaving an Activity with the back button can cause it to be destroyed. As we saw in the last demo, calling the finish method causes an Activity to be destroyed, and there's also system initiated destruction. Now when we look at system initiated destruction, generally that occurs to reclaim resources. So if an Activity has been in the background for a prolonged period of time, the system may choose to go ahead and destroy it so it can clean it up, or if the system is experiencing resource pressure. If the currently visible Activity needs more resources, the system may choose to kill one of the Activities in the background to reclaim resources. So let's see what this looks like graphically. So this is the same model we've been walking through throughout this module. So we know that when the user launches our application it sends an intent, the system will make sure our process is running, our Activity gets created, and that Activity is added to the task. So in our application, that's our new list activity, so when the user chooses a note, we know we send an intent, that creates our Note Activity, and that Note Activity is also added to the task. Up until now, we've always kind of assumed that that Note List Activity always stayed alive in the background, and often it does, but not always. The system may choose to go ahead and destroy that Note List Activity. Now notice the Activity itself is gone, but its place in the back stack remains, so the system is fully aware of the need for that Note List Activity. So what happens now is that when the user hits the back button, the system says, oh, they've gone back to that Note List Activity, the one I destroyed, let's go ahead and initiate its creation, so the Activity comes back, and then the user is passed back to it normally. And if we do things correctly, the user has no idea that that Note List Activity is gone. Now let's take this a little further. Let's say our Note List Activity sends the intent to our Note Activity, again, our Note Activity is added to the task, so now the user chooses the option or application to send an email. Alright, so we send an Intent, the system makes sure that the mail process is running, it creates that Activity, and that Activity is also added to the task. So now as the system is managing resources, it may choose to kill the Note List Activity, it might even choose to kill the Note Activity, which may ultimately result in the process being gone, so our entire application process is now gone. So what happens now, the user hits the back button, the system then says, oh, I need that Activity back that they're heading back to, it takes care of making sure the process is running, recreates our Note Activity, and then takes the user back again. And then, of course, the user hits the back button again, we recreate the Note List Activity, and they proceed back. So the important thing to understand here is that this shows us that with Android, the actual instance of an Activity may be destroyed with a new instance of the Activity being created. This means that we're responsible to code our Activities so that the state of the destroyed instance of the Activity can be restored into a new instance of that Activity. In our next clip, we'll look at the Activity lifecycle methods and see how they fit into our Activity state management.

Activity Lifecycle Methods
As we've talked about, Activities have a lifecycle, and that lifecycle is basically divided up into three lifetimes. Now there's the total lifetime, then there's the visible lifetime, the time when it's visible, and then the foreground lifetime, the timeframe in which the Activity is in the foreground and it's the Activity the user is interacting with. Now the lifecycle is represented by a series of lifecycle methods, and these methods basically represent the start and end of each lifetime. Now there are a few additional methods for transitions, and we'll talk about those later, but we generally focus much more on these methods related to the start and end of each lifetime. So the lifecycle of an Activity starts when that Activity is first launched, and then we first look at the onCreate lifecycle method, and that represents when the Activity is created, but it's not yet visible, and that's the beginning of the total lifetime within the lifecycle. Then there's the onStart method, and that's part of the process of the Activity becoming visible, so that's the beginning of our visible lifetime. And then there's the onResume method, and that's when our Activity moves into the foreground, in other words the Activity the user is interacting with, and that's the beginning of our Foreground lifetime. And once we get through that, our Activity is now the running Activity. It's important to understand that Android differentiates between an activity being visible and it being in the foreground, again, the foreground being the Activity that the user can interact with. So if you have a situation where an Activity appears other than yours and it obscures only part of your Activity, so part of your Activity is still visible, well, in that case your Activity is no longer in the foreground, and you're signaled that by a call to the lifecycle method, onPause, but your Activity is still visible. So in that situation, when the Activity that's obscuring yours goes away, your signal that you're going back into the foreground, because your onResume method is again called, and then your Activity goes back into the foreground, and your activity is running again. But remembering the point that Android differentiates between being in the foreground and being visible, if you have a case where another Activity shows up and it fully obscures yours, the user can no longer interact with yours or see it, well, onPause method is still called to indicate you are no longer in the foreground, but then after that the onStop method is called to indicate that you are no longer visible, as well. So in that scenario, once the other Activity is gone, and yours is coming back, first onStart is called to indicate that you are now becoming visible again. Then onResume is called to indicate that you're moving back to the foreground, and now you're up and running again. So now we reach the point where the user maybe _____ the activity and maybe do something like press the back button, where we're going to actually go away, well in that case we're leaving the foreground, so our onPause method gets called, we're no longer visible so our onStop method gets called, and then finally we're being destroyed, so our onDestroy method gets called, and then our Activity is then shut down. As you see, we have this series of lifecycle methods, and there are various transitions that occur, but they do occur predictably. Now there is one important caveat on the visible lifetime. Let's say that our Activity is up and running, so we know that we are visible and we're in the foreground, and in that scenario where another Activity fully obscured us. Now we know that we are now considered no longer in the foreground, so our onPause method was called, and then we're no longer visible so our onStop method is called. Well, when the user leaves that Activity and they return back to our Activity, our onStart method does get called, but there's one method that gets called first. There's a method called onRestart, and that's used to indicate that you're transitioning from the stopped state, the non-visible state, back into the visible state. So after onRestart is called, then Start is called, so in that case, we then become visible, we then move into the foreground, and be the running Activity. So that onRestart method is there if you need it to do additional or special work returning to the visible state, but as with all of these lifecycle methods, we override only the ones that we need. Now in our next clip, let's return to our demo. As you'll recall, I mentioned earlier that we would run into a problem if we returned to our Note List Activity after adding a new note. Let's see if armed with our knowledge of lifecycle methods, we can identify and fix the issue that comes up.

Demo: Updating ListView After New Item
Here we are with our application running in the Emulator. Let me go in here and click our New Note button. So that brings us into our Note screen, so I go ahead and choose a course, let's choose Java Fundamentals: The Java Language. We have our note, and let's give it the title of My Java Note. We'll make our note something like, this is my note. Alright, so we have that there, so let's go ahead and hit the back button first to take the keyboard away, and then again to return back to our Note List Activity. And you notice that we crashed. So why did we crash? Let's go back here into our code. So here we are in Android Studio and we're looking at the onCreate method, and the onCreate method calls another method we wrote, initializeDisplayContent. You see there initializeDisplayContent, that's where we set up our ListView, took an ArrayAdapter, loaded it up with the notes that we had in our DataManager, and then displayed those in the ListView. Well, the problem is is that the amount of data that the ArrayAdapter is responsible for has changed. Remember that onCreate only gets called when our Activity is first created. Well, when we switched over from NoteListActivity to NoteActivity, we know that for NoteListActivity the onPause got called, onStop got called. So as we're returning back to our NoteListActivity from NoteActivity, but although they got called, we didn't do anything to let the ArrayAdapter know that the data had changed. So that's what we want to do is that whenever we are returning back to the NoteListActivity we want to let the ArrayAdapter know that the data has changed so it can deal with it. So what we should probably do is that inside of initializeDisplayContent we've got that ArrayAdapter named adapterNotes, let's go ahead and make that a class-level field. So I'm going to go over here and just do Ctrl+Alt+F, I'll accept that name, mAdapterNotes, so we'll do that. So now the next thing we want to do is go ahead and override the onResume method. So I can do that by going up here to Code, Override Methods, I want to find onResume, so there's our onResume method, so let's go ahead and double-click that, so that goes ahead and stubs it out for us. So now, again, all we need to do is let the ArrayAdapter know the data has changed. So I'm going to call a method called NotifyDataSetChanged on my mAdapterNotes field. This way, each time our NoteListActivity moves back into the foreground we're telling it to just go ahead and make sure you're prepared for the latest list of notes that we have, so let's go ahead and run it again. So we're back in our Emulator, let's click our New Note button, let's create that same note, so we'll say Java Fundamentals, we'll call it My Java Note, and for the body of it we'll just say This is my note. Alright, so hit the back button to get the keyboard out of the way, and then head back. And we didn't crash that time, which is really good. And if I scroll down here to the bottom, we can see at the very bottom we have java_lang|My Java Note|This is my note. If I select it, we see our note. And now we're properly managing the lifecycle. Each time we go back to our NoteListActivity, it just makes sure that its ArrayAdapter is prepared for that list of notes.

Demo: Restoring a Note's Previous Values
So here we are looking at the Emulator with our app running in it Let's just check out how lifecycle behavior affects some of our apps. So I'm going to go ahead and choose this very first item. Now we know if we go in here and I add some text onto the end, and then when we go to our menu option if we hit cancel, we know that's undone. If I return back to it, the original text is there, not the text I added. Let's do something different now. Let's add some text to the end, and then I'm going to go ahead to our menu option that says Send mail, so Send as email. So, yep, go ahead and use gmail. So, of course when we get in here, if I get that keyboard out of the way, we've got our latest text including the Y, and we'll go ahead and head back to our app and go, hey, you know what, I think I do want to cancel this, so I go to the menu, and I hit cancel. Even though I cancelled, the YYY's are still on there, so something happened differently when I went to send email. So let's go back to our NoteList, let's switch back here into Android Studio for a second, and I'm looking at my NoteActivity, and remember that onPause is where we actually save our content. So let's go put a breakpoint right here inside of our onPause method, and let's return back to the Emulator. So let's choose a second item here now, and let's put some content onto the end. And now I'm going to go ahead and choose that send email option again. And when I choose that, notice what happens. In the background here, I hit the breakpoint inside of onPause, and so if I step through this, what happens. I actually save the note in that state, because if I release this, go back to the Emulator, go back into or email, then go back again to our app. So now, when I hit Cancel, and we get inside of onPause, it doesn't matter that we're cancelling. Even though I step through here and it's cancelled and I don't save now, I've already saved that note, because I saved the note when I went to the email app, because the lifecycle caused the onPause method to actually run. So what I need to do is change my app so that it matches the lifecycle correctly. So what that means is I can't just rely on saving on onPause, and then if they cancel, doing nothing. What I need to do is change the app so that when the user comes into the app we preserve those original values of the note, and then if they cancel, we go ahead and set it back to the old values. So let's go ahead and stop our app here. I'll just get this window at the bottom out of the way so we can see better. So let's scroll up to the top here and get into our onCreate method. So we're here in onCreate, and notice we have this method here, ReadDisplayStateValues. So I'm going to scroll down here just real quick and look at that guy. And readDisplayStateValues is where we actually get the note information out of the intent, where we get the position of the note and then we retrieve it from the DataManager. So what we should do is that after we call this readDisplayStateValues, that's a good time for us to preserve the original values of the note. So what we're going to do is scroll back up to onCreate, and right after I call readDisplayStateValues, I'm going to call a method I'll call saveOriginalNoteValues. Of course, that method doesn't exist yet, so I'll do Alt+Enter, we'll say create new Method, tab to accept avoid return type. As we save the original values, we want to save each of the values from the Note, but the first thing we want to check is if the note is new, because if it's a new note there are no values to set. So if it's a new note, I'm just going to return out of here. So now it just comes down to saving each of the values from the Note. So the first thing i want to do is save the course. And what I'll do is rather than saving the reference to the course, I'll just save the course ID, because each course has a unique ID. So I'll start by creating a local variable that I'll call originalNoteCourseId and setting it to the course id of the Notes course. So once I have that, I'm going to just go back here and promote that up to a field, so I'll do my Ctrl+Alt+F, and accept that name. So now we have the CourseId of the notes original course stored inside of our activity, so later on we can actually go back and get the course if the user cancels, and assign it back into the note. And let's do that same thing for the NoteTitle and NoteText. So now we have all of the original note values stored so we can use them later if the user cancels. So what we'll do is we'll change our application now so that when the user cancels, rather than doing nothing we will explicitly put the original values back into the note. So let me scroll down here into my onPause, and we have this section here where do the IsCancelling, and inside the IsCancelling we have one thing there that we do if it is a new note, so what we want to do is add an else side to this. And on the else side we'll call the method that puts the old values back into the note. So I'm going to call that method storePreviousNoteValues. I'll do the Alt+Enter to create it, tab to accept the return type, and then all I need to do inside of here is set each of the original values back. So the first thing I'll do is look up the course in the DataManager that goes with the CourseID I stored. So that gives me a reference to the original course. What I'll do now is just call mNote. setCourse for that course, and then for the Title and the Text, I'll just go ahead and put the original values right back. Alright, so that should do the trick now. If I go back up here to the beginning of my onCreate method. So in my onCreate, right after I read the DisplayStateVales, I save the OriginalNoteValues, Then when I go down here to my onPause, if they're cancelling, actually explicitly store the old values back. So let's go up to our saveOriginalNoteValues and put a break point in there as well. And let's go ahead and run our app again. So we are in the Emulator, we'll go up here and we'll choose the first one. Of course, we hit our breakpoint initially back here, and of course we're inside of our saveOriginalNoteValue so we're actually going to save all of those values as soon as we come in, so let's go ahead and release this guy. I'll switch back to the Emulator. So we're in there, let's go ahead and add some text onto the end of this, put that big string of X's. We'll go ahead and send the email we did before. Of course, now we hit our breakpoint inside of our app. Now we're not cancelling it, right, so if I step through here, we then save the note, so we're actually saving it with the user changes in it. And that's actually a good thing, because if the user never came back to our app, we of course don't want them to lose their changes. Let's go back to the Emulator, we'll go ahead and run an email. Now, of course, once I get here I want to get back out. Okay, so now we're back inside of our application. Notice we didn't go back through onCreate, because our instance still exists, right, the instance of our Activity is still there. So what I'll do now is go up and choose Cancel now, and when I cancel, if I'm back here in Android Studio, as I step through, now as I'm cancelling it's not a new note, so I store the previous values back. And if I release it and return back to the Emulator and go back and choose that first one again, of course we go back into our breakpoint and let's just go ahead and release that, back to the emulator, and now notice we cancelled properly. So because of the way the lifecycle works, it was important for us to not rely on the note staying in some state when we left our activity. So we preserved information about what the note originally looked like so we could reverse it if the user cancelled out when they came back. In our next clip, we'll look a bit more at this idea of preserving activity state.

Activity State Management
Now looking at an application like ours, where the user is looking at the NoteListActivity, they make a selection, so we send an Intent, which goes to our NoteActivity, and then looking at our NoteActivity they select an option to send an email. We know that that sends an Intent and then takes us over into the mail process. And as we've discussed, as we go through this task of Activities, it's possible that Activities are being destroyed behind us. But, of course, that creates an issue, because when the user hits the back button, the user expects to go back to that other activity in the exact state it was in, so the user expects that activity to have always been there, even though the activity may have left, it is now being restored. What that means then is we have to have some mechanism for any instance state associated with an Activity to be preserved, and then restored when the user comes back to it. Now there's another common scenario where activity instance state is really important. Now if you've used Android for any length of time, you've likely experienced something like this, where you're looking at the screen of an application, and then you rotate your device from portrait to landscape, and you'll notice the screen kind of disappear and then come back. And some apps actually do a really poor job of that. Other apps do a nice job of it. It turns out that whenever you rotate the device like that, by default an activity is fully destroyed and then recreated for the new orientation. Now we'll talk a lot more about this issue of how the system deals with changes in configuration, things like changing the orientation when we talk about resources later in this course series, but the important thing to remember is that there are a number of scenarios where activities get destroyed and restored. It may be something as simple as rotating the orientation of the device, or cases of the system reclaiming resources. So we have to have some way of dealing with that, so we need some kind of Activity state management. And the good news is, Activities do provide activity state management. Activities provide an opportunity to save our state before an Activity instance is destroyed, and Activities provide a way to have that saved state restored when the Activity comes back. Now it's a pretty straightforward process. When it comes to saving state, there's an activity method called onSaveInstanceState that the system will call, and when that method is called, we can write our activity state into a bundle that we'll receive into onSaveInstanceState. Now the system takes care of managing that bundle, so then when our activity is restored, that saved bundle is passed into our onCreate method. So the bundle that comes in has the information that we wrote into it from onSaveInstanceState. We've seen our onCreate methods get called a lot, so the question is, how do we differentiate between when an Activity is being restored versus being created for the first time. If that bundle is null, it means it's the initial creation for a particular Intent for this Activity, but if it's non-null, that means we're being restored. Now it's important to remember that when you're being created for the first time, or you're being restored, the Activity always has access to the Intent that created it. In our next clip, let's see how we can verify that our activities are providing proper behavior when an Activity instance is destroyed and then recreated.

Demo: Testing Activity State Saving
One of the challenges with managing activity lifecycle is we know that sometimes an Activity instance will stay around. We saw that in our last demo, because we saw that onCreate didn't get called when we returned to the Activity from the email. But we know that there are other times that the system does tear that activity down, and it's going to recreate a new instance that we're responsible to restore the state into. So the question is, how do you test for that case, if you don't know whether the system is going to tear down an activity or not. Well, Android provides a mechanism for us to actually set our devices or our Emulator to actually destroy activities each time we leave them. That way we can verify that our behavior for activity destruction and being restored works properly. Now to do that we go into our device settings, and then what we want to do is scroll all the way down to the end, and when we get down to the end there's the About device option. Now this is an Emulator, so it says about emulated device, I'll choose that. I'm going to scroll all the way down to the bottom again. Now this will seem odd because we're looking at the build number, but what we need to do is turn on Developer Options. Older versions of Android had Developer Options enabled by default, newer versions actually require you to enable the ability to get to Developer Options, and the way you do that is kind of strange. What you do is you go down here to the Build number, and you start clicking on it. And watch what happens when I start doing that. Notice it's starts saying you're two steps away from being a developer, one step away from being a developer, You are now a developer. So now by doing that, as I go back, and you see here now there's Developer options. That option wasn't there before. So now that I have Developer options enabled, and now that I've done this, developer options are always within my settings now. I'll choose Developer options. I'm going to scroll down a little ways here, and fairly far down the list under the Apps section, you see there's an entry here that says Don't keep activities. And what we're going to do is we're going to turn it on. And what that says now is that whenever I leave an Activity, destroy it, and what that does for me is that gives me the ability now to make sure my Activity works correctly when I leave it and come back, and what this does for me is it gives me the ability to verify that my state handling works properly. That when an Activity is destroyed I save that state correctly, and when I return back to the Activity it has the appropriate state in it. Alright, so now with that option enabled, let's go back here and let's launch our application. So we go back here, and scroll up to my onCreate method. So I'm in the NoteActivity, and I'm in the onCreate method, and what mm going to do here is where it says saveOriginalValues let's put a breakpoint there, and we'll run the application. Okay, so we're here inside the Emulator. Let's go ahead and choose the first option. Now, of course, when we do that we break in our onCreate, because it's the first time it's creating our _____ Activity, so let's go ahead and release it, and switch back to the Emulator. We'll go ahead and put that text on the end here. Let's go ahead and go to our email application. So we're inside of email. Now I'm going to head back to my NoteActivity, and notice now when I get inside of here I'm actually in my onCreate method, it's actually recreating the Activity from scratch. Now that's going to be a problem, right, because when we say saveOriginalValues here, let's go ahead and step into that. And we go through here, I'm going to step through until I get down to the NoteText. And if you look at my NoteText, you look down here in the bottom window where it says Variables, notice the NoteText has the XXX on it. Now notice what that means. That means that we're storing the original NoteTextValue, including the X's. So why did that happen? Well, remember that we're storing the original values in fields that are tied to the Activity instance. The OriginalNoteCourseId, the OriginalNoteTitle and OriginalNoteText. Well, when that Activity instance went away, and we were recreated, all the instance values are gone, so when we are recreated, we're assigning the instance values at the state the note is in at that moment. And remember that we saved the changes to the note in the onPause, so we save those changes into the note when we went to the email as we come back, but because we're now being fully recreated, all of our instance fields are gone, right, all of those things that are tied to the Activity are gone. So what we need to do is modify our application so that we actually preserve this state between when the activity is destroyed, and when we return. And in our next clip we'll see how to do that.

Demo: Saving Activity State
Here we are in Android Studio, and we know we want to start saving the instance state of our activity when it's destroyed so we can restore it later. We know in order to do that we're going to store this information into a bundle, and when we store information into a bundle, each item in there has to have a name. So what we're going to do is create names for each of the three things I want to store at my state, which is the OriginalNoteValues. So that way, when I return I can actually get back those OriginalNoteValues so that our Cancel feature will actually work. So let's go ahead and declare constants for OriginalNoteCourseId, OriginalNoteTitle, and OriginalNoteText. And so now we have constants for each of the Activity instance state items that we want to preserve. So now what we're going to do is, when the system tells us to save our instance state, we're going to write the fields that we have for PriginalCourseId, Title, and Text, into the bundle using those names. Now in order to do that, the first thing we need to do, of course, is override saveInstanceState. So let's scroll down here a little bit. Alright, so what I'll do now is go ahead and override the method. Now I could go up to the Menu, or I can use Ctrl+O. Ctrl+O lets me choose which method I want to override, and I want to override onSaveInstanceState. So there's onSaveInstanceState, so I'll just go ahead and just double-click. Alright, so onSaveInstanceState is stubbed out to call the base class implementation. You always want to make sure you do that so any state that the base activity wants to store can go inside of there as well. And so what we'll do now is inside of here we're going to take that parameter that's passed into use, which is our outState, and we're going to put each of the values inside of there that we want to save. So we'll start out with our OriginalCourseId. So that writes the CourseId that we want to save out into our InstanceState, and we'll do the same thing for the Title and the Text. So now when the Activity instance is being destroyed, and the system wants to go ahead and preserve our state, it'll call onSaveInstanceState for us, rewrite all of those values into there. So, of course, what we need to do then is when we're recreated we need to restore those values. So let's scroll back up to our onCreate method. So here we are in our onCreate method. Now remember that the way onCreate works is that when we're initially created, there is no savedInstanceState, so savedInstanceState is null. But if we're being restored, then we're passed in that savedInstanceState. So what we want to do here is that where we say saveOriginalNoteValues, well, we only want to do that when we're being newly created. Otherwise, we want to restore the values we wrote in onSaveInstanceState. So what we want to do here then is where we call saveOriginalNoteValues, let's put an if in front of that, that checks to see if savedInstanceState is null. And if it is null, we want to go ahead and save the OriginalNoteValue, so I'll put that inside the if block. But on the else side, we want to restore the OriginalNoteValues. So let's call our method, restoreOriginalNoteValues, and pass in the savedInstanceState. Alright, so when we're newly-created, we do what we've always been doing, saving the OriginalNoteValues, but when we're being recreated, we're going to go ahead and get those vales back from the state. Now of course this doesn't exist yet, so let's go ahead and do Alt+Enter, and create it. We'll tab on the return type, and tab our way through the parameters as well. So now what we want to do is just get those values that we put into the instance state, back out. So what I'll do is I'll first set OriginalNoteCourseId and then we'll assign that savedInstanceState. getString, and then pass in our constant for OriginalNoteCourseId. And then we do that same thing for the Title and the Text. So now we have the ability to restore those values back from the InstanceState. So let's put a couple of breakpoints in. Let's first scroll up to our onCreate method, and let's put a breakpoint here where we check to see if savedInstanceState is null, and the other thing we'll do is we'll scroll down to our onSaveInstanceState, and let's put a breakpoint in there as well. Alright, so let's go ahead and run our app. Alright, so here inside of our app, now remember that we've set this Emulator to always destroy our Activities when we leave them. So let's go in here now and choose the first item. And when we choose that, of course, it goes into our NoteActivity. Of course, when we get in here savedInstanceState is null, so that means when I step I'm going to go ahead and save the OriginalNoteValues, I'm actually going to get them from the Note. Let's go ahead and release this, return back to the Emulator, so we're inside of here. And let's go ahead and put some extra text on the end, and now let's go over to the email. So go to our Menu, send as email, say yep, go ahead and use gmail. So you notice when I did that, if you look back here in the Debugger, we've gone into onSaveInstanceState, So that's cool, we're going to save those values now in the state. So let's go ahead and release this, go back to the Emulator. Let's return back to our app now. And notice now when we go inside of here we're in our onCreate method, but notice that savedInstanceState is not null, and by not being null, when we step through here, we now restore the originalNoteValues, we get those values back out from that bundle. So let's go ahead and release it, return it back to the Emulator. And so now let's cancel, and when we come back in here, of course we stopped inside of the Debugger, so let's release that, back to the Emulator, our Cancel worked properly. And so now we've got proper lifecycle handling throughout our entire activity. Not only do we preserve the original values of the notes so when we get paused we can put them back, but now even when our activity is fully destroyed, we preserve those original values so we can restore them back when we recreate it later.

Summary
To wrap up, here are some of the key things you want to remember form this module. Remember the Activity lifecycle is broken up into three basic lifetimes, the total lifetime of the Activity, the visible lifetime of the Activity, and then the foreground lifetime of the Activity. And remember that there are methods that represent the starting and end of each of those lifetimes. And then finally, we looked at Activity state management, and that's about our Activity's instance state. Remember that activities are often destroyed and then restored, so we've got to preserve the state of the Activity across that process. So we use the onInstanceState method to save our InstanceState, and then when our Activity is recreated, the savedInstanceState is passed into our onCreate method. And remember that that savedInstanceState it comes in as null if there is no state to be restored. Alright, well that wraps up our first course in this series. In our next course, we're going to start digging into the tools we use in Android development.

Course author
Author: Jim Wilson	
Jim Wilson
Jim Wilson is president of JW Hedgehog, Inc., a consulting firm specializing in solutions for the Android, iOS, and Microsoft platforms. Jim has over 30 years of software engineering experience,...

Course info
Level
Beginner
Rating
4.5 stars with 161 raters(161)
My rating
null stars

Duration
3h 51m
Released
31 Mar 2017
Share course
