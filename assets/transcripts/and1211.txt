Android Apps with Kotlin: Custom Views
by Brendan Wanlass

Adding customized views and components to your app will set it apart from the crowd. In this course, you will learn three foundational techniques for creating any view you can imagine.

As you develop Android apps, you will discover that the default Android views and widgets almost always fall short. While these components are a great start, you will need to add customized components to maximize your appâ€™s potential. In this course, Android Apps with Kotlin: Custom Views, you will gain the ability to to build any view you can imagine. First, you will learn how to combine basic Android views into compound components. Next, you will discover the benefits of extending existing views to add your own unique style. Finally, you will explore how to build a custom view from the ground up by extending the View class. When you are finished with this course, you will have the skills and knowledge of creating custom views needed to build world-class Android apps.

Course author
Author: Brendan Wanlass	
Brendan Wanlass
Brendan is an Android and game developer. He has a passion for well designed, engaging software. He was a designer and engineer for the game Magnetic by Nature...

Course info
Level
Intermediate
Rating
0 stars with 3 raters
My rating
null stars

Duration
2h 10m
Released
26 Feb 2019
Share course

Course Overview
Course Overview
Hi everyone. My name is Brendan Wanlass, and welcome to my course, Android Apps with Kotlin: Custom Views. I'm a mobile technical lead specializing in android at Canopy. One of the greatest aspects of Android development is the ability to express your unique style with custom views and components. By customizing your apps views you can make it stand out from the crowd and tackle all kinds of UI designs. In this course we're going to explore three foundational approaches to creating custom views; compound components, extending views, and building custom views from scratch. By the end of this course you'll have a solid skill set for creating any kind of view you can imagine. I hope you'll join me on this journey to learn how to create custom views with the course, Android Apps with Kotlin: Custom Views at Pluralsight.

Getting Started
Getting Started
Hi. My name is Brendan Wanlass, and welcome to my course, Android Apps with Kotlin: Custom Views. One of the greatest aspects of Android development is the ability to provide users with a unique and engaging experience by customizing the appearance and functionality of your app. You can implement your own theme and feel by expressing yourself on what is essentially a blank canvas. In this course you'll be equipped with multiple techniques for developing customized views and widgets that can set your app apart from the rest. With these highly responsive and interactive components you can offer your users an enjoyable experience that will keep them coming back for more. Throughout the Android Apps with Kotlin Learning path we've been building a NoteKeeper app. This is, at its core, an app that lets you take notes on a topic and save them for reviewing later. Each course has taught you how to add something new to the app or a new approach for improving the app. Now you want to add the ability to color code your notes in the NoteKeeper app. This will allow you to keep your notes organized into categories. We will learn several ways to tackle this feature by leveraging custom views. We will begin by taking various readily available Android widgets and combining them into compound components that can be reused throughout the app. We will create a customized color picker that lets users select from a list of colors so that they can color code any note. We will learn the benefits of encapsulating this custom functionality into its own view class. We will then take this idea one step further. We will take an existing Android widget, and instead of combining it with another widget we will extend its functionality and appearance to meet our needs. We will create a custom color slider that makes it even easier to select a desired note color. We will swap out our first color selector with a color slider in the NoteKeeper app. We will compare and contrast compound components and extended views to see the pros and cons of each one. We will identify situations which are appropriate for each one, which will enable you to make an informed decision when you set out to create a custom view. Finally, we will create a fully customized view from the ground up by extending the view class directly. When a view needs a high level of customization or unique appearance or behavior a fully customized view is a great approach. We will take the color selector concept to this final step by building a rotating color selector dial from scratch. We will learn how to make the view responsive to varying layout sizes and restrictions. We will also make the view respond to user gestures, such as taps and drags. We will start by learning how to create a compound component by combining existing components together for a convenient and reusable widget. We will then learn how to extend an existing view to add our own functionality and appearance. We will learn a third technique suitable for when a highly customized view is needed. We will create a component from scratch by extending the view class directly. We will learn how to support positioning and sizing the custom view so that it can be used in a variety of situations and layouts. Finally, we will learn how to handle user input in order to make the custom view interactive and easy to use. To succeed in this course I recommend having a basic knowledge of developing apps in Android Studio with Kotlin. If you've already built apps before you'll be fine to jump right into this course. If not, I recommend completing all the courses in the Android Apps with Kotlin learning path leading up to this one or, at the very least, completing Android Apps with Kotlin: Building Your First App; Android Apps with Kotlin: Tools and Testing; Android Apps with Kotlin: Resources, Styles and Themes; Android Apps with Kotlin: RecyclerView and Navigation Drawer. These courses will give you the foundational knowledge required to learn the concepts in this course. The tools we will be using in this course include Android Studio. You'll be okay with Android Studio 3.1 or newer, but I recommend Android Studio 3.2 or newer, that way you'll have full support for Android Pie. We'll be using Kotlin 1.2 or newer, and we'll be targeting Android API 21 and newer. Next up we'll jump into Creating Compound Components to begin our journey of creating custom views with Kotlin.

Creating Compound Components
Creating Compound Components
Hi. I'm Brendan Wanlass, and welcome to Creating Compound Components. The simple components and widgets available in Android can get you pretty far, but as your app grows it often makes more sense to group these together to create convenient, reusable compound components. These components will reduce code duplication and the potential for errors. They will also help to keep your code and logic clean and organized by extracting a lot of view code into its own class. So let's get started. We'll start by introducing compound components and what they're made of. We'll get an idea of how they differ from simple Android widgets and what sets them apart from fully custom views. We'll learn how to combine multiple simple views or widgets into a compound component. We'll add a compound component to our NoteKeeper app and see how it fits in with the rest of our layout code. Next we'll learn how to communicate between our compound component and it's hosting activity or fragment. Custom views often produce events as the user interacts with them, so it's important to be able to capture those events and respond to them. Finally, we'll learn how to style and customize our compound component through a declarative approach using custom attributes in our layout XML.

Intro to Compound Components
Compound components are a great way to create custom views with special functionality that a simple viewer widget can't provide on its own. By using simple views as building blocks you can create a powerful and reusable custom view. Android offers many useful views and widgets right out of the box, so before you go to the effort of making a custom view make sure that an existing view doesn't already meet your needs. Most apps are made up almost entirely of existing simple views and widgets. That being said, there are plenty of cases where custom views make a lot of sense or may be required. Consider an app that has a quick booking feature on various screens. Combining several text fields and a button into a reusable compound component is a great way to tackle such a feature. The custom view can also contain validation logic that handles displaying errors on text fields and toggling the button between enabled and disabled. That way our activities are slimmer and don't have to worry about all that logic. You're also reducing code duplication because the logic for this view only has to be implemented in one place. The compound component could also be used for a dual list view where the user can select items to enable or disable or an image browser with options to hide and show the image. Compound component provide good reusability. You can implement logic for complex views just once and utilize it many times throughout your app. This will save you time and expose you to fewer errors. Compound components also provide a clean separation of concerns. You can put code and logic that is specific to your custom view inside the compound components class instead of directly in your activities and fragments. This will help to reduce clutter in your activities and fragments and will make future refactoring simpler. So now that you have a good idea of what compound components are and how you can benefit from using them, let's learn how compound components are created.

Combining Views into a Compound Component
Compound components are created by combining multiple simpler views together into a single reusable component with self-contained logic. Take two buttons, for example. It's perfectly fine to add simple buttons like these directly to your layouts, and just about every app uses this kind of basic component. However, if you find that you are using the same buttons together over and over it may make sense to combine them into a compound component with some accompanying logic to orchestrate their behavior. When creating a compound component you start with a view group to act as a container. This could be something like a linear layout or a constraint layout. You will then place the other views that make up your custom view inside of that container. This can all be done via XML layout, just like any other layout. To make your compound component you will extend your chosen view group. You can put your custom view logic inside of that class. Then you can use your compound component inside your normal activity layout and treat it just like the other views in your layout. Let's jump into Android Studio and try this out. Okay, we're here in Android Studio. Make sure you have the code for this module, which you can find in the resources section for this course. Open up the project and follow along. We'll be using the NoteKeeper app that we've been building throughout this learning path. Let's say that you've been building this NoteKeeper app for your company and your product person comes to you and tells you that the app needs a new feature. This new feature would allow users to color code their notes in order to classify them. A user should be able to open up a note and pick a color for that note. This color would be displayed in the list of notes. Let's create a custom color picker view using a compound component. Start by creating a new class called ColorSelector. Make this class extend LinearLayout. LinearLayout will be our container for the compound component. Remember, your compound component class must extend the view group type. Notice that LinearLayout has four different constructors. We should implement all four of these constructors. To implement a constructor use the keyword, constructor, followed by the appropriate parameters. Call super to call the parent class's constructor, making sure the pass the constructor parameters. Here in the constructor we can set the orientation for our container. Since we are extending LinearLayout we can set our class's orientation like so. Let's use a horizontal orientation for our control. Implement the rest of the constructors with the appropriate parameters. Now that we have all four constructors we could initialize this view in four different ways, depending on what parameters we wish to provide. For example, if we just wanted to use our view without custom attributes of any kind we can call this top constructor and just provide a context. This is a good start, but all of these constructors are making our class pretty verbose with a lot of boilerplate and duplicated code. Let's see if Kotlin can help us out to simplify this. First, we are setting the orientation on our view four times. Let's move that to an init block. An init block will be called regardless of which constructor is used, so the orientation is guaranteed to be set. Great. We've removed some code duplication. Now let's see what we can do about all of these constructors. Let's use a primary constructor with all four parameters, but we still want to have the option to provide fewer parameters, so we will take advantage of default parameter values. By defining a default value for a parameter we can call this constructor but just provide the context and the default values will be used for the rest of the parameters. We can also call the constructor and pass different values if we'd like. Great. This will work fine if we are only instantiating this view from our other Kotlin files, however, we want to be able to put this custom view in our XML layouts as well. If we were to do that with this current implementation the app would crash like so. We'd get a stack trace that says, NoSuchMethodException. Android is looking for a constructor signature that just has the one parameter, but we've only defined a constructor with all four parameters, as far as Java is concerned because under the hood Java is being used to instantiate our views and Java has no concept of default parameters. So it interprets our constructor as a normal constructor with four parameters. To solve this problem we can use a handy annotation called @JvmOverloads. This will tell the compiler to generate a constructor for each parameter in our primary constructor. In our case, it will generate four different constructors in the Java bytecode. That way when the framework goes to instantiate our view it will find the constructor it's looking for. To see what is happening go to Tools, Kotlin, Show Kotlin Bytecode. Then click Decompile. This will show us the Java code that is being generated. Remember, even though we are using Kotlin, the compiler actually generates matching Java files. The Java files are what the final app is made of. You usually don't have to worry about these Java files, but sometimes it can be useful to see what's going on behind the scenes. Here we see a Java class called ColorSelector, which extends LinearLayout just like the Kotlin ColorSelector we are writing. And here we see four different constructors that got generated thanks to the @JvmOverloads annotation. Now we can use this view in our XML without any problem. Okay, so now that we've got our constructors in place let's move along. You find a default list of colors for the ColorSelector and a selectedColorIndex. This index will keep track of which color is selected as the user is interacting with this view. Next, let's create the views that will make up our compound component. Create a layout file called color_selector. Use merge for the enclosing tag. This will allow us to merge these views into the parent LinearLayout. Now we can start adding the views that will make up our compound component. Let's add a couple of arrows, so the user can click back and forth through the list of colors in order to choose one. Add a drawable for the back arrow. Go to the Drawables folder and import a vector drawable. You can use whatever icon you like. I'll just choose the simple back arrow. Import a similar arrow for the forward button. Once you have two arrow icons imported go back to the ColorSelector layout file, add an ImageView using the left arrow as the source. This will be the back arrow. Next, add a simple view that we can fill in with the currently selected color. Then add another ImageView for the forward arrow. Use the other arrow icon that you imported. Next, add a checkbox. We can use this checkbox to enable or disable the color. Last, let's add a TextView as a label for the checkbox. Now if you go look at the Design tab the layout doesn't look very good. This is because so far we just have the merge tag enclosing our views, so the designer doesn't know how to draw things. We'll want to check it out in a second once we've placed it in the rest of our layout. Let's come back to that in a moment. Jump back to your ColorSelector class. Now that we have the views for our layout we need to inflate them into the parent container. In this case, this is the linear layout. Here is where we are going to take advantage of that merge tag. Get a reference to the SystemService LayoutInflator, call inflator.inflate and pass in the color_selector layout. For the root pass this. That will tell the inflator to inflate our ColorSelector views into the ColorSelector class's container, which is a LinearLayout. Great. Now we can show the currently selected color by setting the background color of the simple square view we added to our compound components layout. Now jump to the file, contentmain. This is the layout for our note detail screen. At the bottom add a label for our ColorSelector. A simple TextView will do. Then add our custom ColorSelector view. Notice here that we can reference our custom view with a fully qualified name. Putting the package in front of the class name will tell the framework where to find our custom view. Switch to the Design tab. We can see our new text label, but no color selector. Notice the error icon in the top right corner of the design view. Click on that icon and a tab comes up with a missing classes message. Expand that message and you'll see that even though we fully qualified our custom views path, our class still couldn't be found. This is because we haven't built our project yet. If you've already built your project you shouldn't see this error. All you have to do to fix this is to build the project. Go ahead and do that. Right away you should see the color selector appear in the design view. Run the app and navigate to a note detail screen. We see our color selector here in the layout. Great. If you try clicking on the arrows nothing will happen. This is because we haven't wired up any events or actions to our custom view yet. Let's jump back into our ColorSelector class and add some ClickListeners to those arrows. Add a ClickListener to each arrow and stub in a method call to selectPreviousColor for the left arrow and selectNextColor for the right arrow. We'll create those methods next. Start with selectPreviousColor. Inside this method we'll want to cycle through our list of colors and update the background color of our selected color view with each click. First, check if the currently selected index is 0. If so, we need to jump to the end of the list by assigning the listOfColors.lastIndex as the currently selected index. This will make sure that we cycle through the list instead of stopping at the beginning. If we're not at 0 we can go ahead and decrement our index. This will effectively move us backwards through our list. Finally, set the selected color views background based on the current index. Next, create a selectNextColor method and implement similar logic to the selectPreviousColor method, except this time we'll move forward through the list of colors. Now that we've wired up some actions to those arrows let's launch the app and try it out. Click the left and right arrows and see that we can now cycle through the list of colors. We've learned how to combine several simple views into a compound component. We've learned how to place that component into our regular activity layout and then added some custom logic to our compound component class. Next, let's learn how to communicate events from our custom view into the note detail activity.

Communicating between View and Activity
Views often generate events that other parts of your app will need to respond to, especially as users interact with your UI. We previously learned the benefit of encapsulating view logic into the view class itself. Now your activities and fragments can benefit by simply concerning themselves with user interactions and resulting events. Take this image viewer for example. The user can tap Hide or Show and the activity can then just listen for a response. The image viewer will worry about the details of hiding the image. The view will need a way to communicate those events to the activity or fragment. We don't want to concern the view with knowledge of the activity, and we want to keep things flexible, so that a variety of things can listen for the view's events. This is the perfect use case for an interface. We can have our view defined in interface with methods that it will call as events occur. Our compound component will be able to use this interface to communicate those events to activities or fragments. The interface for our color selector could look something like this. We can define an onColorSelected method, which passes an integer representing a color. The note detail activity can implement this interface and respond to the selected color. Let's break down how this back and forth happens. First, our CustomView defines the interface with corresponding methods, then our activity will implement that interface, satisfying the contract by implementing each method defined in the interface. Then the activity will tell the CustomView, hey, I'm listening. I've implemented your interface. As events occur the CustomView will call the corresponding method on anyone who has implemented the interface. In this case, it will call the method defined in our activity without even knowing that it's an activity or anything else about it. All it knows is that our activity has implemented the interfaces methods and it is content to call those methods. The activity can then take action based on those methods being called by the CustomView. Let's jump back into Android Studio and implement this communication between CustomView and Activity. Let's start by going to our note item layout and adding a color swatch. This is the layout for items in our list of notes. Adding a color swatch will allow users to see which color they've picked for each node. Open item_note.xml. At the bottom add a simple view and constrain it to the end, top, and bottom of the parent container. Set the background color to red for now. Switching over to the design tab, we see the new red view. Let's make it look a little nicer by extending it all the way to the edge of the parent view. Go back to the Text tab and find the CardView and remove the padding. This will allow our view swatch to go all the way to the edges. Great, but now the other views need to have their own spacing to get a similar effect that the padding provided. Add a margin to the start of the ImageView to the top of the textCourse TextView and to the bottom of the textTitle TextView. Add a margin to the end of textTitle as well, so we have a little spacing. Now that we've added a bottom margin to textTitle we need to add a constraint on the bottom as well or else the margin tag will have no effect. Okay, let's take a look at the Design tab. Everything looks good. Don't forget to remove the background color on the color swatch. We'll be setting that programmatically with our custom view. Great. Now that we've got somewhere to show the note color let's implement the logic for communicating between the ColorSelector view and the Activity. That way we can use the activity to save the selected color. Go to the ColorSelector class, create an interface called ColorSelectListener, add just one method called onColorSelected with a color parameter represented as an integer. This interface is saying that anyone who wants to implement the interface and act as a ColorSelectListener must implement the method, onColorSelected. Now add a new member called colorSelectListener using the interface as its type. Make this member nullable and initialize it to null. We'll use this variable shortly. At the bottom of the ColorSelector class create a new method called broadcastColor that takes in a color represented as an integer. We will use this method to communicate the chosen color to the colorSelectListener. See here how we are calling the onColorSelected method that we defined in our interface. Notice the question mark there. This syntax is saying if our local colorSelectListener isn't null, or in other words, if there is a listener registered, go ahead and call the onColorSelected method to broadcast out colors. Go to the selectPreviousColor method, add some code to call the broadcastColor method, check if the colorEnabled checkbox is checked. If so, broadcast the currently selected color, otherwise, broadcast TRANSPARENT as the color. This will effectively show no color is selected. Add the same logic to the selectNextColor method. Notice we just added identical logic to both methods. Let's improve this. Move the logic for showing either the selectColor or TRANSPARENT to the broadcastColor method. Remove the color parameter from the method. Now in both selectNextColor and selectPreviousColor, we can just call broadcastColor and we don't have code duplication. It's good to be aware of this kind of thing as you're coding, so that you can keep your code base tidy. Now we need to add another bit of logic for when the colorEnabled checkbox is checked or unchecked. We want to call the broadcastColor method when this happens, so that the listeners notify that it needs to show or hide the color and the color swatch. Now let's create a public method called setColorSelectListener. Our NoteActivity can call this method and say, hey, I'm a listener, and I want to be notified of color changes. Now jump to the NoteActivity. Let's create a listener and register it to the ColorSelector view. Call setColorSelectListener on our ColorSelector view. Now we need to pass something that implements the ColorSelectListener interface. Let's use the object keyword to instantiate an anonymous instance of this interface. This just means we are going to use a simple object to satisfy the interfaces contract. We don't have to actually declare a named class. Notice the red line under the object. That is there because we haven't satisfied the ColorSelectListener contract yet. We have implemented the onColorSelected method. Hit Command+N on Mac or Ctrl+N on Windows. This brings up a tiny menu for code generation. Select Implement Methods. Notice here that Android Studio recognizes the methods that we must implement as part if the interfaces contract. Choose onColorSelected and hit OK. The method is stubbed in and ready for us to flesh out. Notice the red line under the object is gone now that we're satisfying the interface contract. Let's create a member variable to keep track of the last color broadcast we received. Initialize it to TRANSPARENT. Now in the onColorSelected method set the member color to the color we received from our compound component. Go to the displayNote method and set the noteColor member variable based on whatever our saved note has. In order to save the note color to a note we need to add a field for it in the NoteInfo class. Now whenever we open a note activity we can grab that same note color. Okay, now that our activity's listening for color changes, let's update our recycler list adapter to show the correct color on each node. Jump to the note recycler adapter and go to the ViewHolder inner class. Add a member that is a reference to the color swatch we added to the note item layout. Now go to the onBindViewHolder method and set their color swatch background color based on the note saved color. Lastly, jump back to the note activity and go to the saveNote method. Set the note color based on the member variable we added. This will save the note's color. Run the app and try it out. You can select a color, make sure the checkbox is checked, and go back to our list of notes. We see that the color swatch correctly reflects our chosen color. However, when we go back into the note the red color we chose isn't shown, and the checkbox is deselected. We need to add a little more communication between our activity and custom view. Go to the ColorSelector class. Add a method called setSelectedColor that takes in a color. Here we need to set our selectedColorIndex and the state of the colorEnabled checkbox. We will also update the color swatch background color. We will do this based on the color passed to this method. Now when we launch our note activity we can call this method to tell the ColorSelector view what the previously saved color was. Jump to the NoteActivity class and go to the displayNote method. Add a line calling the setColorSelected method we just made. Launch the app and try it out. We can select a color, navigate away from the note activity. Now to get back to the same note and see that the color selector reflects our previously saved color. So we've been able to effectively combine simple views into a compound component and create a colorSelector view. We've added communication to the custom view and an activity via interface. However, there are some improvements that we can make. We've implemented a couple of features using a more traditional Java styled approach. Let's go back and explore how Kotlin language features can streamline our code.

A Kotlin Approach to Communication
First, let's see how we can improve this setter here. Using a named set method like this is more commonly found in Java code. Let's update this to reflect a Kotlin styled approach. Grab the guts of this method, as we're going to reuse them elsewhere. Delete the rest of the method. Let's define a member variable called selectedColorValue of type Int. Initialize it to transparent. Now we can use a custom setter to implement the logic we had in the method we just deleted. Right below the variable declaration use the keyword set, along with value, like so. This is saying whenever someone goes to set the value of this variable execute the code in this block. Here's the code we cut earlier into this block. This'll maintain the same logic we had before. Jump back to the note activity. In the displayNote method we can now access and set the note color directly. This is in line with Kotlin best practices. Launch the app and try it out. We should get the same behavior we had before. Now jump back to the ColorSelector class and find the interface we defined. An interface like this with just one method is called a functional interface, and it is common in Java 6 and older. It works fine, but it is fairly verbose. We can improve this by using a couple of Kotlin language features called higher order functions and lambdas. We learned about communicating between our view and our activity with an interface. The more Kotlin appropriate way to achieve this communication uses different mechanisms. In Kotlin we can communicate with higher- order functions and lambda expressions. Thinking about this from a high level, we first implement a higher- order function in our custom view. A higher-order function is a function that takes in another function as a parameter or returns a function. Then in our activity we can create a lambda expression, which will define what we want to happen when the event in question fires off. We then pass that lambda to the higher- order function we defined in the custom view. Finally, the custom view will be responsible for executing the lambda expression at the appropriate time. A higher-order function is a special function, which can take in another function as a parameter. The parameter signature has the same elements as any other parameter. First, you have the parameter name followed by a colon. Then you have the parameter type. In this case, the type is a function with its own parameters and a return type. To define the function that will be passed you first define any parameters it needs inside parentheses. Then you have an arrow, followed by the return type. In Kotlin, Unit is basically the same as void in Java. It means the function won't return anything. So, in this case, we have defined a higher order function that takes in a function as a parameter. That parameter is a function with one parameter, a view, and it returns nothing. A higher-order function can accept any sort of function, as long as its signature and return type match. For things like click listeners it is common and convenient to pass in a lambda expression. A lambda expression is an anonymous function. First, you define the parameters of the lambda here, then you have an arrow, followed by the body of the function. You can reference the parameters of the lambda inside the body, just like a normal function. Let's jump back into Android Studio and use these tools to clean up our custom view communication. Go to the ColorSelector class and delete the ColorSelectListener interface, as well as the setColorSelectListener method. Create a new method, which will be a higher -order function. Call it setListener for now. For the parameter define the type as a function which takes in an int and returns a unit. This higher-order function will be used to take in a function that is looking to receive the selected color. The color will be passed as an int to the provided function. We will need to keep track of the function, so let's change our member variable to be able to do that. Change this type to a function that takes in an Int and returns Unit. Make it nullable and initialize it to null. Now in the setListener method we can stash the passed function into the colorSelectListener member variable. Okay, now that we have a higher order function defined, and a way to keep track of the listener function, we need to update how we are triggering color change events. Go to the broadcastColor method. We need to change our code here to work with our new listener. Check if the listener is null, and if it's not null, then you can execute the listener. Remember, the listener we are saving is actually a function, so to execute it just add parentheses, and in this case it takes in an int as a parameter, so pass in the selected color. Our code here doesn't have any knowledge of what the listener is doing, so we maintain the decoupling that the interface provided us. It simply executes the function and and provides the necessary parameters. Now jump over to the note activity. In the onCreate method let's define a function that we can pass to the ColorSelector's higher-order function. Call the higher-order function n. Since it has a function as its last parameter we can skip the parentheses and just use brackets. Inside the brackets we will define a lambda expression or anonymous function. The higher-order function declares that we need to have one parameter of type Int. We can name that parameter color. In the body of the lambda simply assign our local noteColor. This is the same thing we were doing previously with our interface and object. Notice how when we compare the two approaches the Kotlin way has fewer lines of code and is more concise. Delete the old code and run the app. We should see the same behavior we had before. Oftentimes it is useful to be able to register multiple listeners to a view. This can be accomplished using higher- order functions and lambdas. Go back to the ColorSelector class. Make colorSelectListener plural, and change the setListener function to be named addListener. Change the type of colorSelectListeners to be an ArrayList of functions. Initialize it to an empty list. In the addListener function add the passed function to the colorSelectListeners list. In the broadcastColor method use a foreach operator on the listener list. For each function in the list call it passing in the selected color. Jump to the note activity and change the method call from setListener to addListener. Run the app again, and you should see the same behavior. We've learned how Kotlin coding practices can help to make our code more concise with less boilerplate. The last thing we'll do with this compound component is add support for custom attributes.

Custom Attributes
An important part of views in Android is the ability to customize them declaratively in XML. Think of a text view and setting the font size, typeface, and text. When making a custom view it is a good idea to support custom attributes, so that your view may be customized without further subclassing. Remember the constructor for the ColorSelector we're creating. One of the parameters is called attributeSet. AttributeSet is the object that contains any custom attributes defined for a given instance of the view. We will be able to pull the values out of this object and apply them to our view. Supporting custom attributes has four major steps. First, you need to define the attributes that your view will support. This is done inside of a declare-styleable resource element. Next, you can specify custom attributes anywhere you're using the custom view in XML. Then you'll retrieve those custom attribute values at runtime in your custom view class. Last, you'll apply those custom attributes to your view. In order for the framework to know what kind of custom attributes your view supports, you will declare them inside of a declare-styleable tag inside of a resource element. Here we use the name of our class, ColorSelector, declare-styleable tag. Then we can list the attributes we want to support. Here we have one custom attribute, colors, and the format for this attribute is reference. For the format we could use one of a variety of values, such as integer, string, or dimension. This is telling the framework what kind of value this custom attribute represents. We will use reference because for our color attribute we want to reference a list of colors in another file. Let's jump into Android Studio and try this out. Go to your resources folder and navigate to the values folder inside. Create a new file called attr, which stands for attributes. Inside an enclosing resources tag create a declare-styleable tag with the name ColorSelector. Remember, this name must match your custom views class name. Inside the declare-styleable tag create another tag called attr that has the name colors and the format reference. Now that you've defined a custom attribute for your ColorSelector view let's define some nice looking colors to use. Go to the strings.xml file and add a string-array of colors. You can name it something like note_color_array. Since we've built the ColorSelector to be dynamic as it scrolls through colors, you can add as many or as few colors as you'd like to the string array. Okay, so now we have a custom attribute declared and a list of colors that we can use as a reference value. Now let's set up the custom view to do something with the custom attribute. Go to the ColorSelector class and scroll to the init block. Grab a reference to the custom attribute by calling context.obtainStyledAttributes. Pass in the attributeSet, which comes in through the constructor. Also pass in a reference to the styleable attribute we defined. This is saying, look through the set of attributes associated with this view and pull out the ColorSelector styleable if there is one defined. Now call getTextArray on the typed array we pulled out of the attribute set. We can pass R.styleable .ColorSelector_colors. We never defined a value called ColorSelector_colors, rather, the framework generated this based on the name of our declare-styleable, in combination with the name of the attribute it contains. Notice that there's a warning about a type mismatch here. Our local list of colors is a list of integers, but this getTextArray is returning a list of CharSequence, which is basically a list of strings. Remember we defined our list of colors as hex value strings, so we need to convert each string into its corresponding integer representation. Luckily, Kotlin has several built-in functional operators that can help us do this very succinctly. GetTextArray returns a collection, so we can call .map on its result. See here that the map operator will give us a reference to an individual item in the textArray. We can call Color.parseColor on that CharSequence, which will convert it into a color or, more specifically, an integer. Make sure to cast the CharSequence into a string because that's what parseColor takes in as a parameter. So map essentially applies whatever logic we declare in this lambda block to each element in the list and then repackages the list for us with the resulting values. Now that we've got a list of colors extracted from the attribute set we must call typedArray.recycle. TypedArray objects are a shared resource and must be recycled after each use. They use up a lot of resources and memory and should be freed up when you're done with them. Okay, everything is in place, and the last step is to go to the XML where we were declaring our custom view and add the colors attribute pointing to the desired list of colors. Go to the contentmain.xml file and scroll to the ColorSelector view. Begin typing app:colors and see how the colors attribute appears in the autocomplete list. The framework recognizes our custom attribute and that is associated with the ColorSelector view. Provide the color array we defined earlier. Notice that since it's an array we can find it with the @array tag, even though it's in the strings.xml file. Run the app and try out the new color list. We can see all the new colors we defined in our string array being represented in the ColorSelector compound component. We learned how to declaratively specify the colors we wish to use in a given instance of the ColorSelector view, via custom attributes.

Summary
In this module we learned that oftentimes the basic views that Android provides can often solve your UI needs. There are times, however, when custom views are necessary. A compound component is an efficient way to get custom functionality without having to build a view from scratch. We discovered that we can combine various simple views together in a parent container to create a new view with custom functionality. We learn that we must house the simpler views in a view group, which we can then place into our normal layout files. We explore the need to communicate data and events from custom views out to their corresponding activities or fragments. We learned that a custom interface is the simplest and quickest approach to communicate with views. Finally, we added support for custom attributes to a compound component. We learned the proper way to declare new attributes and that various data types can be supported, such as string, integer, Boolean, and reference. We learned how to consume custom attributes in the compound component view class and that we must be conscious of the resources it consumes by recycling typed arrays. When a particular UI requires even more custom behavior than a compound component can provide, extending a view can be a great option. Join me in the next module to learn this useful technique.

Extending Views
Extending Views
Hi. I'm Brendan Wanlass, and welcome to Extending Views where we'll learn how to take existing Android views and customize them to better meet your needs. Let's get started. We'll begin by exploring the differences between extending a view and creating a compound component, such as the one we created in the last module. We'll discover a good mental approach when beginning to extend an existing view. Then we'll roll up our sleeves and create a custom view by extending an existing view. We'll be working in Android Studio to learn how to subclass an Android progress slider. We'll take a first look at the canvas and paint objects and learn how to draw our own shapes as part of our custom view. And finally, we'll look at some of the pros and cons of extending a view, so that you can decide which approach is best for you.

Intro to Extending Views
If a basic Android widget, or even combining multiple widgets into a compound component isn't getting you what you need, you should consider extending a view. Creating your own view subclass could provide the flexibility and customization you need. Android offers a wide variety of views and widgets right out of the box. These views come with a basic level of customization. Most of the time these views will meet your apps needs. Sometimes, however, it will be more convenient to group these together into a compound component, such as the one we explored in the previous module. However, there will be times when a single existing view gets you almost what you need, and perhaps a little tweaking or altered functionality or appearance would be enough. Take this progress slider, for example. It offers a good amount of flexibility right out of the box, but it certainly has its limitations. If your designer came to you and said, can you build me a color picker like this? A good first step in your thought process should be taking a look at existing views to see if any of them can get you the functionality and appearance you need. In this case, you might consider the progress slider, as it has similar functionality to the design you've been given. You could then examine the various attributes that the slider has for you to play with. If you can get the results you need, great. Just use the widget as it is. Otherwise, you can consider subclassing the slider and adding the functionality you need. This thought process is an important part of developing apps with needs for custom views. Consider the tools you have readily available, and if those aren't sufficient, you can put in the time to make your own. It then becomes a question of which approach to use. In the last module we learned the compound component approach, which is great in many situations. It is, however, very common for features and requirements to change as your app matures. A feature that was previously satisfied with a compound component might change and be better suited to a subclass custom view. As you consider your various options, you can take into account the behavior of the various types of custom views. Where a compound component consists of various existing views bundled up together in a parent container, a subclass view is just a single view with customized behavior. The requirements of your feature will often dictate which approach is better, so it is important to understand the high level differences of each one. When extending a view to make your own view subclass you'll be able to add more customization in both functionality and appearance. It is often simpler to extend and existing view than to create your own view from scratch. When subclassing a view you get to benefit from the existing functionality, and you only need to modify it where necessary. Oftentimes an existing view will get you most of the way and adding a few tweaks in a subclass will be enough. Now let's get our hands dirty and create a custom view by extending an existing view.

Customizing Existing Views
Let's jump into Android Studio and extend an existing view so that we can create a new version of the note color picker. Make sure you've downloaded the project files for this module and follow along. Open up the note keeper project we've been building throughout this learning path. Navigate to the content_main layout file. This is the layout file for the note activity. If you haven't built the project yet you'll need to do that before the layout preview will show up. Here you can see the note screen with the color selector we created in the previous module. The selector works pretty well, and we can define the colors with a custom attribute. However, it can be improved. Having to select Enabled with a checkbox is an extra step that we can avoid. Also, we can't see all of the color options at once. We have to scroll through them one at a time. Let's make a new color selector that allows users to see all the colors at once and is easier to use. Let's start by replacing our previous ColorSelector with a SeekBar widget. This view is already pretty similar to our intended view, so let's see how close we can get with the built-in attributes and options. Set some appropriate margins and spacing and launch the app so we can see what this widget does. Before the app will launch you'll need to go to the note activity and clear out references to our previous ColorSelector. Once you've done that you can launch the app. Go to a note and play around with the seek bar. You can see that it already gives us some nice features, like the ability to drag a thumb left and right. You can click along the widget and the thumb will jump to that point, so this is a good start. Our ColorSelector will need to have discreet stops, and the SeekBar is continuous. Let's go see how to add some stops. Go back to the content_main layout file. Add a value for the attribute called max. This will change the seek bar to be divided into discreet sections with stops in between each one. Max refers to the maximum value the SeekBar can have. Each stop along the widget will correspond to a value between 0 and max. Launch the app and try it out. As you interact with the SeekBar you'll see that you can still drag the thumb back and forth, but it will now snap to the nearest stop. Great. This will work better for our ColorSelector. We will want a visual indicator at each stop along the widget that will correspond to a color. Let's see if we can add some shapes for tick marks. Use the attribute tick mark and assign a drawable of your choice. Run the app and go to the note activity. You'll see a drawable bitmap displayed at each tick mark. There's a split on the selected tick mark, so let's go remove that. On the SeekBar set the attribute splitTrack to false and run the app again. Navigate to the note activity, and we see that the split on the selected stop is gone now. Great. Now we have visual indicators at each stop along the slider. Let's see if we can add color to these ticks so that it can be used as a color selector. On the SeekBar layout add a value for the attribute tickMarkTint. Assign a color and run the app. Navigate to the note activity, and you'll see that the tick marks are all assigned a color. This is close, but the view doesn't have a way for us to specify individual tick mark colors, so we'll have to address that later. Now let's see if we can hide the track, since we really just care about the thumb and the tick marks. Try setting the foregroundTint to transparent and launch the app again. Go to the note activity; nothing appears to have changed. This is because the track color uses a couple different attributes. Go to the SeekBar layout and set both the progressBackgroundTint and the progressTint to transparent. Run the app and go to the note activity. Now both the foreground and background progress tracks are gone. So with the built-in attributes we got pretty close to meeting our needs, but we will need to customize this view further to match our designs. You need to be able to set each tick mark color individually. You should also move the tick marks down below the thumb. Let's create a new class that will extend the SeekBar view. Name the class ColorSlider. Similar to what we did in the previous module, let's take advantage of the JvmOverloads annotation and primary constructor. Let's take a look at what constructor parameters we need to support from SeekBar. Go to the SeekBar class and we see four constructor parameters. Pay special attention to the def style attribute parameter. It defaults to the SeekBar style. We will want to use that style to get the same basic behavior that the regular SeekBar offers. Go back to the ColorSlider class and add all four parameters. Use default values for the latter three, and make sure to use the seekBarStyle for the default style on def style attribute. Now jump to the content_main layout file. We can replace the default SeekBar with our new ColorSlider class. Since we haven't changed anything yet, it should appear the exact same as the parent SeekBar class. Run the app and verify that everything works correctly and looks the same. Now go back to the ColorSlider class and let's start customizing things. Let's start by defining a default list of colors. Use the init block to set the max value. Remember, this is the value that determines how many stops there will be. Set the max to the size of the colors list minus one. If you paid careful attention you noticed that the number of stops on the seek bar is actually one more than the max value. This is because it adds 0 as the first stop. In our case, we don't have a 0, so we just want stops for each color. Therefore, we subtract one. Run the app and go to the note activity. You should see three tick marks. Perfect. This matches the number of colors in our list so far. Now we can set some default values for a few attributes. Set the progressBackgroundTint and progressTint to transparent. Doing this programmatically is a little different than an XML. Here we set a tint list. Use ContextCompat to get a ColorStateList and just use transparent as the color. Set the splitTrack attribute to false. Now you can go back to the layout and remove those attribute declarations from the layout XML. Run the app and make sure everything looks good so far. You should see three stops and no slider background. Okay, to customize further we'll need to override the onDraw method and do some custom drawing. To do that we need to introduce the Canvas.

Intro to the Canvas
When creating custom views it often becomes necessary to draw shapes or letters as part of the view. Android gives us some tools to do that. Let's take a look. First, we have the canvas. The canvas is where we will describe what we want to draw. Whether it's a shape or text, we can use a canvas to draw it as part of our custom view. The canvas has several important details that we will learn as we go. Next, we have paint. Where the canvas describes what we want to draw, paint will describe how to draw it. For example, we might use the canvas to draw a square, and we would use paint to make the square green and have a blue outline. Using canvas and paint together we can draw anything we can imagine onto our custom view. For paint you'll instantiate it manually and set its attributes. For canvas, however, we are given an instance as part of each onDraw call. The canvas will be valid for the duration of the draw cycle until the next draw is performed. In order to draw things onto our view we can override the onDraw call, get a reference to the canvas, and paint things. Let's jump back into Android Studio and get painting. Go to the ColorSlider class and find the onDraw method. Here we get a reference to the canvas. We give the call to super's onDraw method, as we want the parent to draw first. Then we can draw our custom items on top. Block in a method called drawTickMarks and pass in the canvas. Next, let's declare the drawTickMarks method. This is where we'll add our own custom tick marks to the slider. We'll use our reference to the canvas to draw a colored square for each tick. Start by checking if the canvas is null. We can check if the canvas is null by using the safe call operator, which is a question mark followed by a period. This syntax is saying, if canvas is not null, go ahead and call this next function, which, in our case, will be the let function. The let function is one of Kotlin's standard functions and is often called a scoping function. It takes in a lambda expression with a single parameter. The parameter is the object we are calling let on. So all of this code together is saying if canvas isn't null run the code the code inside of this block. Next, grab the size of the colors list and stash it in a local variable. Call canvas.save and stick that in a variable as well. We will learn what this call does in a moment, so for now let's move on. Next, check to see that the color count is at least one. Then we will iterate through each color and draw a tick mark for it. Start by defining a width and a height for the squares. We will just use 48 here. When you're working with custom views the unit of measurement is physical pixels, so by assigning 48 to the width and height we are saying that we want each square to be 48 pixels tall and 48 pixels wide. We will come back to this concept of units of measurement later in this module. Next, calculate half the width and half the height for each square. We will use this later when drawing the squares. Next, let's calculate the spacing in between each square. We want the spacing to be even and to work for different quantities of colors. First, we should consider the width of our view. This is defined by the layout and layout parameters we set for the view. Grab a reference to the width with a member variable called width. Then we should subtract padding from the left and right sides. When you're defining padding for a view you expect everything to be drawn inside of that padding. Subtract the left padding and the right padding from the width. Remember, we get access to all these values because we are inheriting from view. Now that we have the amount of space we are working with, let's divide it up based on the number of colors. Divide the working space by the count minus one. That will tell us the space in between each square. Convert the count to a float so that our result is a float. We want the spacing value to be a float for when we use it later. Okay, now that we know how far apart we need to space the squares let's get to drawing them. Initialize a paint object. Set the paint's color to the correct color by using our current index. Remember, we're inside of a loop so we can use the index to grab the correct color for the paint object. Now call canvas.drawRect. This is how we will draw each square. Pass in the left, top, right, and bottom size of the square to be drawn. This is telling the canvas how far each side should be from the origin point of where we're currently drawing. For the left side, for example, we'll put a negative in front of the half width value. This will draw the left side of the square left of the origin, half the width of the square away. Do the same thing for the top, then for the right and bottom we will use positive values. These values should be floats. Instead of casting them to floats here let's go back and initialize them as floats instead. Finally, pass in the paint you just instantiated. So this is telling the canvas to draw a square and the paint tells it what color to be. Next, we should call canvas.translate. Think of this call as moving an imaginary pen that is hovering above the canvas. When you call translate you are moving the pen in the x and y plane or up and down and side to side. After calling translate, the next shape will be drawn at the new translated position. Okay, that should be everything we need to draw some squares. Outside of the loop call canvas canvas.restoreToCount and pass in the saveCount we defined earlier. Now let's talk about what canvas.save and restoreToCount actually do. As you're drawing things with canvas you're going to call translate many times and move that imaginary pen all over. If each thing you're drawing is positioned relative to the last that's not a big deal, but what if you wanted to draw another shape or set of shapes that need to be positioned somewhere else? There's not really a way to get the original starting point of the canvas whenever you want, so you would have to undo all the translates you made, which gets very messy. Instead, we can use canvas.save and canvas.restore to count. Canvas.save is like a bookmark. You can save its value to a variable. Then, after you do a bunch of drawing, you can call restoreToCount to reset the position of that imaginary pen. Then you can begin drawing some other shapes. In our case, we are just drawing a row of squares, so there's no real need to reset the imaginary pens position, but I have included it here to illustrate that it's there in case you need it. Great. Now that we're drawing our own tick marks jump back to content_main and delete the tickMark and tickMarkTint attributes. Run the app and let's see what we get. Go to a note and you'll see the color slider with three differently colored squares. That's good progress. We have a square for each color in our list. However, the squares aren't quite positioned correctly. Notice how they aren't centered. They do have good spacing spread out across the slider, so our spacing formula appears to be working, but we need to center up the squares.

Coping with Clipping
The reason the shape and size of the squares looks off is because of clipping. We drew the squares the correct distance apart and with the correct size, but we didn't center them up inside the view bounds. We started drawing in the corner and just moved horizontally drawing each square. The result is that the parts of each square drawn outside of the view bounds get cut off or clipped. To fix this we need to draw the squares a little to the right and a little down. This will center up the squares and prevent them from being clipped. We can adjust our drawing position by using Canvases translate method. In order for our drawing to be in the correct position we need to move that imaginary pen to a good starting position. Above our drawing code call canvas.translate. For the x dimension let's move the starting position to the right, accounting for the view's left padding. For the y dimension let's move the starting position right in the middle of the view. Do this by dividing the view's height by two. We need to cast both of these values to floats. This should start our drawing in the correct position and each call to drawRect will be drawn relative to the last translate, so they should all be positioned correctly. Launch the app and check it out. Go to a note and we see that the squares are now perfectly centered at each stop. We successfully moved that imaginary pen to a good starting position and then drew each square relative to that with successive translations. Okay, now let's move the squares down so that the thumb isn't covered up. In our initial translate let's move down by 50. Run the app and go to a note. The squares moved down, but they are being clipped. This is because the size of the view didn't change. When you're doing your own drawing on a custom view you're responsible for changing the view size if necessary. In the init block call setPadding and change the bottom padding to add 50. Run the app and go to a note. We now have some more space and see more of the squares. Before we adjust further, let's change the thumb to use the drawable we actually want. Then we can go back to adjusting the square positioning if necessary. We can set the thumb in the init block. Go to the drawable folder and add a new vector drawable. Select a down arrow triangle shape. After you import that open up the drawable and change the fill color to a dark gray. Change the width and the height to make it a little taller and easier to see. Then go back to the ColorSlider class and set the thumb to the drawable you just imported. Run the app and go to a note. Great. It looks like things are lined up well with the new thumb drawable. Now let's add support for a list of colors as a custom attribute, just like we had in our last color selector.

Using Custom Attributes
Go to the attributes file in the values folder and change it to look like this. We added a declare-styleable for the ColorSlider and pulled the color attribute out. You can't have the same attribute declared twice with the same name, so by pulling it out both declare-styleables' can use it. After you have that attribute defined go to the content_main layout file and add the colors attribute to the ColorSlider. You can reference the color array we defined in the last module in the strings file like so. Go to the ColorSlider class and grab the colors attribute as a typedArray. Convert it into an array list of colors using the map operator, which will parse each color from a string to an int. Finally, don't forget to recycle the typedArray. A common approach to this is to put all the custom attribute code in a try block with the recycle happening in the finally block. That way you're guaranteed to call recycle. Now run the app and go to a note. We can see the list of colors represented with the various tick marks. The number of stops has increased to match the number of colors. Our color slider is looking really good and is almost finished. Now we need to add another stop for when the user doesn't want a color. Go back to the ColorSlider class and add transparent to the first spot in the colors list. Do this after you've gathered any custom attribute colors.

Selecting No Color
Now let's import a drawable that can be used to represent no color, since just leaving a blank transparent space might be confusing. Import an X shaped drawable and make it red. In the color slider go to the drawTickMarks method and let's draw the red x before we draw the rest of the colored squares. Check if the index is 0, which means we're drawing the first tick mark, then grab the drawable, and then get its width and height. Wrap half the height and width as well. We'll use this to position our drawing just like we did with the colored squares. In order for the canvas to know how large the drawable should be call drawable? .setBounds and pass in values for each side, similar to what we did for the colored squares. Finally, call drawable? .draw and pass in the canvas. By now we've already positioned the imaginary pen and the canvas is ready to draw. Calling drawable? .draw will draw the red x at the starting position we've defined. Now let's grab the values we defined for the colored squares and pull them outside of the loop since they don't change. Now add an else block to draw the rest of the tick marks. Put the drawing code for the colored squares in here. Run the app and go to a note. We see that the red x is drawn at the beginning, followed by each color. The last thing we need to do is add communication, so that the activity can get the color from our view. We will use a higher order function and lambda for this, just like we did with the previous color selector.

Extended View Communication
Create a method called addListener, which takes in a function. This is our higher order function. We will add the function to a list of functions. Declare a list of function locally to store that. In the init block we can add a listener that fires whenever the thumb position on the slider changes. Call setOnSeekBarChangeListener. We will need to use an anonymous object to implement the onSeekBarChangeListener interface. This interface has multiple methods, so unfortunately we can't use a lambda for this. We won't do anything with the onStartTrackingTouch or onStopTrackingTouch methods, but in the onProgressChanged method we can run our listener functions and pass the selected color. Remember, each item in the listener list is a function. Android Studio gives you this hint here to remind you what the function looks like. Run the function by adding parentheses and pass in the selected color. The progress parameter represents the selected tick mark on our color slider. Now add a member variable for the selected color. Add a custom setter that will update the progress of the color slider depending on which color is passed. This will cause the thumb to jump to the correct tick mark when the activity sets the view selected color. Go to the note activity, and in the onCreate method add a listener to the colorSelector. Pass a lambda expression that updates the local noteColor. In the displayNote method set the selectedColorValue on the colorSelector based on the save note color. Run the app and try it out. We can now go to a note and easily select a color. The color is saved and shows up in the notes list. This new selector makes it easier to see all the color choices and is easier to use. Next, let's go over some considerations to keep in mind when you're extending a view.

Considerations When Extending Views
When you extend a view to create your own custom view there are some important things to keep in mind to ensure that you get the most out of your new widget. First, let's talk about performance. When extending a view you will often need to override methods like onDraw. These methods are a double-edged sword. They give you a lot of power to draw custom things on your view, but you can easily end up with poor performance and a laggy widget that results in a poor user experience. As you're building your view take time to take a step back and examine your code to see if there are ways to improve your widget's performance. A little careful optimization can go a long way. Let's jump back into Android Studio and look at our color slider code to see if there's some simple optimizations we can make. The first place to look is the onDraw method. The onDraw method can be called many, many times, and is often the source of poor performance. Our onDraw method is making a call to drawTickMarks, so let's check that out. In our drawTickMarks method we are initializing several variables that aren't really changing. We can pull those out as a member variable instead. We're also instantiating a paint object in every draw call, and actually multiple times per draw call since it's inside this loop. Paint is an expensive object, and you should avoid instantiating it inside the onDraw method. We can initialize this object outside the onDraw call method and then simply change it's color here as needed. Let's start by pulling these variables out as member variables. We can initialize them here, and then they won't be needlessly re-initialized on every draw call. Next let's go grab the paint object. That can also be initialized as a member variable. Run the app and make sure everything is still working. While we probably won't notice much of a performance change, since this view is so simple, with a more complex view these kinds of optimizations can really make a difference. Now let's get this drawable set up code and take it out of the drawTickMarks method. Refactor the variable name to be a little more specific. Then let's move this call to get the drawable to the init block. Make a new member variable for this drawable. Now go back to the drawTickMarks method and grab the drawable set up code. Let's pull it out and place it in a custom setter on the drawable member variable. Be sure to initialize the various sizing variables. When the drawable is set those variables will be updated. Be sure to assign the fields value after we've done all the set up. Since we're using a custom setter, we're responsible for actually signing the value. Otherwise, noColorDrawable will remain null. Run the app and navigate to a note. Make sure everything is still working correctly. The drawTickMarks method is much slimmer now and is doing less work every time it's called. These kind of optimizations are a fairly simple way to be more intentional as you build your custom views and can help you to have highly performant widgets.

Supporting Different Screen Sizes
When creating custom views it is important to keep in mind that there are many different screen sizes and resolutions. Part of creating a good, robust custom view is making sure that your view is dynamic enough to work on as many different devices as possible. Here I've created an emulator with a much lower screen resolution than most modern high-end phones would have to test our custom color selector. it's important to remember that not everyone has the latest and greatest phone, and many people will have devices that are several years old. When the color selector is drawn on a device like this we can see that it doesn't look quite right. The tick marks appear larger than expected. Also, the thumb is way too far away from the tick marks. This is happening because in several parts of our ColorSlider code we've used hard-coded pixel values. 48 pixels on one device will look drastically different on another device. This is a long standing concept in Android development. This is why we often use a different unit of measurement than physical pixels. Jump over to the content_main layout file. In many places throughout this layout, and in most layouts, the unit dp is used. DP is a very common unit of measurement in Android development. Originally, you would use it by typing DIP in your layout files, and it was eventually shortened to DP. DP stands for Density-Independent Pixels. This unit of measurement was introduced to account for the wide variety of screen sizes and resolutions. A DP unit is based off of one pixel on a 160 dpi device. So if you use either pixel or dp on a 160 dpi device they will appear exactly the same. On a newer device with a higher resolution, however, 1 dp and 1 pixel will not appear the same size on the screen. Pixel refers to the physical pixels of the device screen. Dp, on the other hand, is a relative unit, so 1 dp on a screen with higher resolution will appear roughly the same as 1 dp on a screen with a lower resolution. More pixels will be used to draw each dp on screens with higher resolutions, so that you can get more consistent results across devices. Let's try this out. Go to the ColorSlider class and create a method for converting from dp into pixels. Remember, when drawing we need to work in pixels, so we'll need to feed pixels to our draw calls. The method should take in a Float and return a Float. Call TypedValue.applyDimension, and for the first parameter pass TypedValue.COMPLEX_UNIT_DIP. This tells the function which unit we are converting from. Next, pass in the value representing the number of dp we want converted to pixels. Last, pass in context.resources .displayMetrics. This will tell the function to use the current device's screen attributes for the conversion. Return the result of the applyDimension function. Now that we have a tool for converting dp into pixels, we can decide what measurements we want in terms of dp, and simply pass them to our conversion function before assigning them. Let's go through our code and find where we've hard-coded pixel values. Starting at the top, we've defined the height and width of our color tick marks. Instead of using the hard pixel value, 48, call our getPixelValueFromDP method. Let's say we want our tick marks to be 16 dp by 16 dp. Next, in our init block we added some extra padding to accommodate the tick marks. Let's also use 16 dp here, and remember, padding has to be provided as an int. Finally, in our drawTickMarks method we are translating our initial draw position. For the second parameter we are moving the imaginary pen down by half the height of the color slider view, plus enough space to draw the tick marks underneath the thumb drawable. Let's use 16 dp here as well. Now that we've changed the hard pixel values to relative dp values, let's run the app on both a high dpi device and a low dpi device. We can see that the view looks great on both devices and has proper proportions. By making sure to accommodate varying screen sizes by using density-independent units of measurement you can have great looking views on many different devices.

Compound Component vs. Extended View
Remember, when you create a custom view it is reusable. You could, for example, combine your color slider with another view and create a compound component, which can then be used throughout your app. Extending a view can be a great choice if an existing view is pretty close to what you need. Subclassing a view takes advantage of the parent views existing functionality. Oftentimes a few simple changes will get your custom view where it needs to be. By extending an existing view you'll rarely have to implement methods like OnMeasure, and that will save you a lot of time. OnMeasure is a more involved method that we'll cover later in this course. Extending a view does have its limitations. It can be hard to stray too far from the parent view's intended behavior and appearance. If what your feature calls for is nothing like an existing view, you may be better off building your view from scratch. Many times an existing view won't publicly expose some of its members or functions. This can present a problem if there's a certain aspect of the view that you want to change and may cause you to have to build your view from scratch.

Summary
In this module we learned the difference between a compound component and extending a view. We discovered how a compound component and extending a view solve different kinds of problems and can be used in conjunction with one another. We learned how to subclass an existing view and customize its appearance and behavior by overriding key methods like onDraw. We talked about the value of leveraging a view's existing functionality where possible. You got an introduction to the canvas and learned how to paint shapes onto it with a paint object. You learned the importance of being conscientious of the work being done in the onDraw method to ensure good performance. We discussed some considerations when extending a view and gave you some tools to analyze when it's appropriate to extend a view versus creating a view from scratch. By identifying an existing view and determining if you can tweak its behavior to meet your needs, you'll be able to decide which approach to take. Next up we'll learn how to create a custom view from scratch for complete flexibility by extending the view class.

Creating Custom Views
Creating Custom Views
Hi. I'm Brendan Wanlass, and welcome to Creating Custom Views where we'll learn how to tackle feature requirements that require completely custom view functionality and appearance. By learning how to create views from scratch you can develop any kind of view you can imagine. We'll start by getting an introduction to custom views and learn how they differ from compound components and extended views. We'll discuss what it takes to make a view from the ground up. Then we'll jump into Android Studio and create a view from scratch using the new custom view template to get started. Finally, we'll use mathematics to add a highly custom appearance to our new view, taking advantage of the onDraw method. Don't be worried if your math skills aren't very advanced. I'll walk you through each step. Let's get started. Creating a view from scratch is typically a more involved process than creating a compound component or subclassing an existing view. However, if your app has a need for highly customized widgets, creating a custom view is the way to go, as it gives you total control and flexibility over your view. We've learned that Android offers a large variety of basic components that you can use in your apps. Most widget needs can be met with these basic components, and they typically offer a small level of customization. We learn how to combine these basic components into a more robust and reusable compound component, which is a great solution for reducing code duplication and pulling view logic out into its own class. We learned that sometimes it makes more sense to take an existing component and extend its behavior by subclassing it and customizing it. This is a great approach if an existing view is pretty close to what you need, and you just need to tweak it a bit to get the functionality you require. We started off by creating a compound component color selector by combining a few views with a checkbox widget. We then evolved the color picker by extending a progress slider to create a color selector slider. This provided more custom behavior and functionality and a more usable widget. Now your product people will come to you with new designs. They need even more customized behavior and a fun to use color selector, which acts like a radial analog dial. This will be the final iteration of the color selector, and we will spend the rest of the course building this widget from scratch. This color dial design doesn't match any existing Android widget, so we can't reasonably extend an existing view to get the functionality that we require. It also wouldn't make sense to try and create a compound component for this widget because the behavior would be difficult and inefficient to implement by grouping many views together. Instead, we will extend the view class directly, which will give us the flexibility to implement the widget how we need to. Since we're building the view from scratch we will be responsible for implementing all of the measuring, drawing, and interactivity logic. We'll go over our two _____ methods of the view class, onMeasure and onDraw. The onMeasure method is where we'll tell the system how large we want our view to be, and the system will tell us how much space we have to work with. This is the place where we'll make sure our view is the correct size. We got into onDraw a little bit in the previous module, and we'll dive deeper during the rest of this course. This is the method where we will create and display all of the visual elements of the color dial.

Creating a View from Scratch
We will use Android Studio's new custom view template to get started with creating our fully custom color dial view. Let's jump in and get started. Throughout this course we've been creating color selector widgets with various techniques and adding them to the note keeper app as a way to color code the notes. Now let's create a custom color dial selector view. Go to File, New, UI Component, and select Custom View. It is recommended to append the word View to the end of your view's name. So let's name our view ColorDialView. Make sure Kotlin is selected as the source language and click Finish. Android Studio will create a few files as part of the new custom view. First, go to the layout file they created called sample color dial view. This file can be used as you develop the custom view as a way to preview things. You'll need to build the project before things will render properly, so go ahead and do that. Notice here that there's still an error here in the message window for the layout that says, Hardcoded Package in Namespace. Go to the text view of your layout and you can see that the app namespace is using the hard-coded path of our project. Instead, this namespace should always use res-auto. The system will sort out all of the imports automatically this way, so change that import now. The system placed an instance of our ColorDialView here in the test layout with some example attributes. Go ahead and delete those sample attributes. Go to the values folder and you'll see that the system also created an attributes file specific to the ColorDialView with some placeholder values inside. Let's go ahead and delete this file. We'll place our custom attribute declarations inside of the existing attributes file later. Now we can go to the ColorDialView class itself. We see various placeholder values that were generated as part of the new custom view process. Let's go ahead and delete those placeholder values now. We also see that the system generated several constructors for the view. It actually created the class in Java and converted it to Kotlin. Ideally, the Kotlin implementation would already use the @JvmOverloads annotation and primary constructor, like we learned in a previous module, but we can make that change here ourselves. This kind of thing will improve over time with new releases of Android Studio and generated files will follow Kotlin paradigms more closely. Now we see an init function. We will keep this and change it to work better for Kotlin. Delete the existing placeholder code. Delete this invalidateTextPaintAndMeasurements placeholder method. Now delete all the placeholder code in the onDraw method. Okay, great. We have a clean slate to start working with now. I've included a graphic as part of the project files for this module called ic_dial. This drawable will be used in our ColorDialView. In the ColorDialView class let's initialize a list of colors that will act as the default colors for the view. Now create a member variable for the dialDrawable and initialize it to null. Create another member variable called dialDiameter and initialize it to 100, which is the default intrinsic size of the drawable. Remember, we need to convert values using density independent pixels, so let's create a method to do that. Create a method called toDP, which takes in an Int value. Call TypedValue.applyDimension. This function will let us convert from DP to display pixels. Pass in TypedValue.COMPLEX_UNIT_DIP, followed by the value. You'll need to convert it to a float here. Finally, pass in context.resources .displayMetrics, which tells the function what screen we want to use for the conversion. Finally, convert the result to an int and return that. Use the toDP function to assign the dialDiameter's initial value. Next, let's grab the dialDrawable and stash it in the member variable. In the init method call context.getDrawable and pass the ID for ic_dial. Let's set the bounds for the drawable right here as well. Remember, the bounds describe the outer perimeter of the drawable, which affects where and how large it is drawn. Use the Kotlin function, also, which takes in a lambda expression. This function gives us a reference to the drawable object after it's initialized and let's us modify it. Let's set the drawable's bounds here in this lambda expression. Stub in a method called getCenteredBounds and pass in the dialDiameter. We will define this method next. Define the method called getCenteredBounds. We will use this to get the bounds for our drawable with the very center being the origin. This method should take in the desired size of the drawable, as well as a scalar, in case we need to scale the size of the drawable up or down. Return a Rect, which can be used to store bounds data. We will keep this method simple and make it only work for square drawables, so we will just take in the one size value. First, figure out the value for half of the desired size. If the size is at least 0 go ahead and divide it by 2. Otherwise, just set the value to one instead. Then multiply the result by the scalar. This will effectively scale the halfway mark correctly. Then convert that to an int. Finally, return a Rect that uses the halfway value to define the drawable bounds. By using negative half for the left and top sides, followed by positive half for the right and bottom we effectively have bounds that place the origin in the middle. This will make drawing things easier. Okay, now that we're getting the dialDrawable and giving it correct bounds we can tint it to the dark gray. Now that we have a drawable we are ready to draw it. Part of drawing efficiently is precomputing as many values as you can so that the work doesn't have to be done in the onDraw call, which can be called many times. So let's precompute the horizontal and vertical size of our view and place those values and member variables. Create member variables for horizontalSize and verticalSize, as well as centerHorizontal and centerVertical, and initialize them to 0. You'll use these values to know where to draw the dial and various other elements of our widget. Then create a method called refreshValues. This is where we'll do the computing, and since it's a method we can conveniently call it as needed. Set the horizontalSize and the verticalSize to be the dialDiameter. Since this is the only thing we're drawing so far this represents the total size of our view in both those dimensions. Next, compute the halfway point or center in each dimension. We want these values because we set our dials bounds to have the origin in the middle, so if we can calculate the middle of our view we can simply draw the dial at exactly that point and it will be centered correctly. Set the centerHorizontal value to horizontalSize divided by two. Set the centerVertical value to verticalSize divided by two. In the init method call the refreshValues function. This will initialize those member variables so we can use them in the onDraw method. Okay, we have our drawable, and we have calculated where to draw it. So now let's actually draw it in the onDraw method using the canvas. In the onDraw method call canvas.translate. For the first parameter pass the centerHorizontal value we calculated. Second, pass the centerVertical value. This will move that imaginary pen to the very middle of our view. Next, call dialDrawable? .draw and pass in the canvas. Make sure to use the null safety operator here so that the call won't happen if the drawable is null for some reason. This should draw the dial right in the middle of the view space we've defined. Change the init function from a normal function signature to instead use a Kotlin init block. This will now automatically get called when the view is initialized. Build the project and go to the sample color dial layout. We see the dial has been drawn right in the top left corner. Perfect. Notice how the ColorDialView has hard-coded dimensions of 300x300. So far we haven't taken into account the size of the view. We just said, I'm going to draw something that is 100x100, and we'd move the canvas to that point for drying. Go ahead and remove the background attribute on the ColorDialView because we don't want to have a background. Perfect. We're drawing the dial in the correct position using precomputed values. We're off to a great start. Next, we'll add the circular tick marks around the perimeter of the dial.

Drawing with Math
Mathematics is a very important part of programming. When working with graphics and rendering it becomes even more important. The more custom and exotic a view you create the more math you will probably have to use. We're going to use a bit of trigonometry and algebra to draw tick marks around the color dial view and for other functionality as well throughout this course. I highly recommend brushing up on those math skills in general, as they will help you become a better programmer and enable you to solve more complex problems, but don't worry if it's been a while since you took a math class or you've never even learned those subjects. You'll still be able to complete this course. So far we've drawn a circular dial in our custom view. Now we'll need to add circular tick marks evenly spaced around the perimeter of the dial. Users will eventually be able to rotate the dial and select one of the colors on the perimeter. We also need to make the view robust enough to handle different quantities of colors without having to add lots of extra logic and code. By using a bit of math we'll be able to accomplish this relatively easily. So far the dial fills up the entire view. We haven't accounted for any padding yet. We want to add some extra padding around the dial to make room for the color tick marks. After we add some space we can begin to draw circles of different colors. Our strategy for drawing the circles will be this. We will start by drawing one circle directly above the dial, right in the middle. We can then rotate the canvas by the appropriate amount and draw the next tick mark in the exact same place, right above the dial. To know how much to rotate the canvas we will simply take 360, which is how many degrees make up a circle, and divide that by the number of colors we need to display. So if we have 8 colors that would give us 45 degrees. We can rotate the canvas by 45 degrees and draw the next tick mark. This will evenly space each tick mark around the perimeter of the dial. Let's jump back into Android Studio and draw some tick marks. To start off we'll need to set up some more member variables and precompute some additional values. First, declare a member variable called extraPadding. This will be used for that extra space needed to draw the tick marks. Initialize it to 30 pixels using the toDP method. Next, declare a variable called tickSize. This will be used to draw the tick marks. Initialize it to 10 pixels with the toDP method and convert it to a float. Later when we use it we'll want it as a float. Next, declare a variable called angleBetweenColors. This is where we'll store the number of degrees we need to rotate the canvas by based on the number of colors we need to draw. Initialize it to 0 for now. Next, make member variables for the total padding values. These will represent the view's normal padding plus the additional padding space or the color tick marks. This will be useful for things like knowing where to draw the dial. Initialize these to 0 for now. Next, create a variable called tickPositionVertical. This is how far down from the top of the view we will draw each tick mark. Initialize it to 0 for now. Go to the refreshValues method and let's precompute some values. First, let's compute those total padding values. For totalLeftPadding calculate the left view's padding plus our extra padding. Convert the result to a float and assign it to the totalLeftPadding value. Repeat this for top, right, and bottom making sure to use our corresponding padding values. Next, let's compute the tickPositionVertical value. We will take the view's normal top padding and add half of the extra padding. This will effectively let us draw the tick mark below the top padding and right in the middle of our extra space. Now we need to update the centerHorizontal and centerVertical values to account for the view's normal padding, as well as our extra padding.

Padding and Positioning
One thing that you need to consider as you build a custom view is how that view will behave when it's resized. If the view is declared to match parent, but the actual widget only takes up a portion of the view, by default, it should typically sit in the top left corner of the available space. You could add support to position the widget within the available space, such as an attribute that could center it. This is commonly found in existing Android widgets, such as a text view where the text can be center aligned. For this course we will forgo support for aligning the widget and let it remain left and top aligned. That being the case, we will calculate the horizontal center of our widget like so. We will start by taking the totalLeftPadding, which is the left padding plus the extra padding, and add to that the total horizontalSize of the view, which is both left and right padding and left and right extra padding added to the diameter of the dial. Minus the totalLeftPadding and the totalRightPadding. Next, divide that by two. This effectively causes us to draw to the right of the left padding and right in the middle of our desired draw area for the dial view. The same calculation will be applied for vertical measurement. Update the centerHorizontal value by using the calculation that was just described. TotalLeftPadding plus horizontalSize minus totalLeftPadding minus totalRightPadding divided by two. Do the same thing for the centerVertical value, but use totalTopPadding plus verticalSize minus totalTopPadding minus totalBottomPadding divided by two. Now for these calculations to be correct we also need to update the horizontalSize and verticalSize values. To calculate the horizontalSize add the left padding, right padding, both the left and right extraPadding, which are the same value, so just use extra Padding multiplied by two, and the diameter. Do the same thing to calculate the verticalSize, but use paddingTop and paddingBottom instead. Now that we've updated our calculations to account for all the padding, go to the init block and calculate the angleBetweenColors value by dividing 360 by the number of colors.

Painting Circles
Great. We've computed the values that we need to draw the tick marks, and we can get to painting, but first we need to initialize a paint object. Declare a member variable called Paint and initialize it. Use the also function to make the color default to blue, and set isAntiAlias to true. If you navigate to the setAntiAlias function you can see a little bit about what it does. Basically, it will smooth out the edges of the shapes we draw. Now go to the onDraw method and we can begin painting. Call canvas.save and stash it in a local variable. We will actually put this value to good use this time. Next, call colors.forEachIndexed. This will let us iterate through each color and also give us the corresponding index. Inside the loop update the paint object's color based on the current color in our loop. You could use the color from the loop directly here or use the index to grab it from our colors list. We will need the index later. That's why we're not using the normal foreach loop without the index. Now that we've assigned the correct color let's call canvas.drawCircle. Pass in centerHorizontal for the first parameter. This will tell the draw call to happen right in the middle of our view in the x dimension. For the second parameter pass the tickPositionVertical value that we calculated. This will draw the circle below the top padding and right in the middle of the extra padding we provided. Next, pass in the tickSize and the paint object. Now that we've painted the circle in the correct position, let's rotate the canvas in anticipation of the next iteration of the loop. Call canvas.rotate and pass in the angleBetweenColors value that we calculated. The next two parameters tell the canvas what point to rotate around. We want to rotate around the very middle of the view, so pass centerHorizontal and centerVertical. Now outside the loop call canvas.restoreToCount and pass in the value we saved previously. This will reset the canvas to the position it was in prior to all those rotates we made to draw the tick marks. That way the dial drawing code can remain unchanged from what we had working previously. Assemble the code and go to the sample color dial view layout. We can see that the dial is drawn and the color tick marks are drawn all around the perimeter. We can see also that the view is now respecting the declared padding. We can change the padding and see the view respond accordingly. Now let's add a tick mark for no color selection. We'll use the same red x drawable from the previous module. In the ColorDialView class create a member variable called noColorDrawable and initialize it to null. In the init block grab a reference to the noColorDrawable and assign it to the member variable. Use the getCenteredBounds method to get bounds for the noColorDrawable. Pass the tickSize for the first parameter and let's scale at the size of the x by passing two for the second parameter. Next, add TRANSPARENT to the beginning of the color list. Now that we have our noColorDrawable and we've added TRANSPARENT to the color list let's go draw the red x as one of the tick marks. Go to the onDraw method. In the colors.forEachIndexed loop add code to check if we are on the first index in the list. If we're on the first index we'll draw the red x. For the rest of the indices we'll draw the colored circles. Call canvas.translate and pass centerHorizontal for the first parameter and tickPositionVertical for the second parameter. These are the same values we're using to draw the circles. This will move that imaginary pen to the correct position. Next, call draw on the noColorDrawable. Next, let's translate the canvas back by passing the same values but negated. This resets the canvas back to where it was so that the colored tick marks will still be drawn in the correct position. This is an alternative to calling canvas.save and canvas.restoreToCount. Since it's just one translate needing to be undone it's easy enough to do it manually. Put the code for drawing the colored circles into the else block and we should be squared away. Assemble the project and go to the sample color dial view layout. We see that the x is drawn at the top followed by each of the colored circles. Our code for spacing out the tick marks evenly adapted to the new number of colors and displayed everything correctly. So our view is pretty responsive to padding changes and changes of the number of colors. However, if we go to change the layout_width or layout_height to something like wrap_content the bounds of the view do not know what to do, so they expand all the way out instead of wrapping around our color dial view. This is because the system doesn't know how much space our view wants to take up. In the next module we'll learn how to measure our view so that it has correct sizing. We'll also learn how to handle cases where there's not enough room to display our view.

Summary
In this module we got an introduction to completely custom views and learned that when a high level of custom behavior or appearance is required extending the view class directly and building your view from scratch is a great approach. We jumped into Android Studio and started building a color selector dial from scratch. We learned that using a test layout to get a preview of the view as you build it is a great way to save time, since you won't have to build the app every time you want to see a change in the view. We learned that the Android Studio design tab will reflect padding and positioning changes in real time, as long as the project is assembled with the latest code. Then we use some mathematics to draw colored tick marks around the center dial. We learned that pre-computing values, where possible, continues to be important as views become more complex. In the next module we'll learn how to make the ColorDialView more robust by overriding on measure and getting correct sizing set up for the view.

Custom View Positioning and Sizing
Custom View Positioning and Sizing
Hi. My name is Brendan Wanlass. Welcome to Custom View Positioning and Sizing. When building a custom view it's important to make its sizing flexible and customizable, so that it will work in a variety of layout compositions. In this module we'll add this functionality to the color dial view we've been building for the NoteKeeper app. We'll begin by gaining an understanding of how onMeasure works and why you need to implement it in your custom views. We'll then use that knowledge to add measuring to the color dial view we've been building. This will let the system know how large the dial is when placing it in a layout. We'll add some customization to the color dial view with custom attributes, leveraging the skills we gained in previous modules. By allowing the color dial view to be customized it will be more useful in more situations. Finally, we'll make our view size flexible so that even if there isn't enough room for our desired size we can still see the full widget and use it correctly.

Understanding onMeasure()
The onMeasure method comes from the view class. When creating a custom view it is important to override the onMeasure method and implement custom measuring logic, so that the view can be drawn correctly and interact properly with the other views in a layout. Up until now our color dial view isn't telling the system how large it is, so we can't properly add the view to a layout and expect good results. This is because the system has no way of knowing how much space our view wants to take up, so it will have trouble placing it in among the rest of the views in the layout. By implementing onMeasure we can tell the system exactly how much space our view wants and the system will try to accommodate it. This will result in more correct bounds for our view and the system will have better results when placing our view in a layout. We can also include padding in our calculations when we go to measure our view. This will maintain the flexibility we've already added to the view. The system is happy to give us all the space we want when ours is the only view on the layout. However, in reality there are usually other views nearby that need to be accounted for when layouts happen. Sometimes those views will conflict with one another trying to take up the same space, so it is your responsibility when implementing onMeasure to come to a compromise. You need to decide how important it is to take up the desired space versus allowing your view to shrink or move a little bit in order to accommodate other views. OnMeasure gives us various tools to help us come to that compromise. OnMeasure is actually called several times in each view before the layout is finalized and the views are drawn. Each of these calls is a sort of negotiation where each view is told what space is available and how strictly that space allotment needs to be followed. Then the view responds by telling the system, okay, based on the available space I'm going to take up this much. Many times other views will adjust themselves to accommodate your view, however, that's not always the case, so it is important to make your view flexible as well. This may include resizing your view so that it can play nicely with the other views. Otherwise, depending on the layout, you may see overlapping or, more commonly, clipping will occur, which will cut the edges off your view so they can't be seen. OnMeasure comes from the view class. We can override it in our own custom view class. It has two parameters, widthMeasureSpec heightMeasureSpec, which are both integers. However, they are special integers. These parameters will be populated with some value like this, which, at first glance, seems unintelligible. These are actually compound bit shifted integer variables. That's a mouthful, but for our purposes all it really means is that the parameter is actually a couple different values encoded into a single integer. It was implemented this way to make measuring more efficient. Each encoded parameter value represents a mode and a size. The size is straightforward. It's just the number of pixels for that dimension, either width or height. The mode could be one of three values; EXACTLY, AT_MOST, or UNSPECIFIED. EXACTLY is used when we define a specific width or height value for our view. For example, if we declare our view to have a width of 171dp that will make its way to onMeasure with the mode of EXACTLY and the 171dp would be encoded in the parameter as well. AT_MOST could be used if we declared our width to be wrap_content. This mode is more flexible and is essentially giving us a range to work with, as long as it's no larger than the encoded pixel value. UNSPECIFIED basically means that we can take up as much space as we want. So onMeasure gives us these two parameters as a starting point for negotiating our actual final size. We are required to call setMeasuredDimension in the onMeasure override. We will pass a width and a height to that call. This is the call that tells the system what our final width and height should be, given the measure specs we received. It's kind of like saying, okay, you gave me your terms, and now here's my best offer. Remember, onMeasure can be called several times, so there might be several passes or negotiation steps. It's up to us to figure out the logic before the setMeasuredDimension call. Taking into account that this logic might be called a few times, we should think of each pass as a refinement of the overall layout negotiation, and eventually every view will have made its best offer. It is then up to the system to draw things as best they can, given the measurements it received.

Measuring Your View
Now that we have a basic idea of what is happening with onMeasure, as the system attempts to lay out our views, let's jump into Android Studio and add some measurement to our color dial view. Go to the ColorDialView class and override the onMeasure method. Remove the call to super. Like the onDraw call, the base implementation of this method doesn't do anything. Now let's come up with our best offer for a width and height based on the measure specs we're receiving. Conveniently, there is a utility method for handling basic negotiation for us. call resolveSizeAndState and pass in the size values we calculated for our view in the last module. Remember, horizontalSize and verticalSize represent the total width and height of our color dial view, including padding. Then pass in the corresponding MeasureSpec. The first parameter is our desired size. In our case, we'd like to take up the full width and height of our view. The second parameter is the system telling us how much room we have to work with given the layout of the other views. The resolveSizeAndState method takes all that into account, examines the mode and pixel value in the encoded MeasureSpec parameter, and comes back to us with a value that satisfies everyone as well as it can. Pass 0 for the third parameter, as we won't be measuring any children views. Then we can call setMeasuredDimension passing in the width and height. This is us telling the system, okay, we looked at the numbers, and here is the width and height we want. If we're lucky, the system will oblige and grant us that space to lay out our view. If not, another call to onMeasure will occur with possibly different measure specs and our code will execute again. If you don't call setMeasuredDimension in onMeasure an illegal state exception will be thrown and the app will crash, so make absolutely sure that setMeasuredDimension gets called with your desired values. Go to the sample color dial view layout where we can preview our color dial. Build the project and we see that the bounds of our view now properly wrap around our widget. Now that we've told the system how large our view is and how much space it should take up it can represent it properly in the layout. We can add some padding and see that the view reflects the new value and the bounds change as well.

Custom Sizing with Attributes
Now that we've got some basic measuring in our view let's add some support for customizing the view so that it works in more scenarios. Our color dial view is currently pretty static, as far as sizing the various elements of the view. Let's add support to resize the dial by changing its diameter. We can also support changing the size of the tick marks and the extra padding they reside in. This will let us define different size values of the view to meet different needs. For example, if we want to have more or fewer tick marks we may want to make them smaller or larger, and as a result, we may need to tweak the padding. Perhaps we want to make the dial smaller to fit a particular layout. By adding some custom attributes we can support changing the size of these various elements. Begin by opening the attributes file in the values folder. Add attributes for colors, tickRadius, tickPadding, and dialDiameter. This will allow us to define custom values for each. Then go to the ColorDialView class and find the init block. Let's grab the styled attributes and put them in a local variable. Make sure to recycle the typedArray in a finally block. First, grab the customColors as an int array. Use the same logic we've used with the color slider and original color selector. If there is in fact a list of custom colors, assign it to our colors member variable. Next, grab the dialDiameter custom attribute. Notice we are using the getDimension method on the typedArray. This will handle converting the custom value to the correct dimension. For the default value pass 100, making sure to convert it to display pixels. Next, grab the extraPadding custom attribute in the same manner. Pass 30 for the default value. Finally, grab the tickSize custom attribute. Now that we're responding to those custom attributes go to the sample color dial view layout and build the project. You'll see the attributes we defined in the list of attributes. Try changing the values and see how the view responds. We can make the dial larger and smaller. We can change the tick size and the tick padding. Notice how the view bounds change and respond as you change those values. This is working pretty well so far. However, if we go to declare a specific width or height for our view part of the view might get clipped. This is because although we are telling the system how large our view wants to be in the onMeasure method we are responding to measure specs that are telling us there simply isn't enough space. We are getting the width and height back from the resolve size and state methods, but we aren't doing anything about the results. We're just passing them on to the setMeasureDimension method. Next, we'll learn how to make our view more flexible so that it can draw correctly under more restrictive sizing.

Making Your View Size Flexible
A good first step and proper measuring of your view is to tell the system how large your view wants to be. But to have a more robust view we need to make it flexible to the constraints it is given. So far we took our view from having no measurement at all to properly supporting wrap content. We did this by providing a basic measurement of our view, but up until now our view isn't able to accommodate more strict layout requirements, and we run into problems if the space isn't large enough for our declared size. Now we need to implement the compromise and negotiation we discussed earlier. We need to teach our view how to resize itself in order to support tighter constraints. Instead of just expecting other views to move out of our way or settling for views that get clipped, let's add support to scale our view size down, so that it can fit into the layout. Let's get to work. In Android Studio go to the ColorDialView class. Add a member variable called scale, and initialize it to one. Add another member variable called tickSizeScaled. Initialize it to tickSize multiplied by scale. Go to the refreshValues method. Here we can apply the scale to all of our measurements. Add a parameter called withScale and make it a Boolean. Create a local variable called localScale. Add some logic that will set our local scale to either the member variable value, if we want to refresh values with the member variable scale or just leave them at their original 1x scale. We will need the option to do either later when we measure. Now apply the local scale to each value. Start with the padding values. Simply multiply the extraPadding by the localScale. Don't multiply the views normal padding because that should stay the same. Now update the horizontal and vertical size by scaling the extraPadding and the dialDiameter. Update the tickPositionVertical by multiplying the extraPadding by the localScale. We don't need to do anything to the centerHorizontal or centerVertical values because the values from which they are derived are already scaled. Set tickSizeScaled to tickSize multiplied by localScale. Go to the init block and update our call to refreshValues and pass true. Now let's add a custom attribute that will allow us to declare if we want the view to scale to fit or not. Go to the attributes file in the values folder. Add a custom attribute called scaleToFit and make its format a Boolean. Go back to the ColorDialView class and define a member variable called scaleToFit and initialize it to false. In our custom attribute, try catch, grab the custom attribute for scaleToFit. Use the getBoolean method on the typedArray. Use false for the default value. Now that we are able to scale all of our dimensions as necessary, let's go add some logic to the onMeasure method that will use those values and better negotiate our size needs. In onMeasure, at an if else block it checks if scaleToFit is true. Put our existing measurement code in the else block. If scaleToFit is false we will just use the simple measurement logic that we started with. Now add a call to refreshValues passing false. This will update all the dimensions with their default 1x scale. We want to begin our negotiation with the default 1x scale because it just might fit, and if so, we won't need to resize anything. Now pull out the specWidth and specHeight from the widthMeasureSpec and heightMeasureSpec parameters. Remember, these parameters are encoded values and we can extract both the mode and the pixel values from them. Call MeasureSpec.getSize and pass in the corresponding parameter. This will extract the pixel value from the parameter. Now to start our negotiation we need to determine how much space we have to work with. Define local variables, workingWidth and workingHeight. Take the specWidth and height that we extracted and subtract the view's normal padding. Now that we know how much space we have to work with we can figure out how much we need to scale our view, so that it will fit in the available space. If our view wants to be 100 pixels wide, but the available space is only 50 pixels, we can divide our view size by the available space or 50 divided by 100. This gives us 0.5, which is the ratio by which we will multiply our view; 0.5 becomes our view scale. We will use it to resize our view so that it can fit into the available space without clipping. Set the scale member variable by dividing the working space by the size of our view minus padding. This will give us the ratio, which will be our scale. We want to use the shortest dimension for our scale, so if width is less than height use that to get the scale. Otherwise, use height. Now that we have a scale we can begin resizing our view. Update the dialDrawable's bounds by multiplying the dialDiameter by the scale. Update the noColorDrawable's bounds as well, but use the tickSize instead. Now that we've done our negotiating, we need to determine the width and height that we will pass to the setMeasuredDimension method. Call resolveSizeAndState and pass in the horizontalSize and verticalSize and make sure to apply the scale. Pass 0 for the third parameter, as we won't be measuring any children views. Now call refreshValues, but this time pass true. This will update all the dimensions of our view with the scale with the assumption that our offered measurement will be accepted. Finally, call setMeasuredDimension and pass the width and height. Now our onMeasure implementation can be more flexible and our view will resize itself if the scaleToFit attribute is set to true. This will enable us to use our view in a much wider range of situations. The last thing we need to do is go to the onDraw method and update our draw call for the color tick marks. Instead of tickSize, pass tickSizeScaled. Now go to the sample color dial view layout and build the project. You will find a new attribute for scaleToFit. Set it to true and change the layout's width and height values. We see that the view resizes itself to fit into the new dimensions, making our view much more flexible. You can also change the padding values and the view will continue to respect those.

Summary
In this module we gained an understanding of the onMeasure method. We learned that it expects us to negotiate our view size with the measure spec parameters and that the system plays intermediary between all the views in the layout, trying to accommodate each one. We learned how to perform a basic measurement of our view, so that wrap content accurately captures our view's bounds. We learned that a simple measurement without negotiation will limit your view's ability to display correctly under limiting size constraints. We learned that by adding custom attributes for sizing the various elements of a custom view you can provide a more robust view that will work in more situations. Finally, we learned the importance of making your view flexible, so that it can collaborate with the other views to obtain a successful layout. We learned how to scale our view down as a part of the onMeasure negotiation. Next, we will complete the color dial view and use mathematics and gesture listeners to make the color dial view interactive so that users can select a color by rotating the dial.

Making Your Custom View Interactive
Making Your Custom View Interactive
Hi. I'm Brendan Wanlass, and welcome to Making Your Custom Views Interactive. Making your views intuitive and enjoyable to use is a great way to increase the overall quality of your app. It will help users to navigate through your app and engage with your features comfortably. In this module we'll add some interactivity to the color dial we've been building. We'll start by learning about motion events and how to handle them. We'll discover how to gather the coordinates of user inputs and explore a strategy for using that input to make the color dial view interactive. We'll then jump into Android Studio and apply what we learned to the ColorDialView class. We'll use some trigonometry combined with user motion events to make the dial rotate, so that users can select a color. Finally, we'll tie everything together. We'll complete the color dial view so that we have a functional custom color picker that works in the NoteKeeper app.

Handling Motion Events
Handling user input is an essential part of a complete functional custom view. The Android framework simplifies things for us by providing motion events, which contain lots of info about how users are interacting with the screen. The basic kind of event that we want to consume in our custom view is a touch event. A touch event can represent a variety of actions, such as a down press or an up press. Every time the user touches, taps, or drags their finger on the view an event gets generated. We can consume those events in our view if they are events we're interested in or pass them along to any other view that may be listening for events. In our custom view class we can override the method, onTouchEvent. This method comes from the view class and doesn't do anything in the base implementation, much like onDraw and onMeasure. The method takes one parameter, a MotionEvent. This is the object that contains a bunch of information about the user touch event. This method returns a Boolean. This Boolean should be set to true if we are consuming the event, meaning we want to use the event and do something with our view. If it's not a MotionEvent we care about we can return false and some other view can consume it. The MotionEvent that we get in the onTouchEvent method will give us all the information we need about the user's touch actions. We can determine things like the X and Y position of the touch event, as well as what kind of action is being taken. Actions could be something like ACTION_DOWN, where the user taps down. or ACTION_MOVE, when the user is dragging their finger. So we'll use this method to capture user input, and based on that input we can rotate the dial on our color dial view. Based on where the dial is rotated to, we will snap to a color and fire off the color selected event. As the user interacts with the dial view events will be generated. These are the events that we will consume in the onTouch event method. The first event we will need to consume for our color dial is ACTION_DOWN. When the user taps down onto the view they may not necessarily go to rotate the dial and instead just tap on a color. We want the dial to jump to that spot. The next action is ACTION_MOVE. As the user drags their finger we want the dial to respond by following the finger around. Finally, we will consume ACTION_UP. When the user lifts up their finger we will stop rotating the dial. When an ACTION_DOWN event comes through we will pull out the X, Y coordinates of the event to know where the user tapped. Also, when ACTION_MOVE events come through we will grab the coordinates. Based on the coordinates we will rotate the dial accordingly. We don't worry about coordinates on ACTION_UP events, we will just use the most recent ACTION_MOVE coordinate to keep things simple. In order to use event coordinates we have to understand how the view coordinate system works. Let's assume we have a view that is 100 pixels wide and 100 pixels tall. The very top left corner of the view is at coordinate (0, 0). That means the X position is 0 and the Y position is 0. If the event takes place at the top and the far right side of the view the coordinates are (100, 0); that is 100 in the X direction and 0 in the Y direction. The X dimension is horizontal and the Y dimension is vertical. If the event takes place at the far left side and at the bottom of the view the coordinates are (0, 100) or 0 in the X dimension and 100 in the Y dimension. If the event takes place in the bottom right corner of the view the coordinates would be (100, 100) or 100 in both the X and Y dimensions. So if an event takes place right in the middle of the view it would have coordinates (50, 50). Based on these coordinates we can figure out how to rotate the color dial. These are called Cartesian coordinates. They take place in two perpendicular planes. If you've taken an algebra or geometry class you've come across a graph like this. This is a graph of Cartesian coordinates. Don't confuse this graph with the view coordinate system. The very middle of this graph has coordinates (0, 0). A view has (0, 0) in the top left corner. We won't be able to use Cartesian coordinates directly for our dial because we aren't moving our dial in the X and Y planes. Instead, we want to rotate our dial around a single point, so we need to take these Cartesian coordinates and convert them to polar coordinates. While Cartesian coordinates deal in perpendicular dimensions, in the (X, Y) plane for example, polar coordinates deal in angles and distance from a central point. This will be more suitable for rotating the dial. We can take the Cartesian touch coordinates and convert them to polar coordinates. This will give us an angle in degrees, and we can rotate the dial to that angle.

Making the Color Dial Interactive
We're ready to make our color dial view interactive. Let's jump into Android Studio and use touch events to rotate the dial to a specific color. Open up the project files for this module and follow along. In Android Studio go to the ColorDialView class. The first thing we're going to do is define some member variables that will be used for handling touch events and for making the dial rotate. Define a dragStartX and dragStartY variable and initialize them to 0. This is where we will store the X and Y coordinates of each touch event. Then define a variable called dragging. This will be set to true while the user's finger is dragging and false otherwise. Next, define a member variable called snapAngle. This will be the angle that we will make the dial snap to. Initialize it to 0. Finally, define a member variable called selectedPosition. This will represent the currently selected position, and we will use it to reference the corresponding color in the colors list. Okay, now that we have some member variables to work with let's go populate them with relevant values. Go to the bottom of this class and override the onTouchEvent method. Remember, this is the method that gets called any time a user touch event happens. Remove the call to super. Set the value of dragStartX and dragStartY by getting the X and Y coordinate from the motion event. These are the coordinates at which the touch event took place. Next, let's check to make sure that the action is one that we're interested in consuming. Check if the action is either ACTION_DOWN or ACTION_MOVE. If so, start by setting the dragging member variable to true. Now we won't actually use the dragging member variable for anything in this view, but it's there to demonstrate that we can define and update some local state based on these motion events. You could add some logic that occurs while the user's finger is down, based on this member variable, for example. Next, check if the action is ACTION_UP, and if so set dragging to false. Go ahead and return true, since we'll just consume all the touch events in this view to keep things simple. For your own views you may want to let some touch events pass through to another view. Next, we need to convert the touch event (X, Y) coordinate into polar coordinates.

User Input Coordinates
Define a method called cartesianToPolar that takes in an X and Y value as floats. Make the method return a float. Fill the method with the following code. This is an algorithm that will use the built-in math class to convert the X and Y coordinates into an angle for us. We will represent that angle as a float and return it. We won't go into the math for this conversion, as it's outside the scope of this course, but remember that custom views often involve this kind of mathematics, and it's worth your time to brush up on them. Okay, great. We are consuming the touch events and we will have a way to get the polar coordinate of the touch event. Now we need to make sure the dial ends up in the correct spot as the user rotates it. As the user rotates the dial they will typically not let go of the dial at exactly the right spot, aligning the selector to the perfect angle, so we need to make the dial snap to the correct angle and, as a result, point at the intended color. This is similar to how the color slider we made would snap to the nearest tick mark. We will determine the nearest color to the dial selector. We will calculate this by recognizing that each color marker takes up a position. For example, this red color is at position one. If the dial is closest to one we will use that, and then we will multiply it by the angle between each color, in this case, 45 degrees. We will then rotate the dial to that angle. Go back to Android Studio to the ColorDialView class. Create a new method called getSnapAngle. For parameters add a float for X and Y. We will feed the motion event (X, Y) coordinates to this method. For the return type use a Boolean. If the snap angle we derive in this method is different than the currently selected color's angle we will return true. Otherwise, we will return false. Start by declaring a local variable called dragAngle. This will be the angle of the motion event based on where the motion event occurs. Use the cartesianToPolar method to get the dragAngle. For our cartesianToPolar method to work we need to convert the (X, Y) coordinates from the Android view coordinates to more traditional coordinates. View coordinates start in the upper left hand corner, but if we pass those coordinates to our cartesianToPolar method we will get an incorrect angle. We need to convert our touch coordinates to more traditional Cartesian coordinates first. (0, 0) in view coordinates is the top left corner, while (0, 0) in traditional coordinates is right in the middle. To illustrate the conversion we have both graphs with a width and height of four. This is just in arbitrary units for demonstration. If we overlay the graphs on top of each other we see that a click on the top left corner would be (0, 0) in view coordinates, and in traditional coordinates it's actually -2 in the X dimension and positive 2 in the Y dimension. So we need to convert our view coordinates of (0, 0) to (-2, 2). We can do this with the following formulas. For X we can take the view coordinate and subtract half the width of the view. So if our view X coordinate is 0 we would get 0 minus half the width of the view, which is 2, so we end up with -2, which matches what we expect in traditional coordinates. For Y it's slightly more involved since the Y-axis and views increments as you go down, and in traditional coordinates it increments as you go up. We can subtract the view's Y coordinate from the vertical size of the view, and then from that subtract half the vertical view size. So if our view's Y-coordinate is 0 we will end up with 2 in traditional coordinates. Using the formulas we just discussed, pass the modified X and Y coordinates to the cartesianToPolar method. This will give us the dragAngle of the touch event in degrees. Next, we need to determine which color to snap to base on the drag angle. We will snap to the nearest color. To do that we need to get the angle of the nearest color. Define a method called getNearestAngle. It should take in a Float and return a Float. Our colors and dial start at the top and go around clockwise, but polar coordinates start on the right side and go around counterclockwise. To cope with this difference we need to adjust the dragAngle. In the getNearestAngle method start by subtracting the dragAngle from 360 and then add 90. Next, if the adjustedAngle is over 360 keep subtracting 360 until it's not. This will effectively convert the drag angle to a value that will work with our dial and tick mark set up. For example, if the drag angle were 90, which is at the top and in the middle of the view in polar coordinates, this formula would convert to 0, which is where our dial and tick marks start. Now that we can get the nearest angle in terms of our dial, go to the getSnapAngle method and create a local variable called nearest. We want to determine the index of the nearest color. So call getNearestAngle, passing in the dragAngle and divide that value by the angleBetweenColors value we derived earlier. Then round that result to an int. This will effectively give us an int that matches the index of the nearest color. Now create another local variable called newAngle. Set it to the nearest value multiplied by angleBetweenColors. This will give us a clean, exact angle to snap to. Define a local variable called shouldUpdate and initialize it to false. Now we only want to update things if there's actually a change in the selected angle, so check if our newAngle is different than the most recently assigned snapAngle. If so, set shouldUpdate to true and set the selectedPosition, which is the position of our currently selected color to nearest, which is the index position of the new color we're snapping to. Assign snapAngle the newAngle value we derived and return shouldUpdate. Now that we've determined which color to snap to and whether or not it's different than the last color we snapped to, go to the onTouchEvent method and call getSnapAngle, passing in the X and Y coordinates of the touch event. If getSnapAngle returns true we know we are snapping to a new color. Since we've saved the new color position in the getSnapAngle method all we have to do to update our dial is call invalidate. This will cause the view to redraw and it will use the updated values we set. The last step to make this work is to actually rotate the dial in the onDraw method. Go to the onDraw method and call canvas.rotate. Pass in the snapAngle, which is the angle the dial will be rotated to, and for the next two parameters pass in centerHorizontal and centerVertical. That way the dial will rotate around the middle of the view. Great. Now that we have logic in place to handle TouchEvents and rotate our dial let's go try it out. Go to the content_main layout file, replace the ColorSliderView with our new ColorDialView. Launch the app and navigate to a note. Here we see our new color dial view. We can click on the view and drag our finger around and the dial will follow it. As we move our finger the dial will snap to the nearest color. When we lift our finger the dial remains pointed to the desired color. We've built our view to be pretty dynamic. Go to the strings file in the resources folder and add a long list of colors. Update the ColorDialView in the content_main layout to use that long list of colors. In the Design tab we can see that the view updates to show all those colors. Increase the dialDiameter to make more space for those color tick marks. Launch the app and navigate to a note. We see that the dial supports the new longer list of colors, and we can drag the dial to select each one.

Tying It All Together
We've come a long way and have built a color selector dial from scratch. The last thing we'll do is apply the same techniques we used in the other two color selectors for communicating events to the activity. In Android Studio go to the ColorDialView class. Create an arrayListOf lambda expressions where the parameter is an int and the result is a unit. Create an addListener function that takes in a lambda with the same signature. Add the lambda to the listeners list. Create a private method called broadcastColorChange. For each listener in the list of listeners we want to broadcast the selected color. Create an if else block. In the if block check if the selected position is larger than the number of colors in the colors list. If so, just use the first color and call the lambda. Otherwise, call the lambda passing the selected color. In the onTouchEvent method call broadcastColorChange in the same place where we cause a redraw of the view. That way we will only broadcast if a new color is selected. Finally, add a selectedColorValue member variable and initialize it to transparent. Add a custom setter and assign a selected position based on the index of the color value. Set the snapAngle by multiplying the selectedPosition by the angleBetweenColors. Call invalidate to cause the view to redraw. It will use the updated values. This will effectively cause the dial to jump to the desired color when selectedColorValue is set. Now go to the NoteActivity class and add a listener lambda in onCreate. Assign the noteColor here. Go to the displayNoteMethod and call colorSelector.selectedColorValue and assign the note color. Watch the app and try out the fully completed custom color selector dial. You can rotate the dial to select a color, and that color is assigned to the note. We now have a fun to use and highly customizable custom view that we built from scratch.

Summary
In this module we learned some of the intricacies of dealing with user input in the form of motion events. We learned that a motion event has a lot of information about each touch event, and we can extrapolate that data into a highly interactive view. We learned that there are different types of built-in actions that we can watch for. We learned that we can either consume those events or pass them on so that other views can consume them. We learned how to take the touchEvent data and apply it to our view with mathematics and custom drawing. We learned that view coordinates are different from traditional coordinates. We learned how to convert from view coordinates to traditional Cartesian coordinates, so that we can then convert to polar coordinates. We learned that polar coordinates are used when rotating objects, and that Cartesian coordinates are used to translate objects vertically and horizontally. Finally, we tied everything together by adding custom listener support so that our color dial view can broadcast color selected events to listeners. We discovered that the same kinds of techniques for communication can be applied to many kinds of views. In this course we learned how to create a variety of customized views, so that based on the needs of your app you can make an informed choice about which view to create. We learned how to take various existing views and combine them into a compound component. We learned that compound components are a great way to reduce code duplication and allow you to pull view logic out into its own class for better reusability and maintainability. We learn how to communicate between view and activity with powerful Kotlin language features, such as higher order functions and lambda expressions. We learned that much of the time existing views are already pretty close to what you need, and by simply extending an existing view you can get the behavior and appearance that your app needs. Extending a view is faster and more efficient than building a view from scratch. Sometimes your app requires a high level of custom behavior and appearance, and in those cases building a view from scratch is a powerful approach that let's you build anything you can imagine. We learned how to extend the view class to build a completely custom view by overriding the onDraw method. We learned the importance of precomputing values and measurements whenever possible in order to have highly performant components. The best views allow users to customize their size and positioning. We implemented support for padding, as well as scaling the view for those cases where the view doesn't fit and we want to scale it down until it does. We tied everything together by learning how to handle user input to make a custom view interactive. We learned that motion events contain a lot of information about how the user is interacting with your views, and that with careful mathematics you can create all kinds of custom behavior. I hope this course has been helpful to you and that you will create all kinds of amazing views for your own apps. I look forward to your questions and comments in the discussion section for this course. I'm Brendan Wanlass, and thank you for watching my course, Android Apps with Kotlin: Custom Views.

Course author
Author: Brendan Wanlass	
Brendan Wanlass
Brendan is an Android and game developer. He has a passion for well designed, engaging software. He was a designer and engineer for the game Magnetic by Nature...

Course info
Level
Intermediate
Rating
0 stars with 3 raters
My rating
null stars

Duration
2h 10m
Released
26 Feb 2019
Share course