Cloud-native Architecture: The Big Picture
by Richard Seroter

Cloud-native is about how, not where. This course will teach you the principles, patterns, and technologies that help you build more scalable, changeable, resilient, and manageable software.

You're asked to build more changeable, available, scalable, and secure software. While cloud platforms make some of those characteristics easier to achieve, it's more about *how* you build software, not *where* you run it. In this course, Cloud-native Architecture: The Big Picture, you'll learn what it means to be cloud-native. First, you'll look at the core principles behind cloud-native software. Next, you'll dive into the key patterns that help us create better software. Finally, you'll review enabling technologies that realize those patterns. When you're finished with this course, you'll have a strong understanding of what you need to do in order to start building cloud-native software.

Course authors
Course info
Level
Beginner
Rating
4.5 stars with 53 raters(53)
My rating
null stars

Duration
0h 51m
Released
20 Sep 2018
Share course

Course Overview
Course Overview
Hey everyone. My name is Richard Seroter, and welcome to my course, Cloud-native Architecture: The Big Picture. I'm a senior director of product at Pivotal, an 11-time Microsoft MVP, and lead editor for the cloud topic at infoq. com. If you're an established company that isn't all in on the public cloud, and honestly, few are, does that mean you can't be a cloud native? Nope. In this course, we're going to debunk that myth and show that cloud native is about how, not where. Some of the major things we're going to include are the core principles behind the ideas of cloud native and how industry leaders define it. We're going to look at the application, infrastructure, deployment, and team-driven patterns that represent cloud-native ideals. And then we'll review the technologies that cloud natives use to deliver better software. By the end of this course, you'll know what it means to be a cloud, and more importantly, what ideas you can start incorporating today to build and operate software that matters. I hope you'll join me on this journey to learn what it means to be cloud native with this big picture course, at Pluralsight.

The Principles of Cloud-native Architecture
What's Expected of Software Today
Hi there. My name is Richard Seroter. Welcome to this module in a course about cloud-native architecture. In this module, we'll talk about what it means to be cloud native and some of the underlying principles you'll want to keep in mind. We'll start off talking about what do leading companies in the industry actually care about when it comes to technology. We'll look at what's expected of some of our software today. I'll actually define cloud native for you. We'll look at the traits of the cloud natives, what do they look like? What does positive progress look like in this software transformation? We'll talk about how cloud native applies to more than just applications before we wrap up. So what do leading companies care about? I took a look at the Fortune 100 and really the Fortune 10, picked a few different companies like Walmart, United Health Group, General Motors, we looked at some of their annual reports and said what do these companies say, what do they say they care about right now. In one case, first quote from their report was hey if we don't timely identify and effectively respond to consumer trends, meaning responsiveness or preferences that could negatively impact our relationship with customers, demand for our products, our market share, and overall growth. So companies care about their responsiveness, how fast are we responding to customer trends and giving customers what they need. In this next one, we rely extensively on information systems to process transactions, summarize results, and manage our business disruption in any of those systems can harm our ability to conduct operations. So in this case, disruption to systems, I need availability, I need scale or else this could have a material impact on what we do. In this case, if the healthcare company, if we fail to develop and maintain satisfactory relationship with physicians, hospitals, other service providers, our business could be materially and adversely affected. So in this case, they're thinking about how do they build good relationship, not just assume the customers and clients will come to them, but instead, properly build relationships often through technology. And then finally, our future competitiveness and ability to achieve long-term profitability depends on our ability to control costs. So all of this isn't about just spending more money and just plowing money into IT. In many cases, it's about being responsible with that and controlling costs and spending money more wisely. So what are some of the things expected of our software today, what are you and I asked for whenever a client and internal team, someone asks us about software, well they're asking for it to be valued and that might seem obvious, but sometimes we get obsessed with just shipping the bits and building something that maybe meets a requirements doc, but really, it's about delivering something people find useful and like using to an extent that they may actually remain a customer or become a long-term customer, invite their friends, do things that are actually useful. We're asked for software that's constantly and easily changed, so no more annual updates, I don't want to tolerate an annual release cycle every few years. Instead, people, their customers expect bugs to be fixed, features to be added, security to be hardened. So we need software that can be changed and we're not scared to change it and something that we can do regularly. Look, we want software that's available at all times. Look at the availability needs. More changes can't mean more downtime. I expect my bank, my auto insurance, my energy provider, movie time provider, I want them to be online all the time, let alone, business critical, mission critical systems. Look, we're expected to deliver software that's scalable to meet need. From a cost perspective, we expect software to scale up as needed and down when it's not. So the software we ship is expected to be scalable, not just for some steady state workload, but to be able to handle the natural ebbs and flows of consumption. We expect software to be secure in all different respects. We're giving all sorts of key data to companies. I expect it to be safely held in transit and at rest, and those sorts of things are just business critical now. And then finally, we expect the software to be maintainable at scale, that means software can't just be run via heroics. I expect software to be managed with a stable or even shrinking number of full-time operators. So it's expected that our software is more functional, more friendly to change, always available, very scalable, secure, and something that I can operate over time.

Defining "Cloud-native"
Let's look at a few definitions. This one's from the Cloud Native Computing Foundation. Basic Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Things like containers, service, meshes, microservices are all part of that approach according to their definition. They'll often say a cloud native system has properties like container package, dynamically manage, microservice oriented, definitely focused on the technology in many of the CNCF definition components here. Another quote is from Joe Beda, one of the creators of Kubernetes and now of Heptio, Joe says, the cloud native is structuring teams, culture, and technology to utilize automation and architectures to manage complexity and unlock velocity. I like that definition. It definitely touches additional aspects of this around, especially the team and the culture, not just the technology. The company I work for, Pivotal, has a strong definition of cloud native. We say cloud native is an approach to building and running applications that exploits the advantages of the cloud computing delivery model. Cloud native is about how applications are created and deployed, not where. So again, it touches on additional aspects, it's not just a tool chain that makes you cloud native or a certain set of technologies, it's often about how you use that in the right patterns, which of course, we're going to talk about in this course. Now if we look at my definition, I typically say when I present on this topic or talk to customers, cloud-native software is built for scale, built for continuous change, built to tolerate failure, and built for manageability. It's really this sort of thing and all of these definitions really come together to paint a picture of what we expect of cloud native. So with those definitions laid out, what are some of the traits of the cloud natives. If you looked at companies, both new and existing, because a cloud-native could be a company from the last three years who uses nothing, but public cloud technologies or some even existing enterprises, established companies who actually behave like a cloud native because of how they've built and run systems, even though they're using private clouds and public clouds and a number of other different types of infrastructures, they can be cloud natives as well. So what do you see? Well, you see that they're customer-centric. Over and over again, you look at cloud natives focus on the customer and the service that they provide to them. They think of the customer needs, they design to maximize the utility of the software. So every cloud native you come across, whether it is an internet, Silicon Valley kind of startup or an established company, when they're acting like a cloud native, they're thinking about the service, they're thinking about the customer, not necessarily IT. Universally, they have a learning culture, not a blame culture. It's about safe, data-driven experimentation and continuous improvement, they incorporate feedback, they remove waste, they're constantly trying to figure out and learn from customers often by regularly shipping code to experiment, to figure out what is the most impactful thing. When things go wrong, they learn from that via post mortems, they learn from retrospectives and try to figure out how they can actually improve so they get better the next time. It's not about just pointing fingers. Pretty universally, the cloud natives use a form of Agile development. I think it's safe to say Agile has won, at least if there's a competition for how we build software, different variations of course, but this idea of iterative delivery of small batches of changes generated from sort of prioritized backlog that seems universally adopted by companies that value velocity and value customer feedback. In this Agile development, you often see security shifted left in the process as well where security is part of the development cycle, not an after thought the day before you're trying to deploy and having a security review. The cloud natives often focus on products, not projects. So you move away from let's assemble a team, build something, ship it, hand it over, and then disperse, and go onto new projects. Move away from that to more ongoing teams. You retain context, you focus on the lifecycle of your service, not just adding features to call the project complete, but instead, building a sort of service that's sustainable and satisfying customer need. The cloud natives really focus on automation of the entire delivery process. They focus on lead time, how long does it take to go from code commit to production. They don't skip the hard stuff, they don't just automate the integration of code, they automate all the way to production, even including things like databases and other more complex changes to the network. So the cloud natives look at the whole process, they try to eliminate waste, which is often all over your deployment process. So how do we make this process repeatable, auditable, effective, and quick by doing automation responsibly from the very beginning all the way until it's running. Finally, the cloud natives are pretty heavy users of open source software. They are typically powered by proprietary stacks. Now of course, that's part of what they have, but open source software is a fundamental part of how the cloud natives operate often due to the flexibility, the contribution back to open source, the ability to use different providers, the flexibility, the portability. You see over and over again cloud natives have really made a big bet on open source.

What Progress Towards "Cloud-native" Looks Like
So we're not acting cloud native just for the fun of it or to add to our resume, we're trying to do some positive outcomes here. So what does it even look like? How do I know I'm getting good at this? What does good progress look like? Well first, you'll typically notice more speed, and not just speed in terms of hey we're delivering every 10 minutes, that is clearly a metric that you're going to keep an eye on, but it's also faster lead times. I'm going faster from idea to production or from code to commit to production. I'm seeing different kind of speed, even to how fast can I get infrastructure to developers, how long does it take to make a change, how long to deploy upgrades? So that sort of speed and velocity becomes really a core part of how you operate. You'll also notice positive trends towards scale. You'll see the web and API response times go down for the systems you're deploying, the effort to scale in and out goes significantly down and the speed in which you can do it improves. The ability to add developers while actually growing productivity. So many of us are use to this idea that as you add more developers, you actually slow productivity because of communication costs, training, some of the complexity, but the cloud natives can add people, and actually linearly, if not exponentially improve productivity. That's not an accident, it's the way they function. And then finally, you also may have scale to add more environments. So can I scale to run more and more environments, multi-cloud, active passive environments. You don't fear those sort of things because you're getting good at software. You'll also notice more stability. How many impact minutes do your customers experience? How long does it take to recover from a failure? What is your mean time to recovery? Is the change failure rate going down? Is there downtime during deployment? These are things, again, you can measure, they can show up on dashboards, they can show up on the wall or in a chart. These are measurements that you're actually getting better becoming more like a cloud native. And then, of course, there's going to be more security. You're going to notice that you have more infrastructure patched in more places, you're not 6 and 12 months behind urgent patches. But how long does it take you to patch? Are you good at that? How old are your credentials in your server environments? When's the last time you rebuilt your virtual machine? Are you more secure because you're constantly replacing the VMs under your infrastructure? And throughout all of this, sustainability plays a part because you can do all of these things again with heroics and burn out your team. So the cloud natives are going to be focused on sustainability and doing the sort of things that eliminate toil, eliminate manual work, and actually, make sure you have a strong work/life balance while also being happy and enjoying what you're building.

How "Cloud-native" Applies to More Than Apps
The final topic I want to cover here, the idea the cloud-native applies to more than just applications. This isn't just about how you build the software components, your. NET app, your spring boot application. There's more to it, there's also things like cloud-native infrastructure. How do I account for more on-demand scalable need where I want to be able to access infrastructure or change a firewall rule or attach some storage, cloud-native infrastructure says look that infrastructure is API driven and we're going to talk about that more, but the idea is that's an important part of this, it's not just the apps, it's what's going to power those apps. Same with the data, if I have this sort of rigid fixed data story and I have to open tickets to update data or add a store procedure, I can't function. As a cloud native, I can't possibly have continuous delivery if I can't also do some sort of automation at my data tier. So I'm going to expect flexible resilient on-demand data services, as well as a cloud native. There's also cloud-native security. I'm going to account for more fast-changing endpoints and more distributed data, not all just behind some centralized firewall, but all over the place, on mobile devices and different cloud environments. And so, I think of security and authentication and all these sort of things a little differently when I'm dealing with these more diverse environments. And then you may have cloud-native integration. Look, you have more volume of data, you've got different sort of speeds of data that you're processing, more endpoints, many of these are SaaS and cloud-oriented endpoints that your traditional enterprise Service Bus wasn't really designed to process. So we'll talk about the implication of all of these components, but it's important to recognize that cloud native isn't just about doing continuous delivery of your Node. js application. It's about delivering the entire system from infrastructure to applications to data and so forth quickly, reliably, more securely, in a way that satisfies the business need.

Summary
So in this first brief module, we did a quick overview. We talked about what leading companies care about and we reflect on that. They care about things that really touch on how we do technology. They care about resilience, they care about responsiveness, they care about security and scalability, and they also care about controlling costs. Because when we look at our software, though we're expecting those things of the software that satisfies those core business needs, we expect things to be changeable and resilient and secured. We defined cloud native. There're also some technical aspects to that that we looked at. There's also some softer team-based sort of oriented things, as well as simply about how we build software, not necessarily where we build it. We looked at some of the traits of the cloud natives, their learning cultures. They build products, not projects, a number of things that hopefully you can emulate as you start to do these sorts of things. We looked at positive progress, we looked at how companies will notice an improvement in speed, scalability, security, stability, while also, maintaining sustainability. And then finally, we talked about cloud native applying to more than apps. This touches on more things than just the software you're writing. It's also the supporting machinery that makes your system run effectively. I hope you enjoyed this module. In the next one, we're going to look at some of the core patterns that make up cloud native.

The Patterns of Cloud-native Architecture
Introduction
Hey, my name is Richard Seroter. We're in a course about cloud-native architecture. This module focuses on the patterns you'll apply in your journey to become a cloud native. First off, we're going to spend some time on application architecture patterns, what are the things you have to think about when you're building the software. Then we'll switch and look at application delivery patterns, what does it mean to build and ship that software to production. We'll also discuss some application infrastructure patterns, the thing that really are any environment that your software runs in. Then finally, we'll look at application team patterns as you're actually functioning as a team, what are some of those core things you're going to want to do to support those other areas. And then we'll wrap up summarizing some of the patterns we've discussed in this module. As a reminder, using my definition, cloud-native software is built for scale, built for continuous change, built to tolerate failure, and built for manageability. If you do those sorts of things, you're moving in a cloud-native direction.

Cloud-native Application Architecture Patterns
So first out of the gate, let's talk about application architecture patterns. So the first pattern category you'll look at is 12-factor applications. Heroku came up with this definition of 12-factor apps a few years ago. Basically, it's a set of criteria to help you measure how friendly an app is to really run on some quality sub straight, whether that's a Platform as a Service or even Infrastructure as a Service containers. When you build apps to be 12-factor compliant, you have some confidence that these are going to run well in a cloud set of infrastructure. So what are those factors? Well, the first one is one code base in source control. Really, each application is tracked in a code base in some sort of revision control. You might have more than one instance of that software in different environments, but you have that one sort of code base to go back to. The second one is around declared dependencies. An app calls out its dependencies, instead of depending on them just being there in the target environment. We've all built software in the past that assumed things were running on that Windows machine or Linux machine and you kind of tap into that. A 12-factor app brings along its dependencies because it doesn't know what's there and doesn't want to depend on it. The third one is around configuration. Really, configuration being anything that differs among the environments, think connection strings, think feature flags. In this idea, they're injected via operating system environment variables. Now you might not like environment variables, but this can also really mean an externalized configuration that you might reference something in source control and something with an actual change history, but the idea is pulling configuration out of your code and putting it into some sort of remote store if it's the environment or a remote configuration store. The next ones are backing services, things like databases, message queues, they're treated as attached resources, not some sort of embedded tightly coupled resource. This makes it easier to swap when changing environments. You've got separate built-in run stages, the idea that the stage to build the artifact and then deploy it and operate it, these are all separate stages of processing. It doesn't all happen in the same place. The next one is apps executing as stateless processes. So make sure nothing between the app instances, all the state is outside the app process itself. The services are exported as port bindings. Really, the idea here is that the application is kind of self-contained and any services are exposed via ports like HTTP. The next one is around horizontal scale, so you scale-out via processes. You don't make bigger processes, you scale-out to more and more of them, a very, very cloudy concept. The next one is around disposability. What this really means is an application should start quickly and shut down gracefully. This is necessary when you think of quick autoscaling or failure recovery, that if it takes me 10 minutes to start up my app, it really doesn't work well for an autoscaling environment that by the time I've scaled, maybe the incident's over. And same with failure recovery. If I have to assume that instances can disappear when something gets rebooted or restarted, I have to know that I haven't somehow corrupted my application. So I want to build apps for disposability. The next one is around environment parity. So automation and continuous delivery helps you keep all your environments in sync. You don't end up with this works on my machine problem. For the next one, instead of log files, logs are a stream, they get collected, they get aggregated, analyzed, much different than just logging into an individual machine and looking at a log file or an event log on a Windows box. Instead, it's a different way to think about processing logs at scale. And then finally, admin process. You think of admin processes like migrating a database or things like that. When you run these long-running processes scripts, what have you, run the environments identical to the one that's running the app itself. So this is one set of patterns, or really, one pattern as a whole around 12-factor apps that's pretty common. Next, you have the microservices architecture pattern and this idea of decomposing systems and you find those boundaries often via domain-driven design. So you model these systems based on some sort of reality of your business and you might try to figure out the boundaries in different ways. For example, you could look at the events to figure out what happens in this particular context. But the idea is you're carving up services into more discreet units. These components are all very loosely coupled, they're independent, and while they may come together to form a system, you still use something like a messaging backbone to actually bridge them. This helps keep them loosely coupled so that you can independently update each service. One of the differences between microservices architecture and old service-oriented architecture is that traditionally continuous delivery wasn't really part of that, but the point is you're designing microservices to be updated regularly, or at least be capable of it. So that's a little bit of a difference from classic SOA. One of the benefits from that is even surgical scaling. By that, I mean when I have a monolithic app that I need to scale, let's say consumption is going up, I'm seeing resource contention, what do I do. I scale the whole thing. I could take a copy of that application and I run it on more machines potentially or maybe get a bigger machine. I'm forced to scale the whole app because maybe one piece of it is under load. In our microservices architecture, I might just independently scale these services that are doing let's say intensive data processing while not scaling anything else. So I can do this more specific targeted scaling because I've decomposed my app in a smart way. Now testing these systems can be more difficult. I've got more components, I've got, again, this loose coupling maybe with messaging in there and I might use mocks, I might use contract tests though, or consumer-driven contracts where services run tests based on what's expected of them. So you think of different ways to potentially test these systems in a reliable fashion. Another difference with microservices again from classic SOA is that you often see teams arranged around the microservice or the set of microservices, whatever the boundary is. And so, again, this is really as you think of DevOps, you think of continuously updating the software by a steady managed team, that's often what you think of in a microservices world. To successfully use microservices, there's often some supporting infrastructure here that makes these microservices more successful. One of those is service discovery. How do you find these constantly changing scaling set of services? When I have a set of services that may go from two instances to 20 back to 4 back to 1, all of a sudden, I can't have a classic configuration management database where I'm putting the name of my service and the 3 servers it sits on. It's going to be stale every 5 minutes. So instead, I have to think of a different way, really almost the phone book for microservices if I can, how do I look up services at runtime to figure out their addresses? The next one's a circuit breaker. Again, when I'm building microservice and I have more services and I might have some cross dependencies here, cascading failures can be a problem. One service degrades or goes offline, it impacts maybe dozens others. So in a circuit breaker pattern much like with electrical circuits, the idea is I might short a circuit and prevent any more things going there so I actually don't damage the overall systems. So I might use a bull cat sort of strategy where the failing service actually gets cut off and some sort of fast fallback mechanism like cached results or static values come back instead. We touched on this with 12-factor apps, but some of the supporting infrastructures about externalize configuration, you yank those environment specific configurations into a remote version control store. This makes it easier to change behavior and production in other environments and ensure that all the instances of your application are actually using the same configuration values versus something that might be in a per application instance configuration file that could fall out of sync. For microservices, you often also see a token-based security model instead of an operating system specific identity management solution. You want cross-platform mechanisms to authenticate and authorize your users. You also won't be surprised to see messaging components part of this now microservices architecture. This helps with the routing and sequencing of certain activities as I exchange data or I synchronize information or simply send commands between different functions, whatever it might be, messaging is usually part of a microservices infrastructure. And then you also have something like an API gateway, some sort of mediation is important for the services themselves. You might introduce response caching, maybe some light payload transformation, token exchanges from one sort of security paradigm to another. Pretty common to see API gateways also supporting your microservices. The other patterns you see around modern data management. So with modern data management, one of the first things you hear about is databases, and often the recommendation is that a database for every microservice to avoid the challenges you face with shared systems and trying to synchronize schema changes or figure out dependencies. Now this isn't always possible and it's not even reasonable if you don't have some sort of automation centric on-demand databases available. So when I think of operating as a cloud native, I think of more than one database instance. I may have dozens, hundreds, or even thousands, or maybe scoped to a domain tied to a given microservice, but it's often very automation powered. I also may favor different sort of event definition models and access patterns, so there, of course, there's still a place for regular storage and query semantics in a relational database, but increasingly, I've seen cloud natives think in terms of event streams which impacts how you collect, store, and query your information. With event sourcing, you store this raw sequence of events, and in the command query responsibility segregation pattern, you write commands to the event store and queries are done against that store, another one that's maybe normalized or structured differently. Upon requests for the stay, the object's inflated almost by replaying the event's sequence and this gives you some benefits of being able to do other replays and give you actual full audit trail of transaction, so it's a pretty popular way to try to do this, but it does add its own complexities. So plenty of applications still can function with the regular sort of data storage and access mechanisms. And then finally, you'll often see a pattern around caching and thinking about resilience. So how do I prioritize availability in my systems often by adding caching layers that offer smarts for things like right behind behavior, triggers, other things that I want out of a cache that also make it easier for my data systems potentially get changed more regularly without actually breaking my applications because the cache sits in the middle.

Cloud-native Application Delivery Patterns
Next up, let's talk about some of the application delivery patterns now that we've talked about architecture. So first off, it's really around continuous integration and we think about getting fast feedback by constantly testing my software. So first off, version control is a must. I need to be able to build from a trusted source, including all of the assets I need to actually make up the application so configurations, etc. This could be a little contentious, but the idea of not really using sort of long-lived branches or feature branches in my code, but instead, having everyone checking into master trunk to make sure that I'm getting regular check-ins, constant feedback that's often worth the pain of fixing broken builds that will happen more often. So thinking about getting fast feedback on all my source code versus branches I may start merging every week or few weeks. This model is often coupled with test-driven development. To have good pipelines, I need confidence in my code. To have confidence in my code, I need to have confidence in my test. And so, when I think of doing test-driven, I start with writing some tests, I try to make sure that I'm building quality in from the beginning. Typically, this is part of teams that are really successfully doing continuous integration. These continuous integration jobs often get triggered when I check in code. I'll do unit testing on my desktop potentially, but integration tests happen when I check in my code and I'm running it against the entire code base to make sure I'm always dealing with something that's really ready for production by constantly testing it all together. Of course, it's important to test in a production-like environment. My test setup should closely mirror at least a basic prod-like configuration as it's moving to future testing stages and then production. I'm not going to be surprised by the behavior. Next, let's talk about some of the patterns of packaging up the software. So including configuration and code, everything, all dependencies show up in my package. This isn't about just compiling source code. It's about all of those components, scripts, pieces, that need to come together that make up my software. There's often some sort of build service that actually generates some artifacts. So it helps build the components that will then be used in the future environments. Now containers have come out as a very popular way to actually package things. Whether these containers are Linux or Windows, it's a convenient way to bundle up things at this some sort of immutable, unchangeable package. Now it's not always needed, but it's certainly a valuable way to do something that has a chance to be the same in every environment. And then you'll often think about an artifact repository, a way to store the results of a build so I can use that later as part of my deployments or rollbacks or future scalable deployments, I have a trusted place to pull a repeatable immutable set of artifacts from. So we've integrated this software, we've packaged it up, then it's about delivering the value to production. And again, a key is always about small batches. Continuous delivery is about constantly sending new value into production. What's going to be important is that the pattern for applying the same binaries, the same code package software to every environment, your code shouldn't change. I build it once, I run it in each environment, and I avoid the sort of works on my machine or the sort of catastrophe when it hits that next place and we're all surprised it doesn't work anymore. There's lots of fun patterns that actually make sure that you can do low impact deployments. For many of us who grew up in this era of being a little scared of shipping software because it was unpredictable, they were complex and with fragile routines for updating the software so if something hurts a lot, you just kind of avoid it, but in the cloud native world, if it hurts you, do it more. You figure out ways to make it better. But one of those areas you have to be concerned with is how do I avoid downtime, how do I deploy all the time without breaking things. You may use a canary deployment model to deploy to certain areas, geographies first or infrastructure pulls first and ensure your stability before rolling it out elsewhere. You may do a blue/green deploy where you cut over between environments and you have let's say the blue environment with the current version of production. You install the updated version to the green and then you route traffic over the green and blue becomes the backup and you kind of have this environment where you can cut over back and forth. All of this applies to database and infrastructure changes as well. And then finally, once you're deployed, you're not done. So I'm also going to want to smoke test and watch metrics to make sure everything is healthy. I want to ensure success. So smoke tests ensure things work as expected. An ongoing monitor makes sure that we haven't introduced instability or violated service levels we've set up.

Cloud-native Application Infrastructure Patterns
Now let's talk about application infrastructure patterns. So first off, it's really around API-driven infrastructure. We think of immutable infrastructure in this pattern. This treats servers as unchangeable resources. You replace, you don't patch or update. No more terminal-ing into a server. I don't SSH in and change a log file, I don't go into a Windows box and change IIS settings manually. I treat these virtual machines as unchangeable. If I need to make a change, I would make it upstream in a configuration, which that generates new infrastructure and retires the old. We also think about more observable systems, deep telemetry, not just of the server, but of the service. So when I'm doing cloud native work, I'm thinking about the service. I recognize that infrastructure will always fail. I will always have network partitions, drives will always fail. But if the service isn't interrupted because I've architected it correctly, that's actually a key metric there. So I don't want to lose my head or panic because something happens underneath, if I've built enough resilience in that my customer doesn't experience, and I still need to fix it, but that's very different than panicking or worrying when actually the system can heal itself. A big part of proper cloud-native infrastructure is thinking about APIs for building the infrastructure, scaling it, retiring it, attaching storage, changing firewall rules, all of this is API driven, not ticket driven. And then finally, you may think of chaos engineering, creating anti-fragile systems by injecting failure and seeing how the system holds up. If you have a hypothesis, you see what happens when key components go offline and if that meets your expectations and you may end up doing this in production because that's the only place where you can truly get the response and the results you need. You have to be careful when you do this, but this sort of practice of saying let's make sure our system can survive all sorts of bad things gives your better service overall to your customer.

Cloud-native Application Team Patterns
Finally, let's cover a few application team patterns. So specifically, as we think about empowered, customer-focused teams, it's often DevOps style teams. DevOps is typically a part of what we think about with cloud native as he seems to build and run services, not a separate team, not a DevOps team, which you've renamed your release engineering team or your testing team, but DevOps style teams. This means you've arranged these full-featured teams that are capable of building and running a service themselves. It may be super lean where all you have is a product donor and a bunch of engineers. Those engineers often are a pool of people that have DBA skills. Potentially, you have a product designer on the team as well that can do proper design. You've got some infrastructure skills that can work with the infrastructure APIs to build and manage your own infrastructure. So these sort of teams typically come into play as these cloud natives make sure that they reduce their dependencies on other teams and they empower that group to manage their service in a way that meets customer need. One trend we've noticed as well is that you have this sort of platform operations model that says look in larger organizations I can't embed operations into dozens, hundreds, or thousands of teams. I don't scale that way nor does every team need to manage down to the metal. I may not want every DevOps team configuring the firewall, like that may not be a service that they should be doing. So I may have key infrastructure platforms that are run by a very small, talented team and each DevOps style software team owns down to the platform. They own their software that runs on those platforms. They're not the one potentially building the virtual infrastructure or the like, instead there are teams that can actually manage that and that's kind of a flavor of site reliability engineering as well. This is something pioneered by Google and you're really treating operations as an engineering discipline, you're minimizing toil or manual work, you're defining service level objectives, and you're providing the advice, tool and platforms that actually enable scalable systems. So these are the sort of patterns you see around people and how people come together to deliver cloud native software.

Summary
So in this module, we kicked off looking at some of the key patterns that they're going to make up cloud native software. Then we looked at some application architecture patterns. How do we think of microservices 12-factor apps, these sort of things that come together to help us build software that is scalable, resilient, and capable of change. We looked at application delivery patterns including how we think about continuous integration and combining software regularly? How do we package it so that we can use it in future environments? And then what are some continuous delivery ideas around doing 0 downtime deployments or making sure that we don't actually disrupt things in production and think about those sort of cycles. We looked at application infrastructure and looked at how we deal with APIs, how we actually manage that underlying infrastructure in a cloud native way. And then finally, discuss some application team patterns as we think of DevOps and SRE and these other ways that teams come together to ensure they can ship great software. Now these patterns alone will help you get to a good place with cloud native. If you're doing these sort of things, you're doing them for the right reasons, you're doing them with the right intent, and you're building the sort of software and you're iterating on it in a sustainable way. In the next module, we're going to look at the technologies that help make this possible.

The Technologies for Cloud-native Architecture
Introduction
Greetings. I'm Richard Seroter. Welcome to this module in a course about cloud-native architecture and introducing you to some of the patterns and technologies to be successful here. In this module, we're going to start by looking at application architecture technologies. We're going to look at application delivery technologies next, then application infrastructure technologies before we look at application team technologies and wrap up. This will complement the previous module where we looked at the patterns for each one of these categories. Now let's look at some of the tech that helps you realize those patterns. And again, as a reminder, we think of cloud-native software, we're building software that's capability of scale, that's going to comfortably scale, that can change easily, that's built to be changed, that can easily tolerate failures, and it's built for manageability, something that can sustain day after day, month after month.

Cloud-native Application Architecture Technologies
Let's start off looking at the application architecture technologies. What are things to think about here? So first off, there's externalizing configuration like we talked about in the pattern's discussion. How do I yank out that application configuration from code? Now you can store secrets and other metadata and things like Azure's Key Vault or Hashicorp's great Vault product. Another nice option is Spring Cloud Config, which pulls files from Git, file systems, or even Hashicorp's Vault. You can access that via SDKs or APIs, but it's something that lets you do version control. This is where environment variables can be a little dicey as you won't be able to easily see a change history or things like that. So as you look at ways to externalize configuration, look for products that give you a way to pull from something, but the version history. When you think of your application architecture, another thing to think about is these code base microservices infrastructure tools. So if you're a Java developer and you're using Spring, Spring Cloud brings tons of stuff in here whether that is service discovery, circuit breakers, and interacting with message brokers, contract tests, using that config server. Steeltoe is a flavor for. NET developers, both of those developed by Pivotal and has similar capabilities. Poly is another great one for. NET. It does circuit breaker technology. If you're a Go developer, Go Micro has some of these capabilities as well. So based on the programming language you're using, there may be some libraries in here that incorporate some of those patterns we looked at earlier that help you build more resilient fault tolerant code. You'll also want to look at API gateway. So again, we talked about that being an important pattern and each of the public clouds has pretty good offerings here when you look at what Amazon offers, Google offers, Microsoft offers, some pretty powerful technologies here for calling your services and doing some smart things. If you want software-based solutions that you can run anywhere or manage yourself, Apigee, MuleSoft, and others do a good job of this sort of software versions of API gateways. And then finally, you get to think about identity management technologies, things that have a more token based approach where I can still use traditional LDAP repositories if I want to or Active Directory, but I want a standard spaced interface, an RN operating system or language specifics. I'm looking at OAuth, I'm looking at OpenID Connect, I'm looking at ways to transfer identity and authenticate users that will work across Linux and Windows and different environments. We talked about the patterns around database and sort of on-demand solutions, and as you think about services, you can think of self-managed, open source databases like Postgres, MySQL, MongoDB, Cassandra, all these sort of options. Each one of these you can operate in a more on-demand fashion with APIs and others to provision instances. But you also may move to a managed cloud database. Something from Amazon, like their RDS product if I want a relational database including the serverless Aurora sort of model or DynamoDB for more of a schema list model. In the Azure cloud, you've got things like Azure SQL database or CosmosDB for their planet scale NoSQL database. And with Google, you have things like the Rome Cloud database, as well as Spanner, a really powerful database that could function across locations. So there's also finally that category of caches and many of the public clouds offer Redis space cache, you may use something like GemFire, a number of different products that give you a choice of running this as a service or running this yourself in multiple different environments. The key with all of these is again I'm trying to get things that are scalable, things that are API driven, and things that are going to support a very fast changing application base. Finally, in this category, we did talk about messaging being a big part of Microservices architectures cloud native architecture. So your choices here are things like brokers, a message broker, RabbitMQ, ActiveMQ, 0MQ, and NATS. All of these are very powerful things. NATS is super-fast and meant for fire and forget. RabbitMQ is just a standard for routing async, request reply, kind of reliable delivery. You may start adopting more event stream processors to complement those brokers. This is great for log-based event streaming systems where I have a number of different players that I can choose from here, like Apache, Kafka, Flink, WSO2's product as well. In these cases, you end up with an append only log that you can do replays on and this puts a more responsibility on the consumer to kind of have an offset and read that log versus a broker that kind of holds that data until you're ready for it, but it also introduces a lot of new handy patterns that are tough to do with a traditional broker. And then finally, you have cloud-based variants of this. So Amazon has things like Kinesis for string processing or SQS for queuing. Google has got things like pub/sub and Azure has Event Hubs, or there's some really powerful messaging-based solutions that you can run as a service. Again, those are cloud specific. They also offer a fully managed experience that scales very, very well.

Cloud-native Application Delivery Technologies
Now let's talk about application delivery technologies. We think of actually shipping code to production. So first off, continuous integration. Clearly a popular category as we think of ways to build our code. We have to start with version control, of course. There're popular things like GitHub, GitLab, Azure Repos, formerly Visual Studio team services, and Bitbucket. Then you get into the continuous integration workflow tools, popular tools like Jenkins, Concourse, as you can see in the picture on the left, Circle CI, TeamCity, AWS CodePipeline, and the renamed Azure Pipelines, again something that formerly was part of Visual Studio Team Services until it was rebranded. Then when we think of packaging and deploying software. We have artifact repositories from providers like JFrog, these are ways to actually store the results of a build. I might use Maven, there's a number of things I might use here to actually store the artifacts. Then I've got packaging, these might be Docker containers, Linux containers, Windows containers, and then I might use a package manager like Helm that actually then can define a set of containers that I'm deploying. And then when I'm doing actual continuous deployment or delivery, I can use many CI tools, so something like Concourse or Jenkins. I can also push that code to a resulting environment. I can use Concourse to deploy it to infrastructure. But I also may combine that with software like GoCD or Spinnaker or something that also can do more sophisticated blue/green deployments or other smart things on the CD side. So I typically combine my CI/CD tools together and make them work together versus instead of forcing one tool to do the whole thing. And then when I think of doing smart deployments, I'm trying to minimize downtime, I'm trying to make sure I'm learning, but I might use things like LaunchDarkly to actually have feature flags so I can launch that software anytime, but actually enable the customer facing feature may be based on a marketing timeline or other ways I want to just expose it to a subset of people. And then, of course, I need good application performance monitoring tools like Dynatrace, New Relic, and others. They can actually watch those metrics and make sure that my deployment didn't introduce new instability because I'm still performing maybe the better level, of course, hopefully, than before, but I'm definitely not doing worse because after a deployment, that's when the work starts. That's when I'm actually learning that it's going to influence my next software sprint or my next release, so I need good metrics there and using some good APM tool can help you do that.

Cloud-native Application Infrastructure Technologies
Now let's cover some of the application infrastructure technologies that are going to be part of your cloud native journey. So first off, you're going to probably have some sort of config management like Chef, Ansible, Salt, CFengine, Puppet, all sorts of great tools for managing servers. They're typically great at setting up individual servers, keeping them in a good state. If file share goes away, making sure that comes back online, services stop, restart the, it's more of a server management tool. I also may be creating infrastructure. Alright, in a good cloud native environment, I'm not having people opening tickets and then someone clicking through a wizard to build me a VM. No, instead I'm using tools like Terraform from HashiCorp. I'm using CloudFormation in Amazon, or Azure Resource Manager, something that can create infrastructure in a very repeatable declarative way where I can define a manifest and tell it to go just build stuff. I may do more complex systems management things with things like Cloud Foundry BOSH. This is a tool for not just kind of packaging a release, but also building the infrastructure kind of like Terraform, and also, managing the infrastructure kind of like Chef and Ancible and others. So BOSH is a pretty powerful tool for actually building and managing systems doing things like rolling updates, things like that. Then some of the infrastructure automation will come from my container runtime. I might use Kubernetes, I might use Mesos, I might use Nomad, a number of different tools here that can actually help run containers for me if that's my chosen way to package and operate the software. And of course, the software itself typically moves up abstractions. Instead of dealing with infrastructure as a developer, I often want an application centric runtime for my cloud data apps. So I may use a Platform as a Service, this could be Heroku, this can be Pivotal Cloud Foundry, this can be a number of tools whether these are on-premises or off, they'll try to give me an application sort of runtime. Or I might use a function as a service, something like Amazon Lambda or Google Cloud functions, things that even move up another layer and say give me some code, event-driven code, run that for me. As a cloud native, that's a very, very quick rapid way to deliver software. So you'll often see PaaS, FaaS, these sort of things being very popular with cloud natives who really are focusing on the software not as much the infrastructure to get the value at the customers. And then finally, more and more recently you're seeing more service meshes come into play. Obviously, ESTO is a big piece here and some of that functionality we talked about earlier that you often see in that microservices infrastructure around service discovery, or circuit breakers, or even distributed tracing, some of that can move into the service mesh where sidecars attached to applications are actually doing some of that mediation and intelligence. It's still pretty immature technology, but you're going to definitely want to pay attention to this as this may change some of your architectures moving forward, but the same patterns come into play, this really becomes about where does the actual mediation occur in a code package part of my application code or in the environment or in the platform that my code is running in.

Cloud-native Application Team Technologies
The final category is application team technologies. What are the sort of technologies to help you deliver cloud native software and function well as a team. So of course, some of this may be chat tools. I need ways to quickly collaborate that don't involve meetings that help me make quick decisions and bring together different people. This could be something like Slack, Microsoft Teams, all sorts of tools that let me quickly engage a group of people and share information. If I'm doing Agile, I'm typically looking at things like Kanban boards and how do I use things from Trello, Jera, RealtimeBoard, Asana, other tools that actually help me visualize work. A big part of high performing teams is actually elevating this work so I can visually manage it. And of course, I also have shared access to logging and monitoring tools, those APM tools we talked about before, I don't want information silos. As a cloud native, we have to come together, quickly pinpoint issues, resolve it, and get my service back online. I'm trying to reduce impact minutes, not trying to blame someone. So that means I need shared access. I need the sort of tools that make it easy for me to quickly look at logs, quickly look at monitoring data, especially historic, and pull all that together. And then finally, cloud natives typically aren't going to always be in the same room together. Modern tech culture often involves distributed teams, and so these teams have to quickly come together and work on something and sometimes a chat alone isn't a way for us to come together to solve a problem. So I want tools like Zoom, or BlueJeans, or Skype, or Google Hangouts, WebEx, any sort of number of tools where we can actually get online, quickly see each other, answer questions, and then solve the problem. All of these tools are really about improving collaboration, improving information sharing, on top of this, you have things like wikis and other ways to share information and have a good knowledge base. Really, you can't leave this stuff out. If I build all the great architecture patterns, but I still have information silos or I can't resolve the issues quickly enough because people don't have trust or people haven't built relationships, I'm going to be in trouble. So this is an area to not ignore as I think about actually building a sustainable cloud native culture.

Summary
In this module, we specifically looked at some of the technologies that actually help realize those patterns, which in turn, realize some of the principles of cloud native. We looked at some application architecture technologies. We look at things like Spring Cloud or we look at GoMicro, or we look at tools that actually help us build good application architectures that are cloud native scalable fault tolerant. We looked at application delivery using good CI/CD tools, using Jenkins, using Concourse, using Docker, using these sort of tools that help us deliver software repeatedly, reliably, and do it in a way that gets things to production quickly without a whole lot of change failures. We've looked at application infrastructure technologies. How do I use something like BOSH to build out a system? How do I use Ancible to configure a VM? How do I use Terraform to build that infrastructure? How do I take care of things like service meshes, and PaaSs, and all those sorts of things, they all play a really big part because you're probably not going to be cloud native with just one of them. There're probably different sorts of software abstractions like PaaS or IaaS, they're going to run your software in and they're different ways you may end up building different types of infrastructure. Getting well-versed at this layer is going to pay off. And then finally, we looked at application team technologies. How do you improve collaboration, make sure that the cloud natives are working together on one mission, thinking about the customer. I hope you enjoyed this pretty quick course. The goal was to really introduce cloud native as an idea. Cloud native isn't just something that Silicon Valley companies do or 3-year-old companies do. Instead, you can function as a cloud native if you're 100-year-old bank, and you can do that by thinking about your architecture, how you deliver software, how you run infrastructure, and how you arrange your teams. It's been done, teams are doing it now, and this is an exciting way to put the focus back on delivering gratuitous value to customers, delivering a sort of software that's resilient and changeable, and making a big difference. I hope you found this enjoyable. You can find me on Twitter @rseroter. I would love feedback on the course, especially as we continue to talk further about these sort of topics.

Course author
Author: Richard Seroter	
Richard Seroter
Richard Seroter is the VP of Product Marketing at Pivotal, with a master’s degree in Engineering from the University of Colorado. He’s also an 11-time Microsoft MVP for cloud, an instructor for...

Course info
Level
Beginner
Rating
4.5 stars with 53 raters(53)
My rating
null stars

Duration
0h 51m
Released
20 Sep 2018
Share course
