Firebase on Android: Real-time Database and Cloud Storage
by Mitch Tabian

Looking to dive into Firebase Database and explore cloud storage tools? In this course, you'll develop an understanding of how to save data to a real-time database and upload files to a personalized cloud storage directory.

At the core of modern mobile application databases and storage systems is a thorough understanding of Firebase. In this course, Firebase on Android: Real-time Database and Cloud Storage, you'll learn how to seamlessly integrate Firebase into your Android projects. First, you'll discover how to create, retrieve, update, and delete data from the database. Next, you'll explore how to upload files to cloud storage. Finally, you'll learn to retrieve files in cloud storage. When youâ€™re finished with this course, you'll have a foundational knowledge of the Firebase Database and cloud storage tools that will help you as you move forward to develop mobile applications. Software required: Android Studio 2.3.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
4.7 stars with 26 raters(26)
My rating
null stars

Duration
2h 3m
Released
20 Nov 2017
Share course

Course Overview
Course Overview
Hi, my name is Mitch Tabian, and welcome to my course, Firebase on Android Real-time Database and Cloud Storage. I'm a self-employed Android developer, and I'm here to teach you about two incredible developer tools, the Firebase Database and Firebase Cloud Storage. Like other Firebase tools, the database and Cloud storage are fully integrated with Android Studio and are extremely easy to set up. Inserting data and uploading files can be done in less than 10 lines of code. Additionally, every Firebase task is automatically run on a background thread, so you don't have to worry about managing an async task, a handler, or a thread. Some of the major topics we'll cover include inserting data into the database. In the course, we'll create custom Java object classes and insert them directly into the database. Retrieving data from the database. We'll retrieve user information and display it in a custom profile. In the chat portion, we'll retrieve messages and display them in a chatroom. Uploading files to storage. Users will have the ability to upload a profile image. The profile image will be selected from the phone's memory or they can take a new one using the phone's camera. Once the image is uploaded to Firebase Storage, a download URL will be saved in the database. Real-time chatrooms. Users will have the ability to create or join chatrooms. All messages in the chatrooms are displayed in real-time. By the end of this course, you'll have an excellent understanding of two fundamental components of every mobile application, a database and a file storage system. You'll be able to apply your skills to new Android projects, or integrate with existing ones. Before beginning the course, you should be familiar with Android Studio, but I'll guide you through everything, so even if you're fairly new, you should be okay. I hope you'll join me on this journey to learn about Firebase with the Database and Cloud Storage course, at Pluralsight.

Getting Started
Introduction
Hi, my name is Mitch Tabian, and welcome to my course, Firebase on Android Real-time Database and Cloud Storage. In this course, you learn how to build an Android application that can create, request, update, and delete information in real-time from your personalized Firebase Database. We'll also learn how to manage and upload files to a Cloud-based Firebase storage directory. The process will be similar to most of the conventional systems that exist today in that we will be uploading files to a cloud-storage directory, and then saving a URL in the database that references the files. So now you're probably thinking, the real-time feature is cool, but if the process is so similar to conventional methods, why should I invest my time learning a new technology? There are a number of features that make Firebase stand out from the crowd. Regarding a database, there is no server required, that's a big one on its own. That means there's no extra code required to connect your application to the database. If we use PHP as an example, that means no PHP scripts to facilitate data transfer from the app to the database. Firebase has custom methods for communication with the database. Sending data is as simple as typing out a few lines of code. You don't need to worry about sending requests to a server, like using gets, puts, posts, and deletes. Security. If you integrate their authentication system, you can limit use to only authenticated users. I highly recommend becoming acquainted with the authentication system if you aren't already. I have a course on Pluralsight covering this topic, it's called Firebase on Android, User Email Authentication and Verification. Additionally, Firebase has a unique framework that allows developers to define special security rules for the database. You can get as precise as putting individual rules on a specific node, or, on the other side of the spectrum, you can allow anyone to see anything. It's very customizable. Real-time. We live in a mobile first world and technology is advancing faster and faster every month. Users demand information at their fingertips and they want it now. These days, having a database that operates in real-time is almost a requirement for any new cloud-based technology to survive. With Firebase, you can create custom Java classes and insert objects directly into the database. This ensures data is always consistent and is yet another way Firebase speeds up the data management system. Scalability. Firebase scales to for your storage and bandwidth needs. You're only charged for what you use. Google product. Firebase is a Google product, and the Firebase SDK is fully integrated with Android Studio. Regarding updates, Firebase reminds me of the book The Lean Startup, in that they are constantly iterating and testing new features. I made this course using version 11. 4. 0, and they'll likely be on 3 or 4 versions ahead by the time it's published. Now let's talk about Firebase Storage. Most cloud storage services are very similar and there are a ton of options out there. Just the other day I received an email from my server host, Digital Ocean, telling me that they now offer storage services. So, what makes Firebase storage better than one of the dominant service providers out there, someone like Amazon Webservices S3, for example? The number one reason is ease of integration. The Firebase tools work extremely well with one another, and their framework as a whole is literally built for mobile development. To upload files, you can execute simple upload tasks that are available with the Firebase SDK. When the tasks are complete, Firebase anticipates your needs in terms of objects you'll be needing next. For example, we'll be uploading images in this course. When the image upload tasks are complete, the method returns a URL that points to the image in storage. We can then easily insert the URL into the database. It's a finely tuned system with few moving parts. All Firebase tasks are automatically run on background threads. This saves a ton of code. You don't need to do any threading or create any background workers, that is just a huge time saver. In the next section, we'll take a look at the prerequisites you need to get started with Firebase Database and Cloud Storage.

Prerequisites
In this section, we're going to talk about the prerequisites related to the course. To get the most value from this course, I recommend you watch the course that preceded this one. It's available on Pluralsight, and it's called Firebase on Android, User Email Authentication and Verification. In that course, you'll learn how to build an Android application that can register new users, verify emails, sign-in users, and manage user account properties. As I mentioned in the introduction, all Firebase tools are built to work together. Authentication is a key component for using the database and cloud storage as it restricts unwanted users from seeing sensitive information. However, if you only want to learn about the database and cloud storage, this course will use the authentication system and you'll be able to fill in the gaps in knowledge as you go. If you're someone who's good at pattern matching and learning from doing, then you should be fine. If you're someone who needs a little more explanation and detail, I suggest checking out my course on Firebase Authentication. Other than that, I recommend you know your way around Android Studio, and know how to use the Android Emulator. This course technically does not require any prior experience with Firebase, but as I mentioned, I do recommend checking out my course on Firebase Authentication. Here's some information on the software versions we'll be using. We'll be using Android Version 26, otherwise known as Android O. Firebase Version 11. 4. 0. Android Studio Version 2. 3, and we'll be using the Firebase SDK, and Google Play Services SDK. For testing the application, I'll be using a Samsung Galaxy J5, and mirroring its screen using the Google Chrome Extension called Vysor. In the next section, we're going to talk about the story behind the application that we're building in this course. That way you'll have some real context as to why we're using Firebase for the database and cloud storage.

The Story Behind the App
For the duration of the course, we will approach app development from the perspective of an imaginary company, Tabian Consulting Inc. For those of you who have watched my Firebase Authentication course, we're literally continuing from where we left off at the end of the course. For those of you who haven't seen my Firebase Authentication course, here's the scenario of Tabian Consulting. Tabian Consulting is currently a 10-person company that is looking to expand their personnel to 100 employees in just 12 months. For those of you with no experience in the corporate world, that's a sizeable increase. The CEO recognizes there's too much work being done with respect to their current infrastructure around employee scheduling and communication. The current employees are a tightly knit group who send up schedules via email and communicate through text, phone calls, and emails. With 100 employees, there needs to be a more efficient system. The CEO has decided to invest in the development of an application that will manage employee scheduling and provide a means of commination. The CEO has the following criteria in mind. It must be secure and only allow employees to access. It must be scalable as the company is growing, and she wants to minimize developments cost, in other words, development time. The first point here specifies the application must only allow employees to register with an email address atTabian. ca. So someone named Mitch would have the company email mitchatTabian. ca. The CEO is unsure about Firebase as it's a relatively new technology, but you as the developer ensure her that it meets every criteria perfectly, and is owned by a very reputable company, Google. In the next section, we're going to do a complete application demo, and showcase all the features of the Tabian Consulting app.

Complete App Demo
In this section, we're going to do a complete application demo of what we'll be building in this course. As I mentioned in the earlier sections, this course is a continuation of the Firebase own Android User Email and Authentication course on Pluralsight, therefore, it's going to contain the authentication system that was implemented in that course. In this demo, I won't be going over the authentication features, but I'm going to log in and proceed to demo the features of this new course. All right, let's get started. Since I'm going to be demonstrating a real-time chat system, I'll be using two devices for this demo. I'll log in to two separate accounts. For the first one, I'll type in my email, mitchatTabian. ca., then type in my password, uh, password, and I'll click Sign In. For the second account, I'll type in a dummy email that I created, verifyatTabian. ca, and the password of password. Great, I'm authenticated. Here we have the employee dashboard for the Tabian Consulting employees. These widgets don't do anything. This screen is basically just for show. The button that does do something is this Menu button up in the top right. If we click it, we see three options. Number one is Sign Out, which will obviously sign out the user. Number two is Account Settings, which will bring up to an account settings screen, and Chat, which will bring us to an activity where we can create new chatrooms or join chatrooms. Let's check out Account Settings. In Account Settings we have some options for user personalization. We choose a profile image by clicking this Image View widget and selecting the option that we want to use. We can either select a photo from the phone's memory, or we can take a new photo using the phone's camera. I'll bring up the Firebase console in the background so we can see the fields changing in the database. I'll select to choose a photo from memory, and I'll select this bright reddish photo of some scenery. After the image is selected, we can click the Save button at the bottom, and the upload process will begin. Before I click Save, I want to mention something. As I stated in the previous sections, all Firebase tasks are run on background threads automatically. So once the image begins uploading, I can navigate away from this activity and it will still complete the task. So, I'll click Save and as soon as the progress bar goes away signifying the image compression process is complete, I'll press the Back button and wait for it to say 100% Upload Complete. Then we'll navigate back to the Account Settings, and check to see if our new image is set. Cool, everything worked, and if you're watching, you'll notice in the background on the database, that image URL was also updated. Now, we have some other properties we can set down here such as a name and a phone number. The name and phone number parameters are saved directly into the database, as opposed to the image, which is uploaded to the storage, and then a URL pointer is saved in the database. This email field actually isn't saved in the database. The email is saved in the Authentication system. We covered that in the Firebase Authentication course. So to change the name or phone number, I just need to change these fields. Let's change my name to mitch tabian, and change my phone number to 6048551234, and I'll click Save. Notice the data is changed in real- time in the database. Just to confirm it's now reading the new parameters, let's navigate away from the activity by pressing the Back button. Now, navigate back to Account Settings, cool, the fields are showing the correct values. Now, let's take a look at the real-time chat system. Here I have two devices and I'm logged into two different accounts using the Tabian Consulting app. One user's name is Mitch, and the other user's name is Jess. Let's navigate to the chat portion of the app on both devices. We just click the Menu icon in the top right, and select Chat. Now they're both looking at the same section of the app. I've already created a chatroom, as you can see here, and given it a title of Scheduling, but for this demonstration, I'll create a new chatroom. So I'll click the floating action button down here. Now, a dialog pops up and asks for some information that will be associated with that new chatroom. The first thing that it asks for is a Chatroom Name, I'll just call it test chat. Now it's asking for a Security Level. In this app, users will have a security level associated with their account. They'll be able to create and join chatrooms, but they won't be able to create or join any chatrooms that are higher than their security level. I'll just give this one a Security Level of 1 and click Create. Notice that the new chatroom now shows for the user who created it, Mitch, but the other user who was viewing the same screen, doesn't see that new chatroom. I purposely did this because I want to emphasize a feature that we're going to talk about in a minute. So, to refresh the list on this device, I'll navigate back, and select Chat again, and now we see the new chatroom. I want to reiterate that I did this on purpose. I realize that in a real situation, you would want the chatroom to update in real-time for all users of the app, but once again, I've done this for a reason so stay with me. All right, let's join the chatroom on both users. Now I'm going to type some messages from both users. What you need to notice here is the messages are updated in real-time on both devices. So I'll say hello from mitch, and now I'll say hello from jess. Also notice the user's names and profile pictures are displaying with their messages. The reason I didn't update the chatrooms list in real-time is because in this course, I want it to be unmistakably obvious how we did it. So you can easily compare the two activities, the chatroom activity and the chat messages activity, and figure out how to update the content in real-time. Now that we've showcased the chat system, let's delete our test chatroom. We can delete chatrooms by clicking on this little trash icon right here. Keep in mind that only the user who created the chatroom will be able to delete it. So if I try to delete the chatroom with the username jess, it tells me that I didn't create the chatroom, but now if I try to delete it with the username mitch, it asks me to confirm the deletion, when I select Delete, it's deleted. Once again, the chat list is not refreshed on jess' screen because I want to emphasize how to update views in real-time when we look at the code in the course. That's it for the new and improved Tabian Consulting app. In the next module, we'll get started integrating the Firebase Database and cloud storage tools.

Integrating the Firebase Tools with Android
Software Requirements
In this module, we're going to get started integrating the Firebase database into our Android project. For the duration of the module, we'll be working with the Source Code files in the directory module_2\start\TabianConsulting. As I mentioned before, the course preceding this one is Firebase on Android Email Authentication and Verification. We'll be continuing from the end point of that course and working on the Tabian Consulting application. If you've watched that course, then you can skip this section and move on to the section named, Syncing the Android Project with the Firebase Project. We're going to be working with Android Studio Version 2. 3 and Android Version 26, which is otherwise known as Android Oreo or Android O. To use Firebase with Android Studio, we're required to install the Firebase SDK and Google Play Services SDK. We need to take a quick look at the SDK Manager in Android Studio to make sure you meet all the requirements, and since we're going to be looking at the SDK Manager, we might as well open the project. Once you've downloaded and opened the project in Android Studio, you're ready to proceed. Let's navigate to the SDK Manager and see if we meet all of the dependency requirements. To navigate to the SDK Manager, click on Tools, Android, and select SDK Manager. First, make sure you have Android O installed, if it isn't, simply check the checkbox for Android O and click Apply. Next, take a look at the SDK Tools. Here we need to make sure that Google Repository is installed under Support Repository, and Google Play Services is also installed. If they aren't, simply check the checkbox and click Apply. That's all we need to do to start using Firebase. Also note that if you're going to be using the Emulator Accessory Application, ensure that it's updated. You can check that by viewing the status here. If it says it needs an update, just click the checkbox and hit Apply. In the next section, we'll head over to firebase. google. com and get started connecting our Android application to the Firebase servers.

Creating a New Firebase Project
In this section, we're going to take our first look at the Firebase Cloud Console and create a new Firebase project. Once again, if you've taken my Firebase Authentication course, then you can skip this section and move on to the section named Syncing the Android Project with the Firebase Project. You don't need to create a new Firebase project, you can continue using the one from that course. For the remainder of this video, I'll assume that those of you who are watching have not completed my Firebase Authentication course. So now we're ready to create a new Firebase project, so we can integrate the Firebase database and Cloud Storage Tools into our application. As I mentioned before, Firebase is a cloud based framework, so all we need to do is essentially point the Firebase project to our Android project and vice versa. After that, they'll be connected forever unless you break the connection. To get started with Firebase, head over to Firebase. google. com. Once you're there, ensure that you're signed into a Google account. Firebase automatically syncs to your Google account, so you can manage your projects from anywhere in the world. This course focuses on the Firebase database and cloud storage tools, so I'm not going to go over the other Firebase tools, but if you want to learn more about them, check out these links below. In the top right of the browser window there's a button labeled Go To Console. Click it and you'll be redirected to your personalized Firebase console. On this page, all of your Firebase projects will be listed below. If this is not your first interaction with Firebase, you'll have any number of projects already here. If this is your first interaction with Firebase, there will only be one button and it will say Add to project. Let's click it. Let's follow the instructions and give our project a name. Keep in mind that the Firebase project name doesn't have to match your Android project name. It's just something I prefer to do. Now select your region. My region is Canada, but you can enter your own region here. Click Create Project, and let Firebase build your project. This is the project dashboard. It's a custom view where you can access all the Firebase tools your application uses. They're shown in the column on the left. Currently, we don't have any of these features enabled, but in the next part, we'll take a look at the Database and Storage tabs, and integrate Firebase into our Android project.

Syncing the Android Project with Firebase Project
In this section, we're going to connect our Android Studio project to our cloud based Firebase project. For those of you who have not completed my Firebase Authentication course, this section is going to be mostly review. We're going to connect our Firebase project to our Android application by referencing the package name and acquiring the Google Services JSON file. Remember, you must use your own Google Services JSON file from your Firebase project. You can't use mine or the application will try to communicate with my Firebase console. For those of you who have not taken my Firebase Authentication course, that statement will make absolutely zero sense to you, but it will in a few minutes. Okay, let's head back to the Firebase console. So here I am in the console with the Tabian Consulting Firebase project selected, as you can see from the pull-down menu right here. Select the Add Firebase to your Android app icon in the middle of your screen. As you can see from the top of the popup window, there's three steps we need to complete. In this first step, we have three fields available to us, Android package name, App nickname, and Debug signing certificate SHA-1. The app nickname is 100% up to you, and I'm just going to be leaving that field blank. The SHA-1 certificate isn't needed to use the Database and cloud storage. As you can see below, it's only required for Dynamic Links, Invites, Google Sign-in, or phone number authentication, so we'll also be leaving that blank. We can get the application package from our Android Studio project. You can get it from any of the java files in the main package directory. So let's open up Android Studio, and we'll navigate to one of the java files, I'll just open up Login Activity, and copy the package from the top of the file. Now, I'll go back to Firebase and paste the package name right here. Now, press Register App. Next, is adding the Google Services JSON file to your application. This is the most important step. Any time you open my source code in Android Studio, you'll need to add this Google Services JSON file from your Firebase console. Your package name must also match, but that's why I recommend using the same package name that I'm using. If you use the same one, you only have to worry about the Google Services JSON file. The Google Services JSON file will allow Firebase to identify your application. Once again, do not copy mine from the Source Code files. You need to get your own from the Firebase console just as I'm going to show you in this video. Okay, now let's download the file and add it to our project. After downloading, navigate to the Project pane in Android Studio. You can get to the project pane by selecting this double-sided arrow, selecting Project, expand the directory and drag the Google Services and JSON file into the App folder. That's it. Let's go back to Firebase and see what's next. This is now the final step. Add this first dependency to your Project-level build. gradle file, and add this second dependency to your App-level build. gradle file. The two build. gradle files can be found in the same directory in Android Studio. One is labeled Project, and the other one's labeled App. So we'll start by copying the dependency for the build. gradle app file right here. And navigate to Android Studio, the two build. gradle files can be found in the Android pane, expand Gradle Scripts, choose the gradle script labeled App, and paste in the dependency. Now, go back to Firebase, copy the dependency for the build. gradle project file, now go back to Android Studio once again, and paste in the correct folder. Once you've added the dependencies, click the Sync button, wait for gradle to finish, and head back to Firebase. Now we can click Finish, and we're done. The Firebase project and the Android application are now connected. In the next video, we'll take a look at enabling all the Firebase tools we'll be using in this course.

Integrating Firebase Tools Database Cloud Storage Authentication
We've connected our new Firebase and Android projects, now we're ready to integrate the Firebase tools. The only thing we need to do in the Firebase console is enable our sign-in method. Since we're carrying on from the previous course on Firebase Authentication, we're going to be enabling the email sign-in method. Just click on the Authentication button on the left, select the Sign-in Method tab, and click on Email and Password. Flip the switch and click Save. The database and cloud storage tools actually don't require us to do anything from the Firebase console, so we're going to move on and add the required dependencies in Android Studio. The easiest place to get the dependencies is from the Documentation. This will also ensure that you're using the most up to date versions. Head over to firebase. google. com/docs and select Get started for Android. Let's start with the Authentication dependency. Select the Authentication pull down on the left, and select Get Started. Right here is where we can grab the dependency from, copy it, and navigate to Android Studio. Open up your build. gradle app file, and paste in the dependency right here. I like to add a little heading so if I glance quickly at the file, I know what kind of dependencies I have. I'll just say, Firebase Authentication and press Sync. Okay, looks like we forgot something. As of version 11. 2. 0, Firebase and Google Play Services dependencies are available via Google's Maven Repository. If you took my course on Firebase Authentication, you didn't have to do this step because we used version 11. 0. 4. We can include a reference to the Maven Repository by adding a line of code in the build. gradle project file. Scroll down and we'll do a hard return with your cursor where it says jcenter. This is the line we need to add to the project level build. gradle file. We do maven then url https colon//maven. google. com Now try syncing again. There we go, now it works. Head back to the Firebase docs, now we'll select the Realtime Database pulldown, once again, Get Started, and the dependency is right there. Copy it and head back to Android Studio. Now we'll navigate to the build. gradle app file, type a short heading, Firebase Database, and paste in the dependency. Okay, last one. Head back to the Firebase docs, select Storage, and once again, Get Started, and grab the dependency, now head back to Android Studio, once again, we'll type a little heading, Firebase Storage, and click Sync once last time. I actually realized something as I'm filming this, when I planned the course, I made the test application, I used version 11. 4. 0 because that was the newest version at that time. It's only been two weeks, and it looks like there's already a new version. Taking a quick look at the Change Log found at firebase. google. com/support/release-notes/android, it looks like there is a new version that was just released on October 3, 2017. To prevent any small issues you might run into, we're going to be using version 11. 4. 0 for this course. So let's head back to Android Studio and change that version. So, just select the last digit and replace the 2 with a 0 for each of those dependencies and press Sync one last time. Great. That's all the dependencies we need. In the next section, we're going to get started inserting some data into the Firebase Database.

Inserting Data into the Database
Introduction
In this module, we're going to get started using the Firebase Database. For the duration of the module, I'll be referring to the Source Code Files in the Directory module_3\start\TabianConsulting. Remember to add your Google Services JSON file to the Source Code. If you try to use mine, your application won't be able to communicate with the Firebase servers. In this section, I'll explain how the database is structured and some best practice ways for structuring your data. Firebase uses a term called Normalization to describe the way you should try to structure your data. We'll take a look at how Firebase uses security rules to enable or restrict access to certain database nodes. However, we won't get into detail on this topic, since it could be a course on its own. We'll talk about how you can backup your data. We'll create custom object classes in Android Studio and insert them directly into the database, and we'll target specific nodes in the database and talk about how to update values. Before we begin coding, let's take a look at short demo of what the application will be able to do by the end of this section. I'll start off by demonstrating the registration process. Keep in mind that we won't be going over the registration process in detail in this course because I covered it in my Firebase Authentication on Pluralsight. So, here we have the Tabian Consulting application running and the Firebase Console in the background, and if I select the Database, you can see there's no data. This Cloud Firestore option is the feature Firebase recently introduced. Essentially, it's another version of the Database, but we won't be talking about that in this course. I'm going to click on Get Started on the Realtime Database icon. I'll leave the Firebase console in the background, so that when I register you can data inserted in real-time. All right, let's start the demo. To register, you click on the text view labeled Register down here, now we can enter some credentials. I'll use mitchattabian. ca, and enter a password of password, and enter once more, now I'll click Register. Cool. You can see some data was inserted into the database. This is the default data that's inserted when a new user registers. Here is a user's unique user id and it's located under the node labeled users. Now, before we log in, we need to verify the email. So, I'll open up my email inbox, and there's the verification link. I'll click it, and now my email is verified, and I'll be able to log in. So, I'll type mitchattabian. ca and my password of password. Cool. I'm authenticated. Now let's navigate to the Account Settings screen. You can get to the Account Settings screen by clicking on the Menu icon in the top right, and now select Account Settings. Here we can alter the user's personalized account settings. By the end of this section, you'll be able to change their name and their phone number by editing these fields and clicking Save. We'll work on changing the profile image in the module on Firebase Storage. In the next section, we'll work on building and inserting custom java objects directly into the database.

Inserting Custom Java Objects
We'll talk about the Firebase Database and build a custom user object class for inserting data into the database. Before we can insert any data, we need to figure out what we want it to look like in the database. I've already inserted some data so technically you already know what it's going to look like, but I want to spend a little time exploring the database from the console for you to get familiar with it. To properly demonstrate, I'll just delete the data currently here. To delete it, I can just click on the small red x right here, now select Delete. Since we're inserting user object properties, we can start by creating node named users. You can do this by clicking on the plus icon right here and typing in a name. Click this other plus icon right here next to Value. Now it drops down to a second tier. In the second tier, we're going to going to something similar, but instead of saving the name users, or a user's name, we're going to save their user id. If you've completed my Firebase Authentication course, then you already know that user ids are generated by Firebase as long strings of characters and numbers. An example might look something like this. Now we press the plus icon again, and move to a second tier. This is where the personalized user data will be kept. Essentially, it's a tier system of key value pairs. Here we have the keys, and here we can enter some values. Our user objects are going to have five parameters. Name, now I'll enter a dummy name. Phone, and we'll just put 1 for now. Profile image, and we'll just use a blank string for that one. Security level, just put a 1, and user id and enter their user id once again. Make sure that all keys are lowercase here. This is very important. The Firebase Database is case sensitive so the best practice way to name the nodes is using all lowercase. Also notice that I'm using underscores and I'm not using the regular java convention of capitalizing the first letter of every word after the first word. It can also cause issues when inserting objects from Android Studio, so make sure all keys are lowercase. Also notice that I stored the numbers as strings. Firebase does support numbers to be saved as floats, and also Booleans as true false, but I prefer just to save everything as strings. I save everything as strings because in my experience it makes things easier when you're retrieving or managing data from your application. You'll just have to trust me on that one. Okay, let's insert the data. So, that's what a user object will look like when we insert it into the database. If there were two users, we would add a second id here below the first one and repeat the process. I'll skip the video ahead here and show you what it would look like. So here's what two users would like in the database. This is what we're going to aim for when we create our custom user object class and we insert the user data. It's always good to insert some dummy data first just to get a feel for what it'll look like, or, alternatively, I like to write it out on a whiteboard since that's just much faster. Now that we know what our data is going to look like, open up Android Studio and let's create our custom data model. Expand the app directory, now expand java. When creating object classes for Firebase, I like to create a separate package directory and name it models. Now, right-click on the models package and create a New Java Class named User. Our User class will have the five properties we just talked about. private String_name, private String_phone, private String_profile_image, private String_security_level, and private String_user_id. Once again, I need to mention here that it's very important to keep everything lowercase. I know typically java best practice is to start with lowercase and then capitalize the first letter of every new word after, but with Firebase, you should use all lowercase and separate words with underscores. The Firebase SDK is designed to work with Android Studio, but if your getter and setter methods aren't perfect, then you won't be able to read data properly from the Database. Now let's insert our default constructor. Go Alt+Insert on Windows, and Command+Insert on Mac, select Constructor, and select all the parameters. Let's do a hard Return here so it fits in all one window. Now select the Constructor and copy the whole thing, paste it below because we're going to override it with an empty constructor. Also, close the pane over here for more space. Now let's generate our getter and setter methods. When doing this, make sure to let Android Studio do it for you because any capitalization variances will cause errors. So we go Alt+Insert on Windows, and Command+Insert on Mac, select Getter and Setters, select them all, and done. Now, let's also get our two string methods so we can easily display objects in the log. Okay, that's all we need to do. In the next section, we'll be working with register activity and inserting our first user object into the database.

Inserting Data When a New User Registers
We'll insert some default data into the database when registering new users. Let's quickly go over the general process of user registration. Our user will navigate to the register screen by clicking on the Register text view widget on the login screen. Once at the Register screen, the user will need to enter their email address and two passwords. I'm requiring that they enter their password twice so we can be sure that they don't enter something incorrect by accident. Once the fields are filled, they press the Register button and a request will get sent to our Firebase server. If the request is successful, meaning the user has a valid domain, then some default data will be inserted into the database. That's it. Pretty simple. I want to mention one more thing here before we proceed. If you've completed my Firebase Authentication course, make sure to delete any users currently registered in your Authentication section of the Firebase console. You can do this by navigating to the Firebase console, clicking on the Authentication button, selecting the Users tab, clicking on Users, and deleting them. We need to remove any existing users because after this module is complete, default data will be inserted upon registration. If the users are already registered, the default data won't be inserted. All right, let's take a look at the code. Open up Register Activity and scroll down to the Register new email method. We're going to make some alterations here before inserting data into the database. After the Firebase task, createUserWithEmailAndPassword is complete, two methods are executed. Number one is sendVerificationEmail, which does exactly as it sounds, and sends a verification email to the newly registered user, and redirectLoginScreen, which also does exactly as it sounds and redirects the user to the login screen. We also sign out the user by using FirebaseAuth. getInstance. signOut, but now we're going to add a forth action here. First, we create our user object by going User user = new User and make sure to import the user object class from our models package, then we save the properties of the user class. So the first one will be user. setname email. substring 0, email. indexOf the at symbol, user. setPhone to 1 making sure it's a string, user. setProfile_image to a blank string, user. setSecurity_level to a 1, again, making sure it's a string, user. setUser_id to FirebaseAUth. getInstance. getCurrentUser. getUid. Now we're ready to insert the data into the Database. I'm excited to showcase this because it's incredibly easy. There's no http requests, no special formatting of the request body, and no authorization token, just a simple insertion of an object. So, all we need to do is create a database reference object and then reference the node we want to insert it into. So, we go FirebaseDatabase. getInstance. getReference to get the database reference, then we reference the node we want by doing. child and we get the string for database node users, and then. child FirebaseAuth. getInstance. getCurrentUser. getUid and then we set the value to the user object. I used the getString method here to reference a string that I included in the strings. xml file. This is the best practice way to store your database node names and database field names, that way you don't have to deal with typos. Let's take a quick look at the strings xml file. Open up the Navigation pane, expand the Directories, and select strings. xml down here in the Values folder. As you can see, I have all the database field names that we'll need in this course, and also the main database nodes. We don't have a chatroom node in the database yet, but we'll get to that in a later section. If you're not seeing pattern here, these field strings match with what the database field names are. Take a look at the Firebase Database, and as you can see, the Database node names in the strings file match what we have in the Firebase Database. Okay, let's go back to Register Activity. So what we currently have will work. It will insert data into the node we want. The thing I noticed here is that the users can only insert data into their personalize database node because the insertion statement references their user id. This will change depending on what user is authenticated with the app because every time we reference the user id we use FirebaseAuth. getInstance. getCurrentUser. getUid. To increase the security level, we can also alter the security rules in the Database. I'm going to cover this quickly because as I said in the introduction, security rules could be an entire course on their own. So here we are in the Firebase console, select Database on the left and click the Rules tab up here. This is where you can set custom security rules for your database. You can get as specific as targeting individual nodes, or as vague as we have it right now. Right now, it's saying if the user is authenticated, then they have read or write access to any node. So, what we're going to do is we're going to give every authenticated user the ability to read any node, but we only want users to be able to write to their own user's node. If that sounded confusing, here's an example. If I was in the database, I'm going to be the only one who can write to mitch's user's node. We start by referencing the node we're defining rules for. So, I'm going to write users, now I'm inserting a variable. The way you would insert variables is by using a dollar sign. So we can write dollar sign uid, then inside the variable user id, we're going to add our permission, so we can write. writecolondollarsignuid = auth. uid and that's it. Then we just add the read permissions down below the uid variable so anyone can read it. Now delete these old permissions down here, and I almost forgot to include a comma right here, there we go. Now click Publish and make the changes permanent. If you can't see the pattern here, let me explain a little more. Take a look at our Database. The hierarchy goes users, then the variable user id, which will change depending on which user is authenticated, and then user. Now take a look at the rules. Once again, the hierarchy goes users, variable user is, and then the write permissions. Now, keep in mind that because we're adding special permissions to the user's node, now we're going to have to add special permissions for every new node we create. I'm just going to write in the permissions for the chatrooms node now, but we won't be working with it until later in the course. So once again, we define the node I'm interested in, and then we just write. writecolon auth does not equal null and. read auth does not equal null. So, anyone will be able to read or write to that node if they are authenticated. Okay, and click Publish. Now head back to Android Studio and continue our insertion. Like other Firebase tasks, we can add an addOnCompleteListener and then addOnFailuerListener. So, we go. addOnCompleteListener and now we implement the onCompleteListener interface, and onFailureListener and implement the onFailureListener interface. In the onCompleteListener, we'll sign out our user and redirect to the login screen. In the onFailureListener, we'll do the same, but also add a toast message saying something went wrong. Don't forget to delete this bit of code down here since we're now handling it inside our onCompleteListener interface. All right, before we test it out, I want to remind you that you'll need to change the domain restriction or you won't be able to register. Okay, let's run it. Okay, so we'll start by going to the Registration screen, and now I'm going to type in my email, mitchattabian. ca and my password of password, and once again, my password of password, now I'll click Register, cool. You can see data was instantly inserted into the Database. Before we move on to the next section, let's verify the newly registered email. If you've completed my Firebase Authentication course, then you're no stranger to this. Simply open the email Inbox of the email you registered with, and now we can click on this verification link right here. Great. Now the email is verified, and we'll be able to log in. In the next section, we'll work on updating the default user data from the user account settings screen in the application.

Updating Users Profile Data
We'll update the default data we inserted upon registration. Before we begin, let's quickly review the process a user goes through if they want to change their profile information. I'm logged into an account, now let's click on the Menu in the top right and select Account Settings. Here's where you're going to update the users profile information. The user will only have the ability to alter their name, phone number, profile image, and email address. The name, phone number, and URL to the profile image are saved in the database. We won't be inserting a new profile image in this section, that will be in the Firebase Storage section. The email's altered via the methods discussed in the my Firebase Authentication course. For more information on that, be sure to check out that if you haven't. So, to make a change, I would simply enter some text for the phone number, or name, and click Save. The change will be submitted directly to the database. All right, mitch tabian, and a phone number of 6048551234, and I'll Save. As you can see, the values were updated in the Database. All right, let's write the code. Open up Settings Activity and scroll down to the onClickListener interface on the Save button widget. Since the email is saved in a completely different location and is essentially a different process altogether, we're going to the insertion of the name and phone number below these if statements. We need to write separate if statements that check if the fields are null. It doesn't matter what the user changes the name or the phone number fields to since they're not unique, but it's important that they are not null. Later, when we take a look at building a chatroom, it won't make much sense if a user has a null name. So we can write DatabaseReference reference = FirebaseDatabase. getInstanstance. getReference, and now we'll write some comments just saying Change Name. So if not name. getText. toString. equals blank. In other words, if the name isn't blank. We can go reference. child getString R. string. dbnode_users then. child FirebaseAuth. getInstance. getCurrentUser and then getUid and then. child once more getString and we reference the field name and then setValue to that name. Now we can do the phone number. I'm just going to copy everything we just wrote for the name and change the fields to phone. So I'll paste it down here, change that to phone, change that to phone, change the field to the phone, the Database nodes users is the same. Take a look at the way I'm inserting the data here. How does this compare to the way we inserted it during the registration process? When we inserted data after registration, we create a user object and inserted it directly into the child node of the user id. Here, we're pointing directly to the field we're interested in. This showcases two different ways we can insert data into the Firebase Database. The one we did during registration makes sense because we knew what each field was going to be at that moment in time. However, in this situation, we need the ability to change the properties independently of one another. A user may want to change their phone number, but they may not want to change their name. Or a user may want to change their name and they may not want to change their phone number. Look closely at the way we used the. child calls on the database reference. In the situation with registration, we referenced the node that encapsulates every field in the object class. We then use. setValue to set the entire object. In the situation with the Account Settings, we referenced the field directly using the. child method calls. I used. child to getString, R. string. field_phone to directly reference the phone number field and then setValue to set the exact value of that phone number field. All right, that's all we need to do to update the user's profile data. I'm not going to implement the onCompleteListener here because it's not really needed. The only reason you'd want to give the user feedback is if the task failed, and I'm going to leave that up to you if you want to add it. Oh, it looks like I made a mistake here. We need to move these if statements outside of this bracket right here. If we only want to alter the name or the phone number, there's no need to check if the email field has been changed. We only need to check if the email has changed, if we want to change the email. Okay, let's test it. Okay, I'll navigate to the Account Settings screen by clicking the Menu icon and then selecting Account Settings. Now, the current name is mitch tabian and the phone number is what we set it to before, I'm just going to set my name to mitch and then set the phone number to 1 and I'll click Save. There we go. We can see that the data is instantly updated in real-time. Great. So now we're able to update the information in the Database. In the next section, we'll write the methods required for reading the Firebase Database.

Reading Data from the Database
Reading Data from the Database
In this module, we're going to read data from the Firebase database. For the duration of this module, I'll be referring to the Source Code files in the Directory module_4\start\TabianConsulting. Remember to add your Google Services JSON file to the Source Code. If you try to use mine, your application won't be able to communicate with the Firebase servers. This module will serve as an introduction to the more difficult topics covered later in the chat portion. I'll showcase the various ways you can read data and their respective purposes. To get more specific, we'll be working on reading the data in Settings Activity and displaying it in the application. Some key objects, interfaces, and methods you want to pay attention to are, the DataSnapshot object, a query object, the ValueEventListener interface, the addValueEventListener method, and the addListenerForSingleEvent method. Don't worry if you have no idea what those things are right now. It will all make sense shortly. I'll also talk about one thing that Firebase is missing in terms of a way it queries data from the database. In my opinion, it's pretty crucial, and there are some third party tools available that you can use to fill in the gap in functionality. In the next section, we'll take a look at Settings Activity and begin building the methods required for reading data from the Firebase database.

Reading the Database Using a Query
In this section, we'll make our first queries to the Firebase database. There are many ways to read data from a Firebase database, but they all begin with getting a database reference, creating a query object, and then executing a task on that query object. Right now, we have a way to insert and update information in our database, but there's no way to read it. To demonstrate, take a look at the Firebase console. We clearly have data for the name and the phone number, we inserted it in the last module, but if we look at our application, there's nothing showing on the screen. So let's go back to Android Studio and write a method that'll be responsible for retrieving those profile details. So here we are in Settings Activity. Let's scroll down below onCreate and create our new method. We'll call it getUserAccountsdata. Let's start with the log. So we'll type out Log. d, and we'll type getting the users account information, then we'll get the database reference object. In general, you'll always need to get a database reference object if you want to look at your Firebase database. The database reference is exactly what it sounds like. It's literally just a reference to your database. So we go DatabaseReference reference = FirebaseDatabase. getInstance. getReference. Now, something I want you to notice here is the similarities between the database reference object and the Firebase Auth object that we've looked at before. The Firebase Auth object is used for accessing things like the authentication state. It's used in a very similar way. So with the Firebase Auth object, we would go FirebaseAuth. getInstance then we could get properties like the user id or the email by calling methods like getUid or getEmail. I'm just going to delete these. I just wanted to make sure I pointed out the similarities. So now that we have a reference to our database through the database reference object, we can create our query, and we do that through a query object, and I'm actually going to show you two different ways to make the exact same query. Both are going to be equal in efficiency and query speed, I just want to make sure you understand all the tools that you'll have at your disposal with Firebase. So, I'll write a small heading here and label it Query method 1, now let's create that query object. So we go, Query query1 = reference. child and then we reference the node by calling getString R. string. dbnode_users. This is going to reference the database node that is called users. Now, we have a number of methods we can use here. For this query, I'm going to use the order by key method. This is going to do exactly as it sounds and order the objects by their key. In a Firebase database, the keys are the JSON objects that encapsulate the properties. Let's look at the Firebase database to clarify what that means. Here we have our users node. Inside the users node is an id and and then some properties. The key of this particular user object is the user id. So that's what the order by key method is looking for. All right, back to Android Studio. So, now we've told it what property we're looking for, now we need to tell it what value we're looking for. For that, we use the. equalto method, and then we pass the value of the object we're looking for. In this case, we're looking for the currently logged in users user id. We can get that by writing FirebaseAuth. getInstance. getCurrentUser and then getUid. So, to actually perform the query, we go query1 and then we add a ListenerForSingleValueEvent. Make sure the query only accesses the database once. There are a number of different types of listeners we can use, and I'm going to talk more about that in the chat portion of this course. So, we'll addListenerForSingleValueEvent, then we go new ValueEventListener and implement the interface, now we can loop once more inside of our interface override method on datachange, and since this loop is only going to return either nothing or a single result, I'll call the variable single snapshot for emphasis, then we do for DataSnapShot SingleSnapshot colon dataSnapshot. getChildren. The getChildren method will return all of the children of the dataSnapshot. In this case, it should only return a single child since we're specifically targeting a single user id. Now to get the user objects from the single snapshot, we go User user = singleSnapshot. getValue and then we reference our user class. This is a unique way that Firebase retrieves data from the database. You use the getValue method and then you specify what the data structure is going to look like by referencing the class. In our case, that's the user class. So, then we can write a short log for debugging. I'll just write Log. d and say query method 1 found user and then do user. toString. This is why having a two string method is very convenient to have in your object classes. It makes it really easy to print out all the properties to the log. So, now that we have all the properties, we can set the details to the text view widgets. So, we can go mName. setText then user. getName to get the name of the user, and then mPhone. setText then user. getPhone to get the phone number of that user. That's it. That's all there is to it. Notice the similarities to the other Firebase tasks that we've executed. You start with an object, you call a method, and then you implement an interface. Much like our add on complete listener method and on complete listener interface we've looked at in previous sections. And this design pattern isn't unique to Firebase. This is something a lot of Android programming API's are doing. You start with an object, call a method, and implement an interface. It's simple, effective, and most even operate on their own background tasks so you don't need to worry about creating threads and handlers, which is great. On that same vein, if I were to loop this entire query and add the results to an array list as the query's completed, I wouldn't have to worry about managing and creating background tasks and handlers. All Firebase tasks automatically operate on background tasks. That saves a ton of time and headaches for developers. Okay, let's work on query number two. I'm going to go a little bit faster on this one since it'll be mostly review. I'll start by coping the entire query from above. Now, change the query name as it's currently conflicting with our first one, so we'll go Query method 2, query 2, query 2, and don't forget to change the debug log down here to query 2. So everything's going to be the same except for the way we search the database. We're going to change the orderByKey method to orderByChild. This is going to change the way Firebase searches the database. If that doesn't make sense to you, let's talk about it while viewing the Firebase console. In the orderByKey method, it will search for the key encapsulating the values of the object, but with the orderByChild method, it will look for the name of that field, which would be user id. If I was looking for the field named phone, I would call orderByChild and pass the field name phone. That might sound a bit confusing, so let's go back to Android Studio and I'll explain it a little better. I referenced the field name user_id because that's what I'm looking for, then we just call. equalTo like we did before. We're still looking for the user id, we're just looking for it in the field instead of in the key. That's it. That will yield the exact same result as Query 1. Okay, so we just need to do one more small thing before we call the getUserAccountData method inside of init, and that's get the email. To do that, we just do mEmail. setText then FirebaseAuth. getInstance. getCurrentUser. getEmail. We don't have to query the database on this one because it's not saved in the database. For more information on where the email is saved, checkout my Firebase Authentication course on Pluralsight. Okay, now let's call getUserAccountData inside of init, and it's time to test. Okay, so I have the Firebase console open in the background. I want to confirm that it's reading the correct data. Cool, it's now successfully retrieving the data. Let's take a look at the log and Android Studio to see our two queries in action. Here we have the query from method 1 getting the data, and here we have the query from method 2 getting the data. Notice that they are exactly the same. In the next section, we'll take a look at some of the other methods related to Firebase queries.

Firebase Query Methods
In this section, we'll take a look at some of the other methods related to Firebase queries. You don't need to code along with this one, just sit back, relax, and enjoy the demonstration. To start off, I've inserted a bunch of dummy data into the database. I've inserted 20 additional users worth of data. The names are random, all start with 604855 and then 4 random digits. The profile images are blank, and the security levels are a random integer from 1 to 10. This is going to help me demonstrate the other sorting and filtering methods. If you don't know what I mean when I say sorting and filtering methods, that's okay, I didn't explain myself very well in the last section. We pretty much jumped right into an example. Let's head to the Firebase documentation at firebase. google. com/docs/database/android/lists-of-data. Scroll down to where is says Sort data. Here it shows two of the methods we were working with in the previous section, and one that you've never seen before. We have orderByKey, orderByChild, and orderByValue, which is the one you haven't seen yet. Just to give you an overview before we start talking about the details, this is the general process of executing a query. First, you choose a node referencing where you want to query, then you choose a sorting method, the sorting methods are the methods that I just described under the Sort data heading. So we have orderByKey, orderByChild, and orderByValue, and then finally, if we scroll down a bit, we see Filtering data. So after you choose a sorting method, you need to choose a way you want to filter your query. Let's compare this new information with what we did in the previous section. So we started by referencing the users node by calling. child, and then getString, and referenced the users string. We then chose a sorting method of orderByKey on the first Query, and orderByChild on the second, and finally, we used the. equalTo filtering method to filter on the value of the user id. So, now I think you can probably pretty clearly see that we followed the documentation, and you can see the general process of you reference your node, you choose a sorting method, and then you choose how you want to filter it. Now let's take a closer look at these methods individually with some examples. Since we've already tried the orderByKey and orderByChild method, let's use the orderByValue method and use the. equalTo filtering method. So this query is actually going to crash the app, but let's run it and take a look at what happens. Okay, so let's navigate to Settings Activity, and there's the crash. Let's open up the log and see what happened. To pinpoint the exact line it crashed on, click this link right here. Now close the log, so it crashed on this line of code right here where we get the user object from the dataSnapshot. So why do you think it crashed on the user object? It worked in the other queries we did. Why did changing the method to orderByValue make it crash? It's because the orderByValue method tells the query to look at the value field of the JSON object, so it's literally retrieving the value of the user id, not the user object itself. So essentially what this line of code is trying to do is it's saying User user = a string, which is obviously impossible. A user object can't be a string. It has to be a user object. If we look a little closer, we can see from the log in the line above that there are no other details about the user, just the id. That's a good indicator that there's a problem getting the user object information. Using the getValue method on the Snapshot should print out the entire user object, we should see the user id, we should see the name, the phone number, the security level, all those details, but we only see the user id. So, basically the orderByValue method should only be used if you're looking for a specific field value, not all the values of an object. So now we've seen all the methods for sorting data, let's experiment with the ones for filtering data. We'll start with the limitToFirst method, we'll use it with the orderByKey sorting method. So we'll change our query and get rid of these lines, and we'll use orderByKey, and then we'll type limitToFirst, and we'll just type in 5. Everything else about the query is the same. So this combination will retrieve the first 5 users from the top of the database list. Note that I could also use orderByChild and pass the user id, or orderByValue here and it would achieve the exact same thing. It essentially doesn't matter what you put for the sorting method, it will just grab the first 5 users from the database. Let's run it, and we'll navigate to Settings activity, cool. So you can see that it definitely got the user data for more than one user, and if we count them, we can see there's 5 users here. So the first one was Tabitha Canon, and the last one was Claude Wilburn. Let's make sure that's the first and the fifth user in the database. So here we see the first one is Tabitha and the last one is Claude. So everything is acting as we expected. I'm not going to bother with the limitToLast method as it's literally identical to the limitToFirst method, but it starts from the bottom of the list instead of the top. Now let's talk about the startAt and endAt methods. Now, what I'm about to say is based on my personal experiences, so you should take this suggestion with a grain of salt. I actually don't recommend using these methods at all, and here's why. In order to use these, you need to save numbers in the database, and in my experience, when you start saving numbers into the database, you start running into all kinds of issues. If you want to use greater than and less than logic, which is essentially what they accomplish, then just query using one of the other methods we talked about, and write logic on the client's side to handle the sorting. So in other words, query the data, get the strings, convert them to numbers on the app, and then handle the data however you want to. If you need to use numbers for anything else, just save them as strings and do conversions on the client side, which nicely transitions me to our next topic, the limitations of Firebase queries. Firebase is excellent for a lot of things, but there are a few limitations when it comes to retrieving data from the database. In the section, we're going to talk about those limitations and their solutions.

The Limitations of Firebase Queries
In this section, we're going to talk about some of the limitations of querying data from a Firebase database. The biggest problem I have with querying data from a Firebase database is there is no functionality to execute searches that are similar to SQL Like queries. For those of you who are not familiar with SQL, it's a relational database. Firebase is a non-relational database, and when I refer to an SQL query, I mean a query made to an SQL database, much like if I say a Firebase query, I'm referring to a query to a Firebase database. When using an SQL Like query, the developer can pass a set of keyword arguments, or a series of characters, that are contained in a word, phrase, or object they are looking for in the database. For example, if I'm looking for a person's name and I don't know the spelling, I can type the first few characters, or any combination of characters, and search. So if I knew the first two characters were Mi and I didn't know the rest, I could submit a Like query using the two characters I knew, the query will retrieve a list of matches, and likely find the name. With Firebase, there's no way to do that, it's either a perfect match or it's nothing. Now, I know what you're thinking. You're thinking you can just iterate through the entire data snapshot and perform the check on the Android application itself, and you'd be right. It would work, but it's painfully slow so it's not really an option. The best solution that I know of is to create a cloud based index of your Firebase. That means syncing your database with something like an Elasticsearch server, which can then query for any data you need. There's a little more work involved, but the finished product is polished and extremely fast. You can perform all types of queries at incredible speeds. The Elasticsearch index would also serve as a backup for your data, which is an added bonus. Google actually has a number of Elasticsearch solutions, but it general, any cloud based Elasticsearch will work. You can see what Google has to offer at console. cloud. google. com Once you're there, click on the navigation icon in the top left, now select Cloud Launcher, now search ElasticSearch, and there will be a number of options. Between you and me, I personally think that they left out this functionality because using an Elasticsearch API costs money, and if they offered it free with Firebase, it would likely cause some turmoil. Unfortunately, I won't have time to include Elasticsearch on this course, but Pluralsight has a great course by Janani Ravi. You can check it out at Pluralsight. com/courses. elasticsearch-analyzing-data. Now that you're aware of the limitations of Firebase queries, we can move on to the next section and talk about backing up your data.

Backing up Your Data
In this section, we're going to talk about how to backup your cloud storage and database with Firebase. Backing up your data with Firebase is simple. Open up your Firebase console and we'll explore the options. First, before you can create any backups, you'll need to upgrade to the Blaze plan, which is a pay as you go plan. You can upgrade by clicking on this icon down here, but don't worry, you won't actually be charged until you actually use the tools. So just select Pay as you go, and then Upgrade. If you don't want to upgrade, just watch me and I'll demonstrate. Once you've upgraded, we can go to the Database section and click on the Backups tab. This is where you can select your backup options. That's pretty much all there is to it. You can choose an option that suits you and the backups will be saved to your Google cloud console in the Storage section. You can get there by clicking on this link. In the next module, we're going to get started using the Firebase cloud storage tool.

Saving and Deleting Files from Cloud Storage
Saving Files in Cloud Storage
In this module, we're going to Save Files to Firebase Cloud Storage. For the duration of this module, I'll be referring to the Source Code Files in the Directory Mosule_5\start\TabianConsulting. Remember to add your Google Services JSON file to the Source Code. If you try to use mine, your application won't be able to communicate with the Firebase servers. The current best practice way to save media files for your mobile applications is to store the files on a server, and then save a link in the database pointing to its location. Using the Firebase database and Firebase storage is absolutely perfect for this. Firebase has an easy to user API that even manages download and upload tasks in the background automatically. That means, as the developer you don't have to worry about building or managing threads, handlers, or background tasks of any kind. All you need to do is to convert the file into one of the formats Firebase requires and execute the task. Some of the formats we'll take a look at are Byte array's, Uri's, and input streams. Most of the documentation I'll be referring to for the duration of this module, can be found at firebase. google. com/docs/storage/android/upload-files. Let's take a look at the Storage section of the Firebase console before we begin writing the code. Here we are at the console, now let's select Storage, we'll click Get Started, this popup is just telling us what the default rules are for our storage. We're going to talk more about the rules in a later section, so just click Got It. Here is your Firebase Storage console. From here, we can create folders, upload files, and make different buckets if we want requests to our storage to be faster for people living in various parts of the world. To create a new bucket, you need to be on the Blaze plan, otherwise know as the Pay as you go plan. Let's talk about how we're going to be structuring our files. Right now, the only media we have to store is the profile images of the users of the Tabian Consulting app. So we're going to create a folder and name it images. Then go inside the images folder, and we're going to create another folder and call it users. Inside the users folder is where we'll have to separate everyone's media. To keep it simple, we can just use the same system we're using in the database. In the database, we use the user id as keys, and then the user object fields are stored inside. So, we'll do the same thing here. Let's go to the Authentication section and copy the user id from my user. Now, head back to the Storage section and navigate back into the Users folder, now make a new folder, and name it by the user's user id. Now, inside this folder is where we'll save the particular user's profile image, and every other user will have their own folder denoted by their user id. Let's upload an image. So click on Upload Image, and we'll select an image, name it profile_image. The naming is going to be important here because when a user replaces their profile picture with a new one, we need to replace the old one by giving it the same name. That will ensure that the old one gets overridden. Now that the image is uploaded, we can click on it and check out some properties down here. You can see that it has a metadata option, and it has a download URL. Click on the Download URL to copy it, now paste it up in a new browser window. Cool. So the image is coming through in the browser. Now that we know how we're going to structure our files in storage, we can move on to the next section and upload a new profile image for a user.

Selecting an Image to Upload
In this section, we're going to add functionalities so users can select a new profile image from the phone's memory or take a new photo using the camera. Before we take a look at the code, let's review the whole process with a demo. First, let's delete this image we uploaded in the previous section. I'll leave the storage open in the background so we can refresh it once the image is successfully uploaded. Now, open up Settings Activity, click on the imagery widget with the Android image set it, now we can either upload an image from memory, or take a new one using the camera. I'll choose upload one from memory. Now, I'll select this high-resolution image of Iceland down here. Notice right away the image is set the widget, but the image hasn't been uploaded yet. Now, we need to click Save to upload. So, first the image is compressed, then the upload begins, and there we see the upload completes. Now, refresh the Firebase storage, cool. There's our image. So now that we know what's going to happen, let's take a look at the code. There's a ton of code here, so I'm going to walk through it slowly. The whole process starts when the user clicks the profile photo image view widget, after they click it, we check to make sure the camera and storage permissions are verified using the Boolean mStoragePermissions. That Boolean can be found down here in the verifyStoragePermissions method. This method will check permissions for reading external storage, writing external storage, and using the camera. If all the permissions are confirmed, the mStoragePermissions Boolean will get set to True. If the Boolean is set to True, a dialog will popup and ask the user how they would like to choose a photo. They can choose an image from the phone's memory, or they can take a new one with the camera. The dialog that pops up and asks the user their preferred method is called ChangePhotoDialog. Let's take a look at it. As you saw from the demo, the dialog has two text views, one for starting the camera intent and one for starting Action_get_content intent. Depending on what they choose, the result will get caught by the onActivityResult override method down here. As you can see, we have two If statements. One for the camera request and one for the pick file request. Both If statements make use of the OnPhotoReceived listener interface. I've defined that interface above the onCreateView method. As you can see, there are two void methods inside the interface. One takes a Uri object, and the other one takes a Bitmap object. The Bitmap is for the camera and the Uri is for the pick file request. After the image is chosen, the respective interface method is called, and the dialog is dismissed. Now, let's head back to Settings Activity. At the top of Settings Activity, you'll notice that I've implemented the OnPhotoReceivedListener interface, and there are two interface methods present. Just like in ChangePhotoDialog, there's one for the image Uri and there's another one for the Bitmap. If you're not familiar with interfaces, I'm basically using it to pass the image Uri or pass the image Bitmap from the dialog to Settings Activity where we can use it. Here's a little diagram. So, we start off in ChangePhotoDialog, the user either selects the camera option or a photo from memory. If they select the camera option, they're going to get an image Bitmap and therefore follow this path. If they select an image from memory, they'll get a Uri object and therefore, follow this path. When you implement an interface like we are, you can then generate override methods to retrieve the objects that are passed to them. That's what you're seeing right here with these override methods. If this isn't making sense to you, I'll do a demonstration. So if I cut out these two methods, notice that I get an error up here. Then when I remove the implementation of the interface, the error goes away. So now, if I implement the interface and see what the error says, it's telling me that I need to implement interface methods. I'll just click on this little red lightbulb and implement the methods. So, notice these methods have the exact same name as the ones that I just cutout, so I'll cut these out and I'll paste the other ones back in. So, once the image Uri or Bitmap is received in Settings Activity, we can save it to a global variable inside the class. The globals I'm going to use are mSelectedImageUri and mSelectedImageBitmap. Great. So we have our image ready to go in Settings Activity, and now we can move on to the image compression process, and then the upload. In the next section, we're going to talk about image compression and why it's necessary when uploading images to Firebase.

Compressing an Image Before Uploading
In this section, we'll compress and image and prepare it for uploading to Firebase storage. It's very important to compress files if you're storing any kind of media. Images saved on your phone can be very large and compressing them often doesn't sacrifice any quality. That might sound too good to be true, but I'll demonstrate what I mean shortly. There's a lot of code involved in the compression and upload process, so let's get an overview before we begin. The whole upload process kicks off when the user presses the save button. The save button executes a method called uploadNewPhoto. Remember from the previous section, we had two situations to deal with. Selecting an image from storage, which would result in getting a Uri object, and taking a new photo with the camera, which would result in getting a Bitmap object. That's why you see two paths here. uploadNewPhoto executes a background task that resizes the image in iterations. After the image is resized, the on post execute method of the Async Task calls a method named executeUploadTask. executeUploadTask does exactly as it sounds and uploads the new photo. I haven't written in the code for executing the upload task yet. We'll add that in the next video. There are a lot of parts here so I wanted to make sure I gave you an overview before we took a look at the code. All right, so we'll start off in the if statement checking to see if the selected image Uri is not null, or if the selected image Bitmap is not null. Remember, we can only have one or the other because up here in our interface, we've defined the opposing variable to be null. So, for example, if we chose a Bitmap, we set the Uri null, and if we chose a Uri, we set the Bitmap null. After we figure out which is null and which isn't, we call a method called uploadNewPhoto. In uploadNewPhoto, I've overridden the input parameter to accept either a Uri object or a Bitmap object. The two methods are right here and here. They're both very similar. The only difference is this one passes null to the background image resize object and a Uri object to the execute method, and this one passes the image Bitmap to the background image resize object and a null Uri to the execute method. I'm sure you have some questions about that, but just hang on and wait until we take a look at the background image resize class. Now we're ready to do the file compressing, but before we take a look at our background task, why do you think I did this? Why go through all the trouble of compressing, not to mention compressing on a background thread? If I wanted to simply compress the image, I could do that in a few lines of code. The reason it's being compressed on a background task is because it's being compressed in iterations. We want to maintain as much image quality as possible during the compression, so the best way to do it is in iterations. One way to achieve that is to loop the compression and simultaneously reduce the quality by, say, 10% each iteration. So if we scroll down to the BackgroundImageResize class, we can see what's happening. We have the input coming in as either an image Uri or as a Bitmap. If it's a Uri, then the Bitmap will be null so this if statement will be true. The Uri is then converted to a Bitmap using this line of code right here. This line of code can also slow down your main UI thread, so it's also important to run on a background task. So to summarize the first steps of this process, step one is to get the image into a Bitmap format. If the image is coming from the camera, that's already done. If the image is coming from memory, then we need to convert the Uri to a Bitmap. So that's what this if statement achieves. Step two is converting a Bitmap to a byte array so we can compress it, and, as I mentioned, we're going to do it in iterations, so we have it inside this for loop that runs 10 times. We're running it 10 times because the maximum quality is 100% and the minimum quality is 10%. Each iteration drops the quality by 10%. The method for compressing Bitmaps is defined down here. It's called getBytesFromBitmap. This method will convert the Bitmap to a byte array and then it will also compress it. The quality variable here refers to the percentage quality remaining of the original photo. For example, if I put a 90 here, that means there's 90% of the image quality remaining, or a quality loss of about 10%. Let's scroll back up to our background task. I want to give you a nice visual on what's happening here, so I created some meaningful log outputs for us to look at. This log is going to print out the total number of bytes the image has and its relative compression percentage. If this sounds confusing and you're feeling like you don't understand, it'll make 100% sense after we demo this. Okay, let's run it and take a look. Let's open the log so we can see what's happening as we compress the image. Notice I have doingBackground typed into the log filter. This will make it easy for us to see what's happening on the background task. Navigate to Account Settings, click on the image view widget, and I'll just select an image from memory, I've got a few high-resolution photos on here so we can test one of these. All right, now click Save to initiate the process. Right away, notice it doesn't slow down the main UI thread. If this process wasn't being executed using a sync task, it would be slowing down the app a lot. You'd see the button freeze and probably the edit text stop flashing. So we can see the original size of the Bitmap image is about 83 megabytes, then when we compress it to 100% quality, it shrinks down to 7. 16 megabytes, but since 7 megabytes isn't below the threshold of 5 megabytes that we defined as the global variable in Settings Activity, it compresses once more to 1. 6 megabytes. So now you're probably wondering, how is that possible? How does a compression of 0% amount to a loss of 76 megabytes? When you select an image from memory like we did, it's decoded into it's Bitmap, so the image that the app receives is completely uncompressed. Android does this so setting Bitmaps to widgets is faster and don't have to decode it before setting. When we use the compress method on the Bitmap, we're choosing a compression algorithm and compressing the image, so even a compression of 0% still has a significant effect on the size of the Bitmap since it was in a completely uncompressed state. That's all there is to compressing an image before uploading. In the next section, we'll upload the compressed image to Firebase Storage.

Uploading an Image to Firebase Storage
In this section, we'll upload a photo to Firebase Storage and we'll save a download URL in the Firebase database. There are a number of methods you can use to upload files to Firebase Storage. Basically, each method requires you to get an image into a specific format before initiating an upload task. The formats available are, Uri, input stream, and byte array, which is what we'll be using. If you want more information on the other methods, check out the Firebase documentation at firebase. google. com/docs/storage/android/upload-files. We've done most of the heavy lifting already preparing the image for uploading. Now, basically all we need to do is initiate an upload task and check for completion. So, in the onPostExecute method, after we finish compressing our image, we're going to call a method named executeUploadTask. If you don't want to type it out, you can just copy the method from my Source Code files in the folder, module_5/end/TabianConsulting. You don't have to copy the whole thing, just navigate to SettingsActivity. java and copy what you need. All right, let's walk through the method. We start off by showing a progress bar so the user knows something is happening in the background. Next, we create a FilePaths object, which is just a helper class that I made that holds the file paths for Firebase storage. You don't need to do this. I just do this to keep things organized. You could just write in the path directly by typing images/users, it's exactly the same thing. Next, we create our StorageReference object. This is essentially a pointer to a location in our Firebase cloud storage. We use it to reference the specific folder we want to upload to. Just for clarity, that's exactly where the storage reference is pointing. Also, just an FYI, this object doesn't need to be final, I forgot to remove it when I finished doing some testing. You can leave the final declaration, or you can remove, it makes no difference. Next, we need to check our image size and make sure it falls within our allowed threshold. I've set a megabyte threshold of 5 megabytes defined as a global variable in this class. So, now we just take our byte array, we get the length, and then we divide by the number of megabytes in a byte. If the number is within our allowed threshold we can proceed, otherwise, we'll let the user know that the image is too large. Next, we'll create some metadata for the image. I'm just going to attach some random information just to demonstrate how it's done. You can set the content type, you can set the language using a language code, but, as a side note, make sure to use a valid language code, like EN for English. Putting something like English, e n g l i s h, will cause a crash. I actually submitted this as a bug to the Firebase get hub page because at the time of this recording there was no documentation out letting what the proper format was. And, finally, some custom metadata. You can attach any number of custom metadata. You can just define a title and then a description. I'll put Mitch's special meta data for one title, and give it a description of JK nothing special here. Then we can attach a second custom metadata and give it a title of Location and a description of Iceland, which is something more realistic. All right, it's time to create our uploadTask object. We start by setting our uploadTask = storageReference and then we call a method called putBytes. Just as an FYI, you aren't actually required to attach any metadata, you can just use putBytes without including metadata and it will work just fine. I've commented out an alternative right here with no metadata. So now we have our uploadTask. This task is no different than any other Firebase task. However, instead of implementing the onCompleteListener interface like we usually do, we'll be using an onSuccessListener. We'll implement the onSuccessListener interface because it will yield a result with a URL pointing to the new image in storage. Since we have to store the URL in the database, this is perfect for our needs. We also need to check for failure. So, we'll add an addOnFailureListener, and one last method down here at the bottom. This is an onProgressListener. It's comparable to the onProgressUpdate method from the async task class. Basically, it just gives you updates as the upload progresses. The only problem is I find it distracting if you print out updates using a toast. I find it prints out too frequently. To solve this problem, I've written a bit of logic here to decrease the frequency of the progress updates. Feel free to tweak it to fit your needs. Basically, the new progress percentage has to be greater than 15 plus the previous progress percentage. That way, at most, you'll get an update when the progress increases by 15%, but I find it will only print out maybe 2 or 3 times during the upload, which is perfect. Inside the onFailureListener, we just want to let the user know that something went wrong, and then close the dialog. Inside the onSuccess method, we have to do a few more things. First, let's let the user know the upload was successful using this toast. Now, we need to get a download URL of the image from Firebase Storage and save a pointer in the database. You can get the download URL by using the taskSnapshot and calling a method getDownloadURL. Now we need to insert it into the database. We get our database reference, reference the location we're inserting the data, and set the value. Make sure to call toString here because technically this download URL is a Uri object, and last but not least, we hide the dialog. That's it. Run it and test. All right, so we have the Firebase console in the background, now let's navigate to Settings Activity, and we'll select an image from memory, I'll choose this high-resolution image of Iceland, there we have a compression starting, and now the upload starting. This is image is going to take a while to upload because it's high- quality, and therefore the compression loop will need to run a few times. Note, that in a production application, it's not a good idea to leave users waiting. That's another advantage of running this on a background thread. Users can navigate away from this screen and continue doing other things while the image is uploading. They don't need to stay and wait for it. Let's refresh the Storage Directory. Great. So we see the image was successfully uploaded to Firebase Storage. The size is 1. 6 megabytes, which is perfect, there's the metadata we attached, now let's quickly check the Database to see if a pointer was saved. So, we'll select the Database on the left, and here's our user, now let's copy the value in the profile image field, and paste this in to a new browser window. Cool. There's our image. In the next section, we'll make some minor alterations to the getUserAccountData method inside Settings Activity so we can retrieve the profile image.

Retrieving an Image URL from the Database
In this section, we'll retrieve the profile image URL from the Database and display it in the user's profile. To start off this section, I want to quickly talk about the library we're going to use to display the images from Firebase Storage. If you take a look at your build. gradle app file, you'll notice that I've added another dependency for the Universal Image Loader. The Universal Image Loader is my favorite external library for caching and displaying images. Setting it up is very simple. I've created a special java class just for its configuration. You can find it in the utility package right here. Open up SignedInActivity and you can see right here I've set the configuration. The configuration is saved in the app instance, so you only need to set it once and then you can access it any time from any java class. You can copy this exact setup procedure for your Android projects, just copy the UniversalImageLoader class, I have it right here, then make sure to initialize like I've done here in SignInActivity. If you want more information on the Universal Image Loader, check our it's GitHub page at this link. Now, we're ready to retrieve the user's profile image from the database and display it in their profile. Open up Settings Activity and scroll down to the getUserAccountData method. Inside the onDataChange method for query1, we just need to add a single line of code. We can get our ImageLoader instance, call the displayImage method, pass the profile image URL, and then pass the profile image widget. Pretty simple stuff. This is one of the reasons I love the Universal Image Loader. It's just so easy to display images. Let's also comment out query2 since it was only for demonstration purposes. We're not quite done yet. When the user chooses a new image, we need to set it to the ImageView widget. So let's scroll up to our interface methods at the top of the file. For the Uri case, we can just use the UniversalImageLoader. We can go ImageLoader. getInstance. displayImage and pass the SelectedImageUri and then reference the widget, but for the case when we have a Bitmap, we have to use the SetImageBitmap method on the ImageView widget. Okay, let's test it. Okay, navigate to Settings Activity, now we'll upload an image from memory, I'll choose this reddish, high-resolution image. Now, I want to show you that the task will complete even if I navigate away from this screen. I'm going to press the Back button immediately after I click Save before the upload is complete. Cool. So, we still see the completing upload. Now, we're going to navigate back to Settings Activity, but I want you to notice something. Pay attention to how long it will take the image to display on the ImageView widget. I want to demonstrate the power of the UniversalImageLoader cache. So, that took a pretty long time. Let's navigate back, and then we'll go back to Settings Activity again, and see how much faster the image loaded? That's the UniveralImageLoader caching the image. I'll give you another demonstration on what I mean. Open up the UniversalImageLoader class, now comment out these two lines, and then these two lines, now run the app again. And we'll do the same thing, we'll navigate to Account Settings Activity, it's still slow like the first time, but now we'll go back, and we'll navigate back again. Notice how slow it still is. Last time when we did this, it was much faster the second time. That's the power of the Universal Image Loader. So let's uncomment those lines and run it again. Now, we'll navigate to Settings Activity, and, as you can see, right away there's a drastic difference in speed. So everything is working as we expect at this point. We've covered a lot of information in this module, so in the next section, we're going to quickly review everything from this module and help solidify this new knowledge.

Cloud Storage Review
We covered a lot of material in this module. Here's a general overview. First, we either get a new image from storage or we take one using the camera. The camera results in a Bitmap object, and the storage option results in a Uri object. We then pass the objects to the OnPhotoReceivedListener interface. The interface is implemented in Settings Activity with the two override methods, getImagePath and getImageBitmap. Once the image arrived in Settings Activity, we could work on uploading on it. The upload process begins when the user presses the Save button. The Save button executes a method named uploadNewPhoto. Remember from the previous section, we had two situations to deal with. Number one was selecting an image from storage, which would result in getting a Uri object, and number two was taking a new photo with the camera, which would result in getting a Bitmap object. That's why you see two paths here. Upload new photo executes a background task that resizes the image in iterations. After the image is resized, the onPostExecute method of the AsyncTask calls a method named executeUploadTask. executeUploadTask does as it sounds and uploads the new photo. Once the upload task is complete, a download URL was made available and inserted into the database. We used the UniversalImageLoader to cache and display the image received from the database. In the next module, we'll build our chatroom integration for the Tabian Consulting application.

Implementing a Real-time Chat System
Implementing a Real-time Chat System
In this module, we're going to build a real-time chat system so we can showcase all the functionality we've been working on. For the duration of the module, I'll be referring to the Source Code Files in the Directory, Module_6\start\TabianConsulting. Remember to add your Google Services JSON file to the Source Code. If you try to use mine, your application won't be able to communicate with the Firebase servers. So far in this course, we've done a lot of coding, but we haven't added a lot of features to show for it. We can save and edit data in the Firebase database, and we can upload and display images, but that's about it. By the end of this module, users of the Tabian Consulting app will be able to create new chatrooms, add security restrictions to chatrooms, and send messages in real-time to other employees. Let's demo the fully functional version so you have an idea of what we'll be building. To access the chat portion of the app, we just click on the Menu icon and choose Chat. Once in the chat section, we can either join an existing chatroom or we can create a new one. Since we don't have any chatrooms, let's create one. We have to give it a title and a security level. The title can be anything. I'm just going to call this one new chat. The security system on the chatroom is pretty simple. Users with a security level lower than the chatrooms won't be able to join it, so if I create a chatroom with a security level of 5, only those with a security level of 5 or higher will be able to join it. I'll just give it a security level of 1 since that's my current security level. Cool. There's our new chatroom. Now, obviously, it's going to be pretty lonely in here since there's no other users, but if I wanted to test it, I can make another account and then join the chatroom. In the next section, we'll start building our real-time chat system by coding the functionality for creating new chatrooms.

Creating a New Chatroom
In this section, we'll walk through the code involved in creating new chatrooms. Before we take a look at the code, let's quickly demo the chatroom creation process. To create a new chatroom, you just click on the floating action button in the bottom right hand corner of Chat Activity. A dialog will popup and they can give it a Name and then a Security Level. That's it. Let's take a look at the code. Open up Chat Activity, scroll down to the Init Method, and you'll see an OnClickListener attached to a floating action button. When users click it, a dialog fragment is generated. The dialog fragment class is called New Chatroom Dialog. Let's take a look at it. As you saw in the demo, it's a very simple class. There are two inputs, one's for a name and one's for a security level, and there's just a button to execute the creation of the chatroom. There's also a method named getUserSecurityLevel, and it's responsible for retrieving the current user's security level. Let's take a look at it. So there's nothing new here. When you start by getting the DatabaseReference, then create a Query object, and then reference the node we're interested in in getting the data from. I use the sorting method orderByKey, but remember, we could also have used the orderByChild sorting method with a mild alteration. We get a result by adding an addListenerForSingleValueEvent, then set the SecurityLevel after looping through the single data snapshot that's retrieved. Alternatively, you could also use DataSnapshot singleSnapshot = dataSnapshot. getChildren. iterator. next instead of looping since we know we're only going to have a single result returned. Now that we have the user's security level, we can actually create a chatroom. Let's take a look at the onClickListener for the Create Chatroom button. Everything's pretty straightforward here. First we check to make sure the chatroom name isn't null, then we make sure the user security level is greater than or equal to that of the SeekBar position. Now we're ready to insert the data, but first I want to quickly talk about the data structure you can picture what the insertion is going to look like. All the chatrooms will be placed in the chatrooms node, then the next child will be the chatroom's ID, then inside the chatroom's ID will be all the fields for a particular chatroom. We have the chatroom id, the list of messages, the chatroom name, the user id of the person who created the chatroom, and the security level assigned to it. As you can see, it's very similar to how we structured the user data, the only difference is the field names and the chatroom has a list of messages. There's no list in the user object node. Okay, now that you've seen the data, let's create a new chatroom. First, we need to generate a new chatroom id. We can do that by using the push method on the database reference accompanied by the getKey method to typecast it to a String. Next, we need to actually create the chatroom object and assign all the fields. The chatroom object class can be found in the models package right here. Now we insert the chatroom into the database by referencing the chatroom's node, then the chatroom id, and then setting the value. Now we're going to create a welcome message for the chatroom. Once again, we need to start with generating a new id, just as an FYI, the fact that I referenced the chatroom's node here, doesn't make a difference. I could've left that out, the key would've generated just the same. Now, we can create a new message object and set the fields. We just need to set the message and the timestamp fields, since this message isn't going to come from an actual user, and now we insert the new message by referencing the chatroom's node, then the chatroom id, chatroom messages, then the message id, and finally, the value. All right, the completes the chatroom creation process. We're going to call the Init method from chat activity to refresh the list of chatrooms, and then dismiss the dialog. In the next section, we're going to take a look at retrieving the list of chatrooms and displaying them in chat activity.

Retrieving the List of Chatrooms
In this section, we'll walk through the code involved in retrieving a list of all the chatrooms. So we have two main parts to this process. Number one is retrieving the objects from the database. Number two is sending the objects to a ListAdapter class, which will then assign the data to their respective widgets. So let's start by getting the data. Open up Chat Activity and start by scrolling down to the method named getChatrooms. This query is going to be a little different than what we've seen before. I've structured the messages data this way on purpose so we'd run into this problem. I'm referring to the way I've put a list of messages inside each chatroom node. Before we walk through the code, I want to show you the problem. I'm going to comment out the way it works, and I'm going to run the app, and retrieve the data the same way we've been doing throughout the course. We'll use a chatroom object, and then use the getter and setter methods to get and set the fields. All right, navigate to ChatActivity, and there we see the crash. So as you can see, Firebase is interpreting the data as a HashMap, and it's unable to read it. It then throws an uncatchable error and the app crashes. This is pretty much the worst-case scenario possible. This is going to happen any time you try to put list as fields in the database. Lucky for us, there's actually a pretty easy solution. Let's comment out these four lines of code, and uncomment these five. Since Firebase is interpreting the data as a HashMap, let's just type cast the object to a HashMap. Then we can use objectMap. get getString are. String. fieldchatroom. id to reference the field we're looking for, and then typecast it a string using toString, and then we can repeat this process with each one of the database fields. If Firebase thinks it's a HashMap, then let it think it's a HashMap. It makes no difference to us as long as we get our data. Now that that's out of the way, let's start from the beginning. We start by getting our DatabaseReference like always, but notice the query object here. We don't need to use a sort or filter method. We're just going to use. child and reference the chatrooms node. We're able to do this because we want to get all the chatrooms, not just one, or a set list of them. We're essentially telling Firebase that we want to see everything inside of the chatrooms node, then we add our ListenerForSingleValueEvents and iterate through the results. I've named the DataSnapshot variable SingleSnapshot here, but it's not really a single snapshot since we're getting a list of all the chatrooms, but I'm just going to leave it for consistency. Inside the loop, we start by getting the Chatroom_id, the Chatroom_name, the creator_id, and the security_level, but we can't just assign the messages by calling getMessages. That won't work because it's actually a list of messages we're after. We actually have to create another loop and loop through the messages inside the chatroom. So, we create an ArrayList of chat message objects, then iterate through the chatroom_messages node by calling singleSnapshot. child then we reference the messages field, and then getChildren, then create a message object, and set the fields, and finally, set the messages to the chatroom, and add the chatroom to the list of chatrooms. Once our outside most loop is complete, we can call the setupChatroomList method, and send the chatrooms to our like adapter class. Let's take a look at the ChatroomListAdapter class. I want to quickly go over it because there's actually a query in here, so it's a little different than what we've seen before. So everything is pretty standard to begin with. We have our Constructor, our ViewHolder, and the getView method. We then implement the ViewHolder build pattern, and set the fields down here, but one thing that's not so standard is the query. We need a query in our ListAdapter class because a chatroom object doesn't store information about the user who created the chatroom. It only has their user id saved as the field creator id. The reason we don't want to save user information anywhere except the user's node is because it's subject to change. If we started saving user information all over the place, things like names, emails, profile pictures, we would have to update every single field in every single node every time a user made a change to their profile. For example, currently we display the user's name who created a chatroom on the chatroom itself, right in the list of chat activity. Now, supposed that user has created 100 chatrooms. That would mean every single time they changed their name, every single chatroom would need to be updated. Obviously, that's not a good system. So what we do instead is save a reference to the user's profile by saving their user ids to the nodes, then we query their profile every time we need to get their information, that way you don't need to update a bunch of fields. When your applications are small, it probably wouldn't make a bid deal. You can be able to keep track of all the places you saved their profile picture, but as your application grows, it's pretty easy to forget a node here and there, and pretty soon, you've got bugs all over the place. Anyway, back to the query. Everything here is pretty standard. We just reference the user's node and query using the user id that's passed to the ListAdapter. Once we get a result, we set the creator name field to the chatroom, and attach the profile image, and once again, I just want to mention that all Firebase tasks run on background threads so you don't need to worry about this slowing down your app's UI. That's it. That's all there is to retrieving the list of chatrooms. In the next section, we'll take a look at the code involved in deleting chatrooms.

Deleting Chatrooms
In this section, we'll walk through the code involved in deleting a chatroom. It's pretty straightforward. All a user needs to do is navigate to Chat Activity and click on the little trash icon in the top right of the chatroom. If the user is the one who created the chatroom, a dialog will popup and ask them to confirm the deletion. Cool. So it was removed from the database and also from the list in the app. All right, let's take a look at the code. The deletion itself is occurring in a java class called DeleteChatroomDialog. When the dialog is created, it gets a reference to the chatroom that was selected through arguments passed in a bundle. In the onCreate method, the chatroom id is assigned to a global variable called ChatroomId. To initiate the deletion, the user just needs to click the delete TextView widget in the dialog. To perform the deletion, we start by getting our Firebase database reference, then we reference the node we're interested in, in this case, it's the chatrooms node, and then the chatroom id in question. Then we call removeValue, when you call removeValue, Firebase replaces the node you referenced with a blank value, which is essentially the same thing as deleting. That's all there is to deleting nodes from the database. In the next section, we'll take a look at the code involved in inserting chatroom messages.

Inserting Chatroom Messages
In this section, we'll walk through the code involved in inserting new chatroom messages. Open up Chatroom Activity and scroll down to the onClickListener interface on the button named Checkmark. You can find it inside the init method. This is actually a pretty straightforward process. All we need to do is check and make sure the message isn't blank and then insert it into the database. So after the check, we create our ChatMessage object, now we set the message, the timestamp, and the user id to the message. Then we get the database reference, we're inserting into a chatroom so we go. child and then reference the chatroom's node,. child, and then reference the chatroom id, and then. child and reference the chatroom messages field. Now we create a new id for the message by using. push and then getKey to typecast it to a string, just like we did before, and finally, insert the message by calling. child and referencing the new id, and set the value. Then we clear the message text and we're done. Let's insert a new message and watch the insertion in the database. Okay, let's navigate to Chat Activity, looks like we don't have a chatroom since we deleted it in the last section, let's create a new one. I'll give it a Title of test chat and a Security Level of 1. I'll expand the node so we'll be able to see the data inserted, I'll just type hello. We can see the message was instantly added to the database. Cool. So everything is working as we expect. In the next section, we'll review the code related to retrieving messages from a chatroom and displaying them in a list view.

Retrieving Chatroom Messages
In this section, we'll walk through the code involved in retrieving the list of messages in a chatroom, and then displaying them in a list view. Let's look at the getChatroomMessages method inside of ChatroomActivity. Here's a general overview of the process of getting chatroom messages. We'll start by retrieving the messages from Firebase, then we'll send them to our ListAdapter class, and finally, we'll query some user specific data using the user id attached to the message. Pretty much an identical process to retrieving a list of chatrooms, except we don't need to do a query inside the ListAdapter. Everything starts off pretty standard here. We get our database reference, then we use. child three times to get the reference down to the messages node of the chatroom, and if you're wondering how I got the chatroom object here, it came from the Intent extra passed from the previous activity. The method that sets the chatroom is called getChatroom and it's right here. So anyway, we use the chatroom id from the Intent extra, and then we reference the chatroom messages node to get the messages. Like always, we add an addListenerForSingleValueEvent, and we iterate through the results by calling getChildren on the data snapshot. Note that this line of code isn't needed. I forgot to delete it after testing. Now we're going to do something a little different. This loop will retrieve the messages from the chatroom, but we need to do a secondary query because we need to retrieve the user information for the user who posted the message. Remember, we don't save user specific information anywhere except the user's node. Instead, we save their id and then we query the data independently to keep data consistent. So, as you can see, there is a comment down here that says, query the user's node to get the profile images and name. The method that we'll use for this is called getUserDetails, and we'll take a look at it after we're done here. So back up here inside our dataSnapshot loop, we need to create a ChatMessages object and assign the fields. After the fields are assigned, we add the message to the messages list. You'll notice that we're checking to see if the user id is null here. That's because we have that welcome message in every chatroom, and they don't have a user id attached to them, so that's an exception case and we need to handle that using this else block down here. We're done retrieving all the messages, so we can set up the ListView and ListAdapter by calling initMessagesList. Now, we're ready to get the UserDetails for each individual method. Scroll down to the getUserDetails method. We'll start off by getting our database reference, but now we need to do something different. We're going to loop through all the messages and query the user's node looking for the user id that's attached to that message. So I'm going to use. orderByKey and then. equalTo the user that we're looking for. I'm referencing the array positions using the i iterate variable from the four loop. Here's another thing I'm doing differently than what we've done in the past. Notice we're not iterating through the children of the DataSnapshot. We only need to get a single user object from the database so there's no need to loop, we can just go DataSnapshot singleSnapshot = dataSnapshot. getChildren. iterator. next and get the data snapshot that way. That will just retrieve a single result, which is all we need. We then set the profile image and name using the single snapshot, remember to reference the user class here since we're getting a user object, and once we get the user details, we can just call notifyDataSetChanged on the adapter and the list adapter will be updated with that new information. So that's it for retrieving the messages, but we're not done yet. How do you think we deal with the situation when more than one user is inside a chatroom and then simultaneously posting messages? We need a way to update the messages in real-time or the users are subject to seeing old data. There's a very simple solution to this problem. Scroll down to the method named enableChatroomListener. Here we implement something you haven't seen before. So far, we've only been using the AddListenerForSingleValueEvent method on our database references, but here we use the AddValueEventListener method. This method will listen constantly for any changes to the node that it's referencing. So, as you can see, we referenced the chatroom messages node to the chatroom we're currently in, then we use the addValueEventListener method so any updates, deletes, or inserts made to this node will trigger this method. So inside it's interface, we can then call getChatroomMessages, therefore causing all changes to be published to the messages list view. So every user looking at the chatroom will be seeing the same data in the same order. Also, just an FYI, this method will trigger automatically once the activity starts without any changes being made to the database. So, we can just call the enableChatroomListener method in our getChatroom method, and all the messages will be added to the list view as soon as the user joins the chatroom, and one last thing before we move on, it's important to remove this type of event listener because it will continue listening when you leave the chatroom. So, inside the onDestroy method, we can call removeEventListener on the database reference and pass our ValueEventListener. All right, that's it. We've added a ton of code in this module. So in the next section, we'll do a quick review before moving on to the final module.

Reviewing the Chatroom System
In this section, we'll quickly review everything we've covered in the chatroom system. The first thing we needed to build was a way to create chatrooms. Creating a chatroom is simple. We get our DatabaseReference, create a new chatroom id, declare a chatroom object, and assign the fields, and insert it into the chatrooms node in the database. Next, we needed a way to retrieve a list of all the chatrooms and display them in Chat Activity. This was a little trickier than what we're used to when it comes to reading from a Firebase database. Like always, we started by creating a DatabaseReference, then a query object, but when we iterate through the datasnapshot, we type casted the results to a HashMap. Remember, we had to do this because we're saving a list of messages inside the chatroom node. Firebase is interpreting the messages as a HashMap. We then iterate through the list of messages, and add them to the messagesList. After we built a way to create and retrieve chatrooms, we needed a method for inserting new messages. To insert messages, we instantiate a chatMessage object, assign the fields, get our DatabaseReference, create a new message id, and insert it into the respective chatroom by referencing the chatroom id. And last but not least, we needed a method for reading messages from the chatroom that we're looking at. We started by getting a DatabaseReference, then creating the query object, and referencing the chatroom messages node. Then creating ChatMessage objects for each one of the messages that we retrieved, and adding them to the MessagesList. After we found the messages, we still needed to query their specific user details using the user id. For that, we used a separate method named getUserDetails. So that was all of our methods for retrieving and creating data, but what about the issue when multiple users are viewing the same chatroom? How did we ensure that the data they're seeing was up to date? We solved this problem by adding an addValueEventListener on the chatroom messages node. We then implemented a ValueEventListener interface. When users join the chatroom, there'll be a listener intercepting all changes made to the ChatroomMessages node. This will ensure the users are all seeing the exact same data. We made sure to remove the listener in the onDestroy method because if we don't, it will continue listening even when the user exits the activity. And one last time, here's a high-level overview of what we did in this module. Number one is we created chatrooms. Number two is retrieved the list of chatrooms. Number three is we created messages, and number four is we retrieved a list of messages. That's all for this section. In the next module, we're going to quickly review everything and tie it all together.

Tying It All Together
Tying It All Together
Congratulations on reaching the end of the course. In this final module, we're going to briefly summarize everything we've covered and solidify this new knowledge. First, we talked about the features that make the Firebase Database and Cloud Storage stand out from the crowd. Regarding the Database, we talked about how there is no server required. Firebase has custom methods for communication with the Database. Sending data is as simple as typing a few lines of code. You don't need to worry about sending requests to a server, like using Gets, Puts, and Posts requests. Security and security customization. If you integrate their authentication tool, security becomes a walk in the park. You can get as specific as defining custom rules for each database node, or get as a vague as only requiring authentication to read or write to the database. Data in real-time. Users demand information at their fingertips and they want it now. These days, having a database that operates in real-time is almost a requirement for any new technology to survive. As you saw in the many demos we did in the course, information is updated in real-time in the Firebase Database. Insertion of custom Java objects directly into the database. With Firebase, you can create custom Java object classes and insert objects directly into the database. This ensures data is always consistent and is yet another way Firebase speeds up the data management system. Scalability. Firebase scales to fit your storage and bandwidth needs. You are only charged for what you use. Google product. Firebase is a Google product, and the Firebase SDK is fully integrated with Android Studio. Firebase is being constantly updated with new features and the technology is always advancing. Regarding Cloud Storage. There are so many options out there, and they're all very similar. In the introduction of this course, I compared Firebase with one of the industry leaders, Amazon S3. So, what makes Firebase superior to Amazon S3? The number one reason is ease of integration. All Firebase tools work extremely well with one another, and they're literally built for mobile development. They're custom methods built for uploading and managing files, additionally, all upload tasks are automatically run on background threads. I don't know about you, but I absolutely love not worrying about the main UI slowing down. In the next module, we went over how to integrate an Android Studio project with a Firebase project. in other words, we connected our application to the Firebase servers, and added all the required dependencies for using the Firebase database and Cloud storage tools. We covered the SDK requirements for using Firebase. How to create a new Firebase project at firebase. google. com. How to sync your Android project with your Firebase project. This entailed referencing your package name, downloading a Google-services-json file so Firebase could identify your application, and adding the required dependencies. Although it wasn't featured in the course, we also enabled email sign-in from the Firebase console so users could register and sign-in. Don't forget that you can use multiple Android Studio projects for a single Firebase project. Your applications can share users, a database, or any other features that Firebase offers. The next module was broken down into three subsections, building and inserting custom Java objects, inserting data when a new user registers, and updating a user's profile data. The next module was composed of four subsections, reading the database using a query, Firebase query methods, the limitations of Firebase queries, and backing up your data. The next module was broken down into five subsections, selecting an image to upload, compressing an image before uploading, uploading an image to Firebase storage, retrieving an image URL from the database, and Cloud storage review. The final module was broken down into five subsections, creating a new chatroom, retrieving the list of chatrooms, deleting chatrooms, inserting chatroom messages, and retrieving chatroom messages. The titles are pretty self-explanatory here, so I think you get the big picture. Essentially this whole module was a practical example of what we learned in the modules prior. I wanted to make sure I included something valuable with practical use before ending the course. Learning concepts is great, but seeing them in action is far better. By completing this course, you've added a powerful new asset to your developer toolbox. With Firebase authentication, the database, and Cloud storage you have all the basic building blocks for a production mobile application. So, whether you're going to start exploring a new app idea, or build a new tool to improve a process at your workplace, I hope you've enjoyed the course and I have successfully portrayed the power of the Firebase Database and Cloud Storage, and as always, thanks for watching.

Course author
Author: Mitch Tabian	
Mitch Tabian
Mitch loves to teach, but his close second is learning new technologies. The tech industry is evolving and changing at an incredible rate. It's almost as though a new coding language is built every...

Course info
Level
Intermediate
Rating
4.7 stars with 26 raters(26)
My rating
null stars

Duration
2h 3m
Released
20 Nov 2017
Share course

