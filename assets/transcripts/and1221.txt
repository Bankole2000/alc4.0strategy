Android Fundamentals: Intents
by Chiu-Ki Chan

Intents allow Android apps to work together. In this course, you'll learn how to use intents to launch other activities both within your own app and outside, plus how to accept intents from other apps.

At the core of developing any Android application is how different components work together. Android achieves that by intents. In this course, Android Fundamentals: Intents, you'll learn different ways to use intents with activities, including both within your own app and outside. First, you'll cover how to use explicit intents to launch an activity within your app. Next, you'll delve into how to use implicit intents to launch an activity outside of your app. Finally, you'll explore how to use intent filters to accept intents from other apps. By the end of this course, you'll have the fundamental knowledge of Android intents, and how to utilize it to have different apps working together seamlessly.

Course author
Author: Chiu-Ki Chan	
Chiu-Ki Chan
Chiu-Ki is a mobile developer with a passion in speaking and teaching. Her mother tongue for mobile is
 Android, acquired while working on Android Maps at Google. Now she runs her own mobile...

Course info
Level
Beginner
Rating
4.3 stars with 23 raters(23)
My rating
null stars

Duration
1h 38m
Released
12 Jun 2017
Share course

Course Overview
Course Overview
Hi everyone! My name is Chiu-Ki Chan, and welcome to my course, Android Fundamentals: Intents. I am a Google developer expert on Android. An intent is integral to Android. It allows components within an app and across apps to talk to each other leading to a very extensible system. This course will show you how to use Intents in activities. Before beginning the course, you should be familiar with how to build a basic Android app. If you have never built an Android app, watch Start Developing for Android to get up to speed. Some of the major topics that we will cover include using explicit intents to move between activities of your own app, using implicit intents to launch another app, accepting incoming intents from other apps using intent filters, and how to test it from a web page, another app, and a DB. By the end of the course, you will know the basics of Android intents and how to use them to have different apps working together seamlessly. I hope you'll join me on this journey to learn how to use Android intents with the Android Fundamentals: Intents course at Pluralsight.

Introduction
Overview
Hello! This is Chiu-Ki Chan, and welcome to Android Fundamentals: Intents, the introduction module. In this course, I am going to explain to you what is an intent, and how is it used in Android. We will focus on activities exploring examples for explicit, implicit, and incoming intents. After that, I will give you a quick overview of how intents are used beyond activities in services, broadcast receivers, etc. By the end of the course, you will have the foundation to use intents to coordinate different Android components to build a rich Android application. What is an intent? An intent is an abstract description of an operation to be performed. It can be specific, for example, Open the About page for my app, or general, for example, Take a photo. Intents are the glue that allows different Android applications to work together. Think of it like a web link. It tells the browser that the user wants to go from one place to another on the web. Intents are similar. They tell Android where to go. Compared to web links, intents are much more powerful. They can move information back and forth. For instance, your app may want to pick a photo from the phone. You send a Pick photo intent to the Android system, which opens the gallery app. Once a photo is picked, it gets sent back to your app. How do intents work? An intent alone does not do much. The power lies at the intent resolution in the Android system. Intent resolution allows apps to express their request in an intent and the system to dynamically match the components to fulfil that, meaning that your app may gain extra functionality depending on what other apps are installed in the system. This makes Android very extensible. Let's go through an example of intent resolution. Say your app wants to take a picture. Most Android phones ship with a camera app, so when you send a Take photo intent, the Android system will launch the camera app. However, the user may download another camera app from the Play Store to get new functionalities, say Panorama. In that case, after the system receives the intent to take pictures, it goes through all the installed apps to find the ones to fulfil that and show them to the users to pick one. This way your app is automatically customized to the camera the user prefers completely seamless to you. And if they got a new app like panorama, that adds functionality to your app without you doing anything. This is the power of the intent system. Different apps can work together tightly. In this course, we will focus on how to use intents in activities. In particular, you will learn how to launch a specific activity with an explicit intent, expressing your request in an implicit intent and letting the user decide, and, finally, how to register your app with the system to accept incoming intents from other apps.

Launching a Specific Activity with an Explicit Intent
Overview
Hello! This is Chiu-Ki Chan, and welcome to the Explicit Intents module. Intents allow us to tell Android where to go. An explicit intent lets us tell Android exactly where to go. Think of it like an exact address in real life. You can tell someone to go to the ABC Store on Main Street as opposed to telling someone to go to a grocery store. In the case of Android, we will need both a package and an activity to specify exactly where to go. Once we put the package and the activity in our intent, we can call the function startActivity to go to where we want to go. Sometimes, just the address is not enough. We also want to specify more parameters. For example, you may want to say you want to get 12 eggs. In Android, you can use extras to do that. After you specify your activity, you can use putExtra to put any key value pair you want. In the receiving activity, it can call getIntent and then get the extra to see what parameters were specified. StartActivity lets us launch another activity. But what if you want to return some result from that activity back to the place where you came from? In that case, you will call startActivityForResult. StartActivityForResult is very similar to startActivity. You give it an intent but also a request code. This way, when the other activity returns the result, you'll have a way to tell where it came from. To return the result, the receiving activity calls setResult, which will then return the result to the calling activity. The calling activity needs to override onActivityResult to process what came back. To understand how explicit intents work, let's go through an example.

Creating a Second Activity
To get started on the app, clone this GitHub repository, import it in Android Studio, and then switch to the branch 01-main. Right now, the app doesn't have much, just a MainActivity. Let's run it. In the MainActivity, there is a button that says Roll. It is not hooked up yet, so even if you click on it, nothing happens. What we will do now is to add a second activity called DiceActivity and hook it up to this button. Right-click on the package name, select New, Java Class. We will name it DiceActivity. Have this class extend the class Activity. Then press Ctrl+O to override the onCreate method. Let's copy the layout from the MainActivity. Copy, paste, and rename it to activity_dice. Instead of a button, we will have a TextView. Give it the ID result. Go back to DiceActivity and setContentView. Next, we will need to declare this activity in our manifest. Press Alt+Enter to create the string resource for the title. Now that we have a second activity, how do we make the Roll button go there? Go to activity_main. xml and add an ID so that we can find the button in MainActivity. java. Go back to the MainActivity and find the button. Set the OnClickListener on the button. Add a helper function called roll, and call it in the OnClickListener. Inside this function, we are going to launch the activity DiceActivity. The way to do that is to declare an intent. New Intent(this, DiceActivity. class). The first parameter, this, refers to MainActivity. And it is given as a context. The reason why we need a context is that we need to tell Android which package we want to go to. In this case, it's our own package, so we just give the context, this, referring to the MainActivity itself. The second parameter tells Android where exactly to go within this package. DiceActivity is where we want to go. Now that we have an intent, we can startActivity with it. Let's run the app. When you click on the Roll button, it opens up a blank screen with the title result. Yes, this is DiceActivity. We have successfully used an explicit intent to go from one activity to another. Now, let's make DiceActivity a little bit more interesting by having it generate a random number from 1 to 6 just like when you roll a die. First, let's find the TextView and call it resultView. Next, we will add a function called rollOne to generate that random number. Create the field random with the type Random. Next, we will call rollOne and put the result in resultView. Let's run the app. Now when you click on Roll, you will see a number. Go back and click again. A different number.

Passing Parameters Using Intent Extras
We are going to make our DiceActivity even more interesting by having it roll multiple dice. To do that, we will add a new function called rollAll. It takes two parameters--TextView to set the result and numDice for the number of dice you want to roll. In rollAll, we have a for loop that calls rollOne as many times as we have with dice. After each roll, we stash the result in the builder and then also sum it up in the variable total. At the end, we append the string = and then put the total right there. After that, we call builder. toString to set the result to the textView. Now let's call rollAll. Let's say we want to roll two dice. Great! Let's run the app. Click on Roll, and we see that we roll two dice. And we can see the individual results and also the total. Let's try again. Yay! Another dice roll. I can do this all day, but let's get back to Android. Notice that I hardcoded the number of dice 2 into DiceActivity. Wouldn't it be nice if I could call from MainActivity and tell DiceActivity how many dice I want to roll? You can do that by setting an extra in your intent. In DiceActivity, let's add a parameter called KEY_NUM_DICE. An intent extra allows you to store a key value pair inside an intent. The key is any string you picked. The only requirement is that the path that sets the key and the path that reads the key have to agree on what exact string to use. This is why I put it in the variable so that I know for sure the key is matching. Let's go to MainActivity. In the function roll, we are going to set KEY_NUM_DICE. Intent. putExtra(DiceActivity. KEY_NUM_DICE, 3). This means I want to roll three dice. Now we need to go to DiceActivity to read this value. To do that, you will need to call getIntent to retrieve the intent that this activity was started with. Then we will call getIntExtra with the key we want to retrieve, In this case, KEY_NUM_DICE. GetIntExtra takes another parameter. That's the default value in case the intent does not contain this key. We are going to give it the value 1, meaning we are going to roll one die if nobody told us how many dice that they want us to roll. Let's run the app. When we click Roll, we see the result of the dice roll. It looks just like what we had before except we had three dice instead of two. To recap, if you want to pass parameters in an intent, you can put an extra and get an extra on the other end. It is a key value store, so make sure that your keys are matching. Otherwise, you can put all the values in but nobody will be able to read them properly. I recommend using a variable.

Returning Results Back to the Calling Activity
So far we have seen how we can pass from one activity to another. What if we want to pass some result back? Android allows you to do that by calling startActivityForResult instead of startActivity. Go ahead and replace startActivity with startActivityForResult. This function takes two parameters. The second parameter is a request code. We need a request code because when the result comes back to us, we need to know what to do with it. In a more complicated activity, you may be calling startActivityForResult into different activities, and we want to know which one was it calling back from. We are going to make a variable called REQUEST_CODE_DICE. Alt+Enter to create a constant field. Give it an integer value. It does not matter what exact value of integer you give it as long as when you have multiple request codes, they are different. Next, we need to change DiceActivity to return the result. In DiceActivity, we will change the variable total from local to a field. Next, we are going to add a button to DiceActivity. When this button is pressed, we are going to finish this activity and pass the total back to whichever activity that calls it. Open activity_dice. xml to add a button. Go back to DiceActivity, find the Done button. Set up an OnClickListener for the Done button. Here we're going to pass total back to whoever calls us. To do that, you will use the function setResult. The first parameter is the resultCode. We are going to use Activity. RESULT_OK, meaning that everything went as expected. The second parameter is the data we want to pass back as result. It is an intent, so let's create that. Just like how we put extra from Activity to DiceActivity to store the number of dice we would like to roll, we are going to use putExtra to put the total as a key value pair into this intent. Press Alt+Enter to create the KEY_TOTAL constant. Change this constant from private to public. Can you guess why we did that? Yes, because we are going to need this KEY_TOTAL string to retrieve this value in MainActivity. But before we do that, we need to finish this activity when the Done button is pressed. So call finish after setResult. Now, let's go to Main Activity. When setResult is called, MainActivity will be notified by the onActivityResult callback. Let's override that. OnActivityResult has three parameters-- requestCode, resultCode, and data. In our case, when the requestCode is REQUEST_CODE_DICE and the resultCode is Activity. RESULT_OK, we would like to go ahead and display that result. Otherwise, we will keep the super call in case our super activity handles some other activity result. To display the result, we will to add an extra field into our layout. Let's go to activity_main. xml. After adding the result view, we will go back to MainActivity and use that to display the result. FindViewById for the ID result and assign it to the resultView field variable. Then in our activity result, retrieve the total from the intent and set it in the resultView. Let's run the app. When we click on Roll, we see that we got three dice rolled with the total. Clicking on Done brings us back to MainActivity with the result. You can keep going and see different values.

Conclusion
In this module, you learned how to go from one activity to another with an explicit intent. To make an explicit intent, you will need to specify the package and the activity. We usually specify the package by a context, which is the activity that you're calling from. In other words, this. You can call startActivity to launch the activity that you want to go to. If you would like to pass some extra parameters to that activity, you can call intent. putExtra. My recommendation is to define a constant to use as the key in the key value pairs in the activity extras. This way, you know that the keys are matching. To pass a result from an activity back to the activity that calls it, the calling activity needs to use startActivityForResult and specify a request code. For an activity to return a result, it will need to call setResult. Use activity. RESULT_OK to indicate that this is a normal operation. If you want to pass data back, you will need to create an intent and put them as extras. After setResult is called, the result will be passed back to the calling activity in the function onActivityResult. Check for the requestCode and the resultCode and extract the values of the data intent to use in this activity.

Specifying an Action by Implicit Intent and Letting the User Decide
Overview
Hello! This is Chiu-Ki Chan, and welcome to the Implicit Intents module. Intents allow us to tell Android where to go. An explicit intent tells Android exactly where to go like a street address. An implicit intent tells Android what we need at the destination. It is like telling someone to go to a grocery store but without specifying which particular one. In an explicit intent, we specify a package and an activity. In an implicit intent, we specify the action. When you tell someone to go to a grocery store, there may be more than one to choose from. Same for Android. The Android system matches all the apps that can refill the request and lets the user choose if there is more than one. In this module, we will look at different ways to specify an implicit intent. In particular, we'll be trying some of the intents listed in the Common Intents page on the official Google documentation.

Using ACTION_VIEW to Launch the Browser and Open Google Maps
To get started on the app, clone this GitHub repository. Import it in Android Studio, and switch to the branch 01-base. Run the app. Right now the app has a bunch of buttons in it hooked up to empty functions. We are going to use these functions to try to implement different ways of using implicit intents. The most basic action is View. Let's put that in the link function. Create an intent. SetAction to Intent. ACTION_VIEW. What are we going to view? To tell Android where to go, we need to setData. SetData takes a URI as the parameter. So let's define it to go to the Pluralsight web page. Once we define the URI, we can put it into the intent with setData. Now we have defined our implicit intent. Let's call startActivity with it. Run the app. When we click on the link button, it opens the browser and goes to the Pluralsight web page. This is the behavior of ACTION_VIEW when you give it a website. We can make our intent definition a bit more compact by directly passing the action and the data URI into the constructor. Move the URI line to be the first. Then in the constructor of the intent, put Intent. ACTION_VIEW as the first parameter and a URI as the second parameter. With that, you can delete the setAction line and the setData line. This is exactly the same as what we have done earlier but much shorter and easier to read. Besides opening a web page, we can actually use the View intent with the URI to open an app. Android allows apps to register themselves with certain domains and certain URI patterns. Let's try that with a mapLink. Copy and paste the three lines of code from the link function. Then replace the URI from the Pluralsight to maps. google. com/maps? q and then latitude and longitude you want the map to open to. Let's run the app. When you click on mapLink, instead of going to a browser, the map app is opened. This is because Google Maps registered this URI pattern, and then the Android system sees that your URI in the intent matches this pattern, so it opens the map's app instead of the browser. Right now, the URI still looks like a valid web link. But you don't have to do that. The URI can be anything that you define. As long as the receiving app recognizes that URI pattern, it will be used to open that URI. For instance, the Google Maps app recognizes the geo: URI pattern. Let's try that. Copy and paste the three lines of code from the mapLink function into the mapGeo function. Change the URI to have the geo: prefix. And let's run the app. Click on the mapGeo button. And, once again, the map's app is opened. Here we have three examples of using ACTION_VIEW with different URIs. The first one is a general URI that has not been associated with any apps installed on your device. In that case, Android opens the web browser with the link you specified. In the second case, it is also a web link, but you have an app, namely Google Maps, that has registered this URI pattern. In this case, Android opens the map's app with this URI. In the third case, it does not look like valid web link anymore. But because the Google Map's app has registered this particular URI pattern, it is used to open this.

Using ACTION_DIAL to Launch the Phone Dialer
Now you may ask me, How do I know that this geo: pattern is recognized by the Google Map's app? Well, indeed, this is information that is hidden within the map app itself. So the way I know that is because Google has a page called Common Intents which lists that. Let's take a look. The Common Intents page lists many different implicit intents that you can use. So far, we have been using the ones listed in the Map section. As you can see, it tells us to use the ACTION_VIEW action, and then the data URI scheme is in the format geo: latitude, longitude. Let's try another intent listed on this page. Go to the Phone section. Instead of the ACTION_VIEW action, we are going to try ACTION_DIAL. According to the documentation, we can use tel:(phone number) as the data URI. Let's try that. In the dial function, let's define a URI in the format tel: and then the phone number. Next, we are going to create an intent with the action ACTION_DIAL and the URI which contains the phone number. Finally, call startActivity with the intent and run the app. When we click the Dial a Number button, the dialer app is brought up with the number that we gave it in the data URI. This is very similar to the ACTION_VIEW action that we just did except because we gave it a different action, a different app is used to handle this intent.

Using ACTION_GET_CONTENT to Get an Image from the Gallery
So far, the intents we have been using launch a new activity. We can also use intents to launch an activity and then get some result back. Let's try that with a gallery app. Create a new intent and set its action to ACTION_GET_CONTENT. What type of content? Instead of using setData, we can use setType to tell Android what type of content we want. In this case, we want images, so we specify the MIME type image/*. To get data back, we also need to specify an extra with the key return-data and then true. Finally, since we need to get data back from the gallery, we will call startActivityForResult instead of startActivity. StartActivityForResult needs a request code, so let's define that. Press Alt+Enter and Create constant field. It doesn't matter what value we give it as long as when you have multiple request codes, they are different. This way, when the result comes back, we can tell what we are trying to do in the first place. Speaking of results coming back, we need to override onActivityResult so that we can handle the results coming back from the gallery. Press Ctrl+O to override the method onActivityResult. Here, if the requestCode is REQUEST_CODE_GALLERY, and the resultCode is Activity. RESULT_OK, we will try to load the image. The way this works is that the gallery app will pass us the imageUri inside the intent called data in the parameter of onActivityResult. Let's save this imageUri to a field variable and then use it to load the bitmap and then set it on an imageView. To get the bitmap corresponding to that imageUri, we will call the function MediaStore. Images. Media. getBitmap. This may throw an exception, so we will wrap it in a try/catch block. Press Alt+Enter to surround it with a try/catch. At this point, we won't do anything if we have an error, so just empty out the catch block. Now that we have the bitmap, we will need to set it to the imageView. But we don't have an imageView yet, so let's go to onCreate, and use findViewById to locate it. Then go back to onActivityResult and call setImageBitmap on the imageView with the bitmap that we retrieved from the media store. Once we set the image in the imageView, return. Otherwise, it will fall through to the super call in case our parent is going to be able to handle some other requestCodes. Let's run the app. When we click on Pick Image, Android sends us to the gallery app. But since we are running this on an emulator, it didn't come with any images. So let's go to the browser and download an image so that we can use it here. Long press on an image and click Save image. Now that we have downloaded an image, when we click Pick Image, we go to a gallery with something that we can pick. So let's pick the image. And now we can see that the image is loaded into our imageView.

Using ACTION_SEND to Share Text and Image
In the gallery example, you saw ACTION_GET_CONTENT, which allows the gallery app to provide data to other apps. Android also has an action for the other way for apps to send data to other apps for sharing. In that case, we use ACTION_SEND. Let's try an example where we send text to another app. In the sendText function, create an intent and set the action to Intent. ACTION_SEND. Next, we want to tell Android what text we want to share. We will use the extra Intent. EXTRA_TEXT to do that. Intent. putExtra, and then use the key Intent. EXTRA_TEXT, and then the value is the text that you want to share. Now, just like the gallery example, we also need to specify the type. In this case, we will specify it as text/*. The reason why we need to specify the type is that we want to tell Android what kind of data we are sharing. In this case, we are telling Android that this is a piece of text. We have specified our intent. Let's start the activity. Run the app. When you press Send Text, you are sent to the SMS app. Give it a phone number, and the message window is prepopulated with the text that we put in the intent. The reason why we go directly into the SMS app is because on the emulator, the SMS app is the only one that is capable of handling this particular ACTION_SEND type, the text/* type. If you run it on a real device, you will see a lot more choices. For example, email, or if you have other apps installed such as Slack or WhatsApp that are capable of sharing text, those will be listed as well. Next, let's try to share an image. Wait! What image? Remember in the gallery example, we picked an image and put it in the imageView, why don't we share that one? To share that image, we are going to use the imageUri member variable. That member variable is not going to be set if we don't have an image picked yet. Let's handle that case by showing a toast. If the imageUri is null, we will make a toast with the error message of no_image_picked_error and then show the text and return. Otherwise, we will prepare an intent to share the image that has been picked. Create an intent with the action ACTION_SEND. Call intent. putExtra, Intent. EXTRA_STREAM as the key and imageUri as the value. This tells Android what image we want to share. Now that we have given Android the imageUri, we still need to tell Android what type it is. This way, it will be opened by the correct app. In our case, it's a little bit tricky because the MIME type of an image can be a JPEG or a PNG, and we don't really control what images get picked from the gallery. Fortunately, you can determine the MIME type of the image just by the URI. And there's a handy helper function to help you do that. You can call intent. setType with the type as computed by the getContentResolve. getType. Now the intent is ready. Let's start the activity and run the app. When you click on Send Image, the toast is shown because you have not picked an image yet. So let's pick an image. Now when you click Send Image, you are given the choice between a Messenger app and the Maps app. This is because both apps are registered to handle the ACTION_SEND with that particular type of image. Let's choose the Messenger. Here we go. We are in the Messenger app with the image ready to be shared.

Handling the Case When No Activities Matches the Intent
So far, we have seen the case where there is exactly one match for the implicit intent in which Android will automatically open the app corresponding to it. And we also see the case where there is more than one app that matches the intent, in which case the Android system will show a choice for the user to choose. But what happens when there are zero apps matching the intent? Let's try that. Here we are going to try to get Android to send an email by using the ACTION_SEND intact action combined with the type message/rfc822. We can use the Intent. EXTRA_EMAIL to specify the recipient of this email, and EXTRA_SUBJECT to specify the subject, and then also EXTRA_TEXT to specify the body of the email. Then call startActivity. In this emulator version that I'm using, there is no app that can handle this type of intent. So we will see what happens. When we run the app and click on Send Email, the app crashes. Let's check the log. In the log, you can see that the app crashes because of an ActivityNotFoundException. It says No Activity found to handle Intent. So how do we know whether the Android device actually has any app that can handle our implicit intent? We can ask the Android system to resolve this intent before we launch the activity. If (intent. resolveActivity), and then you need to give it a parameter of a Package Manager. So if this function call returns something that is not null, that means there are some activities that will be able to handle this intent. Let's run the app. Now when we click on Send Email, the app doesn't crash. But it's still very confusing for the user when they click on a button and nothing happens. So one thing you can do is that if resolveActivity returns null, show some error message. Another thing you can do is to wrap your intent with Intent. createChooser. This way, the chooser UI will be presented no matter how many activities are able to handle the implicit intent. And, yes, that includes zero activities. Let's try that and see what happens. Intent. createChooser takes two arguments. The first argument is the actual implicit intent that you want to use. The second argument is the title of the chooser UI. Let's launch the app. This time when we click Send Email, we are presented with the chooser. The chooser has the title Send to, which is what we gave it, but then it helpfully tells the user that no apps can perform this action. This way, the user knows that they actually clicked on the button, but there are no apps that are able to fulfil that action. In general, it is a good idea to wrap an implicit intent in a chooser before calling startActivity.

Conclusion
In this module, we looked at different ways to specify an implicit intent. Every implicit intent needs an action. The most basic action is ACTION_VIEW, which is used with a data URI. When the data URI is a web link, Android opens the browser by default. However, apps can register various URI patterns. In that case, Android will open those apps to handle the implicit intent. There are many actions besides ACTION_VIEW. We looked at the Common Intents page and tried ACTION_DIAL to open the dialer with a phone number. We also tried ACTION_GET_CONTENT with startActivityForResult to get an image from the gallery. Another useful action is ACTION_SEND, which lets us send data to other apps for sharing. To use ACTION_SEND, we need to specify the type, for example, text or image, so Android knows which apps will be able to handle it. Finally, we looked into the case when there are no apps on the device that can handle the implicit intent. We can either call resolveActivity and show an error message when it returns null, or wrap our implicit intent with a chooser so that the Android system always presents the chooser UI and populates it with an error message as needed.

Accepting Incoming Intents from Other Apps
Overview
Hello! This is Chiu-Ki Chan, and welcome to the Incoming Intents module. In Android, you can use implicit intents to request an action from another app component. In this module, we will look at how to have your app receive implicit intents from other apps. To advertise which implicit intents your app can receive, you need to declare an intent filter element in your manifest file. In fact, you have already done that for your launcher activity. Let's look into what defines an intent filter. An intent filter has three parts--action, category, and data. When the Android system receives an implicit intent, it tries to find activities to fulfil it by matching the action, then category, then data. Action defines what the intents want to do. For instance, the VIEW action indicates that we want to view something, and the SEND action indicates that we want to share some data. Category defines which parts of the Android system can access this activity. Launcher allows the app to be discovered by the app launcher, which is how your main activity shows up on the app drawer. DEFAULT allows the app to be started by startActivity or startActivityForResult. BROWSABLE allows the app to run when the user clicks on the link in the browser. Data further filters the set of apps that match the intent. There are two ways--URI structure and MIME type. Each URI is in the format scheme://host:port/path. Here are some examples. Data type is specified as MIME type. For instance, text/plain, audio/mpeg4-generic, image/jpeg, or image/*, which means any kind of image such as JPEG, PNG, etc. Let's go through some examples. In this example, we want LearnActivity to be launched when someone clicks on the link Pluralsight. com or when someone calls startActivity with this URI. The first thing we need to specify is the action. In this case, we will use the VIEW action because that works with the browser. Next, we have categories. The first category, DEFAULT, means that we want to be able to launch from startActivity or startActivityForResult. BROWSABLE means that we want to be able to be launched from the browser, meaning when someone clicks on a link. Next, we have data URI. We specify the scheme as HTTPS and then the host to be www. Pluralsight. com. Both the scheme and the host have to match in order for LearnActivity to be considered a match. Let's also look at an example for the MIME type. First, we specify the action. In our case, we are going to match the action SEND so that other activities can share data with us using this action. Next, we specify the category DEFAULT, which means that we are going to be receiving intents that are launched by startActivity or startActivityForResult. We specify two MIME types here--one is text/plain, and the other one is image/*. Unlike the URI, which you have to match both the scheme and the host, the MIME type is either/or, meaning that if someone wants to share text, ShareActivity can handle it. But if someone wants to share images, that works too. The incoming intent will have either the MIME type text/plain or any image type. In this module, we will write an app that has three sub-activities. Each of them will show us how the action, categories, and data together define how these activities can receive intents. We will see how to test incoming intents from the browser, from another app, and also from the command line using ADB.

Using ACTION_VIEW to Accept a Web Link
To get started on the app, clone this GitHub repository. Import it in Android Studio, and switch to the branch 01-base. Right now, there are two apps in this repository--incoming and outgoing. We will be adding intent filters to the activities in the incoming app. And then to test these intent filters, we will be sending implicit intents from the outgoing app to make sure that the incoming app is receiving these intents. Open MainActivity in the incoming app. Run the app. The three buttons in MainActivity each launch one activity. We'll be adding intent filters to MainActivity and also each of these other activities. The first thing we are going to do is to have MainActivity be opened when someone clicks on the link. Go to AndroidManifest. xml. If you look under MainActivity, we already have an intent-filter. This intent-filter has the action, MAIN, and then the category, LAUNCHER. You have seen this many times already. Do you know what it means? This means that we want this activity to show up in the LAUNCHER, also known as the app drawer. This is something that you use every day. It is the drawer that contains all the apps, the browser, the dialer. They are all listed here because they put this intent-filter in the manifest. We are going to add one more intent-filter to MainActivity. Copy and paste the intent-filter block. Change the action to VIEW and then the category to BROWSABLE. BROWSABLE means that we want the browser to be able to launch this activity. Notice how intent-filter has some error in it. If you hover over, it says Missing data element. It means that if you just have the BROWSABLE category, it is not enough. You also need to specify the data so that you can tell the browser what URI parent do you want to handle. Let's do that now--data android:scheme="https", and then data android:host="example. com". This tells Android that when someone clicks on a link that has the scheme HTTPS and the host example. com, we want it to be offered as an option. How do we test this? To test this, we want to have a web page that has the link https://example. com. I have prepared an HTML file just like that in the web directory. This HTML page has three links. We are going to use them to help us to test our incoming intents. To use this HTML page, we will need to display it in the browser in our emulator. How do we do that? We need to use the command adb push to get this file onto the emulator. Click on the terminal tab. Type adb push web/test. html /sdcard/. This means that we want to push test. html onto the top level of the SD card of the emulator. Now it's pushed. Let's go to the emulator and open this file in the browser. File:///sdcard/test. html. If the link looks too small, you can adjust the font size in the HTML and push again. Reload the page and click on the first link. Right now, the link is loaded into the web browser because we have not pushed our app yet. This is the normal behavior. But after we install our incoming app with the intent-filter to tell Android that we can handle this particular domain, it will be different. Let's try that. Go back to the browser, and then go back to test. html. Click on the first link again. This time, instead of opening the link, the Android system gives us two options. One is our incoming intents app, and two is the default action, which is to open it with Chrome, the web browser. Click on Incoming Intents. For now, we'll select Just Once. So now we got back to MainActivity. But it looks just like when we are launching the activity from the app drawer. It would be nice if we were able to do something different if we are launched by the browser. To do that, we will try to get the intent from MainActivity. In MainActivity, call getIntent. getData. If this URI is not null, we will display it in a TextView. Run the app. Go back to the browser and click on the first link again. Open with Incoming Intents. This time, you can see that the URI is displayed. Every time your app receives an incoming intent from the browser, the URI will be stored in the data. You can get this data URI by calling getIntent. getData. Right now we are just displaying it. But your app may be doing something different depending on what parameters this intent contains. Right now we are matching the whole domain, meaning that our app can handle everything that has the URL with the host example. com. You can also tell Android that you only want to handle certain paths of that domain. Let's try that. Go to AndroidManifest. xml. Add data android:pathPrefix="/testing". This tells Android to offer our app only if the path also matches. Let's run the app. Go back to the browser. Click on the first link. This time Android did not offer us the option to open the incoming app because the URL is just example. com. The path does not match. If you go back and click on the second link, we are offered the option to use the Incoming Intents app. And when we choose that, the incoming app is launched with the URL https://example. com/testing. There are other ways to specify the path as well. We have used prefix. You can also specify just the exact path or a pattern.

Using ACTION_VIEW to Accept a Non-web Link
Let's add some intent filters to ArcticActivity. First, let's run the app and see what it does. Click on Check Arctic to launch ArcticActivity. It asks you for a latitude, so let's try putting in something like 37. Click Check, and it tells you that it is outside the Arctic Circle. Let's try 73. Latitude 73 is inside the Arctic Circle. If you go to ArcticActivity, you can see that when you click the Check button, the activity takes the latitude from the TextView and compares it to see if it is bigger than 65. 8256 to tell you whether this is inside or outside the Arctic Circle. Let's add some intent filters so that we can accept incoming intents to check whether a latitude is inside or outside the Arctic Circle. Go to AndroidManifest. xml. Copy and paste the intent-filter with the action VIEW. We will modify this intent-filter to do two things. First, we want to accept incoming intent from the browser. To do that, we will be still using the action VIEW and category BROWSABLE. Duplicate the category and change it to DEFAULT. We add the DEFAULT category because we want to be able to reach ArcticActivity by startActivity. Next, we will need to change the scheme to geo. And we don't need a host, so delete that line. Let's run the app. To test this incoming intent, we will use the HTML page that we pushed to the device when we were testing MainActivity. Go to the browser and load the page file:///sdcard/test. html. Click on the third link. We are presented with two options--Check Arctic, our app, or Google Maps. Notice that it is showing Check Arctic, which is the label for ArcticActivity, but not incoming, which is the label for the whole app. This is because ArcticActivity is the one that has the intent-filter that is matching this link. Click on Check Arctic and Just Once. And, yay, ArcticActivity is launched. Next, we'll need to extract the latitude out of the incoming intent. Go to ArcticActivity. In onCreate, we will call getIntent. getData to get the data URI. Next, we need to extract the latitude out of the URI by calling getSchemeSpecificPart. We first check that the URI is not null because when ArcticActivity is launched from MainActivity, there is no data URI in the intent. Next, we are also going to check that the getSchemeSpecificPart function is not returning null. When that is the case, we will split the SchemeSpecificPart by comma. If we get two parts, we will take the first part as the latitude. Then we are going to update the TextView, latitudeView, with this latitude that we extracted from the intent. Finally, we will call the check function on this latitude as if somebody has clicked the Check button. Run the app. Go back to the browser, and click on the geo link. This time, we can see that the latitude has been extracted from the URI and put into the EditText. We can also see that the message, It is inside the Arctic Circle, is displayed. This is how we can get the data out of the intent and use it in the app. We have seen how we can launch this activity from the browser. Let's also try to launch it from another app using startActivity. Open MainActivity under the app outgoing. Run the outgoing app by switching our target from incoming to outgoing and then clicking on the green triangle. Right now the button Is Hong Kong Arctic? is hooked up to the checkArctic function, but as you can see, the checkArctic function is empty so it doesn't do anything yet. Let's fill that in. As a reminder, go to AndroidManifest. xml from the incoming app. What we need is an intent that has the action VIEW and then a data URI with the scheme geo. Go back to outgoing/MainActivity. java, and create a URI with the geo scheme-- geo:22. 276556, 114. 160573. This latitude/longitude pair goes to somewhere in Hong Kong. Next, we are going to create an intent with this URI and also the VIEW action. New Intent(Intent. ACTION_VIEW, uri). Finally, call startActivity with this intent. Run the outgoing app. Click on the first button, and we are presented with two options. Open with Check Arctic and then Google maps. Let's open with Check Arctic. Yay! ArcticActivity is launched with the value prepopulated from our geo URI. It also shows us that Hong Kong is outside the Arctic Circle.

Using ACTION_SEND to Accept Shared Text
Let's take a look at CountCharacterActivity. Run the incoming app. Click on the second button, which says Count Characters. Type something in the EditText. Click on Count, and you will see the number of characters that you have typed. We are going to add an intent filter to CountCharacterActivity so that other apps can send text to it to be counted using the action SEND. Go to AndroidManifest. xml. Copy and paste the intent-filter from ArcticActivity. Change the action to SEND, and then remove the category BROWSABLE. Instead of matching the data URI, we will be matching the MIME type. Change the data tag to android:mimeType and then the value text/*. This intent-filter tells Android that CountCharacterActivity handles intent with the action SEND, and you can start it using startActivity. The MIME type tells Android that it is only able to handle text. So, for instance, if you are trying to share an image, this activity will not be launched. Let's deploy the app. From the incoming app, we can't really tell that we have added an intent-filter. So we are going to test this using the outgoing app. Switch to outgoing/MainActivity. Right now, the countCharacters function is empty. Let's add an intent with the action ACTION_SEND. We will be sending some text, so we will need to call setType to tell Android that the MIME type is text/*. And then we need to tell Android what text are we sending over. We will store the text that we want to share inside the intents using an intent extra-- Intent. putExtra(Intent. EXTRA_TEXT)--and then we are going to retrieve the string that we would like to share out of our string resources. Next, call startActivity with this intent. As a reminder, when you have an intent filter that specified the MIME type, make sure that you include the type in your intent when you're trying to launch the activity. Otherwise, Android will not match it to that activity. Let's run the app and see what it does. Switch to the outgoing app target and click on the green triangle. Click on the second button. We are presented with two choices. One, Count Characters, which is our app, and, two, Messenger, which is another app that is installed on this emulator that is able to handle the ACTION_SEND intent with the type text/*. If you run it on your phone, you will probably see a lot more choices including email, maybe other apps such as Slack, WhatsApp, Twitter. A lot of apps add this intent filter into the activity so that other apps can send it things to share. For us, let's choose Count Characters. Yay! The CountCharacterActivity is launched. But right now we don't see the actual string that is shared to us. Let's fix that. Go to incoming/MainActivity. And come and click on CountCharacterActivity. In onCreate, retrieve the shared text from the intent by calling getIntent. getCharSquenceExtra(Intent. EXTRA_TEXT). If you come and click on Intent. EXTRA_TEXT, you can see that this is a string that is used as a key in the extra. Remember, intent extras are key value pairs with the keys as strings allowing you to store arbitrary values inside the intent. We need to make sure that we are retrieving the data of the intent with the correct key. This is why this is a constant in the class Intent. Also notice that the command says Note that this may be a styled CharSequence, so you must use getCharSequence to retrieve it. What does that mean? If you go back to CountCharacterActivity, you can see that we call the function getCharSequenceExtra and then pass the string Intent. EXTRA_TEXT. There is no type safety here. With the same key, we could be calling getBooleanExtra or getStringExtra. So you need to be very careful when you are retrieving data out of an intent extra to match both the key and also the type. Now that we have the text, let's call textView. setText so that it looks as if somebody has typed the text into the TextView. We only do that if the text retrieved from the intent is not null because when we launch CountCharacterActivity from MainActivity, there is no extra in the intent. After we set the TextView to be the text retrieved from the intent, call count to make sure that the count is computed and displayed. Let's run the incoming app. Verify that Count Characters still works when we launch it from MainActivity. Then switch to outgoing activity and click on the second button. Choose Share with Count Characters. The reason why it says Share with instead of Open with is because we are using the action SEND so the Android system changes the text to indicate that we'll be sharing with a SEND action. Here you can see that the EditText is populated with the string Sharing is caring, which is what we send from the outgoing activity. You can also see that the number 17 is displayed, meaning that we counted the number of characters in that string.

Defining a Custom Action
So far, we have been using built-in actions such as VIEW and SEND. We can also define our own action. Let's try that with our CelsiusToFahrenheitActivity. First, let's run the incoming app to see what it does. Click on the third button. Put 37 in the TextView that says C. Click on Convert, and you can see that it is 98. 60 in Fahrenheit. Go to AndroidManifest. xml. Copy and paste the intent-filter from CountCharacterActivity to CelsiusToFahrenheitActivity. Change the action to something custom. The action is just a string. So to make sure that our action does not clash with any other actions provided by either the Android system or other apps, the convention is to prefix it with our package name-- com. sqisland. intent. incoming. That is the package name. And then we add a string to indicate this action--. CELSIUS_TO_FAHRENHEIT. What we are doing here is to define this custom string so that the Android system knows that our app can handle this action. When other apps want to convert Celsius to Fahrenheit using our app, they can launch an activity specifying this action. The next line is the category. We are going to keep it as DEFAULT because we want people to be able to launch it by startActivity. Finally, delete the data line. We delete it at the MIME type because we are going to rely on just the action to be able to match when other apps want to launch our activity. Let's run the incoming app. Right now, the app doesn't look any different. To test that our app now knows how to accept an incoming intent with our custom action, we are going to go to our outgoing app. Go to outgoing/MainActivity. java. We are going to fill in the convertTemperature function. We need an intent with the same action as the one in the manifest. Let's copy that. Next, we need to put in the intent the number of degrees in Celsius that we want to convert. Let's put that in as an extra. Notice that we put 100f instead of just 100. That is because the putExtra function has the same name but is associated with multiple versions. One of them takes an integer, and one of them takes a float. By specifying 100f, we are asking for the float version. Next, call startActivity on this intent. Let's run the outgoing app. Click on Convert 100C to F. CelsiusToFahrenheitActivity is launched, but it didn't read the extra value yet. Let's do that. Go to CelsiusToFahrenheitActivity. At the end of onCreate, check that our intent contains the key Celsius. If so, get the value out as a float. At this point, we are going to be using the same string Celsius as the key, so let's extract that as a constant. Refactor, Extract, Constant. We will call it EXTRA_CELSIUS. Now that we have a constant, we can use it as the key. GetFloatExtra takes another parameter, which is the default value. Let's give it 0. Next, we are going to set this Celsius into a Celsius value as if the user tied it in. Finally, call convert on this Celsius value. Let's run the incoming app. Go back to the outgoing app, and click on the third button again. This time, the EditText is prefilled with the value 100, which is the value that we passed in from the intent. And then, also, the value 212. 00 F is displayed as the converted value.

Sending an Implicit Intent via ADB
So far, we have tested incoming intents two different ways. One is to have an HTML page so that we can click on the link to test the BROWSABLE category. Two is to have another app so that we can test it using startActivity. Both of them are a bit clumsy because we have to either create an HTML page or a completely separate app. There is one more way to test incoming intents. We can use the ADB command. Open the file scripts/launch. sh. Here are three adb commands we can use to test each of our activities. Click on the Terminal tab. The first command allows us to launch ArcticActivity with a data URL. Let's break it down. First, the command itself is adb shell, which means that we are sending a command into the shell of the emulator. The argument that we give adb shell is quoted with a single quote. This is important because, otherwise, when the command on the other side receives it, it may only receive partial information if we don't quote the whole parameter. Inside our single quotes, we are using am start. Am stands for ActivityManager. And we are using it to start an activity. What activity? We specify that by using an intent. The intent is defined by the action, which is specified by -a. In the case of ArcticActivity, we would like to use action. VIEW. We also would like to give it a data URI, which we do with the flag -d. Let's copy and paste this command to run it and see what happens. When you run this command in the terminal, you can see that it says Starting: Intent, and then the action is the action. VIEW, and the data is geo:87, 65. On the emulator, we are given a choice of Open with Check Arctic or Maps. This is equivalent to calling startActivity from another app, but it is much easier to use it to debug because you can just change the parameter on the command line. Let's open Check Arctic. As expected, the parameter 87 is extracted out of the data URI and then used as the value to check whether it is in the Arctic Circle. Next, let's try to launch CountCharacterActivity. Same as before, we are sending a command to adb shell by putting the whole command inside single quotes. We are calling am start with -a, meaning the action being action. SEND. The next line, -e, allows us to define an extra. The first parameter is the key, and the second parameter is the value. You may wonder how do I know to give it this particular key? If you go to the MainActivity of our outgoing app, you can see that we are putting the extra Intent. EXTRA_TEXT. Cmd+click and you can see the actual string that is defined by EXTRA_TEXT. This is where I got the value. After using -e to define our extra, we also use -t to define the data MIME type that we want to put in the intent to launch the activity. Let's try this. We are given the choice between Share with Count Characters or Messenger. Let's try our own app first. CountCharacterActivity is launched with the string Greetings from ADB, which is the value that we passed in when we launched it using the adb shell am start command. And then also the count 18 is displayed. Let's run this command again but choose a different app. This time pick Messenger. This is the SMS app, so we need to put in a phone number. I'm going to choose one that I've put in before. As you can see, Greetings from ADB is prefilled as the text. This is to show you that this particular command is sending an implicit intent, which means that multiple apps could be receiving it. Finally, we are going to try to launch CelsiusToFahrenheitActivity. This time, the action we are using is the action string that we defined in our AndroidManifest file. Remember, this is a string match so it has to be exactly the same. Usually it's safer to copy and paste. After defining the action, we are also defining the extra. Unlike CountCharacterActivity, we are using --ef. This stands for extra, which is a float, and then the first parameter is Celsius, which is the key for this extra, and the second is 30, which is the float value. Let's try it. This time, CelsiusToFahrenheitActivity is launched automatically without the chooser dialog. This is because there is only one app, our app, that is able to handle this particular action. The value 30, which we passed into the app using the adb shell intent, is displayed as the Celsius value to be converted. Let's try to run this again with a value that's different, say 50. The app now has the value 50 as the input value and 122 as the output value. Using adb shell am start is a convenient way to test incoming intents. You can use different flags to specify different actions, different data URIs, different types, and different extras. Make sure you put a single quote around the whole command so that the adb shell on the emulator is able to process the complete command correctly. Within that, if you have a variable that has spaces in it, such as the string "Greetings from ADB", put double quotes around it.

Conclusion
Conclusion
In this course, you learned how to use intents to communicate between apps. You learned how to create an explicit intent with a package and activity to launch a specific activity. You used intent extras to store key value pairs from one activity to another and back. You learned to use startActivityForResult with a request code to ask another activity to do some work and return the result to you. You learned how to return the result by calling setResult. You also learned how to create an implicit intent with a combination of action, data URI, and MIME type to express your request for the Android system to find matching activities. Finally, you learned how to specify intent filters in your manifest file to tell Android what implicit intents your activities can handle. With that, you learned how to get activities to work together with explicit intents, implicit intents, and incoming intents. Intents are used in other parts of Android as well such as service, which runs in the background, broadcast receiver to react to events, and notifications to specify which activity to launch when the notification is clicked. Just as in activities, an intent describes an operation to be performed. It allows different components to tell each other what they can do and what they want done. This way, different apps can work together tightly making Android very customizable and extensible.

Course author
Author: Chiu-Ki Chan	
Chiu-Ki Chan
Chiu-Ki is a mobile developer with a passion in speaking and teaching. Her mother tongue for mobile is
 Android, acquired while working on Android Maps at Google. Now she runs her own mobile...

Course info
Level
Beginner
Rating
4.3 stars with 23 raters(23)
My rating
null stars

Duration
1h 38m
Released
12 Jun 2017
Share course