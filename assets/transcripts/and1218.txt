Android: Getting Started with Retrofit
by Alex Wolf

Learn how to accomplish sharing and connecting data between users, integrating third party services, and persisting data on a remote server using Retrofit, one of the most popular HTTP communication libraries on Android.

As you learn to develop Android apps you’ll quickly want to add dynamic and connected features. In this course, Android: Getting Started with Retrofit, you’ll learn how to connect your app to Web Services with one of the most popular HTTP clients on Android. Retrofit can empower your app to retrieve or send data to a server, share and connect that data between users, or even implement third party services like stocks or weather. First, you will discover the fundamental concepts and principles behind RESTful Web services, which are a modern standard and a great fit for mobile apps. Next, you’ll step through converting a sample app from managing data right on the local device, before finally managing that data using a Web Service, and many other essential HTTP Tasks. By the end of this course, you should feel comfortable building your own apps that connect to Web Services with Retrofit.

Course author
Author: Alex Wolf	
Alex Wolf
Alex Wolf is passionate about software development and mastering new technologies. He has several years of experience working almost exclusively with .NET platforms, such as SharePoint, NopCommerce...

Course info
Level
Beginner
Rating
4.6 stars with 24 raters(24)
My rating
null stars

Duration
2h 20m
Released
10 Jan 2018
Share course

Course Overview
Course Overview
Hey, everyone! My name is Alex Wolf and welcome to this course on Android: Getting Started with Retrofit. As you learn to develop for Android, you'll very quickly want to add more dynamic and connected features to your app. Features like retrieving or sending data to a web service, sharing and socializing that data between users, or integrating third-party stocks or weather. All of these types of valuable tasks require web service communication, so in this course you will learn how to connect your apps to web services with a tool called Retrofit. Retrofit is a popular choice on Android for managing HTTP requests and web service integration. You will also discover the fundamental concepts and principles behind RESTful web services, which are a modern standard and a great fit for mobile apps. We'll then step through converting a sample app for managing data right on the local device to managing that data using a web service. This will involve learning how to request data from the server as well as send new or updated data back to the web service. We will also see how to accomplish other common, but essential HTTP tasks with Retrofit. So by the end of this course you should feel comfortable building your apps that connect to web services with Retrofit. Before starting this course you should be familiar with general Android development such as working with activities, layouts, and responding to user interactions. Any prior knowledge of web service technologies or HTTP communication is a helpful bonus, but certainly not required since we'll be starting with the basics. So I hope you'll join me on this journey to mastering Retrofit and really taking your apps to the next level, right here on Pluralsight.

Getting Started with HTTP on Android
Introduction
Hi, I'm Alex Wolf and welcome to this course on Getting Started with Retrofit. Retrofit is a great HTTP client for Android that can really help take your apps to the next level. When you first begin building Android apps, you'll most likely practice common tasks like building activities, creating views and layouts, and responding to user interactions. These are core skills that are essential to building an app, but as your skills and application become more complex, you'll likely want to do more. The next logical step is to connect your app using online services through the internet. If you want to retrieve and persist large amounts of data or allow users to socialize with one another or even integrate third-party services like weather or stock market data, you'll need to bring your app online. All of these types of features require understanding how to integrate your app with web services. A web service is some type of program that runs on a server to perform a task, usually to receive or respond with data. Mobile apps generally consume these services over the HTTP protocol, which you're probably familiar with already. This is of course the same standard that websites and other systems or devices use as you're browsing the internet. HTTP defines a set of standards for application-level communication, which we'll explore in more depth later on. Now web applications use HTTP requests to load entire HTML pages, JavaScript files, images, and other data like JSON using a web browser. Android apps behave in a similar way, though usually mobile apps are more interested just in the raw data from a web service, often in JSON format. This data is then displayed using layouts and views that are already installed as part of the app. Of course, other types of data can be requested from a mobile app as well, which we'll see later. This brings us to the main focus on the course, which is the Retrofit client for Android. Retrofit is a great tool that provides an abstraction layer around HTTP requests and responses. It takes care of all kinds of tedious, low-level details for us and it's an especially good fit for RESTful web services, which we'll explore later. Over the next few clips we'll learn more about what this technology has to offer us and why you might want to use it in your own projects. Before we continue that discussion though, let's just take just a moment to make sure this course is a good fit for where you are as a developer.

Are You in the Right Place?
Let's make sure you're in the right place before moving forward. Although this course is fairly open and introductory in nature, a few specific audiences will get the most out of the content. The first audience is developers who have a working knowledge of the Android platform, but are looking to expand the capabilities of their apps. So maybe you've built simple apps users can interact with locally on a device, but you're at the point where your app needs to do more. Most real-world apps require some level of internet connectivity or web service integration. If you're wondering how to expand your app to retrieve and persist data to a web service, you're in the right place. A second audience would be developers who have already worked with HTTP or web services in Android apps, but are looking to specifically learn Retrofit. Perhaps you've worked with a different tool like Volley, but you're wondering if Retrofit is a better match for your next project. Retrofit has specific advantages over other options in many scenarios as we'll see later, so it's definitely worth learning, even if you're familiar with other tools. A third audience might also be web service developers who are looking to expand their knowledge of mobile app development. Perhaps you're looking to build client apps that can actually consume your web services. Understanding how apps use your data can also help you build more friendly and approachable web services. On a more technical note, there are a few topics you should be comfortable with in order to get the most out of this course. Most importantly, you should have a general working knowledge of Android development. Our exercises will focus specifically on converting an existing app to use web services instead of local data so we won't spend any time actually building the app from the ground up. It's also a nice bonus if you have prior knowledge of working with web services. This could include anything from other Android libraries to server-site technologies such as. NET or Node or just general experience with HTTP. Of course, this knowledge is certainly not required, since we'll be starting with the basics in the upcoming modules. So if any of this sounds like a good match, let's really get started in the next clip by exploring HTTP communication in Android in more depth.

Working with HTTP on Android
In this clip let's begin to explore HTTP communication on Android. As the platform has matured over the years, many different libraries and options have emerged for managing HTTP requests. In this clip we're just going to discuss a few of the popular choices to provide a broader context for Retrofit. We also want to answer the important question of why we need a tool like Retrofit in the first place. Now earlier I mentioned how apps require web service integration to provide many compelling features. Well, the technical implementation details of these services can quickly become very complex. Technical requirements like authentication, queuing multiple requests at once, parsing different types of responses and downloading files, this can all be very labor intensive. Without a helper client or reusable library, these same tasks all have to be done manually every time a new app is created. Several popular options have emerged to solve this problem. One choice is to use the standard HttpURLConnection class provided by Java, which is fairly manual, but can still get the job done. Volley is another popular library that provides more high-level abstractions of your HTTP requests to help with day-to-day tasks. Retrofit is another HTTP client that provides these types of wrappers and is a particularly good choice when working with RESTful web services. Another technology you might come across when researching all these different options is OKHttp. This is another library that handles HTTP communication, but at a more low level. The HttpURLConnection and Retrofit clients actually both sit on top of the OKHttp library, but you don't need to know this library to initially get started with either. Volley is not built on top of OKHttp and instead uses other underlying classes, but those are outside the scope of our discussion. Let's review each of these libraries in a little more detail. HttpURLConnection is a class that allows you to manage HTTP requests and responses. It's worth understanding at least the basics of this client since you can sort of think of it as the built-in option on Android. This client works in conjunction with AsyncTask, which is a class that allows you to run HTTP requests and other operations outside of the main UI thread of your app. That main thread continuously runs to respond to user interactions so making networking calls on background threads prevents the app from locking up or lagging. Now there are several downsides to using this approach. First, the code for HttpURLConnection is a bit more difficult to read and write when compared to the other options. You'll need to be comfortable working with byte arrays, stream readers, and related classes to truly be effective. Parsing responses is also a more manual process as is sending data and working with different data types in general. Manually managing background threading for multiple requests can also present challenges. These are the types of issues that higher-level libraries like Volley and Retrofit seek to improve. The Volley library improves this experience by managing abstractions over common HTTP tasks and configurations. Here you can see some pseudo sample code for a Volley get request. All we have to do is create a new request object, provide a URL, and then two handler methods for the success and failure scenarios. Notice at the bottom that we can also add these requests to an asynchronous queue that Volley will effectively manage for us. Volley also provides other useful features for working with caching, request timeouts, files, and more. Unfortunately, Volley is not without its own problems. This library has surprisingly limited formal documentation, even though it's part of the official Android docs. Since Volley is sort of a generalized helper library, it also does not have quite as many REST and authentication friendly features as other libraries like Retrofit. Volley also arguably does not have quite as active of a community anymore as Retrofit does. In the next clip, let's see how Retrofit addresses some of these shortcomings and provides many of its own special features.

Introducing Retrofit
So why should you choose to use Retrofit other than other options? Well, Retrofit is one of the most popular Android HTTP clients due to the way that it easily maps RESTful web services into Java interfaces and classes in your app. We'll be exploring the details of REST in the next module, but in very general terms, REST is a popular way of designing web services around HTTP methods and URL structures. So for example, here we can see some pseudo code for a Java service interface in an Android app. Let's say that we want to connect to a web service that manages create, read, update, and delete operations for contacts. Retrofit can map these web service endpoints directly to an interface in our app using a URL path and HTTP verb types. We can then use a class in our app that implements this interface to make calls back and forth. We'll be looking much more closely at this essential pattern in the upcoming modules when we start to explore REST. Retrofit also provides annotations, parameters, path management and all kinds of other features that improve the experience of working with web services. These configuration options are extremely valuable once you get into the details of writing your requests. They give us fine control over those requests while still maintaining readable and expressive code. One interesting aspect of Retrofit is that it relies on a couple of other more low-level libraries, which are OKHttp and GSON. In the previous clip I mentioned that OKHttp is a Java library for working with HTTP requests, which we'll explore as needed throughout the course. In many ways, Retrofit is essentially just a REST oriented wrapper around OKHttp that provides additional features. GSON is another important library that handles mapping requests and response data from JSON to Java objects. Let's explore this one in a bit more depth. So when you receive data from a web service, it's usually in the form of JSON or XML. JSON stands for JavaScript Object Notation and all it means is that data is formatted as simple JavaScript objects. Here we can see an example of a simple JavaScript contact object. the GSON converter will automatically take care of parsing this JSON into a matching Java class instance for us using naming conventions and other configurations. This means we don't have to manually loop through the response body and perform all kinds of checks and parses for different data. It just gives us a usable Java object right away. This is a powerful workflow that we'll be leveraging quite a bit throughout the course. Retrofit has plenty of other advantages and features that make it great to work with. It has an active community that makes learning and troubleshooting the toolset easier. It also includes features that make working with request queues, authentication, error handling, and other common HTTP requirements much more enjoyable. As I mentioned earlier, the whole point of Retrofit is to abstract low-level details away so you can focus on architecting and building your applications. In the next clip, let's tour the sample application we'll be working with to help us understand all of these concepts and features.

Touring the Sample App
In this clip let's take a brief tour of the sample application we'll be working with throughout the course. This will simply act as an overview of the features and general functionality of the app. We'll examine the actual source code and project structure in a later module. So let's say we're working with a development team at a company called Globomantics. This company has a great developer culture and allows for quarterly hackathons or code fests. Every few months, a couple days are set aside for developers to try new technologies, ideas, or work on side projects that might benefit the company. The dev team at Globomantics is eager to improve their mobile skills so during a previous hackathon they built a small Android app. This app allows users to create and manage ideas for future events, but right now it's very limited. All data is managed locally on the device. This means users cannot chare ideas or collaborate, which defeats the purpose of an innovation-focused app. After building this proof of concept during the first quarter, the team now wants to improve on it to be a more connected app. Specifically they want to manage all app data through centralized web services. This will be necessary to implement additional features like user accounts or file sharing in the future. More importantly though, learning to integrate with web services will allow the devs to build larger, more meaningful apps for Globomantics outside of these hackathons. After a bit of research, the team has determined Retrofit is a great option for managing their web service calls. This starter app will provide an easy introduction for working with this HTTP client so they'll be able to build smarter apps in the future. Let's take a look at what has been built so far. I already have an Android emulator running, so let's launch the app and take a look. When the app starts, we'll be greeted with a basic landing page. Right now this is all static text, but the team is interested in pulling messages from a web service so they can send these updates to all users. If we click Get Started at the bottom, we'll be taken to the main listings page of the app. Here we'll find a simple list of some ideas that have been submitted. Our main focus in this course is on implementing Retrofit into an existing app, so we're just using the out-of-the-box Android themes to keep things as simple as possible. This list provides a typical master detail workflow. So if we click on an item we can navigate down to find more information. From here we can read the details, update information, or even delete the idea if it's just not inspiring enough. So for example, I'll replace our text title here to something like Awesome idea. So I'll type that out and then if I hit Update, we'll be taken back to our main listing page. A toast message will alert us that the item has been updated and you can see that change displayed in the list as well. We also have the option to create new ideas as you can see if we click on the floating action button in the lower right-hand corner. From here we can fill in the details of a new idea. Now one thing you might notice is this app features fairly standard create, read, update, and delete functionality or CRUD operations as it's sometimes known. These are very common requirements when working with different data types and in a lot of ways, REST services are built around these operations. We'll be looking at this structure more in the next module when we explore RESTful web services in more depth. In the next clip let's review all of the specific topics we'll be working through using this app.

The Agenda
Now that we've covered some introductory concepts, let's explore the full agenda for this course. This will help you know what to expect going forward. We'll begin by reviewing essential RESTful web service and HTTP concepts. Understanding how web services work and how to set one up for development purposes are essential skills for building connected Android apps. Next we'll examine our sample app and learn how to add Retrofit to an Android project. We'll see how to make our first HTTP request and take care of any initial configurations. Once we're comfortable with our Retrofit setup we'll cover how to retrieve more complex data from a web service and display that in our app. We'll see how to work with GSON to map response data, how to modify request parameters and use these skills to populate a master detail view. After we're comfortable retrieving data from a web service, we'll then learn how to send data to a web service. This will involve creating and updating new entities and how to modify different request headers and send different data types. Finally, we'll wrap up the course by exploring other essential HTTP tasks with Retrofit. These are more miscellaneous topics that you're likely to come across day to day such as working with logging or error handling, implementing interceptors, or managing request cancellations and timeouts. By the end of this course you should feel comfortable exploring more of these types of topics on your own. We have a lot to cover in the next several modules so let's wrap up this module and quickly move on to a deeper discussion of RESTful web services.

Summary
As we transition into the next module there are a few key points I want us to keep in mind. When working with HTTP communication on Android there are a number of productivity options to choose from. These libraries help remove the burden of managing low-level networking details. Issues such as mapping responses, managing queues of asynchronous requests, or working with different data types, these are all greatly simplified by using a robust HTTP client. Retrofit is one of the most popular options on Android right now since it handles all of these concerns and much more. Retrofit is an especially great choice if you plan on working with RESTful web services, which are a modern standard for managing data. RESTful web services embrace the nature of HTTP by designing operations around different HTTP methods and URL structures. We'll look more closely at the characteristics of RESTful web services in the next module so let's keep moving forward.

Understanding RESTful Web Services
Introduction
Hello again, I'm Alex Wolf and in this module let's explore the fundamentals of RESTful web services. Although Retrofit continues to be the main focus of this course, it's difficult to work effectively with any HTTP client without understanding certain core concepts. In preparation for connecting to our web services, we'll begin with an overview of HTTP requests and responses. This will help us understand some of what Retrofit manages for us and what we're actually trying to accomplish behind the scenes. We'll see these concepts in action through a simple demo of using HTTP requests to retrieve and send data to a web service. Once we're comfortable with HTTP requests, we'll focus on RESTful web services. First, we'll discuss the high-level concepts surrounding REST, followed by a closer examination of more practical concepts that you'll work with day to day. We won't actually be building the services from the ground up though, since that would be outside the scope of this course. Instead, we'll step through two demos of our completed web service so we can review the essential information. Each demo covers the same functionality in two different technologies. First, we'll look through an example using Node, which is a great lightweight option for fans of JavaScript syntax. We will also explore the same application built in. NET Core for developers who are more comfortable in that arena. You'll be able to choose whichever one you are more comfortable with for working through the course since I'll show you how to get set up with both. Now if you are already very comfortable with HTTP and web services and you're just looking for Retrofit specific training, you could probably just skip to either setup demo to get your web service ready for the rest of the course. If you're looking for a better understanding or even just a refresher of HTTP and RESTful web services, let's start off in the next clip with an overview of HTTP requests.

HTTP Fundamentals
In this clip let's review the fundamental concepts of HTTP communication. Understanding these concerns will give us a better idea of what Retrofit handles for us and what we are trying to accomplish at the most basic level. The hypertext transport protocol or HTTP can be formally defined as an application-level protocol for distributed, collaborative, and hypermedia information systems. In practical terms, essentially this means that HTTP is a set of standards that allow applications to communicate with one another. HTTP communication is accomplished through requests and responses. A client application such as a mobile app assembles a request asking for or sending information to a server. The server parses this information, performs some type of task, and then creates a matching response. These messages adhere to consistent rules and structure, which allow clients and servers to understand each other. A basic HTTP request is actually very simple to read and write, especially since they all consist of the same parts. First, we have the request line. This defines the HTTP verb we want to use, which we'll discuss in a moment and the URL of the resource we're trying to access. Second, we can include optional HTTP headers which provide additional metadata or information about the request that the server can use to make decisions. Finally, we also have the body of the request, which is separated by a space. Inside of this body we can include data that we want to send along with the request for processing. So the HTTP verbs I mentioned provide additional information about the type of requests. The four most common are get, post, put, and delete. For practical purposes you can think of get as retrieving information, post as sending data, put for updating, and delete for well, deleting data. We'll be revisiting these verbs later on in the context of RESTful web services. So let's look at an example HTTP request, assuming our app user has filled out a feedback form. In order to send this data to our web service, we need to package it up as an HTTP request. We can set the verb type as post, which means that we're sending data to the server, and then include a URL path of just /feedback, which is the location that manages this type of resource. We can also include an HTTP header that specifies the data format, which in our case is form data and another example header that sets a preferred language or any other headers we'd like. Finally, we package up the names of our form fields with their corresponding values and attach that in the body of the request. All of this gets sent to the server for processing. Once the web server receives our request, it creates a new feedback object from the posted data and potentially adds it to a database. It might perform other server-side tasks such as sending out a thank-you email. Assuming these operations were successful, it then creates an HTTP response message. Response messages contain a similar structure as a request, but the request line simply contains the HTTP version number and a status code detailing how things went. In this case it sets the status code to 200 OK, which indicates that everything was successful. The mobile app will receive this response, check the status code, and then display a message to the user of whether it was successful or not. Status codes are an important part of HTTP communication and are grouped into five categories. Codes starting with 100 are informational while codes in the 200 range indicate the request was successful. The 300 range deals with redirects and the 400s imply the client has made some type of error while making the request, such as sending bad data. Status codes starting with 500 indicate some kind of server side error has occurred. Clients consuming these responses such as our mobile app should check these status codes and display an appropriate result to the user. Manually authoring and managing all of these requests throughout an application can be quite a chore so this is where Retrofit helps us out on the most basic level. Retrofit and the underlying OKHttp library manage and create the details of these requests for us based on the needs of our application. It allows us to work strictly with expressive code objects like you see here rather than having to manually stitch together the text of a request and handle responses and this is just the beginning of what Retrofit offers. In the next clip let's look at an example of working with a few HTTP requests.

Demo: Working with HTTP Requests
In this clip let's walk through authoring and sending a few simple HTTP requests. This exercise will demonstrate some of the concepts we just covered and offer context for a more meaningful discussion of RESTful web services. I have a nice tool called Postman open for us to work with. Postman provides a really friendly environment for authoring HTTP requests and viewing the responses. The basic version of Postman is a free Chrome extension you can download if you'd like to follow along. Along the top of the window you can see a few different controls where we can select an HTTP verb type from a drop-down and then type in a URL we want to hit in this address bar. Over on the right we can click to send or save requests. We also have a few useful tabs for modifying the requests, most notably to add HTTP headers are key value pairs. Right now I already have a local web service running, which we'll be looking at later in the module so let's try making a few sample requests to it. So let's make sure we select Get as our verb type and then in the address bar, let's type in our URL. Since this is a local web service we can use localhost on port 9000 instead of a typical domain name. Let's also add a URL path of /customers at the end and that's actually all we need to do to make our first request. This is about the simplest HTTP request possible. One small feature I really like about Postman is this code button over here on the right. If we click on it we can see the raw text of the HTTP request we've authored with all of the helpful UI removed. You can see at the most basic level the request is still just plain text like we looked at in the slides with the same structure. Postman has added a couple headers like Host to try and adhere to HTTP's standards, but the request remains pretty basic. Let's hit the Send button and you can see we'll jump over to our sample API. Here I've placed a debugging breakpoint so we can step through the code. Our HTTP request has been received by our web service and mapped to a method that will handle generating a response. In simplified. NET terms, this class name corresponds to our URL path and this get method corresponds to our HttpGet verb. All this method does right now is return a static list of customers. So let's hit the Continue button at the top of Visual Studio and we'll switch back over to Postman to see our JSON data. So this worked well. We've successfully authored an HTTP request and received a response. Now let's try adding an HTTP header to our request to try and manipulate the response. So let's add a header of Accept, which allows us to specify a preference for different content types and then let's give it a value of application/xml. Remember, this supplies additional metadata for our server-side web service to use when it's deciding what type of response to send back. So if I hit Send we'll land inside of the same API method. Behind the scenes,. NET will process the Accept header we added and I've configured this project to be able to return XML. These server-side details aren't important for our discussion so let's just hit Continue and see what happens. You can see in Postman we'll receive data back in XML format rather than in JSON.. NET recognized the Accept header and adjusted the response formatting accordingly. Notice how you can also see the response status code over here on the right. So this all serves as a light introduction to making HTTP requests. As long as you get the general idea of what's going on here, you're good to go. Now that we understand these basics, in the next clip let's start to discuss RESTful web services in more detail.

RESTful Web Services: The Big Picture
In this clip let's review a few high-level concepts surrounding RESTful web services. These are the services that receive and send the data of your app so understanding how they work can help you develop more effectively with Retrofit. One question worth asking right at the beginning is well, what is REST? What does it mean for a web service to be RESTful? Well, REST is actually an expansive topic of its own with plenty of conversation around the technicalities of what is or isn't REST. In this course we're going to focus mostly on practical implementation patterns you're likely to find in the real world rather than on rigid definitions. Over the years, various design patterns and protocols have been applied to web services. You may have heard of SOAP or WSDL-based services. These web services transmit data using XML and the SOAP protocol, which can also run on top of HTTP. These services can be heavy and complex to work with and most importantly for us, have architectural requirements that are not very mobile friendly in a lot of cases. Although SOAP certainly still has its uses, developers began to explore alternate options for emerging use cases. Of course, there are also all kinds of custom web services where both the client and server are built specifically for each others' needs. Unfortunately, these designs are often tightly coupled and require extensive knowledge of both the client and server to work. The web service URL endpoints are often arbitrary collections of operations with naming and structures that are unique to an organization, product, or even just arbitrary choices by a developer. These solutions are not easily scalable or distributable to a huge number of clients. For these reasons and more, REST quickly grew in popularity for web services. So let's begin with a more formal definition of REST and then migrate to something more appropriate for our needs. So REST is technically just a set of architectural principles for communication between network systems. These principles date back all the way to around the year 2000, but grew in popularity with changing demands and technologies of web services. This is partially because the principles of REST are a natural fit for the structure of the web in HTTP so they can help streamline and standardize how web services are built. There are roughly six or so technical principles that a REST architecture or web service should aspire toward, which you can see here. Now most of these topics dive pretty deep into web service architecture and are outside the scope of this course. So instead of laboring through specific technical requirements, let's instead summarize these details into a few more general and practical concepts. So first let's abstract a more relevant definition of a RESTful web service for the purpose of this course. A RESTful web service provides stateless operations to manage server side data using different HTTP methods and structured URLs. In order to fully appreciate this definition, there are a few practical concepts we should review, which summarize the principles of RESTful design. First, RESTful web services are implemented through a client server relationship and this relationship is stateless. Second, these services rely on HTTP methods or verb types for different actions. Third, RESTful communication is generally implemented through structured URLs that are consistent and comparable to file system paths. Fourth, these services can use different data types for transferring information, though for the web there are a couple of standards. Once you understand these concepts, you'll be ready to go for this course so let's look at each of them in more detail in the next clip.

Core Concepts of RESTful Web Services
In this clip, let's discuss some of the practical concepts you'll encounter when working with RESTful web services day to day. Once you're comfortable with these topics, you'll be ready to go for this course from a web services perspective. One side note I want to mention is that I'll be using the terms web service and web API interchangeably throughout the course. API standards for application programming interface and acts as a gateway for one application to integrate with or influence another. In general terms, all RESTful web services are APIs, even though not all APIs are web services, so for our discussion we can get away with using them interchangeably. So to start with, RESTful web services are built on a client server relationship. In the context of our project the Android app is the client and our web API infrastructure is of course the server. This architecture allows these components to be more loosely coupled so we can make changes to one without affecting the other. For example, we could release an update that changes the entire visual interface of the app, but behind the scenes it's still making the same web service calls so the API server never even needs to know. We can also change implementation details in the API, but as long as the return data is structured the same, the client app will be fine. The client server relationship also allows us to greatly scale up our application to handle increasing demand. We can add more clients to consume our API and we can add more servers to handle this increase in clients. If designed properly, this can be a seamless scaling process and allow us to build connected apps with limitless users. The next concept to understand is that RESTful web services rely on HTTP verb types. These verbs correspond to an action the user is trying to take. Now REST itself does not define specific mappings, but instead relies on the standards of the underlying protocol. In HTTP a widely used pattern is to have get respond to retrieving a data entity and a post request to create an entity. A put request updates and existing entity and obviously delete generally deletes an entity. I do want to mention there is some room for interpretation over how to use post versus put if you read the official HTTP specs, but for our purposes I'm using this general pattern. Each of these methods also has generally accepted HTTP request structures. For example, a get operation will of course include the request line with a URL that might include parameters as well as any necessary HTTP headers; however, it does not send any data in the request body since it's only retrieving information. A post and put request will send data in the body, which is the information to create or update an entity. Finally, a delete method also generally does not send any information in the body. The identifying information is sent as part of the URL such as a product id. Each type of request also has a generally accepted response structure. Get, post, and put will all receive the data they either requested or modified. Delete does not contain any data in the body since the entity no longer exists. Instead we rely on the status codes we looked at earlier to tell if the operation was successful. RESTful web services use these verb types in conjunction with consistently structured URLs to manage data. For example, here we have a URL that's /article that can be used to manage blog articles on a news app. If we want to create, read, update, or delete an article, the URL is still just /article. There are no arbitrarily named endpoints like make new article or retrieve articles. Our RESTful web service just understands what we want to do based on the verb type of the request. Now these URLs can also be extended to include more information. For instance, we can also add identifier segments if we want to retrieve or delete a specific entity instance. A get request to a URL of article/3 might return a single article with an id of 3. A delete request to that same URL would delete that specific entity. A URL might also include additional segments to drill down to more specific information, much like a file system. For example, this URL might return all of the comments associated with the article that has an id of 3. It's worth noting that identifiers can also be more expressive such as a product name or posting date. One advantage of this setup is that we can guess how other URLs will behave. All of the examples shown here have the same structure to them and will provide similar operations based on the verb type we use. This makes documentation for a REST API much more straightforward and the URLs more readable. Some APIs also include an endpoint that returns all entity types so you can figure out every available entity operation just from the API itself. I also mentioned that RESTful web services transmit data using different data types. Although REST doesn't define any specific type of data to send back and forth, the web service standard is usually JSON or occasionally XML. We can rest assured that every response type will be consistently formatted. This allows our client to reliably parse the data and not have to worry about different structures for each response. In the next clip, let's start to look at the sample web services for our Android app that implements some of these concepts.

Web Service Technology Overview
In this clip let's review some of the options we have for building RESTful web services. Understanding all of these technologies is not necessary at all for progressing through the course, but I do want to provide context for the RESTful API technologies of our sample app. There are many different languages, frameworks, and platforms available for building RESTful web services. You may have heard of options like. NET, PHP, Ruby on Rails, Node, or even cloud-based options like AWS, Lambda, or Azure functions. I have built a sample REST API using a couple of these tools for us to use in this course. I'm providing these web services for you to run locally so that you can experiment with existing or additional endpoints, debug issues you run into, and reset the sample data whenever you'd like. You can use one or the other depending on your personal preferences so I want to give a quick overview of each and why they were chosen. I'll also be providing GitHub links to the source code for each web service and their respective setup clip. The first option is to use Node. Node is a lightweight JavaScript runtime that is pretty easy to get started with. Node offers one of the largest open source ecosystems in the world so you can accomplish a lot with minimal code. JavaScript is also one of the most ubiquitous languages out there so there's a good chance you might be comfortable with this syntax already. The Node runtime also works on both PC and Mac so it's compatible with whatever environment you prefer. The other option I'm providing is a. NET Core MVC project written in C#, which I think is a great language to work with. This is the latest version of the ASP. NET platform, which means it can also run on both PC and Mac. Like Node,. NET Core is also open source, unlike previous versions of certain. NET tooling. I really enjoy working with the debugging tools in Visual Studio and. NET so it's the platform I'll be using to demonstrate a few API concepts here and there throughout the course. Now I want to reiterate that you don't need experience working with either of these technologies to cover all of the content in this course. Any demos that involve directly stepping through web service code will be infrequent and mostly conceptual so you don't have to worry about understanding. NET or Node. The concepts should also easily apply to a different technology if you go that route. Let's step through how to get a local REST API running in both Node and. NET.

Demo: Setting up a Node Web Service
Let's walk through how to set up our local RESTful web service using Node. Once you have this app running, you'll be able to start sending and retrieving data for the innovations idea app. In the previous clip I mentioned I would provide a GitHub download for the Node web service project since we won't actually be writing any of that code in this course. You can clone the repository from the URL listed here. Now the first thing you'll need to do is install Node on your computer. So if you head over to Node. js. org, you can download it for the platform of your choice. The installation instructions are pretty straightforward so after your download completes, just run through the Install Wizard. After Node is installed, we can either copy the Node project from the course exercise files, or clone it from GitHub. I like working with Git so let's grab the download link from that page. Now let's open an empty folder where we can copy this project and then right-click to open up a Git window. I'll simply type the git clone command and then paste in that download URL. Once that finishes, let's open up this top level folder to see our small project. The main file we are interested in is this server. js file. So let's right-click on it and open it up in MS Code or whatever text editor you prefer. I've tried to keep this project as simple as possible so our entire web service is actually contained inside of this one server. js file. This is not necessarily a best practice if you're building a real-world web service, but it's quick and simple for our needs. At the top you'll see that we're pulling in a framework called express, which is a minimalist option for creating our API endpoints. If we scroll through the code you'll see there's some dummy data set up in here as simple JavaScript objects. As we modify our dataset, this will be saved in memory until the next time we restart Node so your changes will be tracked at least while you're using the app. Express also allows us to create these methods that handle different URL endpoints. These methods are named appropriately to the type of HTTP verb they map to. So for example, if we want to retrieve a particular idea for our innovations app, we can make a get request to ideas/id. Id is parameterized with this colon to make that work for us. I encourage you to experiment with adding or modifying endpoints as you get comfortable with the project, but for now you just need to understand conceptually what the file is doing. To actually run this code we need to start our Node server. So over in our command window, let's first change directories down into that main Retrofit API Node folder and then type npm install. This will download and install all of the necessary dependencies for our project such as express. Once that finishes, all we have to do is type node server. js and that will open up a web server using the main file of our project. Let's switch over to our browser to verify this is running. We can test our web service by trying to hit a few endpoints. So if I simply type /ideas at the end of our URL and then hit Enter, we'll get back a list of those placeholder ideas. If I add a 1 to the end, we'll just get back a specific idea object with that id. This means that our web service is ready to go. In the next clip let's look at how to repeat this same process using a. NET project. If you're planning on just sticking with Node, feel free to also just skip the next clip.

Demo: Setting up a .NET Web Service
In this clip let's step through how to get the. NET version of our RESTful web service up and running. So as promised, here's the link to the GitHub project for the. NET Core version of the web services project. The code is already to go so I'll show you how to clone it and get the web service running locally on your computer. If you don't already have Visual Studio installed, you could head over to visualstudio. com to get the latest release. If you select the download, you'll see a few different options. The Community edition is free and more than powerful enough for what we'll be working on. So once you choose that, the download will start. The install process is pretty straightforward if you choose the defaults so go ahead and run through the Setup Wizard. Once Visual Studio is installed, you can either copy the. NET project from the downloadable exercise files, or clone from GitHub. I like working with git so I'm going to use the clone option, which I have opened in this tab. Let's grab the download URL using this green button over here. Next, let's open up an empty folder where we want to clone the project and then right-click to open a git window. Here we can simply type our git clone command then paste in our download URL. Let's hit Enter and wait for that to copy. After that finishes, if you open up this top-level folder, you should see a directory structure with an SLN file. This is the type of file we use to open a. NET project. So go ahead and double-click on that and our project will open up. Once you're inside Visual Studio, let's expand the Controllers folder so we can open up the IdeasController. In very simple terms,. NET maps URL paths to controllers with a matching name prefix. So in this case the IdeasController would handle URLs that match /ideas. At the top we're also generating some sample data that will be saved in memory until we restart the. NET web server. As we browse through the IdeaController, you can see there is a method named after each HTTP verb type that can operate on an idea object. All of these operations match the same /ideas URL and then. NET will take care of selecting one of these methods based on the verb type. We are also returning various status codes that are appropriate for a given operation. As long as you understand the high-level concepts at work here, you'll be fine since we are not going to be working directly with this code very often at all. All we have left to do now is to run the project so let's click on the little arrow next to run. You'll see that we have two options. Behind the scenes this is choosing to either run the project using IIS Express or the next. NET Core kestrel server. Let's choose the second one. The. NET Core server works on both PC and Mac and in my experience has fewer quirks working with the Android emulator networking. So go ahead and let that start up. Just like with our Node server, we can test our web service by hitting a few URLs. So let's type in our localhost/ideas URL and you can see that we get the expected list of sample data back. So in the next module we will start to replace browser HTTP requests with those from our Android application. At the moment these calls provide little value to a user without our nice Android app UI to wrap the data. Retrofit is going to help us create all these same types of requests behind the scenes in our Java code. We'll see how this works in the next module so for now let's wrap this discussion up in the next clip.

Summary
There are a few concepts I want to reinforce as we transition from working with our RESTful web services into the Android app itself. First, remember that HTTP is the most common protocol for implementing REST. HTTP calls consist of a request line with our verb type, the URI and the HTTP version. They also generally include headers that supply additional metadata about the request and sometimes a body of data for the web service to work with. HTTP defines several verbs that we can use to perform CRUD operations on the server such as get, post, put, and delete. Remember that REST is a standalone set of architectural principles that can be applied to web services. These principles can help streamline and standardize APIs to be more usable and scalable. RESTful web services are designed using a client server infrastructure that is stateless and scalable. They generally receive and process HTTP requests based on the incoming verb type and the directory-like URL structures. These services return different data types to the client such as JSON or XML. There are different options for building RESTful web services such as Node,. NET, or cloud-based solutions. For these reasons it's just as important to understand RESTful concepts and principles as it is to understand specific technologies. In the next module, let's begin to modify our Android app to use Retrofit so we can start communicating with the RESTful web service we've set up.

Creating Your First HTTP Request with Retrofit
Introduction
In this module let's get started working directly with Retrofit. We'll begin to replace the static data in our app with more meaningful information retrieved from our web service. So first we will tour the Android project from a coding perspective to get comfortable with how the project is structured and see more specifically what change we'll be making. Once we are familiar with the code base, we will see how to add the Retrofit dependencies to the project as well as any other necessary configurations. Next, we'll cover the general patterns and core components needed to make well-structured, reusable requests with Retrofit. We will then create some of those core components that we'll be using throughout the project such as a service builder and essential interfaces. Proper setup in the early stages of your project can provide much better code reusability and just save you from a few headaches. After all of our components are in place, we will write the code to make our first HTTP request and handle the response. We will carefully walk through this request and see how everything comes together to finally display data in our app. One task we will also accomplish is to add basic logging to our Retrofit requests. Logging can be extremely useful when working with HTTP. Analyzing the exact data that was sent to and received from the server can make debugging much easier. So let's get started in the next clip by exploring the project we'll be working with for the rest of the course.

Demo: Touring the Sample Code
In this clip let's take a tour of the Android sample project. In the first module I demonstrated what the app can do functionally, but now let's explore the actual code base and Android project itself. If you'd like to follow along with the demos, you can clone the Android project from the GitHub URL provided here. You can also find the sample project in the downloadable exercise files. So right away I want to mention that this project is actually very similar to the master detail template that ships with Android Studio. This design is intentional. So if you've worked with those starter templates, this code base should already be somewhat familiar. I also want us to focus mostly just on Retrofit code. So by using the starter templates we don't have to write a whole custom app ourselves. Now of course, I have modified this project a bit to meet our needs. Under the main node in our Project Explorer, you'll find a couple of additional items. First, we have a LandingActivity, which is a simple class that renders when our app launches. This activity displays some basic messages to the user and will work well as a simple introduction to Retrofit requests. You can see where we are just manually setting the display message with static text, a good example of content we want to retrieve from our web service instead. If we open up the main list activity of our app we can see another example of this hard-coded sample data. This static list of ideas gets plugged into our recycler view for the user to scroll through and choose items. We want to instead retrieve this data from our web service. Currently this data comes from a sample data class, which we can explore in the helpers package. At the top, this class simply creates a set of static sample ideas, but the more interesting code is down near the bottom. Here we have a set of get, create, update, and delete methods, which act as sort of local CRUD operations for our data. Essentially anywhere these apps are being used we want to substitute real calls to our web service. The other notable change I've made is to add a create activity so users can submit new ideas. This has more value once we hook up our data to a web service since all users will be able to see whatever ideas are submitted. I've created this with loosely the same structure as the other activities so there shouldn't be too many surprises here. You can also find the update and delete operations inside of the detail fragment. We also have a model class that represents the ideas users are submitting. This is just a plain old Java object, which we'll be using along the way. So that's really all there is to this project. It's just the master detail sample project with a few additional activities and modifications. We'll inspect any other differences more closely when we need to work with them in later modules. In the next clip, let's take our first steps toward working with Retrofit by implementing it in this project.

Demo: Setting up Retrofit in Android Studio
In this clip let's get our project set up with Retrofit so we can start to make HTTP requests. Within Android Studio there are basically two things we need to do to include Retrofit in our project. First, we need to add an entry in the apps manifest file so it can access the device's internet connection in order to make HTTP requests. So let's open up that file and right now our app is not requesting any specific permissions, but we can add a new one at the top. So below the main manifest node, let's type uses-permission and then Android will give us this helpful prompt, which we could use to select the internet item. The second thing we need to do is add Retrofit as a dependency in our project. This can be done from the module-level gradle file so over in our Explorer, let's click on that file to open up the script. You can see we already have a number of dependencies listed down at the bottom; we just need to add another one for Retrofit. To make sure we get the naming exactly right, I'm going to paste in a small snippet here that includes the correct versioning. Now you'll notice I've also added a second dependency in here for GSON. If you remember from the slides, Retrofit does not include a built-in data mapper for sending and receiving data; however, it features strong integration with GSON and other converters so I'm just adding that here for when we need it. The final thing we need to do is run a gradle sync on our project. This will download the dependencies and make sure they're ready to go for when we actually start coding. So I'll click the little sync button up here at the top and wait for that to finish. If your gradle sync completes successfully, Retrofit should be properly set up in your project. In the next clip let's review a few essential patterns and components for working with Retrofit.

HTTP Request Patterns in Retrofit
In this clip I want to review some general patterns and concepts for making requests in Retrofit. This will not be an involved exploration of all the different features and request options. We'll save that for the upcoming modules. Instead I want to cover the overall process of how we make requests so we can complete a few examples by the end of the module. At a high level there are really three general steps to making a request through Retrofit. First, we need to create an interface that maps to an endpoint in our RESTful web service. Next, we need to create an actual instance of this service ideally through a reusable service builder of some kind. The service instance can be created inside of an activity for example and then be used to actually make our HTTP requests. Let's look at each of these steps in more detail. Earlier in the course we looked at this example of a service interface, which defines methods that map to a web service endpoint. We'll be exploring the detailed syntax of these requests later on. For now it's important to remember that this is just an interface, a contract that describes request endpoints. Until we create a class that implements this interface, we can't actually use these methods. This is where Retrofit's service building features must be utilized. Retrofit offers two classes appropriately named Builder and Retrofit. The Builder class allows us to define various setup configurations for our services and then builds out an instance of the Retrofit class. That Retrofit class then provides a method called Create, which accepts the type of the web service interface we defined and returns a usable class instance. We can extract a lot of this Retrofit service creation logic into a reusable class that we can use anywhere in our app, as we'll see in the demos. Once we have an instance of our service in an activity or fragment, we can make the actual HTTP request. This is the step that you'll be repeating most often in your project. Retrofit will send the request to the server and we define success and failure methods to handle the response after the request has finished. The appropriate method is chosen based on the response status code. This process might sound a little bit abstract, but in practice it's actually simple and requires minimal code. Over the next few clips, let's implement this pattern so we can make our first HTTP requests.

Demo: The Service Builder and Interface
In this clip let's build the two main components we need to make an HTTP request in Retrofit. First, we'll see how to create the interface that will map to our web service operations. Second, we'll learn how to create a reusable service builder that can create implementations of those interfaces. Inside of Android Studio let's start to create these new components. Over in our Explorer, let's right-click on our top-level item here and choose to add a new package and in the dialog that opens, let's name this services and then go ahead and confirm that. Let's now click on that new package and choose to add a new Java class. This time let's name it MessageService. Remember, this will just be a simple interface that retrieves the news text on our landing page. So let's click OK to create that. Now if you remember from the slides, we need to define methods on this interface that correspond to our web service endpoint operations. These methods look almost the same as any other Java interface, so let's start with the return type of call with the type string and then name the method getMessages. It's helpful to prefix the name of your method with the matching operation. The only other thing we need to add is the get annotation above this method. We can pass in a value of messages, which effectively tells Retrofit that when we call this method we should match it to an HTTP get request to this URL. We only define the path here rather than the full URL since the base URL with our domain will be defined in another class. So let's work on creating that next class. Remember, this message service is only an interface. We can't actually do anything with it unless we instantiate a class that implements it and gives us access to these methods. This is something we'll need to do repeatedly in Retrofit so we should create a class to handle this task for us. So let's right-click on our services folder again and choose to add another class. In the pop-up we can call this one something like ServiceBuilder and then hit OK. For this class I really want to focus conceptually on what it does so rather than typing out all the code I'm just going to paste in a few lines for us. As a side note, any time you see a pasted block like this, you can find those same code snippets in the course exercise files. Retrofit provides a builder class that allows us to set up essential configuration and initialize the HTTP client. So all we are doing here is defining a base URL since all of our HTTP requests will be relative to this domain. In simple terms this IP address is just another version of localhost that works a bit better with the Android emulator networking. We are also registering our GSON converter library we added so that Retrofit will automatically handle our data mappings. The rest of this code is an important method that acts as a helper for us to build services. Our builder provided us with this Retrofit object, which can be used to instantiate classes that implement the type of interface we pass it. So in our case this method can create an implementation of our message service, which we can actually use to make our getMessage call. This service also handles declaring items as static so they are reused throughout our app and there's no need for us to have multiple Retrofit builders. With these two classes in place we are finally ready to start making HTTP requests. In the next clip let's step through creating our first request with Retrofit.

Demo: Making the First HTTP Request
Let's make our first HTTP request with Retrofit. We will see how to initiate the request as well as how to provide handler methods for successful or failed calls. The simplest place to make a Retrofit request is from within an activity or fragment. The text we are trying to retrieve is displayed on our landing layout so let's open up that matching activity. You can see right now we have this static text assignment to our message field. This is not very valuable to anyone so let's change the text source to our web service call response. This will allow someone on the server side to change the text and have it update across all our connected apps. So I'm going to paste over this text assignment code with a sample Retrofit call and then take a moment to include our import statements. So once those are all in place, there are essentially two important parts to this code. First, we are instantiating an instance of our message service. Remember, this will act as an implementation of our interface that maps our RESTful endpoints. We can use it to actually make those calls. So here we are storing a reference to the getMessage call. We are then calling enqueue which behind the scenes will add it to an asynchronous request queue that Retrofit manages for us. The second part of this code is the two handler messages for success and failure scenarios. OnResponse is called if the request is successful, which is determined by the response status code that comes back from the server. So if the response codes are in the 200s for example, this method will be called. For simplicity, this first response just gives a straight string result so we can set the response body as the message text directly. We also have a failure method, which will simply set the text to a generic error message. This is good enough for right now, but in general you should carefully consider failure routes and how to handle them. You might want to show a notification message or load default data or even ask the user to retry somehow. Let's place a breakpoint on enqueue as well as inside of our onResponse method and I have also placed a breakpoint inside of our web service endpoint just so we can monitor the flow of the request. We can now run the app to try this out. Since this code is in our landing activity, we'll hit the debugger right away as the app launches. So first we land inside of Android Studio on our call to enqueue the request. If I hit F9 to continue you can see we'll immediately jump over to our web service. Retrofit has successfully fired off an HTTP request to our local server. I'll just click Continue inside of Visual Studio and you can see we'll bounce back to Android Studio inside of our onResponse method since the call was successful. This method should now assign the text from our server to our view. So let's hit F9 again and we'll jump back into our Android app. You can see that it's now showing the text from our server rather than from what was hard-coded into the activity. So this is great! Retrofit is working as expected and we've made our first request. In the next clip let's wrap up the module by seeing how we can gain better insight into our HTTP traffic.

Demo: Monitoring Requests with Logging
There is one other topic I want to mention before we wrap up this module which is logging. Now logging can be a bit of a dry subject, but I strongly encourage you to complete this step. Logging allows us to monitor the exact request and response traffic to and from the server, which can be invaluable for debugging random issues. Let's revisit our gradle script again since we need to add another dependency for logging. I've added an additional line item here and performed a gradle sync so we're ready to go. Just make sure you complete this step and then let's move back over to our service builder. Logging makes use of a concept called interceptors, which are a powerful feature of Retrofit and OKHttp. We will discuss this feature more later on so for now I'm just going to paste in a few lines in here that build and register the interceptor. Basic logging will be really valuable to us throughout the course. So I just want to step through the basics of setting it up before we start working with more complex requests. We first need to create a static instance of the HTTP logging interceptor class. We also want to attach a method called setLevel and then pass in the value of body. There are various levels available for logging, but I generally find this one to be the most useful since it will show us the headers and body of our request and response. Now we need to actually register this interceptor by calling addInterceptor on a new OKHttp client object. Interceptors are a low-level function of OKHttp, which is why we're adding it to this new client object instead of our main Retrofit builder. The last thing we need to do is tell Retrofit to use our custom OKHttp client that includes the logging interceptor. So after our builder method here, let's just call the client method and then call okHttp. build. If all of this code doesn't completely make sense yet, don't worry. Again, we'll be revisiting interceptors later on. Surprisingly, that's all we have to do to add fairly robust logging in for Retrofit. This is a great feature that can really help us out. To see what value this provides, let's run our app again. Once your app loads the landing activity, we can review the logs in our Android monitor to see the HTTP request. Since our app is fairly simple, there won't be too much in here yet and if you look closely, you can see the lines that include OKHttp in them. We can also type in the search bar up here to filter down to just OKHttp specific items. If you actually read through these lines, you'll find very helpful information. OKHttp clearly defines where our request and response start and end. We can see our URLs, headers, and even the body content that was sent back to us. If you run into issues with communicating with your web service, or you just aren't receiving the results you'd expect, this can be a great place to start debugging. This will be especially useful when we start posting data to our web service. In the next clip, let's wrap up the module before we proceed to more involved topics of Retrofit.

Summary
As we transition into the next few modules we want to take with us a few core concepts surrounding HTTP requests in Retrofit. Retrofit enables us to define interfaces that correspond to the URL endpoints of our RESTful web services. We can then use Retrofit to create implementations of those interfaces which actually make the HTTP requests. Requests can be made asynchronously through the use of a queue, which will handle managing multiple requests at a time for us. Each of these requests allows for a success and failure handler method so we can perform logic on the response once it has been received. Requests are determined to be successful or failures depending on their standard HTTP response code. Retrofit can also utilize a feature called interceptors, which we'll revisit later to add useful logging to our requests. These logs allow us to see the request headers and body that are sent to and received from the server. This can help with debugging issues that might surface. In the next module, let's go a bit deeper with making requests in Retrofit by populating a master detailed view in our app.

Retrieving Data from the Web Service
Introduction
In this module let's start to really explore the different capabilities Retrofit has to offer. For now let's focus on the features that allow us to retrieve data from the server. There are a considerable number of options for accomplishing this task, but we'll make sure to look at some of the most common and useful. First we will see how to populate the master detail view of our app beginning with the master list or home view. This will involve retrieving a list of data from the server and mapping it to our recycler view. We will then take a moment to discuss all of the different options in Retrofit for modifying our URL path and query parameters. There are essential tasks for working with RESTful URL structures. So once we understand those concepts, we'll see a demo of how to work with URL path parameters to populate our detail view. Next I'll cover how to add query string parameters to our request in order to filter data or return a subset of a larger result. Retrofit has a few different features for working with query parameters so I'll also demonstrate how to use Query Map to work with a large number of filter options. Finally, we'll see how to modify the full URL that specific requests use to retrieve data including the root domain. This can be really useful if you have a few cases where you need to request information from a location outside your main web service. In the next clip let's really get started building out our mobile app by populating the home list view.

Demo: Populating the List View
Let's take care of populating our master list view. This process is similar to the last request we looked at, but it's an important step to the overall progress of our app. Back in Android Studio we need to create a new interface that maps to all of our web service operations for the idea objects. In the previous module we saw how to do this with our message data. Remember, RESTful web service URLs are generally built around a specific resource so we want to create a separate interface for each data type. So let's right-click on our services package and choose to add a new class. In the dialog box, let's name this IdeaService and then make sure to select Interface from the drop-down. Let's hit OK and add that to the project. This interface will have multiple methods on it by the time we're done, but let's add them one at a time as they become relevant. So first, let's add a method with a return type of Call, this time with a list of idea objects and let's name that getIdeas. This method will retrieve all of the ideas our app can display in a list. We also need to add our annotation to it so above the method let's type out GET and pass in the ideas path. This service will share the same root URL defined in our service builder so we only need to include that path. Next, let's open up the idea list activity, which acts as the main home view or sort of the master view of our app. At the bottom of the onCreate method we'll find this line of code right here that populates the recycler view with the list of sample ideas. We have to replace this with the real data from our web service. Since we already created our service builder in the previous module, making our new ideas request is very simple. I'm going to paste over this line with a code snippet from our exercise files, which just adds in the necessary request and handlers. As we progress through the course, this request structure will be very consistent and should become second nature. So I'd prefer to just focus on the relevant or unique points of each one. You can see we're creating a reference to the getIdeas request and then enqueuing it with Retrofit. If the data comes back successfully from the server we are populating our recycler view with those items. If the request fails, we are displaying a simple toast notification to the user to let them know. If you completed the previous module, this process should be very familiar since this is just another simple get request. The main difference is that our GSON converter will do some work for us behind the scenes to map our response data to a clean list of ideas. Let's run our app and see the results of our work. Once the Globomantics app launches, let's click this Get Started button to move further into the app. If the call is successful, you should see a list of data like we have here. I've updated some of the web service sample data so that it's different than our local hard-coded data and easy to verify, but you could also check using the Android debugger. Now at the moment if we click on one of these items in the list, you'll see that we don't get the correct details for that idea. This is because the detailed view is still hard-coded to use our local app sample data. It is selecting a sample item using the id pass from the web service list item we clicked on, but it's just a coincidence that some of our hard-coded ideas share the same ids. To accurately populate this data from the server we need to make a parameterized call to the web service using that id. So let's explore our options of how to do just that in the next clip.

Understanding Request Parameters
In this clip let's explore the concept of Retrofit request parameters. These parameters allow you to fine tune your request and better control what data is retrieved from the web service. There are basically two types of parameters in Retrofit which are defined by keyword annotations. The first type is path parameters, which actually substitute or add segments in the URL. The second type is query parameters, which are added onto the end of the URL as key value pairs. Path and query parameters have slightly different meanings in the context of a RESTful API. So let's say we have a list of ideas from our web service. Query parameters are generally used to filter out a subset of this larger dataset or maybe handle tasks like pagination. A value that's part of the actual URL path like an id is usually concerned with identifying a specific resource out of a larger set. Now as URLs become more complex, the exact difference between filtering and identifying might be open for debate, but this works for our practical purposes. Retrofit has plenty of options for working with both types of parameters. Path parameters require us to define placeholders in our URL path which Retrofit can populate based on values we pass into the method. If we annotate those method parameters with the path keyword, Retrofit will understand how to match them up. We can also include multiple parameters and Retrofit will still map them properly by name. Working with query string parameters follows a similar pattern. The main difference is that we don't need to define placeholders in the path itself since query string parameters are always added onto the end. We simply need to annotate the interface method parameters with the query keyword and Retrofit will append those values to the end of the URL for us. You can also pass in null for query string parameters and Retrofit will simply ignore that value. So let's look at a simple example of these options. Let's say we define a method with one path variable for an id and two query string parameters to filter by the id's status and how many we want to view. We can then call this method and pass in an id of 12, null for the status string and then say we want 25 items. The resulting output of this method will be the URL that we see here where we have a segment at the end of the path and then a query string that only contains our count value. If your web service includes numerous filtering parameters, Retrofit interface methods can start to look a little bit bloated if we have to define a variable for every single option. Instead we can define a query map, which allows us to just pass in a map with a variable number of parameters. Retrofit will take all of these values and just append whatever we passed into the URL path. Over the next few clips, let's look at a few examples of these concepts, starting with path parameters to populate our detail view.

Demo: Populating the Detail View
In this clip let's work on populating the detail view of our list workflow. This will require using the path parameter feature of Retrofit we discussed in the previous slides. Inside Android Studio I have our IdeaService interface open again. We want to continue adding methods to this interface as we populate our app features. So let's add another method that again has a return type of call, only this time with a single idea rather than a list. Let's name this method getIdea, so the singular form, and then we need to supply a parameter we can use to identify a specific idea. So let's use the @Path annotation and just give that a value of id and then provide an actual integer method parameter called id as well. Now we just need to pair this parameter with a URL path placeholder. So above this line I'll type get and pass in a path of ideas, only this time we need to add a path parameter. Remember, these placeholders are contained inside of curly brackets, which Retrofit can parse and understand. So I'll provide that placeholder name of id, which corresponds to the idea parameter in our path annotation below. Now whenever we pass in a number to getIdea, Retrofit will populate our URL path parameter with that value and make a request to the right resource. Let's use this operation inside of our IdeaDetailFragment. The Android starter template uses a fragment for the item detail to make it more flexible such as in tablet layouts when we want to show the master and detail views at the same time. Inside of this fragment you can see where we are assigning data to our layout views. We want to replace this logic with our HTTP request. The code for this is again very similar to the last few requests we've made so let's paste in another one of our snippets and I'll just pull in a few of these import statements quick. The most important thing to note here is that we are passing in the id of the item we clicked on from the master view. So first we retrieve the argument from our fragment data and then pass it into our Retrofit method as a parameter. Retrofit will map that idea to our URL and adjust the request as necessary. Another interesting point can be found within our success handler. Rather than just mapping the response data to a list like we did in earlier clips, we are accessing specific properties on that idea. Of course, we also again are displaying a toast message in the event of an error. Let's run the app and see what happens. When the app launches, let's click Get Started to get to our main list view. We should now be able to click on any of these items to see more information. So if I choose the first item, you can see on this next page we'll immediately get our data back for that item. Retrofit has made a request for just this specific data and populated our layout views. We can verify this by jumping back to Android Studio and examining our logs. In the previous module we set this up so that we could examine our requests back and forth to the server. Using our OKHttp search filter, you can see where our get request is labeled. We can verify that the id of that object was passed along successfully just like we wanted. Now one point I do want to mention is that in a real world app you may or may not need to make a separate HTTP request for the detail view of a list. Sometimes it actually makes more sense to load the entire list and the necessary details of each item up front if you have a fast connection or small amounts of data. However, the way we've done it here is still a valid pattern in a lot of scenarios and works as a nice example of REST and Retrofit principles. Now that we understand path parameters, let's look at another example in the next clip using query parameters.

Demo: Filtering with Query Parameters
Now that we're comfortable with path parameters in Retrofit, let's see how to handle query parameters. This will allow us to filter the results of our main list view. Inside Android Studio I have our IdeaService interface open again. We already have the method we need to get our list of ideas, so let's modify it to support filtering through a query parameter. Within our parentheses let's add a query annotation, which will tell Retrofit to map this method parameter to a query string parameter when we actually make the request. So I'll type @query and then add a string parameter named owner. This will allow us to supply a name to filter by so ideas will only show up if they were created by that person. Remember, for query annotations, we don't need to add anything to our get path above the method since they just get appended to the end. Let's switch over to our list activity and test this out. Right now we are obviously not supplying a filter parameter to this method since we just added it. If we pass in null, Retrofit will ignore the parameter and not include a query string; however, if we do pass in a value to filter by, it will add to the query string like we'd expect. Now I do want to point out that this app is not the best example for filtering through query strings. In a real app if you are working with such limited data, it probably makes more sense to just retrieve all of the records at once and filter on the client side; however, just to prove how this works with Retrofit, let's temporarily set up our list view to only return ideas for the person we specify. So for this message, I'm just going to manually pass in a string value of Jim since I know a few of our ideas have an owner by that name and that's actually all we have to do for Retrofit to set up this request filter for us. Now I did make a simple change to our web service to support this type of filtering. So if we switch over to Visual Studio quick, you can see I've modified the get method slightly. Our get method now accepts an owner parameter and a count for the number of items to return with a default value of 100. We then check to see if the owner variable is empty and if it's not, we filter our results using that name. There are a lot of different ways to handle this in web service code so I don't want us to get distracted by those details. I just wanted to show you that the server does need to be coded to support handling these types of query strings. You can find the code snippets for any of our server-side changes in the exercise files and that goes for Node as well. So if I switch over to that project for a moment, here I'm just accessing the query property on a request and using a simple filter to return the right results. Only a few demos in the course will require these small server-side tweaks to prove out a concept. Let's switch back to Android Studio and run our app to see if this works. Once our app loads, we can click Get Started to move to the main list view. You'll now see that when it loads, we only get back a few results. Since we've already handled populating our detail views, we can also click on that item to verify that the owner was indeed Jim, just like we specified. We can also check out our logging in Android Studio to see exactly what Retrofit came up with for this request. So over in our Android monitor with our OKHttp filter, we can see the request and response. Here on the URL line you'll see the additional query string parameter was appended. If you remember from the slides, we can also add multiple query string parameters and Retrofit will just keep adding them on. In the next clip let's see another way to handle a scenario with multiple query parameters using query map.

Demo: Managing Parameters with Query Map
Let's continue working with data retrieval by looking at the Query Map feature of Retrofit. This provides a convenient way of working with multiple query parameters to filter requests. So inside Android Studio let's open up our IdeaService interface again. We still have a single query parameter that we're passing into the get method; however, let's say as our app grows we want to add additional options. Maybe we want to specify how many items come back for faster loading or maybe we want to provide a date range or filter by idea status. Even a simple app like this has many options so you can imagine the possibilities with a more complicated app with features like search functionality. Query Map allows us to pass in an unlimited number of parameters using this sort of key value pair structure. This change is very simple to make. All we need to do is change query to Query Map so I'll do that now and then change the variable type to a Java HashMap which accepts two string types and that's really all there is to it. Of course, we also need to update our actual method call in our list activity so let's head over there now. Above our method, let's add a HashMap so I'll type that out to create a new instance. In the previous clip we modified our API to accept an owner name and account so let's create entries for those on our map. I'll again specify Jim as the owner so let's put in an entry for that and then below it, let's specify that we only want one item back for our count. In a real world app, you may need to read up on the REST API's documentation to find out what parameters it accepts. Some REST APIs also include URLs you can call to get more information about all the other endpoints. Either way, once you've figured out the names of the parameters you want to use, you can plug them into a map like this. So finally, let's pass our filters variable into that request method and we'll be all set. We can then run the app in our emulator to see what this gives us. Once the app launches, let's click on Get Started to load the list view. You can see we received only one item back which is less than in the previous clip where we retrieved all of Jim's ideas. Now obviously in a real app you would want some kind of user interface to choose filter options or type in search parameters, but this works for right now. We can also confirm these concepts by checking our logs again. So if we switch over to our Android monitor we can search through all of the OKHttp traffic. If you look closely, you can see that this URL now includes two query parameters, even though we only passed in that one variable. Retrofit simply keeps appending them onto the end of the URL as it processes our query map. So we've seen a few examples of how we can modify what data comes back from the server, but in the next clip, let's see how we can actually modify what server the data comes from.

Demo: Retrieving Data from an Alternate URL
There is one other scenario I want to cover for retrieving data. When communicating with the REST API, usually the base URL will remain the same for all requests; however, there are often use cases where an app needs to make a few calls to some external web service. In this clip, let's see how we can substitute an alternate URL for a given request. Let's open up our message service that we created in an earlier module. Suppose we need to modify this service to pull in messages from a company-wide informational endpoint rather than just the news for the innovations app itself. This info lives on a different domain. So our base URL in the service builder is of no use. Retrofit offers an annotation we can add to method parameters that simply call the URL. This allows us to override the entire URL for the method request we attach it to. So for example, let's change this method to accept one parameter, which we'll prefix with @Url and then just make it a string named altUrl. We can also remove the URL path from our get annotation above the method. Retrofit will see this URL annotation and understand that it needs to ignore the base URL in our service builder. Instead it will just use the entire value we pass in as the URL for this request. This is useful because it give us flexibility for these miscellaneous calls, while leaving our other more structured requests unaffected. To test this out, let's open up our original LandingActivity and you can see where we are still calling getMessages inside of onCreate. We can now modify this method call to pass in a new URL as a parameter. So inside the parentheses let's pass in this same URL we've been using, only with port 7000. This makes the URL different enough to demonstrate these concepts and still works with our localhost web services. There are a few ways to test this change. Right now I'm actually running both our. NET API and our Node API at the same time, but I've configured. NET to run on port 7000 instead of our usual 9000. This means the landing content will come from. NET and the rest of the app data will come from Node. Of course, you can also test this by using one API just by changing the port number and restarting the LandingActivity again, but this way is a little more fluid. Over in Visual Studio you can see I have also modified our sample message to prove that it's coming from. NET. Changing the port the web service runs on is also not difficult if you want to modify it further yourself. We simply need to open up our program. cs file and you can see where we passed the new address into the useUrls method. By specifying a different port we can run both APIs at once. You can also change the port that the Node project runs on by modifying the listen method at the bottom of the server. js file. So let's run the app and see what happens. You can see that our message still loads, only this time we are getting a custom message that it was retrieved from. NET. If we hit Get Started we'll be taken into the rest of the app where our data still loads from Node. So feel free to experiment with different URL configurations and test this out. The important takeaway here is that we can give any request in Retrofit a custom URL by using a simple annotation. We've spent a lot of time covering all of these different ways to retrieve data from a server, but with Retrofit we can do so much more. In the next clip, let's wrap up this module so we can transition into an equally important topic, which is sending data to the server.

Summary
Retrofit provides extensive customization options for retrieving data from a web service. With the help of GSON, Retrofit can parse all kinds of JSON response data from lists to arrays to complex objects. Retrofit also allows us to programmatically construct URLs with path and query annotations. These help map our interface methods to the correct web service operations and retrieve more specific data. Path parameters allow us to pass in values to our interface methods that map to placeholders in the URL structure. This type of parameter is usually used to identify a specific resource instead of returning a larger set or a list of items. A similar feature is available for working with query parameters. We can use the query annotation and method parameters to translate them into values at the end of our URLs. This type of parameter is often used to filter a subset of data out of a broader set of items. If we need to filter our results using several query parameters, like with a search feature or complex dataset, we can use the Query Map feature. This allows us to define endless key value pairs that Retrofit will attach at the end of our URL. Retrofit also allows us to substitute the entire URL for a specific request. This is useful for miscellaneous scenarios where you need to retrieve data from a source outside of your primary web service. Now that we've covered various ways of retrieving data from our web API, in the next module let's look at the different options for sending data to the web service.

Sending Data to the Web Service
Introduction
In this module let's explore how to send data to a web service using Retrofit. This essential task allows users to create, update, share, and persist data. In other words, this is the module where our app really becomes interactive. There are many different ways to submit data to a web API over HTTP. We'll look at some of the common patterns and practices and see what tools Retrofit provides us to handle these tasks. After we understand how to submit data, we will complete our first exercise by learning how to create new ideas in our Globomantics app. This will allow users to share their ideas with other users of the app, which is the really the main goal of the project. We will then examine how to update existing items. This will enable users to change the status of an idea or update the name or description. Without the ability to update, our app would quickly become very static. Next we will finish our data management tasks by learning how to delete items. Deleting is interesting in the sense that we usually don't send an entity to the server, but we do send identifiers instructing the server which item to delete. Finally, we will see how to send additional HTTP headers to the server. These headers allow us to manipulate the actions the server might take and influence what response data will be sent back. Our app will really start to come together over this next module as we empower our users to do much more than just read through data. So let's get started in the next clip.

Sending Data with HTTP
There are many patterns and techniques for sending data to a web service. In this clip let's explore some essential concepts you should understand before we enable our app to submit data. Throughout the course we've discussed how HTTP requests consist of a URL, headers, and a body. Well, any of these three parts can be used to send data to the web service. For example, we can send an id for an item we want to update as a path segment in the URL. We can also send HTTP header information to the server that describes the type of data we are submitting. The actual data of the resource or entity we're trying to modify is usually sent in the body, which the web service can read and parse to modify server-side resources. Up until now we've discussed HTTP headers on a basic level, but they are very important when sending data. Request headers obviously provide info about the client request, but can also be used to influence the response that is sent back such as specifying a data format. Response headers detail the generated response from the server and can also influence actions taken by the client such as whether to cache certain data. Listed here are a few common examples for each type of header. So a client might specify the type of user agent that is sending the request, the language it might prefer, or cache expiration checks. The web service can then respond with info about the data it is returning such as the server type, which language it did end up selecting, and the time that it was sent. When sending data to the sender, the content type HTTP header is very important. This header describes the data format you are sending such as plain text or JSON. The server uses this content type to decide how to parse the body data into a code object, otherwise it would not know how to handle the incoming data. If successful, it then performs some operation like creating a new entity in a database and then generates a response. The response informs the client if the operation was successful through a status code and potentially includes response headers with additional information. Theoretically we can send data in request body in any format, but there are a few common content types that most web services are designed to work with. JSON is an increasingly common format for sending data, which we can specify with the application/json content type value. JSON is especially useful because it can represent complex object structures such as arrays or child objects like you see here. Many web services can automatically parse JSON into matching code classes like the pseudo C# code we see here. Another common format is form-url-encoded, which sends data along as encoded key value pairs. This format is usually seen when working with simpler forms that don't require as much structure. Although these key value pairs might be easier to parse in simple cases, recreating a complex structure like in the previous slide from this flat data would require more work from the web service. There are a huge number of potential content type values you can send to a web service so we're only going to explore a few of the most common in this module. Earlier we discussed that POST and PUT values are used to send data. POST requests generally create new entities using the root URL to manage that resource such as /ideas. PUT requests are often used for updating existing resources and thus include the existing id of the resource in the URL path along with the updated values in the body. We usually include the id in the URL itself if we can since RESTful endpoints should identify specific resources when possible. Now in practice you will also run into some endpoints that just read the id out of the posted data in the body for updates rather than from the URL, so just be aware of real world variants. In the upcoming clip let's explore how a lot of these concepts are put into practice through Retrofit.

Sending Data with Retrofit
Let's quickly review a few essential tools Retrofit provides for sending data to a web service. A high-level overview of these features will give us a good starting point for the upcoming demos. Submitting data with Retrofit is structurally similar to requesting data. We still define interface methods like we have been, only this time using post, put, or delete annotations. The more interesting part are the annotations we can use to control how data is sent. For example, here we are using the @Body annotation which allows us to pass in a Java object that will be serialized and added to the request body. So for example, let's say we invoke the createIdea method that's mapped to an HTTP POST operation. Retrofit utilizes GSON to actually serialize that object into JSON and then attaches it to the request body. It also takes care of adding the necessary HTTP headers for our server to understand, like we discussed in the previous slide. By default, the body annotation will set the content type to JSON. When the response comes back from the server we can still handle it using success and failure methods like usual. Retrofit provides tools for working with other formats as well. For example, we can use the Field and FormUrlEncoded annotations to pass in data parameters to our methods. In this case, Retrofit will add them to the request as key value pairs inside a content type header with the FormUrlEncoded value. Retrofit also provides a few different ways for working directly with HTTP headers. The simplest techniques also make use of annotations like you can see here where we are just hard-coding a header to the request. In our upcoming demos we'll see both static and dynamic ways of adding headers to one or more requests. By now, hopefully you're starting to appreciate the way Retrofit maintains similar structure and implementation details for its various features. In the next few clips let's look at a few examples of these concepts in action.

Demo: Creating New Entities
Let's step through our first example of how to send data to a web service. Right now in our app if a user creates a new idea, it's only saved locally to the device memory. Let's upgrade this feature by using Retrofit to send the new idea to a web service where it can be persisted and shared among users. Back in Android Studio let's revisit our IdeaService interface once again. We need to add another method to handle posting data to our web service. This will handle creating new ideas for us, which adhere to general REST practices. The method to accomplish this isn't all that different from the others we see here. So let's add a return type of Call and then for the type let's again specify an idea object. It's common for web services to return the entity they created, which ours is also set up to do. We don't necessarily have to do anything with that object, but it's there if we need it. Let's call this method createIdea and then pass in an idea object prefixed with the @Body annotation. This will tell Retrofit to serialize the object we pass in as JSON in the request body. The final step is to add the POST annotation above our method so I'll type that out with the same ideas path and this will tell Retrofit which type of HTTP verb to use. That's all we have to do in our interface so let's switch over to the createIdea activity. At the moment we have this OnClickListener, which will create a new idea from the entered values and add it to our local sample data. We want to modify this code to instead post the data to our web service. So I'll paste in another one of our code snippets, which still follows the same request pattern that we've been using. The most interesting part of this request structure is the way that we're building out a new idea object and then passing it into the createIdea method. Retrofit and GSON are handling many low-level details for us so we don't have to manually serialize or attach any of this data to the body. If the request is successful, we will send the user back to the home view so they can see their new item. If it fails, we'll let them know through another toast message. We are now ready to run the app and see how all of this works. Once the app loads, let's choose Get Started and then we can click on the floating action button to launch the create activity. For now let's enter some sample data into these form fields. So just go ahead and type in whatever you want for these fields and in a real app you would want to add logic to enforce data formats or avoid empty fields, but we aren't concerned about all that at the moment. Once you've filled that out, just hit Create and you should be taken back to the home list view. You can see our new item has been successfully created and if we click on it again we can go back to the details that we just entered in. More interestingly, let's visit our Android monitor to see what information our logs provide. If we search through this OKHttp information, you can see where our POST request was executed. We can see that there is no data in the URL itself; all of our info was sent through the body as JSON. You can also see the additional HTTP header that was added to tell our web service what type of data it's sending along, which in this case was JSON. Our web service has also included a URL in the response that we can use to retrieve the idea it created, which can be a useful HTTP standard. Later in the module we'll see how we can customize these headers for our own intentions. So we're now able to create all kinds of new ideas in our app, which is nice. In the next clip let's see how we can update some of these existing items using Retrofit and work with alternate data types.

Demo: Updating Existing Entities
In this clip let's see how to use Retrofit to update the details of existing ideas in our app. To accomplish this, let's try another Retrofit technique for sending data to the server. Let's open up our IdeaService again and revisit our methods. In the previous clip we created this POST method which allows us to create new items by passing in an object to a body parameter. Well, as we saw in the slides, there is another way to easily send data to the server using field annotations. Fields are a bit more verbose to work with so I'm just going to paste in the method call that we need to add. Our idea object has several properties so typing out every annotation can be a little repetitive. There are a few things to make note of here. We are declaring the PUT annotation on top of our method, which we will use to signal an update operation to our server. The web service will find an existing item using the id we supply and then update the rest of the properties accordingly. Those properties are passed into our method using multiple parameters. So we are passing in each property of the object one at a time with the field annotation rather than as an entire object. As we discussed in the slides, field annotations allow us to easily send data in a FormUrlEncoded format instead of JSON, which can be useful in some scenarios. This format is also easy to use if you only have a few data points to send or if those data points are too unrelated to easily combine into a strongly typed model. Let's switch over to our detail activity to actually call this method. Right now we are still trying to update entities using our local sample data so let's highlight that section and replace it with one of our code snippets. This code is very similar to our create method requests so it might look familiar. First we create a reference to our update method as usual. We then read the values entered by the user, only this time we pass them into the method one at a time instead of constructing an object. This process is admittedly a bit more verbose and difficult to read, but it certainly has its uses depending on the format and amount of data you're trying to send. Assuming the call is successful, we redirect the user back to the home view and if a problem occurred, we let them know through a toast message. Let's start up the application to see this in action. Once the app loads, let's click Get Started to return to our home view and then we can click on any of these items in the main list. Let's try updating some of the information in here. So I'll make a change to the name since that's the most visible and then maybe one other field just for thoroughness. Once you're happy with the data, just hit Update. So we'll be taken back to the home view and now you can see that the name of our list item has changed to what we entered. If we click on the item again, Retrofit will make a get request to retrieve that updated item and we can see the new status. We should verify that the data was sent in the format we'd expect. So let's switch over to Android Studio. In the Android monitor let's check to see what requests Retrofit made. So if we scroll through this carefully you can see that a PUT request was indeed sent to the server with an id path parameter. More importantly, we can also see the FormUrlEncoded header as well as the data sent in key value pair format. One other point worth noting is that you should double check to see what types of data your REST API supports. Some web service endpoints only accept data as FormUrlEncoded while others prefer a JSON format and others support both. There are other formats out there as well that we haven't looked at, but these are some of the most common. In the next clip, let's finish out our CRUD operations by looking at another way of managing data using a delete operation.

Demo: Deleting Entities
Let's finish the CRUD operations of our Globomantics app by implementing the delete functionality. RESTful delete requests are sort of interesting in the sense that they usually only send data in the URL rather than in the body. This makes their structure similar to a get request, except that delete operations actually manipulate data on the server in contrast to say for read-only operations. For these reasons we'll loosely group deleting as sending data to the server since we are specifying in the URL the id of the item to delete. So let's revisit our IdeaService once more to map our final web service operation. Below the other methods, let's again type out our return type of Call and this time we can actually leave the return type Void. Delete operations generally use a status code to indicate success or failure instead of sending back any actual data since that entity was just removed. So let's name this method deleteIdea and then have it accept an integer parameter associated with our familiar path annotation. Above the method let's add that DELETE annotation and for the path we just need to include a placeholder for our id after the usual ideas path. This method also demonstrates that you can use path parameters for more than just get requests. Retrofit tooling is flexible and can help in a variety of scenarios. Now let's move over to our IdeaDetailFragment which is where our delete operation is currently set up. Once again, we need to replace this sample delete with a call to our web service so let's highlight that code and paste one of our snippets over it. This delete request is one of the most simple. It's actually very similar to the request that gets the details for this item. The main differences are that we are using a delete HTTP verb rather than a get and we don't need to bind any data on the response. Hopefully you can start to see the patterns of RESTful web services coming together. There isn't much to this call so let's run our app and just make sure that it works as expected. Back in our LandingActivity, let's again select Get Started to launch our home list view. We can click on any of these items to view their details and then we have the option to delete or update the idea. So let's choose Delete this time and right away we'll be redirected back to our home activity. You should no longer see the item that you deleted listed in the results. Of course, we can also confirm this operation using our usual Android monitor. So if we switch back over to our IDE you can see the request and response structure in our logs. Also take note of the status code that came back, which is more specific to a delete operation. So as you can see, implementing delete in this case is very simple, but provides a great feature for our app and our users. In the next clip, let's examine how we can send along additional information to the web service through the use of HTTP headers.

Demo: Working with HTTP Headers
In this clip let's explore a few different ways to add HTTP headers to our requests. This can be a powerful feature of Retrofit that provides greater control over web service communication. There are a couple of examples of custom headers that might apply to our simple app. First, let's say we want to send along a custom HTTP header that tells the server the request is from a certain device type. Now this might be the type of info you want to add to every request on the app, but we'll see how to do that later in the course. For now let's open up our IdeaService and walk through a simple, more isolated example. Adding a header to a request is pretty straightforward, although there are a few ways to do so. Let's first use the simple technique of adding another method annotation. So above our getIdeas method let's add the @Headers keyword and then we just need to pass in a raw string value for our header. So I'll type our x-device-type and then assign it a value of Android. If you are not using a standard HTTP header, it's a common practice to prefix it with an x like you see here. So that's really all there is to it and now the header will be added to the getIdeas request. Now let's say we want more dynamic control over the value of the header we're sending, in case it might change. For example, perhaps we want to send along the accept language header, which can influence the language of our response data for better localization. We can easily accomplish this by adding a header parameter to our method. Let's make this change to our getIdeas method since it returns a fair amount of textual data. All we have to do is create a parameter with the @Header annotation and then pass in the name of the HTTP header we want to map the value to, which in this case is Accept-Language. Let's then declare a string after it named language. Now whatever value we pass in for this parameter will be mapped to our Accept-Language header value and added to the request. Since we added an additional parameter, we need to switch over to our list activity where we are invoking this method. For the language value, right now I'm going to pass in EN for English as a string. Our simple web service doesn't actually support multiple languages right now, but if it did, you could use this value to provide translated results. For now we just want to confirm that these headers actually are added and sent to the server, which we can do by running our app so let's try it out now. After your LandingActivity loads, let's click on Get Started to move to our list view. The headers we've added don't affect these list results yet so we still see the same data, but let's check out our Android monitor to see what's happening behind the scenes. In the middle of our OKHttp traffic, you should be able to see our GET request, only this time with additional header information. Right here we will find the language and device headers we added with the values we supplied. So at this point we know that the data was attached to the request, but let's confirm the server received those values. Over in Visual Studio I have added a couple of lines of code to simply try and access the header values we added to the request. We are then logging the values of those entries to the console. So if we open up our Output window we should be able to find where those values are logged. Our headers were successfully sent along with the request. In a real project the server could use these values to manipulate data or change the response. Now proper localization can be a pretty involved topic so I don't want to give the impression that this is all that's required, but it's certainly a starting point for exploring such features. So this wraps up our discussion of sending various types of request data. HTTP headers can often simplify sending additional data to the server that doesn't neatly fit into the main data of the request. As we transition into the next module, we'll see a more efficient way of adding headers to every request. We'll also explore other useful features for handling day-to-day HTTP tasks in Android apps. So let's wrap things up in the next clip and move on to the final module.

Summary
With Retrofit we can send JSON data to a web service using POST or PUT requests and the body annotation. We can then pass common Java objects into our request methods and they will automatically be serialized and sent along in the request. We are also able to send FormUrlEncoded data with the use of the field and Form URL Encoded annotations. These will attach the data as key value pairs in the request body, which is another common data format for web services. Retrofit of course also allows us to delete entities. This can be done either with path parameters or by sending data in the request body. Delete requests are also declared with the method annotations just like the other HTTP verb types and operations. Retrofit also enables us to manually attach HTTP headers to a request through various declarations on our interface methods. This can be useful if you need to provide the server with more information about the request or influence the type of response data that is returned. By this point we have finished building the core functionality of our app so congratulations on making it this far! We now want to turn our attention to other tasks we can accomplish with Retrofit. This HTTP client can do much more than simply send and retrieve data so in the next module let's explore some other common Android app requirements when working with HTTP and the tools Retrofit provides to accomplish them.

Exploring Essential HTTP Tasks with Retrofit
Introduction
As you continue to build connected Android apps you're likely to encounter all kinds of different scenarios and use cases for HTTP requests. So in this module let's explore how to handle some common, but more miscellaneous tasks and improvements for our app. To start things off we'll look at interceptors, which are a powerful feature of Retrofit that give us more global control over requests and responses. Interceptors provide a productivity boost in many scenarios so learning how to control them can be very beneficial. Once we understand what interceptors are how they work, we will use them to add HTTP headers to our app. This is a topic we left off on in the last module so now we'll look at how to work with headers more efficiently. Next we will revisit the way our app handles errors. Right now our response handlers are very generic, but we'll explore some of the options available to us to fine tune different situations. In real projects, connections and requests are often not as stable or as quick as we'd like. To handle these scenarios, we'll also see how to configure request timeouts and how Retrofit can work with problematic requests. Next we will see how to cancel requests. There are certain real world scenarios where this can be useful and even improve the stability of your app. Up until now we have run our Retrofit requests asynchronously, which is the most common practice, but we can also execute HTTP calls synchronously. We'll walk through a simple example of how to do this and discuss some common issues or concerns with this option. Finally, we will briefly discuss the next steps on your journey to mastering Retrofit. There are more advanced topics that are beyond the scope of this course that enterprise apps may require. We'll identify some of these topics and define the next steps in a productive learning path. Let's start working toward improving our app in the next clip where we'll discuss interceptors.

A Closer Look at Interceptors
HTTP interceptors are a powerful feature of Retrofit and OKHttp. These components allow you to hook into both outgoing requests and incoming responses on an app-wide level, which can provide all kinds of benefits. So how do interceptors work conceptually? Well, when our app makes an HTTP request, an interceptor can modify the request before it gets sent to the server. This might include adding headers or logging or some other type of logic. OKHttp then forwards the request on to the server, which ultimately sends back a response. Before the response handlers for our calling method are invoked, interceptors can again act upon the response object. We can read headers, store data, and much more. Interceptors are implemented through an interface and added to an OKHttp client like this pseudo code we see here. This interface allows us to override a method called intercept. The intercept method also receives a chain parameter, which gives us access to the request and response. After we retrieve a reference to the request, we can call a method named proceed, which continues the HTTP pipeline and gives us access to the response. Although this setup can be a bit confusing to work with at first, it gives us considerable flexibility and power over our requests. We've already seen how interceptors can be useful for managing data like logging or headers since they can track HTTP requests app wide. Interceptors are also useful for authentication patterns, which usually requires some type of token to be sent back and forth with every request. Interceptors can make HTTP calls of their own such as to refresh an expired auth token before retrying the original request. Full authentication patterns are beyond the scope of this course, but interceptors are a useful starting point. We can also use interceptors to globally handle certain types of errors, which promote code reuse and consistency. In the next clip, let's look at an example of an interceptor that allows us to manage HTTP headers app wide.

Demo: Adding HTTP Headers with Interecptors
In this clip let's see how we can use interceptors to globally add HTTP headers to our requests. Inside Android Studio I have our IdeaService open again. I just want to point out that I've removed any existing header functionality from the previous module. So I removed the annotations from our getIdeas method to revert it back to its default behavior. You'll also need to delete the language we are passing in from our IdeaListActivity where the method was called so just make sure that's back to normal as well. Adding an interceptor requires us to revisit our service builder class, so let's jump over there. Right now you can see that we are adding our logging interceptor from earlier in the course. The logging interceptor acts on both the outgoing request and incoming response behind the scenes. To add our headers we only need to modify the outgoing requests. Let's paste in one of our code snippets for the new header. Since the code for working with these can be a little bit awkward, we have to make sure we add this interceptor before the logging. If we add them after the logging, the new headers will still be sent with the request, but they won't show up in our logs, which can make verifying them more difficult. So with this code we are creating a new interceptor and attaching it to the OKHttp client. The interceptor exposes an intercept method and a chain parameter we can use to access the request pipeline. We then use the request builder class to add additional headers to the request chain. Further down the chain. proceed method resumes the request pipeline, which allows our headers to be sent. I've also made the values for those headers populate dynamically using Android tooling to further automate this process. So that's all we have to do to add new headers. Let's run our app now to ensure that this is working. Once our app loads, everything will look the same on the surface. To test this new interceptor out, let's click Get Started and then click on an item to just populate a few HTTP requests in our logs. To prove our interceptor is running on every request we need multiple examples. Let's move over to Android Studio and use our monitor to verify our expected results. You should be able to see in the window here that there are two additional headers on every request. We are also getting our dynamic header values, which is nice, and could be used for a variety of purposes. So this is one useful example of working with interceptors to manipulate an outgoing request, but you'll likely encounter other ideas in your own apps. In the next clip, let's revisit the way our app handles request errors.

Demo: Improving Error Handling
In this clip let's look at a couple of different ways to improve error handling in our app. This will involve revisiting our response handler methods to better understand our options. I have the IdeaListActivity open in Android Studio. Let's reexamine these onResponse and onFailure methods. The behavior or these two methods is a bit more nuanced than it might appear. OnResponse is technically called whenever a valid response is returned from the server. This means that regardless of the status code, whether that's a 200 or a 401 or a 500, this method will still be called. This could cause errors to occur since a 500 error probably won't include data to bind. OnFailure is actually only called when the request completely fails due to a problem like a lost connection or timeout. There are several different ways to handle these situations so I'll paste in a code snippet with a few examples. We are now using a conditional to explicitly check the status code before trying to populate the list. The isSuccessful method checks for a 200 range status code, which in this case would include our data so we know that's safe to bind. The 401 means the user is unauthorized so we could send them back to a login page or maybe add logic to refresh their auth token. For any other type of error like a 500, we just show a toast message since the response probably won't include data with it. I've also modified the onFailure method. We can try to cast the throwable parameter to different types to get more information so first we are casting to an I/O error. This means that there was a connection problem so we can provide the user with more detailed information. Other errors just get a generic toast message as sort of a catchall. This could happen for a few different reasons such as a failure to convert our response data to an acceptable type. The point here is that we should try to make our errors as informative as possible for both the user and for our logs. Over in Visual Studio I have also modified our getIdeas endpoint to return a 401 unauthorized. This will simulate the user try to access a resource without a valid session since we don't have a real authentication flow set up. Let's switch back to Android Studio to run our app and see how all of this works. So let's click Get Started to move into our app and right away we'll land on the breakpoint on our conditional. If we hit F8 to step through this, you'll see that we jump past our isSuccessful block and land in our 401 since the request returned unauthorized. Let's hit F9 to continue and you'll see we just get this security toast message and our data does not load. Let's now repeat this step and see what happens if our connection to the server is lost. So I'm actually going to open up our console where our. NET Core project is running and shut down our local web service with Ctrl+C. Now let's see what happens when our app tries to reach the server. So if we return to our emulator and hit Back we'll end up on this LandingActivity again and this activity still shows data since we're just popping it off the Android stack, but let's see what happens when we hit Get Started to try and launch the list activity again. So at first it appears, well, nothing is happening. Behind the scenes Retrofit is actually trying to make a request, but it waits a default of 10 seconds to try and establish that connection. Once the timeout occurs, we'll land inside of our I/O exception since it was a connection error. This is an example of how to inform the user that the app could not connect to the server. We could either retry the request for them or have them check their connection or other troubleshooting steps. So hopefully this gives you some ideas of how to better control your errors and give the user better messages. One side note I do want to mention is that some of these error handling tasks can be handled more efficiently by the interceptors we looked at in the previous clip. For example, OKHttp provides an authenticator class that can intercept all 401 responses and make a request to refresh the session before retrying the original request. Full authentication scenarios are beyond the scope of this course, but it's certainly something to look into. You could also hook into some of these response status codes for more specific logging and messages. In the next clip, let's see how to modify the request timeouts in Retrofit that we just worked with to get the best results for your app and user experience.

Demo: Configuring Request Timeouts
One issue you might run into when working with mobile HTTP calls is slow connections or wireless service might cause problems or delays with connecting. Web services might also have slow underlying dependencies or you might experience lag receiving the response even after a connection has been established. In this clip let's see how we can potentially smooth out those types of issues. Inside of Visual Studio I have added a line in here that causes our thread to sleep for 12 seconds. This will simulate a web service that is very slow to generate a response. All of Retrofit's timeouts default to 10 seconds, which is why I have set this to 12. I also have our emulator running so let's see what happens when we click Get Started to load our list of ideas. You'll find that we receive a blank screen. If we continue to wait, eventually we'll get a toast message that the server timed out from that error handler we added in the previous clip. These types of scenarios are not that uncommon with mobile traffic so let's see how we can improve this situation using Retrofit. Extending timeout length in Retrofit is extremely simple. Let's open up our service builder since this configuration is set at the OKHttp level. Right after our builder method, if we hit period and type timeout, Android Studio will prompt us with a few options. Retrofit has three different timeouts we can configure. In simple terms, connectTimeout is the length Retrofit will wait to actually establish a network connection to the server. ReadTimeout is the length that it will wait to receive data once that connection has been established. Finally, writeTimeout is likewise the time that we'll wait between write attempts to the server once that connection has been made. We added a sleep period to our web service endpoint, which will only happen after we have connected to the web service and it attempts to generate a response. Therefore in our case we want to extend the duration of the readTimeout so I'll choose that one. This method accepts a number and a unit so I'll pass in 15 and then choose the time unit of seconds. Our thread on the server sleeps for 12 seconds so this should give us more than enough time to still receive a response. The other timeout configurations all work basically the same so this example should apply to those other use cases as well. Let's run the app and see what happens this time. Once your app loads, let's click Get Started and then just wait for a little bit. We still get this blank screen while our web service sleeps and in a real app you might want to consider adding a loading icon. This time, however, we should see our list data eventually pop in. Retrofit will wait for the server long enough to bypass that sleep method. So in a real app, if your web service took over 10 seconds to reach out to a different web service or access a slow database call or wait for some other dependency, this call would still succeed. This timeout configuration can be a real lifesaver in those unfortunate situations where you really have no choice, but to rely on a slow call or bad connection. In some user experience cases though, you might not actually want to wait this long. Instead you might alert the user of connection problems and auto retry after 5 seconds or whatever technique you prefer. So that wraps up our demos to handle more low-level configurations of Retrofit. In the next clip let's look at an alternate way we can execute HTTP requests with Retrofit using synchronous calls.

Demo: Canceling Requests
In this clip, let's see how we can use Retrofit to cancel an active HTTP request. This could be useful in a variety of scenarios like if the user takes some action that makes the request unnecessary. Inside of our app, I have the layout for our recycler view open. For this clip I have added an Android progress bar to simulate the list loading. I also added a cancel button that we'll be able to use to end the request. We need to add the click handler in out activity to handle that action so let's do that now. Inside the list activity I have also created references to our new views so we have them to work with. Below them we can then programmatically assign an on-click listener to the button. So I'll type out buttonCancel. setOnClickListener and then pass in a new handler message so I'll type that out as well and inside of here is where our Retrofit-specific code will live. All we have to do is type request. cancel. It's really that simple. You may also need to mark your request variable as final further up and then you'll be good to go. Retrofit will take care of all the request details for us behind the scenes. Next, let's place a breakpoint inside of our failure handler since this should be called when we cancel the request. While we're revisiting these handler methods, also notice that I've added a couple of lines that just hide the progress bar and button once the request is complete. Right now since our app is hitting a local web service, the call happens so quickly there is no time to try and manually click the button to cancel. So if we switch over to Visual Studio I've actually added a line of code that causes the response to sleep for 7 seconds before sending the response like we did in a previous clip. Again, you could also easily accomplish this in the Node project, so if I switch over there, you can see there's a set timeout call configured to 7 seconds. Just choose whatever duration works for you. So once that's all set up, let's switch back to Android Studio and then we can run our app to test this out. So first let's click Get Started to move to our app list view. You should see our progress bar loading and after we wait a few seconds we should finally see the data pop in and the icon will disappear. So this is properly simulating the web service delay and eventually the successful call. Now let's try again, but actually cancel the request while it's loading. So I'll hit back on our emulator to return to the Landing Activity and once I hit Get Started again I'll immediately hit Cancel so we can catch our request. You'll find that we land inside of our onFailure method and if we look closely we can see Retrofit has labeled the reason as cancelled. Right now this will land in our I/O exception block, but if you wanted, you could have a separate conditional specifically for cancelled requests. Regardless, this proves that the feature is working as expected. Cancelling requests is one of those features you might not use every day, but you'll be really glad it's there when you actually need it. Disposing of excess calls in a mobile app can sometimes help with performance or stability so it's useful to be aware of. While we're on the topic of controlling request execution, in the next clip let's explore how we can make HTTP requests synchronously with Retrofit.

Demo: Making Synchronous Calls
Up until now, all of the requests in our app have executed asynchronously. This is the most common pattern when using Retrofit since it does such a great job of managing background threads and providing useful response handlers; however, Retrofit does provide the option to run synchronous HTTP requests. Now the use cases for this are somewhat limited so we are not going to spend a lot of time on it, but it's still a feature worth understanding. I have reconfigured our Landing Activity to synchronously retrieve the message it displays. This requires a little bit of setup and the actual Retrofit code is very minimal so in the interest of time I have completed this ahead of time. To run a request synchronously, all we have to do is create the same service instance and then call execute instead of the usual enqueue method. Because synchronous requests directly wait for a result, there are no response handler methods. We just treat the return value like any other method. However, we don't want to execute this synchronous call inside of onCreate like we have been. In fact, an exception will just be thrown if we even try. If we make requests synchronously on the main thread, they become blocking calls, meaning our UI can become unresponsive while they run which is a bad practice for Android apps. So instead, I have wrapped this call inside of an AsyncTask. I don't want to get too lost in the details of working with AsyncTask since that's sort of its own topic, but it's worth understanding a few fundamentals for this discussion. The async task allows us to manually start up a background thread as you can see by the doInBackground method we have to override. AsyncTask has a couple other methods should implement such as postExecute which runs once doInBackground is finished. There we can update our UI with the results of this synchronous request. Conceptually, you can think of this class as helping to manually recreate our Retrofit enqueue and response handler features. Again, in a real app it usually doesn't make a lot of sense to do all this work manually since Retrofit can elegantly handle so much of this for us. To run this getMessages AsyncTask we must create an instance of it in our onCreate method and then call execute. This will kick off all the method we just review. Let's run the app and see if this works as expected. So once our app loads, we should get the message back like we'd expect. Our app has created a background thread and then synchronously executed our Retrofit call within that thread. So you might be wondering why you would ever want to run a synchronous request if it becomes a blocking call on that thread. Well, it's important to understand that even though a blocking call is a bad thing on the main UI thread, there might be cases on a background thread where we want one call to finish before we execute another. For example, if a request comes back as unauthorized due to an expired session, we might initiate a background request to get a new token. We don't want to retry the original request or make any other network calls until that token comes back verified. The synchronous call can help ensure a proper ordering in the background without blocking that main thread. This topic is a good transition into more advanced concepts that are beyond the scope of this course so in the next clip let's discuss those next steps on your journey to mastering Retrofit.

Next Steps with Retrofit
By now we have covered many essential features of Retrofit. These tools should be enough to get you started building your own apps that communicate with the web service; however, as your apps evolve in complexity, there are other capabilities and shortcomings of Retrofit that are certainly worth researching. Most of these features require knowledge of topics or libraries outside of just Android and Retrofit, which is why they are beyond the scope of this more introductory course. One common requirement when working with mobile apps is image management. It's common for apps to request images from the server and display them in galleries or more visual layouts. It's also a good idea to have at least a basic caching strategy around this more network-intensive data. Retrofit has fairly limited capabilities when working with images, which is why we haven't covered them in this course. There are a couple of great libraries I recommend like Picasso and Glide, which can work well alongside Retrofit and handle this type of functionality. One valuable area worth looking into with Retrofit is caching. Caching can provide great performance enhancements by reusing response data and avoiding unnecessary network calls. OKHttp provides a cache class that allows us to build a local data store for response information. This cached data is influenced by HTTP request and response headers that define expiration and modify times. So let's say we need to repeat a request that our app has already made. First, our app can check the cache to see if the response data already exists or if it has expired. If the data is present and still valid, we can retrieve it from that local storage instead of making another expensive network request. If it doesn't exist or has expired, we can go get it again from the server. A successful caching strategy requires detailed design considerations between the server and client and a strong understanding of your app needs, but I definitely recommend looking into it further. Another topic certainly worth researching are various authentication patterns such as OAuth, which allows users to log in securely to your app. Through the user of interceptors and an OKHttp feature called authenticators, Retrofit is certainly capable of robust authentication scenarios. I also recommend looking into various types of mocking and testing. Unit testing is possible with Retrofit and can improve your code quality, but involves other libraries that are beyond the scope of this course. Retrofit itself can also mock out server requests, which allow you to easily test different response scenarios and develop offline. Finally, even though the process is a bit manual, Retrofit does support uploading and downloading files, which can be valuable to certain apps. So hopefully this provides a general roadmap for you if you're interested in going further with Retrofit in your apps. In the next clip, let's wrap up our exploration of Retrofit by reviewing a few essential concepts and goals.

Summary
Retrofit provides a host of configuration options for improving request management in your apps. Many of these features do not apply to one specific request, but rather improve the overall stability and flexibility of your HTTP traffic. Retrofit and OKHttp allow us to manipulate requests and responses through the use of interceptors. These components can be extremely useful for managing headers, authentication, error handling, and more. Interceptors allow us to hook into requests before they are sent to the server and into responses before they are fully processed by our handler methods. With Retrofit we are able to make both async and synchronous calls. Although most requests in your app will probably run async, there are many use cases where synchronous calls can be helpful or necessary. Retrofit also allows us to cancel requests before a response is returned. This can be useful for terminating unnecessary calls, which can improve app stability, performance, or user experience. We can also manage how long Retrofit waits for various aspects of a request such as connection timeouts or read and write timeouts. Retrofit defaults to 10 seconds, but we can easily expand this to handle all the variances that come with mobile networking and web service calls. Retrofit provides plenty of other features that can further empower your app. It also works well with libraries like Glide or Picasso, which can be used to manage images and compensate for areas that might not be Retrofit's strong points. So now we've finally reached the end of our introductory exploration of Retrofit. By now you should feel comfortable building your own apps that manage data through web service requests. There is still more to learn so I hope you're also excited about additional features to create and opportunities to explore. Mastering HTTP communication is one of the most essential skills for building real world or enterprise level apps. I strongly encourage you to keep pushing yourself further to master mobile app connectivity. I've really enjoyed working through our sample app and exploring the great features of Retrofit and I hope you have as well. Thanks for your time and effort and I'll see you next time.

Course author
Author: Alex Wolf	
Alex Wolf
Alex Wolf is passionate about software development and mastering new technologies. He has several years of experience working almost exclusively with .NET platforms, such as SharePoint, NopCommerce...

Course info
Level
Beginner
Rating
4.6 stars with 24 raters(24)
My rating
null stars

Duration
2h 20m
Released
10 Jan 2018
Share course