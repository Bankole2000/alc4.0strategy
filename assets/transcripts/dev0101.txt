DevOps: The Big Picture

by Richard Seroter

What is DevOps, how should you transition to it, and which technologies matter? This course answers those questions and more.

What is DevOps, really? In this course, we look the problems faced by today's IT departments and how a DevOps transformation can help focus on value and streamlined delivery. We'll explore the key cultural changes necessary, where organizational change is required, and how to confront the inevitable objections. Automation and technology play huge roles in DevOps success; in this course we'll analyze the major capability areas and which technologies can get your team on its way.
Course author
Author: Richard Seroter
Richard Seroter

Richard Seroter is the VP of Product Marketing at Pivotal, with a master’s degree in Engineering from the University of Colorado. He’s also an 11-time Microsoft MVP for cloud, an instructor for...
Course info
Level
Beginner
Rating
4.1 stars with 1113 raters(1113)
My rating
null stars
Duration
1h 21m
Updated
23 Jan 2019
Share course

Course Overview
Course Overview

Hi everyone. My name is Richard Seroter. Welcome to my course, DevOps: The Big Picture. I'm a vice president at Pivotal, a Microsoft MVP, InfoQ editor, and long-time Pluralsight author. This course has the information you need to understand what DevOps is all about. Is it a role? Is it a team? Is it a product? Just hype? We'll find out together. Some of the things we're going to cover include pain points that lead you to DevOps, required organizational and cultural changes to succeed with a DevOps model, common objections and the responses, and technologies that support DevOps. By the end of this course, you'll know what you need to move forward with adopting a DevOps style that lasts. This is a topic I care a lot about, and I hope you'll join me on this journey to learn about DevOps with this DevOps: The Big Picture course, here at Pluralsight.
Problems That DevOps Solves
Introduction

Hi. My name's Richard Seroter. Welcome to this module in a course about DevOps. In this module, we'll talk about what pain DevOps solves and what DevOps is all about. First, we'll talk about this fictitious company that we'll refer to throughout the course. We'll cover what today's enterprise typically looks like. I'll cover some common pain points they experience. We'll look at the idea of waste and how that influences how we think about DevOps. We'll then define lean and DevOps so that we can all work off a common definition. I'll share whether DevOps actually matters; what are those sort of things that actually this helps impact so you can justify the effort. And then finally, we'll wrap up. So let's briefly talk about this fictitious case. So here's Carl. He's the CIO of Globomantics, a mid-size enterprise, and his goal is to understand what DevOps is; understand the common objections, figure out the strategy for implementing this in his organization. Whether you're a developer, architect, CIO, operations person, or anyone in a technology function, there's probably something here for you. And the reason Carl cares about this right now is that this company's been an industry leader for years, but they're starting to lag on technology innovation that's impacting their ability to succeed as a business. So they were thinking about how are we actually going to get better at technology, and DevOps is one option.
Let's Learn About Globomantics

Let's learn about this company, and hopefully that will help draw some parallels to what you're doing in your company and help you actually apply some of the things we learn here. So Globomantics, this company is arranged by functional area. This is a typical breakdown of business units with a centralized IT department. So each of these groups depends on IT for services. They'll often commission IT to work on projects for them, ship software, and then run it when they're done. You often see companies do this in order to localize a particular functional expertise. Some companies do this by business line, will actually have a replica of this sort of thing for each one of their core products, or others organize this way for all their products and services. If we double-click into IT, IT is also arranged by functional area. So within IT in this company, they are segmentations of architects, developers, operators, QA, project management, compliance, business analysts; all those things are separated on their own. And then you have sub teams for technical disciplines and centers of excellence like integration, collaboration here, ERP, content management. In that center of excellence, you have some specialized skills and people who either run or have expertise in some core products that the company depends on. And of course, even though there's a centralized IT here, many of the business units also have their own mini IT org, sometimes referred to as shadow IT, sometimes to get things done faster or for some local needs. Let's start off by talking about some of the characteristics of this company including their deployment pipelines. There's a lot of handoffs, a lot of teams involved in delivering a product or service to any end user. It isn't just a single piece flow; instead, as something finishes, it goes from a development team to a QA team for testing. It goes from a QA team maybe to a release engineering team or maybe an information security team. All of these steps mean that going from code complete to production involves a lot of individuals, a lot of approvals. All those teams being involved obviously adds time and complexity to the deployment, and it also ends up having some manual intervention. There may be human signoffs. There may be review boards that have to take a look at something. There may be all sorts of steps that are not automated, which make this more complicated, makes it something that's hard to do quickly. As a result, because these are complex deployments, you often do incur some downtime. Think of the weekend maintenance windows or those emails you've sent out that says hey, the system will be offline Friday through Sunday. That's because it's complicated deployment, it involves a lot of parties in a war room, making a deployment procedure succeed, and hopefully it does so they don't have to roll back. Many companies today are also dealing with commercial off-the-shelf software, or COTS, versus custom software, things they've built themselves. So you have this sort of buy versus build discussion. Many organizations do buy a lot of software, and so in that world, you're at the mercy sometimes of what those tools have exposed. Have they made it easy to automate installation? Have they made it easy to monitor it? Is this a specialized skillset or is it something transferable? So each organization has this sort of landscape where they have bought some core technologies, even if they're Software as a Service, versus things they've built themselves. One of the characteristics then is this commercial software is usually updated maybe every three to five years. Think of your database platform. Think of your ERP systems. Think of your collaboration systems. There are not things that are updated on a weekly, monthly, even 6-monthly basis. Instead, these are major upgrade projects. We actually commission a team to go install this thing, switch over, run some testing. So these are a big deal, which can often, again, impact how you try to deploy software. In my experience, a lot of these products often get customized like crazy because there are some extensibility points in many commercial off-the-shelf products, they get customized to fit somehow your situation, which makes it then harder to upgrade, harder to bring in outside people because you've done a number of things that are nonstandard. And then finally, a lot of the functional silos in an organization do take advantage of custom software that might be unique to what they're doing. So most large companies have pockets of custom software, maybe hanging off a reporting system; maybe data collection software that isn't something they could've bought off the shelf, or bought easily, and so these teams have custom software that they're maintaining while they're buying some large software products from large vendors. Today, Globomantics, not to mention a lot of companies, have a project mindset. By that I mean, projects are funded and teams are formed. When work needs to get done, projects are pulled together from a cross-function matrix team of project managers, and architects, and developers and the like, and they go and build some software or install some software. After they finish deploying it, that team that came together disperses, and that application is handed over to an operations team. What that also means is if there's an update, you have to actually reassemble a new project team or maybe have a skeleton crew that's still on staff to help with that. Typically, these things are deployed once, and then maybe every 6 to 12 months, every couple of years, those projects reassemble and do a version upgrade. The one lasting artifact in many organizations is the documentation, and so sometimes we go very heavy on the documentation because that's all that's left and that's the no-how we have to maintain these products. Today, Globomantics, like again, a lot of companies, are optimized for cost. They're not optimized for speed. So the priority's given to cost savings. How can we consolidate into a central IT team to save money instead of having it in each business area? How can we have a single team of architects and developers so that we don't have duplication unnecessarily within the organization? How can we do these things and maybe buy the cheapest product? And how do we do things that make us more efficient as an IT organization? So that's most of the focus in many companies is how do I actually make IT more efficient? How are we using tools and things that internally help us feel like we're actually running things better? That means that the value is typically put on things like stability, predictability, rather than changeability. Most IT organizations are not oriented around going faster and changing things more often. That is not the orientation. Instead it's about, how do we have things stable? How do we have processes and principles in place that make it kind of hard to change things? Because that can introduce instability, therefore we don't want that. And so most organizations are optimized for cost, not for going faster.
Pain Points

So let's discuss some of the pain points. We just looked at where this company is, let's talk about the pain points Globomantics faces, and again, that you probably do as well, especially if you're thinking about DevOps. The first pain is serious outages. So there's panic when systems go offline. Very few systems are bulletproof, so when an issue occurs, sometimes a panic can ensue. Where are the people who know the system? What's the impact? Who needs to be involved? There's an intensity because you're not thinking always about running these systems and doing the most manageability when you build software. You're often thinking about the feature functionality. And when another team is taking this on without a lot of depth of knowledge, there's a lot of panic and risk when that system has a hiccup. You'll often get these repeated instances of the same mistake. You're not always learning from your mistakes because heroes step in and can just fix it. So you have someone who comes in, somehow makes some sort of change on the server, amazingly something comes back online, everyone goes back to normal. You might feel a little weird about that because maybe you didn't document it or no one else knows it but that hero, but at least you're back online and the panic has subsided. Slow recovery is a bit of the norm at this company when there's an outage. It's hard to pinpoint the problem. Often you have to start at the basics. Is the network down? Is the server online? You're not going immediately to the problem, you don't have the right telemetry to actually figure out what's going on. So as a result of a lot of this, you have some low faith in IT within the organization. These outages become a black eye for IT, you lose trust with the end users, and then there's a lot of finger pointing within IT about who caused these sort of outages. So this becomes a sort of painful cycle that happens over and over again as these organizations are experiencing these outages, not really learning from the things that are going wrong, and the rest of the organization doesn't really trust IT to deliver what they need. The next pain the company faces is they're not getting incremental value. It's this big bang problem. Globomantics does these major releases with no visible progress before that. So you have these lengthy projects with a lot of work up front. These might be large requirements phases, they might even be a little more agile where you're still shipping code more often, but not in any way that anyone can use it, so they're not seeing it. It's maybe going to a staging environment. So there's a lot of up-front work. Very rarely do you see something until the end. So you have these infrequent, big bang releases of large batches of software and large batches of changes, which again, can also be tricky as you're trying to troubleshoot. So the company's used to releasing every so often and including a lot of things in there. What this means is it's really hard for the company to experiment. Shipping is costly. It's hard to deploy software. So teams are hesitant to experiment. They can't do basic A/B testing to see if people like one UI or another. It's painful to try out new things, which is really starting to blunt their innovation progress. And as a result of some of this, the lines of business in the company are starting to look elsewhere for innovation. IT's reputation is slow, it's unreliable. They're not doing innovation. Different business units then end up hiring consultants who build one-off systems faster, but then maintenance still becomes a pain. That's not a long-term solution. So because these lines of business are not getting the value they want as quickly as they would like, they start looking elsewhere, which doesn't actually fix the problem. The other pain is some of the excessive infighting. IT is under the gun here. They're feeling some pressure, and so you have this us versus them mode within IT where the IT teams don't collaborate. IT is treated as separate from the lines of business as well, so it's us versus them within IT, and even us versus them within the organization, as you have IT, and then you have all these lines of business who depend on them. Each IT team often has its own incentives. The classic DevOps problem is you have this VP of development who's incentivized by feature time to market, get things shipped, new value. So they're motivated to get as many things as they can out there. But the VP of ops is incentivized by operational availability, so they're motivated to keep things pretty stable without any changes. The QA team's incentivized to find as many bugs as possible, even if they don't really matter and they're slowing things down. The project management team just needs to ship on time, almost if it's the wrong thing. So you have different incentives within these teams. None of those are necessarily customer focused. These incentives are often on internal optimizations and milestones, not customer-centric metrics. So how many of these teams, especially within Globomantics, are actually measured on customer utilization rate? How much are they measured on customer satisfaction, product adoption, those sort of things? Not things like just uptime, not just things on feature velocity. And then finally, the result of a lot of this is that you're losing talented people because the culture isn't great. Retention is hard nowadays. The IT field gives people a lot of options for where they want to work. People in tech have a lot of choices, and so organizations that want to attract and retain their talented people can't have this sort of culture or you're going to be left with people who simply can't find jobs elsewhere.
About Waste

Now let's switch gears and talk a little bit about waste and how these ideas influence the creation of DevOps. So how are we going to define waste? Waste is often referred to as anything that takes time, but doesn't add value to the customer. So what's the result of Globomantics's problems? Typically, waste. Wasted opportunities for revenue, wasted time on non-value-added activities and more. So let's name and shame some of these wastes. Let's figure out what are those things that don't add value to the customer. First there's knowledge waste. This can be caused by disrupting the flow of knowledge. Thinks like constant reorganizations, teams that don't talk, things that are actually keeping knowledge from flowing throughout the organization. But it can also be caused by the disruption of the absorption of knowledge. What is preventing people from actually learning? Is it a bunch of busy slides that don't actually convey the true point? Is it constant review meetings which are actually hiding some of the real important things you have to do? Super complex reports and procedures, not actually testing and looking at failures? What are all these things that actually keep people from absorbing the knowledge they need, therefore wasting it? And so lots of examples. Again, it could even be physical barriers, keeping teams physically apart from each other so they're not learning from each other. Knowledge waste is extremely dangerous because you're not actually sharing the information other people need to succeed. Let's talk about waiting waste. This is often caused by uneven processing. How long are teams waiting for other teams? If one team if going faster than another, you have this sort of unpredictable flow. I can't tell how long something takes because this one team is maybe writing specs super fast, but the development team's not keeping up, or a development team is writing code very quickly, but the QA team, the work is just piling up, so everyone's just waiting at different stages. What can happen here is this often occurs if you've employed highly specialized personnel. If you have people who can only do one thing, database administrators, UI specialist, maybe even someone who just knows one language and writes one type of component, you're going to be waiting, in some cases for that person to be available, and in other cases, that person is waiting for work. Because they have such a specialize skillset, rarely can you always be keeping them busy. And so a lot of different examples here. You might be waiting for environments, so a development team might be willing to do some performance testing, but they're waiting hours, days, weeks to get an actual environment to test that code in. Or you might be waiting for approvals before actually deploying your software, and therefore it's sitting there just waiting to add value, but everyone can't get it there. So again, this is a very painful one that we've all experienced I think in our jobs in IT and one that's simply not adding value to the customer. The customer doesn't want to pay for this waiting waste, therefore it is waste. Then there's over-processing waste. This is about doing more work than is actually required or needed. And this often comes from actually not knowing the requirements. If you don't know the requirements, how do you define that you're gold-plating a feature? Now I might have a requirement written down, but am I actually talking to the customer? Do I know what they actually need? Do I know their intent? If I don't know that, I often end up over processing, doing more work than I need to to either learn or add value to that customer. So I might over-engineer software. I might have very, very complicated processes that actually weren't required for what the customer needed, or really long design specifications that went into unnecessary levels of detail. I've just done too much work. It wasn't required. It's wasteful. I'm spending time on that versus doing something else the customer would want to pay for. Then you get into motion waste. This is some of the toil on the people who actually create the product. It's unnecessary movement by people or machines. Again, many of these things come from lean manufacturing, which you can think about in you mind as you hear these, but they apply to us in IT. You might fix this by actually physically rearranging your people and putting them closer together so they're not running across campus to talk to each other, or by updating tech and preventing some of that extra work they're doing in these systems. So you might have a lot of double entry of data in different systems. They might actually be literally keying it into one system and then swivel-chairing over and keying into another system. That's motion waste. It's unnecessary. It's not effective. Or you might just have really repetitive manual UI testing, and you're actually creating a physical toll on your people where they're actually going to have physical problems from some of the things that they're doing repetitively with your systems. Then you get into transportation waste. This is about moving things without actually adding value to them. So things are moving around, but it's actually not doing anything that's adding value to the core product. This can impact waiting waste because maybe you're waiting while things are moving around, and sometimes you're doing this because we've always done it that way. So this might be rubberstamping an approval doc among executives. Maybe we actually send a document around to the entire executive team to approve, let's say, a deployment, and every single time everyone says yes. I'm literally wasting time. I'm just moving things around. It's not adding any value to the core product, but we've always done it that way, so that's how we do it. Those sort of things are dangerous, and it's another way that we're not actually adding value back to the customer or the product they're using. Then you get into correction waste or defect waste. This is when the product isn't really usable and rework is required. I'm wasting effort because I'm going back and fixing something that probably should've been done right the first time. This often happens if quality isn't built into the whole process. Maybe if I'm relying on a QA team to actually detect and fix problems versus moving that further upstream in the development process, or maybe I'm rushing to hit a deadline, and so teams could just say hey, I'm finished, just so another team could be stuck with the next deliverable. So it could be based on process, could be based on culture, could be based on a lot of things. And so you'll often see this in place when you actually have a distinct software testing team as a phase in your software development lifecycle. I don't really want to have this sort of inspection-based quality model where I'm actually just looking at the results and hoping to find that everything's okay. Instead, I want to build quality in upfront so that I'm not wasting time going back to the beginning, rebuilding things, potentially throwing out a whole bunch of stuff that's wrong and starting over, versus actually having quality up front. So I'm detecting problems early and not manufacturing a lot of code or products that are bad that I'm going to have to throw out later. Inventory waste is a really tough one as well. This is about things that are piling up and not receiving value. This is about things that are piling up and not realizing the value. You can imagine in manufacturing this is a bunch of things just sitting there, not being shipped out to store. You can't sell them. You can't make money on them. And so inventory's almost evil in a lean world. It leads to all other sorts of waste and means you don't have a great flow. You can imagine this in IT as well, as you might have code piling up before the QA team. You might have requests queued up in front of an operations team to go build environments. Any sort of inventory is dangerous because while that's sitting there, you're not getting any value from that request. And so this causes lumpy processing, meaning you kind of have bursts of stuff. You're not just constantly flowing these requests through to value to customer, instead things are happening in bunches. And the problem is it can often hide problems. If I have a bunch of inventory sitting in front of a QA team and that inventory is code, it could be full of bugs and I'm going to have to just wade through all this as the QA team versus, hey QA team, here's an individual class or function, test this and give me some feedback. There's no hidden problems there. I'm immediately finding a problem, sending it back. I'm not burying it under a ton of other things that might cause it to get missed. So really, inventory waste is often if you have completed code waiting to be deployed is one example. Really anything that could be actively processed, but isn't, is wasteful. And then finally you get into over-production waste. This is really one of the worst. So this happens when you actually produce more of something than is necessary. This is one of the worst ones in lean because it often causes all the other ones. If I make too much of it I'm going to be maybe moving more of it around, or causing more waiting while people wait for stuff, or over processing it. All sorts of things happen when you make more than you need to. Sometimes you actually over produce to keep people busy. You believe you need 100% utilization, and so we're going to keep this machine running all the time, churning out widgets, even if no one's buying them right now. Or we're going to keep our staff almost doing busy work just because we want to show that they're 100% utilized. So I might do something like create a test environment for each team. Now maybe each team needs a test environment. I could do something that's shared. I could have something where each team has an isolation within a shared environment. I could be over-producing things. I could be creating more virtual machines than I need to run my applications because I'm just over provisioning because that's how we've always done it, or we have 10 VMs for every app, even if we don't need that type of capacity, that's just our standard for a medium-sized application. It's over production, it's not adding value to the customer, and it's adding to your costs.
Introducing DevOps

So let me introduce DevOps to you a little bit. Really it starts off with what do you want to accomplish? And if you think about lean, and we'll talk about that in a moment, it comes down to two things. I think you want to increase the value given to customers. We want our customers to enjoy the things that we're giving them so they stay customers so that they're happy. Eventually, obviously, they give us more money, but the goal is to first just increase the value to customers, but the one you can't forget is respect for your people. If I do this by burning out my staff and having this high turnover rate, or asking them to do just inhuman work schedules or dangerous things, that's actually still not achieving the goal here. The goal is to increase value while making sure that your people are being successful, taken care of, and able to work to their maximum. I still want the most out of the people on our team, but I want to do in a way that makes them feel valued and accomplished effectively. And so those are the two things we're after. If we talk about lean and lean manufacturing, a very successful model for really going away from some of the classic manufacturer models to actually building things a little more effectively, if we look at what lean's about, it focuses on customer value. The goal of lean isn't to cut costs when manufacturing things, it's to free up resources so I can focus on adding value. The first question you ask, even with things like the Toyota Production System, is what value are we adding from the customer's perspective? A real attention on time and value to that customer. A huge piece of this is eliminating waste. We just talked about a bunch of wastes, and so in lean you work systematically to eliminate all non-value-added processes in order to achieve your goal with the least possible effort and waste. One Piece Flow, or cycle time, is really important here. The ideal batch size in lean is one. It means I go from building it to processing it to shipping, and one team's able to process that. If I have One Piece Flow, I've almost eliminated all the different types of waste we just talked about. That's really the ultimate goal in lean is to apply that sort of One Piece Flow to all business operations. You also want shared, continuous learning, incremental improvement, that's a core part of this. It's not only am I doing continuous learning, but it's shared. I don't have a single expert who knows things. I have the organization getting smarter, I have multiple people growing, learning the right way to do these sorts of things. I'm also eliminating some of the overburden of people. Just eliminating waste is only one part of making lean successful. Eliminating the overburden to people, even the equipment, and eliminating some of that unevenness, that lumpiness in production, is just as important as just getting rid of waste. So I'm going to make sure my people are also being maximized in lean. Finally, you have this idea of the theory of constraints. This is about finding bottlenecks, removing those bottlenecks, and recognizing that those things are constraints. They're things that are holding up the process. If I don't improve the bottleneck, there's really no point improving anything else. Imagine an IT flow where I decide to make my development even better, and they're amazing. I give them better tools, I rearrange their workstations, but I've done nothing to fix, let's say, a QA team where things actually bottle up. So in that case, the dev team's working even faster, but my bottleneck is the same. That's my constraint. So my goal is to go tackle that constraint, figure out how to make that better, elevate that, do whatever's needed to improve the capacity because if I don't fix that, it really makes no sense to fix anything elsewhere. So the theory of constraints is a powerful model for actually going to fix the areas that make the most difference. Now when we're defining DevOps, one definition that's been around for a while that I still like, uses the C.A .L .M .S. acronym. And so as we think about that, we'll break down each component, each letter of that, but DevOps has a lot of definitions. All are mostly focused on value; cost savings isn't the point, just like lean. DevOps is a manifestation of many of these lean ideas, but to a technology world. So if we look at this, the first C is culture. People and processes are at the forefront. If you don't have the culture, all of your automation efforts are fruitless. You can't buy DevOps. There's no product that should really be called DevOps because just automating something doesn't matter if I don't have the right culture in place, and we'll talk more and more about that throughout this course. Automation is a big piece of it though. I need to repeatably automate activities that are redundant, that are things that are human prone to error, or things that simply add waiting waste because they're things done by people that should just be done by automation. Once you have some of the cultural pieces in place, that's when you can also use some tools to stitch together core steps of your deployment pipeline. And of course all those lean ideas we've talked about are really important here. We want to make sure that we're applying those lean concepts, that we're actually decreasing the amount of time to make changes, that we're making work visible, reducing batch sizes, building quality and preventing defects, all kinds of things that are core to lean, that you apply those to IT to actually make better software that adds value to the customer. And metrics are important. This isn't just about a one-way directional flow, it's about feedback loops. It's about making sure that I'm measuring progress, that I'm measuring customer usage, I'm measuring things are going wrong so I can improve that. Any successful DevOps implementation measures all sorts of things and has discrete feedback loops between teams, from the technology back to the people who build it, to make sure you're always able to improve. And then finally, sharing, continuous learning. So again, I'm not just collecting all this data, but I'm learning it by sharing the knowledge. This is really the core part of the feedback loop, creating a culture where people are sharing ideas, problems are the focus. We're critical, we're going to swarm on that, we're going to fix that, we're going to do things together. When I follow the C, the A, the L, the M, and the S, I start to build the actual culture, the process, the technology needed to be successful with DevOps. Now does DevOps matter? Are all the things I just called out worth it? That seems like a lot of work if you're in an organization where things at least appear to work, this is a lot of change that you might be introducing. But the real difference is the elite performers, the ones who are doing these sort of things are winning in industry. If you look at the 2018 Accelerate State of DevOps report by Dr. Forsgren and team, you get some amazing numbers, and they've been running this survey for years, so they're actually seeing year over year changes. But the high performers, these elite performers, have an amazingly faster time to recover from incidents. They don't have these long outages that we pointed out earlier in this module that Globomantics faces. Instead, they can recover very quickly from incidents. The elite performers are doing 46 times more frequent code deployments. That means they are getting value into the hands of their customers much faster than everyone else. So the best companies in the industry right now across sectors, this is not Silicon Valley IT companies, these are companies in retail, in government, in financial services, and healthcare. All of these sorts of organizations are doing DevOps successfully, and they're doing that and they're getting code, they're getting value into the hands of their users fasters, meaning they're learning faster than you. They're learning faster, which means they're making their customers happier, which is a risk to any business. It's also interesting, they did a nice job tying this back to business goals. So more than one and a half times more likely to meet or exceed their business goals when they're elite at technology, and they're using DevOps ideas. So they're actually a more successful company. As you can imagine, that's not hard to realize when we look at this module and we look at the sort of waste that infects, not just IT teams, but sometimes the company as a whole, as they're not focused on customers, as they're not focused on shipping value. And so the companies that are doing that are actually exceeding their business goals at a better rate. And then finally, it's almost two times more likely that these elite performers are going to recommend their team to others. This is a recruiting tool. This is a retention mechanism. This is the elite performers are building and retaining the most talented people. The most talented engineers in Silicon Valley companies or startups came from companies like yours. So these aren't people manufactured somewhere else. Your team has probably some very elite performers on there, they just need to be unleashed. The best companies at technology are now making it possible for their people to succeed in that organization, and then they're bringing in other talented people. This is a cascading effect that's very exciting.
Summary

I think this was a good first module. We really looked at a number of things here. We kicked off the course by talking about the overview of what we're trying to accomplish. We discussed Globomantics, our fictitious company that maybe resembles your own company, or at least aspects of it, as this company has traditionally been a leader, but now they're struggling to keep up because technology's actually holding them back a bit. Today's enterprise, like them, might be dealing with projects over products. They might be doing a number of things where it's hard to keep their systems online. That causes all sorts of pain as they don't have the trust in IT, they can't get value into the hands of customers. We looked at waste and the idea of things like waiting waste and over-production waste, and all these sorts of things are actually things that if you asked your customer, would you pay for us to have this meeting to discuss this design spec, they'd probably say no. So maybe that's wasteful. Maybe that's something I should be trimming. When you start thinking in a waste mindset, you put a more critical eye on some of the activities that are happening in the organization, and maybe don't keep doing things just because you've always been doing it that way. We defined lean, some of the core ideas of One Piece Flow and building quality in, and then saw how that applied to DevOps. DevOps also includes these cultural aspects, these metrics, these feedback loops, and of course, automation and technology, but you will never buy DevOps from a company. That is not a product that should ever be on a price list from your vendors. Instead, it's something you do. It's a cultural thing. It's a practice. It's a way of working. Does DevOps matter? I hope so. DevOps does matter. The best companies who are following DevOps principles are succeeding more in business than others, and they're keeping more of their talented people. I hope you enjoyed this first module. We're going to keep going by talking about some of those changes that actually have to happen to make DevOps a reality before looking at some of the technologies that do play a big part in you being successful here.
Making a DevOps Transition
Overview

Hey there. My name's Richard Seroter. Welcome to this module in a course about DevOps. In this module, we're going to discuss the changes you need to make to succeed in adopting a DevOps work style. We'll start off by talking about how do you change the culture? What are the core cultural changes you have to make in your organization to be successful? And I'll candidly tell you, if you don't make the cultural changes, you really should ignore the rest of them because you're not going to find the success you're after. Next we'll talk about some of the organizational changes, what actually has to happen within the company to orient you to be successful. And then finally, I'll fire a few objections at you that you might hear when you're trying to make this sort of change where someone will try to either blunt it or shoot it down, and give you some answers you can provide there. We'll do all that and wrap up.
Change Culture: Start with Why

Many DevOps changes do fail, the numbers prove it, because they don't meet the expectations, and some of that happens because they actually don't deliver the value you're after. They don't deliver the change and practices you're after. So without changing the culture, typically the rest of it becomes a facade. It's a new automation tool. That's interesting, but that's not introducing a fundamental change to your organization. So we have the cultural changes. Well first, you need to reestablish your purpose. What are your shared objectives? What's universal across all parts of the organization? Does everyone at Globomantics, the company we discussed in module one, do they have a shared goal? Feel a shared pain? Do they have one customer they're thinking about? Do they empathize with the customer or are they disconnected from the customer and don't really know what they need? Does that person in ops know why they're keeping that system online really? Do they know who they're serving? Are they keeping it online for the developer? Do they treat the developer as their customer, or is everyone heads down thinking about their individual silo and they're not really feeling the pain of that customer who's trying to use their system internally, or the outside customer who's trying to purchase a product, who's trying to fulfill a prescription, who's doing something that's really important to them and they can't do it, so reestablishing that purpose is key. Are you going through the agile motions? If you're just doing agile development, but you're doing it a certain way because the book says so and you're just following certain ceremonies, it doesn't matter. Stop doing that. Are you going through the motion or are you doing the things that matter? Reestablish your purpose. Any sort of misalignment here really is going to doom the effort. If you value hitting dates over quality, if you value silo success versus the collective company and customer-oriented success, if you think your staff is just interchangeable numbers and I can just replace people as they leave, if you do any of those things, it's really going to be hard to be successful here. So if you don't change your values, you honestly should probably give up the effort. I'm not usually a doom-and-gloom person, but this is one of those important things, that values like this that we'll talk about over these next few minutes, are really important to success.
Change Culture: Empowerment

The next one to spend time on is elevating the idea of empowerment. Trusting the team, letting them take some ownership. The employees are doing what they need to do to build and run the service for their customer. They're having more control, they're not having as many gates to get through, they have less approvals to chase down, fewer teams to hand things off to. Instead, you're empowering these teams so you don't end up with the, well it's not my job, sort of answers. Instead, people feel like they're in control. They can go make things happen. Anyone can pull the cord; by that, I'm referring to in a lean manufacturing delivery process, there's an actual cord in there, and if something's going wrong, any employee on the production line can pull that cord, which stops production, halts everything. They can call someone over and say I see this problem. That's an empowerment thing. Someone who's scared to do that because they don't want to get yelled at, maybe something's not really a problem, they think that the last time someone did that they got fired. If you have that kind of culture, guess what? People will not raise their hand. They will not go just fix things because they fear the consequence. Instead, you want everyone in the organization to be able to raise their hand going, quality's not good enough on this software. We cannot ship this. And they can still be wrong, they still have to make their case, but empowering everyone is important here. The teams that come together when they're working together, these empowered teams often form when there's a crisis. They can use their judgment to actually resolve issues. So when teams are empowered, they can come together themselves really quickly and solve problems.
Change Culture: Accountability

I can't have empowerment without accountability. That's important. I just can't say everybody can do whatever they want and there's no consequences or there's even no accountability if they do something right or wrong. So instead it's about also holding teams accountable for the product, the project, the service success. Focusing on quality means not just relying on a QA team to inspect and catch some defects. Instead, it means actually making quality parts of everyone's job in the organization, everyone's. Everyone's responsible for the health and quality of the service. That's a cultural change, but it's such an important one that makes everyone accountable versus I don't know if I figured out this edge condition, but QA will figure it out. That makes a shared commitment to excellence. Everybody embodies, and frankly protects, excellence. This is often shared among a team, and there's actually a little bit of social pressure to step up and call out bad form because we're all in this together, and if we see a teammate maybe, again, taking shortcuts, or not stepping up to fix something that they broke, that's something the team then calls out, not a manager, not some sort of thing, but the team really feels a shared responsibility to deliver something great because they are the ones who are building and running it. So how are you rewarding people? Are you rewarding people who deliver and take responsibility? Are you rewarding people who actually ship and execute, not people who just come up with ideas? Ideas are important, but I want people who will also just take responsibility for what they're doing and they're accountable when things go right or wrong. That's what you reward, and that's the signal you send to the rest of the organization.
Change Culture: Teamwork

Another core cultural change is you're requiring teamwork, all disciplines working together in crisis or daily operations; developers, operators, project managers, QA architects, they should all be working together in both quiet times and in crisis. To do that, you have to respect the unique skill sets. It's not those silly people in development, it's not those lazy QA people, it's not those awful project managers; instead, it's respecting that each of those people has some unique skill that they have trained and learned, and yes, they might not be technical, or they may not know how to figure out a project plan, they don't recognize complex architecture, that's okay. There's unique skillsets here that all have to come together to form a successful product. If you're leading one of these teams, you need to look for excuses to get these teams together. Do brown bags where people are demonstrating features, but also make sure the ops teams are there, or the ops team comes in and explains some new hardware and considerations for your cloud deployment. Take lunch breaks together, co-mingle. These sort of teams shouldn't just come together when there's emergencies. And what's really important is again, not having this model anymore where you have the lone genius or the firefighter. I don't want that person who no one can work with, but they're just super smart. At some point, they're not super smart, they're actually a hindrance on the team. And so I don't want to just have people who just do great work on their own or people who can just swoop in and somehow fix every problem in production. At some point, that is waste. That's slowing me down, I'm not transferring knowledge, I've put way too much into one person. And while that person could be brilliant and super helpful, in some cases they're actually maintaining the status quo because they like the status. They like being the hero, and that's not helpful to your culture. So, when you move to this world of requiring teamwork, sometimes this starts to weed out people who were brilliant on their own but can't play nice with others.
Change Culture: Learning

As a culture it's about encouraging continuous learning, offering resources and time to learn. Using Pluralsight subscriptions, sending teams to conferences, encouraging a public profile and engagement, not locking your people away so they can't learn more and worrying they're going to leave. It's about encouraging experimentation, having ways for teams to maybe have a hack Friday where they're going to try to solve problems in unique, interesting ways, or maybe, because you've made deployment simpler, they can try something new in some of the new applications you're building and figure out if customers like one way or the other. Deploying a new navigation, does that work well? Changing the order of fields on a form to see if that increases the completion rate. All kinds of things that you won't do if you ship every year. But if you're shipping every day, and I encourage teams to constantly experiment, learn, what makes our customers happy? What satisfies them? That's going to encourage a certain mindset for people to try new things with technology, with your processes, to see what works better. When things do go wrong, and they will always go wrong, having postmortems or retrospectives to figure out what happened. Instead of shying away from discussing failures, embrace them as learning opportunities. Invite a broad audience. Share your notes afterwards. These things aren't about pinpointing the problem to one person. Instead, it's finding what broke down in the system so we can go fix those things and we don't have repeated mistakes, like you can often have in organizations that just seem to have the same problems over and over again. It's so important to make it easy to share and discover information. How are we sharing it? Are we doing public forums, again, brown bags, and all hands, and things like that? Or do we have a great environment internally, whether that's a Wiki, whether that's a chat place, whatever it is, how are we making it easy for teams to share and learn information so that everyone's getting better all the time? No one feels stagnant, and more people then are empowered to jump in and help fix things or volunteer for assignments.
Change Culture: Reinforcing Values

Finally, culturally, it's so important to share, live, and reward the right values. Don't just say your values. Don't just print them out and put them on the wall and say this is what we believe. You have to live it. You have to prove it. So what triggers promotions or bonuses at your company? The person working 80 hours a week or the person who just shipped something of value to the customer? If it's the former, if you're simply promoting people who happen to be the noisiest people, or working the most hours, or swooping in and solving the most problems, you're sending a signal to the team. We all notice who gets promoted. We all notice who got the biggest bonus, and then we're going to emulate that because I want that bigger bonus, I want that promotion. So what are the behaviors you're trying to encourage within the company? You're demonstrating that by how you promote people. And the managers have to lead by example here. If, as a manager, in your role, if you're bad mouthing another team, guess what? So will your employees. If you reward firefighters, guess what? The team won't worry about consistency because they'll know if they can jump in and save the day they're going to get praised. If you reward delivery of quality components, doing it on time with human hours, the team notices that, other people notice that. So it's really up for the managers to make sure they lead by example here and thoughtfully think about how they're rewarding and sending signals to the teams.
Change Organization: Understand Customers and Bottlenecks

Let's now talk about changing the organization. We just talked about changing the culture a bit, what does it mean to actually change some of the things in the organization to make us successful with DevOps? First off, understanding your customers and the actual value streams. I can't automate or optimize what I don't actually understand, so I need to build up and value empathy for users. I can't design anything truly useful unless you understand the people for whom you're designing, says Jeff Sussna. I love that quote in his book, Designing Delivery. I can't just skip right to writing automation scripts if I don't know what I'm doing and I don't understand what's happening. Then what's the point? What am I automating there? I need to think about understanding my user, empathizing with them, and putting myself in their shoes so I can feel the pain they feel or understand what they're thinking. So sometimes this requires all of us to step back and see the system in place, focusing on different perspectives when you look even at your technology systems or your overall programs. Look at them from a value perspective. Where's value? Where's the waste? What are the processes or the flow? We've talked about things from a waste perspective, I could look at value. Where's the expected value to the customer? What's the something they've asked for versus what's delighting them? What's actually making them delighted to use our systems? I could look at different process maps and figure out how that reflects in my system because sometimes I'm going to have even necessary waste. It's good to see where in the process things are actually adding value. So you might do something like value stream mapping exercises to focus your improvement efforts. I might want to understand the components that make up the solution and see how they work together and kind of see sometimes where the hidden pain is or where the handoff are, where the bottlenecks are that I should go optimize. So it's really important to start off organizationally seeing the system, figuring out where I should actually spend my time. And as I just mentioned, some of that's about putting the spotlight on bottlenecks. It's ineffective to optimize anywhere but the constraint in real life. So if my pain point in my value stream is the release engineering team taking code and putting that into production, it honestly makes almost no difference to give the developers better tools, to give the testers better tools, to add more people to a PMO team or architecture team. You're wasting all of your money because if you don't fix the constraint, all you're doing is piling up more inventory. And so when you think about optimizing, you have to start at the constraint. When you fix that, you move to the next constraint. But that's such an interesting, fun way of thinking about this because it makes sure that any improvement you're making outside the constraint, it's just an illusion, and so focus there instead. And a constraint could be anything. It could be internal, it could be a person because there's only one person who approves every release, we've got to fix that; let's add two. Let's change the process. Or it could be external. Look, there could be a bottleneck because there's just limited demand for what I'm shipping, and therefore maybe I should change my flow or my output or my volume because it's actually not something people are asking for. So identifying the constraints and figuring out what they are is important. The theory of constraints, that sort of mindset helps you identify and eliminate any of these limiting factors, but bottlenecks is such an important way for all of us to start taking this DevOps approach seriously.
Change Organization: Remove Inconsistencies via Automation

The next thing I'll say organizationally to think about is doing away with inconsistent environments. This applies to different environments, but also within each environment. So Globomantics developers don't have a production-like environment to develop against. Why not? Well, maybe it's too big, maybe the configuration isn't the same, but then there's so much wasted time getting code tested and deployed correctly when each environment is different. If you have this bottleneck, is that because it's taking too much time to get an environment? Can you easily recreate production in dev? The result of this bottleneck is you simply have slower software releases and slower issue resolution. QA becomes a bottleneck when they hit defects and developers can't reproduce it. It's a real pain in the neck because you simply have this sort of excess complexity that you don't need to have. So aim for on-demand environments that, at least configurably, look like prod, even if they're smaller, in a way that seriously mimics production, and they don't configuration drift, meaning that the configuration can be the same in dev, QA, and prod; everyone's working off the same setup. When something does change and you have a new base image or new operating system, that cascades everywhere. So everyone's using a cloned environment in each place, so I don't have any of this defect waste. I don't have any of this waiting waste, waiting for environments. Everything's on demand, everything's identical. Next, it's all about automating the path to production, such an important thing to do in a DevOps world. How fast can you deploy code? Is inventory piling up? If you're at Globomantics, there's people actually scared to touch or update systems because it's such a pain in the neck and it's such a complicated process, but do you have this inventory of useful features just sitting in QA or sitting in someone's head waiting to get into production, but not happening because it's so cumbersome? So often coding faster or testing faster won't help you if the deployment process has too many manual steps and I'm packaging up software, handing it to this team, deploying it to this group, staging it here. If that deployment process isn't optimized, I'm really stuck. The solution involves things like continuous integration, comprehensive automated pipelines. By comprehensive I mean that pipeline should do everything it takes to get this to production. Security scanning? Sure. Configuration management in your config system that actually is doing change control? Absolutely. How do you think of comprehensive pipelines that do not require any person to be involved from code complete to production? That's not easy, but that's such an important way to make sure that you improve things like experimentation because getting code to production is faster. You fix defects faster, get value in the hands of your customers faster. So automating the path to production should hopefully be a rallying cry for your team as you get going with DevOps.
Change Organization: Build in Quality and Break down Communication Barriers

Next up, it's about building in quality upfront. QA teams are not responsible for quality at your organization or any. They may've been given that task, but in reality, we are all responsible for quality. There is not one team responsible for that. That shared commitment to excellence means testing early and often. It makes sure that we are building things in upfront to constantly test out code, to make sure that we're thinking about this upfront, whether you're using test-driven development or another way of working. It's about actually making sure that we are testing our code, we're thinking about the user experience, we're having empathy for our customers, not waiting for some other team to catch our obvious mistakes. And so I may use things like TDD, test-driven development, that's great, quality from the start, but even then, whatever, rigorous integration testing that doesn't let developers commit code that fails to meet a standard. That's where continuous integration is such a powerful idea. Next, organizationally, it's about breaking down communication barriers within your company. Poor communication results in push, not pull-based systems, meaning if I'm not letting you know stuff is coming, what does it mean? I'm just handing stuff over to you, you weren't expecting it, you weren't optimized to process it, and now, again, inventory piles up because I'm doing push-based movement through my pipeline versus pull-based saying hey, I'm ready for work, let me go grab the next thing. It's this nice, clean flow when you have these pull-based systems versus pushing, when I might be surprising the recipient. So feedback loops are really important here. It's critical helping these teams understand what's coming. They know why it matters. They know why this next push that's coming through is really important to customers for this reason. So really, really great stuff, and I could have good feedback loops, all of sudden again I break down these communication barriers, and I have more people, again, accountable and empowered, to make this happen. So some of this is a mix of tools. It's going to be practices and procedures, and sometimes just literally that intent that I want to collaborate. I don't want to have this confrontational relationship or siloed knowledge; instead, I do want to actually want to make sure that everyone sees the outcome of this work and we're in this together.
Change Organization: Rethink Team Approach

And so potentially controversially, you need to rethink and rebuild your teams. Organizationally, you have to make some changes to actually rethink how you're organized. Typically, IT is organized by functional teams, pools of developers who work on projects and then go onto something else. Globomantics does this, many companies do. It's teams of specialists, and then maybe some skeleton crew that runs the project after. The result? You have waste. You have uneven flow. You have poor visibility of the value stream. You have teams that are, again, swarming on a problem, building something, leaving, and am I still adding value to it after the fact? Is it wasteful? Am I actually getting things to production constantly or was it just one burst and we all went and did something else. Smart companies right now are moving from projects to products. Instead of saying let's form a project and do some work, they're saying let's build a product and staff that product so that when we do a release, we group again and we do another one and those same people stay together and run that product. So you're building and running products within a unit versus just forming a development team and an engineering team to build stuff and then handing over to someone else. Now this won't apply to everything. You're not going to do this with everything you build, but for a lot of your core systems, you take a product-based mindset. Look, we looked at the classic IT organization earlier. This is optimized for IT efficiency and cost, not for speed. You wouldn't have this grouping if you were oriented for speed. What do you do? You form project teams out of these groups and they kind of matrix in, they have this project team trying to build some software, or deploy some new packaged software, and then they go back into their organization when they're done. But as Adrian Cockcroft said, DevOps is a re-org, not a new team to hire. Instead, you're looking at these all-inclusive pods that can come in and have every skill they need to build and run the service. You have these empowered groups that are encapsulated that can go everything from product design to building the software, to deploying it, to running it. Everything you need is in that one unit or pod, very empowering. It's focused on speed. Is it a little less efficient? Sure. You might have some duplication because you have people in different teams all maybe doing a similar thing, but it's also oriented around the customer.
Change Organization: Alter Team Structure

And so you end up creating permanent teams around some of your core products. The teams don't disband after just shipping one version. They come in and they build and run their service. This isn't, again, going to be a fit for everything, but it actually makes it more responsive, higher-quality result that gets better satisfaction from your customers. So the benefits here, well, you retain knowledge. I don't just rely on giant documentation that no one wants to read. Instead, I have the people who built it the first time still here educating new people who come on the team. I have constantly updated services. I improve customer satisfaction, and really importantly, you don't have these sort of big batch releases because everyone's terrified that you'll never ship again; so let's add every feature into the first version, which then delays its release, makes it more complicated. Instead, if I know you're going to ship again next month, sure we can hold this. I could do smaller releases with a smaller change surface because I've built some trust in with my stakeholders, and we're going to keep going on this. So again, not a fit for every product, but it puts a focus on customer value. In large organizations, you might move to this new model of platform ops where you have a team that delivers, maintains, and improves a Platform as a Service or an application platform, has all the CI/CD sort of toolchain ready. And then application teams, these sort of product teams are really just managing down to that platform. In a large organization, in Globomantics or your own company, you're not going to stick an operations person on every sort of team. You might not scale that way. So instead, you still may have some platform operations, you still may have people who run platforms, and then all these product teams deploy to it. Whatever your configuration is, the idea is you're switching from this project to product mindset. So you need complete teams. That means I have teams going from idea to production all on their own. So I'm encouraging a generalist skill set versus just having hyper specialization and all these people who only know one thing and have to wait until someone needs that one thing. Now you're still going to have people who have a specialization, nobody's just going to be a generalist on everything, but you also want people who can then pair with someone else and maybe build something in a front end, even though they're typically a back-end person. They can understand both and add value there. In some large organizations, again, I still may use services or APIs for a constrained team. I'm not going to put an information security person on every one of these product teams, you probably don't have enough of them, but you may have APIs around security code scanning, or doing other vulnerability checks or dependency management. You may have those things turned into APIs from those constrained teams, so I can still use that in a self-service fashion. So again, you're thinking of complete teams, teams that can actually solve their problems themselves and get things into production.
Change Organization: Eliminate Waste

Finally, you're really looking at it organizationally, how do I eliminate waste? How am I looking at policies and procedures that got heavier over time? It's typically not malicious. You're not purposely trying to make people slow, but these things have gotten bigger over time, they've become just the standard way we work, and sometimes you have to go back to the intent. You might have a procedure around requesting hardware, new or upgraded. You have to request a change. Maybe it takes place in front of a large review board once every six weeks. Do you actually need that policy? It is achieving its intent anymore or is it really just getting in the way? So looking at those policies and procedures that are well intentioned, but actually slowing you down. Automating manual steps wherever possible, organizationally promoting this idea, and especially not making people think they're losing their job as a result. So technology helps here of course, but it also takes a change of focus. This is where this isn't just a technology improvement. This is organizationally saying we want to eliminate waste, we want to put a focus on the customer, we want to automate more things because that helps us do more valuable things for the customer.
Addressing DevOps Objections

Now let's talk about overcoming some of the objections that you may have when you're starting off on this DevOps journey. The first objection you may hear is that DevOps actually makes us less secure. Devs can't touch production, there's information security needs, there's all sort of compliance needs. So that can be a fair objection. Really the focus here though and the response is that we're focusing on quality, which reduces security vulnerabilities. Focusing on teamwork and automation actually helps us do things in a repeatable fashion, typically through automation, which is going to help us be more secure. Likewise, automated mirror test environments also mean I can adequately do security testing even before production. DevOps shouldn't open you up to security issues, it should actually close many of them. Likewise, shifting left or moving security earlier up in the dev process actually improves your overall posture. And when I automate, it means fewer manual mistakes, faster vulnerability resolutions. So if I do this correctly, I'm actually more secure when I'm doing DevOps because of these things. Another fair objection is hey, we have offshore teams. This whole, let's stick everybody in a room and work around the table together, that can't work for us based on how we're investing. So co-locations of teams isn't always possible or even necessary. Now of course, not having this can be more difficult. Teams that are coming together to work on something new, if they don't have the relationship, if they don't have some of that collaboration already in place, it can be difficult if people are in different time zones in different environments. But really, shared culture, values, and incentives are the only requirement. These teams have to be on the same page. There has to be some overlap in these things to make sure that these teams work well together, but the nature of your outsourced partnerships probably has to change. If this is Globomantics, or you, or you have some sort of organization where a major function is completely handled by some sort of third party that you don't really interface with, it will be very difficult for you to optimize your entire deployment pipeline because given that theory of constraints, you may be optimizing areas that aren't actually the bottleneck. You're working on things in your location, but your outsourced partner is actually where things are slowing down. If you don't have any control over that, it's going to be impossible for you to improve it. So you may need to change some of the nature of this to regain some of the control back, or at least improve the visibility so that you can improve the process.
Addressing Additional DevOps Objections

Another objection you may hear is hey, you're eliminating our ops team. All of sudden this is now no ops where I have to fire all my admins since everything's done by automation and robots. But is that really the case? Are you firing all the system administrators? Far from it. If anything, operations becomes a more important role, but the role itself does change a bit. Ops takes on this important role of delivering environments everywhere, getting production value to everybody. It's about making APIs that automate infrastructure and delivering deployment pipelines, and these teams are working together with ops versus just throwing it over the wall to an ops team. But the ops role is constantly changing, as many roles do. This isn't going to stay the same. Ops team shouldn't be patching infrastructure anymore. You're moving up the stack, you're adding additional value, and you're trying to automate all this commodity work and all this manual toil that's not very value-added for your company. So all roles will always evolve, but operations and the skill about architecture and infrastructure automation, that is hugely valuable, and that's not going away. Another objection that may come up is look, I've got too much existing software and legacy code, I can't automate any of that. But, can you only do DevOps with fresh, cloudy systems? I say the answer's no. I can do DevOps with a mainframe. I can do DevOps will all kinds of on-premises infrastructure. If I start doing test-driven development, I start doing continuous integration, deployment automation, I can do that even with legacy environments. Large enterprises often can't get code to production because they haven't built the flows in front of these production releases to constantly test and ship code. Doing that, even with legacy systems, is entirely possible. So the point isn't just pushing code faster, but it's also improving the flow. It's reducing the bottlenecks. It's automating where possible. It's reducing unnecessary friction, getting rid of waste. So even if you have software you buy from a vendor, even if you have legacy applications, there's things you can do to improve the flow of those systems and get into this sort of DevOps mindset, even if you aren't working with native cloud systems. Another objection I've heard is hey, we don't have these skills. These are some sort of magical unicorn skills that only people trained in DevOps can actually do. Our teams didn't grow up this way. I'll tell you though, this is an investment work making. These are skills that are valuable, it's good for these folk's careers, many of these are soft skills. They're not even just technical skills, saying I have to learn configuration management tools or cloud APIs. It's about better communication skills, developing empathy, persuasion, presentation skills, continuous improvement mindset. These are all valuable things for your team that aren't just about learning the new hot technology. It's also changing how these teams are working together. And as you make a group learning and apply it, this is going to be something where multiple people are learning these things, they're immediately applying it to their new product team, and being able to not waste that knowledge while it kind of atrophies while they wait for something to use it on. Instead, it's about teams learning together, applying it immediately, and this is how you start to build the skills in-house so you're not waiting for some sort of outside experts to swoop in and save the day.
Summary

In this module, we kicked off, looked at the overview of what we were going to cover in this module. We talked about changing the culture. What are some core values and principles that you have to internalize to really make sure you're successful with DevOps? Then what organizational changes are necessary as you think about changing team structures, as you think about certain approaches that actually impact how the organization runs? Then we looked at a handful of objections that you may face, and there's going to be additional ones I didn't cover here, but hopefully as you go through this course you feel better prepared to answer those objections. I hope you found this module useful. In the next one, we're going to talk a little bit more about the technologies that make up your DevOps transition.
Introducing DevOps Automation
Introduction

Hello there. My name is Richard Seroter. Welcome to this final module in a course about DevOps. In this module, we'll cover the core technology categories and specific technologies that help you realize your DevOps objectives. There's a lot of good stuff to cover here. We'll start with an overview of the overall DevOps toolchain. What are all these different categories? We'll look at planning tools, issue-tracking tools, some source control management tools, built-in testing tools, continuous integration and continuous deployment tools, some of the configuration management tools, cloud platforms, monitoring and logging tools, communication and knowledge-sharing tools, and then we'll wrap up the course.
About DevOps and Tools

Now before going too far down this path, there's a few things to remember about DevOps and tooling as a whole. Let's remember that the goal here is continuous improvement. It's not an, if it ain't broke, don't fix it mentality, instead, you're thinking about automating repetitive tasks. Those are many things about the tooling that we're thinking about here. There's a feedback loop. It's making sure that we're using the right tool and we're always learning, we're improving what we're doing, but you cannot buy DevOps, as mentioned earlier. There's no product that makes you DevOps. There's no teams that just makes you DevOps by bringing in some third party. DevOps is a new way of working that focuses on the customer, focuses on reducing waste, focuses on efficiency and flow. These are things that involve how you work, not just what you buy. Now there's technology that helps it, as we'll cover in this module, but there is no product that you should be buying, thinking you're doing DevOps. And then some of the tool adoption does happen in stages. You may start off with just using source control systems. You may start then moving into builds being triggered by committing to that. You may be then be automating the testing and deployment process. You then may be getting more advanced in how you're doing telemetry and feeding that back into your teams. So, some of these things will happen in stages. You won't just introduce 15 technologies at once, successfully at least, and expect that to make a difference.
DevOps Technology Categories

Now let's take a look at the DevOps toolchain. We're going to start by thinking of planning tools. What are those things that help us actually design what we're going to be building and running? There's issue tracking tools, figuring out what sort of things we need to fix and improve. There's of course source control systems, often the heart of many of these DevOps efforts. There's a set of build tools that are complemented by testing tools, continuous integration tools then feed into continuous deployment tools. Configuration management plays a big part. Cloud platforms, both on-premises and off, are a big piece of being successful here. Monitoring and logging, really a key part of the feedback loop, and across all of this is improved communication and the tools that support that, and knowledge sharing and the tools that support that. We're going to start off by
DevOps Technologies: Planning

looking at planning tools. These are the sort of tools that help us get going with the technology. And really, if you think about these matter to DevOps because they're helping you define a shared purpose. They're giving you better transparency. They're empowering the teams. You're getting the collective team participating in planning. You're able to see if everyone's priorities are in harmony or not. And these are often online tools, not static documents that are always out of date. So what are some examples of planning tools? GitLab has some tools for actually planning things out and being able to look at the scope of work; Tasktop, CollabNet's VersionOne, Pivotal Tracker, good for agile backlog management, Trello, used by many teams as they're trying to plan out individual sprints of work. And same with Azure Boards, part of the Azure DevOps portfolio of things. And again, theses are ways to visualize work, share plans, track progress, and make sure that you're going towards the goal.
DevOps Technologies: Issue Tracking

Next we have issue tracking tools. As we think of this category, it's the sort of things for collecting, triaging, and responding to issues; shared systems, things I'm not having each team using their own because then I can have extra transportation waste where the information gets lost in transit. Why does this matter to DevOps? Why do you care about these tools? Well it's customer responsiveness. I'm showing them listening to you. I'm empathizing. I'm hearing what you're saying, and it's helping me prioritize what I'm going to build back in the planning stage. There's a limited knowledge waste if I'm not duplicating systems and losing data as it moves from system to system, and overall helps feedback loops make sure that these teams can talk to each other, work on things that matter to the product. What are some examples of these issue tracking tools? Atlassian's Jira is good. JetBrains YouTrack, Zendesk, other ways you you can collect tickets, assign them, process them, triage them, make sure again that you're hearing from your customers and not having them just scream into a black hole with no one listening to their feedback.
DevOps Technologies: Source Control

Source control systems are just a foundational piece of getting into DevOps, and it's valuable because these are your software assets. This is the stuff that matters. Maybe one of the most important pieces. You're not just using a file system somewhere, you're using something that's storing your source code, storing a lot of your configuration, in modern applications, not just your code itself, but the infrastructure manifest, the definitions, the things that can actually help you repeatably create infrastructure. So this matters to DevOps because it helps you manage all of your assets, both infrastructure and application code combined, you can limit transportation waste by not having a bunch of duplicated things or things copied between file systems, but you have a shard source control repository, and it's empowering to teams to be able to check out a certain bit of code, make some changes, check it back in, give them control over the source. So a number of things in this space. Git has obviously gotten very popular, you could use that by itself. You can use hosted things like GitHub on the public cloud, or even GitHub Enterprise. GitLab has a great offering, Bitbucket, Subversion, a lot of things in this distributed source control space that can really help you make sure you're managing your source control well, whether binaries, source code, manifest files, pretty much anything that defines your system should be able to be something in a source control system.
DevOps Technologies: Build and Test

Let's look next at build tools and what build tools are offering you. Really, this is about a precondition into getting into continuous integration, continuous delivery. It's about consistent ways to package your source code. Automating sometimes the error-prone activities of bundling code with all of its dependencies, putting it somewhere that's accessible, and it can also help you move quality left by having tests that are running as part of your build process, running unit tests, to make sure that that package, as it moves from environment to environment, is in good quality shape. What are examples of build tools? Well, if you're a Java developer, you may be using Maven or Gradle. You might be using MSBuild for .NET applications, Rake for Ruby. And then I combined a couple of categories here. I might be using JFrog's Artifactory, Sonatype, NuGet for actual package management. So when I actually deploy the result of a build to an artifact repository that I can then use in my other systems to move that package between environments. So this a mix of the tools that build things, as well as the tools where I store the resulting artifact. If you hopefully take nothing else away from this course, understanding the value of testing and the importance of testing to make DevOps successful. I can't trust deployment pipelines if I don't have testable code. Instead, I'm just moving something that may not be of good quality, quickly through a system. So testing and having the right tooling here makes a huge difference. This is also something, it's about helping us catching defects earlier and eliminate some of that defect waste by taking greater ownership of quality up front. So this matters to DevOps because it puts the focus on built-in quality, not inspection after the fact. And then it helps you create confidence in your deployed artifacts so the teams become more willing to say, yes, let's take source code that's checked in and have it go all the way to production because we trust that there's good gates in place, we trust that there's good quality checks in place, and we know that what we've built has been tested thoroughly up front and we can go to production without a bunch of manual steps. What are some tools here? Well if you're a Java developer you may be using JUnit, xUnit.net, Selenium for UI, Jasmine for Node.js and JavaScript, Cucumber for infrastructure, and other quality testing against functional requirements. There's a number of really good tools out there that can help you do things like front-end testing, component testing, infrastructure testing. There's really no excuse for not testing every layer of your application architecture.
DevOps Technologies: Continuous Integration and Deployment

Next, let's look at continuous integration. Probably the one that most people think of, or a lot of people think of, when they think about DevOps. This is pretty much trying to make sure we're not doing all this integration at an end stage of a project. All those last minute integration problems that delay a project's release. Instead, how are we doing integration testing early and often? We want to constantly be building releases and testing them out to catch problems before they're released to production or before we have some massive code base we're trying to combine together. This matters to DevOps because it gives us fast feedback. If I'm checking into the mainline branch or master four or five times a day, all of a sudden I'm going to get fast feedback if something's broken. I'm not scouring days or months of code to look for a defect. I know it's just last commit that I can go check. So it helps us reduce defect waste. It reduces waiting waste because I'm taking code that's of good quality and knowing it's always production ready. You're familiar with many of these CI tools I bet. Things like Jenkins, CircleCI, Travis CI, the great Concourse tooling, and then the public clouds all offer something here. AWS has CodePipelines, Azure has Azure pipelines. There's all these tools that can talk to source code repositories, run the unit tests against that code, and then emit something to an artifact repository or even go all the way to production. So we've been continuously integrating our code, making sure that it's all working together with all the different pieces, and then you have continuous deployment; the idea of actually taking some of that source code and getting it into production. Deployment should be boring. You are good at DevOps. If your deployments are very boring, anyone can launch them, it's not a big deal. Something like these continuous deployment tools run through that whole deployment pipeline. They help make deployments more reliable, less scary. So why does this matter to DevOps? Well, I'm trying to limit any preproduction inventory. I'm not piling work up waiting for an annual or biannual release. I'm automating these steps. I'm getting these things to production. I'm getting value from the code we've written into our customer's hands as quickly as possible. Often by doing continuous deployment, I'm helping unify the team or I'm actually getting value to the customers because we all have to come together to build an enterprise-class deployment pipeline. Security teams, infrastructure teams, app development teams. All those have to work to make your app function on a pipeline. So it's a great unifying effort. What are examples here? Things like Spinnaker is a great took for actually doing continuous deployment and some intelligence on things like blue/green patterns and other ways to make sure I'm actually deploying safely. Octopus deploy, AWS has a CodeDeploy tool. A lot of good things that can actually do continuous delivery of your source code. Now you may use your continuous integration tool to also push to production, sometimes though, as teams evolve, they want separate tools because continuous integration is really focused on combining my code, running tests, and then continuous delivery tools and continuous deployment tools are really good about getting things to production, sometimes with some sophistication about how you role things forward, how do you do this with no downtime.
DevOps Technologies: Configuration Management

Now I'd probably be willing to bet that most people do think of configuration management tools when they think of DevOps. They think of things that equate to a server, and also in cloud services, but enforcing a certain state of an environment. So these sort of tools make sure that the server or a system stay in a certain state and return it to that state if it happens to drift. It uses automation to actually kind of configure these servers so people are not doing that. This helps you manage large sets of servers at scale. You're treating the infrastructure as code that can be source controlled and then deployed and configured. This matters to DevOps because it enforces consistency. It ensures that you have a repeatable process that's easy to audit, easy to check, and reduces manual toil. What are some of the tools you may see here? You may see things like Terraform from HashiCorp, open source tech that builds infrastructure for you in a repeatable way from a manifest that you can always check into source control. Technologies like Cloud Foundry BOSH that can build systems and manage those systems. And of course the popular things like Chef and Ansible and Puppet, which can set up server configurations and keep them in a good shape. And then again, public clouds can do some things. Google Cloud's Deployment Manager actually goes and build infrastructure. Azure Resource Manager and other things that help configure infrastructure at runtime for you. All of these are good technologies to make sure that you can just treat this infrastructure as a configurable automation-centric resource versus something that you manually handcraft, deploy, manage yourself. That's something that's not going to scale well and is prone to error.
DevOps Technologies: Cloud Platforms

The next layer of our stack looks at cloud platforms, and this could be a little controversial because I don't need to be using cloud platforms to be doing DevOps. I can do this with other platforms, but I think of API-enabled infrastructure, things that are making it easy to add automation to the infrastructure layer. All of these platforms, whether they're public clouds, private clouds, whatever they might be, is it's about API-drive self-service scalable things. This helps me build automation, helps me track and monitor these environments very easily so I can get feedback, and it helps me enable teams via self-service so they don't have to go open tickets to get infrastructure. They can call APIs. The consumption is metered so I can charge back if I need to. I'm decentralizing. I'm making it easier for other teams to use infrastructure and not have a blocker, or a bottleneck, or a constraint with my infrastructure team. What are some examples? Well of course there's major public clouds, clouds like Amazon Web Services, Microsoft Azure, Google Cloud Platform, Oracle, IBM, Alibaba. You have software platforms like Pivotal Cloud Foundry. You have things like Heroku. And then you have this whole class of container schedulers. You have things like Kubernetes, Docker Swarm, Nomad, these other technologies that are kind of a component of platforms, some treat them as such, but they're also API-enabled infrastructure layers, which are very powerful for people, who again, are trying to improve the flow. They're trying to make sure that infrastructure doesn't become the constraint.
DevOps Technologies: Monitoring and Logging

One of the areas that can potentially be something you overlook is monitoring and logging. You could automate all these certain steps, you could do all this great work, but if you're getting lousy telemetry, if you're not able to pinpoint things and recreate problems and figure out what's going on, you may be in a state where your DevOps work actually starts to slide backwards because teams are frustrated that they're taking on more responsibility, but not actually able to fix problems faster. So when you think of monitoring and logging tools, it's about seeing the health of the entire system. I'm trying to see inside out. I'm looking inside my system to see how healthy it is. Outside in to see what the end user's experience is. You can everything look great internally, but if it's very non-performant for your actual customer, that's actually what matters more. So when I think of monitoring and logging, it's about recovering faster, it's about being more responsive to my customer who's experiencing some sort of disruption, it's improving transparency, especially across teams who are trying to use this telemetry to figure things out, and it can help limit the human involvement during incidents because I can have systems that may be auto-recover, based on automated checks against logged data. So there's a lot of really important things about investing in monitoring and logging tools. A well-designed monitoring solution means operators aren't getting randomly paged, developers aren't stuck troubleshooting weird opaque issues, cloud environments can expand and contract without raising false alarms. What are examples here? We have the ELK Stack, the Elasticsearch, Logstash Kibana, set of technologies. You have things like Datadog and New Relic, Prometheus, Zipkin for distributed tracing, again, each public cloud does some great things here like Azure Monitor. So you are not experiencing any shortage of capabilities out here, it's about weaving these into your application stacks so that you have great transparency, great visibility, so when something does go wrong, and something will go wrong, you can quickly figure out the problem and get on with your day.
DevOps Technologies: Knowledge Sharing and Communication

Now one of those categories you may not think of is communication. So even though you're automating the stack, you're storing things in source control, you're continuously deploying them, being successful with DevOps is also about the team dynamic; so how well am I communicating? Am I using tools that are eliminating meetings and improving my developer productivity? Am I making sure all the teams communicate regularly with meaningful action, building that sort of trust that they're going to need later? So this matters to DevOps because I want to connect the teams together. I want to limit any waiting waste by having easy channels for everyone to connect to each other. I want to improve collaboration so that whether things are good or whether there's a crisis, the team works well together, they know how to play off each other. What are tools here? Well of course things like Slack, Microsoft Teams, using Google Hangouts, Zoom, Webex, all these different tools that can help people quickly connect, could even be good old fashioned email, but it's ways teams are able to connect, collaborate, have discussions, make decisions quickly, not wait for old legacy processes where we get together once a month and discuss things. Instead, it's about the customer. It's about throughput. It's about eliminating waiting waste, and that's going to happen when I have good communication tools that people want to use. The final major category in this particular model here is knowledge sharing. How are we thinking about actually making sure that our folks are saving information that others can find useful? This is all about, again, fast feedback so that teams can store the information they're learning so others can learn about it. It's when we learn new things that we're sharing it in ways that others can take advantage. We reduce that knowledge waste, things that keep us from absorbing it. Instead, replacing that, making sure more people can learn and cut through the noise. It increases new higher productivity. If I don't have to go walk around the floor and ask 50 people how to do my job, instead I can go to a centralized place and learn the core aspects of running this system. That's going to make all of your newly hired folks productive much quicker. And then I can limit repeat mistakes because I've documented the things we've done before, what we've learned from those postmortems and retrospectives, and I've done it in a way that prevents that process from being a problem again. What are some tools here? I might use things like GitHub Pages, storing some historical information. I might use Confluence or Jekyll for static sites to store my information, the things we're learning as a team, maybe a wiki, things like that, Google Sites, any sort of place where we're all empowered to add to it. There's not one gatekeeper, but there's a way to add, organize, and discover this sort of information so everyone is getting smarter, I don't have any sort of lone geniuses on the team, and instead we're in this mode of all constantly learning together and documenting that learning.
Summary

So we looked at that whole DevOps toolchain over the course of this module. We looked at all these different categories that come together to collectively help you do DevOps. Any one of these is helpful, but all of these I would argue are required for you to be in this place where you are continuously delivering value to the customer in a way that's sustainable to the team, as well as helping you differentiate. Sometimes we're all quick to jump to the technologies of DevOps when we start studying this space. It's important to know the other parts, but we don't want to leave out the technology, so we started off this module by preparing for what we were going to cover and doing an overview. We looked at the overall DevOps toolchain before jumping into each piece; things like planning tools, the issue-tracking tools, source control management, building and testing your code and being successful with that, continuously integrating and deploying your source code, managing configurations, using cloud platforms, and then monitoring and logging before doing some of the softer things like communication and knowledge sharing. I hope you enjoyed this course. DevOps is an exciting way to work. It's not going to be the only way or even the best way. Something better may come along in the future, but for right now it seems to represent a good way for teams to collectively work together to ship value that matters in a way that's sustainable for the people on the team, while also helping them focus on the customer, not on IT efficiency, not just on internal things, but actually on speed, on learning, on the things that actually matter as companies are differentiating now based on how good they are at technology. Thank you for listening to this. You can always find me on twitter at @rseroter. I hope you enjoyed the course, and I would love to hear some feedback. Thank you.
Course author
Author: Richard Seroter
Richard Seroter

Richard Seroter is the VP of Product Marketing at Pivotal, with a master’s degree in Engineering from the University of Colorado. He’s also an 11-time Microsoft MVP for cloud, an instructor for...
Course info
Level
Beginner
Rating
4.1 stars with 1113 raters(1113)
My rating
null stars
Duration
1h 21m
Updated
23 Jan 2019
Share course
