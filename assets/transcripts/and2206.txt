Android Animations
by Sriyank Siddhartha

Enhance the user experience of your Android applications by applying animations to your apps.

Animations add a polished look to your application, which gives it a higher quality look and feel. They are especially useful when the UI changes state, such as when new content loads or new actions become available. In this course, Android Animations, you will learn foundational concepts of how to use animations in your app in the most effective way. First, you'll learn core animation APIs such as property animations. Next, you'll discover applying animation to drawables. Finally, you will explore how to use transitions API to animate between layouts and activities. When you're finished with this course, you will have skills and knowledge of using animations needed to enhance app user experience.

Course author
Author: Sriyank Siddhartha	
Sriyank Siddhartha
Sriyank is a passionate software developer and loves to share his knowledge through his blogs and video courses. He follows "share and gain" principle which led him to publish many courses online....

Course info
Level
Intermediate
Rating
0 stars with 8 raters
My rating
null stars

Duration
2h 16m
Released
25 Mar 2019
Share course

Course Overview
Course Overview
Hi, this is Sriyank Siddhartha, and welcome to my course of Android Animations. I am a freelance Android developer and trainer with several years of experience in the field of Android development. Animations can add visual cues that notify users about what is going on in your application. They are especially useful when the UI changes state, such as when a new content loads or new actions become available. Animations also add a polished look to your application, which gives it a higher quality look and feel. Well, Android includes different animation animation APIs depending on what type of animation you want, so this course covers all of the important animation APIs found in Android. Some of the major topics that we will cover include exploring property animation APIs, how to apply multiple animations on UI elements, applying transitions between layouts using Transition API, apply transition between activities, and finally, learn to animate drawables by using animated vector drawables. By the end of this course, you will know how to apply animations to your applications. Before starting the course, you should be familiar with using Android Studio, the basics of Android application development, also just the basics and syntax of the Kotlin programming language. So I hope you will join me on this journey to learn animations in Android, only at Pluralsight. See you in the course.

Getting Started with Android Animations
Welcome
Hi, this is Sriyank Siddhartha, and welcome to the course of Android Animations. In order to provide the best user experience, animations becomes the most important aspect of application development. As a developer, we all have come across the importance of using animations in our projects in one way or another. Imagine an application without animation. It doesn't really matter if your application is loaded with different functionalities, if it doesn't contain animations, in no time your user will start using applications of your competitor. All your hard work will go in vain. So animations provide a polished look to your application. A famous designer, Frank Chimero, has rightly said, if you ignore what your user needs, your user will eventually ignore you. Any aspect of a website, application or software that does not consider the user's need is ultimately doomed to fail, so in this course we will explore all the basics and fundamentals of using animations to deliver or improve the user experience.

Evolution of Animation APIs
We all need to evolve with time. The same happened with animations API. Since the evolution of Android, we have come a very long way. When Android was just born, we could view animations API in API level 1, which is the oldest API among animations API. Soon after that we got property animations API such as ValueAnimator and ObjectAnimator. Using this API, you can animate any object values over time. Thereafter, in API 12, we got ViewPropertyAnimator. This class is, again, a part of property animation, but target only view objects. In API 19, we got a wonderful transition API, which was a major breakthrough in the world of Android animations. It provided seamless transitions between layouts and screens. Next, in API 21, that is Android Lollipop, we got Animated Vector Drawable. which was proved to be a great way to animate drawables and vectors in Android. Right now we also have APIs like Physics Based Animations and Motion Layout. Both of them are now a part of AndroidX library. Well, by the time you're watching this video, there might be more APIs that can be added to this timeline, but those won't have any impact on this course because our objective is to get an understanding of animations and get you started with it. Initially in this course we will explore property animations API, which includes ValueAnimator, ObjectAnimator, and ViewPropertyAnimator. Well, there are more classes in this API, but these are the important ones. Moving on, we will explore how to animate drawables such as by using animated vector drawables. Thereafter, we will dive into transitions API and explore how to apply animation between layouts and different activities. Other topics such as physics-based animation and motion layout are beyond this course objective. They are quite broad topics, and should be covered in a separate intermediate course. Now, what about this view animation? Why I have just ignored this? Well, for this let us classify Android animation API based on animation resources. An animation resource can define one of two types of animations. The first one here is the view animation itself and the second one is the property animation which we got in API 11. The view animation can further be classified into tween animation and frame animation. Well, the view animation is the oldest animation API in Android. At the time of recording this video, officially it is not yet deprecated, but tactically you can consider it deprecated. What you can achieve using tween animation, which comes under view animation, can be achieved by using property animation API. Since property animation is new and more powerful, so it is highly recommended to use property animation wherever possible in place of view animation, so that is why in this course we will save some time by ignoring this tween animation. Now frame animation, which is also known as drawable animation, is a part of view animation framework. It has some use case as well, which we are going to cover in this course.

How to Follow Demo Videos?
This is a hands-on course. Throughout the course, we will learn animation by going through various demo videos. To make the most out of this course, I highly recommend you to follow along with me. You can pause the demo video while watching and type code yourself. To make your life easy, kindly download the exercise files of this course. You can find them in exercise files tab on the landing page of this course. Once you do it, you will find exercise files for each of the modules. For example, this module contains a demo folder which further contains before and after projects. Well, before is the starting point of this module, and after is the end result of the demo application which you will create in the end of the module. Along with this, you will find some helper files. Well, these folders contain some code snippets, or supporting files, you can say, which I will ask you to import in your project at the very beginning of the demo video. So first things first, make sure you download these files now.

Initial Project Setup
Before we can start our demo from the next module, let us set up our basic Android project, on top of which we can code the next module. So firstly, launch your Android Studio, and make sure you are using the updated version. Once you do it, create a new project, create an empty activity, provide the application name as AnimationsDemo. Make sure you have the package name as com.sriyank .animationsdemo. Make sure you enter the same package name as it is here so that it will be easy for you to follow along with me. Select your project location of your own choice. For this course, I'm going to use Kotlin as the language, and right now I'm going to use minimum API level as API 21. That is Android Lollipop. That covers approximately 85% of the active devices. Once you are done, click on Finish. Once your project is created, launch your application in your emulator. For this course, I will be using emulator running an API 26, that is Android Audio. If you want, you can use emulator of your own choice, just make sure the API level of the emulator should be above API 21. If you have made it this far, then you are done with your initial project setup, so that is all for this module. In the next module, let us start with our property animations.

Working with Property Animations
Overview
Hi, this is Sriyank Siddhartha, and welcome to the next module where we will start using animations in Android. In this module, we will talk about property animations. Now most of the property animation APIs are found in android.animation package. While using the APIs found in this package, you can animate anything, everything. You can animate views such as button or text view, and even non-view objects. The very basic property animation class that you will find in this API is the Animator class. Normally we do not use this class directly, as it provides minimal functionality. The subclass of Animator is the ValueAnimator. Let us talk a little bit about ValueAnimator. Well, this class computes the values for an animator over a given duration. The values could be float, int, or even eRGB color values. So once you get the computed values, you can use it to update the property of an object over time. However, to do that you need to use AnimatorUpdateListener interface and write your own logic to apply animation to the view, which is painful if you want to apply a very simple animation. You can call it as a limitation of ValueAnimator. To overcome this limitation, we have ObjectAnimator, which is a subclass of the ValueAnimator. Well, this class holds a great importance in the animation API, so let us talk a little bit about this class. Similar to ValueAnimator, this class computes the values and modifies the property of the object over time, but here the animated values updates automatically, which means you no longer need to use the AnimatorUpdateListener interface and write your own logic manually. Now most of the time you will be using ObjectAnimator class to animate some views. Now you can implement property animation in two different ways. The first is by using XML resources. For that, you need to store animation files within resource animator directory. The second way is just from code. In this case, we did not use animation files from the resource directory, so one by one let us explore them.

XY-coordinate System in Android
Before we proceed further, I would like to walk you through how XY-coordinates system are defined in Android, and how it is different from what we see in mathematics in general. Assuming this is our Android device screen, now the center point, that is the origin of XY-coordinate in Android, lies in the top left edge of the screen, like this. If you move to the right, you will find the positive X axis. Moving left to origin, you will find negative X axis of course. Well, the X axis looks quite similar to what we know already, but when it comes to Y axis things are very different. If you move down, you will find positive Y axis, and moving up from the origin we we will have negative Y axis. Well, it is totally opposite to what we see in mathematics in general. So always remember this thing, moving down the screen, you will find positive Y axis. And this coordinate system is very important, and we will utilize it as we move ahead with this course.

Elements Performing Property Animation
Under property animation we have several basic animations that allow us to animate views. Let us explore a few basic animations which you can perform using XML resources. Alpha animation is one of the basic property animation. It is also known as fade-in or fade-out animation. Here I will write a very simple code where a view will fade out in just 0.5 seconds. So within your XML file, you can use objectAnimator tag and define some properties. Property name defines what kind of animation you want to apply. In this case, it is alpha animation. ValueFrom and valueTo determines the starting opacity and the ending opacity of the view. Right now it is in floating value. Opacity of 1.0 means opaque. Opacity of 0.0 means transparent. Now any value in between these two means a view is translucent, that is partially opaque. Next is the valueType. That specifies what kind of value you want to animate over time. So based on these two values, which are of floating type, we have the value as floatType here. Now apart from floatType, you can also support intType, pathType, and colorType values. Now duration is always in milliseconds. So here the duration of our animation is 0.5 seconds. If you run this animation on a view, the view will fade out in 0.5 seconds. Pretty simple, isn't it? Now moving on, let us see an example of the scale animation. As the name indicates, this animation allows you to scale a view up or down. That is why it is also known as the resizing animation. Here I will show you an example that will scale above you to 1.5 times horizontally pivoted at its own center. Now what exactly I mean by a pivot point? Well, pivot point is also known as the fixed point, and by default, the pivot point lies at the center of the image, so 50% along the X axis and 50% along the Y axis. Evaluating these two together, our pivot point comes out to be here at center. Now to implement scale animation, you again need to use the objectAnimator tag. Thereafter, define some attributes. The property name here is scaleX, which means the image will scale horizontally. This is a starting position, which is its original dimension. The ending value is 1.5, which means the image will scale 1.5 times its original dimension. This is a valueType, and here is the duration of the animation in milliseconds. If you run this animation, you will find that your view will scale up to 1.5 times in 1.5 seconds with the fixed point at the center along the X axis. How simple is that? Also note that if you want to perform the scale animation along the Y axis, then use scaleY as the property name. Next is the translate animation that allow views to move horizontally, vertically, or even diagonally. So here I will define the animation that makes a view to move 500 pixels horizontally in the positive X axis. So within our objectAnimator tag, we can define property name as translationX. Now if you want translation along the Y axis, then you can use the property name as translationY. Then we have valueFrom as the starting position, where 0 represents the original position, value 2 is the ending position. Make a note that here we are using the positive value. Using the negative value will move the view in negative X axis. So accordingly, here our animation will look like this. Moving on, we have the rotate animation, which of course, allow you to rotate a view. In this example, we will rotate a view 180 degrees clockwise in just 1 second. So within objectAnimator tag you can use the property name as rotation, starting position in degrees. Here 0 means original position, ending position, again, in degrees. A positive value here will rotate the view in clockwise direction, but in case if you want your view to rotate anti-clockwise, then use a negative value such as -180 degree. Now note that by default the pivot point lies at center, so if you try this you will get animation like this. And in case if you just want rotation along along the X axis, then use rotationX as property name. Similarly, for Y axis use rotationY. Quite simple, isn't it? Now summarizing all the property names at one place, in this video first we saw alpha animation, then we saw rotate animation where you can use these property names as per your requirement. Then we have these properties for scale animation, and these two properties for translate animation. Now apart from all of these we also have properties such as pivotX and pivotY that allows you to change the pivot point of a view. Well, by default the pivot point lies in the center, so you can change it using these two properties. Finally, we have X and Y properties. Well, these two properties describes the final location of the view with respect to its immediate parent layout, within which it is present. So that's all for this video. In the next video, we will see some code in action.

Implementing Property Animation through XML Resource
In this video, I will show you how to implement property animation using XML resources file. We will explore alpha, scale, translate, and rotate animation. So here we are within our same application that we created in our previous module. Before we start, move to the exercise file of this module where within the demos folder you will find helper-files 1. Now just copy this animator directory and paste it within your resource folder. Add this image to your driver folder, and accordingly update your activity_main.xml, strings.xml, also MainActivity.kt file. Once you are done, your activity_main.xml will appear to be like this. It contains an ImageView in the center and four buttons at the bottom to perform four different animations. Note that these animations can be applied to any object, including the views found in your application. For example, you can apply the property animation to the TextView, Button, RecyclerView, as well as the Switch. Right now I will use ImageView for this demo. Now on click of these buttons, the corresponding methods present within the MainActivity will be executed, such as rotateAnimation, scaleAnimation, translateAnimation, also the fadeAnimation. Now within the resource folder we have animator directory, which contains four different kind of animations. So let us explore our alpha animation. Well, the name of the animation is alpha animation, which will last for 1.5 seconds. Well, this animation will start from opaque, and slowly within 1.5 seconds it will become transparent, that is, it is a fade-out animation. Based on the type of value that we are supplying here, we have provided the valueType as the floatType. Now to apply this animation, you need to write some code. So within our MainActivity, within the function of fadeAnimation, we are using AnimatorInflator class. Using AnimatorInflator class, you can use the static function of loadAnimator that accepts the first parameter as the context of this current activity, and the second parameter as the reference to our animator file, which we have defined here. And this function of loadAnimator returns the reference of the animator object. Let's call it fadeAnimator. Then you can set the target object on which you want to apply the animation. In this case I want to apply animation to my targetImage, which is the ID of the image which we have defined here. And then finally you can start the animation. And that is it. You are good to go. Now here if you notice, there is some repetition of the same variable. Well, we are using Kotlin, right, so why don't we take advantage of the Kotlin feature such as the apply function. That is why I have started loving Kotlin. Do more with less code. Now similar to the fadeAnimation, I have written the code for other animation in the same pattern, such as the translateAnimation, scaleAnimation, and also rotateAnimation. The code pattern is exactly the same. So let us test our fadeAnimation first. Click on the FADE button. So here we go our image faded out in 1.5 seconds. Now you can also apply the reverse animation on the same object. For that, within your XML file of alpha, you can use the attribute of repeatMode whose default value is restart. Well restart means that it will just repeat the same animation again. But if we change it to reverse, then it means that it will perform the reverse animation from this ending value to the starting value. Along with this, you need to add another attribute of repeatCount and provide the value as 1. If you make it 2, then in that case the animation will be repeated twice. For now, let's keep it 1. Run the application, click on the FADE button, yes, our object faded out, and soon after that the reverse animation was performed where our object faded in. How cool is that? Moving on, let us explore our rotateAnimation, where we have the property name as rotation, duration as 1 second, starting position as 0 degrees, which is the original position, then ending value is -180 degrees, which means our object will rotate in anti-clockwise direction. If you make it positive, then our object will rotate in clockwise direction. Thereafter, we have written our attributes to perform the reverse animation. Now if you want to rotate your object just along the X axis, so in that case you can use rotationX as a property name. For the Y axis, you can use rotationY. Let us try this animation. Click on the ROTATE button. So here we go, our view rotated in the anti-clockwise direction, and also we saw the reverse animation. Similarly, we have the scaleAnimation. Here we will scale our view along the X axis horizontally over the duration of 1 second. The starting position will be its original dimension and the ending position will be three times the original dimension. Thereafter, we are performing the reverse animation. If you try this animation, then you will find some weird asymmetrical expansion in the horizontal axis. So if you want to apply animation symmetrically, so in that case you have to apply animation vertically at the same time. To do that, you have to apply some trick here. You need to use another object animator and just change the scaleX to scaleY. Now when you want to apply two animators on the object at the same time, then you need to group it within the set tag, and this set tag represents the animator set. So if you try the scale animation now, you will find the symmetrical expansion. Proceeding, we have the translate animation. Let us just focus on this objectAnimator. Here I want to move my object along the X axis from its original position to 200 pixels on the right. Now, at the same time I want to apply other animator, which translates the object in the positive Y axis. Also note that we are grouping these two animators within our set element, so 200 pixels along the positive X axis and 200 pixels along the positive Y axis. As a result, our object will move diagonally. Let us try it out. Click on the TRANSLATE button. So here we go, our object moved diagonally. So this is how you apply the property animation on an object using XML resources.

Listening to Animation Events
Sometimes you might want to listen to the event during an ongoing animation. For that we have Animator.AnimatorListener interface. This interface contains three abstract methods. The first one is onAnimationStart function, which is executed when the animation starts. Next we have onAnimationEnd function, which is executed when the animation ends. Note that this callback is not executed for animations whose repeat count is set to infinite. Next we have onAnimationRepeat function, which, of course, is executed when the animation repeats itself. Finally, we have onAnimationCancel function, which is executed when the animation is cancelled. Also note that a cancelled animation triggers execution of onAnimationEnd function regardless of how they were ended. To see the code in action within your application, again, navigate to the exercise file of this course. Within your current module, you will find helper-files-2. Just copy the MainActivity and replace the current one. Once you do it, you will find the implementation of this interface in your MainActivity, and down below you will find the implementation of all the abstract methods, and accordingly, in each of these functions, I have written some Toast messages. Now to execute these functions, you need to add a listener on all of these ongoing animations. For example, for the rotateAnimation you can use addListener function and pass the context of this activity. Or you might want to use this function straightaway within your apply function, like this. Similarly, register the listener for other animations as well. So here are the changes. Let us now run our application, click on any of the animation, and here we go, animation started, repeated, and after that ended. Similarly, click on translate animation. Again, the same toast messages in sequence. Now during this, if you notice, one callback function was not executed, which is onAnimationCancel. Well this function will only be executed if you try to cancel the animation by calling animator.cancel function. And, of course, calling this function from here doesn't make any sense, so let us comment this. Also note that onAnimationRepeat function is getting executed just because of repeatCount attribute, which we have placed within our objectAnimator tag in all the animation. If you remove it, then onAnimationRepeat function won't be executed. Now moving forward, if you notice, the Toast messages are getting executed on click of any of these animations. So how can we distinguish or differentiate between all those animations within these callbacks? Well, for that we can take advantage of this parameter of animation, which is of the type of animator, but before that let us make all of these local variables as a property of our class so that we can access them within our callback functions. So on the top, let us declare those variables. Once we are done, remove the val keyword from these reference variables, and apply the save call variable required. like this. Now within our callback of onAnimationStart, we can use if the animation is scaleAnimator, then show Scale Animation started. Similarly, for other animation let us do the same thing. So these are the changes. Quite simple. Well, similarly for the other callbacks you can use the same parameter of animation and differentiate between all the animations in the same way. If you run the application and start any animation, then you will find a specific Toast message, Rotation Animation Started. Similarly, for translate animation it will show Translate Animation Started. How cool is that? Now for this demo, we were using objectAnimator, but in case if you decide to use ValueAnimator class, which is a super class of objectAnimator, then you need to use a special interface of ValueAnimator.AnimatorUpdateListener. Well, this interface contains the abstract method of onAnimationUpdate, which is executed on every frame of the animation, and you can listen to this event to use the calculated values generated by ValueAnimator class during the animation. So this is how we use listeners for our animation.

Building Property Animation from Code
So far we have implemented property animation using XML resource files. You can also implement property animations just from code, that is, without using XML files. Now before we start, I want you to navigate to helper-files-3 of this module, and just update your MainActivity.kt file. Once you are done, you will find some changes in this file. I have updated the objectType of these animators. Now the objective of this video is not to use these animation files present within the animator folder. So let us start with our fadeAnimation. To implement animation just from code, you need to use objectAnimator class followed by a static function. Well, there are several static functions. The important ones are ofArgb, ofFloat, ofInt, and ofObject. Now to understand things better, let us open our alpha animation file on the right. So here, if you notice, we are using the values as the float value. Since we are using the floating values. So here you have to use the function of ofFloat, which expects the first parameter as the target object, which is our Image view, here. The second parameter is the type of animation you want to apply, so in our case it is alpha animation. Next, the third parameter is a set of values that the animation will animate between over time. So these are the two values in sequence, so I will use these two values separated by a comma. Now since we have defined our targetImage here, so we can now remove this statement. Next, let us set the duration by using the duration property in milliseconds. Set the repeatCount as 1. Then we have repeatMode as reverse. So for that we can use the property of repeatMode equal to use the class of valueAnimator. the integer constant of REVERSE. So now we have all of these properties here in code. If you understand how we define properties for fade animation, then you can easily understand the code defined for the translate animation where the code is already in place. Note that here we are performing the translate animation only along the X axis where it will move 200 pixels onto the right. Then we are setting the duration, repeatCount and repeatMode. Now let us open our translate.xml. Well, in our XML file we are performing translation diagonally by applying translation along the X axis, as well as Y axis, and grouping them together within the set tag. Now the question arises, how can we use this animator set in code? Well, for that you need to wait a little. We will explore it later in our upcoming module. So right now I have just mapped the code for translation along the X axis. Now moving on, we have the scale animation. Here we are scaling our object along the X axis, and the final dimension will be three times its original, and these are the other attributes. Similarly, we have the rotate animation where the code is, again, self-explanatory. Now, the rest of the code down below for the animator listener remains the same. Also, in the end I just forgot to remove this val keyword from the fadeAnimator. Let us now try running our application. So this is the rotate animation, then translate animation, fade animation, and in the end we have the scale animation, which looks pretty weird as it is only scaling in the horizontal X axis. Well, don't worry, we will rectify this animation when we learn about animator set in our upcoming module. So this is how we implement property animation just from code. So that is all for this video.

Up Next?
So far in this module we have covered how to implement basic property and images in Android. Now, coming up next, we will explore how to animate multi properties on the same object using various other classes of this API. So basically we will continue our discussion on property animation in the next module as well. So thanks for watching and see you all in the next module.

Choreographing Animations
Overview
Hi, this is Sriyank Siddhartha, and welcome to the next module of this course. Now while applying animations in many cases, you want to play an animation that depends on when another animation starts or finishes. In simple words, for example, you might want animation B to run after animation A, or you might want animation A to run simultaneously with animation B. Well, property animation API provides various classes for that. One of the most commonly used class is AnimatorSet, which is a subclass of Animator. Using AnimatorSet, you can define the sequence in which multiple animations will be played. Now there might be situations where you only want your animations to run at the same time, that is, in parallel, so for that we have a class of ViewPropertyAnimator. Well, this class is backed by ValueAnimator, which means it is not a subclass of ValueAnimator, but using this class you can animate views. And trust me, ViewPropertyAnimator is more efficient than animating views using ObjectAnimator or ValueAnimator. Now moving on, similar to ViewPropertyAnimator there exists a class of PropertyValuesHolder. Again, this class is not a subclass of Animator, but when you use this class you need to use it in conjunction with ValueAnimator. You can also use this class with ObjectAnimator. So one by one, let us see how to animate things using these classes.

Using AnimatorSet from XML Resources
So let us start our discussion with AnimatorSet. Well, as mentioned earlier, using AnimatorSet you can apply multiple animations on an object. Now since AnimatorSet is a part of property animations API, so you can implement it in two different ways. The first will be by using XML resources, and second will be, of course, from code. So in this video, let us see how to use it in XML resources. In the previous module, we already got a sneak peek of how to use AnimatorSet in Android. In this video, let us explore more on it. Before you start, just update your ActivityMain.xml and MainActivity.kt file from helper-files-1 of this module. And also, add the set.xml with an animator directory. Once done, within your MainActivity you will find a very familiar code to load animation. Here we will load animation present within our set.xml, which is present here. And then apply the animation on our target, which is our targetImage. Thereafter, start the animation. In our scale animation in our previous module, we used a set tag. Well, this set tag is an XML representation of an emitter set. So moving on, within our set.xml we have similar kind of code with some minor changes. Now within the set tag you can actually add another set tag, and of course you can add as many objects and emitters as per your need. Now within our AnimatorSet, you can add the attribute known as ordering, whose default value is together, which means these two objectAnimators will play simultaneously at the same time. Now if you change it to sequentially, then let's see what happens. On performing this animation, you will find first our image was scaled along the X axis and then along the Y axis, which means these two animators were executed one after the other in sequence. So let us revert it together, which made more sense. Moving on, suppose we want our target view to first show the flip animation followed by the scale animation, so in that case we can wrap this whole set within another set tag, like this, and then put this schema here within our parent set tag, and accordingly, format the code. And immediately within this parent set, I will now define the animator to perform the flip animation, which will be the rotate animation along the X axis. So here is the code for that where I am rotating along the X axis. Also, let us add ordering of the set as sequential so that first we are going to see the flip animation, and then the scale animation. Run the application, let us try this animation. Well, you will find some flip animation followed by the scale animation, but our animation is a little slow. So let us modify the duration and try the animation again. Much better. So in this way you can use AnimatorSet to apply multiple animations on the same object.

Using AnimatorSet from Code
Now moving on, let us see how to implement AnimatorSet in code. Here in our application I am within my MainActivity. Down below within this file, you will find a button click event handler. Here I will paste some code, which you can get from helper-files-2 of this module. Once you do it, open your set.xml. To understand things better, I have just mapped all of this code present within our set.xml in our MainActivity.kt file. So let me explain to you what I have done here. For a moment, within our set.xml, just look at these tags independently. First, as a root tag we have AnimatorSet element. So onto the left I have defined the same set element as AnimatorSet in code, which I have named as rootSet. Now moving down in the hierarchy, we have objectAnimator for flip animation, so accordingly, we have flip animation defined here. Then we have another set element, which again, I have defined here in code as childSet. Moving on, within our childSet we have two objectAnimators, one for scale animation along the X axis and another for the Y axis, so accordingly, I have defined a scale animation for X and Y axis respectively. Now once all of these elements are defined in code, our final step will be to implement these orderings, that is, either sequentially or together. Well, firstly I want this animator to play sequentially with this AnimatorSet, and remember, these two are the part of our rootSet present here. So in code I will use rootSet.playSequentially function, and pass flip animation and childSet as a parameter, separated by a comma. Then I want these two animators to play together as a part of this childSet. So here in your code you can use childSet.playTogether function, and pass child elements as scaleX and scaleY. Pretty awesome. Finally, start the animation. Let's try the animation, click on this button, cool, as expected. Now alternatively you can perform the same animation by using the concept of method chaining, rootSet.play the flip animation before the childSet, then for the childSet play scaleX along with scaleY together. So here you can take advantage of functions like play, before, and with function to do the same thing which we are doing here. Along with these three functions, there exists the after function that can accept our duration in milliseconds to delay the animation or you can pass another animator object, after which you want your animation to play. So right now we don't need it. Try running the application, click on the button, works like a charm. So using AnimatorSet from code was quite easy. That's all for this video.

Adding Interpolators
Let us now take a look at what are interpolators in Android, and what role they play in animation. Well, an interpolator defines rate of change in animated values as a function of time. It basically allows you to add various effects to your animation such as acceleration, deceleration, and there are many more. And these are the list of interpolators which you can use to add different kind of effects to your animation. So within our application within set.xml, let us add interpolator to these two animators. First I will use bounce_interpolator for this animator, and use the same interpolator here as well. Also, I will modify the duration and valueTo attribute so as to see the applied changes with more clarity. Let us now run our application, click on this button. So here, if you notice, while applying the scale animation we had some bounce effect. Now apart from bounce_interpolator, you can try other interpolators as well, such as overshoot_interpolator, anticipate_interpolator, accelerate, decelerate_interpolator, and there are many more. Right now, let us try to use this overshoot_interpolator. Here, as well, let us change it to overshoot_interpolator. Click on this button. Now this time, if you notice, our animation exceeded its final animated value, and soon after that it came back to its defined size. So in this way in your application you can try other interpolators and see what they do. You can also apply interpolators in code. For that, on your animator you can use interpolator property, and instantiate the interpolator you want to apply, such as, in this case I am applying the bounce_interpolator. In a similar way, you can apply the overshoot_interpolator as well. For scaleY animator, you can use the same syntax. So this was all about interpolators in Android.

Implementing ViewPropertyAnimator
It is now time to talk about ViewPropertyAnimator. As mentioned earlier, this class allows you to run animations only in parallel. Also, you might ask a question, which is more efficient, using ViewPropertyAnimator or using ObjectAnimator with AnimatorSet? Well, the answer is ViewPropertyAnimator because this class is specially designed to animate just views. So use it in place of ObjectAnimator where it is required. Similar to ObjectAnimator, ViewPropertyAnimator is also used to animate view objects. Well this class allows you to run animations simultaneously all at the same time, that is, unlike what we saw in case of AnimatorSet, you cannot define the ordering of the animation. All the animations will run at the same time. Well, you can use it if you want to animate multiple properties of a view object at the same time. Now if in case you want to apply just one or two animations on your view object, then simply use ObjectAnimator. This class also provides short and convenient syntax to animate views, so this might be another reason to use it for animation. To get the reference to your ViewPropertyAnimator object, you need to call animate function on the view object on which you want to apply animation. So before we start, make sure you update your MainActivity.kt file, as well as ActivityMain.xml, from helper-files-3 of this module. Once you are done, within your MainActivity, at the bottom you will find this function of button event click handler. On our targetImage, let us call animate function. This will return reference to the ViewPropertyAnimator object. Using this object, you can start adding properties. Set the duration. Let us perform the flip animation, perform scale animation along X and Y axis, then add interpolator of your own choice. And finally, start the animation. And I guess this should be scaleY. Let us now run our application, click on this button, pretty awesome. Note that these three animations of rotation, scaleX, and scaleY, were executed at the same time, that is, simultaneously. And all of these three animations were executed for just one second. Now if you want you can also add more animations to it such as translationX and alpha animation. So now these five animations will run at the same time. So, in short, using this class of ViewPropertyAnimator, you cannot define the ordering of animation, unlike what we did in case of AnimatorSet where we declared the ordering of animations using before or with function. Also, you will find the code for ViewPropertyAnimator very short and convenient, so I hope now you know when you should use ViewPropertyAnimator to apply animations. So that's all for this video.

Using PropertyValuesHolder
In this video we will talk about PropertValuesHolder. Well, PropertyValuesHolder and ViewPropertyAnimator has one thing in common. They both perform multiple animations in parallel. But in case of PropertyValuesHolder, additionally you need to use either ObjectAnimator or ValueAnimator to perform animation. Here we are within our application. Before we start, just update your Main Activity and ActivityMain.xml from helper-files-4 of this module. Once you do it, down below you will find a button click event handler. Now in this demo I will perform the same animation what we have done here using PropertyValuesHolder and ObjectAnimator. So in this function, first let us define our flip animation. So here this ofFloat function simply returns the instance of PropertyValuesHolder. Similarly, let us define scaleX and scaleY animation. Once you are done, you can use ObjectAnimator.ofPropertyValuesHolder function and pass targetImage as a first parameter, and then pass these animations as the further parameters. Finally on this ObjectAnimator you can set the duration, interpolator, and call start function to execute the animation. Now notice here that all the properties which we have defined here exactly match with what we did in our previous video, just that the syntax is a bit different and the classes are different. So let us now launch our application. Click on this button. So here, again, our animation is executed parallel. Now in the end you might ask this function and this function are performing the same animations, so what is the difference, and which one to prefer? Well, in case of ViewPropertyAnimator, you don't have much control over the animation because it is nowhere linked to ObjectAnimator, so you cannot use any AnimatorListener and coordinate the animation events. So using this you can just perform simple animation. But in case of PropertyValuesHolder, since we are using ObjectAnimator, so it gives you better control over animation events. You can use AnimatorListener and control any event of your animation. So that's all for this video.

Summary and Conclusion
Well, in this module, and in the previous module, we have talked a lot about property animations API. We have covered a lot of simple examples to animate things. When looking at all of these classes, you might ask when to use what animator. Well, you can use ObjectAnimator as a general purpose animator. If you have any property to animate, then go for this animator. ValueAnimator, on the other hand, is used to perform custom animations. Use it in the case where you want to animate a value and then apply that value to some of your UI elements. Next is the ViewPropertyAnimator. This class is best to use when you have multiple view properties to animate simultaneously on the same view. And also, you don't have much control over the animation events, so use it for simple animations. Next we have PropertyValuesHolder. Using this class, you can define multiple properties and animate them using an ObjectAnimator. Well, since you are using ObjectAnimator, you have better control over animations as compared to ViewPropertyAnimator. Finally, we have AnimatorSet, which is very powerful, and you can define complex animations with ease. Animations are good, but using too many animations can have negative impact on performance of your application because animators that update the UI cause extra rendering work in your main UI thread. For this reason, use animations wisely. Avoid using resource intensive or unnecessary animations. So, yes, that's all for this module. In the next module, we will talk about how to animate drawables in Android, so see you all in the next module. Thank you.

Animating Drawables
Overview and Prerequisites
Hi, this is Sriyank Siddhartha, and welcome to the next module of this course. Sometimes in Android, we need to apply animations to drawable images on screen. So in this module, I will show you how to apply animations to drawables. So before we proceed, what exactly is drawable in Android? Well, anything that can be drawn on the screen is a drawable in Android. The simplest example of drawable would be an image file, and that image file can be in the form of png, jpg, or gif format. In Android, you can animate these drawables in two different ways. The first way is to use an animation drawable. This allows you to specify several starting drawable files that will be displayed one at a time to create an animation. You can also call it as frame animation where the animation is created with a sequence of different images played in order, just like a roll of film. Well, this frame animation is a kind of view animation which we saw earlier in this slide. The second option is to use an animated vector drawable, which lets you animate the properties of a vector drawable, which is another kind of drawable in Android. Well, there might be a possibility that the whole vector and animated vector drawable is new to you, but the course objective is to talk about just animations in Android. So if you have little or no idea regarding vectors or animated vectors, then you might want to go through this documentation of vector drawables. Also, we have this article on how to apply animation on vectors by Alex Lockwood. This article also talks about the vector path commands that are used to draw a vector. So basically this article has everything you need to know about the subject, and of course, there are dozens of articles on Medium that talk about vectors and animated vectors. Trust me, they all are super informative.

AnimationDrawable: Frame Animation
Let me first show you the example of the frame animation, how it looks like. Now in frame animation, you play the images in sequence like a roll of film. For example, if you run these images in sequence, it will appear to the user like this. It looks quite interesting, isn't it? So let's see how to implement this. So here I am within my same application that we were using in our previous module. I will do some changes to my application. Go to the helper-files-1 of this module. From there, update your Main Activity, along with activity_main.xml. Once you do it, your activity_main.xml will appear to be like this. It will have an image view along with a button. And your activity file will just contain a button click event handler. Now our first step will be to collect all the images to be used in the animation within this drawable folder. So I will right-click, go to New, select Vector Asset Studio. Well, here I'm going to use vector drawables for this animation. Well, as a beginner, you might ask, what exactly is a vector drawable? Well, vectors are a huge topic in itself, but in simple words, you can define vector drawables as lightweight scalable bitmaps, or you can see lightweight image files. Well, instead of vector files, you can use png or jpg files as well. It is totally up to your choice, but remember, whenever you use bitmaps, always give first priority to vector graphics wherever possible, because vector graphics are very efficient in terms of memory and performance. So here I will go ahead and look for the battery icons. Well, I am going to show you the animation that appears in your phone when the battery starts to charge. So one by one, I will add these seven icons to my drawable folder. So let us select my first icon and rename the file to battery_charging_0. Once you do it, click on Next and add it. So here this is my file with a root tag of vector with some width and height. Within the path tag, you will find the path data. Well, this attribute defines how the image will be drawn on the screen. Then we have fillColor attribute that defines the color of the image. Also we have fillAlpha, which defines the opacity of the image. If you try to change the opacity here such as 0.5 or 0.9, then in that case, you can yourself see the difference. Let us revert it to 0.3. Similarly, I will create the next image in sequence, which is this image. Rename the file to battery_charging_1. So here is our image. In that same way, put other images in place within their drawable folder so in the end you will have seven image files. Just pause the video and do it. So here I have all the images in place. Now moving on, we need one more xml file that will play all of these images in sequence. So let us create that file. Let us call it battery_animation_list.xml. Once you create it, go to the Text tab of this file. Change the root tag to animation-list. Define the first item with drawable property that points to our first image. Then define the duration in milliseconds for which you want this image to appear on screen. Similarly, define mode item tags for the rest of the images. So when you run the application, this image will appear on the screen for four-hundred milliseconds, and soon after four-hundred milliseconds, the next image will appear on the screen, again for 400 milliseconds. In a similar way, the other images in order will be executed. Now it is time to write some code within our activity file. Let us define a lateinit animation drawable in the name of batteryAnimation. Now save the BackgroundResource drawable of our image view whose id is target view as battery_animation_list, which we just define here. Then from our image view we can extract the background resource and cast it to AnimationDrawable, and assign it to our batteryAnimation, which we just defined here. Finally we can now start the animation. Great! But right now our animation won't work. Why? Because we have written this code within our onCreate method. Well, if you remember the application views in Android are only visible when onStart lifecycle method is executed. So we have to execute this code within onStart or some later lifecycle method. So I will use the onStart lifecycle method, and put all of this code here. Let us now launch our application. So here our application is up and running, and if you notice, as soon as our application starts, the animation begins to run so this is our frame animation. Well, right now our frame animation is looking pretty slow. You can control it by modifying the duration here, so instead of 400 milliseconds, you can use 200 milliseconds. Let us try it out. Much better! Now proceeding, you might want to control the animation dynamically through code, that is using this button you can either start or stop the animation programmatically. So within your main activity within this function of event handler, you can check if the animation is running. Then simply stop the animation, else restart the animation. Let us try it out. So here the animation is already running. Click on this button; it will simply stop the animation. If you click on it again, it will restart the animation. Great, isn't it? Well, I think I missed to add one more item in my animation list, that is my battery_charging_6.xml so I will add it here. Now further in your animation-list tag, there exists an attribute known as android:oneshot. Well, by default its value is false, but if you try to change this value to true so in that case what it means, then your animation will execute only once. It is not going to repeat automatically again and again. Let us try this animation with oneshot value equal to true. So here we go. Our animation just executed once and once the cycle was complete, it was eventually stopped. So I think we are not really done with this video. So that's all for frame animation. Now before I end this video, I suggest you to implement a frame animation with this Wi-Fi icons. Try it out yourself. The steps will be totally the same. Take it as an assignment, go ahead and do it.

Introduction to Animated Vector Drawables
The next way to animate a drawable is by using AnimatedVectorDrawable. Well, this class lets you animate the properties of a vector file. So these kinds of animations are mainly used on icons. An animated vector drawable is a fire and forget animation, which means it is a very simple API that just starts and stops the animation so you don't have much control over its progress and these are the few potential examples of what you can achieve using this animation. So let's take a look at the important key points of this class. Well, this class was introduced in API 21, and it is used to animate the properties of a vector drawable beautifully and easily. Using this animation you can rotate, scale, translate, draw paths, do path morphing, so in short, you can do a lot more things on a vector using this class of AnimatedVectorDrawable. Starting from API 25 that is Android Nougat, AnimatedVectorDrawable runs on RenderThread, and on earlier APIs this class used to run on UIThread, which means starting from API 25, the animations in AnimatedVectorDrawable can remain smooth even when there is a heavy workload on the main UI thread. To enable backward compatibility below API 21, you can use AnimatedVectorDrawableCompat class so as to extend support devices running on API 11 or higher. To implement AnimatedVectorDrawable, you at least need three XML tags. The first one is animated-vector, which represents an animated vector drawable. The second tag is a vector, which represents a vector drawable, and a third tag is objectAnimator, which represents animations. Note that you have multiple object animators based on how many animations you want to apply on your vector. Now the purpose of this animated vector is to apply this animation on our vector drawable. So let's see how to prepare these XML resources and use them within files. You can prepare resources for AnimatedVectorDrawable in two ways. In the first way, you need at least three XML files. The first file will be in drawable folder and will define your vector graphic. Note that this is not the actual code of a vector. Right now I am just showing you those attributes that are worth to note as of now. The second file will be in animator directory and will define what animation you want to apply on your vector. The third file will be in drawable folder where we will define our animated vector. Well, this tag will be used to link our animation file with our vector file. So under the target tag, we have name as crossIcon, which is the same name we have defined for our vector here. Next for the animation attribute, we have referenced our animator file, which is present here. Now moving on in the second approach, you can merge all of these three files into a single file. So here we just need one file within drawable folder. The root tag is again animated-vector. The vector file, which you can see here is now present here. Next is a code for animation, which you can find it here. Finally within the target tag on this vector icon, we are applying this rotate animation.

Implementing Animated Vector Drawables
For the demo, I will use a very simple example. I will use this tick icon and slowly morph it to a cross icon like this. During path morphing, the icon will rotate as well. Next, I will show you how to perform the reverse animation, that is from this cross icon, slowly get back to the tick icon from where it started. Now to start implementing this animation, you first need to get this starting vector icon, which is our tick icon, along with the ending vector, which is our cross icon. Usually, to use some animation in your live project, you would ask a designer of your team to provide you the SVG files for both start and end vectors. He might use tools such as Sketch or Illustrator to get the icons. Now SVG stands for Scalable Vector Graphics, which is the actual vector format, but in Android this format is not supported so you need to convert it into vector drawables using the Vector Asset Studio present in Android Studio. Based on your preference, you can use some online tools to convert SVG into Android vectors. Now since our objective is to understand the basics of animated vector so there is no need to look for a designer around you. So here we are inside our application. Before you start, make sure you update the MainActivity, as well as activity_main.xml from helper-files-2 of this module. Once you're updated, let's begin. To implement such animation in Android Studio, let us create the check icon and cross icon, both in the form of vector drawables. Go to the Clip Art and look for the check icon. Just rename it to ic_check. Change the color to 999999, and then add it to your project. Once you do it, you will get this code. Here I will make some changes. I will remove the tint attribute and instead use the fillColor here as 999999. Great! Repeat that same step for the cross icon. Well, we don't have a cross icon here so I will choose the close icon. Rename the file and add it to your project. Repeat the same thing for tint and fillColor attribute for this icon. Now if you notice, for each of the vector drawables, this pathData attribute defines how to draw this image. Similarly for this ic_check.xml, we have this pathData that defines how to draw this vector. Now from this stick icon, I want to morph to this close icon so how to do it? Well, we have a free online tool available, shapeshifter.design, special thanks to Alex Lockwood who is the creator of this tool. So in this tool, I will import this ic_check.xml. So just drag and drop this vector to this tool. Once you do it, select Add Layers. So here is my vector and this is the path to draw this vector, and all the attributes you will find here in this panel. So let us add some animation to it. Select the path and click on this Add New Animation. Well, there are a lot of options that you can use to animate. PathData is a bit tricky, but trust me, it gives you a seamless animation and you will love it. Once you've selected, you will find your animation in your timeline, and on the right in the panel, you have modify your animation such as this fromValue represents the pathData of your current check icon, which is exactly the same as what we have here in the Android Studio. Now next we have toValue, which will be the ending point of our animation. As per our objective, our ending point is actually this cross icon or the close icon. So I will simply copy the path data of this icon and place it here in the toValue. Just replace the commands, but here it shows some error. Why? Because while morphing vectors, the number of commands that creates your current icon should exactly match with the target icon to which you want to morph your image. What I want to say is the number of commands defined for this tick icon or the the check icon should exactly be the same as the number of commands present here in the pathData of this cross icon. But unfortunately in our case, the number of commands are different in both cases, but don't worry, Shape Shifter tool allows you to resolve this issue. Just click on this edit icon. It will show the starting and ending position. These blue icons are showing you the number of commands present in both the cases, which is of course in the both the cases are different. So if you click on this magic button, then it will automatically add the missing commands or the coordinates which you can see yourself as the red points. If you play the animation right now, well, it was pretty fast. Let us use this slow motion, play the animation again. You will find some weird kind of animation. Go back and let us increase the duration of the animation to 300, and let's play it again. Well, you will find that our animation is working, but it is looking pretty weird. It is not as I was expecting, and I am sure you won't like to put it in your live project too, so what is a solution for this? Well, the solution to this will be to sit with the designer of your team and prepare the SVG file for both the icons, and trust me, if you like to play with vectors, then you can do it yourself. It will indeed take some time, but the result will be flawless.

Animating Vector Drawables
So as for what we discussed in the previous video, as for my environment I have got two SVG files, and I will convert them into supported Android vector format. So within your helper-files-3 of this module, you will find those two vector drawables. Just copy these two and in your project, just delete these two old files and replace them with the new one. So if you take a look at the code of these two vectors, you will find there the number of commands are exactly the same such as these commands and these commands, and both of these paths are enclosed within a group in both the vectors. So we are going to apply the rotate animation on this whole group and while rotating, we will morph the path between these two icons so let's do it. So again, go to the same website and then import the same ic_check.xml, which is our drawable. Now as per our requirement, I want to apply the rotate animation on this group. So on this group I will add the rotate animation. You can adjust your time, apply some interpolator of your own choice, and define the rotation value. I will rotate it to 180 degrees. So if you play the animation right now, our drawable is rotating 180 degrees. So while rotation, I also want to morph the image to the cross icon so I will apply one more animation to our vector so just add the new animation, I will apply the pathData, decide the start time and end time, select the interpolator of your own choice, and now define the fromValue. Well, this fromValue will represent the check icon or the tick icon, which is present here, and our target values should be the commands of this cross icon, with is present within the pathData here. Just copy these values and paste it here. Perfect! So if you run this animation, you will find the seamless transition from check icon to close icon. How cool is that? Play it again. Awesome! Now it's time to export our animation. Well, for our application we want this animated vector drawable. Once you download it, paste that animation in your drawable folder. Well, if you want, you can rename the file such as avd_check_to_close. So in this file you will find that we have vector, animator, also the animated-vector within the same file. Well, having all the animators, vectors, and animated vectors within the same file is made possible by using that aapt schema. This XML bundle format requires the build tools of 24 and above, which I am sure you all are using in your project right now. So this vector represents the check icon, and on this icon we are applying some animation such as the rotate animation on the whole group, and then we are morphing the path from these values to the cross icon path data. Well, here let us modify the duration of the animation. Let's make it one second. Now proceeding in your activity_main.xml, on this image view, let us start the image source as @drawable/ avd.check_to_close. Once you do it in your MainActivity.kt, let us write some code to implement our animation. On your image view, let us start the onClickListener, on click of which a method will be executed. Let us set the image resource as our animated vector, which we just redefined here. From this image view, get the drawable and cast it to AnimatedVectorDrawable and assign it to a variable avdCheckToClose, and finally, let us start the animation. Let us run our application. Click on this image. Just now we saw the check icon getting transformed into the cross icon and it was really a flawless animation. Now when I click on this icon again, it again repeats that same animation, but on click of this icon, I warned that it was animation. That is this cross icon should get transformed into the check icon. So let's do it in the next video.

Animating Vector Drawables: Continued
In this video, we will apply the reverse animation, that is from close icon to check icon. The steps will be totally similar to what we saw in the previous video. In this tool of Shape Shifter, from the helper-files-3, import this ic_close.xml. Once you do it in your group layer, just apply the animation such as the rotate animation. So here is our rotate animation with these properties. So here I am rotating it anti-clockwise, and then I have applied another animation to this cross path such as this pathData. So here is the animation, and these are the properties. This path belongs to the close icon and this path belongs to the check icon. If you run the animation, you will find from close to check icon. Once done, you can export the file. So in this file you will again get this animated vector as a root tag, and then we have the code for our vector cross icon. Down below we have these applied animations. Now instead of using one file, you can actually extract these resources into different files. For example, you can extract this close vector and put in the drawable folder. So in my Android Studio I already have ic_close.xml in place, whose code is exactly the same as what you can see here. Also, you can extract these two animators and put it as separate files in Animation Resource Directory. So from the helper-files-4, you can copy this animator and paste it in your resource folder. The first one is responsible to morph the path from close icon to check icon, and the second animator is responsible to rotate the vector anti-clockwise. Now our third file will be the animated vector itself, which will apply these two animations on our vector ic_close.xml. So from our helper-files-4, copy this animated vector file and paste it in your drawable folder. So here is the file which looks pretty clean. The objective of this file is to define the target name on which you want to apply this animation. And remember, this target name equal to cross is exactly the same name that we have defined within our ic_close.xml for this path tag here. Similarly for this group, we have the name of groupTickCross and on this group, we are applying the rotate animation. So I will use this name within my AnimatedVectorDrawable, which you can find here. And on this target we are applying the rotate animation, which we have defined here. Quite simple, isn't it? So now our last step will be inside our Main Activity. Here I will declare a flag that will help us re-toggle the animation, and then call a function to apply the reverse animation. So within this function, the code to define the animation will be totally the same, except that the name of the animated vector will be different such as avd_close_to_check. Run the application, click on the image, perform the reverse animation, great! Working perfectly fine. Now before I end this video, you might think that in the previous video I had applied animation using just one file, but in this video I am using the multiple files. So which one is a better way to perform animation? Well, the answer is it depends on your need. Suppose in the future you want to reuse this animator or this animator, or this icon. So in that case you can follow what we saw in this current video. Perform animation using different files, right, but if you're sure that you are not going to use this vector or these animators, then you can go for this single-file technique. So I hope now you know the difference between these two techniques. Also, since we have defined this vector already in this file so we no longer need this ic_check.xml, we can now delete this file. Great! So that's all for this video.

Maintaining Backward Compatibility
When it comes to backward compatibility of animated vectors, you need to do some changes in your project. Just for a quick recap, animated vectors were introduced in API 21, that is Android Lollypop, but it allows you to use the class of AnimatedVectorDrawableCompat. Using this class, you can extend support to devices running on API 11 or higher. Apart from using this class, there are a couple of changes that you need to do in your project such as in your application level gradle file, add this statement to use vector support libraries, and then you can decrease your minimum SDK version below 21. Next, in your layout file while referencing the vector drawable use srcCompat attribute, which is already in place, along with you have to use app namespace, which is the namespace defined here. Next, in your code, instead of using AnimatedVectorDrawable, you have to use AnimatedVectorDrawableCompat class. And here as well, change it to AnimatedVectorDrawableCompat, which belongs to support library. Once you are done, you are good to go. If you run the application in the lower API version, you will get the same result. In this way we have reached the end of this module. The whole objective of this module was to explore how to animate drawables. We first saw how to use AnimationDrawable to implement frame animation. Thereafter we saw how to use AnimatedVectorDrawable to animate vector graphics. So yes, that's all for this module. Thanks for watching, and see you all in the next module. Thank you!

Applying Transitions
Overview
If you already know the basics of how to develop an Android application then you must have come across the word transition and how it provides a finishing touch to your application. Hi, this is Sriyank Siddhartha, and welcome to the next module of this course. In this module, we will talk about how to apply transitions to your application. Most of the transition APIs are found in the android.transition package. It was introduced in API 19, that is Android KitKat. So if you want this API below API 19, then in support library we have a support package of android.support .transition, but in this module we will use android.transition package, because going below API 19 as a minimum SDK version won't affect the range of target devices. The very basic transition animation class that you will find in this API is Transition class. Well, this class has several subclasses such as Fade transition, which is a very basic transition yet very useful, and this is the xml tag that defines a Fade transition. Next subclass is the Slide transition, which adds some sliding effect. Then we have Explode transition and ChangeBounds transition. Now these are all the individual transitions that you can use in your application and animate things, but if you want to combine all of these transitions and use multiple transitions at the same time, then for that we have TransitionSet, which is another subclass of Transition. This class allows you to execute multiple transitions at the same time or in a sequential manner. Last, but not the least, we have AutoTransition. Well, this class automatically decides what transition to apply. For example, when you use it, it can apply the Fade transition or Slide transition or Explode transition automatically. So basically you do not have control over it. It does the magic automatically. Now apart from all of these classes, there exist several other classes. I have just shown you the few important ones here. A few of the other important classes are ArcMotion, ChangeClipBounds, ChangeImageTransform, Scene, TransitionInflater, and TransitionManager. In this module, I will show you implementation of important API classes. Now using this transition API, we can apply a transition in two ways. In the first way, you animate the layout changes within the same activity or fragment, and in the second way there are two activities involved. So we call it as Activity Transition. In the first case where one activity is involved, basically we swap between child layouts. For example, let us assume this is our root layout, and here is our Layout 1 that contains some views. So currently our child Layout 1 is visible on the screen, and here is our Layout 2, which is yet to appear on the screen. Now I will apply a transition and replace child Layout 1 with child Layout 2, like this. Now notice here that everything happened within the same activity. Coming to the second case, here, currently we are in Activity One. If I move to the next activity, the views will appear as if it is flying to the next activity. So here the transitions are taking place between two activities. So first, in this module I will cover how to prepare transition between layouts within the same activity. So let's see how to do it.

Animate between Two Layouts: Project Setup
You can animate between layouts in three easy steps. First, you need to create a scene object for both the layouts. That is starting and ending layouts. Next, you need to create a transition object to define what kind of animation you want to apply for your layouts. Well, these transitions can be any subclass of transition which we saw in this slide. Finally, you need to use TransitionManager.go function to start animating things. Proceeding, you can complete these three steps in two different ways. The first way is by using XML Resources. For that, you need to store transition files within res/transition directory. The second way is just from code. In this case, we do not use transition files from the resource folder. So one by one, let us explore them. So first, let us start with implementation using XML Resources, but before that, let us do the initial project setup and understand our objective. Before you start, just add this dependency in your application level Gradle file. This is an external library, which will help us to use circular image view. Proceeding, go to the helper-files-1 of this module and update your MainActivity, activity_main.xml, and strings.xml. Along with this, add this transition folder in your resource directory. Add this image to your drawable folder, and put scene1.xml and scene2.xml within your layout folder. Once you are done, make sure these are the updated or new files and folders. If you run the application right now, then in your Emulator, you should see something like this. If you find this output, then your project setup is completed. Right now this window has one activity, and this whole layout is activity_main.xml, and the very same layout contains our frame layout whose id is sceneRoot. Within this frame layout we will swap between scene1 and scene2. Currently this layout shows you scene1. Let us take a look at scene1. Well, it contains an image view and a text view. They're aligned horizontally. Let us open scene2.xml. Well, in scene2 we have three elements, two text views and one image view. They are aligned vertically. If you compare scene1 and 2, you will find that the idea of the image view and the text view is exactly the same as the id of the image view and this particular text view present here. Also note that apart from id, the properties such as the size of the view, their alignments, and their other text view are different. Well, that doesn't matter. The only thing that matters is that is the id of these views should exactly match in another scene. Also in scene2, if you notice, we have an additional text view, which is absent in scene1.

Animate between Two Layouts: Demo
So in our Main Activity I have declared three steps to implement the transition, and these three steps are exactly the same as what we saw in this slide. So our first step will be to create two scene objects and those two scene objects will correspond to these two layouts, scene1.xml and scene2.xml. So as a part of step 1, I will use Scene dot static function of getSceneForLayout and pass the first parameter as the id of the root layout within which the animation will take place. In our case, it is sceneRoot, which is the same id provided to our frame layout present in our ActivityMain.xml. Now the second parameter is the reference to our scene1 layout and finally pass the context of this activity. Let us repeat that same code for scene2. Just make a note that the id of the root layout will be the same. Moving on, we have step number 2, to define our transition. Well, let us skip this step at this moment. I will come back to it shortly. So moving on, we have step number 3, where we need to apply the animation. So initially if the current scene is scene1 then use TransitionManager to go to scene2. Also point the current scene object to scene2. In the else block, we can do the opposite, that is go to scene1. Perfect! Now since we are using Kotlin so we can simplify our code. Just press Alt+Enter and do it. Great! Finally when the application starts, we need some initial scene to be populated so I will use scene1 as the entry point of the application and point currentScene to scene1. Also in the end, please note that we have skipped our step 2. Let us try to run our application and see what happens. So tap anywhere on the screen. So here we have some Fade transition. This shows that even if we don't supply any transition, that is if we skip our step number 2, then by default transition framework applies AutoTransition to our scenes, and that AutoTransition decides whether to fade, slide, move, explode, or resize the views. In short, you don't have any control over it. It does the magic automatically. So moving ahead, let us define our own transition, and for that we have defined the XML files within our transition directory. Let us open our example_1.xml. Here we are using changeBounds transition with some duration and some interpolator. Of course, if you want, you can go ahead and modify these two values. To use this transition, we need to write some code. So within our Main Activity, let us use the class of TransitionInflater and inflate that transition. This will return a transition object. Next, you can pass this object to these two functions as a second parameter. Perfect! Let us now run our application. Tap anywhere on screen, much better! It looks great, isn't it? But this could be improved. For example, the changeBounds transition works well with our image and this text, but for the title, which is present here in our scene2, it doesn't go as well. The title appears on the screen with a jerk and moves out of the screen in the same way. Well, this certain appearance of the title can be best replaced by Fade transition. So basically what I want to do is along with changeBounds transition, I want to apply one Fade transition as well to my scenes. We will apply those transitions in a way that the changeBounds transition will fit well for this image view and this text view, but for this title, we will apply only Fade transition. So let's see how to do it.

Using Multiple Transitions: TransitionSet
As mentioned earlier, to apply multiple transitions, you need to use TransitionSet, which is a subclass of Transition. So in our application within our transition folder, you will find example_2.xml. Here we have transitionSet element. Well, this tag allows you to add multiple transitions for a scene. So here I will copy the code present within our example_1.xml and paste it within our transitionSet. I will now add a Fade transition with a duration of 250 milliseconds. Now these two animations will by default execute together, because the existent attribute known as transistionOrdering whose default value is together. You can change it to sequential as well, which will execute these two transitions one after another, but right now, let us keep it together. Now as mentioned earlier, we want the Fade transition just for this title. So I will use our targets tag and define our target view by using the id of our title text view. Note that this is the id of the title present within our scene2.xml. Now if you want this transition to be applied on any other specific view, then you can use another target here like this. In a similar way, you can add as many targets as you want to. Now let us start this transition with some delay so that our Fade transition will start a little after the changeBounds transition, but with a slight overlap. Then we can define the fading mode. Well, this option of fade_in_out means that the views will fade out while exiting the screen and fade in while it appears on the screen, and all of these will be taken care of by the framework internally. So I will use this option. It looks great! Now within our Main Activity, let us change our transition name from example_1 to example_2. Run the application, tap on the screen, much better, but still it can be improved, because while fading in it looks good, but while fading out, if you notice, there is a slight overlap between scene1 and scene2, which means that we have to split our Fade transition such as the first one will perform just the fade_in transition, and the second one will perform the fade_out transition. I'll just modify a few of the attributes, so here are the changes. If you try to transition right now, you will find things are much better. All the transitions are now in place. Now similar to these transitions in example_3 and example_4, you will find the explode transition with some attributes, and also the slide transition. Well, if you apply these two transitions in our demo application, they won't look good, but you can just try them out and see how they look.

Apply Transitions from Code
Let us now proceed and see how to apply transitions and animate between layouts just from code. So we will not use any XML resources to achieve our required transition. To understand things better, I will map all the code present within our XML file in our Main Activity, but before we start, just comment this statement. We won't use it in this video, and from helper-files-2 of this module, just paste this code snippet. Well, this code will do the same thing as what we have defined within our example_2.xml. So now let us take a look at these transition elements independently. First, we have changeBounds, which we have instantiated here. Also, this is a duration and interpolator. Next, we have the fadeInTransition so here it is. Then we have some properties, which you can find it here. Finally, we need to set the target. For that, we are using addTarget function here, and passing the reference of our text view. Similarly we have the fadeOutTransition, which looks pretty similar, just that we are using Fade.OUT here. Now all of these elements are a part of transitionSet whose ordering is together. So within our Main Activity, let us define our transitionSet and instantiate it here, then define its ordering. Next, one by one, add the created transitions to this transitionSet. Note that the order in which these objects are added will determine the sequence in which they will be played. Now since our ordering is together so far as the sequence in which these are added to the transitionSet doesn't matter. Finally, pass the transitionSet in both of these functions, run the application, tap on the screen. So here we go, things are working as expected. Great, isn't it? Now in the end you might ask a question, which one to prefer? Applying transition via code or applying transition via XML. Well, in terms of performance, both are the same, but using transitions as XML resources will help you to separate your code from your logical code, which you have written within your Main Activity. And in the future, if you want to modify your transition, then without disturbing the code within your activity, you can just modify your XML file, but in the end the choice is always yours.

Apply Transitions without Scenes
Now proceeding, you can also apply transitions between layouts without creating a scene object. That is without using the first step, you can now implement transitions. So let us see in what situation you can implement transition in such a way. So here in this example, we had two different layouts so we created two difference scene objects and accordingly applied some transition on it, but suppose we have a case where these two layouts have a very minute difference. For example, suppose our Layout 2 appears to be like this. So if you compare Layout 1 and Layout 2, you will find a minor difference. Just in case of Layout 2, we have additional text view so in this case you don't really have to create two different scene objects and maintain two different layouts. So here within our application, before we start, just update your Main Activity and activity_main.xml from helper-files-3 of this module. Once you do it, in your Main Activity, you will find two button click event handlers. I will show very simple examples to make you understand the basic steps that are required. First, you need to define your transition. Next, use TransitionManager and call the static function of beginDelayedTransition. As a first parameter, pass the parent layout id, which is sceneRoot in our case. Then pass your transition. Great! Also note that if you remove this transition, then by default AutoTransition will be applied. Now our next step will be to toggle the visibility of our target view. For that we are using a Boolean value, which we have defined here on the top. Also, let us toggle the Boolean value, and you are good to go. Now you might ask how exactly this transition works. Well, when this statement is executed, the system stores the current state of your view, and when you try to modify the property of the view, which we are doing it in this statement, then system modifies the property of the view, but with an animation, which we have defined here. So once again, these two statements work in sync. Let us try this animation. Click on the Fade button. It looks good. A simple Fade transition. Next, we have another example of Slide transition, only the transition name has changed here; the rest of the code remains the same. Let us try this animation. Click on the Slide button. So here if you notice, we have some sliding effect from the bottom within the parent view. Well, you can decide the slide direction. For that you can use Gravity., define your direction such as END, RIGHT, BOTTOM, CENTER, HORIZONTAL, and so on. Right now I will use END, which means slide from right. Click on the button. So here we go, we have some sliding effect from the right. Great, isn't it? Now similar to these two animations such as Slide and Fade, you can try Explode, ChangeBounds, ChangeImageTransform, and other transitions on different views. Well, the basic steps which I have shown here will be totally the same. Also, on Medium, this is a very good article on transitions by an Android engineer from Google. Here you will find many different examples such as how to use Explode Transition on your Recycler view. Then apply ChangeImageTransform on your image view. How to use path motion, then some scale transition, a rotation, and there are many more such examples. Well, as a beginner, I highly recommend you to go through this article.

Activity Transitions
Moving on, we have another kind of animation known as Activity Transition. In this case, the transition occurs between two activities. Well, I have already covered this transition in my course of Getting Started with Android Material Design. So in this course, you will find a dedicated module on animations. Here I have talked about activity transitions such as Explode, Fade, Slide, and even Shared Element Transition. Also I have discussed how to use custom Ripple Animation, which is another important animation found in Android. So I recommend you to go ahead and watch this module.

Limitations of Transition API
Finally, we have reached the end of this module. We have learned a lot about how to use Transitions API in our application. Though Transition API is a very powerful API, it has some limitations as well. When you animate views such as SurfaceView or TextureView, it may not produce desired animation effect correctly. Next, the Transition API works well with RecyclerView, but if you are using ListView in your application, then your animation won't work because the ListView is incompatible with the Transition API, because of the way it manages its child layouts. Well, these limitations won't have any significant effect in your application, but you should be aware of it. So yes, that is all for this module. Thanks for watching, and see you all in the next module!

Applying Animations to Common App Scenarios
Overview
Hi, and welcome to the last module of this course. In this module, I will show you a few examples of how to apply animations to most commonly used views in Android. Initially we will learn what are the basic steps to animate a constraint layout. In this case we are going to make use of the Transition API. Mostly in all the Android application these days we have RecyclerView, so we will see a very simple example of using animation on RecyclerView as well. Lastly, we will explore how to apply transformation to a view pager. Now so far in this course we wrote code for animation from scratch, but there are various open source libraries available on GitHub that allow you to use animation in your project. Using those libraries you can apply tried and tested animations, which will save a lot of time and effort.

KeyFrame Animation Using ConstraintLayout and ConstraintSet
We all use ConstraintLayout quite often in our application. When it comes to support animation, ConstraintLayout is really compatible and can add seamless transition to your layouts without any boilerplate. So in this video we will define a key frame animation using ConstraintLayout and ConstraintSet. Well, don't get overwhelmed by the term KeyFrame. You can call it as just another name for layout. Now ConstraintSet is a class that allows you to programmatically define a set of constraints that can be used within a ConstraintLayout. In simple words, this ConstraintSet can represent the constraints, margin, and padding of all the child elements present within the ConstraintLayout. And we are going to achieve this animation by using TransitionManager, which belongs to Transition API. So in our demo, we will have a layout like this. Let's call it Layout 1. The root layout here is ConstraintLayout. Please make a note of that. When we tap on the screen, it will switch to Layout 2. Again, it is some kind of transition between the layouts. Before you start from the helper-files-1 of this module, update your MainActivity and activity_main.xml. Also, add activity_main_detail.xml and this image file in your drawable folder. Once it is done, let's get started. So in our activity_main- detail.xml, you will find a layout that contains some views. Here the root layout is constraintLayout. It contains several immediate children. Well, KeyFrame animation is only applicable to the immediate children of the ConstraintLayout, which means if you place some nested views here, then by default, those nested views won't get the animation. So that is why here we have all the views as immediate child of this root layout. Now let us move to our activity_main.xml. Here in the Component Tree, you will find all the views will represent in our detail layout here. So the Component Tree is exactly the same in both the cases. The only difference is that these views are not visible on the screen in case of this layout, just because I have modified their constraints to hide them on the screen. Also note that the id of these views is exactly the same as the id of the views present in the other layout. Well, this is a rule that you need to follow in order to apply such kind of animation. Once you define your layout, we need to write some code to apply animation. So here in Main Activity, we have a function to swap layouts or transition between layouts. So on click of our root layout, if it is a DetailLayout, then simply switch to our default layout, or else we can go to DetailLayout. Now within this function of swapFrames, we can instantiate a constraintSet object. On this object, we need all the constraints of the child views of the new layout, which will replace the old one, and this layoutId is received as a parameter here, which is getting passed from here. So in short, this clone method will absolve all the constraints of the views present in our desired layout. Once we get it, we can then use TransitionManager.beginDelayedTransition function and pass the root layout on which we want to apply the animation. Please make a note that this ConstraintLayout is the id of the ConstraintLayout present in both of these layout files. Also note that as a second parameter, we are not passing any transition object, which means by default AutoTransition will be applied here. Finally, we can apply the new constraints to our root layout, that is our ConstraintLayout, and then we can toggle the Boolean value. Well, the code looks pretty simple, just four lines of code and the magic happens. Let us run our application, tap on the screen, and great, isn't it? Working perfectly fine. Well, we can add some effect to this transition by adding some interpolator. So first, let us define our transition. Define the interpolator, then duration if you want to, and finally pass the second parameter here as transition. So now we're applying our own transition. We are no longer relying on the AutoTransition. Run our application, tap on the screen, how cool is that? Let us try some other interpolator, and try it again, tap on the screen, much better! Awesome! So this is how we apply the KeyFrame animation using ConstraintLayout and ConstraintSet so that's all for the video.

Using Open Source Library: RecyclerView Animations
So far in this course we were writing our own code to implement animations. Well, that is great, but there are people out there to make our life easy. Their open source libraries allow us to use animations and customize them as well, without any efforts. So in this video I will show you how to use open source libraries available on GitHub. For this purpose, I will use our demo project of RecyclerView. Well again, if you don't know how to implement RecyclerView, then do not panic. The objective of this video is not to dive deeper into RecyclerView, but to give you an idea of how to apply animation using a library. For this particular video, you can just watch it and later on get the code from the exercise files of this module, or else if you wish to follow along, then go to the helper-files-2 of this module, and update your classes here. add or update your layout files over here, also from your layout file, just add the RecyclerView dependency to your application. Look for it and click on this icon. Also add the CardView dependency to your project. Thereafter, add these images in their drawable folder, and once you are done, simply rebuild your project. Now after the build completes, you will find some error within their transition folder. If you want, you can comment the code within this file or you can also delete the file as we no longer need this in this video. Once you are done, let's begin. Well, this project contains a very simple implementation of the RecyclerView. Our application just contains a simple RecyclerView with Add and Delete operation. If you delete any item, then you will find some simple animation while the item was removed from the UI. The same with the Add operation. We have some default animation like this. Well, this animation is due to the itemAnimator property, which we have defined here. Now what if I want to delete an item with a slide animation or some fade animation? Well, for that we need to write our own piece of code, but if we use any library, then it will be a lot easier for us. For example, there are several websites where you can look for Android libraries. Android Arsenal is one of them. You can sort any libraries by rating or by name or even by last updated. Let us sort it by rating and let us look for the Animations library. So here we go, Animations. Well, these libraries on the top are highly rated and popular libraries. On scrolling down, you will find a library of recyclerview-animators. Well, there are many more, but right now I will use this library. Once you open it, you will find its GitHub stats, its general information, and down below you will find its Read Me file, how to use this library, such as the setup procedure. I will right now copy this statement and in my project, I will simply navigate to my application level build.gradle file, and paste that dependency here. Just make sure you have defined some version here such as I will use 3.0 .0. Sync the project. Also make sure in your project label gradle file you have jcenter and a Maven section included under repositories. Now moving on to Main Activity, instead of DefaultItemAnimator, you can use the classes of the library. For example, right now I will use the ScaleInBottomAnimator. Well, there are a couple of mode options. You can try them all, but right now, let us use this. Well right now it is showing some error. Also if you run the application, you will find some error related to Manifest merger. Well, this is kind of an unexpected error. On looking for a solution, I found that this error occurs when there is any dependency conflict between Google's files and the third-party libraries. Well, if you can't see the error, then it's fine, no need to do anything, but if you get this error, then just migrate your project to AndroidX. Back up your project. Well, there are more solutions to this error, but right now I will use this solution. Once you do it, your error will be gone, it's just that you have to make some changes here. Instead of LinearLayoutManager use RecyclerView.VERTICAL constant and you are good to go. Let us now run the application. Let us now delete an item. So here we go, we have some ScaleInBottom effect like this. Fine, you can even control the duration of the animation. On your itemAnimator, you can modify the duration of add operation. In a similar way you can modify the duration of delete operation. So let us see the changes. So this time the animation can be seen in slow motion. Great, isn't it? Similarly, let us try some other animator. For example, OvershootInRightAnimator. Delete any item. Much better, isn't it? Now if you check the code for this class, then you will find some code residing here. We have all the code for this animation, which you were supposed to write manually, but now things are easy just because of this library. Now in a similar fashion, you can try other animators as well such as these are the variants of the ScaleAnimator, FadeAnimator, Flip and Slide animators. You can even try some custom adaptors, and the steps are again mentioned in the Read Me file of this library. Let us try them out. So here again with our Main Activity, I will wrap this adaptor with ScaleInAnimationAdapter and pass adapter as a parameter here. Let us run the application. Now when you scroll, you will find some kind of scale animation on the items getting loaded. How cool is that? Similarly, these are the other adaptors you can try in your application. Now the cool objective of this video was to show you how you can make use of the open source available libraries and apply them in your projects. So whenever you try any animation, just try to look for such libraries online. If it is there, then you are lucky, if it is not, you can create your own library and make your library open source so that people like me can use it and contribute to it. That's all for this video.

Using Open Source Code: ViewPager Animations
In this video we will see another example of using open source code available on GitHub. This time I will use animation on ViewPager. Well, a view pager allows you to flip left and right through different pages. Each page can be a fragment or a layout. In our case, we have a layout which contains an image view. Now again, for those who don't know how to implement ViewPager, do not panic. My objective here is to show you how to use animation, and I will just show you the simplest possible code of ViewPager, which is easy to follow. Now before you start, just add ViewPager to your application. Next, from helper-files-3 of this module, you can get the modified project files. If you want to follow along, then simply add all of these files in your project. Once you are done, for a quick walk through all of the project, we have our ViewPagerAdapter class present here. The purpose of this class is to load data on the screen. Moving on to our Main Activity, here I have written the code to instantiate our ViewPagerAdapter, and on our ViewPager I am just attaching this adapter. Now this ViewPager is the UI element present in our activity_main.xml here. Next, in our activity, down below we have some code for our pop-up menu. So these are our menu items which you can find here in our action bud like this. Now these menu items are calling a function. Well, in that function, we are calling a function on our ViewPager known as setPageTransformer. Well, this function is responsible for adding some animation to our ViewPager. So again, make a note. This function is the only responsible code right now which will help us to add animation to our project, and all of these classes which we are passing to this function are actually present within the transformers package. If you expand it, you will find all of these transformation classes. Well, all of these classes are available on GitHub. I have just collected them. They are all open source and absolutely free to use. Well, right now our ViewPager is not showing any animation. It has just a normal sliding effect, but let us try our Fade Out animation. Select this menu item, and try to flip through the pages. So here we go, we have some fading effect as we slide to the right, and if you slide to the left, again we have some fading effect. So let us take a look at this Fade Out transformation, which is present here. So this class extends from ViewPager.PageTransformer, which contains an abstract method of transformPage. Inside this function I can use the page-view parameter and apply some translate and fade animation. Well, here we have a little bit of mathematics. Also note that this function of transformPage is called when you start to slide through the pages like this. So in that case, that function is triggered. Now let us try our Zoom Out transformation. It looks great, isn't it? So if you take a look at its code, which is present here, then within the TransformPage function you will find some conditional statements. Here we have three conditions. The first case represent when the position is smaller than -1. The second case is for in-between -1 to 1. And the last case is for greater than 1. Now what exactly is meant by position here? Well, the page present on the left of the screen has the position of -1, which is currently invisible to the user. The page on the right has a position of 1, which is again not visible. Now since at these two positions our page is not visible, so that is why in these two cases we have alpha value as 0, which makes them transparent, hence invisible. Now the page which is visible on the screen has position of 0. So if I try to move this page, then we are either moving it towards -1 or moving it to the position of 1 on the right like this. So this shows that we have to apply animation in-between -1 and 1. Quite simple. So here is the case for that, which represents the position in-between -1 to 1. So here we are applying some transformation such as their translate animation, scale animation, also the alpha animation. Along with this we have some logic and mathematical calculation to show a seamless transition as we move our page. Well, it looks a bit complex, but trust me, if you love mathematics, then it is super easy for you. If you don't, then these open source files are there for you. You can use them without any effort. Now similarly we have other transformation such as Depth Page transformation, which appears to be like this. Then we have Vertical Flip animation, that simply flips the pages vertically. Then we have Cube Out transformation, and finally I have the Hinge transformation, which looks like this. Also you can go ahead and use other transformations that you can find within this transformers package. To use these files you can just modify your Main Activity, add some menu item here, and pass the instance of the transformation to this function present over here. Quite simple, isn't it? So yes, that is all for this video.

Course Summary
The whole objective of this course was to make you understand the basics of animations in Android. In this course we first explored property animation API. There we glanced at various basic animations of translate, scale, rotate, and fade animations. Thereafter we explored how to apply animation on drawables in Android. There we explored frame animation and animated vector drawables. Moving on, we saw how to apply a transition between layouts, and in the end, we saw a few examples of how to apply animation on ConstraintLayout, RecyclerView, and ViewPager. In these sample examples we also saw how to use open source libraries in our project. Well, I would have loved to cover more on animations. There are a few topics like motion layout and physics-based animations, but they are all beyond this course objective. By the time you are watching this video, maybe there are more courses published on animations at Pluralsight. Kindly look for them, and yes, thank you for taking this course. This is Sriyank Siddhartha signing off, and I hope to see you in my next courses. Take care and bye-bye!

Course author
Author: Sriyank Siddhartha	
Sriyank Siddhartha
Sriyank is a passionate software developer and loves to share his knowledge through his blogs and video courses. He follows "share and gain" principle which led him to publish many courses online....

Course info
Level
Intermediate
Rating
0 stars with 8 raters
My rating
null stars

Duration
2h 16m
Released
25 Mar 2019
Share course

