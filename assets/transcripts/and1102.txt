Building Your First Connected App with Android Studio
by Simone Alessandria

This course will teach you how to make your Android app connect to a web service and retrieve JSON data from the web, show it with a RecyclerView and persist data with SharedPreferences. You'll also create menus dynamically and use data binding.

There are many times when your Android app will need to fetch data from the internet, to provide users with fresh information. In this course, Building Your First Connected App with Android Studio, you'll learn how to make your Android app connect to a web service and retrieve JSON data from the web. First, you'll connect to the Google Books API to make searches and retrieve book titles, covers and detailed information about your favorite books. Next, you'll learn how to add networking and internet permissions, build URIs, use AsyncTask and NetworkUtils to connect to the web asynchronously. Then, you'll discover how to parse JSON content and correctly use a RecyclerView. Finally, you'll see the Google data binding library in action, and how to use Parcelable classes in order to obtain greater speed of execution. By the end of this course, you'll have a better understanding on how to build your first connected app with Android Studio.

Course author
Author: Simone Alessandria	
Simone Alessandria
Simone Alessandria wrote his first program when he was 12: it was a text based fantasy game for Commodore 64. A few years later, he is now a trainer (MCP), author, speaker, passionate software...

Course info
Level
Beginner
Rating
4.8 stars with 21 raters(21)
My rating
null stars

Duration
2h 19m
Released
31 Jul 2017
Share course

Course Overview
Course Overview
Hi, everyone. My name is Simone Alessandria, and welcome to my course, Building Your First Connected App with Android Studio. I'm a trainer, author, and proud coder at softwarehouse. it. There are many times when your Android app will need to fetch data from the internet, to provide users with fresh information. In this course, you'll see how to use a web API from your Android app and present data to your users. You will build a fully functional app from scratch, and you'll connect to the Google Books API and retrieve data from there. Everything you need is Android Studio. Some of the major topics that we'll cover include connecting to the internet, parsing JSON content, downloading images with a Picasso library, saving data with shared preferences, and an introduction to the data binding library. By the end of this course, you'll have a clear knowledge of the steps involved in creating a production-ready app that connects to a web service. Before beginning the course, you should be familiar with Android Studio and some Java. I hope you'll join me on this journey to learn Android programming with a course, Building Your First Connected App with Android Studio at Pluralsight.

Getting Started
Let's Get Started
Hello, this is Simone Alessandria. Welcome to the course building your first connected app with Android Studio. Throughout this course, we'll build an app from scratch. It will be simple but we'll solve many real world issues you'll be facing when building your next great app. Please, let me introduce you to the Books App. It's made of three activities. The main activity contains a search text box. And the results of your search are shown below, where you have a list of books with title, authors, publisher, and publish date. If you click on one of the books, you get to the detail activity. Here you can also see the cover image of the book and the description. There's also an advanced search activity that lets you search books by title, author, publisher, and ISBN. The five most recent searches made from this activity are saved automatically. In order to make this work, we'll connect to the Google Books API. This is such a great web service. Its purpose is simply exposing information about most of the books that are published anywhere in the world. So thanks to this web service, your app will always be up to date and contain several millions relevant results. If you can't wait and want to try the app straight away, just follow the link below, you'll be able to download the app from the Google Play Store. We'll write every single line of code of the app during the course. So you'll never need to copy and paste code from external files unless you choose to do so. The approach of this course is learn by doing. Many concepts will be introduced and explained just before we need them. This includes classes like NetworkUtils to connect to the internet. SharedPreferences to parse data. JSONOBject to parse JSON. An introduction to the Data Binding Library. And many, many others. This is the flow we'll be following. In the next module, you'll connect to the Google Books API. We'll have a look at the steps involved in the connection, permissions, acing tasks, and retrieving results. Then you'll see how to parse JSON and use a recycler view to show the results in an efficient way to you the user. After that you'll create the detail activity. For the image we'll use the Picasso Library but you'll also have a look at Parcelable Classes and constrained layout. In the last module, everything will come together. You'll save data with SharedPreferences but we'll also apply many fixes to create a realistic app. This is a beginners course targeted at Android developers. It's okay if this is your first real world app in Android but you should at least have some programming on your shoulders. Possibly in Java. I try to explain the Android specific concepts and go quickly over the more dramatic ones. Like objects, functions, constants, loops, even switch statements. If you don't know what I'm talking about, probably you should begin from a genetic introduction to programming and then come back here. We'll be using Android Studio 2. 3, that version or any version above will be fine. I recommend you install it on your system before beginning the next module. And the third prerequisite is you should be willing to write code. Which will not always be perfect and won't always work the first time you write it. But success is made of small steps. At the end of this course, you'll have all the elements you need to create apps that connect to web services, look for specific data, show the retrieved information to your users and persist user data onto your device. Let's begin this journey together.

Connecting to a Web Service
Module Intro
Hello, this is Simone Alessandria. Welcome to this module of our course, building your first connected app with Android Studio. In this module, you will see all the steps required to connect to a web service with Android Studio. In particular, we'll connect to the Google Books API and retrieve some JSON data. We'll begin by creating the app. You'll see how permissions work in Android. We'll see how to use URIs and URLs. Then we'll actually connect to the API. And in doing so, we'll use a stream and see an incredibly useful class, the AsyncTask. We'll finish this module building stronger foundations and see a few best practices that might help you build great apps in the future. At the end of this module, you will have built an app that queries the Google books API, retrieves JSON data and shows the results in a text view. This will be the foundation for the remaining of this course. Enough talking, let's start coding.

Creating the App and Setting Permissions
Let's open Android Studio and click on start a new Android studio project. We'll call it books. Choose your favorite project location and then press next. We'll be targeting phones and tablets. And Android API 16 seems a sound choice as it will cover over 95% of the active Android devices. Let's click next. We'll begin with an empty activity. And we'll call it book list activity, as it will contain the list of books retrieved by the Google books API. Let's click finish. This will create our project. After the project completes loading, let's get to the layout of our activity. You may notice that now the default layout is a constraint layout. We'll see it in action later. For now, let's just notice that inside the layout, there's a text view that contains a hello world text. For this module, this text view will contain the response we get from the Google Books API. So let's just give the text box an I. D. of TV response so that we can reach it from our Java code and then remove the text. Next we need to make a change in our manifest file. In Android every app is sandboxed. That means that generally speaking, it cannot use any feature outside of itself. This limit would make our app totally useless. We really need to access the Internet in order to download book data. The solution here is asking for a permission. This case we need to get the permission to access the Internet. And this is rather simple. We only need to add a statement in our app manifest file stating that we need to Internet permission just like that. This bit of code could be placed in the manifest route node. In newer versions of Android, starting with Android 6 Marshmallow, this permission will be granted automatically as Internet access is considered a normal permission. In older versions, the user will be asked to grant permissions during installation. Permissions are divided into different protection levels. The two most important protection levels to know about are normal and dangerous. Normal permissions cover areas where your app needs to access data or resources outside the app's sandbox. But where there's very little risk to the user's privacy or the operation of other apps. For example, our Internet permission is a normal permission. If an app declares that it needs a normal permission, the system automatically grants the permission to the app. Dangerous permissions cover areas where the app requires data or resources that involve the user's private information or data used by other apps. For example, the ability to read or write the user's contact can a dangerous permission. And if an app declares that it needs a dangerous permission, the user has to explicitly grant the permission to the app. Here, you can see a selection of some of the most common permissions apps are likely to use. But if you want to learn more about Android permissions, have a look at the link below. Okay, let's put that in action. We'll open our manifest file. And add the permission statement right on top before the application tab.

Building the URL and Connecting to the API
In order to get the information we need, we have to reach the Google API through a URL. This URL is made by the scheme. In this case, HTTPS. The authority, www. googleapis. com. The path that is specific for the books API, which is books/v1/volumes. And the query string, a question mark, a q, an equal sign, and the title we are looking for. In this example, Android. If we put this URL in a browser, we can see that indeed we are connecting to the Google Books API and receiving data in JSON format. This text that we see in the browser is what we are going to put into the text view in our activity. In order to do so, we'll make a class to help us build the queries to the Google Books API. Let's call it API util. We'll remove the comments here. This class will only contain static methods and constants and will never be instantiated. So it's a good idea to remove the constructor. And we can do it like this. Private API util. Open close, open close, and that's it. Now, let's create a constant for the base URL of the API. We'll call it base API URL and we'll follow the Java convention to write constants O upper case. This constant will contain the part of the address that is not going to change. Now, we need to add a query for the title. So let's build a function that will help us create a proper URL. We'll keep it very basic for now. We'll just create a function that returns a URL. We need to import java. net. url in order to use it in our code. So let's press alt + enter to have Android Studio do this for us. And not surprisingly, we'll call this function build URL and takes a string as a parameter. This string will contain the title we want to query. Remember, the final result is what you see here. The base URL will not change. We have to add the variable part of the URL. We just create a new string that contains the base URL constant, the question mark, the q letter and the equal sign and the title parameter. Note, this is a temporary solution. And it is not the recommended approach to build a URL. But we'll fix that later in this module. Now, let's declare a URL and try to convert the string into a URL. Then we'll add a tricatch block and then the triblock will create a new URL based on the full URL string. In the catch block, we'll print the stack trace. And finally, we'll return the URL that we have built. Okay, now that we have the URL, we need to connect to the API. In order to connect to the API, we'll create a new method. We'll call it get JSON. It returns a string and takes as a parameter the URL we want to connect to. First we need to establish a connection to the URL that was passed. The object we'll use in order to do that is the HTTP URL connection. Note that a URL connection instance does not establish the actual network connection on creation. This will happen only when we try to read data from it. To create it, we'll call the open connection method on the URL. Because open connection can throw an IU exception, we could put this line into a tricatch block and this would be perfectly legal. But we can also specify the exceptions when we declare the method. So that it can be handled by the caller. We'll choose this second approach here. So we'll just add throws IU exception after the method declaration. Once we have the connection, let's try to read the data. We need to create an input string. This is a very flexible class that's allowed to read any data. The stream could be a file, a web page, an image, whatever. We just need to call the get input string method from the connection. Once we have the stream, as we are Json, we need to convert our stream to a string. There are several ways to do that in Android. One of those is using a scanner, which has the advantage of buffering the data and encoding the character to UTF 16, which is the Android format. So let's create a new instance of a scanner. + alt + enter in order to create a correct import. And let's pass it the stream as a parameter. The scanner can be used to delimit large pieces of stream into smaller ones. In this case, we will set the delimiter to backslash backslash A. Meaning that we want to read everything. And by the way, the backslash A parameter is a pattern which in turns is a regular expression. If you want to learn more about patterns and regular expressions, just follow the link below. Now, let's check whether we have data calling the has next method on our scanner. The has next function returns true if there is data and false if not. If there is data, let's return it. Otherwise, we'll return now. It would be a good idea to enclose this code into a tricatch block. So let's do that. In the catch, we can log the error. And in the final block, we definitely want to close the connection, calling the disconnect method. Let's not forget to return now in the catch block. Actually, we'd better put these lines of code into the triblock. Now that's better. And that's it. There's only one last step before we can verify that everything's working. We'll need to call this method from our activity and put the result into our text box. And that's what we are going to do next.

The Mistery of Missing JSON
In our book list activity in the on create method, let's build the URL first. We'll use a hardcoded string for now. Let's see we want to look for every book that has the word cooking in it. So we'll create a URL called book URL. And we'll call our method build URL passing cooking as an argument. Then we'll create a string called JSON result, calling our get JSON method and passing the URL. We need to put all this in a tricatch block as our get JSON function throws an IU exception. In the catch section, we'll just log the error. Next we need to write in the text view the result we got. So first, we'll get the text view. You may remember that we called it TV response. Finally, we'll write the result in our text view using the set text method. Okay, let's see what happens when we try to execute this code. Well, absolutely nothing apparently. This is not exactly what we wanted to achieve. Let's try to understand what's happening a little bit better. We'll stop the app and put a break point at the call to our build URL method. You can just click near the line number in order to do that. Then let's debug the app. You can also press shift + F9 to do that. Let's step over the build URL method. I'm confident the problem is not coming from them. And indeed, we can see that the URL has been built as we expected. So no problem there. Let's step into the get JSON method. Let's step over the first line and then the second. And we can see that this line is throwing an exception. We have a network on main thread exception. And we also have it in the log. Okay, let's have a look at this error on the Android Developer's Guide. And here we can see that what this means is that we are not allowed to perform any networking task on the main thread. Interesting. We'll try to understand what this means and how to deal with it next.

Introducing Threads and AsyncTask
We generally take for granted that our devices can do more than one thing at the same time. If you are listening to music on your smartphone, you also expect to be able to browse your playlist or adjust the volume. The thing is, in Android by default, when your app begins running, every single action is executed in a single thread, also called main thread, or UI thread. This basically means that until a task is completed, next task cannot begin. So in our app, while the network call is in progress, the user interface would be unresponsive. And we want to avoid an unresponsive UI at all costs because the user will get the impression your app is slow. And after five seconds, Android will ask the user if they want to kill your app. What we can do to solve this issue is creating different threads when we have long running tasks in our app. So that, for example, our network tasks run at the same time or concurrently as our main thread. In fact, concurrency is what happens when two or more tasks can start, run, and complete in overlapping time periods. But if tasks run concurrently, we need some way to interact between threads. In other words, when the network task completes, we need a way to tell the user interface that the results are ready. And this is where AsyncTask comes into play. This class allows you to perform background operations and publish the results on the UI thread. Here's how it works. When you extend an AsyncTask class, you can override four functions. OnPreExecute is called on the UI thread before the task is executed. You can override this function to set up the task. For example, showing a progress bar in the UI. DoinBackground is invoked on the background thread. This is the function where your long running tasks should be placed. In our app, this is where we'll put the network call to the Google Books API. Note that doinBackground is the only required method to extend this class. Optionally, onProgressUpdate allows you to display any form of progress in the user interface while the background task is still executing. For example, you could animate a progress bar. To invoke this function, you just call the publish progress method from the doinBackground function as many times as you want. Finally, onPostExecute is called when the doinBackground function completes. This is where you can pass the results of the long running activity to the user interface. AsyncTask is a generic class, which basically means you can choose the data type to work with. When you extend an AsyncTask, you need to specify data types for three parameters, params, progress, and result. Params is what you send for the execution. In our app, we'll pass a URL because a URL is what our class needs to connect to the Google Books API. Progress is the data type that you can use to publish the progress of your background task. In our example, we'll just pass void because we don't need to publish progress. And finally, result is the type of result of the background computation. When we call the API, we expect to receive some JSON text, which is a string, so we'll pass a string here. And to call your class, we'll call the execute method. Let's see all that in action next.

Demo: Using AsyncTask
Inside our book list activity class, let's create a new public class that extends AsyncTask. The first argument params is the type of the parameters sent to the task upon execution. So we'll put a URL here. Progress is the type of the progress units published during the background computation. And we don't need that, so we'll put void. Result is the type of the result of the background computation. So we'll pass a string as a result. You may notice that Android Studio is giving an error. This is because we need to implement the required method for this class, which is doinBackground. Just press alt + enter to make Android Studio create the doinBackground method. Android Studio recognized that we need a URL parameter in order to execute the doinBackground function. But you might wonder what are the three dots. Well, for the params argument, you can pass or more URL objects. The argument passed in this way is always an array, even if there is only one URL. So we need to make sure we treat it as an array within our function. The function returns a string because we specify that the result is a string. Let's remove the return now line. Now we'll get the first member of the array and put it in a URL that we'll call search URL. We'll declare the string that will contain the result. At the beginning, it will be null. And then in a tricatch block, we call our get JSON function. So the result is equal to apiutil. getjson. And we'll pass the search URL. And in the catch, we log the error. Finally, we'll return the result. Now, you may remember that the doinBackground does not execute in the main thread. So we have no access to the user interface. And therefore we need to implement the unpost execute method. Which will be called in the doinBackground has completed. So let's remove this line and here we'll copy and paste the code we have already returned to write into the text view. On the second line, instead of JSON result, the name of the string here is just result. And one last step. In order to call the AsyncTask, we need to instantiate the class and call the execute method. And we'll do that in the on create function of the book list activity class. So let's remove these lines that we don't need. So under the book URL line, we'll create a new books query task. And call it execute method. That's it. Now hold your ______beth because the big moment has arrived. We need to try the app. And we can see that we can download the JSON data and write it in the text view. Well done. Now, if this didn't work for you, I suggest you try and go back and see if you misspelled something and find the problem. But remember that if you are stuck, you can always access the completed code for this module in the exercise files. Now, there are a few smalls issues we need to fix before we move on. Let's have a look at those next.

Powering up the App: Using URI.Builder, ProgressBar, and Scrolling
In this moment our app has a few weak points. If there is no Internet connection or the device is in airplane mode or the query we passed contains invalid characters or the network task takes a long time, the user will have no idea what's happening. Just as an example, if we put our device in airplane mode and we try to read data, there will just be a blank screen. So let's follow a few best practices in order to build solid grounds for the future of our app. First, we'll use a URI. Builder class to help us avoid errors building the URI. Then we'll get an API key from Google. We'll notify the user when data is loading. And we'll show an error message to the user when something is wrong with data. You might also have noticed that our JSON is not scrolling. This is only a temporary text view. So we could ignore this issue. If you feel like, I leave it to you as an optional challenge to find a solution for that. I show you an incredibly easy solution at the end of this lesson. The first improvement in our app will be using the URI. Builder class instead of creating the URL using a string like we did in our previous demo. The URI. Builder makes it easier to create well-formed URIs. For example, it adds ampercents between parameters. And encodes correctly invalid characters. Now, you might wonder, what's the difference between a URI is a URL? To put it simply, the URL is a specific type of URI. A URI is a uniform resource identifier. While a URL is a uniform resource locator. So a URL is a subtype of URI. Or, in other words, every URL is a URI. But not every URI is a URL. A URL has the ability to locate a resource. Because there is another subcategory of URIs, URNs, or uniform resource names, which name resources but do not specify how to locate them. An example of URN is the ISBN code of a book which names the book but does not include any way to locate it. The key point here is that a URL is a URI so it makes sense for us to use the URI. Builder for our URL. And here's how it works. First you create a URI. Builder calling the build upon method. Then you can add as many query parameters as you need. For each parameter, we call the append query parameter method passing the parameter name and its value. Finally, we call the build method. This will actually return a well-formed URI. And once we have a URI from it, we'll create our URL. You can follow the link below if you want to learn more about URIs. Let's see that in action. We'll get back to the build URL method. First, we'll remove the code that used the string to build the URL. Then we'll create a URI. The URI. parse method will try to convert the string into a URI. On top of that, we'll call the build upon method that will construct a new builder. And then we'll call the append query parameter method that encodes the key end value and then appends the parameter to the query string. We'll use a constant. Let's call it query parameter key. And we'll create it in a moment. Finally, the build method will actually create the URI. Okay, let's create the constant. This constant just contains a lower case q. Now let's try to convert the URI into a URL. Okay, let's try the app. And we can see that's working correctly. As we are here, let's do something that's required by Google if you want to deploy the app. This will also have the side effect of having a much lower throttling so that we have much higher limits of usage. According to Google's conditions available at this link, the application must identify itself and the simplest approach for us is requesting an API key. In order to do that, let's enter the Google API's dashboard at the address you see here. You need a Google account in order to do that, but I guess that as an Android developer, chances are you already own one. If not, you can get one for free. Okay, from the Google API dashboard, open the credentials page. Now click create credentials API key. Now just copy the key so that we can use it into our app. And back to Android Studio, let's create a couple of constants. One we'll call key and put a value of key into it just to be original. And the other, we'll call API key. And we'll paste the key value we have just copied. Now, let's append a new query parameter to the URI. And just to check what's being created, let's put a break point here and start debugging. As you can see, the URL has been created correctly. And if we resume the app, we can see that our app is still working. Great job. We also want to tell the user when data is loading. There is an easy way to do that. And this involves using a progress bar widget. Let's get to the design view of our activity. Let's make this view a little bit more friendly. Okay, then let's select a progress bar. And then place it in the center of the activity. Then let's put a constraint on the parent in all first sides like this so that it's right in the center of the activity. We'll call it PB loading. Also, we want to make this invisible by default. We want to make sure that before we call the network connection the progress bar will show. And after the data is loaded, it is appears again. Let's get back to our book list activity and declare a progress bar member. Let's make it private and call it m loading progress. Then in the on create method, we'll get the progress bar from the activity layout. In the books query task class, we need to override the onPreExecute method. This method is called before the network call. And here we'll make our progress bar visible. Let's set the visibility of our progress bar to visible. And in the post execute, let's do the opposite. So the set visibility will be invisible. And let's try this out. Okay, it's rather fast, but I hope you could see it. Much better, right? We also want to tell the user when something is wrong and in order to do so, we can create another text view that in case of error will tell the user that something wrong happened. In our activity layout, let's add a new text view. The same position of the other controls. Let's create the constraints for this view as well. Let's call this TV error. And this text view will also be invisible. As for the text, we'll write error loading data from Google Books. It's always a very bad idea in Android to hardcode strings like this. So we'll use the alt + enter shortcut to extract the string. We'll give this resource the name of error data message. Just to make sure we wrote everything correctly, let's press control + click to get to the string's XML file that contains all the strings we'll be using in this app. Of course, you can also get there in the RES values folder. Back to the books query task class in our book list activity in the on post execute method, let's show and hide the TV error text box according to our needs. Let's get the reference to our TV error text view. If result is null, let's set the visibility of TV result to invisible and the visibility of TV error to visible. And we'll do just the opposite if result is not null. In order to try this out, let's put our emulator in airplane mode so that it cannot load data and try to run the app. And as I expected, the error is showing. Now let's put back to normal. Try it out again. And the JSON is showing. The very last improvement is the scrolling, remember? That's the incredibly easy solution I promised. In our activity layout, let's create a scroll view. For the width, we'll choose match parent. And for the height, wrap content. Then we'll enclose the text view into the scroll view. And when we try this out, we can scroll and scroll and scroll for hours. (laughs) Okay, let's wrap this up.

Module Summary
Well done. We have definitely covered a lot of ground in this module. We have seen the steps required to connect to a web service, including asking for permissions, building URLs, and leveraging the URI. Builder to build well-formed URIs. We have talked about threads and concurrency and seen the importance of putting long-running tasks away from the UI thread. This impacts dramatically the user experience. We have seen how to use concurrency in Android through the AsyncTask generic class and seen how to override its main methods. Hopefully now you fully understand how to connect an app to a web service. And this is great. Next we'll build upon this knowledge and see how to parse JSON content for our users to make our book list activity a little bit more user friendly. And that's the goal of our next module.

Parsing JSON Content
Module Intro
Hello, this is Simone Alessandria. Welcome to this module of the course, Building Your First Connected App With Android Studio. In the previous module we have seen how to connect to our web service, retrieve data asynchronously, and show the data in a text view. Happy as we may be for this great result, we must also admit that the user experience isn't the greatest so far. Our poor user would soon get lost in all the data we have put in the text view, so in this module we'll try to make our app a bit more user friendly, selecting the information we really want to show to the user and then putting it in a scrolling list. What we want to do is something like this, a scrolling list of books with title, authors, publisher and publish date, and a simple search function. This is the result we'll get at the end of this module. In order to achieve that we'll talk a little bit about the JSON format, and see how to parse it in Android, then we'll have a look at the RecyclerView in order to create an efficient list of items for our app. In our demo we also create our model class, select the data to show to the user, and add a simple search functionality. So let's begin with some JSON.

Parsing JSON in Android
JSON, or JavaScript Object Notation, despite the name is actually language independent, and many languages including Java contain code for parsing and generating JSON data. It's a text-based format made of key-value pairs, and today it is generally the preferred format to exchange data over the web, because JSON is easier to read than XML, and its structure is much lighter. Here you can see an example of JSON, each attribute or key is enclosed in quotes because it is a string. The firstName value, Paul, is also a string, and strings are enclosed in quotes. The colon character separates the key, or name from its value. Booleans and numbers are not enclosed in quotes, for number in JSON there is no distinction between integer, decimal, or floating-point, every number is just a number. Objects are an ordered collections of key-value pairs, they're delimited with curly brackets, and use commas to separate pairs, while within each pair the colon character separates the key, or name from its value. You can enclose an object within another object. Arrays are ordered lists of zero or more values, each of which may be of any type, arrays use square brackets with elements being comma-separated. Before we begin parsing the results in our app, let's have a look at an example of our books API result. Everything begins with a curly bracket that identifies the main object of the result. The part that we need to read in our app is the items element, and as we can see from the square bracket, it's an array. By the way, don't trust the totalItems value too much, at the time of this recording it's just an approximation of the real number of items found. Anyway, each element of the array is an object, in this case a volume, and when this object ends there is a comma, and then another volume begins. Now we want to retrieve the title of the book. As you can see, title, subtitle and authors are contained into another object called volumeInfo. Also, authors is an array, so we have to treat it as such from our code. Finally, still inside of volumeInfo, we want to retrieve the publisher and the publishedDate, so how do we parse JSON from Android? Well the procedure is relatively straightforward. First we need to create a JSON object from the string that we have retrieved from the API. We'll do this, calling the new JSON object and passing the JSON string to the constructor. Once we have the whole content of the result, we use the getJSONArray method of a JSON object to retrieve the array of objects that contain the books, and we pass the name of the array, in our case items as an argument. The array contains child objects, so after enclosing this line into a for loop, we can call that getJSONObject method of the array to retrieve a single object. Again, inside of the main object we have another child object called volumeInfo, and we can call the getJSONObject method again, this time passing volumeInfo as an argument. Finally we can retrieve a single string value calling the getString method, basically we'll need to serve the JSON result hierarchically, and we have a few get methods that give us access to the JSON content. All of them take the key string as a parameter and return the proper object. There is no distinction for the type of number in JSON, but when we parse a number into Java, we can use getInt or getDouble. You probably won't be surprised that there is also a getBoolean method to retrieve Booleans. Finally there is also a generic get method that returns a generic object, you can then parse it into whatever you need. Okay, I think that we are ready to put all this into code.

Demo: Parsing JSON
When dealing with data I generally like to create model classes, I find they make the code more readable, and easier to test and maintain. So let's create a Book class into the project. We'll keep everything very basic here for now, we'll only create a few public members and the constructor. We're interested in the title, subTitle, authors, and this is an array of strings, publisher and publishedDate. We'll probably add more members later on, but this is what we need for now. Let's only add an id, generally speaking it's a very good idea to have an id that helps us identify each item. Let's create the constructor, we'll make Android Studio help us with that. We'll just press the Alt + Enter combination to get the insertion templates, then we'll select all the fields and press OK. Now we have a book class with all the data we need for our activity, let's go parse the JSON result. In the ApiUtil class let's add a new function that will return an ArrayList of books. We'll call it getBooksFromJson. We'll declare an ArrayList of books and set it to null at the beginning, this is what we'll return at the end of the function. In Android it's considered a best practice to create constants instead of using strings in code, so let's create a few constants for the data we want to retrieve from our JSON string. So we'll create an id, title, subtitle, authors, publisher and publishedDate. Let's also add a constant for the items. Now let's finally parse our JSON, we'll create a try/catch block, and in the catch we'll just print the StackTrace. The first step is creating a JSON object from the JSON string. JSON is what we will be expecting when this function is called, so let's add it as a parameter. Now that we have the JSON object we'll get the array that contains all the books, we'll call it arrayBooks, and from jsonBooks we'll call the getJSONArray method, passing the name of the array, in this case ITEMS. Now we need to know how many books were retrieved, this can be zero or more. We can count the number of items using the length function of our JSON array, so we'll declare an integer called numberOfBooks, and we'll call the length method of arrayBooks. Okay, now let's loop through the JSON array, we'll create a for loop starting from zero until i is less than numberOfBooks, then we'll create a single JSON object and we'll call that bookJSON. We'll also get the volumeInfo object and we'll call it volumeInfoJSON, let's also create a volumeInfo constant just to be consistent. Now you may remember the authors are an array, so we need to count the number of authors, so int authorNum, we'll call again, the getJSONArray, this time passing AUTHORS, and we'll count the number of authors with length, then we'll create an array of strings that will contain the authors, and then again let's loop through the authors and add the author names to our string array. This time we'll use the get method, and then parse it to a string with the toString method. Now let's create a new book, retrieving all the data we need. We'll use the getString method to get the ID and TITLE. The SUBTITLE key may not be there at all, so we'll use a ternary operator saying that if the subtitle is not there, we'll just pass an empty string, otherwise we'll read the subtitle. Then we'll pass the author, the publisher and the published date. Then we'll add our new book to the books list array, we'll write in the text view only the data that we have retrieved parsing the JSON. Let's get to the onPostExecute method of the BooksQueryTask class inside our activity. We'll get an array list of books, calling the getBooksFromJson method. We'll create an empty string as a container for the result, let's call it resultString, and then for each book, we'll take the title and the publishedDate. Finally let's write the result in our text view. One last step, instead of setting the books array to null, let's set it to an ArrayList of books. Let's try this out. And now this works, but I believe our user deserves better than that, both for functionality and user interface. With a text view it would be very difficult to select a single item to view the details of a single volume. Also let's face the hard truth, this UI is really ugly, (laughing) so in order to make our app a little better we'll use the RecyclerView next.

Using the RecyclerView
A RecyclerView is a flexible view for providing a limited window into a large data set. To put it simply, a RecyclerView is a scrolling list of data that allows you to create a series of views that can have different formats and sizes. One of the interesting features of the RecyclerView and the reason behind its name, is that it deals with memory usage very efficiently. When a Recycler view is created, it can contain several thousands, even millions of rows, so instead of creating all of them at the same time and loading them into memory, the RecyclerView only creates the items that need to be displayed on screen, and then uses a queue. There is a separation between the views and the data they contain, the views are created first and put in memory, and then they are filled with data. A view previously used to display data may be placed in a cache to display different data later on, so when you scroll the list, Android does not need to create new views for each row, but it just fills the same one with new data, recycling the existing views. The advantages of this approach are that our app does not need to load all the objects and data at the beginning, and does not need to create or inflate new views each time the user scrolls your list. Let's take a look at some of the moving parts we need to implement in order to use a RecyclerView. The RecyclerView contains data, so it needs to connect to a data source. This can be a database or a web API, or any other data source that comes to your mind. In order to get data from a source we'll need an adapter, the adapter will send data to the RecyclerView with an object called ViewHolder. The ViewHolder describes an item of the RecyclerView, in our app this will be a single row of data containing the book or volume information, and also contains information about its place within the RecyclerView. Adapter and ViewHolder work together, the Adapter should subclass the ViewHolder to load the views, and then bind data to the views. ViewHolders get cached to make scrolling smoother because the find view by ID methods gets called only when an item is created, and not each time it's updated. Finally we have the LayoutManager, we can use this in order to decide how the items are displayed in our RecyclerView. In our app we'll use the LinearLayoutManager, and scroll the items vertically, but there are also other options. We'll take a look at those during our demo. Speaking of which, I believe we are now ready to get back to our books app.

Creating a RecyclerView Item
In this demo we'll define our list item layout, which is a row in the RecyclerView, then we'll create the RecyclerView itself and use the data we have selected from the Google Books API through an Adapter and the ViewHolder, and finally we'll use a LinearLayoutManager to create a vertical scrolling list in our activity. First we'll create our list item layout, this will be a single row inside of our RecyclerView. It will contain an icon, the title of the book with a large font, authors, slightly smaller, publisher and publishing date. As this is relatively simple, we'll just use a combination of nested linear layouts, so let's create the layout in our app. From the res folder let's create a new layout resource file, we'll call it book_list_item. Switching to the text view will change the orientation to horizontal, because our row will contain an outer horizontal linear layout, one for the icon, and one for the text elements. So let's find the icon. When looking for icons I like to use the materialdesignicons. com website, it contains several 100 open source icons that you can use for your project, but for private and commercial use. In case of doubts about the license, have a look at the link below. The icon we'll choose is called book-open. Let's click on it, and then let's select View Vector Drawable. Vector drawables are actually graphics defined with XML. Let's select the content of the file and copy it, then let's create a new drawable resource file in the drawable folder, we'll keep the name book_open here, and then paste the content we have copied previously. The only thing we want to change is the fillColor property, and for that we use the colorAccent of our app, which in this moment is an awesome pink. By the way, colors are defined in the colors. xml file in the values folder, here you can change the existing colors and add new ones, so feel free to play a little bit with them in your app. Next we'll place the icon as the first item of our horizontal linear layout. We'll give the ImageView the height and width of wrap_content, and a padding of eight dps, then we'll next a second linear layout for the text views, this time with a vertical orientation. There is an interesting way to decide the relative size of elements inside of a layout, in this case let's say that we want the icon to be approximately 15% of the available space, and the text views to be 85%. What we can do is giving the outer linear layout a weightSum of 100, the ImageView a width of zero dp, and a layout_weight of 15, and the nested linear layout, a width of zero, and a layout_weight of 85. Inside the nested linear layout, the first item we need to add is the title. It's a text view, set the width to match parent and the height to wrap_content, we'll call it tvTitle. The textColor to PrimaryDark, and the textSize to 20 sps. We'll also specify a text, just to make it visible in the design view, and let's have a look at the design view, we can see that our row is beginning to take its shape. It is never a good idea to hard-code dimensions in the layout files, so let's click on the bulb near the textSize property and select Extract dimension resource from the menu. Let's call it title_size. Under the Title TextView we'll place the authors, we can copy and paste the Title TextView, as we only need to change the name and font size to tvAuthors and 18. We'll also extract the resource here. The last row of the layout contains two different TextViews, one for the publisher and one for the published date, so we'll create the last nested linear layout with a horizontal orientation, we'll set the weightSum property to 100, and this is, again, the sum of all the elements inside this linear layout, and then we'll create our two TextViews, one for the publisher and one for the published date. For the publisher we'll give a layout_weight of 70 because we want the publisher TextView to use 70% of the available space. We'll also change the alignment so that the publisher has a left align. Let's write some text to see this in the design view, and let's not forget to give it a width of zero dps. For the published date we'll copy and paste the publisher TextView, changing the id to PublishedDate, the weight to 30, and the alignment to be a right alignment. As a final touch let's add a little bit of padding for the date TextView, so we'll use paddingEnd and paddingRight. We'll also extract this as published_date_padding. Okay, let's have a look at the design view, and the result is what we expected. Okay, we have now created the layout for our RecyclerView item, which is a single row of what we'll see inside the RecyclerView. Now let's create the Adapter next.

Demo: RecyclerView in Action
We'll add to our app a new class, called BooksAdapter. Inside that let's create the ViewHolder first. We'll create a public class called BookViewHolder that extends RecyclerView. ViewHolder. As you can see, Android Studio is telling us that we have a problem, this is because we need to have a constructor here, so let's press Alt + Enter to have Android Studio write it for us. Let's declare our TextViews as members of the class. We have the Title, Authors, Date and Publisher. In the constructor we'll call the findViewById method for each TextView, so we'll do this for the title, the authors, date and publisher. Now we'll create a method called bind that will take as an argument a book. In this method we'll bind the book data to the text views we have defined, we'll begin with a title. As authors is an array, we'll first define a string to contain all the authors, and then for each author in the array, we'll add a new author to the string, and if the author is not the last one, we'll also add a comma and a space. We'll set the text of the Authors TextView to our string, and then we'll do the same for the date and publisher. That's it, this is what a ViewHolder does, it defines the views and binds the data. Now in the adapter let's extend the RecyclerView. Adapter of type BookViewHolder. The adapter needs a few methods to be implemented, so let's press Alt + Enter again and select Implement methods, and press OK. onCreateViewHolder is called when our RecyclerView needs a new ViewHolder, onBindViewHolder is called to display the data. We also want to create a constructor that takes an ArrayList of books as an argument. Let's also define an ArrayList of books that we'll use throughout the class, and inside the constructor let's set our books to what's passed to the constructor. In the onCreateViewHolder method we need to inflate the row layout that we have defined in the previous lesson, so let's get the context, then let's create a view called itemView. This will use the LayoutInflater, and from the context call the inflate method, passing the book list item layout as a resource, the parent as the root, and false for the attach to root value. Finally we'll return a new BookViewHolder, passing the itemView. In the onBindViewHolder method we'll just get the book and the current position, and then bind it to the holder. Finally for the getItemCount method, let's return the size of the books ArrayList. Okay, in order to complete this part, we only have two simple steps, we need to delete the TextView from our activity, we don't need it anymore, and place a RecyclerView, and then we need to write the data into the RecyclerView through our adapter. So from our layout let's remove the TextView and add a RecyclerView that will take all the space of the screen. Let's call it rv_books. In the design view let's add a few constraints so that the RecyclerView is correctly shown in the activity, then from the Activity class let's create a RecyclerView called rvBooks, then in the onCreate method let's assign the RecyclerView, then we'll remove the TextView, create a new book adapter called adapter, and pass it the books ArrayList. Now let's call the setAdapter method of the RecyclerView, and pass it our adapter. We also don't need the for each loop anymore, so let's just delete it. Before we try this out, we still need to make a couple of changes in the onPostExecute. Let's remove the tvResult calls, and set the visibility of our RecyclerView instead. Finally let's create a new layout manager, it will be a LinearLayoutManager, and predictably called booksLayoutManager, and let's pass the context, this, define a vertical orientation, LinearLayoutManager. VERTICAL, and false. Finally let's set the layout manager for our RecyclerView. Now let's try this out. Okay, we can see that we are close, but we still need to change the height of the book list item layout to wrap_content. Okay, this is better, we also need to resize the RecyclerView to match_parent, and here we are, this is done. The last function we want to implement in our app for this module is the search function, and we'll do that next.

Demo: Using the Search Widget
The last function we want to implement in our app for this module is the search function. In order to do that, we'll use a SearchView widget, this will allow us to enter and submit our search to the Google Books API, without the need to create another TextView in our user interface. In our project, first we'll create a new menu item that will contain the search widget. In the res folder, let's create a new Android resource directory of type menu. From there we'll right-click and select New, Menu resource file, and we'll call it book_list_menu. Let's create a new item inside of the menu element, we'll give it an id of action_search. As a title we'll use search for now, in a moment we'll create a string resource for that. In order to use the SearchView widget, we'll use the app actionViewClass property. Let's add the app namespace to our file, as a value we'll put android. support. v7. widget. SearchView, all this will make sure that our app is compatible with older versions of Android. Finally we'll give the showAsAction property a value of always, so that we have the search icon always visible on the action bar. Now we are ready to create a string resource for the title property, we'll open the strings file in the values folder, and add a new string with a name of search, and a value of search. This is to make it easier to change values in our app, especially when we need to translate the app in other languages. We'll get back to the BookListActivity, here we'll override the onCreate options menu function to specify that we want to use the book list menu in this activity. Let's remove the call to the superclass, and there we'll call the inflate method of the menu inflater and as a resource we'll pass the menu we have just created. Then let's get the action_search menu item, and then call the getActionView method that will return the search action view that we set for this menu. Finally we need to call the setOnQueryTextListener to respond to the user actions, but in order to do that we also need to implement the OnQueryTextListener interface that requires two methods. onQueryTextChange, and onQueryTextSubmit. We're only interested in the onQueryTextSubmit method for now, as we only want to search books when the user submits their search string. We'll build a try/catch block, and in the try section we'll just build the URL, passing the query that the user has submitted, and execute the search on this URL. In the catch we'll only log the error. Let's try this out. In a spark of creativity, we'll search for Android Programming, and indeed it works, good. We covered a lot of ground in this module, we have seen how to parse JSON content in Android, and access objects, arrays, strings, and other values hierarchically. Then we have seen the main moving parts of the RecyclerView and seen how this is a very efficient way to create lists. Finally we have seen how to use the SearchView in our activity to add a necessary functionality to our app, in an efficient and user-friendly way. In the next module, we'll build upon these features to make our app more complete and interesting by adding a detail activity with more data, and book cover images.

Showing Images and Using Parcelable Classes
Module Intro
Hello, this is Simone Alessandria and again, welcome to this module of the course building your first connected app with Android Studio. The title of this module is Showing Images and Using Parcelable Classes and we'll certainly do what the title suggests but this is just the beginning. If you have followed me up to this point, you know that our app has a single activity with a list of books taken from the Google Books API. What we'll do in this module is creating a second activity so that when the user clicks on one of the books in the list, they will see the book details that will contain the information we could see in the list plus the book cover, the subtitle, and the description of the book. We'll build the second activity using the constraint layout in a matter of minutes. And most of it will be using only the Android Studio graphical tools. In order to pass the information from the recycler view to the second activity, we'll have a look at intents and see how to pass objects from one activity to the other. And in doing so we'll talk a little bit about the difference between the Serializable and Parcelable interfaces and write the code to actually implement the Parcelable interface. Next we'll have a quick introduction to the Android Databinding Library which is a very elegant solution to avoid the abuse of the find view by AD method. And finally, in order to load the book cover image, we'll use a great library called Picasso. Ready? Let's go.

Using the ContraintLayout
The ConstraintLayout allows you to create large and complex layouts without the need to use nested view groups. Well truth be told, our detail layout won't be that complex but we'll still be able to save a lot of time designing it with a ConstraintLayout. This layout was introduced in Android Studio 2. 2 and in 2. 3 it has become the default layout when creating new projects. If you have designed user interfaces with Android Studio before, I'm sure you love that one. The idea is that you can build a user interface with a ConstraintLayout almost entirely by drag-and-dropping instead of editing the XML. I guess it will be easier to see than to explain so let's get back to our project. If you want to follow along and you haven't completed the previous modules, you can download the project from the exercise files. What we want to do is create the layout for our book and this will give us the opportunity to dive a little bit deeper into the ConstraintLayout. So let's create a new empty activity for the detail of the book. And we'll call it BookDetail. If you open the XML of the activity you can see that the default root element is the ConstraintLayout. Remember that our final result should look like this. We have a total of seven elements. Title and subtitle at the top. Then an image for the book cover and three other smaller text views. And the description at the bottom. In the design view, let's arrange the space so that we can see everything properly. We'll begin by dragging an image view from the toolbox to the layout. We'll choose the book open image for now. You can see that we now have two windows. The blueprint view and the design view. And we can switch from one to the other. Or use both at the same time. The difference between the two is that the blueprint shows only outlines for each view and the design displays a color preview of your layout. Let's use the blueprint for now. The four circles you see here are the four constrained handles. They define the position of the object in the space and relative to other objects. So for example, if we wanted to bind this image view to the left side of the ConstraintLayout, we could just take the left handle of the view and drag it to the left border of the layout. If we take the right handle and drag it to the right border of the view, we get a centered image. You can even decide whether you want to give a different weight to the left or the right side dragging the horizontal by its bottom. A couple of rules here. You should define at least two constraints for each object. One vertical and one horizontal. If you forget to define a constraint, the object will go to position zero. So to the top for vertical and to the left for horizontal. And the second rule is that each handle can be used for a single constraint but different views can get to the same anchor point. The interesting part comes when we put more elements in the layout. Let's bring a text view into play. Let's say this will be the title. It has the same four handles so that I can bind it to the left, right, and top. Let's say that we want the image to be bound to the text view for its top alignment. We can do this putting the top handle to the text view. Now let's say we changed our mind as we realize that we need another text view under the title for the subtitle. We can just delete all the constraints with the button here. Let's add another text view with constraints to the left and right borders and a top constraint to the other text view. We can begin giving a few names here. The first text view will be called TV Title and the second, TV Subtitle. The image will have an ID of imgCover. And we'll have a constraint to the subtitle text view and to the left borders. Let's also make it a little bit bigger. Like this. Now let's add three more text boxes. For the authors, publisher, and published date. The authors will have a constraint to the subtitle at the top and to the image at the left. The second and third text boxes will have the same left constraint and at the top we'll just use the other text view. Like this. If you have designed activities in Android before you probably realize how this method makes designing the UI much easier. The only property we are setting right now is the name. So the first text view will have an ID of tvAuthors. The second, tvPublisher and the third, tvPublishedDate. Let's insert one last text view that will contain the description of the book. This will stay under the image. Let's change a few properties from the XML view of the editor. You may notice an error in the XML if we hover over it, we can see that we need to make a small change in the build dot gradle file in order to use the support library for vectorDrawables. So let's do this. And then sync the project. When we go back to our activity XML, you'll notice that the error has disappeared. Let's simplify our margins. We'll just use one value, 16dp's for all our margins. Let's extract the value and call it standard margin. Then we'll apply this margin to all the elements in the activity. Then let's make the title bigger. Let's say that the text size will be 36 sp. The subtitle will have a text size of 24 sp. The authors, 18. And the other text views will be 16 sp. We want the title to take all the available space horizontally but match parent is not supported in the ConstraintLayout. So we can just use zero dp to match the constraint. And we'll do the same for the subtitle. And that's it. Our layout is ready. Now we need to call it from the book list activity and pass the book object that the user selected. This is what we are doing next.

Passing Data with Parcelable Objects
As you maybe already know, you can start a new instance of an activity by passing an intent to the start activity method. You can use intent for a wide variety of tasks. Here we'll use it to start the BookDetail activity. Here's how it works, you create a new intent passing the context and the name of the activity you want to start. Now things get interesting when you want to pass data from one activity to the other. If you only need to pass basic data, like integers or even strings, you can use the putExtra method that takes key value pairs. But what if we want to pass objects between activities? In this case, we have two options. Serializable and Parcelable. They are both interfaces but Serializable is a standard Java interface. Parcelable is an android interface. Also, Serializable is very easy to use. You just need to add implements Serializable to the class you want to pass. Whereas Parcelable requires some code. Nothing incredibly difficult but still, some code. At this point you might wonder why should you ever use Parcelable? The main difference is speed. The reason why Android developers chose to create an alternative to the Java Serializable interface is that Parcelable can be up to ten times faster. Like with many programming issues, this is debatable in some circumstances but we'll stick to the basics here. Generally speaking, Parcelable is really much faster. This is how it works. First we need to implement the Parcelable Interface. This interface requires two methods and a static field called Creator. Creator is used by the Android operating system to recreate the object and generates instances of our class from a Parcel, which is a container used to pass data. The two methods are describeContents, which returns an integer, and writeToParcel, that returns voids. This CreateContent we can safely ignore. If you want to learn more about how to use this particular method, have a look at the link below. The writeToParcel method is where you write the values that you want to save to the Parcel, which again, is the container of the data we will be sending from one activity to the other. I actually have some good news for you. Android Studio will be writing most of this code for us. But as we'll make a few changes, here and there, it's important to know what we are doing. Back to our app. Let's first implement the Parcelable interface. Then let's implement the required methods. And let's also add the Parcelable implementation. Actually, that's it. Let's have a look at what happened. First we implemented the Parcelable interface and then we made Android Studio help us with the steps of building a Parcelable class. We now have a constructor that takes in a Parcel and from that populates our members. We also have the Creator, which calls createFromParcel method, returning a new book that calls the constructor passing the Parcel. The writeToParcel method takes a Parcel and an int for additional flags and flattens our book to a Parcel. When we click on the list, we want to get to our new activity. So the first thing we want to do is go to our BookViewHolder class and implement an OnClickListener. Let's also press alt plus enter and implement the onclick method. Then in the constructor, we'll set the listener. And in the onclick method, first we'll retrieve the position of the item that was selected. Calling the getAdapterPosition method and then with the position, we'll get the book that was clicked by our user. Then we'll create an intent. Using the context of the view that is passed to the function and the destination, which in this case is the BookDetail class. And then let's make use of our Parcelable class calling the putExtra method of the intent. And finally let's call the startActivity method. Then in the BookDetails activity, let's read the book from the bundle. Calling the getParcelableExtra method of our intent. To make sure everything is working correctly, let's put a break point here and start debugging our app so that we can have a look at the book object that gets passed. On the emulator, let's click on any book in the list and when our break point gets triggered, in the variables window, let's open the book object. And indeed, the book contains all the data we expected. Good. Now we need to write the content of the book object into our user interface. And this is what we'll do next.

A Simple DataBinding Example
In order to write the content of the book object into our user interface, we could declare each text box, find it with a find view by ID method and assign each property. Truth be told, this would actually be okay for a small app like the one that we are building. But we have already seen how to do that before so we'll do something better. We'll use the Data Binding Library. This can seriously help you reduce all your plate code in your apps. The Data Binding approach is different from the find view by ID approach. In Java we don't need to interact directly with the views, we just need to have an object, in our app it's a book, and in the XML we'll call the members of this object to populate automatically values like the text of our text views. And user interface will update automatically when we change objects. Interesting right? Let's see the main steps involved in order to use the Data Binding Library. First we need to enable Databinding in our app. And we'll do this in our gradle configuration file. Then you usually need to create model classes. In our app we already have the book so we'll use it and we won't need to change it in order to use the Data Binding Library. The only changes we'll make will be because we need to retrieve more data from the Google Books API. Then we'll update our layout files. We need to tell to our views which data they need to contain. And finally, we'll also update our Java code in order to set the bindings and make all the magic work. Getting back to our app, in the build dot gradle, let's enable dataBinding. No need for much explanation here. Let's just sync our project in order to be able to use dataBinding. Next we'll have to make a small change in our activity XML code. When you use dataBinding, you need to start the activity with a layout route tag followed by a data element. So let's create the layout node and delete the duplicate name space declarations below. Then we'll create the data node. The data elements describe the data available for binding. In our case the data will contain a variable element with the name of book and the type of com dot example dot books dot book. The great thing about data binding is that we can use any Java class as a model. So in this case we'll use our book class and we don't need to make any changing to it. As once loaded the book is not going to change. The name property is the way we will call the element inside our code and you're free to use any name that makes sense in your code. We could call this foo and it would work fine. The type is the actual object we are using for the binding. The meaning of this is when this activity is called, it will include an object of type book. This object will contain members and properties and I want to bind this property to the user interface. Let's close the layout element that we left open. So how do you bind the object members to the layout elements? Using the at sign, with curly braces. So let's say that the tvTitle text view should contain the title of the book, we'll use the text property of the text view and inside the quotes, we'll put an at sign followed by brackets. Then the object name, in this case book, and the member I want to bind. Title. And we can just do the same with subtitle, authors, publisher, and published date. We'll ignore the image for now. This is something we'll see in the next topic. But we need to add the description to our book class. First we'll create the description member. But this isn't enough. We need to add the description in the book constructor. And set the description member. As we are here, let's also simply file a little bit our authors array. Actually using an array with a data binding library would require too much of an effort. So let me show you a little trick. First let authors be just a string. There's a very nice class called TextUtils that among other methods, contains a static method called Join that takes an iterable, like an array, and returns the string. They're limited by any sequence of characters you need. We'll use a comma and a space. Now we have a string instead of an array. It is that easy. Let's also change the authors in the constructor that takes the Parcel. So we'll use the read string method instead of create string array. And we'll also update the writeToParcel method. So let's add the description in the writeToParcel method and in the constructor that takes the parcel. And the book class should be okay. Now let's get to the API util class. As you could expect, we have an error, as the constructor has changed. Let's create a description constant. And add it to the book object creation. In the book adaptor class, we have to fix the bind method in the part that was using the array to populate the authors. We can just remove the four loop from here and then pass directly the authors member of the book object. The last step required to use data binding is activating it in the activity. Android Studio has created automatically a class called activity book detail binding. Which is the name of the layout files converted to pascal case plus the binding suffix. This happens whenever you update the layout files to use data binding. From this class we call the data binding util set content view method, passing the context and the layout file. And finally we'll pass the current book to this object. The very last step is putting the description in the layout file. And we are ready to test our app. And it's working. That's great. And we have a very last step. What if the description does not fit in the screen? We wouldn't be able to see the whole description. You might have already guessed the fix. We can just add a scroll view to our layout. Let's add it. Just before the ConstraintLayout, giving it a width and height of match parent. And then close it at the end. And that's it. This is done. Let's try it out. Okay. I said that everything's done, well, almost. We still need the cover picture. Well, I guess you'll have to bare with me a little longer. But thanks to the Picasso Library, it will be a piece of cake. Or maybe, given the name of this library, I should say a piece of art actually.

Using the Picasso Library and BindingAdapter
If we had to load an image writing our code from scratch, we would have to deal with a lot of issues. A syncrin is loading, caching, resizing. Fortunately for us, there are a few great libraries that do all the heavy lifting for us. One of those is Picasso. Which in this case, is not the great Spanish artist, but an incredibly useful Android library that provides caching so that you don't have to download the image every time. A placeholder while the image is still downloading and resizing and visual effects like cropping, centering, scaling. But the best part is you only need a single line of code to use it. In the slide, you can see the most basic example of using Picasso. You just need to specify the context, pass the URL to the load method, and point to the image view you want to load the image into. Now the question is, as we are using data binding, how do we pass the URL of the image to the image view in our layout? When we just need to pass some text to the view as you saw previously, data binding can really save you a lot of boiler plate code and make everything cleaner. But for the image, we need something different that allows us to be a little bit more flexible. The data binding library contains exactly what we need. Which is the binding adapter. This will allow us to manage how values should be set to views with expressions. It works like this. You write a binding adapter annotation and you pass the attribute name that you'll use into your XML code. Then we'll need to write a method that takes to parameters. The first parameter is the type of view we are using and the other one is the value that will be set as the attribute. This feature will allow us to pass the URL of the book cover image right from the Google Book's API Library. Let's see all this in action. First we want to add the dependency for the Picasso library in the build dot gradle in the dependencies section. At the time of this recording, what we need to write is compile, come dot square up dot Picasso collum Picasso collum 2. 5. 2. And then let's sync our project. In our book class, we need to add a member for our image. We'll call it thumbnail. Basically we'll repeat the steps we followed for the description. We need to add the thumbnail to the contractors. The first that takes the strings. And the second that takes the parcel. Then let's also update the writeToParcel method. And the book class is ready. Now let's get to the API util. We'll create a couple of constants here. The JSON result we get contains an image links object that contains the thumbnail we are looking for. So let's write a couple of constants to help us get there. The first one will be for the image links object. And the second for our thumbnail. Then in the four loop that reads all the books from our result, let's add the JSON object. That we'll call image links JSON. That will take the image links object. Then when we create the new book, let's get the string that contains the URL of our image. Okay, back to the book class. Let's create our binding adapter. We'll call this through the Android collum image URL attribute in our XML. We create a method called load image. Taking in the image view and the URL. Inside the method we'll use the Picasso library. With the context of the view that gets passed, we load the image of the URL that was passed. And we'll use the book open image as a place holder. All of this will be loaded into the view. Now let's use the image URL attribute to pass the thumbnail member. And then let's try our app. Beautiful, isn't it? Now, because the colors seem a bit monotonous here, let's change the text color of the title text view to color primary dark. And the text color of the subtitle to color primary. For the authors we'll us the color accent. Let's try this out one more time. I think we can be quite happy with the result. Also, because we covered a lot of ground in this module, after playing with the Constraint Layout, we have seen how to implement the Parcelable interface. Then we have seen a nice example on how to use the Databinding library in our apps. Then we have seen how to use the binding adapter annotation to make data binding incredibly flexible. And finally, we have seen how easy it is to add images to our app with the Picasso library. About data binding, we have seen a very basic example. If you want to learn more and see a different example of data binding, you can have a look at my other course here at plural site, building your first Android database application with SQLite. You'll find a full module there on data binding and references to other resources. Right. Our app is almost ready. In the next module we'll add a search activity and a little polish here and there.

Saving Data with SharedPreferences and Recap
Module Intro
Hello, this is Simone Alessandria and again, welcome to this module of the course Building Your First Connected App with Android Studio. Our app is almost ready but before giving it to our users we'll add a new feature, an advanced search function so that we'll be able to search books by title, author, publisher and ISBN, and as you can see from the title of the module we'll also save the queries our users do with an object called SharedPreferences. This is what we'll be doing in this module. First, we'll create a new activity for the advanced search. Then we'll see how to work with SharedPreferences, an easy-to-use object that lets you persist data even after your app is killed. And finally, we'll see how to create menus dynamically using Java and while adding the new features to our app, we'll also apply some fixes here and there. Okay, let's begin by creating our new activity.

Creating an Advanced Search Activity
The first step is creating the activity that will allow our user to search through the Google Books API. We'll need four edit text views and a search button. So, let's select new, activity, empty activity. We call this SearchActivity and click finish. Once the activity has been added to our project, we'll change the root element to LinearLayout and set orientation to vertical. Then, switching to the design view, let's set four EditTexts and the button. We'll just drag them from the toolbox. Let's switch to the XML in order to change a few properties. We'll remove all the texts from the views and rename them, etTitle, etAuthor, etPublisher and etISBN. ISBN means International Standard Book Number and is a unique book identifier. An ISBN is assigned to each edition of a book. We could say that an ISBN is the primary key of a book all over the world. We'll also change the ID of the button to btnSearch. Now let's set some margin so that the text boxes are properly spaced. We'll give a margin of 24 DPs to the title EditText, then extract the dimension resource calling it margin_search_activity and assign this to all the EditTexts and the button and give it a text of search using the string resource we created previously. Now, let's create a few strings that will help the user understand what these text boxes are for. We'll be using the hint property. So, let's get to the string's resources file in order to write our hints. The first we'll call hint_title and specify a value of insert title. The second will be hint_author and the value will be insert authors, the third, hint_publisher with a value of insert publisher and the last one hint_ISBN insert ISBN. Then let's use the hint property of each of our EditTexts, so we'll do this for the title, the author, the publisher and the ISBN. Okay, let's have a look at the result of our work and we can see that we really need to make the button a bit nicer. We'll use a shape object. A shape in Android is an XML file that defines a geometric shape. We'll be using a rectangle with rounded corners but you could also use a shape to draw ovals, lines and rings. Let's create a new drawable resource file in the drawable folder. We'll call this search_button_shape. In the XML we'll create a shape element. It will be a rectangle. Inside the shape we'll put a corners element with a radius of 50 DP. Let's also add a solid element so that we can specify a color for our shape. We'll use the colorAccent here. Right, our shape is ready. Now, back to our search activity, let's change the button a little bit. We'll make sure that both the height and the width of the button have wrap_content as their value. For the layout_gravity property we'll specify center. Now, let's finally use the shape. We set the background attribute to the search_button_shape and the textSize to 18 SP. As usual we'll extract the dimension calling it search_button_text_size. Okay, let's have a look. We'd better change the text color of the button to white and also the margin should probably be a margin top instead of margin so that we can reduce a little bit the distance between the views. Again, let's have a look and that's definitely better isn't it? At this time our activity cannot be reached during the execution of our app. So, we need to add a menu item to the book list activity menu. We'll call it action_advanced_search. Give it a tile of Advanced search and extract the string resource. And we'll not show this as an action. Next we have to respond to the click event on the new menu item and create an intent to launch our new activity. So, let's override the onOptionsItemSelected method. Let's write a switch statement checking the value of the selected menu item. We'll have two cases. The first is for when the selected item is our advanced search menu item and the second is the default case where we'll just copy the call to the method on the parent class. Then we will create the intent that uses this as a context and the SearchActivity class as a destination. Let's call the startActivity method passing the intent and let's return true and then let's quickly check if everything is working as expected. And indeed, when we open the menu and click on advanced search, our new activity's showing. Nice. Obviously right now this activity's doing nothing. What we want to do here is build a query based on the content of the EditTexts and execute it to show the results in the list book activity class and that's what we are doing next.

Creating Dynamic URLs and Bug Fixes
When the user clicks on the search button, we have to create a string that we'll use to query the Google Books API. Let's have a look at the Google Books API Guide at the link you can find below. As you can see the queue parameter we have used up to now searches for volumes that contain this text string as a generic search but there are keywords you can specify to search in particular fields and the ones we are interested in are intitle for queries in the title, inauthor, inpublisher, and isbn. What a lucky coincidence, exactly what we need. So, in the API util let's create a method that will build the URL with all the data we inserted in the views. It will take four strings, title, author, publisher and ISBN. Before we begin let's create a few constants we'll use to build the URL. The first one will be for the title and to make things a little bit easier for us, it will contain the parameter required by the Google Books API and a column. We'll do the same for the author, the publisher, and the ISBN. Let's create a variable for the URL. It will be now at the beginning. Then we'll create a new string builder. If you haven't used it before, a StringBuilder is generally recommended when you make changes to strings. Even if it isn't obvious using them, strings are actually immutable. Each time you append a sequence of characters to a string, Java will create a new object and return it and this obviously should be avoided for performance issues. Let's begin with a title. If the title parameter is not empty, we'll append to the StringBuilder object the title content that contains the field in the Google Books API, the title that was passed and a plus sign for the query string. We'll do the same for author, publisher, and ISBN. Next we'll remove the last character, the plus as after every part of our string we are adding the plus sign which is not required at the end of the query string. Now our StringBuilder is ready. Let's convert it to a string. We'll call it query. Then we'll build the URI like we did previously. We'll parse the BASE_API_URL constant called the buildUpon method and append our newly created query and our key. Then we'll call the build method. Finally, in a try catch block we'll try to build a URL from the URL we have created. Otherwise we catch the exception and print the Stack trace. In any case, we are returning the URL that will be now in case of error or contain the URL complete with our query in case of success. We need to call this method from the advanced search activity. In the onCreate method first let's retrieve the EditTexts. We could actually do this with a data binding library but let's keep this very simple. So, we'll call the findViewById method for etTitle, etAuthor, etPublisher, etISBN and finally, for our button. Then we'll add a ClickListener on our button because everything we do here will happen when the user clicks on the button. Here we'll read the content of our views and put them in a string. We'll follow the same order of our declaration, so we'll begin with the title. We'll also call the trim method that deletes any space you might have at the beginning and end of the string. There are some people that have what I call a compulsive space click problem. Whenever they write something, they click the space at least once, often more, well, they won't be able to hurt our app. Okay, let's do the same with author, publisher and ISBN. These might have clicked without filling any text, so let's check if everything is empty and if it is, we'll give a message to the user. Let's write the message in the strings resource file. We'll call the string no_search_data and the message will be please insert valid search terms. Back in Java let's retrieve the string and then create a toast with our message. Now, if at least one of the strings is not empty, we need to call the BuildURL method we have just created passing the strings. Then we'll create an intent to get to the book list activity and pass the queryURL we have just created as an extra and then call the startActivity method. At this time the book list activity cannot read any extra so it will just ignore our query. Let's fix that. In the unCreate method we'll get the intent and the string. If it's empty or null, we'll just build the URL with cooking like before, otherwise we'll create a URL from the string we have passed as an extra. Then we call the book query task, great, almost there. Before we try our app to see if everything is working as expected, we need to make a few fixes here and there. First, there might be books that don't have a color image. In this case we don't want to use Picasso. So, in the book class if the image URL is not empty we'll make use of Picasso, otherwise we'll just load the book open image that we have in our drawable folder. Next, let's deal with now empty data returning from the Google Books API. In the API util class, when we create a book we cannot be sure that all the data is there, so we'll use a turnary operator checking for null values, like we did with the subtitle. If any of the fields are null, we'll just use an empty string, otherwise the field itself. In the end we should check all the fields except the ID and title which are always there. We might also get an error from the authors, so let's put the line that gets the number of authors in a try catch block. If we get an error while retrieving the array, we'll just set the author number to zero. The last object we could be missing is the imageLinksJSON. Some books do not have any cover image and we'll solve this by initializing it to null, then only if the volumInfoJSON has an imageInfo we'll get the JSON object, otherwise it will just remain null. Let's also make sure that when we create the book, we apply the turnary operator to the image as well. Okay, let's try this out. We'll search for a book called Brave New World by Aldous Huxley which by the way, is a great book to read. And we can see that it's working. Let's try only by author. I'll search for well, I search for myself and indeed, we can find a book that I have written. It's in Italian so it's a very bad advert here. I also happen to know the ISBN of this book, so let's try it and indeed it works apparently because there is one last very important fix we need to implement. Let me show you a huge problem that we have here. Let's put our emulator in airplane mode so that we do not have any internet connect, then let's try to start our app. You might have guessed. Our app is miserably failing. I cannot stress enough how important it is that you always check external objects that may fail. A device internet connection should never be taken for granted. There are several methods to check if an internet connection is available on your device but for now we'll just fix a small bug that we have in our code. In the onPostExceute method of the book list activity, when we check if the result is null, we have to include the code that loads the result on the list only when the results are not null. Let's try this again and we can see that we tell our user that there was a problem loading data which is good enough for now. As a challenge you might want to tell the user when the internet connection is not available but what we'll do next is save the searches that our user did so that they persist even after our app is closed. Let's do that next.

Using SharedPreferences
To make things easier for our users, we want to save their five most recent advanced queries so that just by clicking a menu they will be able to retrieve the books data they're looking for. All of this will be done without any action by the user. Now, in order to do that, we need to find a way to save data. There are several ways to save data after your app is closed in Android. The most obvious and flexible is probably using a database but there are times when you only need to save simple data like user settings or passwords or like in our case a few strings with short information. Well, in those cases SharedPreferences is a great tool. It allows you to persist information and works with key value pairs. It works like this. First, you need to call the getSharedPreferences method from the context. Then, to write data, you need to get an editor object. All changes to your SharedPreferences will be done through an editor. From the editor you can call a method to add or edit data. In the example we are using the putString method but we also have putInt, putLong, putBoolean etc. Then you call the apply method in order to commit the changes. There's also a commit method that works similarly and returns a boolean. When you want to read data from the SharedPreferences you can just call a getter like getString passing the key you have used while writing. Pretty straightforward, right? Okay, let's see all this in action. To deal with everything related with SharedPreferences we'll create a new class called SpUtil. We'll try to write methods that are as generic as possible so that you can use this as a starting point for your next app if you need to persist data with SharedPreferences. Code reuse is always nice in your life as a developer. So, we do not want this class to be instantiated. We'll only create static methods here, so let's create a constructor like this. Next, let's create a constant for the preference name. This will be BooksPreferences. Let's create a method for the initialization of the SharedPreferences. We call this getPrefs. This will take the context as an argument. Here we'll just return the result of the getSharedPreferences method from the context, passing the name and the constant, Context. MODE_PRIVATE which means that only the application creating the SharedPreference can read and write the preference. Then we'll create a method to read the string from the preferences. We'll call this getPreferenceString. It will take the context and the key we want to retrieve. So, we'll call the getPrefs method, passing the context and then the getString method passing the key. The second parameter is the default value, in this case an empty string. We'll do exactly the same for an integer method. We'll call it getPreferenceInt and we'll call the getInt method instead of the getString and the default will be a zero instead of an empty string. Now, we need to create two more methods, one to write a string and the other to write an integer. Let's begin with a string. We'll call it setPreferenceString. It will take the context, a string containing the key and the string containing the value. Inside the method let's retrieve the editor object first. From it we'll call the putString method, passing key and value and then we'll commit the changes with the apply method. Let's do the same with setPreferenceInt method. We do a copy and paste here just changing the parameter and the putInt method instead of the putString. Right, now we can read and write data through SharedPreferences. But we need to call the methods we created. Remember, we want to save the latest user searches made from the advanced search activity.

Creating Menus Dynamically
There will never be more than five queries in the SharedPreferences at any given time. So, how do we decide which query to override when our user makes their sixth or seventh search? We'll use a first in, first out approach. The first query to enter the SharedPreferences will also be the first to be overwritten when the available space is filled. An image that helps me understand this concept is the one you can see on the slide. Let's say we have a pipe that only contains five balls. When we try to insert the sixth ball, the first one comes out and this keeps happening as long as new balls enter the pipe. We'll do exactly the same with our SharedPreferences. So, in our search activity, when the user clicks the search button we need to save the query in one of the five available positions but which one? Well, we need a way to keep track of the latest saved position and we need five slots for the query strings. Let's create a couple of constants in the SpUtil class to help us keep track of this. The first constant will be for the position and the second for the five queries. Let's get back to the search activity. We need a context here. So, let's add it there. And let's retrieve the position integer. The first time we won't have any position saved, so when we call this method we'll get the default value which is zero. And if we think about the future, we can imagine that a time will come when the user will reach the fifth position. In both cases we need to set the position to one. In all other cases we'll increment the position by one slot. Now that we know which position to update, let's create a string containing the key. It will be a concatenation of the query constant and the number of the position converted to a string. So, we'll have query one, query two, query three and so on. Then let's set the value which will contain the title, author, publisher and ISBN separated by a comma. So, let's call the setPreference string passing the context, the key and the value. Let's also update the position integer passing the same context, the position key and the position value. Great. If everything works correctly, we have now written to the SharedPreferences file. We have no way of knowing whether this is working or not but in order to test this, let's put a breakpoint here and then use our app to check the variables. So, let's debug our app. We search for Brave New World again. And now let's check a few values in our debug window and we can see that the position is one and the key is query one. Let's click the resume button and do another search. This time we'll look for Android Development. And we can see that the position has been updated to number two and the same happened for the query. Great. Now our last tab for this demo. We want to add the search queries to the menu in the book list activity. First we need to retrieve all the queries in the SharedPreferences. Let's create a method in the SpUtil class. It will return an array list of strings and we'll call it getQueryList. The only argument we need is the context. Inside the method we'll create a new array list of string and call it queryList. We know that we have five positions to check. So, let's create a for loop that checks our five positions. Because this result will appear on the menu let's also remove the commas and add a space as a separator instead. We don't want commas on our menu. Then, let's remove beginning and ending spaces from the string and that's it. We'll return the query list. Now the menu. First, we want the query items to appear as menu items and then we want to listen to the click on the item. In the onCreateOptionsMenu method let's retrieve the array list of items. Let's count them because their number might be smaller than five, then let's create a menu item. We'll call it recent menu. And then let's create a for loop that adds the menus. The second parameter is the idea of the menu, in this case I and the fourth is the text of the menu. Now let's respond to the click. We'll use the default case here. As we said, the idea of the menu we can retrieve it and add one since we began with query one and not zero in our SpUtil. Let's create a string for the preferenceName which is a concatenation of the query constant and the position. Then let's get the string that contains the query based on the position. The reason why we cannot just use the string of the menu is that we removed the commas and we need them as a separator. Okay, I guess we may do this in several different ways but let's create two array of strings. One will be populated by the preference item itself, let's call it prefParams and the other one is queryParams and we'll use this to actually build the URL. This double declaration is necessary because the split method will return less than four elements if the query does not contain an ISBN. Okay, let's cycle the elements and finally build the URL. Here we can use a turnary operator so that if any of the items in the four positions is null we'll just pass an empty string, otherwise we'll read from the array. We'll repeat this for all the elements. Good, let's try this out. First, let's check whether clicking on the Brave New World menu item will give us the results we expect. Good. Then let's make a few more searches to see if the searches are added to the menu and then see what happens after the fifth query. So, let's look for iOS just to see how the competition is doing. And then Windows Development. Competition again and then back to Android Studio. And to finish this beautifully let's also look for Web Development. And we can see that Brave New World has disappeared and we still have five positions in our recent searches. Well done.

Recap
And with that last piece of code we can say that our app is complete and with it we have also completed the last module of this course. We have seen how and why SharedPreferences can be a great tool in your Android development and how to create menus dynamically. We have also seen a few objects like shapes and StringBuilders but probably more important by fixing a realistic app we have seen how important it is to always check the behavior of your software in different conditions, like when your internet connection is missing, so now where should you go from there? As a Pluralsight subscriber you have a lot of content to choose from so my first advice would be to have a look at the great courses that are out there. Try them and play with them but maybe even more important, I believe there's only one way to truly master any programming language and that is building your own apps. If you really want to make the most of this course, have a look at the great many free web APIs that are out there. With what you learned in this course you could build a great weather app or if you like movies or music you could go with them. If you google open data with the name of your country you will also find plenty of information and statistics about the place you live or maybe you already know what you want to build and it's better than anything I could think of, so by all means go for it. The important thing is do it and with that we have come to the end of this course. Thank you for following me up to the end. Good luck and keep coding.

Course author
Author: Simone Alessandria	
Simone Alessandria
Simone Alessandria wrote his first program when he was 12: it was a text based fantasy game for Commodore 64. A few years later, he is now a trainer (MCP), author, speaker, passionate software...

Course info
Level
Beginner
Rating
4.8 stars with 21 raters(21)
My rating
null stars

Duration
2h 19m
Released
31 Jul 2017
Share course